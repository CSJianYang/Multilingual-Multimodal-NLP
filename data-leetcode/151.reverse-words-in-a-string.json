[
    {
        "title": "N-Queens",
        "question_content": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n&nbsp;\nExample 1:\n\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n\nExample 2:\n\nInput: n = 1\nOutput: [[\"Q\"]]\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 9",
        "solutions": [
            {
                "id": 19808,
                "title": "accepted-4ms-c-solution-use-backtracking-and-bitmask-easy-understand",
                "content": "In this problem, we can go row by row, and in each position, we need to check if the `column`, the `45\\xb0 diagonal` and the `135\\xb0 diagonal` had a queen before.\\n\\n**Solution A:** Directly check the validity of each position, *12ms*:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            solveNQueens(res, nQueens, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (isValid(nQueens, row, col, n)) {\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                }\\n        }\\n        bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {\\n            //check if the column had a queen before.\\n            for (int i = 0; i != row; ++i)\\n                if (nQueens[i][col] == 'Q')\\n                    return false;\\n            //check if the 45\\xb0 diagonal had a queen before.\\n            for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)\\n                if (nQueens[i][j] == 'Q')\\n                    return false;\\n            //check if the 135\\xb0 diagonal had a queen before.\\n            for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)\\n                if (nQueens[i][j] == 'Q')\\n                    return false;\\n            return true;\\n        }\\n    };\\n\\n**Solution B:** Use flag vectors as bitmask, *4ms*:\\n\\nThe number of columns is `n`,  the number of 45\\xb0 diagonals is `2 * n - 1`,  the number of 135\\xb0 diagonals is also `2 * n - 1`. When reach `[row, col]`, the column No. is `col`, the 45\\xb0 diagonal No. is `row + col` and the 135\\xb0 diagonal No. is `n - 1 + col - row`. We can use three arrays to indicate if the column or the diagonal had a queen before, if not, we can put a queen in this position and continue. \\n\\n**NOTE:** Please don't use `vector<bool> flag` to replace `vector<int> flag` in the following C++ code. In fact, `vector<bool>` is not a STL container. You should avoid to use it. You can also get the knowledge from [here](http://stackoverflow.com/questions/17794569/why-is-vectorbool-not-a-stl-container) and [here](http://stackoverflow.com/questions/670308/alternative-to-vectorbool).\\n\\n    /**    | | |                / / /             \\\\ \\\\ \\\\\\n      *    O O O               O O O               O O O\\n      *    | | |              / / / /             \\\\ \\\\ \\\\ \\\\\\n      *    O O O               O O O               O O O\\n      *    | | |              / / / /             \\\\ \\\\ \\\\ \\\\ \\n      *    O O O               O O O               O O O\\n      *    | | |              / / /                 \\\\ \\\\ \\\\\\n      *   3 columns        5 45\\xb0 diagonals     5 135\\xb0 diagonals    (when n is 3)\\n      */\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            std::vector<int> flag_col(n, 1), flag_45(2 * n - 1, 1), flag_135(2 * n - 1, 1);\\n            solveNQueens(res, nQueens, flag_col, flag_45, flag_135, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, std::vector<int> &flag_col, std::vector<int> &flag_45, std::vector<int> &flag_135, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (flag_col[col] && flag_45[row + col] && flag_135[n - 1 + col - row]) {\\n                    flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 0;\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, flag_col, flag_45, flag_135, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                    flag_col[col] = flag_45[row + col] = flag_135[n - 1 + col - row] = 1;\\n                }\\n        }\\n    };\\n\\nBut we actually do not need to use three arrays, we just need one. Now, when reach `[row, col]`, the subscript of column is `col`, the subscript of 45\\xb0 diagonal is `n + row + col` and the subscript of 135\\xb0 diagonal  is `n + 2 * n - 1 + n - 1 + col - row`.\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            /*\\n            flag[0] to flag[n - 1] to indicate if the column had a queen before.\\n            flag[n] to flag[3 * n - 2] to indicate if the 45\\xb0 diagonal had a queen before.\\n            flag[3 * n - 1] to flag[5 * n - 3] to indicate if the 135\\xb0 diagonal had a queen before.\\n            */\\n            std::vector<int> flag(5 * n - 2, 1);\\n            solveNQueens(res, nQueens, flag, 0, n);\\n            return res;\\n        }\\n    private:\\n        void solveNQueens(std::vector<std::vector<std::string> > &res, std::vector<std::string> &nQueens, std::vector<int> &flag, int row, int &n) {\\n            if (row == n) {\\n                res.push_back(nQueens);\\n                return;\\n            }\\n            for (int col = 0; col != n; ++col)\\n                if (flag[col] && flag[n + row + col] && flag[4 * n - 2 + col - row]) {\\n                    flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0;\\n                    nQueens[row][col] = 'Q';\\n                    solveNQueens(res, nQueens, flag, row + 1, n);\\n                    nQueens[row][col] = '.';\\n                    flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1;\\n                }\\n        }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<std::string> > solveNQueens(int n) {\\n            std::vector<std::vector<std::string> > res;\\n            std::vector<std::string> nQueens(n, std::string(n, '.'));\\n            solveNQueens(res, nQueens, 0, n);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 19810,
                "title": "fast-short-and-easy-to-understand-python-solution-11-lines-76ms",
                "content": "ideas: <br>\\nUse the `DFS` helper function to find solutions recursively. A solution will be found when the length of    `queens` is equal to `n` ( `queens` is a list of the indices of the queens).<br><br>\\nIn this problem, whenever a location `(x, y`) is occupied, any other locations `(p, q )` where `p + q == x + y` or `p - q == x - y` would be  invalid. We can use this information to keep track of the indicators (`xy_dif` and  `xy_sum` ) of the invalid positions and then call DFS recursively with valid positions only. <br><br>\\n\\nAt the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format.\\n\\n\\n    def solveNQueens(self, n):\\n        def DFS(queens, xy_dif, xy_sum):\\n            p = len(queens)\\n            if p==n:\\n                result.append(queens)\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \\n                    DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \\n        result = []\\n        DFS([],[],[])\\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]",
                "solutionTags": [
                    "Python"
                ],
                "code": "ideas: <br>\\nUse the `DFS` helper function to find solutions recursively. A solution will be found when the length of    `queens` is equal to `n` ( `queens` is a list of the indices of the queens).<br><br>\\nIn this problem, whenever a location `(x, y`) is occupied, any other locations `(p, q )` where `p + q == x + y` or `p - q == x - y` would be  invalid. We can use this information to keep track of the indicators (`xy_dif` and  `xy_sum` ) of the invalid positions and then call DFS recursively with valid positions only. <br><br>\\n\\nAt the end, we convert the result (a list of lists; each sublist is the indices of the queens) into the desire format.\\n\\n\\n    def solveNQueens(self, n):\\n        def DFS(queens, xy_dif, xy_sum):\\n            p = len(queens)\\n            if p==n:\\n                result.append(queens)\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \\n                    DFS(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \\n        result = []\\n        DFS([],[],[])\\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]",
                "codeTag": "Python3"
            },
            {
                "id": 19805,
                "title": "my-easy-understanding-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            char[][] board = new char[n][n];\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < n; j++)\\n                    board[i][j] = '.';\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(board, 0, res);\\n            return res;\\n        }\\n        \\n        private void dfs(char[][] board, int colIndex, List<List<String>> res) {\\n            if(colIndex == board.length) {\\n                res.add(construct(board));\\n                return;\\n            }\\n            \\n            for(int i = 0; i < board.length; i++) {\\n                if(validate(board, i, colIndex)) {\\n                    board[i][colIndex] = 'Q';\\n                    dfs(board, colIndex + 1, res);\\n                    board[i][colIndex] = '.';\\n                }\\n            }\\n        }\\n        \\n        private boolean validate(char[][] board, int x, int y) {\\n            for(int i = 0; i < board.length; i++) {\\n                for(int j = 0; j < y; j++) {\\n                    if(board[i][j] == 'Q' && (x + j == y + i || x + y == i + j || x == i))\\n                        return false;\\n                }\\n            }\\n            \\n            return true;\\n        }\\n        \\n        private List<String> construct(char[][] board) {\\n            List<String> res = new LinkedList<String>();\\n            for(int i = 0; i < board.length; i++) {\\n                String s = new String(board[i]);\\n                res.add(s);\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            char[][] board = new char[n][n];\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < n; j++)\\n                    board[i][j] = '.';\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(board, 0, res);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 810358,
                "title": "c-4ms-heavily-commented-clean-solution-fast-easy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ret;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            ret.push_back(board);\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n\\t\\t// return empty if n <= 0\\n        if(n <= 0) return {{}};\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ret;\\n    bool is_valid(vector<string> &board, int row, int col){\\n        // check col\\n        for(int i=row;i>=0;--i)\\n            if(board[i][col] == \\'Q\\') return false;\\n        // check left diagonal\\n        for(int i=row,j=col;i>=0&&j>=0;--i,--j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        //check right diagonal\\n        for(int i=row,j=col;i>=0&&j<board.size();--i,++j)\\n            if(board[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n    void dfs(vector<string> &board, int row){\\n        // exit condition\\n        if(row == board.size()){\\n            ret.push_back(board);\\n            return;\\n        }\\n        // iterate every possible position\\n        for(int i=0;i<board.size();++i){\\n            if(is_valid(board,row,i)){\\n                // make decision\\n                board[row][i] = \\'Q\\';\\n                // next iteration\\n                dfs(board,row+1);\\n                // back-tracking\\n                board[row][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n\\t\\t// return empty if n <= 0\\n        if(n <= 0) return {{}};\\n        vector<string> board(n,string(n,\\'.\\'));\\n        dfs(board,0);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107948,
                "title": "c-easy-explanation-w-backtracking",
                "content": "**Please upvote the post if you like it :)**\\n\\nSo, basically  we have been given `n` queens and we need to place those **queens** in the `board` such that  no **two** queens **attack** each other right?\\n\\nCool, so we know that the number of ways to place `N` **queens** on a `NxN` **board** can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... which eventually leads to an overall **time** **complexity** of `O(N^2N)`, which is extremely **high** and we can\\'t afford that.\\n\\nBut, simultaneously we also know that we don\\'t actually need to traverse all the `O(N^2)` options each time. \\nSo, we can place one **queen** in each **row** and then move to the next row.\\n\\nSo for each row, we will place one queen (if possible within the contraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the `isSafe` method to ensure that the queen is safe to `place` at **(i, j)**. Once, all `N` **queens** have been placed, we have got our first solution.\\n\\nFinally, to get all the other possible solutions, we will keep on removing the previously placed queen and try if its possible to place it at some other location, i.e, where we need to **backtrack**. This will give us all the possible combinations to place `N Queens` on the board as per the given constraints.\\n\\n****\\nVisualization if needed from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif)- \\n\\n\\n![image](https://assets.leetcode.com/users/images/6388c419-0494-4d56-9bc4-a710a3699862_1654316356.7472951.gif)\\n\\n\\n****\\n**Backtracking Approach (C++) :**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string> > sols; // 2D vector of strings to store the solutions\\n    vector<vector<string>> solveNQueens(int n) {    \\n\\t    vector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\t    solve(board, 0); // calling the recursive function\\n\\t    return sols; \\n    }\\n    bool isSafe(vector<string>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i < n; i++) {\\n\\t\\t\\t// checking if there is a queen in the same column\\n\\t\\t    if(board[i][col] == \\'Q\\') return false; \\n\\t\\t    // checking if there is a queen in the same diagonal (left to right)\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\t    // No need to traverse more since the lower rows below current row attribute will always be safe.\\n\\t\\t\\t/* if(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false; */\\n\\t    }\\n\\t    return true;\\n    }\\n    // Recursive Function (solve) - It basically tries all possible placement of queen for the current row & recurses for it\\'s next row\\n    void solve(vector<string>& board, int row) {\\n\\t// Base condition. \\n    // We reached the last row, so we have a solution so we add it to the solution vector\\n\\t    if(row == size(board)) { \\n\\t\\t    sols.push_back(board);\\n\\t\\t    return;\\n    \\t}            \\n\\t    // Try placing a queen on each column for a given row. \\n        // Explore next row by placing Q at each valid column for the current row\\n\\t    for(int col = 0; col < size(board); col++){\\n\\t\\t    if(isSafe(board, row, col)) {\\n\\t\\t\\t    board[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\t    solve(board, row + 1);    // Exploring next row\\n\\t\\t\\t    board[row][col] = \\'.\\';    // Backtracking to get all possible solutions\\n\\t\\t    }\\n        }\\n    }\\n};\\n```\\n\\n****\\n**Time Complexity : O(N!)**, Since we have N choices in the first row, then N-1 choices in the second row and so on so the overall complexity become **O(N!)** \\n**Space Complexity: O(N*N)**, Just the `board` and recursive `stack` space",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string> > sols; // 2D vector of strings to store the solutions\\n    vector<vector<string>> solveNQueens(int n) {    \\n\\t    vector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\t    solve(board, 0); // calling the recursive function\\n\\t    return sols; \\n    }\\n    bool isSafe(vector<string>& board, int row, int col) {\\n\\t    int n = size(board);\\n\\t    for(int i = 0; i < n; i++) {\\n\\t\\t\\t// checking if there is a queen in the same column\\n\\t\\t    if(board[i][col] == \\'Q\\') return false; \\n\\t\\t    // checking if there is a queen in the same diagonal (left to right)\\n\\t\\t    if(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\t    if(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\t    // No need to traverse more since the lower rows below current row attribute will always be safe.\\n\\t\\t\\t/* if(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false; */\\n\\t    }\\n\\t    return true;\\n    }\\n    // Recursive Function (solve) - It basically tries all possible placement of queen for the current row & recurses for it\\'s next row\\n    void solve(vector<string>& board, int row) {\\n\\t// Base condition. \\n    // We reached the last row, so we have a solution so we add it to the solution vector\\n\\t    if(row == size(board)) { \\n\\t\\t    sols.push_back(board);\\n\\t\\t    return;\\n    \\t}            \\n\\t    // Try placing a queen on each column for a given row. \\n        // Explore next row by placing Q at each valid column for the current row\\n\\t    for(int col = 0; col < size(board); col++){\\n\\t\\t    if(isSafe(board, row, col)) {\\n\\t\\t\\t    board[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\t    solve(board, row + 1);    // Exploring next row\\n\\t\\t\\t    board[row][col] = \\'.\\';    // Backtracking to get all possible solutions\\n\\t\\t    }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19971,
                "title": "python-recursive-dfs-solution-with-comments",
                "content": "   \\n   \\n    def solveNQueens(self, n):\\n        res = []\\n        self.dfs([-1]*n, 0, [], res)\\n        return res\\n     \\n    # nums is a one-dimension array, like [1, 3, 0, 2] means\\n    # first queen is placed in column 1, second queen is placed\\n    # in column 3, etc.\\n    def dfs(self, nums, index, path, res):\\n        if index == len(nums):\\n            res.append(path)\\n            return  # backtracking\\n        for i in xrange(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):  # pruning\\n                tmp = \".\"*len(nums)\\n                self.dfs(nums, index+1, path+[tmp[:i]+\"Q\"+tmp[i+1:]], res)\\n    \\n    # check whether nth queen can be placed in that column\\n    def valid(self, nums, n):\\n        for i in xrange(n):\\n            if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]:\\n                return False\\n        return True",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "   \\n   \\n    def solveNQueens(self, n):\\n        res = []\\n        self.dfs([-1]*n, 0, [], res)\\n        return res\\n     \\n    # nums is a one-dimension array, like [1, 3, 0, 2] means\\n    # first queen is placed in column 1, second queen is placed\\n    # in column 3, etc.\\n    def dfs(self, nums, index, path, res):\\n        if index == len(nums):\\n            res.append(path)\\n            return  # backtracking\\n        for i in xrange(len(nums)):\\n            nums[index] = i\\n            if self.valid(nums, index):  # pruning\\n                tmp = \".\"*len(nums)\\n                self.dfs(nums, index+1, path+[tmp[:i]+\"Q\"+tmp[i+1:]], res)\\n    \\n    # check whether nth queen can be placed in that column\\n    def valid(self, nums, n):\\n        for i in xrange(n):\\n            if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]:\\n                return False\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 19804,
                "title": "share-my-java-dfs-solution-very-easy-to-understand",
                "content": "    public class Solution {\\n        private Set<Integer> col = new HashSet<Integer>();\\n        private Set<Integer> diag1 = new HashSet<Integer>();\\n        private Set<Integer> diag2 = new HashSet<Integer>();\\n        \\n        public List<List<String>> solveNQueens(int n) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(res,new ArrayList<String>(), 0, n);\\n            return res;\\n        }\\n        private void dfs(List<List<String>> res, List<String> list, int row, int n){\\n            if (row == n){\\n                res.add(new ArrayList<String>(list));\\n                return;\\n            }\\n            for (int i = 0; i < n; i++){\\n                if (col.contains(i) || diag1.contains(row + i) || diag2.contains(row - i)) continue;\\n                \\n                char[] charArray = new char[n];\\n                Arrays.fill(charArray, '.');\\n                charArray[i] = 'Q';\\n                String rowString = new String(charArray);\\n                \\n                list.add(rowString);\\n                col.add(i);\\n                diag1.add(row + i);\\n                diag2.add(row - i);\\n                \\n                dfs(res, list, row + 1, n);\\n                \\n                list.remove(list.size() - 1);\\n                col.remove(i);\\n                diag1.remove(row + i);\\n                diag2.remove(row - i);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        private Set<Integer> col = new HashSet<Integer>();\\n        private Set<Integer> diag1 = new HashSet<Integer>();\\n        private Set<Integer> diag2 = new HashSet<Integer>();\\n        \\n        public List<List<String>> solveNQueens(int n) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            dfs(res,new ArrayList<String>(), 0, n);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2107776,
                "title": "explained-with-diagrams-backtracking-and-bit-manipulation",
                "content": "### Logic:\\nThe best way to generate all valid Queen positions is through backtracking. \\nFirst, we need to understand how a Queen moves and what constitutes a valid position. Queen\\'s can move in literally any straight-lined direction. \\n\\n![image](https://assets.leetcode.com/users/images/b51628d9-0917-45db-a2b7-823ece81a8c1_1654307228.4397633.png)\\n\\n\\nIt\\'s possibe to place a Queen down if and only if:\\n* There exists no Queen on the current row.\\n* There exists no Queen on the current column.\\n* There exists no Queen on the current diagonal.\\n* There exists no Queen on the current anti-diagonal.\\n\\n> Backtracking: Try a promising Queen position, see how it goes. If it fails, undo that Queen and try again somewhere else.\\n\\n![image](https://assets.leetcode.com/users/images/ca380113-d402-4c1e-a21d-a632196a39fd_1654307245.1164281.png)\\n\\n\\nHopefull it\\'s now clear that we need some way to keep track of Queens on previous rows, columns and diagonals. We can take care of rows automatically by incrementing each queen placement by row. In other words, after each successful Queen placement, we move to the next row (since no two Queens can share the same row).\\nWe can keep track of previous columns just by their column indexes. What about the diagonals? Well here\\'s an interesting observation:\\n\\n![image](https://assets.leetcode.com/users/images/e88b8d70-250d-48bd-bf75-ce265e69b7d4_1654307264.8783712.png)\\n\\n\\n(the \"+N\" is to offset negative values. You will see why we do this in the next section). Now we have everything we need to keep track of previous Queens and start thinking about our algorithm! But just one more thing; let\\'s keep track of \"used\" columns and diagonals using bit masks.\\n\\n___\\n### Why Integer Bit Masks?\\nWe prefer integer bitmasks in this question for 2 main reasons:\\n1. Sets in Java are a slow datastructure. So keeping track of visited columns and diagonals using integers is much quicker through bit manipulation!\\n2. It\\'s slightly more space efficient since we\\'re only storing three integers instead of arrays or other datastructures. \\n\\n### Bit Manipulation Tricks\\n1. **Check the ith bit:** `x & (1 << i)`, where `1 << i` is shifting 1 to the left i number of times.\\n\\tFor example, if we want to check if a Queen exists at column 5, we can check if (cols & (1 << 5) != 0). Basically, if we haven\\'t seen a Queen at this column before, then the bitwise AND operation at that specific bit will be 0. Otherwise, it will be a non-zero value.\\n2. **Set the ith bit:** `x |= (1 << i)`. This performs a bitwise OR operation on the ith bit. This will always set the ith bit to 1. For example, if the ith bit in `cols` is currently 1, then 1 | 1 = 1. If it\\'s set to 0, then 0 | 0 is still = 1.\\n3. **Flip the ith bit:** `x ^= (1 << i)` To reverse the previous action, we use the inverse logic of an OR; a bitwise XOR (exclusive-OR).  The basic idea of XOR is that if two bits are the same (0,0) and (1,1), you will get 0. However if the two bits are different (1,0) or (0,1), you get 1. This is the exact opposite of OR, hence the name. \\n___\\n### Algorithm:\\nAwesome! Now we have everything we need. Here\\'s how the backtracking algorithm will work:\\n1. Check if we\\'ve reached the end:\\n\\t* If `row == N`, we\\'ve filled in all our rows successfully which implies the current board state is a valid combination. Let\\'s add it to our output list.\\n2. Loop through each column in the current row.\\n\\t3. If we can\\'t add a Queen at this position, skip this `col` value.\\n\\t4. If we can, add a Queen at this position and adjust our bitmasks respectively.\\n\\t5. Continue to the next row (call backtrack for `row+1`).\\n\\t6. Undo our changes so we can try other `col` values.\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n```java\\nclass Solution {\\n    private List<List<String>> res;\\n    private int N;\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        res = new ArrayList<>();\\n        N = n;\\n        char[][] emptyBoard = new char[N][N];\\n        for (char[] row: emptyBoard) Arrays.fill(row, \\'.\\');\\n        \\n        backtrack(emptyBoard, 0, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(char[][] board, int row, int cols, int diags, int antiDiags) {\\n        // if we\\'ve successfuly placed a Queen at all rows, we have a valid board state\\n        if (row == N) {\\n            res.add(toBoard(board));\\n            return;\\n        }\\n        \\n        for (int col=0; col<N; col++) {\\n            int currDiag = row-col+N;\\n            int currAntiDiag = row+col;\\n            \\n            // check if the current Queen placement is valid\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << currDiag)) != 0 || (antiDiags & (1 << currAntiDiag)) != 0) continue;\\n            \\n            // if so, add changes\\n            board[row][col] = \\'Q\\';\\n            cols |= (1 << col);\\n            diags |= (1 << currDiag);\\n            antiDiags |= (1 << currAntiDiag);\\n            \\n            // continue to the next row\\n            backtrack(board, row + 1, cols, diags, antiDiags);\\n            \\n            // undo changes and continue\\n            board[row][col] = \\'.\\';\\n            cols ^= (1 << col);\\n            diags ^= (1 << currDiag);\\n            antiDiags ^= (1 << currAntiDiag);\\n        }\\n    }\\n    \\n    private List<String> toBoard(char[][] board) {\\n        List<String> newBoard = new ArrayList<>();\\n        for (char[] row: board) newBoard.add(new String(row));\\n        return newBoard;\\n    }\\n}\\n```\\n**Time Complexity:** `O(N!)` since we look for every valid board state.\\n**Space Complexity:** `O(N^2)` to build our board.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```java\\nclass Solution {\\n    private List<List<String>> res;\\n    private int N;\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        res = new ArrayList<>();\\n        N = n;\\n        char[][] emptyBoard = new char[N][N];\\n        for (char[] row: emptyBoard) Arrays.fill(row, \\'.\\');\\n        \\n        backtrack(emptyBoard, 0, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(char[][] board, int row, int cols, int diags, int antiDiags) {\\n        // if we\\'ve successfuly placed a Queen at all rows, we have a valid board state\\n        if (row == N) {\\n            res.add(toBoard(board));\\n            return;\\n        }\\n        \\n        for (int col=0; col<N; col++) {\\n            int currDiag = row-col+N;\\n            int currAntiDiag = row+col;\\n            \\n            // check if the current Queen placement is valid\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << currDiag)) != 0 || (antiDiags & (1 << currAntiDiag)) != 0) continue;\\n            \\n            // if so, add changes\\n            board[row][col] = \\'Q\\';\\n            cols |= (1 << col);\\n            diags |= (1 << currDiag);\\n            antiDiags |= (1 << currAntiDiag);\\n            \\n            // continue to the next row\\n            backtrack(board, row + 1, cols, diags, antiDiags);\\n            \\n            // undo changes and continue\\n            board[row][col] = \\'.\\';\\n            cols ^= (1 << col);\\n            diags ^= (1 << currDiag);\\n            antiDiags ^= (1 << currAntiDiag);\\n        }\\n    }\\n    \\n    private List<String> toBoard(char[][] board) {\\n        List<String> newBoard = new ArrayList<>();\\n        for (char[] row: board) newBoard.add(new String(row));\\n        return newBoard;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243428,
                "title": "python-solution",
                "content": "We use the backtracking algorithm. Initialize two empty lists `res` and `board`, with the former recording the solutions of the problem we currently have, and the latter the current state of the board during backtracking. We use three sets `cols`, `diag` and `off_diag` to keep track of the columns, diagonals, and off-diagonals that have been occupied in `board`. We define a recursive `backtrack` function which enumerates all possible configurations of `board`, and populates `res` if `board` is valid. More specifically, `backtrack(i)` enumerates all valid positions that the queen can be put in the `i`th row. For each valid position, we append the string representing the `i`th row to `board`, and recursively call `backtrack(i+1)`, until `i == n`, in which case we know `board` represents a valid configuration of the `n` queens, and we append a shallow copy of `board` to `res`.\\n\\nTime complexity: `O(n!)`, space complexity: `O(n!)`. \\n\\n```\\nclass Solution:\\n    def solveNQueens(self, n: \\'int\\') -> \\'List[List[str]]\\':\\n        def backtrack(i):\\n            if i == n:\\n                res.append(list(board))\\n            for j in range(n):\\n                if j not in cols and j-i not in diag and j+i not in off_diag:\\n                    cols.add(j)\\n                    diag.add(j-i)\\n                    off_diag.add(j+i)\\n                    board.append(\".\"*(j)+\"Q\"+\".\"*(n-j-1))\\n                    backtrack(i+1)\\n                    board.pop()\\n                    off_diag.remove(j+i)\\n                    diag.remove(j-i)\\n                    cols.remove(j)\\n        res = []\\n        board = []\\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        backtrack(0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: \\'int\\') -> \\'List[List[str]]\\':\\n        def backtrack(i):\\n            if i == n:\\n                res.append(list(board))\\n            for j in range(n):\\n                if j not in cols and j-i not in diag and j+i not in off_diag:\\n                    cols.add(j)\\n                    diag.add(j-i)\\n                    off_diag.add(j+i)\\n                    board.append(\".\"*(j)+\"Q\"+\".\"*(n-j-1))\\n                    backtrack(i+1)\\n                    board.pop()\\n                    off_diag.remove(j+i)\\n                    diag.remove(j-i)\\n                    cols.remove(j)\\n        res = []\\n        board = []\\n        cols = set()\\n        diag = set()\\n        off_diag = set()\\n        backtrack(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19828,
                "title": "comparably-concise-java-code",
                "content": "Hi guys!\\n\\nI didn't invent a wheel here. We just remember the busy columns and diagonals and recursively try to put the queen into the next row. But I think the code below is short enough to be reproduced in the interview.\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        \\n        private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, \\n                            String[] board, List<String[]> res) {\\n            if (r == board.length) res.add(board.clone());\\n            else {\\n                for (int c = 0; c < board.length; c++) {\\n                    int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1;\\n                    if (!cols[c] && !d1[id1] && !d2[id2]) {\\n                        char[] row = new char[board.length];\\n                        Arrays.fill(row, '.'); row[c] = 'Q';\\n                        board[r] = new String(row);\\n                        cols[c] = true; d1[id1] = true; d2[id2] = true;\\n                        helper(r+1, cols, d1, d2, board, res);\\n                        cols[c] = false; d1[id1] = false; d2[id2] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        public List<String[]> solveNQueens(int n) {\\n            List<String[]> res = new ArrayList<>();\\n            helper(0, new boolean[n], new boolean[2*n], new boolean[2*n], \\n                new String[n], res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        private void helper(int r, boolean[] cols, boolean[] d1, boolean[] d2, \\n                            String[] board, List<String[]> res) {\\n            if (r == board.length) res.add(board.clone());\\n            else {\\n                for (int c = 0; c < board.length; c++) {\\n                    int id1 = r - c + board.length, id2 = 2*board.length - r - c - 1;\\n                    if (!cols[c] && !d1[id1] && !d2[id2]) {\\n                        char[] row = new char[board.length];\\n                        Arrays.fill(row, '.'); row[c] = 'Q';\\n                        board[r] = new String(row);\\n                        cols[c] = true; d1[id1] = true; d2[id2] = true;\\n                        helper(r+1, cols, d1, d2, board, res);\\n                        cols[c] = false; d1[id1] = false; d2[id2] = false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2107719,
                "title": "python-solution-with-explanation",
                "content": "The approach that we will be using is backtracking. I have added comments in the code to help understand better.\\n\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        state= [[\".\"] * n for _ in range(n)] # start with empty board\\n        res=[]\\n        \\n        # for tracking the columns which already have a queen\\n        visited_cols=set()\\n        \\n        # This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        \\n        visited_diagonals=set()\\n        \\n        # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        def backtrack(r):\\n            if r==n:                \\n                res.append([\"\".join(row) for row in state])\\n                return\\n            \\n            for c in range(n):\\n                diff=r-c\\n                _sum=r+c\\n                \\n                # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not (c in visited_cols or diff in visited_diagonals or _sum in visited_antidiagonals):                    \\n                    visited_cols.add(c)\\n                    visited_diagonals.add(diff)\\n                    visited_antidiagonals.add(_sum)\\n                    state[r][c]=\\'Q\\' # place the queen\\n                    backtrack(r+1) \\n\\n                    # reset the path\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(diff)\\n                    visited_antidiagonals.remove(_sum)\\n                    state[r][c]=\\'.\\'                                \\n\\n        backtrack(0)\\n        return res\\n```\\n\\n**Time - O(N!)** - In the solution tree, number of valid exploration paths from a node reduces by 2 at each level. In first level, we have N columns options to place the queen i.e N paths from the root node. In the next level, we have max N-2 options available because we can\\'t place the queen in same column and same diagonal as previous queen. In the next level, it will be N-4 because of two columns and two diagonals occupied by previous two queens. This will continue and give us a `O(N!)`Time. (Let me know if you think otherwise :) )\\n\\n**Space - O(N^2)** - recursive call stack to explore all possible solutions\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        state= [[\".\"] * n for _ in range(n)] # start with empty board\\n        res=[]\\n        \\n        # for tracking the columns which already have a queen\\n        visited_cols=set()\\n        \\n        # This will hold the difference of row and col\\n        # This is required to identify diagonals\\n        # specifically for diagonals with increasing row and increasing col pattern\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,0) and (8,8) are in the same diagonal\\n        # as both have same difference which is `0`\\n        \\n        visited_diagonals=set()\\n        \\n        # This will hold the sum of row and col\\n        # This is required to identify antidiagonals.\\n        # specifically for diagonals with increasing row and decreasing col pattern\\n        # the squares in same diagonal won\\'t have the same difference.\\n        # example: square (1,0) = 1-0 = 1\\n        # squares in same diagonals will have same difference\\n        # example: squares (0,7) and (1,6) are in the same diagonal\\n        # as both have same sum which is `7`\\n        visited_antidiagonals=set()\\n        \\n        def backtrack(r):\\n            if r==n:                \\n                res.append([\"\".join(row) for row in state])\\n                return\\n            \\n            for c in range(n):\\n                diff=r-c\\n                _sum=r+c\\n                \\n                # If the current square doesn\\'t have another queen in same column and diagonal.\\n                if not (c in visited_cols or diff in visited_diagonals or _sum in visited_antidiagonals):                    \\n                    visited_cols.add(c)\\n                    visited_diagonals.add(diff)\\n                    visited_antidiagonals.add(_sum)\\n                    state[r][c]=\\'Q\\' # place the queen\\n                    backtrack(r+1) \\n\\n                    # reset the path\\n                    visited_cols.remove(c)\\n                    visited_diagonals.remove(diff)\\n                    visited_antidiagonals.remove(_sum)\\n                    state[r][c]=\\'.\\'                                \\n\\n        backtrack(0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19932,
                "title": "clean-back-tracking-java-solution-with-simple-explaination",
                "content": "I use three boolean[] array to keep tracking of the position the Queen take in the helper method. \\n\\n1. boolean[] cols is for check if the certain column is taken. \\n2. I use two boolean[2*n] array to keep tracking of two diagonals.\\n3. for the diagonal in the \\\\ direction (from left up corner to right down corner) the col - row will always be same e.g. (0,1), (1,2), (2,3) are on the same diagonal, the range of col - row can be (0-(n-1)) ~ ((n-1)-0), to make sure we can store the value in one array, we will add n to this, it will become to keep tracking of (col - row + n).\\n4. for the diagonal in the / direction (from right up corner to left down corner) the col + row will always be same e.g. (0,4), (1,3), (2,2), (3,1), (4,0) are on the same diagonal, the range of row + col can be 0 ~ (2*n-2)\\n\\nback tracking logic should be easy to understand.\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        helper(result, new ArrayList<String>(), 0, new boolean[n], new boolean[2*n], new boolean[2*n], n);\\n        return result;\\n    }\\n    \\n    private void helper(List<List<String>> result, List<String> board, int row, boolean[] cols, boolean[] d1, boolean[] d2, int n){\\n        if (row == n) {\\n            result.add(new ArrayList<String>(board));\\n        }\\n        for (int col=0; col<n; col++){\\n            int id1 = col - row + n;\\n            int id2 = col + row;\\n            if (!cols[col] && !d1[id1] && !d2[id2]){\\n                char[] r = new char[n];\\n                Arrays.fill(r, '.');\\n                r[col] = 'Q';\\n                board.add(new String(r));\\n                cols[col] = true;\\n                d1[id1] = true;\\n                d2[id2] = true;\\n                helper(result, board, row+1, cols, d1, d2, n);\\n                board.remove(board.size()-1);\\n                cols[col] = false;\\n                d1[id1] = false;\\n                d2[id2] = false;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I use three boolean[] array to keep tracking of the position the Queen take in the helper method. \\n\\n1. boolean[] cols is for check if the certain column is taken. \\n2. I use two boolean[2*n] array to keep tracking of two diagonals.\\n3. for the diagonal in the \\\\ direction (from left up corner to right down corner) the col - row will always be same e.g. (0,1), (1,2), (2,3) are on the same diagonal, the range of col - row can be (0-(n-1)) ~ ((n-1)-0), to make sure we can store the value in one array, we will add n to this, it will become to keep tracking of (col - row + n).\\n4. for the diagonal in the / direction (from right up corner to left down corner) the col + row will always be same e.g. (0,4), (1,3), (2,2), (3,1), (4,0) are on the same diagonal, the range of row + col can be 0 ~ (2*n-2)\\n\\nback tracking logic should be easy to understand.\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        helper(result, new ArrayList<String>(), 0, new boolean[n], new boolean[2*n], new boolean[2*n], n);\\n        return result;\\n    }\\n    \\n    private void helper(List<List<String>> result, List<String> board, int row, boolean[] cols, boolean[] d1, boolean[] d2, int n){\\n        if (row == n) {\\n            result.add(new ArrayList<String>(board));\\n        }\\n        for (int col=0; col<n; col++){\\n            int id1 = col - row + n;\\n            int id2 = col + row;\\n            if (!cols[col] && !d1[id1] && !d2[id2]){\\n                char[] r = new char[n];\\n                Arrays.fill(r, '.');\\n                r[col] = 'Q';\\n                board.add(new String(r));\\n                cols[col] = true;\\n                d1[id1] = true;\\n                d2[id2] = true;\\n                helper(result, board, row+1, cols, d1, d2, n);\\n                board.remove(board.size()-1);\\n                cols[col] = false;\\n                d1[id1] = false;\\n                d2[id2] = false;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369644,
                "title": "detailed-explanation-faster-simple-and-easy-to-understand",
                "content": "So, this is a classic backtracking problem.\\n\\nNOTE : All the points have been described sequentially, so that you can sequentially follow along with code ;)\\n\\nNow lets, move in flow of functions : \\n\\'ans\\' 2D array stores all positions of possible board configuration and so it would be our returning object\\n\\nSOLVEQUEENS ->\\n1) we initalise our board as (nxn) board consisting of all \\'.\\'\\n2) we call our placeQueen fn with request that yes we want to place our first Queen at 1st (0th index) row. The placeQueen will check for its feasibility , and if feasible will place the queen there and move forward to next row\\n\\nPLACEQUEEN -> (It places queen in board based on feasibility(constraints))\\n1) If we had already filled all the rows, then we got one of the answer, and we save our board position to our answer array\\n2) otherwise for that particular row, we iterate in all the columns to look for safe cells where we can place our queen\\n3) If a particular board pos is safe as returned by our isSafe function, then if we can place our queen in that cell and again look for placing our queen in next row. \\nAfter getting all possible combination from that particular column position of queen in that row, we bactrack and move our queen to rext col within same row to get other combinations.\\n4) And if it isn\\'t safe we backtrack to move our queen to next col within same row.\\n\\nIS-SAFE -> (returns boolean value if a particuar position in board is safe or not from attacks)\\n\\n1) As soon as we are placing a queen in a row, we move to next row, so there can\\'t be two queens in same row anyhow. So we don\\'t need to check for queens in the same row\\n\\n2) we check if for a  particular column (for which we are checking for safety), is there already any queen on any row in same column . If yes this cell isn\\'t safe.\\n\\n3) we check for both the diagonals for safety also (commented).\\n\\n\\nHope it helps. Your upvoting would encourage me :)\\n\\n\\n\\n```\\nclass Solution {\\n    vector<vector<string>> ans;\\npublic:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        //column check\\n        for(int i = 0; i<board.size(); ++i){\\n            if(board[i][col] == \\'Q\\'){return false;}\\n        }\\n        int x = row; int y = col;\\n\\t\\t\\n        //checking for upper left diagonal(non-main diagonal), row is decreasing and col too\\n        while(x>=0 && y>=0){\\n            if(board[x][y] == \\'Q\\'){return false;}\\n            --x;  --y; \\n        }\\n        \\n         //checking for main diagonal(upper right), row is decreasing and col increasing\\n        while(row>=0 && col<board.size()){\\n            if(board[row][col] == \\'Q\\'){return false;}\\n            --row; ++col;\\n        }\\n        \\n        //The fn didn\\'t returned false till , implies that our position is safe to place the queen\\n        return true;\\n    }\\n    \\n    void placeQueen(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int col = 0; col<board.size() ; ++col){\\n            if(isSafe(board, row, col)){\\n                board[row][col] = \\'Q\\';\\n                placeQueen(board, row+1);\\n                board[row][col] = \\'.\\';\\n            }   \\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {            \\n            //Initialise board with all \\'.\\'\\n            vector<string> board(n, string(n, \\'.\\'));\\n            placeQueen(board, 0); \\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<string>> ans;\\npublic:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        //column check\\n        for(int i = 0; i<board.size(); ++i){\\n            if(board[i][col] == \\'Q\\'){return false;}\\n        }\\n        int x = row; int y = col;\\n\\t\\t\\n        //checking for upper left diagonal(non-main diagonal), row is decreasing and col too\\n        while(x>=0 && y>=0){\\n            if(board[x][y] == \\'Q\\'){return false;}\\n            --x;  --y; \\n        }\\n        \\n         //checking for main diagonal(upper right), row is decreasing and col increasing\\n        while(row>=0 && col<board.size()){\\n            if(board[row][col] == \\'Q\\'){return false;}\\n            --row; ++col;\\n        }\\n        \\n        //The fn didn\\'t returned false till , implies that our position is safe to place the queen\\n        return true;\\n    }\\n    \\n    void placeQueen(vector<string> &board, int row){\\n        if(row == board.size()){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int col = 0; col<board.size() ; ++col){\\n            if(isSafe(board, row, col)){\\n                board[row][col] = \\'Q\\';\\n                placeQueen(board, row+1);\\n                board[row][col] = \\'.\\';\\n            }   \\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {            \\n            //Initialise board with all \\'.\\'\\n            vector<string> board(n, string(n, \\'.\\'));\\n            placeQueen(board, 0); \\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19840,
                "title": "simple-javascript-solution-using-backtracking",
                "content": "```\\nvar solveNQueens = function(n) {\\n    const res = [];\\n    backtrack(res, n);\\n    return res;\\n};\\n\\nfunction backtrack(res, n, board = [], r = 0) {\\n    if (r === n) {\\n        res.push(board.map(c => '.'.repeat(c) + 'Q' + '.'.repeat(n - c - 1)));\\n        return;\\n    }\\n    for (let c = 0; c < n; c++) {\\n        if (!board.some((bc, br) => bc === c || bc === c + r - br || bc === c - r + br)) {\\n            board.push(c);\\n            backtrack(res, n, board, r + 1);\\n            board.pop();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solveNQueens = function(n) {\\n    const res = [];\\n    backtrack(res, n);\\n    return res;\\n};\\n\\nfunction backtrack(res, n, board = [], r = 0) {\\n    if (r === n) {\\n        res.push(board.map(c => '.'.repeat(c) + 'Q' + '.'.repeat(n - c - 1)));\\n        return;\\n    }\\n    for (let c = 0; c < n; c++) {\\n        if (!board.some((bc, br) => bc === c || bc === c + r - br || bc === c - r + br)) {\\n            board.push(c);\\n            backtrack(res, n, board, r + 1);\\n            board.pop();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19975,
                "title": "accepted-auxillary-space-o-n-using-dfs-cpp",
                "content": "Space complexity :  Instead of using a 2D array to represent the chess board, i am using a 1D array , the index of which would represent the row number and the value of arr at row index will be the column number for the correct position of the queen.\\n \\ni.e\\n         \\n\\n           Instead of doing  arr[row][col]=1\\n           i am using arr[row]=col ;               where queen is positioned at (row,col);\\n\\nLogic :  DFS for every column number ,ranging from 0 to n-1, for all the rows from 0 to n-1 and check the validity of queen position for every row,col combination(using isSafe function)\\n\\nisSafe function : It checks whether the queen in current position(r,c) is being attacked by any of the r-1 queens positioned in row numbers 0 through r-1. \\n\\n\\n \\n\\n     class Solution {\\n        public:\\n            vector < vector <string> > sol;\\n            int limit;\\n            \\n            vector<string> toChessString(vector<int> arr) \\n              {\\n                string s(arr.size(),'.');\\n                vector<string> ans(arr.size(),s);\\n        \\n                for(int i=0 ; i<arr.size() ; i++)\\n                  ans[i][arr[i]]='Q';\\n        \\n                  return ans;\\n              }\\n        \\n        \\n            bool isSafe(vector<int> arr, int r , int c )\\n             {\\n                int check;\\n                for(int row=r-1,ldia=c-1,rdia=c+1 ; row>=0 ; row--,ldia--,rdia++)\\n                {\\n                    check=arr[row];\\n        \\n                    if(check==c || check==ldia || check==rdia)\\n                     return false;\\n                }\\n                return true;\\n             }\\n        \\n            void solveNqueen(vector<int> arr , int r , int c)\\n            {\\n                if(r==limit)\\n                 sol.push_back(toChessString(arr));\\n                    \\n                else\\n                 {\\n                     for(int col=c ; col<limit ; col++)\\n                     {\\n                        arr[r]=col;\\n        \\n                        if(isSafe(arr,r,col))\\n                          solveNqueen(arr,r+1,0);\\n                     }\\n                 }\\n            }\\n        \\n        \\n            vector<vector<string> > solveNQueens(int n) {\\n                vector<int> arr(n,0);\\n                limit=n;\\n                solveNqueen(arr,0,0);\\n              \\n                return sol;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            vector < vector <string> > sol;\\n            int limit;\\n            \\n            vector<string> toChessString(vector<int> arr) \\n              {\\n                string s(arr.size(),'.');\\n                vector<string> ans(arr.size(),s);\\n        \\n                for(int i=0 ; i<arr.size() ; i++)\\n                  ans[i][arr[i]]='Q';\\n        \\n                  return ans;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 511243,
                "title": "simple-java-with-detailed-explanation",
                "content": "```\\n  // classic backtracking: initialize the n * n array and starting first position, perform DFS and fill the queens in the boards in the valid positions\\n    private static List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (n <= 0) {\\n            return result;\\n        }\\n        char[][] matrix = new char[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = \\'.\\';\\n            }\\n        }\\n        nQueensDFSHelper(matrix, 0, result);\\n        return result;\\n    }\\n\\n    // start the process by placing the queen in the first row [0, 0].  \\n    // as we cannot place 2 queens in the same row, when we place the queen in the nth row and if its valid position, dfs again starting n+1 th row and try placing the next queen in all the columns of n+1th row and find a valid position.\\n    // if no valid queen column found in n+1th row, backtrack and go to nth row, and change the queen position to the next column and repeat the process \\n    private static void nQueensDFSHelper(char[][] matrix, int row, List<List<String>> result) {\\n        if (row == matrix.length) {\\n            List<String> possibleResult = resultBuilder(matrix);\\n            result.add(possibleResult);\\n            return;\\n        }\\n        for (int col = 0; col < matrix.length; col++) {\\n            matrix[row][col] = \\'Q\\';   // mark the queen position to try out all the possibilities \\n            if (isValidPosition(matrix, row, col)) {\\n                nQueensDFSHelper(matrix, row + 1, result);\\n            }\\n            matrix[row][col] = \\'.\\';   // undo (un mark) the queen position \\n        }\\n    }\\n\\n    // helper method to validate if the queen can be placed at a certain position (x and y coordinates) on current state of the board\\n    private static boolean isValidPosition(char[][] matrix, int x, int y) {\\n        for (int row = 0; row < x; row++) {   // check for the rows only before x as those are where the queen will be (as we are visiting the rows in sequential order)\\n            for (int col = 0; col < matrix.length; col++) {  // visit all the columns in these rows \\n                // when the matrix already has queen at [row, column] position, the new queen cannot be in this column or one of its diagonals (x-row and y-col -- better understood with an example: these conditions represents if the new queen is placed in one of the diagonals of an already existing queen. if yes, the new queen cannot be valid at the given position) \\n                if ((y == col || Math.abs(x - row) == Math.abs(y - col)) && matrix[row][col] == \\'Q\\') {   // NOTE : important condition. don\\'t forget to take care of it\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // create the list of strings from queen positions\\n    private static List<String> resultBuilder(char[][] matrix) {\\n        int length = matrix.length;\\n        List<String> list = new ArrayList<>();\\n        for (int i = 0; i < length; i++) {\\n            list.add(new String(matrix[i]));\\n        }\\n        return list;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  // classic backtracking: initialize the n * n array and starting first position, perform DFS and fill the queens in the boards in the valid positions\\n    private static List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (n <= 0) {\\n            return result;\\n        }\\n        char[][] matrix = new char[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = \\'.\\';\\n            }\\n        }\\n        nQueensDFSHelper(matrix, 0, result);\\n        return result;\\n    }\\n\\n    // start the process by placing the queen in the first row [0, 0].  \\n    // as we cannot place 2 queens in the same row, when we place the queen in the nth row and if its valid position, dfs again starting n+1 th row and try placing the next queen in all the columns of n+1th row and find a valid position.\\n    // if no valid queen column found in n+1th row, backtrack and go to nth row, and change the queen position to the next column and repeat the process \\n    private static void nQueensDFSHelper(char[][] matrix, int row, List<List<String>> result) {\\n        if (row == matrix.length) {\\n            List<String> possibleResult = resultBuilder(matrix);\\n            result.add(possibleResult);\\n            return;\\n        }\\n        for (int col = 0; col < matrix.length; col++) {\\n            matrix[row][col] = \\'Q\\';   // mark the queen position to try out all the possibilities \\n            if (isValidPosition(matrix, row, col)) {\\n                nQueensDFSHelper(matrix, row + 1, result);\\n            }\\n            matrix[row][col] = \\'.\\';   // undo (un mark) the queen position \\n        }\\n    }\\n\\n    // helper method to validate if the queen can be placed at a certain position (x and y coordinates) on current state of the board\\n    private static boolean isValidPosition(char[][] matrix, int x, int y) {\\n        for (int row = 0; row < x; row++) {   // check for the rows only before x as those are where the queen will be (as we are visiting the rows in sequential order)\\n            for (int col = 0; col < matrix.length; col++) {  // visit all the columns in these rows \\n                // when the matrix already has queen at [row, column] position, the new queen cannot be in this column or one of its diagonals (x-row and y-col -- better understood with an example: these conditions represents if the new queen is placed in one of the diagonals of an already existing queen. if yes, the new queen cannot be valid at the given position) \\n                if ((y == col || Math.abs(x - row) == Math.abs(y - col)) && matrix[row][col] == \\'Q\\') {   // NOTE : important condition. don\\'t forget to take care of it\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    // create the list of strings from queen positions\\n    private static List<String> resultBuilder(char[][] matrix) {\\n        int length = matrix.length;\\n        List<String> list = new ArrayList<>();\\n        for (int i = 0; i < length; i++) {\\n            list.add(new String(matrix[i]));\\n        }\\n        return list;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754625,
                "title": "easy-java-solution-recursion-backtracking-detailed-solution-easy-to-understand-notes",
                "content": "# Intuition\\n<!--  -->\\nLet\\'s see the intuition behind this question.\\n\\n![WhatsApp Image 2023-07-12 at 5.11.51 PM.jpeg](https://assets.leetcode.com/users/images/d7c0148d-9d34-4e20-86a9-34da5b670c08_1689162264.640158.jpeg)\\n\\n# Approach\\n<!--  -->\\nSo, now when we know the question requires backtracking and recursion, let\\'s discuss the thought process and the approach!\\n\\n![WhatsApp Image 2023-07-12 at 5.11.52 PM.jpeg](https://assets.leetcode.com/users/images/76f56253-26ea-4299-9d02-604f8c1a88f1_1689162387.0847921.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.11.53 PM.jpeg](https://assets.leetcode.com/users/images/2872576b-425c-48c9-a5c7-ee6c8b960b72_1689162414.789056.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.18.32 PM.jpeg](https://assets.leetcode.com/users/images/74aa66cb-dc07-4001-a353-ae8220a3bf0d_1689162542.4049857.jpeg)\\n\\n## Please upvote if you loved it! \\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/6caea43f-b90d-4e55-befe-e8963ec23424_1689162825.9038785.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n! * n)\\n<!--  -->\\n\\n- Space complexity: O(n^2)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        queen(board, 0, ans);\\n        return ans;\\n    }\\n\\n    static void queen(char[][] board, int row, List<List<String>> list) {\\n\\n        if(row == board.length) {\\n\\n            list.add(construct(board));\\n            return;\\n        }\\n\\n        for (int col = 0; col < board.length; col++) {\\n            if(isSafe(board, row, col)) {\\n                board[row][col] = \\'Q\\';\\n                queen(board, row + 1, list);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    static List<String> construct(char[][] board) {\\n\\n        List<String> internal = new ArrayList<>();\\n        for (int i = 0; i < board.length; i++) {\\n            String row = new String(board[i]);\\n            internal.add(row);\\n        }\\n        return internal;\\n    }\\n\\n    static boolean isSafe(char[][] board, int row, int col) {\\n\\n        //for checking vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking left diagonal\\n\\n        int maxLeft = Math.min(row, col);\\n\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if(board[row - i][col - i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking right diagonal\\n\\n        int maxRight = Math.min(row, board.length - 1 - col);\\n\\n        for (int i = 1; i <= maxRight; i++) {\\n            if(board[row - i][col + i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        queen(board, 0, ans);\\n        return ans;\\n    }\\n\\n    static void queen(char[][] board, int row, List<List<String>> list) {\\n\\n        if(row == board.length) {\\n\\n            list.add(construct(board));\\n            return;\\n        }\\n\\n        for (int col = 0; col < board.length; col++) {\\n            if(isSafe(board, row, col)) {\\n                board[row][col] = \\'Q\\';\\n                queen(board, row + 1, list);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    static List<String> construct(char[][] board) {\\n\\n        List<String> internal = new ArrayList<>();\\n        for (int i = 0; i < board.length; i++) {\\n            String row = new String(board[i]);\\n            internal.add(row);\\n        }\\n        return internal;\\n    }\\n\\n    static boolean isSafe(char[][] board, int row, int col) {\\n\\n        //for checking vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking left diagonal\\n\\n        int maxLeft = Math.min(row, col);\\n\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if(board[row - i][col - i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking right diagonal\\n\\n        int maxRight = Math.min(row, board.length - 1 - col);\\n\\n        for (int i = 1; i <= maxRight; i++) {\\n            if(board[row - i][col + i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223270,
                "title": "best-c-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N!), Where N is the size of chess board. For the first row, we check N columns; for the second row, we check the N - 1 column and so on. Hence, the time complexity will be N * (N-1) * (N-2) \\u2026. i.e. O(N!).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N^2), Vector of string(nQueens) space. Extra space is allocated for the vector of vector string(output), however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N!), Where N is the size of chess board. For the first row, we check N columns; for the\\n    second row, we check the N - 1 column and so on. Hence, the time complexity will be N * (N-1) * (N-2) \\u2026. i.e.\\n    O(N!).\\n    \\n    Space Complexity : O(N^2), Vector of string(nQueens) space. Extra space is allocated for the vector of vector\\n    string(output), however the output does not count towards the space complexity.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool isSafePlace(int n, vector<string>& nQueens, int row, int col){\\n        for(int i=0; i<n; i++){\\n            if(nQueens[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){\\n            if(nQueens[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++){\\n            if(nQueens[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solveNQueens(int n, vector<vector<string>>& output, vector<string>& nQueens, int row){\\n        if(row == n){\\n            output.push_back(nQueens);\\n            return;\\n        }\\n        for(int col=0; col<n; col++){\\n            if(isSafePlace(n, nQueens, row, col)){\\n                nQueens[row][col] = \\'Q\\';\\n                solveNQueens(n, output, nQueens, row+1);\\n                nQueens[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> output;\\n        vector<string> nQueens(n , string(n, \\'.\\'));\\n        solveNQueens(n, output, nQueens, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N!), Where N is the size of chess board. For the first row, we check N columns; for the\\n    second row, we check the N - 1 column and so on. Hence, the time complexity will be N * (N-1) * (N-2) \\u2026. i.e.\\n    O(N!).\\n    \\n    Space Complexity : O(N^2), Vector of string(nQueens) space. Extra space is allocated for the vector of vector\\n    string(output), however the output does not count towards the space complexity.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool isSafePlace(int n, vector<string>& nQueens, int row, int col){\\n        for(int i=0; i<n; i++){\\n            if(nQueens[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){\\n            if(nQueens[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=row-1, j=col+1; i>=0 && j<n; i--, j++){\\n            if(nQueens[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solveNQueens(int n, vector<vector<string>>& output, vector<string>& nQueens, int row){\\n        if(row == n){\\n            output.push_back(nQueens);\\n            return;\\n        }\\n        for(int col=0; col<n; col++){\\n            if(isSafePlace(n, nQueens, row, col)){\\n                nQueens[row][col] = \\'Q\\';\\n                solveNQueens(n, output, nQueens, row+1);\\n                nQueens[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> output;\\n        vector<string> nQueens(n , string(n, \\'.\\'));\\n        solveNQueens(n, output, nQueens, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223495,
                "title": "python-super-short-backtracking-explained",
                "content": "This problem is similar to problem **46**, basically we need to go over all `n!` permutations and then check if it is correct and write function to draw this solution. Let us use `dfs(board, c1, c2, c3)` function here, where:\\n\\n1. `board` are positions of queen for the first, second and so on lines. Length of `board` is how many queens we already used.\\n2. `c1` is bit mask for columns, `c2` and `c3` for diagonals. Note, that we use `i-j+n` for one of the diagonals to avoid negative numbers.  Each time we try to take all possible positions and then check if we can put queen on this position.\\n\\n#### Complexity\\nTime and space complexity is `O(n!)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def solveNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: ans.append([\".\"*j + \"Q\" + \".\"*(n-j-1) for j in board])\\n            \\n            for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        ans = []\\n        dfs([], 0, 0, 0, 0)\\n        return ans\\n```\\n\\n#### Remark\\nAgain some guys with fakes accounts try to boost they own solutions and downvote me a lot. WTF.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def solveNQueens(self, n):\\n        def dfs(board, i, c1, c2, c3):\\n            if i == n: ans.append([\".\"*j + \"Q\" + \".\"*(n-j-1) for j in board])\\n            \\n            for j in range(n):\\n                if c1 & 1<<j or c2 & 1<<i-j+n or c3 & 1<<i+j: continue\\n                dfs(board + [j], i + 1, c1 ^ 1<<j, c2 ^ 1<<i-j+n, c3 ^ 1<<i+j)\\n        \\n        ans = []\\n        dfs([], 0, 0, 0, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109925,
                "title": "java-backtracking-detailed-explanation-with-pictures-easycode",
                "content": "**Logic:**\\nOur approach for this problem is to place queens at every position of the nxn matrix and check whether it satisfies the case that no two or more queens attack each other\\nFYI: A queen can move in vertical horizontal and diagonal positions till the end of the board \\nas shown in the picture bellow\\n\\n<img width=\"200\" src=\"https://assets.leetcode.com/users/images/292a3259-802c-4348-be35-a43d1c7b71a6_1654348317.2328882.png\">\\n\\nThis solution uses the concept of backtracking in it.\\nThis is what we do --> \\n* Iterate through the whole matrix row wise\\n* Place the queen at every position and call a helper function (i.e validatePosition) which returns true if the queen can be placed there\\n* Suppose the condition is satisfied in the first two rows but no such square is found in the third row so what we do is that we go back to the previous row and delete the queen and try to place it somewhere else if it is found good enough we continue the process but if no such position is found we again go back and delete the queen placed on the row prior to that.\\n**The bellow images will depict how it works**\\n<img width=\"200\" src=\"https://assets.leetcode.com/users/images/cbc6061f-7676-4ef5-b015-c8b7c820c205_1654348858.475833.png\"> **==>** <img width=\"200\" src=\"https://assets.leetcode.com/users/images/c49579bc-aebd-45a5-96c7-4df058af3da2_1654348929.854376.png\"> **==>** <img width=\"200\" src=\"https://assets.leetcode.com/users/images/dc1d0845-9144-4516-91d7-f8c726976b6b_1654348968.3293483.png\"> **==>** <img width=\"200\" src=\"https://assets.leetcode.com/users/images/af8085c8-28d0-4fc9-b74d-a8f8eb6b7cf3_1654348993.753641.png\">\\n**We go on till the end of the row until we find a green square for the queen**\\n\\n**Helper methods used  -->**\\n1. **queenTry**  --> Iterates through every row like a[0][0]..a[0][1]..a[0][2].. and places a queen and calls for validatePsoition\\n2. **validatePosition**  --> finds an appropiate spot for the queen checks horizontally,vertically and diagonally and returns true is the queen can be placed either false\\n3. **build**  --> here as we iterate through the board we convert it to a string and add it to a list\\n\\n**Code-->**\\n**Java**\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans;\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        \\n        char arr[][] = new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                arr[i][j] = \\'.\\';\\n        \\n        queenTry(ans,arr,0);\\n        return ans;\\n    }\\n    private void queenTry(List<List<String>> ans, char[][] arr, int row)\\n    {\\n        if(row == arr.length)\\n        {\\n            ans.add(build(arr));\\n            return;\\n        }\\n        for(int col=0;col<arr.length;col++)\\n        {\\n            if(validatePosition(arr,row,col))\\n            {\\n                arr[row][col] = \\'Q\\';\\n                queenTry(ans,arr,row+1);\\n                arr[row][col] = \\'.\\'; \\n            }\\n        }\\n    }\\n    \\n    private boolean validatePosition(char[][] arr,int row,int col)\\n    {\\n        //checks validity in every row for a single column\\n        for(int i=0;i<row;i++)\\n        {\\n            if(arr[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 45 degree angle\\n        for(int i=row-1,j=col+1;i>=0 && j<arr.length;i--,j++)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        //checks for every 135 degree angle\\n        for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--)\\n        {\\n            if(arr[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private List<String> build(char arr[][])\\n    {\\n        List<String> val = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n            val.add(new String(arr[i]));\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19866,
                "title": "c-6ms-solution-use-bitmask",
                "content": "    class Solution \\n    {\\n        int n;\\n        string getNq(int p)\\n        {\\n            string s(n, '.');\\n            s[p] = 'Q';\\n            return s;\\n        }\\n        void nQueens(int p, int l, int m, int r, vector<vector<string>> &res)\\n        {\\n            static vector<string> ans;\\n            if (p >= n)\\n            {\\n                res.push_back(ans);\\n                return ;\\n            }\\n            int mask = l | m | r;\\n            for (int i = 0, b = 1; i < n; ++ i, b <<= 1)\\n                if (!(mask & b))\\n                {\\n                    ans.push_back(getNq(i));\\n                    nQueens(p + 1, (l | b) >> 1, m | b, (r | b) << 1, res);\\n                    ans.pop_back();\\n                }\\n        }\\n    public:\\n        vector<vector<string> > solveNQueens(int n) \\n        {\\n            this->n = n;\\n            vector<vector<string>> res;\\n            nQueens(0, 0, 0, 0, res);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution \\n    {\\n        int n;\\n        string getNq(int p)\\n        {\\n            string s(n, '.');\\n            s[p] = 'Q';\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1223010,
                "title": "easy-solution-using-backtracking-w-detailed-explaination",
                "content": "\\u2714\\uFE0F ***Solution (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we must realise that we don\\'t actually need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that so queen attacks the other queen. This means, on each row only one queen can be placed and then we can move to the next row.\\n\\nSo for each row, we will place one queen (if its possible without violating the constraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to place at *`(i, j)`*. Once, all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place it at some other location, i.e, we need to **backtrack**. This will give us all the possible combinations to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nvector<vector<string> > sols;\\nvector<vector<string>> solveNQueens(int n) {    \\n\\tvector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\tsolve(board, 0);\\n\\treturn sols;\\n}\\nbool check(vector<string>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(board[i][col] == \\'Q\\') return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking all diagonals-\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false;\\n\\t}\\n\\treturn true;\\n}\\n// Recursive solver - Tries all possible placement of queen for current row & recurses for next row\\nvoid solve(vector<string>& board, int row) {\\n\\t// base condition. When we reach here, a valid placement combination has been formed. So insert it into ans\\n\\tif(row == size(board)) { \\n\\t\\tsols.push_back(board);\\n\\t\\treturn;\\n\\t}            \\n\\t// Try placing a queen on each column for a given row. Explore next row by placing Q at each valid column for the current row\\n\\tfor(int col = 0; col < size(board); col++) \\n\\t\\tif(check(board, row, col)) {\\n\\t\\t\\tboard[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\tsolve(board, row + 1);    // exploring next row\\n\\t\\t\\tboard[row][col] = \\'.\\';    // backtracking to get all possible solutions\\n\\t\\t}            \\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Time Complexity :*** **`O(N*N)`**. Required for board and recursive stack. This doesn\\'t include extra space used by *`ans`*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<string> > sols;\\nvector<vector<string>> solveNQueens(int n) {    \\n\\tvector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\tsolve(board, 0);\\n\\treturn sols;\\n}\\nbool check(vector<string>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(board[i][col] == \\'Q\\') return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking all diagonals-\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false;\\n\\t}\\n\\treturn true;\\n}\\n// Recursive solver - Tries all possible placement of queen for current row & recurses for next row\\nvoid solve(vector<string>& board, int row) {\\n\\t// base condition. When we reach here, a valid placement combination has been formed. So insert it into ans\\n\\tif(row == size(board)) { \\n\\t\\tsols.push_back(board);\\n\\t\\treturn;\\n\\t}            \\n\\t// Try placing a queen on each column for a given row. Explore next row by placing Q at each valid column for the current row\\n\\tfor(int col = 0; col < size(board); col++) \\n\\t\\tif(check(board, row, col)) {\\n\\t\\t\\tboard[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\tsolve(board, row + 1);    // exploring next row\\n\\t\\t\\tboard[row][col] = \\'.\\';    // backtracking to get all possible solutions\\n\\t\\t}            \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692038,
                "title": "python3-backtracking-language-independent-approach",
                "content": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def issafe(r,c):\\n            n = len(board)\\n            for i in range(n):\\n                if board[i][c] == \\'Q\\':\\n                    return False\\n                if r - i >= 0 and c - i >= 0 and board[r-i][c-i] == \\'Q\\':\\n                    return False\\n                if r - i >= 0 and c + i < n and board[r-i][c+i] == \\'Q\\':\\n                    return False\\n            return True\\n                \\n        def solve(r):\\n            n = len(board)\\n            if r == n:\\n                print(board)\\n                ans.append([\"\".join(i) for i in board])\\n                return \\n            for c in range(0,n):\\n                if issafe(r,c):\\n                    board[r][c] = \\'Q\\'\\n                    solve(r+1)\\n                    board[r][c] = \\'.\\'\\n        board = [[\\'.\\']*n for i in range(n)]\\n        ans =[]\\n        solve(0) \\n        return ans\\n# Please upvote if you understand the solution",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def issafe(r,c):\\n            n = len(board)\\n            for i in range(n):\\n                if board[i][c] == \\'Q\\':\\n                    return False\\n                if r - i >= 0 and c - i >= 0 and board[r-i][c-i] == \\'Q\\':\\n                    return False\\n                if r - i >= 0 and c + i < n and board[r-i][c+i] == \\'Q\\':\\n                    return False\\n            return True\\n                \\n        def solve(r):\\n            n = len(board)\\n            if r == n:\\n                print(board)\\n                ans.append([\"\".join(i) for i in board])\\n                return \\n            for c in range(0,n):\\n                if issafe(r,c):\\n                    board[r][c] = \\'Q\\'\\n                    solve(r+1)\\n                    board[r][c] = \\'.\\'\\n        board = [[\\'.\\']*n for i in range(n)]\\n        ans =[]\\n        solve(0) \\n        return ans\\n# Please upvote if you understand the solution",
                "codeTag": "Java"
            },
            {
                "id": 826728,
                "title": "python-easy-to-read-w-explanation-backtracking",
                "content": "```\\n\"\"\"\\nRuntime: 52 ms, faster than 95.31% of Python3 online submissions for N-Queens.\\nMemory Usage: 14.3 MB, less than 26.71% of Python3 online submissions for N-Queens.\\n\\nGoal: Place a queen somewhere such that no queen are attacking each other\\nApproach: backtracking\\n- each recursive layer will decide on a row and also the placement of the queen\\n- the constraint is making sure we do not place a queen where its in sight of another queen. How?\\n    1) make sure it is not on the same column --> create a column set\\n    2) make sure it is not in same diagonal path --> create a diagonal set (calculated via r+c)\\n    3) make sure it is not in a antidiagonal path --> create a antidiagonal set (calculated via r-c)\\n    \\n    We dont need to worry about rows because it is handled by the backtracking parameter that always recurse\\n    to next level of the row\\n    \\n    ** note: if you dont know why r+c and r-c are diagonal paths --> Draw it out and check why it does!! \\n    \\n\\n\"\"\"\\n\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        if n == 0: return []\\n        \\n        col = set()\\n        diagonal = set()    # determined by r+c\\n        antidiagonal = set() #\\n        output = []\\n        result = []\\n        \\n        def backtrack(r):\\n            nonlocal n,col,diagonal,antidiagonal,output,result\\n            if r == n:\\n                result.append(output[:])\\n                return\\n            \\n            for c in range(n):\\n                if c in col or (r+c) in diagonal or (r-c) in antidiagonal: continue\\n                \\n                col.add(c)\\n                diagonal.add(r+c)\\n                antidiagonal.add(r-c)\\n                output.append(\\'.\\'*c + \\'Q\\' + \\'.\\'*(n-c-1))\\n                backtrack(r+1)\\n                \\n                col.remove(c)\\n                diagonal.remove(r+c)\\n                antidiagonal.remove(r-c)\\n                output.pop()\\n        \\n        backtrack(0)\\n        return result\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\n\"\"\"\\nRuntime: 52 ms, faster than 95.31% of Python3 online submissions for N-Queens.\\nMemory Usage: 14.3 MB, less than 26.71% of Python3 online submissions for N-Queens.\\n\\nGoal: Place a queen somewhere such that no queen are attacking each other\\nApproach: backtracking\\n- each recursive layer will decide on a row and also the placement of the queen\\n- the constraint is making sure we do not place a queen where its in sight of another queen. How?\\n    1) make sure it is not on the same column --> create a column set\\n    2) make sure it is not in same diagonal path --> create a diagonal set (calculated via r+c)\\n    3) make sure it is not in a antidiagonal path --> create a antidiagonal set (calculated via r-c)\\n    \\n    We dont need to worry about rows because it is handled by the backtracking parameter that always recurse\\n    to next level of the row\\n    \\n    ** note: if you dont know why r+c and r-c are diagonal paths --> Draw it out and check why it does!! \\n    \\n\\n\"\"\"\\n\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        if n == 0: return []\\n        \\n        col = set()\\n        diagonal = set()    # determined by r+c\\n        antidiagonal = set() #\\n        output = []\\n        result = []\\n        \\n        def backtrack(r):\\n            nonlocal n,col,diagonal,antidiagonal,output,result\\n            if r == n:\\n                result.append(output[:])\\n                return\\n            \\n            for c in range(n):\\n                if c in col or (r+c) in diagonal or (r-c) in antidiagonal: continue\\n                \\n                col.add(c)\\n                diagonal.add(r+c)\\n                antidiagonal.add(r-c)\\n                output.append(\\'.\\'*c + \\'Q\\' + \\'.\\'*(n-c-1))\\n                backtrack(r+1)\\n                \\n                col.remove(c)\\n                diagonal.remove(r+c)\\n                antidiagonal.remove(r-c)\\n                output.pop()\\n        \\n        backtrack(0)\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107895,
                "title": "c-backtracking-beginner-friendly-solution-w-explanation",
                "content": "\\tclass Solution {\\n\\t\\tvector<vector<string>> ans;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check \\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check upper left side\\n\\t\\t\\tint row=r,col=c;\\n\\t\\t\\twhile(row>=0 && col>=0){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col--;\\n\\t\\t\\t}\\n\\t\\t\\t//diagonal check upper right side\\n\\t\\t\\trow=r,col=c;\\n\\t\\t\\twhile(row>=0 && col<n){\\n\\t\\t\\t\\tif(v[row][col]==\\'Q\\') return false;\\n\\t\\t\\t\\trow--,col++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid helper(int r,vector<string> &v,int n){\\n\\t\\t\\t if(r==n){ //if row reaches end of the board \\n\\t\\t\\t\\t ans.push_back(v);\\n\\t\\t\\t\\t return ;\\n\\t\\t\\t }\\n\\t\\t\\tfor(int i=0;i<n;i++){  //fixing row and traversing in column\\n\\t\\t\\t\\tif(issafe(r,i,v,n)){\\n\\t\\t\\t\\t\\tv[r][i]=\\'Q\\';\\n\\t\\t\\t\\t\\thelper(r+1,v,n);\\n\\t\\t\\t\\t\\tv[r][i]=\\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<string>> solveNQueens(int n) {\\n\\t\\t\\tvector<string> v;\\n\\t\\t\\tstring s(n,\\'.\\');\\n\\t\\t\\tfor(int i=0;i<n;i++) v.push_back(s);\\n\\t\\t\\thelper(0,v,n);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n**Please Do Upvote If It was helpful In any way !**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tvector<vector<string>> ans;\\n\\tpublic:\\n\\t\\tbool issafe(int r,int c,vector<string>&v,int n){\\n\\t\\t\\t//column check \\n\\t\\t\\tfor(int i=0;i<=r;i++){\\n\\t\\t\\t\\tif(v[i][c]==\\'Q\\') return false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 562194,
                "title": "clean-python-backtrack-40ms",
                "content": "We use 3 hashsets (```cols, l_diag, r_diag```) to store and check valid positions while doing backtrack.\\n\\nTime complexity is ```O(n!)```.\\nSpace complexity is ```O(n)```, since the maximum recursion depth is ```n```, also the length for all three hashsets.\\n\\n```\\nclass Solution(object):\\n    def solveNQueens(self, n):\\n        \"\"\"\"\"\"\\n        res, cols, l_diag, r_diag = [], set(), set(), set()\\n\\t\\t\\n        def dfs(r, pos): \\n\\t\\t\\t# r: int, current row to set\\n\\t\\t\\t# pos: List[int], previous positioned Queens (at each row)\\n            if r == n:\\n                res.append([\\'.\\' * i + \\'Q\\' + \\'.\\' * (n - i - 1) for i in pos])\\n                return\\n            for c in range(n):\\n                if not c in cols and not r - c in l_diag and not r + c in r_diag:\\n                    cols.add(c)\\n                    l_diag.add(r - c)\\n                    r_diag.add(r + c)\\n                    dfs(r + 1, pos + [c])\\n                    cols.remove(c)\\n                    l_diag.remove(r - c)\\n                    r_diag.remove(r + c)\\n            \\n        dfs(0, [])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```cols, l_diag, r_diag```\n```O(n!)```\n```O(n)```\n```n```\n```\\nclass Solution(object):\\n    def solveNQueens(self, n):\\n        \"\"\"\"\"\"\\n        res, cols, l_diag, r_diag = [], set(), set(), set()\\n\\t\\t\\n        def dfs(r, pos): \\n\\t\\t\\t# r: int, current row to set\\n\\t\\t\\t# pos: List[int], previous positioned Queens (at each row)\\n            if r == n:\\n                res.append([\\'.\\' * i + \\'Q\\' + \\'.\\' * (n - i - 1) for i in pos])\\n                return\\n            for c in range(n):\\n                if not c in cols and not r - c in l_diag and not r + c in r_diag:\\n                    cols.add(c)\\n                    l_diag.add(r - c)\\n                    r_diag.add(r + c)\\n                    dfs(r + 1, pos + [c])\\n                    cols.remove(c)\\n                    l_diag.remove(r - c)\\n                    r_diag.remove(r + c)\\n            \\n        dfs(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19959,
                "title": "14-lines-python-code-dfs-solution",
                "content": "    class Solution:\\n    # @return a list of lists of string\\n    def solveNQueens(self, n):\\n        stack, res = [[(0, i)] for i in range(n)], []\\n        while stack:\\n            board = stack.pop()\\n            row = len(board)\\n            if row == n:\\n                res.append([''.join('Q' if i == c else '.' for i in range(n))\\n                            for r, c in board])\\n            for col in range(n):\\n                if all(col != c and abs(row-r) != abs(col-c)for r, c in board):\\n                    stack.append(board+[(row, col)])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @return a list of lists of string\\n    def solveNQueens(self, n):\\n        stack, res = [[(0, i)] for i in range(n)], []\\n        while stack:\\n            board = stack.pop()\\n            row = len(board)\\n            if row == n:\\n                res.append([''.join('Q' if i == c else '.' for i in range(n))\\n                            for r, c in board])\\n            for col in range(n):\\n                if all(col != c and abs(row-r) != abs(col-c)for r, c in board):\\n                    stack.append(board+[(row, col)])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1564825,
                "title": "simple-python-solution-using-backtracking",
                "content": "```\\nclass Solution:\\n    \\n    #BackTracking\\n    def IsSafe(self,row,column,n,board):\\n\\n        # Check in the row if Q is present or not\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n            \\n        # Check in the upper Diagonal\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        #Check Lower Diagonal\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n\\n        return True\\n\\n\\n    def solveQueens(self,column,n,board,result):\\n\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            \\n            return\\n        \\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n    \\n        return\\n\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    #BackTracking\\n    def IsSafe(self,row,column,n,board):\\n\\n        # Check in the row if Q is present or not\\n        for i in range(column):\\n            if board[row][i] == \"Q\":\\n                return False\\n            \\n        # Check in the upper Diagonal\\n        i,j = row,column\\n        while(i>=0 and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        #Check Lower Diagonal\\n        i,j = row,column\\n        while(i<n and j>=0):\\n            if(board[i][j] == \"Q\"):\\n                return False\\n            i += 1\\n            j -= 1\\n\\n        return True\\n\\n\\n    def solveQueens(self,column,n,board,result):\\n\\n        if column == n:\\n            result.append([\"\".join(i) for i in board])\\n            \\n            return\\n        \\n        for row in range(n):\\n            if(self.IsSafe(row,column,n,board)):\\n                board[row][column] = \"Q\"\\n                self.solveQueens(column+1,n,board,result)\\n                board[row][column] = \".\"\\n    \\n        return\\n\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\".\" for i in range(n)] for i in range(n)]\\n        result = []\\n        self.solveQueens(0,n,board,result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399897,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res = [[Int]]()\\n        \\n        func backtrack(_ p: [Int] = []) {\\n            if p.count == n { res.append(p) }\\n            var pth = p, avb = Set<Int>(0..<n)\\n            for (i,n) in pth.enumerated() {\\n                if let idx = avb.firstIndex(of: n - pth.count + i) { avb.remove(at: idx) }\\n                if let idx = avb.firstIndex(of: n) { avb.remove(at: idx) }\\n                if let idx = avb.firstIndex(of: n + pth.count - i) { avb.remove(at: idx) }\\n            }\\n            for i in 0..<n where avb.contains(i) {\\n                pth.append(i)\\n                backtrack(pth)\\n                pth.remove(at: pth.count - 1)\\n            }\\n        }\\n        backtrack()\\n        return res.map { $0.map { i in (0..<n).map { j in (i == j ? \"Q\" : \".\") }.joined() }}\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.023 (0.025) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.solveNQueens(4)\\n        XCTAssertEqual(res, [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]])\\n    }\\n    \\n    func test1() {\\n        let res = solution.solveNQueens(1)\\n        XCTAssertEqual(res, [[\"Q\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res = [[Int]]()\\n        \\n        func backtrack(_ p: [Int] = []) {\\n            if p.count == n { res.append(p) }\\n            var pth = p, avb = Set<Int>(0..<n)\\n            for (i,n) in pth.enumerated() {\\n                if let idx = avb.firstIndex(of: n - pth.count + i) { avb.remove(at: idx) }\\n                if let idx = avb.firstIndex(of: n) { avb.remove(at: idx) }\\n                if let idx = avb.firstIndex(of: n + pth.count - i) { avb.remove(at: idx) }\\n            }\\n            for i in 0..<n where avb.contains(i) {\\n                pth.append(i)\\n                backtrack(pth)\\n                pth.remove(at: pth.count - 1)\\n            }\\n        }\\n        backtrack()\\n        return res.map { $0.map { i in (0..<n).map { j in (i == j ? \"Q\" : \".\") }.joined() }}\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let res = solution.solveNQueens(4)\\n        XCTAssertEqual(res, [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]])\\n    }\\n    \\n    func test1() {\\n        let res = solution.solveNQueens(1)\\n        XCTAssertEqual(res, [[\"Q\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223934,
                "title": "c-commented",
                "content": "**Do upvote if you find this helpful :)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    vector<vector<string>> solveNQueens(int n) {\\n        if(n==0 || n==2 || n==3)\\n        {\\n            //since it is not possible to place n queens\\n            return res;\\n        }\\n        vector<string> board(n,string(n,\\'.\\'));\\n        //initialize board \\n        //if n=3 then  {...,...,...}\\n        findPlaces(board,0);\\n        return res;\\n    }\\n    void findPlaces(vector<string>& board,int row)\\n    {\\n        if(row==board.size())\\n        {\\n            res.push_back(board);\\n            return ;\\n        }\\n        for(int i=0;i<board.size();i++)\\n        {\\n            //if i can place queen in the row at some pos i\\n            if(canPlace(board,row,i)){\\n                board[row][i]=\\'Q\\';\\n                //place queen in next row\\n                findPlaces(board,row+1);\\n                //back to normal to find other places\\n                board[row][i]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    bool canPlace(vector<string> board,int row, int ind)\\n    {\\n        //check up in the column;\\n        for(int i=row;i>=0;i--)\\n        {\\n            if(board[i][ind]==\\'Q\\')\\n                return false;\\n        }\\n        //check diagoanlly up left\\n        for(int i=row,j=ind;i>=0&&j>=0;i--,j--)\\n        {\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //check diagonally up right\\n        for(int i=row,j=ind;i>=0&&j<board.size();i--,j++)\\n        {\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //we wont check down because we are placing the queens from top to bottom\\n        //i.e first row to last row so we dont have any queens down the side\\n        //so if some queen is placed down afterwards it checks with this queen too\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    vector<vector<string>> solveNQueens(int n) {\\n        if(n==0 || n==2 || n==3)\\n        {\\n            //since it is not possible to place n queens\\n            return res;\\n        }\\n        vector<string> board(n,string(n,\\'.\\'));\\n        //initialize board \\n        //if n=3 then  {...,...,...}\\n        findPlaces(board,0);\\n        return res;\\n    }\\n    void findPlaces(vector<string>& board,int row)\\n    {\\n        if(row==board.size())\\n        {\\n            res.push_back(board);\\n            return ;\\n        }\\n        for(int i=0;i<board.size();i++)\\n        {\\n            //if i can place queen in the row at some pos i\\n            if(canPlace(board,row,i)){\\n                board[row][i]=\\'Q\\';\\n                //place queen in next row\\n                findPlaces(board,row+1);\\n                //back to normal to find other places\\n                board[row][i]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    bool canPlace(vector<string> board,int row, int ind)\\n    {\\n        //check up in the column;\\n        for(int i=row;i>=0;i--)\\n        {\\n            if(board[i][ind]==\\'Q\\')\\n                return false;\\n        }\\n        //check diagoanlly up left\\n        for(int i=row,j=ind;i>=0&&j>=0;i--,j--)\\n        {\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //check diagonally up right\\n        for(int i=row,j=ind;i>=0&&j<board.size();i--,j++)\\n        {\\n            if(board[i][j]==\\'Q\\')\\n                return false;\\n        }\\n        //we wont check down because we are placing the queens from top to bottom\\n        //i.e first row to last row so we dont have any queens down the side\\n        //so if some queen is placed down afterwards it checks with this queen too\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108030,
                "title": "java-branch-and-bound-method-easy-understanding-optimized-solution",
                "content": "**UPVOTE IF YOU FIND IT HELPFUL**\\n```\\nclass Solution {\\n    public void add(char[][] board,List<List<String>> ans){\\n        List<String> rowlist = new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String row = \"\";\\n            for(int j=0;j<board[0].length;j++){\\n                row = row+ board[i][j];\\n            }\\n            rowlist.add(row);\\n            \\n        }\\n        ans.add(rowlist);\\n    }\\n    public void solve(int row,int n,char[][] board,boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol,List<List<String>> ans){\\n       if(row==board.length){\\n            add(board,ans);\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                board[row][col]=\\'Q\\';\\n                solve(row+1,n,board,cols,nDiagnol,rDiagnol,ans);\\n                board[row][col]=\\'.\\';\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        boolean[] cols = new boolean[n];\\n        boolean[] ndiag = new boolean[2*n-1];\\n        boolean[] rdiag = new boolean[2*n-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        solve(0,n,board,cols,ndiag,rdiag,ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void add(char[][] board,List<List<String>> ans){\\n        List<String> rowlist = new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String row = \"\";\\n            for(int j=0;j<board[0].length;j++){\\n                row = row+ board[i][j];\\n            }\\n            rowlist.add(row);\\n            \\n        }\\n        ans.add(rowlist);\\n    }\\n    public void solve(int row,int n,char[][] board,boolean[] cols,boolean[] nDiagnol,boolean[] rDiagnol,List<List<String>> ans){\\n       if(row==board.length){\\n            add(board,ans);\\n            return;\\n        }\\n        for(int col=0;col<n;col++){\\n            if(!cols[col] && !nDiagnol[row+col] && !rDiagnol[row-col+n-1]){\\n                cols[col]=true;\\n                nDiagnol[row+col]=true;\\n                rDiagnol[row-col+n-1]=true;\\n                board[row][col]=\\'Q\\';\\n                solve(row+1,n,board,cols,nDiagnol,rDiagnol,ans);\\n                board[row][col]=\\'.\\';\\n                cols[col]=false;\\n                nDiagnol[row+col]=false;\\n                rDiagnol[row-col+n-1]=false;\\n            }\\n        }\\n    }\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        boolean[] cols = new boolean[n];\\n        boolean[] ndiag = new boolean[2*n-1];\\n        boolean[] rdiag = new boolean[2*n-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        List<List<String>> ans = new ArrayList<>();\\n        solve(0,n,board,cols,ndiag,rdiag,ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879073,
                "title": "way-too-detailed-explanation-and-code-c",
                "content": "**General Explanation:**\\nThis problem makes use of backtracking.\\nHow do we know that?\\nWhen we are asked to find all possible enumerations or all possible solutions, then we can assume that backtracking is a safe bet. \\nWhat enumerations are we talking about here?\\nThere are N queens that are to be placed in an N * N board. (without them attacking each other)\\nSo that means that there should be only one queen per row and one queen per collumn and one queen per a diagonal. \\nthere are N rows and N columns. So, we can conclude that each row is going to get one Queen.\\nThe same can be said about every column. \\nNow there are 2 ways to go about this - row wise and column wise. \\nIf we say we are going row wise, we are taking a row at a time and choosing which column to place the Queen on, before going to the next row. \\nSay we have a 4 * 4 grid. And we have to place 4 queens.\\nSo, we start with row=0 and see where all we can place a queen on that row.\\nWe try out all possible columns and check if those are valid or not. If something is not valid, we drop going in that direction.\\n\\n**This is the principle of backtracking:**\\n1. Make a decision/ go down a path\\n2. Check if path is valid by going till end of path. If valid, keep it. else, discard it.\\n3. Undo the decision/ come back to previous path.\\n\\n**How do we solve this problem then?**\\n1. Start with a row ( or a column if you prefer that)\\n2. Loop through columns on that row.\\n3. For each column, place a Queen and recursively go to the next row with this placement.\\n4. If the placement is valid through all our recusions, we will have reached row==N. At that point, add this placement to our result.\\n5. If at any point, we see that the placement is not valid, do nothing and contiue to next step.\\n6. Regardless of the validity of the placement, undo the action. This ensures that the Queen is removed from the current column on the row we are processing. So when we go to the next column on the loop, we can try our luck there.\\n\\n**Code:**\\nThis is our main function that calls our helper method:\\n```\\nvector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> res;\\n        string s(n,\\'.\\');\\n        vector<string> nQueens(n, s);\\n        solveNQueensForRow(n,0,nQueens,res);\\n        return res;\\n    }\\n```\\n\\nWhat are we doing here?\\nWe created a result vector<vector<string>> res.\\neach entry in res is a valid placement of queens and dots. (nQueens)\\neach entry is a vector of strings, each string being the placement for each row. (nQueens)\\n(You caught me. this is why i am going row wise. Its simpler for me).\\nWe then call the function - solveNQueensForRow for row=0, with an nQueens grid filled with dots.\\n\\nThe important function: solveNQueensForRow\\n\\n```\\nvoid solveNQueensForRow(int n, int row, vector<string>& nQueens, vector<vector<string>>& res){\\n        if(row==n) res.push_back(nQueens);\\n        else{\\n            for(int col=0; col<n;col++){\\n                nQueens[row][col]=\\'Q\\';\\n                if(isValid(nQueens,row,col,n)){\\n                    solveNQueensForRow(n,row+1,nQueens,res);\\n                }\\n                nQueens[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n```\\n\\nif we reached row==n, it means we reached all rows. so add the placement (nQueens) to the result.\\nIf we havent reached row=n, then we process that row. \\nFor each column, add a queen there and recursively try to build a valid placement.\\nUndo the action later. \\n\\nChecking if a placement is valid:\\n\\n```\\nbool isValid(vector<string>& nQueens, int r, int c, int n){\\n        //check column\\n        for(int i=0; i<r;++i){\\n            if(nQueens[i][c]==\\'Q\\')\\n                return false;\\n        }\\n        //check first diagonal\\n        for(int i=r-1,j=c-1; i>=0 && j>=0; --i,--j){\\n            if(nQueens[i][j]==\\'Q\\') return false;\\n        }\\n        //second column\\n        for(int i=r-1,j=c+1; i>=0 && j<n; --i,++j){\\n            if(nQueens[i][j]==\\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n```\\n\\nSo we put a Queen at a certain row and at a certain column ( r and c).\\nRemember when we call this function. \\nWe call it when we are processing row r. So it means, that the rows from r+1 to n-1 are not processed yet and they have just dots. So we just have to look at this upper portion from row=0 to row=r.\\n1.Check if any row above the current one has a queen for this column. If yes, return false.\\n(We arent checking for all columns of this row. Thats because we have one queen per row and if we have a queen at the current column, then we havent processed the columns after that and so they are all dots. And the ones before this column also have dots because we always undo our actions)\\n2. There are two diagonals - left and right. The left one goes like this nQueens[r-1][c-1] (check iteratively)\\n3. The right one is NQueens[r-1][c+1] (check iteratively)\\nRemember that we dont have to bother ourselves with r+1 because they are all dots and no Queens. \\n\\nThat\\'s it.\\nIf you have come this far, thanks for putting up with this insanely long text.\\nThanks!",
                "solutionTags": [],
                "code": "```\\nvector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> res;\\n        string s(n,\\'.\\');\\n        vector<string> nQueens(n, s);\\n        solveNQueensForRow(n,0,nQueens,res);\\n        return res;\\n    }\\n```\n```\\nvoid solveNQueensForRow(int n, int row, vector<string>& nQueens, vector<vector<string>>& res){\\n        if(row==n) res.push_back(nQueens);\\n        else{\\n            for(int col=0; col<n;col++){\\n                nQueens[row][col]=\\'Q\\';\\n                if(isValid(nQueens,row,col,n)){\\n                    solveNQueensForRow(n,row+1,nQueens,res);\\n                }\\n                nQueens[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n```\n```\\nbool isValid(vector<string>& nQueens, int r, int c, int n){\\n        //check column\\n        for(int i=0; i<r;++i){\\n            if(nQueens[i][c]==\\'Q\\')\\n                return false;\\n        }\\n        //check first diagonal\\n        for(int i=r-1,j=c-1; i>=0 && j>=0; --i,--j){\\n            if(nQueens[i][j]==\\'Q\\') return false;\\n        }\\n        //second column\\n        for(int i=r-1,j=c+1; i>=0 && j<n; --i,++j){\\n            if(nQueens[i][j]==\\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 869260,
                "title": "javascript-faster-than-96-backtracking-adriel",
                "content": "Following the explanations given at BackToBack SWE I went ahead and implemented the solution in Javascript\\nThe explanation video is here: https://www.youtube.com/watch?v=wGbuCyNpxIg&ab_channel=BackToBackSWE\\n\\n```\\nvar solveNQueens = function(n){\\n  let res = [];\\n  solver(0, new Array(), n, res);\\n  return res;\\n}\\n\\nfunction solver(cur_row, colPlacements, n, res){\\n  // did we reach beyond last row ?\\n  // if so generate a board that matches colPlacements and add it to response\\n  // colPlacement: an array where each index represent a row, and value reprsent a column in that row were we put a queen\\n  // colPlacements may look like this: [1,3,0,2] which means: in row 0 the queen is in col 1, in row 1 the queen is in col 3 , etc...\\n  if(cur_row === n){\\n    let board = generateBoard(n, colPlacements);\\n    res.push(board);\\n    return;\\n  }\\n  // else try to place a queen in every column in the current row\\n  for(let col=0; col<n; col++){\\n    colPlacements.push(col);\\n    // if this is a valid placement, recurse on the next row\\n    // since we can\\'t have 2 queens on the same row\\n    if(isValid(colPlacements)){\\n      solver(cur_row+1, colPlacements, n, res);\\n    }\\n    // if the placement is invalid, or we have explored all the way deep\\n    // then we come back and undo our choice; BACKTRACK\\n    colPlacements.pop();\\n  }\\n}\\n\\nfunction generateBoard(n, colPlacements){\\n  let board = [];\\n  // make row for every queen in placements\\n  for(let row=0; row<colPlacements.length; row++){\\n    let board_row = [];\\n    for(let col=0; col<n; col++){\\n      if(col === colPlacements[row]){\\n        board_row.push(\"Q\");\\n      }\\n      else{\\n        board_row.push(\".\");\\n      }\\n    }\\n    board.push(board_row.join(\"\"));\\n  }\\n  return board;\\n}\\n\\nfunction isValid(colPlacements){\\n  let n = colPlacements.length;\\n  let cur_row = n-1;\\n  // FOR ALL PREV ROWS or QUEENS since each row must have 1 QUEEN\\n  // we only need to validate same col attack and diagonal attack\\n\\n  // 1. for vertical attack the col pos of the queen we just inserted \\n  // will be equal to that of some other existing quens\\n  // 2. For diagonal attack the colDistance and rowDistance will be the same\\n  for(let row=0; row<cur_row; row++){\\n    let colDistance = Math.abs(colPlacements[cur_row]-colPlacements[row]);\\n    let rowDistance = cur_row-row;\\n    if(colDistance===0 || rowDistance===colDistance){\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar solveNQueens = function(n){\\n  let res = [];\\n  solver(0, new Array(), n, res);\\n  return res;\\n}\\n\\nfunction solver(cur_row, colPlacements, n, res){\\n  // did we reach beyond last row ?\\n  // if so generate a board that matches colPlacements and add it to response\\n  // colPlacement: an array where each index represent a row, and value reprsent a column in that row were we put a queen\\n  // colPlacements may look like this: [1,3,0,2] which means: in row 0 the queen is in col 1, in row 1 the queen is in col 3 , etc...\\n  if(cur_row === n){\\n    let board = generateBoard(n, colPlacements);\\n    res.push(board);\\n    return;\\n  }\\n  // else try to place a queen in every column in the current row\\n  for(let col=0; col<n; col++){\\n    colPlacements.push(col);\\n    // if this is a valid placement, recurse on the next row\\n    // since we can\\'t have 2 queens on the same row\\n    if(isValid(colPlacements)){\\n      solver(cur_row+1, colPlacements, n, res);\\n    }\\n    // if the placement is invalid, or we have explored all the way deep\\n    // then we come back and undo our choice; BACKTRACK\\n    colPlacements.pop();\\n  }\\n}\\n\\nfunction generateBoard(n, colPlacements){\\n  let board = [];\\n  // make row for every queen in placements\\n  for(let row=0; row<colPlacements.length; row++){\\n    let board_row = [];\\n    for(let col=0; col<n; col++){\\n      if(col === colPlacements[row]){\\n        board_row.push(\"Q\");\\n      }\\n      else{\\n        board_row.push(\".\");\\n      }\\n    }\\n    board.push(board_row.join(\"\"));\\n  }\\n  return board;\\n}\\n\\nfunction isValid(colPlacements){\\n  let n = colPlacements.length;\\n  let cur_row = n-1;\\n  // FOR ALL PREV ROWS or QUEENS since each row must have 1 QUEEN\\n  // we only need to validate same col attack and diagonal attack\\n\\n  // 1. for vertical attack the col pos of the queen we just inserted \\n  // will be equal to that of some other existing quens\\n  // 2. For diagonal attack the colDistance and rowDistance will be the same\\n  for(let row=0; row<cur_row; row++){\\n    let colDistance = Math.abs(colPlacements[cur_row]-colPlacements[row]);\\n    let rowDistance = cur_row-row;\\n    if(colDistance===0 || rowDistance===colDistance){\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382484,
                "title": "c-backtracking-solution-2-versions-with-clear-comments",
                "content": "This a typical backtracking problem. I did it using two ways.\\nFirst solution is quiet slow(400ms) because of too many overheads.\\nThe baisc idea is : I check every cell(totally N*N cells), every cell I have two choices: either puts a Q or skip it. Before modifying the cell to Q, I need to check whether putting a Q in this cell is a valid operation, if it is, a DFS starts from the next pos.\\n\\nFor a second thought I found one problem: why do I need to check cells instead of checking rows? By definition, each row could only have one Queen! I modified my code and the second version is quiet fast(8 ms). The basic idea is almost the same: for every row, I have N choices, I have to put a Q in this row. Before putting a Q in this row, I need to check whether it is a valid operation, if so, do a DFS starting from the next row. If none of the cells in this row can hold a Queen, this is not a valid solution and just ignore it and go back and do backtracking.\\n```\\n/*\\nSolution 1, check by position, too many overheads!!!\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> temp(n, string(n, \\'.\\'));\\n        solveNQueens(result, temp, 0, n);\\n        return result;\\n    }\\n    void solveNQueens(vector<vector<string>> &result, vector<string> &temp, int pos, int left) {\\n        int n = temp.size();\\n        // goal : we have no queens left, all queens are put in a proper pos\\n        if(left == 0) {\\n            result.push_back(temp);\\n            return;\\n        }\\n        // constrain 1, pos can\\'t be greater than the size of the board\\n        else if(pos >= n*n) return;\\n        int row = pos/n, col = pos%n;\\n        // choice 1, with constrain 2, that is, the queens won\\'t attack each other\\n        if(helper(temp, row, col)) {\\n            temp[row][col] = \\'Q\\';\\n            solveNQueens(result, temp, pos+1, left-1);\\n            temp[row][col] = \\'.\\';\\n        }\\n        // choice 2\\n        solveNQueens(result, temp, pos+1, left);\\n    }\\n    bool helper(vector<string> &temp, int row, int col) {\\n        // check row\\n        for(int i = 0; i < row; ++i) {\\n            if(temp[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check col\\n        for(int i = 0; i < col; ++i) {\\n            if(temp[row][i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check main diagnoal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(temp[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check auxiliary diag\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < temp.size()) {\\n            if(temp[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n/*\\nSolution 2, check by row, much better!!!\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> temp(n, string(n, \\'.\\'));\\n        solveNQueens(result, temp, 0, n);\\n        return result;\\n    }\\n    void solveNQueens(vector<vector<string>> &result, vector<string> &temp, int cur_row, int left) {\\n        // goal : we have no queens left, all queens are put in a proper pos\\n        if(cur_row == temp.size()) {\\n            if(left == 0) {\\n                result.push_back(temp);\\n            }\\n            return;\\n        }\\n        // constrain, before modifying we should make sure this is a valid input\\n        for(int col = 0; col < temp.size(); ++col) {\\n            if(helper(temp, cur_row, col)) {\\n                temp[cur_row][col] = \\'Q\\';\\n                solveNQueens(result, temp, cur_row+1, left-1);\\n                temp[cur_row][col] = \\'.\\';\\n            }\\n        }\\n        // no possible solution\\n        return;\\n    }\\n    bool helper(vector<string> &temp, int row, int col) {\\n        // check row\\n        for(int i = 0; i < row; ++i) {\\n            if(temp[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check col\\n        for(int i = 0; i < col; ++i) {\\n            if(temp[row][i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check main diagnoal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(temp[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check auxiliary diag\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < temp.size()) {\\n            if(temp[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nSolution 1, check by position, too many overheads!!!\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> temp(n, string(n, \\'.\\'));\\n        solveNQueens(result, temp, 0, n);\\n        return result;\\n    }\\n    void solveNQueens(vector<vector<string>> &result, vector<string> &temp, int pos, int left) {\\n        int n = temp.size();\\n        // goal : we have no queens left, all queens are put in a proper pos\\n        if(left == 0) {\\n            result.push_back(temp);\\n            return;\\n        }\\n        // constrain 1, pos can\\'t be greater than the size of the board\\n        else if(pos >= n*n) return;\\n        int row = pos/n, col = pos%n;\\n        // choice 1, with constrain 2, that is, the queens won\\'t attack each other\\n        if(helper(temp, row, col)) {\\n            temp[row][col] = \\'Q\\';\\n            solveNQueens(result, temp, pos+1, left-1);\\n            temp[row][col] = \\'.\\';\\n        }\\n        // choice 2\\n        solveNQueens(result, temp, pos+1, left);\\n    }\\n    bool helper(vector<string> &temp, int row, int col) {\\n        // check row\\n        for(int i = 0; i < row; ++i) {\\n            if(temp[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check col\\n        for(int i = 0; i < col; ++i) {\\n            if(temp[row][i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check main diagnoal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(temp[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check auxiliary diag\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < temp.size()) {\\n            if(temp[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n/*\\nSolution 2, check by row, much better!!!\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> temp(n, string(n, \\'.\\'));\\n        solveNQueens(result, temp, 0, n);\\n        return result;\\n    }\\n    void solveNQueens(vector<vector<string>> &result, vector<string> &temp, int cur_row, int left) {\\n        // goal : we have no queens left, all queens are put in a proper pos\\n        if(cur_row == temp.size()) {\\n            if(left == 0) {\\n                result.push_back(temp);\\n            }\\n            return;\\n        }\\n        // constrain, before modifying we should make sure this is a valid input\\n        for(int col = 0; col < temp.size(); ++col) {\\n            if(helper(temp, cur_row, col)) {\\n                temp[cur_row][col] = \\'Q\\';\\n                solveNQueens(result, temp, cur_row+1, left-1);\\n                temp[cur_row][col] = \\'.\\';\\n            }\\n        }\\n        // no possible solution\\n        return;\\n    }\\n    bool helper(vector<string> &temp, int row, int col) {\\n        // check row\\n        for(int i = 0; i < row; ++i) {\\n            if(temp[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check col\\n        for(int i = 0; i < col; ++i) {\\n            if(temp[row][i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check main diagnoal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(temp[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check auxiliary diag\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < temp.size()) {\\n            if(temp[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193774,
                "title": "javascript-backtrack-with-comments",
                "content": "```\\nvar solveNQueens = function(n) {\\n    //create empty chess board\\n    //String in javascript is immutable, so here I use 2D array for chess board\\n    var chessBoard = new Array(n);\\n    for(var i = 0; i < n; i++) {\\n        chessBoard[i] = new Array(n).fill(\".\");\\n    }\\n    \\n    var result = [];\\n    \\n    var isValidQueen = function(row, col) {\\n        //check for spots above on this column\\n        for(let i = 0; i < row; i++) {\\n            if(chessBoard[i][col] === \"Q\") return false;\\n        }\\n        //check for up left\\n        for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if(chessBoard[i][j] === \"Q\") return false;\\n        }\\n        //check for up right\\n        for(let i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {\\n            if(chessBoard[i][j] === \"Q\") return false;\\n        }\\n        return true;\\n    }\\n    \\n    var backtrack = function(row) {\\n        if(row === n) {\\n            result.push([...chessBoard].map(row => row.join(\\'\\')));\\n            return;\\n        }\\n        for(var col = 0; col < n; col++) {\\n            if(isValidQueen(row, col)) {\\n                chessBoard[row][col] = \"Q\";\\n                backtrack(row + 1);\\n                chessBoard[row][col] = \".\";\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solveNQueens = function(n) {\\n    //create empty chess board\\n    //String in javascript is immutable, so here I use 2D array for chess board\\n    var chessBoard = new Array(n);\\n    for(var i = 0; i < n; i++) {\\n        chessBoard[i] = new Array(n).fill(\".\");\\n    }\\n    \\n    var result = [];\\n    \\n    var isValidQueen = function(row, col) {\\n        //check for spots above on this column\\n        for(let i = 0; i < row; i++) {\\n            if(chessBoard[i][col] === \"Q\") return false;\\n        }\\n        //check for up left\\n        for(let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if(chessBoard[i][j] === \"Q\") return false;\\n        }\\n        //check for up right\\n        for(let i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {\\n            if(chessBoard[i][j] === \"Q\") return false;\\n        }\\n        return true;\\n    }\\n    \\n    var backtrack = function(row) {\\n        if(row === n) {\\n            result.push([...chessBoard].map(row => row.join(\\'\\')));\\n            return;\\n        }\\n        for(var col = 0; col < n; col++) {\\n            if(isValidQueen(row, col)) {\\n                chessBoard[row][col] = \"Q\";\\n                backtrack(row + 1);\\n                chessBoard[row][col] = \".\";\\n            }\\n        }\\n    }\\n    backtrack(0);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 19937,
                "title": "ac-python-76-ms-iterative-backtracking-solution",
                "content": "N-Queens problem is a typical application of backtracking algorithm. For backtracking, we need to figure out a way to represent the candidates, a way to generate all the possible candidates and accept those valid and reject those invalid.\\n\\nIn this solution, the representation of the candidate is a column vector \"queens\", where i = queen[j] is the column index of the queen in row j. Under this representation, the way to generate all candidates is just like generate all the permutation of vector [0...n-1].\\n\\nNow the rest problem is to efficiently verify the candidate. By definition, two queens cannot be in the same row or same column or same back or forward slash lines. Our representation is already making sure there would never be two queens in a row.  Therefore we only need 3 dynamic sets to maintain the currently available column, back and forward slash lines.\\n\\n> (1) The id of a column is its index range from 0 to n-1.\\n> \\n> (2) The id of a back slash line \"\\\\\" is \"col - row\" or \"x - y\" \\n> \\n> (3) The id of a forward slash line \"/\" is \"col + row\" or \"x + y\"\\n\\nThis way we can reject a candidate in O(1) time since we can use three hash tables or three boolean arrays as the dynamic sets we need.\\n\\n\\n    def solveNQueens(self, n):\\n        ans = []\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        row = col = 0\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n                if row == n:\\n                    ans.append(['.' * q + 'Q' + '.' * (n - q - 1) for q in queens])\\n            else:\\n                if row == n or col == n:\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n\\n    # 9 / 9 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 98.45%",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Iterator"
                ],
                "code": "N-Queens problem is a typical application of backtracking algorithm. For backtracking, we need to figure out a way to represent the candidates, a way to generate all the possible candidates and accept those valid and reject those invalid.\\n\\nIn this solution, the representation of the candidate is a column vector \"queens\", where i = queen[j] is the column index of the queen in row j. Under this representation, the way to generate all candidates is just like generate all the permutation of vector [0...n-1].\\n\\nNow the rest problem is to efficiently verify the candidate. By definition, two queens cannot be in the same row or same column or same back or forward slash lines. Our representation is already making sure there would never be two queens in a row.  Therefore we only need 3 dynamic sets to maintain the currently available column, back and forward slash lines.\\n\\n> (1) The id of a column is its index range from 0 to n-1.\\n> \\n> (2) The id of a back slash line \"\\\\\" is \"col - row\" or \"x - y\" \\n> \\n> (3) The id of a forward slash line \"/\" is \"col + row\" or \"x + y\"\\n\\nThis way we can reject a candidate in O(1) time since we can use three hash tables or three boolean arrays as the dynamic sets we need.\\n\\n\\n    def solveNQueens(self, n):\\n        ans = []\\n        queens = [-1] * n\\n        columns = [True] * n + [False]  # || col with dummy for boundary\\n        back = [True] * n * 2  # \\\\\\\\ col - row\\n        forward = [True] * n * 2  # // col + row\\n        row = col = 0\\n        while True:\\n            if columns[col] and back[col - row + n] and forward[col + row]:\\n                queens[row] = col\\n                columns[col] = back[col - row + n] = forward[col + row] = False\\n                row += 1\\n                col = 0\\n                if row == n:\\n                    ans.append(['.' * q + 'Q' + '.' * (n - q - 1) for q in queens])\\n            else:\\n                if row == n or col == n:\\n                    if row == 0:\\n                        return ans\\n                    row -= 1\\n                    col = queens[row]\\n                    columns[col] = back[col - row + n] = forward[col + row] = True\\n                col += 1\\n\\n\\n    # 9 / 9 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 98.45%",
                "codeTag": "Python3"
            },
            {
                "id": 1551695,
                "title": "java-tc-o-n-n-sc-o-n-space-optimized-backtracking-using-bitset",
                "content": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Also, if there are S(N) solutions, then time taken to generate these solution will be N^2 * S(N).\\n * Here number of solutions will be much less than the total number of permutations.\\n * Thus we can ignore the time taken for generating and adding the board in the result list.\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for queensPos arr\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid board\");\\n        }\\n\\n        List<List<String>> result = new ArrayList<>();\\n        solveNQueensHelper(result, new int[n], new BitSet(5 * n), 0);\\n        return result;\\n    }\\n\\n    private void solveNQueensHelper(List<List<String>> result, int[] queensPos, BitSet occupied, int row) {\\n        int n = queensPos.length;\\n        if (row == n) {\\n            result.add(generateResultBoard(queensPos));\\n            return;\\n        }\\n\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n            queensPos[row] = col;\\n\\n            solveNQueensHelper(result, queensPos, occupied, row + 1);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n    }\\n\\n    private List<String> generateResultBoard(int[] queensPos) {\\n        List<String> temp = new ArrayList<>();\\n        char[] b = new char[queensPos.length];\\n        Arrays.fill(b, \\'.\\');\\n        for (int q : queensPos) {\\n            b[q] = \\'Q\\';\\n            temp.add(new String(b));\\n            b[q] = \\'.\\';\\n        }\\n        return temp;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other N-Queens questions on LeetCode:\\n- [52. N-Queens II](https://leetcode.com/problems/n-queens-ii/discuss/1551698/Java-or-TC:-O(N*N!)-or-SC:-O(N)-or-Space-Optimized-Backtracking-using-BitSet)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Space Optimized Backtracking\\n *\\n * Total number of permutations can be found by this equation\\n * T(N) = N * T(N-1) + O(N)\\n * T(N-1) = (N-1) * T(N-2) + O(N)\\n * T(N-2) = (N-2) * T(N-3) + O(N)\\n * T(N-3) = (N-3) * T(N-4) + O(N)\\n * ...\\n * T(2) = 2 * T(1) + O(N)\\n * T(1) = O(1)\\n * Thus total number of permutations\\n *      = N * (P(N,0) + P(N,1) + ... + P(N, N-2)) + P(N,N-1)\\n *      = N * (e * N! - P(N,N-1) - P(N,N)) + N!\\n *      = ((e-2)*N + 1) * N! = (0.718 * N + 1) * N!\\n *\\n * Also, if there are S(N) solutions, then time taken to generate these solution will be N^2 * S(N).\\n * Here number of solutions will be much less than the total number of permutations.\\n * Thus we can ignore the time taken for generating and adding the board in the result list.\\n *\\n * Total Time Complexity = O(N * N!)\\n *\\n * Space Complexity:\\n * -> O(N) for queensPos arr\\n * -> O(N) for recursion depth\\n * -> O(1) for occupied BitSet\\n *\\n * Total Space Complexity = O(N)\\n *\\n * N = Input board size.\\n */\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid board\");\\n        }\\n\\n        List<List<String>> result = new ArrayList<>();\\n        solveNQueensHelper(result, new int[n], new BitSet(5 * n), 0);\\n        return result;\\n    }\\n\\n    private void solveNQueensHelper(List<List<String>> result, int[] queensPos, BitSet occupied, int row) {\\n        int n = queensPos.length;\\n        if (row == n) {\\n            result.add(generateResultBoard(queensPos));\\n            return;\\n        }\\n\\n        for (int col = 0; col < n; col++) {\\n            // First N bits are for columns\\n            // Then 2*N bits are for diagonal at 45 degrees\\n            // Then 2*N bits are for diagonal at 135 degrees\\n            int diag45 = n + (row + col);\\n            int diag135 = 3 * n + (n + row - col);\\n            if (occupied.get(col) || occupied.get(diag45) || occupied.get(diag135)) {\\n                continue;\\n            }\\n\\n            occupied.set(col);\\n            occupied.set(diag45);\\n            occupied.set(diag135);\\n            queensPos[row] = col;\\n\\n            solveNQueensHelper(result, queensPos, occupied, row + 1);\\n\\n            occupied.clear(col);\\n            occupied.clear(diag45);\\n            occupied.clear(diag135);\\n        }\\n    }\\n\\n    private List<String> generateResultBoard(int[] queensPos) {\\n        List<String> temp = new ArrayList<>();\\n        char[] b = new char[queensPos.length];\\n        Arrays.fill(b, \\'.\\');\\n        for (int q : queensPos) {\\n            b[q] = \\'Q\\';\\n            temp.add(new String(b));\\n            b[q] = \\'.\\';\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19860,
                "title": "93-concise-fast-and-clear-java-solution",
                "content": "The code has comment.\\n\\n    public class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            boolean[] \\n                //ocp0 = new boolean[n], //whether there's a queen ocupying nth row, I don't need it\\n                ocp90 = new boolean[n], //whether there's a queen ocupying nth column\\n                ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation\\n                ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation\\n            List<List<String>> ans = new ArrayList<List<String>>();\\n            char[][] map = new char[n][n];\\n            for (char[] tmp : map) Arrays.fill(tmp, '.'); //init\\n            \\n            solve(0, n, map, ans, ocp45, ocp90, ocp135);\\n            return ans;\\n        }\\n        \\n        private void solve(int depth, int n, char[][] map, List<List<String>> ans, \\n        boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) {\\n            if (depth == n) {\\n                addSolution(ans, map);\\n                return;\\n            }\\n            \\n            for (int j = 0; j < n; j++)\\n                if (!ocp90[j] && !ocp45[depth + j] && !ocp135[j - depth + n - 1]) {\\n                    ocp90[j] = true;\\n                    ocp45[depth + j] = true;\\n                    ocp135[j - depth + n - 1] = true;\\n                    map[depth][j] = 'Q';\\n                    solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135);\\n                    ocp90[j] = false;\\n                    ocp45[depth + j] = false;\\n                    ocp135[j - depth + n - 1] = false;\\n                    map[depth][j] = '.';\\n                }\\n        }\\n        \\n        private void addSolution(List<List<String>> ans, char[][] map) {\\n            List<String> cur = new ArrayList<String>();\\n            for (char[] i : map) cur.add(String.valueOf(i));\\n            ans.add(cur);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<String>> solveNQueens(int n) {\\n            boolean[] \\n                //ocp0 = new boolean[n], //whether there's a queen ocupying nth row, I don't need it\\n                ocp90 = new boolean[n], //whether there's a queen ocupying nth column\\n                ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation\\n                ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation\\n            List<List<String>> ans = new ArrayList<List<String>>();\\n            char[][] map = new char[n][n];\\n            for (char[] tmp : map) Arrays.fill(tmp, '.'); //init\\n            \\n            solve(0, n, map, ans, ocp45, ocp90, ocp135);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 19945,
                "title": "java-when-you-are-familiar-with-backtracking-you-ll-find-this-solution-straightforward-5ms-beats-84",
                "content": "Core idea: greedy + backtracking.\\n\\nA little bit more words:\\n\\n - Put `Q` in the board column after column starting from the first column (`col=1`)\\n - Check if it is safe to put `Q` at current location `(row, col)`\\n - If safe, put `Q` at `(row, col)` (greedy part) and move to next column and check if safe\\n - If no row in next column is safe, meaning we can not put `Q` at `(row, col)`, so remove `Q` (backtracking part) and continue, i.e., check `(row+1, col)` if `row<N` or remove `Q` at previous column, etc.\\n - If `col` gets to `N`, meaning we are done filling all `N` queens. In this case, add board into `res`. And return `false` so that it will backtrack as illustrated in the last step.\\n - keep running till exhausted, i.e., backtracked to last row, first column\\n\\n\\nCode in Java:\\n\\n\\n    public List<List<String>> solveNQueens(int N) {\\n\\t\\tList<List<String>> res = new ArrayList<List<String>>();\\n    \\tif(N<1) return res;\\n\\t\\tchar[][] board = new char[N][N];\\n\\t\\tfor(char[] row : board) {\\n\\t\\t\\tfor(int j=0; j<N; j++) {\\n\\t\\t\\t\\trow[j] = '.';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsolve(board, N, 0, res);\\n\\t\\treturn res;\\n\\t}\\n\\tprivate boolean solve(char[][] board, int N, int col, List<List<String>> res) {\\n\\t\\tif(col==N) { // done soving, simply add the board into the result\\n\\t\\t\\tList<String> list = new ArrayList<String>();\\n\\t        for(int i = 0; i < N; i++) {\\n\\t            list.add(String.valueOf(board[i]));\\n\\t        }\\n\\t\\t\\tres.add(list);\\n\\t\\t\\treturn false; // return false so will backtrack\\n\\t\\t}\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tif(isSafe(board, N, i, col)) {\\n\\t\\t\\t\\tboard[i][col] = 'Q'; // greedy\\n\\t\\t\\t\\tif(solve(board, N, col+1, res)) return true;\\n\\t\\t\\t\\telse board[i][col] = '.'; // backtrack\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean isSafe(char[][] board, int N, int row, int col) {\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tif(board[i][col]!='.') return false;\\n\\t\\t\\tif(board[row][i]!='.') return false;\\n\\t\\t}\\n\\t\\tint step = 1;\\n\\t\\twhile(row-step>=0 && col-step>=0)\\n\\t\\t\\tif(board[row-step][col-step++]!='.') return false;\\n\\t\\tstep = 1;\\n\\t\\twhile(row+step<N && col-step>=0)\\n\\t\\t\\tif(board[row+step][col-step++]!='.') return false;\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "Core idea: greedy + backtracking.\\n\\nA little bit more words:\\n\\n - Put `Q` in the board column after column starting from the first column (`col=1`)\\n - Check if it is safe to put `Q` at current location `(row, col)`\\n - If safe, put `Q` at `(row, col)` (greedy part) and move to next column and check if safe\\n - If no row in next column is safe, meaning we can not put `Q` at `(row, col)`, so remove `Q` (backtracking part) and continue, i.e., check `(row+1, col)` if `row<N` or remove `Q` at previous column, etc.\\n - If `col` gets to `N`, meaning we are done filling all `N` queens. In this case, add board into `res`. And return `false` so that it will backtrack as illustrated in the last step.\\n - keep running till exhausted, i.e., backtracked to last row, first column\\n\\n\\nCode in Java:\\n\\n\\n    public List<List<String>> solveNQueens(int N) {\\n\\t\\tList<List<String>> res = new ArrayList<List<String>>();\\n    \\tif(N<1) return res;\\n\\t\\tchar[][] board = new char[N][N];\\n\\t\\tfor(char[] row : board) {\\n\\t\\t\\tfor(int j=0; j<N; j++) {\\n\\t\\t\\t\\trow[j] = '.';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsolve(board, N, 0, res);\\n\\t\\treturn res;\\n\\t}\\n\\tprivate boolean solve(char[][] board, int N, int col, List<List<String>> res) {\\n\\t\\tif(col==N) { // done soving, simply add the board into the result\\n\\t\\t\\tList<String> list = new ArrayList<String>();\\n\\t        for(int i = 0; i < N; i++) {\\n\\t            list.add(String.valueOf(board[i]));\\n\\t        }\\n\\t\\t\\tres.add(list);\\n\\t\\t\\treturn false; // return false so will backtrack\\n\\t\\t}\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tif(isSafe(board, N, i, col)) {\\n\\t\\t\\t\\tboard[i][col] = 'Q'; // greedy\\n\\t\\t\\t\\tif(solve(board, N, col+1, res)) return true;\\n\\t\\t\\t\\telse board[i][col] = '.'; // backtrack\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\tprivate boolean isSafe(char[][] board, int N, int row, int col) {\\n\\t\\tfor(int i=0; i<N; i++) {\\n\\t\\t\\tif(board[i][col]!='.') return false;\\n\\t\\t\\tif(board[row][i]!='.') return false;\\n\\t\\t}\\n\\t\\tint step = 1;\\n\\t\\twhile(row-step>=0 && col-step>=0)\\n\\t\\t\\tif(board[row-step][col-step++]!='.') return false;\\n\\t\\tstep = 1;\\n\\t\\twhile(row+step<N && col-step>=0)\\n\\t\\t\\tif(board[row+step][col-step++]!='.') return false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2790998,
                "title": "n-queens-solution-with-explanation-recursions-and-backtracking",
                "content": "```\\n//Approach :- we have two options to fill queen in n*n matrix either start filling each queen in row and move to next row\\n//till last row i.e. row wise or we can start filling each queen in column and move to next column i.e. column wise \\n\\n//let\\'s fill row wise and we are doing this by the help of recursion but why recursion?\\n//because we have to try every possible way to place queen in safe position and when there is \"try every possibility\" recursion is most suitable one.\\n\\nEXAMPLE:-\\n//suppose two row is already filled with \\'Q\\' in 4*4 matrix\\n                      0  1  2  3\\n row = 1st        0 | Q  -  -  - |\\nrow = 2nd         1 | -  -  Q  - |\\n row = 3rd\\t      2 | -  -  -  - |\\nrow = 4th\\t      3 | -  -  -  - |\\n\\n//for placing Q in 3rd row we need to find safe place :- we can see that we can\\'t place Q in 1st place of 3rd row because at row 1st there is a\\n//queen at 1st place same as we can\\'t place Q at 2nd place in 3rd row because in diagonal of that cell has Q at row 2nd\\n\\n// so before placing Q first check is it safe cell or not to place\\n//and this can be done by checking three condition\\n\\n     1.Left didonal        2.column          3.right digonal                  \\n\\t\\t\\t  \\\\\\t\\t\\t\\t   |              /\\n\\t       0 | [\\\\]  [-]  [-]  [|]  [-]  [-]|/\\n           1 | [-]  [\\\\]  [-]  [|]  [-]  [/]|\\n\\t       2 | [-]  [-]  [\\\\]  [|]  [/]  [-]|\\n\\t       3 | [-]  [-]  [-]  [Q]  [-]  [-]|\\n\\t\\t   4 | [-]  [-]  [-]  [-]  [-]  [-]|\\n\\t\\t   5 | [-]  [-]  [-]  [-]  [-]  [-]|\\n```\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<>();\\n        char[][] board = new char[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        help(0,n,ans,board);\\n        return ans;\\n        \\n    }\\n    void help(int i, int n,List<List<String>> ans,char[][] board)\\n    {\\n        //BASE CASE\\n        if(i==n){\\n            List<String> temp = new ArrayList<>();\\n            for(int j=0; j<n;j++){\\n                String s = new String(board[j]);\\n                temp.add(s);\\n            }\\n            ans.add(temp);\\n            return;\\n        }\\n        \\n        //RECURSION\\n        for(int j=0; j<n; j++){\\n            if(isSafe(i,j,board,n)){\\n                board[i][j] = \\'Q\\';\\n                help(i+1,n,ans,board);\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    boolean isSafe(int i,int j,char[][] board,int n)\\n    {\\n        //up\\n        int tempi = i;\\n        while(tempi>=0){\\n            if(board[tempi][j] == \\'Q\\')\\n                return false;\\n            tempi--;\\n        }\\n        \\n        //Right Diagonal\\n        tempi = i;\\n        int tempj = j;\\n        while(tempi>=0 && tempj<=n-1){\\n            if(board[tempi][tempj] == \\'Q\\')\\n                return false;\\n            tempi--;\\n            tempj++;\\n         }\\n        \\n        //left diagonal\\n         tempi = i;\\n        tempj = j;\\n        while(tempi>=0 && tempj>=0){\\n            if(board[tempi][tempj] == \\'Q\\')\\n                return false;\\n            tempi--;\\n            tempj--;\\n         }\\n        return true;\\n    }\\n}\\n```\\n```\\n//we can make constant time for isSafe() \\n\\n\\t\\t   \\n1. Column :- maintain an array where each index represent each vertical column\\n                  \\n      arr  = | 1  0  1  0 |\\n\\t  index =  0  1  2  3\\n\\t           |  |  |  |\\n\\t\\t\\t   |  |  |  |\\n\\t           0  1  2  3\\n           0 | Q  -  -  - |\\n           1 | -  -  Q  - |\\n           2 | -  -  -  - |\\n           3 | -  -  -  - |\\n// in arr[] \\'1\\' represent ----> that index column contains Q in Matrix \\n\\n2. Right Digonal :-  row + col\\n                                                                            0  1  2  3\\n          j =  0  1  2  3                                                   /  /  /  /    4\\n       i=  0 | -  -  -  - |                   matrix[i][j] =  (i+j)      | 0  1  2  3| /  5\\n           1 | -  -  -  - |                        -------->             | 1  2  3  4| /  6\\n           2 | -  -  -  - |                                              | 2  3  4  5| /\\n           3 | -  -  -  - |                                              | 3  4  5  6|\\n\\t\\t      \\n//now we can make an array of size[i+j] and each index represent each digonal\\n\\t           0  1  2  3      4\\n           0 | -  -  -  - | /  5\\n           1 | -  Q  -  - | /  6\\n           2 | -  -  -  Q | /                          arr[0  0  1  0  0  1  0]\\n           3 | -  -  -  - |                          index 0  1  2  3  4  5  6\\n\\t\\t   \\n3. Left Digonal :-  (row - col) + (n-1)\\n                                                                    3   2  1  0\\n          j =  0  1  2  3                                        4    \\\\  \\\\  \\\\  \\\\    \\n       i=  0 | -  -  -  - |  matrix[i][j] = (row - col) + (n-1) 5   \\\\ | 3  2  1  0|\\n           1 | -  -  -  - |                     -------->       6  \\\\  | 4  3  2  1|\\n           2 | -  -  -  - |                                       \\\\   | 5  4  3  2|\\n           3 | -  -  -  - |                                           | 6  5  4  3|\\n\\t\\t      \\n//now we can make an array of size[i+j] and each index represent each digonal\\n\\t            \\n            | Q  -  -  - |\\n            | -  -  Q  - |\\n            | -  -  -  - |                          arr[0  0  0  1  1  0  0]\\n            | -  -  -  - |                          index 0  1  2  3  4  5  6\\t\\t   \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n//Approach :- we have two options to fill queen in n*n matrix either start filling each queen in row and move to next row\\n//till last row i.e. row wise or we can start filling each queen in column and move to next column i.e. column wise \\n\\n//let\\'s fill row wise and we are doing this by the help of recursion but why recursion?\\n//because we have to try every possible way to place queen in safe position and when there is \"try every possibility\" recursion is most suitable one.\\n\\nEXAMPLE:-\\n//suppose two row is already filled with \\'Q\\' in 4*4 matrix\\n                      0  1  2  3\\n row = 1st        0 | Q  -  -  - |\\nrow = 2nd         1 | -  -  Q  - |\\n row = 3rd\\t      2 | -  -  -  - |\\nrow = 4th\\t      3 | -  -  -  - |\\n\\n//for placing Q in 3rd row we need to find safe place :- we can see that we can\\'t place Q in 1st place of 3rd row because at row 1st there is a\\n//queen at 1st place same as we can\\'t place Q at 2nd place in 3rd row because in diagonal of that cell has Q at row 2nd\\n\\n// so before placing Q first check is it safe cell or not to place\\n//and this can be done by checking three condition\\n\\n     1.Left didonal        2.column          3.right digonal                  \\n\\t\\t\\t  \\\\\\t\\t\\t\\t   |              /\\n\\t       0 | [\\\\]  [-]  [-]  [|]  [-]  [-]|/\\n           1 | [-]  [\\\\]  [-]  [|]  [-]  [/]|\\n\\t       2 | [-]  [-]  [\\\\]  [|]  [/]  [-]|\\n\\t       3 | [-]  [-]  [-]  [Q]  [-]  [-]|\\n\\t\\t   4 | [-]  [-]  [-]  [-]  [-]  [-]|\\n\\t\\t   5 | [-]  [-]  [-]  [-]  [-]  [-]|\\n```\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<>();\\n        char[][] board = new char[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        help(0,n,ans,board);\\n        return ans;\\n        \\n    }\\n    void help(int i, int n,List<List<String>> ans,char[][] board)\\n    {\\n        //BASE CASE\\n        if(i==n){\\n            List<String> temp = new ArrayList<>();\\n            for(int j=0; j<n;j++){\\n                String s = new String(board[j]);\\n                temp.add(s);\\n            }\\n            ans.add(temp);\\n            return;\\n        }\\n        \\n        //RECURSION\\n        for(int j=0; j<n; j++){\\n            if(isSafe(i,j,board,n)){\\n                board[i][j] = \\'Q\\';\\n                help(i+1,n,ans,board);\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    boolean isSafe(int i,int j,char[][] board,int n)\\n    {\\n        //up\\n        int tempi = i;\\n        while(tempi>=0){\\n            if(board[tempi][j] == \\'Q\\')\\n                return false;\\n            tempi--;\\n        }\\n        \\n        //Right Diagonal\\n        tempi = i;\\n        int tempj = j;\\n        while(tempi>=0 && tempj<=n-1){\\n            if(board[tempi][tempj] == \\'Q\\')\\n                return false;\\n            tempi--;\\n            tempj++;\\n         }\\n        \\n        //left diagonal\\n         tempi = i;\\n        tempj = j;\\n        while(tempi>=0 && tempj>=0){\\n            if(board[tempi][tempj] == \\'Q\\')\\n                return false;\\n            tempi--;\\n            tempj--;\\n         }\\n        return true;\\n    }\\n}\\n```\n```\\n//we can make constant time for isSafe() \\n\\n\\t\\t   \\n1. Column :- maintain an array where each index represent each vertical column\\n                  \\n      arr  = | 1  0  1  0 |\\n\\t  index =  0  1  2  3\\n\\t           |  |  |  |\\n\\t\\t\\t   |  |  |  |\\n\\t           0  1  2  3\\n           0 | Q  -  -  - |\\n           1 | -  -  Q  - |\\n           2 | -  -  -  - |\\n           3 | -  -  -  - |\\n// in arr[] \\'1\\' represent ----> that index column contains Q in Matrix \\n\\n2. Right Digonal :-  row + col\\n                                                                            0  1  2  3\\n          j =  0  1  2  3                                                   /  /  /  /    4\\n       i=  0 | -  -  -  - |                   matrix[i][j] =  (i+j)      | 0  1  2  3| /  5\\n           1 | -  -  -  - |                        -------->             | 1  2  3  4| /  6\\n           2 | -  -  -  - |                                              | 2  3  4  5| /\\n           3 | -  -  -  - |                                              | 3  4  5  6|\\n\\t\\t      \\n//now we can make an array of size[i+j] and each index represent each digonal\\n\\t           0  1  2  3      4\\n           0 | -  -  -  - | /  5\\n           1 | -  Q  -  - | /  6\\n           2 | -  -  -  Q | /                          arr[0  0  1  0  0  1  0]\\n           3 | -  -  -  - |                          index 0  1  2  3  4  5  6\\n\\t\\t   \\n3. Left Digonal :-  (row - col) + (n-1)\\n                                                                    3   2  1  0\\n          j =  0  1  2  3                                        4    \\\\  \\\\  \\\\  \\\\    \\n       i=  0 | -  -  -  - |  matrix[i][j] = (row - col) + (n-1) 5   \\\\ | 3  2  1  0|\\n           1 | -  -  -  - |                     -------->       6  \\\\  | 4  3  2  1|\\n           2 | -  -  -  - |                                       \\\\   | 5  4  3  2|\\n           3 | -  -  -  - |                                           | 6  5  4  3|\\n\\t\\t      \\n//now we can make an array of size[i+j] and each index represent each digonal\\n\\t            \\n            | Q  -  -  - |\\n            | -  -  Q  - |\\n            | -  -  -  - |                          arr[0  0  0  1  1  0  0]\\n            | -  -  -  - |                          index 0  1  2  3  4  5  6\\t\\t   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909453,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path)  }\\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.map({ (path: [Int]) -> [String] in\\n            var res: [String] = []\\n            for i in path {\\n                var string = \"\"\\n                for j in 0..<n { string += (i == j ? \"Q\" : \".\") }\\n                res.append(string)\\n            }\\n            return res\\n        })\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path)  }\\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.map({ (path: [Int]) -> [String] in\\n            var res: [String] = []\\n            for i in path {\\n                var string = \"\"\\n                for j in 0..<n { string += (i == j ? \"Q\" : \".\") }\\n                res.append(string)\\n            }\\n            return res\\n        })\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041503,
                "title": "c-solution-run-time-4ms-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> result;\\n    bool issafe(vector<string>&board,int x,int y){\\n       // for check in column\\n       int n=board.size();\\n       for(int row=0;row<x;row++){\\n            if(board[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n       }\\n\\n       // for checking in left diagonal\\n       int row=x-1,col=y-1;\\n       while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--; col--;\\n       }\\n\\n       // for checking in right diagonal\\n        row=x-1;\\n        col=y+1;\\n       while(row>=0 && col<n){\\n            if(board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--; col++;\\n       }\\n        //if all condition satisfied returning true;\\n       return true;\\n    }\\n\\n\\n    void backtrack(int row , int n,vector<string>&curr) {\\n        if(row == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int col=0;col<n;col++) {\\n            if(issafe(curr,row,col)) {\\n                curr[row][col] = \\'Q\\';\\n                //recursive call to next row;\\n                backtrack(row+1,n,curr);\\n                //backtracting\\n                //before backtracking we are change the location with previous value \\n                curr[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        return;\\n    }\\n     \\n    vector<vector<string>> solveNQueens(int n) {\\n        string s;\\n        for(int i=0;i<n;i++) \\n            s.push_back(\\'.\\');\\n        vector<string> curr(n,s);\\n        backtrack(0,n,curr);\\n        return result;\\n    }\\n};\\n```\\n\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> result;\\n    bool issafe(vector<string>&board,int x,int y){\\n       // for check in column\\n       int n=board.size();\\n       for(int row=0;row<x;row++){\\n            if(board[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n       }\\n\\n       // for checking in left diagonal\\n       int row=x-1,col=y-1;\\n       while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--; col--;\\n       }\\n\\n       // for checking in right diagonal\\n        row=x-1;\\n        col=y+1;\\n       while(row>=0 && col<n){\\n            if(board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--; col++;\\n       }\\n        //if all condition satisfied returning true;\\n       return true;\\n    }\\n\\n\\n    void backtrack(int row , int n,vector<string>&curr) {\\n        if(row == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        \\n        for(int col=0;col<n;col++) {\\n            if(issafe(curr,row,col)) {\\n                curr[row][col] = \\'Q\\';\\n                //recursive call to next row;\\n                backtrack(row+1,n,curr);\\n                //backtracting\\n                //before backtracking we are change the location with previous value \\n                curr[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n        return;\\n    }\\n     \\n    vector<vector<string>> solveNQueens(int n) {\\n        string s;\\n        for(int i=0;i<n;i++) \\n            s.push_back(\\'.\\');\\n        vector<string> curr(n,s);\\n        backtrack(0,n,curr);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370521,
                "title": "n-queen-c-code-easy-to-understand-and-implement-backtracking",
                "content": "class Solution {\\npublic:\\n    void display(vector<vector<bool>>& chess,vector<vector<string>>& result){\\n        vector<string>subResult;\\n        string k;\\n        for(int i=0;i<chess.size();i++){\\n            k=\"\";\\n            for(int j=0;j<chess.size();j++){\\n                if(chess[i][j]==true){\\n                    k+=\"Q\";\\n                }\\n                else{\\n                   k+=\".\";\\n                }\\n            }\\n            subResult.push_back(k);\\n        }\\n        result.push_back(subResult);\\n    }\\n    bool isSafe(vector<vector<bool>>& chess,int row,int col){\\n        //For column\\n        for(int i=row-1;i>=0;i--){\\n            if(chess[i][col]==true)\\n                return false;\\n        }   \\n        // For Diagonals\\n        for(int i=row-1,j=col+1;i>=0 && j<chess.size();i--,j++){\\n            if(chess[i][j]==true)\\n                return false;\\n        }\\n        for(int i=row-1,j=col-1;i>=0 && j>=0 ; i--,j--){\\n            if(chess[i][j]==true)\\n                return false;\\n        }\\n        return true;\\n    } \\n    void printQueen(vector<vector<bool>>& chess,vector<vector<string>>& result,int row){\\n        if(row==chess.size()){\\n            display(chess,result);\\n            return ;\\n        }\\n        for(int col=0;col<chess.size();col++){\\n            if(isSafe(chess,row,col)){\\n                chess[row][col]=true;\\n                printQueen(chess,result,row+1);\\n                chess[row][col]=false;\\n            }\\n        }\\n    }    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>>result;\\n        vector<vector<bool>>chess(n,vector<bool>(n,false));\\n        printQueen(chess,result,0);     \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void display(vector<vector<bool>>& chess,vector<vector<string>>& result){\\n        vector<string>subResult;\\n        string k;\\n        for(int i=0;i<chess.size();i++){\\n            k=\"\";\\n            for(int j=0;j<chess.size();j++){\\n                if(chess[i][j]==true){\\n                    k+=\"Q\";\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1324136,
                "title": "java-2ms-sol-standard-backtracking-sol-easy-to-understand",
                "content": "```\\nclass Solution {\\n    List<List<String>> lists;\\n    public List<List<String>> solveNQueens(int n) {\\n        lists = new ArrayList<>();\\n        char[][] matrix = new char[n][n];\\n        for(char[] array : matrix)\\n        {\\n            Arrays.fill(array,\\'.\\');\\n        }\\n        \\n        recursion(0,n,matrix);\\n        \\n        return lists;\\n    }\\n    \\n    void recursion(int row,int n,char[][] matrix)\\n    {\\n        if(row == n)\\n        {\\n            List<String> list = makeList(matrix);\\n            lists.add(list);\\n            return ;\\n        }\\n        for(int col = 0;col<n;col++)\\n        {\\n            if(isValid(row,col,n,matrix))\\n            {\\n                matrix[row][col] = \\'Q\\';\\n                recursion(row+1,n,matrix);\\n                matrix[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    boolean isValid(int row,int col,int n,char[][] matrix)\\n    {\\n        //checking row wise\\n        for(int i=0;i<row;i++)\\n        {\\n            if(matrix[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        int i = row,j=col;\\n        while(i>=0 && j>=0)\\n        {\\n            if(matrix[i][j] == \\'Q\\')\\n                return false;\\n            i--;j--;\\n        }\\n        i=row;j=col;\\n        while(i>=0 && j<n)\\n        {\\n            if(matrix[i][j] == \\'Q\\')\\n                return false;\\n            i--;j++;\\n        }\\n        return true;\\n    }\\n    List<String> makeList(char[][] matrix)\\n    {\\n        List<String> list = new ArrayList<>();\\n        for(char[] array : matrix)\\n            list.add(String.valueOf(array));\\n        return list;\\n    }\\n}\\n```\\nPlease upvote f u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> lists;\\n    public List<List<String>> solveNQueens(int n) {\\n        lists = new ArrayList<>();\\n        char[][] matrix = new char[n][n];\\n        for(char[] array : matrix)\\n        {\\n            Arrays.fill(array,\\'.\\');\\n        }\\n        \\n        recursion(0,n,matrix);\\n        \\n        return lists;\\n    }\\n    \\n    void recursion(int row,int n,char[][] matrix)\\n    {\\n        if(row == n)\\n        {\\n            List<String> list = makeList(matrix);\\n            lists.add(list);\\n            return ;\\n        }\\n        for(int col = 0;col<n;col++)\\n        {\\n            if(isValid(row,col,n,matrix))\\n            {\\n                matrix[row][col] = \\'Q\\';\\n                recursion(row+1,n,matrix);\\n                matrix[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    boolean isValid(int row,int col,int n,char[][] matrix)\\n    {\\n        //checking row wise\\n        for(int i=0;i<row;i++)\\n        {\\n            if(matrix[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        int i = row,j=col;\\n        while(i>=0 && j>=0)\\n        {\\n            if(matrix[i][j] == \\'Q\\')\\n                return false;\\n            i--;j--;\\n        }\\n        i=row;j=col;\\n        while(i>=0 && j<n)\\n        {\\n            if(matrix[i][j] == \\'Q\\')\\n                return false;\\n            i--;j++;\\n        }\\n        return true;\\n    }\\n    List<String> makeList(char[][] matrix)\\n    {\\n        List<String> list = new ArrayList<>();\\n        for(char[] array : matrix)\\n            list.add(String.valueOf(array));\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489885,
                "title": "python3-backtracking",
                "content": "```\\ndef solveNQueens(self, n: int) -> List[List[str]]:\\n\\tsols = []\\n\\tdef backtrack(pos, row):\\n\\t\\tif len(pos) == n and row == n:\\n\\t\\t\\tsols.append(pos)\\n\\t\\tfor col in range(n):\\n\\t\\t\\tif all(row != row1 and col != col1 and abs(row - row1) != abs(col - col1)\\n\\t\\t\\t\\t\\t  for row1, col1 in pos):\\n\\t\\t\\t\\tbacktrack(pos + [(row, col)], row + 1)\\n\\tbacktrack([], 0)\\n\\treturn [\\n\\t\\t[\\'\\'.join(\\'Q\\' if (i, j) in sol else \\'.\\' for i in range(n)) for j in range(n)]\\n\\t\\tfor sol in sols\\n\\t]\\n                ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef solveNQueens(self, n: int) -> List[List[str]]:\\n\\tsols = []\\n\\tdef backtrack(pos, row):\\n\\t\\tif len(pos) == n and row == n:\\n\\t\\t\\tsols.append(pos)\\n\\t\\tfor col in range(n):\\n\\t\\t\\tif all(row != row1 and col != col1 and abs(row - row1) != abs(col - col1)\\n\\t\\t\\t\\t\\t  for row1, col1 in pos):\\n\\t\\t\\t\\tbacktrack(pos + [(row, col)], row + 1)\\n\\tbacktrack([], 0)\\n\\treturn [\\n\\t\\t[\\'\\'.join(\\'Q\\' if (i, j) in sol else \\'.\\' for i in range(n)) for j in range(n)]\\n\\t\\tfor sol in sols\\n\\t]\\n                ```",
                "codeTag": "Python3"
            },
            {
                "id": 3713298,
                "title": "c-recursive-backtracking-bool-vector-vs-bitmask-beasts-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code solves the N-Queens problem by recursively placing queens on a chessboard. It uses backtracking and checks for valid positions to avoid conflicts. The solutions are stored in a vector and returned. The code initializes the chessboard, sets flags for occupied columns, diagonals, and anti-diagonals, and finds all valid solutions using a recursive function.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)\\n```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\\nvectors col, antidiag, and diag are used as boolean flags to keep track of occupied columns, anti-diagonals, and diagonals, respectively.\\n\\nHere\\'s a breakdown of each vector\\'s purpose:\\n\\ncol: This vector represents the occupied columns on the chessboard. Each element in the vector corresponds to a column on the board. If col[j] is true, it means that column j is already occupied by a queen. Otherwise, if col[j] is false, the column is available for placing a queen.\\n\\nantidiag: This vector represents the occupied anti-diagonals on the chessboard. An anti-diagonal is a diagonal line that runs from the top-right to the bottom-left of the chessboard. The length of the anti-diagonals is 2*n - 1, where n is the number of rows/columns. Each element in the vector corresponds to an anti-diagonal on the board. If antidiag[i+j] is true, it means that the anti-diagonal i+j is already occupied by a queen. If antidiag[i+j] is false, the anti-diagonal is available for placing a queen.\\n\\ndiag: This vector represents the occupied diagonals on the chessboard. A diagonal is a line that runs from the top-left to the bottom-right of the chessboard. Similar to the antidiag vector, the length of the diagonals is also 2*n - 1. Each element in the vector corresponds to a diagonal on the board. If diag[i+n-j-1] is true, it means that the diagonal i-j is already occupied by a queen (Note that i-j may be negative, shifting it to i+n-j-1 to ensure be non-negative ). If diag[i+n-j-1] is false, the diagonal is available for placing a queen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n!)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans; // Vector to store the solutions\\n    vector<bool> col, antidiag, diag; // Boolean vectors to keep track of occupied columns, anti-diagonals, and diagonals\\n\\n    void print(){\\n        int i=0;\\n        for(vector<string>& board: ans){\\n            cout<<\"sol \"<<++i<<\":\\\\n\";\\n            for(string& row: board)\\n                cout<<row<<endl;\\n            cout<<\"=======\\\\n\";\\n        }\\n    }\\n    \\n    void find_sol(int i, int n, vector<string>& board) {\\n        if (i == n) { // Base case: If all queens are placed successfully, add the current board configuration to ans\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) { // Check if placing a queen at position (i, j) is a valid move\\n                board[i][j] = \\'Q\\'; // Place the queen at (i, j)\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true; // Update the occupied flags\\n                find_sol(i+1, n, board); // Recursively move on to the next row\\n                board[i][j] = \\'.\\'; // Backtrack: Remove the queen from (i, j)\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false; // Reset the occupied flags\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> board(n, string(n, \\'.\\')); // Initialize the chessboard with empty cells represented by \\'.\\'\\n        col.assign(n, false); // Initialize the occupied column flags as false\\n        antidiag.assign(2*n-1, false); // Initialize the occupied anti-diagonal flags as false\\n        diag.assign(2*n-1, false); // Initialize the occupied diagonal flags as false\\n        find_sol(0, n, board); // Call the recursive function to find all solutions\\n        //print(); // Optional: Print the solutions\\n        return ans; // Return the solutions\\n    }\\n};\\n\\n\\n\\n```\\n# second solution using Bitmasks instead of boolean arrays\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int col_mask, diag_mask, anti_diag_mask;\\n\\n    void print(){\\n        int i=0;\\n        for(vector<string>& board: ans){\\n            cout<<\"sol \"<<++i<<\":\\\\n\";\\n            for(string& row: board)\\n                cout<<row<<endl;\\n            cout<<\"=======\\\\n\";\\n        }\\n    }\\n\\n    void find_sol(int i, int n, vector<string>& board) {\\n        if (i == n) {\\n            ans.push_back(board);\\n            return;\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0)\\n            {\\n                board[i][j] = \\'Q\\';\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                find_sol(i + 1, n, board);\\n\\n                board[i][j] = \\'.\\';//backtracking\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n    }\\n\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> board(n, string(n, \\'.\\'));\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        find_sol(0, n, board);\\n        //print();\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nsol 92:\\n.......Q\\n...Q....\\nQ.......\\n..Q.....\\n.....Q..\\n.Q......\\n......Q.\\n....Q...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans; // Vector to store the solutions\\n    vector<bool> col, antidiag, diag; // Boolean vectors to keep track of occupied columns, anti-diagonals, and diagonals\\n\\n    void print(){\\n        int i=0;\\n        for(vector<string>& board: ans){\\n            cout<<\"sol \"<<++i<<\":\\\\n\";\\n            for(string& row: board)\\n                cout<<row<<endl;\\n            cout<<\"=======\\\\n\";\\n        }\\n    }\\n    \\n    void find_sol(int i, int n, vector<string>& board) {\\n        if (i == n) { // Base case: If all queens are placed successfully, add the current board configuration to ans\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for (int j = 0; j < n; j++) {\\n            if (!col[j] && !antidiag[i+j] && !diag[i+n-j-1]) { // Check if placing a queen at position (i, j) is a valid move\\n                board[i][j] = \\'Q\\'; // Place the queen at (i, j)\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = true; // Update the occupied flags\\n                find_sol(i+1, n, board); // Recursively move on to the next row\\n                board[i][j] = \\'.\\'; // Backtrack: Remove the queen from (i, j)\\n                col[j] = antidiag[i+j] = diag[i+n-j-1] = false; // Reset the occupied flags\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> board(n, string(n, \\'.\\')); // Initialize the chessboard with empty cells represented by \\'.\\'\\n        col.assign(n, false); // Initialize the occupied column flags as false\\n        antidiag.assign(2*n-1, false); // Initialize the occupied anti-diagonal flags as false\\n        diag.assign(2*n-1, false); // Initialize the occupied diagonal flags as false\\n        find_sol(0, n, board); // Call the recursive function to find all solutions\\n        //print(); // Optional: Print the solutions\\n        return ans; // Return the solutions\\n    }\\n};\\n\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int col_mask, diag_mask, anti_diag_mask;\\n\\n    void print(){\\n        int i=0;\\n        for(vector<string>& board: ans){\\n            cout<<\"sol \"<<++i<<\":\\\\n\";\\n            for(string& row: board)\\n                cout<<row<<endl;\\n            cout<<\"=======\\\\n\";\\n        }\\n    }\\n\\n    void find_sol(int i, int n, vector<string>& board) {\\n        if (i == n) {\\n            ans.push_back(board);\\n            return;\\n        }\\n\\n        for (int j = 0; j < n; j++) {\\n            if ((col_mask & (1 << j)) == 0 && \\n                (diag_mask & (1 << (i - j + n - 1))) == 0 && \\n                (anti_diag_mask & (1 << (i + j))) == 0)\\n            {\\n                board[i][j] = \\'Q\\';\\n                col_mask |= (1 << j);\\n                diag_mask |= (1 << (i - j + n - 1));\\n                anti_diag_mask |= (1 << (i + j));\\n\\n                find_sol(i + 1, n, board);\\n\\n                board[i][j] = \\'.\\';//backtracking\\n\\n                col_mask &= ~(1 << j);\\n                diag_mask &= ~(1 << (i - j + n - 1));\\n                anti_diag_mask &= ~(1 << (i + j));\\n            }\\n        }\\n    }\\n\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> board(n, string(n, \\'.\\'));\\n        col_mask = diag_mask = anti_diag_mask = 0;\\n        find_sol(0, n, board);\\n        //print();\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520928,
                "title": "python3-easy-backtracking-with-1-hash",
                "content": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        d, boards = set(), []\\n\\n        def backtracking(row, leaft, board):\\n            if not leaft:\\n                boards.append([\\'\\'.join(row )for row in board])\\n                return\\n\\n            line = [\\'.\\' for _ in range(n)]\\n            for col in range(n): #process all columns in current row\\n                colKey = f\\'col_{col}\\'\\n                majorDiagKey = f\\'d1_{row-col}\\'\\n                subDiagKey = f\\'d2_{row+col}\\'\\n                local_d = set([colKey, majorDiagKey, subDiagKey])\\n\\n                if local_d & d: continue #has intersection (collision)\\n                \\n                line[col] = \\'Q\\'\\n                board.append(line)\\n                d.update(local_d)\\n                \\n                backtracking(row+1, leaft-1, board)\\n                    \\n                #return data to previously state\\n                line[col] = \\'.\\' \\n                board.pop()  \\n                d.difference_update(local_d)            \\n\\n        backtracking(0, n, [])\\n        \\n        return boards\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        d, boards = set(), []\\n\\n        def backtracking(row, leaft, board):\\n            if not leaft:\\n                boards.append([\\'\\'.join(row )for row in board])\\n                return\\n\\n            line = [\\'.\\' for _ in range(n)]\\n            for col in range(n): #process all columns in current row\\n                colKey = f\\'col_{col}\\'\\n                majorDiagKey = f\\'d1_{row-col}\\'\\n                subDiagKey = f\\'d2_{row+col}\\'\\n                local_d = set([colKey, majorDiagKey, subDiagKey])\\n\\n                if local_d & d: continue #has intersection (collision)\\n                \\n                line[col] = \\'Q\\'\\n                board.append(line)\\n                d.update(local_d)\\n                \\n                backtracking(row+1, leaft-1, board)\\n                    \\n                #return data to previously state\\n                line[col] = \\'.\\' \\n                board.pop()  \\n                d.difference_update(local_d)            \\n\\n        backtracking(0, n, [])\\n        \\n        return boards\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107990,
                "title": "java-clean-1-d-array",
                "content": "```\\npublic class Solution {\\npublic List<List<String>> solveNQueens(int n) {\\n    List<List<String>> list=new ArrayList<List<String>>();\\n    dfs(new int[n],0,n,list);\\n    return list;\\n}\\npublic void dfs(int[] pos,int step,int n,List<List<String>> list) {\\n    if(step==n) {\\n        ArrayList<String> ls=printboard(pos,n);\\n        list.add(new ArrayList<String>(ls));\\n        return;\\n    }\\n    for(int i=0;i<n;i++) {\\n        pos[step]=i;\\n        if(isvalid(pos,step)) {\\n            dfs(pos,step+1,n,list);\\n        }\\n    }\\n}\\npublic boolean isvalid(int[] pos, int step) {\\n    for(int i=0;i<step;i++) {\\n        if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n        \\n    }\\n    return true;\\n}\\npublic ArrayList<String> printboard(int[] pos,int n) {\\n    ArrayList<String> ls=new ArrayList<String>();\\n    for(int i=0;i<n;i++) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int j=0;j<n-1;j++) sb.append(\\'.\\');\\n        sb.insert(pos[i],\\'Q\\');\\n        ls.add(sb.toString());\\n        \\n    }\\n    return ls;\\n}\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/ed76774e-ee8d-4ae6-ae18-d9770e84e9a1_1654314772.279161.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\npublic List<List<String>> solveNQueens(int n) {\\n    List<List<String>> list=new ArrayList<List<String>>();\\n    dfs(new int[n],0,n,list);\\n    return list;\\n}\\npublic void dfs(int[] pos,int step,int n,List<List<String>> list) {\\n    if(step==n) {\\n        ArrayList<String> ls=printboard(pos,n);\\n        list.add(new ArrayList<String>(ls));\\n        return;\\n    }\\n    for(int i=0;i<n;i++) {\\n        pos[step]=i;\\n        if(isvalid(pos,step)) {\\n            dfs(pos,step+1,n,list);\\n        }\\n    }\\n}\\npublic boolean isvalid(int[] pos, int step) {\\n    for(int i=0;i<step;i++) {\\n        if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n        \\n    }\\n    return true;\\n}\\npublic ArrayList<String> printboard(int[] pos,int n) {\\n    ArrayList<String> ls=new ArrayList<String>();\\n    for(int i=0;i<n;i++) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int j=0;j<n-1;j++) sb.append(\\'.\\');\\n        sb.insert(pos[i],\\'Q\\');\\n        ls.add(sb.toString());\\n        \\n    }\\n    return ls;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850044,
                "title": "easy-0ms-beats100-c-backtracking",
                "content": "Find this problem **HARD** \\uD83E\\uDD74??\\n\\nLet me make this problem **EASY** for you\\uD83D\\uDE0D\\n\\n\\n\\nDisclaimer :  Please ignore any grammatical and spelling errors present in this article.  \\uD83D\\uDE05\\n\\nLet\\u2019s start the journey\\u2026..\\nReady .. Set .. Goooo.................... \\uD83D\\uDEB4\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F \\uD83C\\uDFC7\\uD83C\\uDFFB\\n\\nOk, now let\\u2019s say we are given ***N = 4***\\nSo we have a **4 x 4** chessboard and we have to put **4** Queens on it so that they can\\u2019t kill\\uD83D\\uDC7B\\uD83D\\uDC7B each other.\\n\\nLet\\u2019s start with row = 0 , col = 0 and put our 1st queen there.\\n![image](https://assets.leetcode.com/users/images/e04695e7-ae5d-4d79-9ea4-97bd4e4b3baf_1647296218.2432222.jpeg)\\n\\n\\nAfter putting our first queen at row = 0 & col = 0, she has blocked the 0th column and her right diagonal.\\n\\nOk, now let\\u2019s try to put 2nd queen in the 2nd row\\u2026\\nAs (1,0) and  (1,1) cells are blocked by queen 1, we have to put our second queen at cell ( 1 , 2 )\\n![image](https://assets.leetcode.com/users/images/6f0faeec-60cf-40f2-8430-af9384bdc273_1647296146.7885044.jpeg)\\n\\n\\n\\nOk, now let\\u2019s try to put 3rd queen in the 3rd row\\u2026\\nOh, shit\\uD83D\\uDE10\\u2026 all cells of the 3rd row are blocked by the 1st and 2nd queen.\\n![image](https://assets.leetcode.com/users/images/5ecb0036-a5d9-4ad4-ae5d-87e3f13659a7_1647296345.4750628.jpeg)\\n\\n\\nOkay, now we have to backtrack and put our 2nd queen in the 2nd row of 4th column.\\n![image](https://assets.leetcode.com/users/images/adebbe40-f0dc-417f-b581-513aed419c3a_1647296411.3957672.jpeg)\\n\\n\\nOk, now we can put our 3rd queen at (2,1) as all other cells of the 3rd row are blocked by other queens.\\nAfter putting 3rd queen, we have no cell left for the 4th queen.\\uD83E\\uDD75\\n![image](https://assets.leetcode.com/users/images/a2f3f9f8-1624-4020-bb1a-6f67e9400249_1647296518.3951468.jpeg)\\n\\n\\n\\nNow, again let\\u2019s do the backtrack till the 1st queen and put 1st queen at 2nd column of 1st row.\\nStep 1:\\n![image](https://assets.leetcode.com/users/images/a6611148-9635-4c14-8fc2-77a17eec7663_1647296625.0412571.jpeg)\\n\\n\\nStep 2:\\n![image](https://assets.leetcode.com/users/images/92266509-f315-4124-911f-8e30fcf520c2_1647293636.0111742.jpeg)\\n\\nStep 3:\\n![image](https://assets.leetcode.com/users/images/ef1c7104-5bbc-42a8-8b71-884137fe4adb_1647293645.0649197.jpeg)\\n\\nStep 4:\\n![image](https://assets.leetcode.com/users/images/2b4b494c-c445-4c74-bcf1-29aee8d425d9_1647293656.58088.jpeg)\\n\\nHurray \\uD83E\\uDD73 \\uD83E\\uDD73, we got one of our solutions.\\n\\n----------------------------------------------------------------------------------------------------\\nOkay, now let\\u2019s think, about how we can implement the code.\\n\\nYou have noticed when we put a queen at a particular cell, she blocks some other cells.\\n![image](https://assets.leetcode.com/users/images/ab495448-bfcd-4768-bd26-dd699c8454b1_1647293737.3226588.jpeg)\\n\\nYou can see in the above image, the queen has blocked the column where she is present and the left and right diagonal from that cell.\\nSo, how we are gonna know, which cells are blocked and which are safe\\u2026\\uD83E\\uDD14\\n\\nWe can track all blocked cells by using 3 boolean arrays \\uD83D\\uDE3C \\uD83D\\uDE3D \\uD83D\\uDE40. Now let\\u2019s see how\\u2026\\n1st Boolean Array: COLS to track the blocked columns.\\n![image](https://assets.leetcode.com/users/images/6fba09a5-db0e-4ea4-a0c5-bb038926fe02_1647293932.1108158.jpeg)\\n\\n2nd Boolean Array: LEFT_D to track the blocked left diagonals.\\n![image](https://assets.leetcode.com/users/images/b8e00844-7130-45a0-8465-0cfc757fa6bd_1647293949.465065.jpeg)\\n\\n\\n3rd Boolean Array: RIGHT_D to track the blocked right diagonals.\\n![image](https://assets.leetcode.com/users/images/b617f862-3262-41bc-957b-752c4492b597_1647293967.6555202.jpeg)\\n\\n\\n\\uD83E\\uDD71\\nOkay, Now let\\u2019s start coding, rest of the concepts, we will discuss inside the code. [ using comments\\uD83D\\uDE05 ]\\n\\n```\\n void solve(int row,int n,vector<bool> &cols,vector<bool> &LEFT_D,vector<bool> &RIGHT_D,vector<string> &temp,vector<vector<string>> &ans){\\n\\t\\t// Base Case \\n\\t\\t// if we have placed all n queens on the board, \\n\\t\\t// then just add the queens placements in our ans and return.\\n        if(row == n){    \\n            ans.push_back(temp);\\n            return;\\n        }\\n\\t\\t\\n        string str(n,\\'.\\');\\n\\t\\t// if n = 4 ,     str = \"....\"\\n\\t\\t// if n = 7 ,     str = \".......\"\\n\\t\\t\\n        for(int col = 0 ; col < n ; col++ ){  // Let\\'s check for all columns of current \\'row\\'\\n\\t\\t     //  if current cell is safe, we can place our queen there\\n            if(cols[col] == false && LEFT_D[row + col] == false && RIGHT_D[row - col + n - 1] == false){\\n\\t\\t\\t\\n\\t\\t\\t\\t// queen has blocked the current column and it\\'s left and right diagonal\\n                cols[col] = true;\\n                LEFT_D[row + col] = true;\\n                RIGHT_D[row - col + n - 1] = true;\\n\\t\\t\\t\\t\\n                str[col] = \\'Q\\'; //  \\'\\' . . . .\"   -->  \\'\\' . Q . .\" ( placed our queen )\\n                temp.push_back(str); \\n\\t\\t\\t\\t\\n                solve(row+1,n,cols,LEFT_D,RIGHT_D,temp,ans);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We haven\\'t got our ans yet, so BACKTRACK ::\\n                temp.pop_back();\\n                str[col] = \\'.\\';  //  \\'\\' . Q . .\"   -->  \\'\\' . . . .\" \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// As, we have remove our queen from it\\'s position, \\n\\t\\t\\t\\t// release all blocked cells\\n                cols[col] = false;\\n                LEFT_D[row + col] = false;\\n                RIGHT_D[row - col + n - 1] = false;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) { \\n        vector<vector<string>> ans;\\n\\t\\t vector<string> temp;\\n\\t\\t\\n\\t\\t// COLS : To Track Blocked Columns  \\n        vector<bool> cols(n,false);\\n\\t\\t\\n\\t\\t// LEFT_D : To Track Blocked Left Diagonals  \\n        vector<bool> LEFT_D(2 * n + 1, false);\\n\\t\\t\\n\\t\\t// RIGHT_D : To Track Blocked Right Diagonals  \\n        vector<bool> RIGHT_D(2 * n + 1, false);\\n\\t\\t\\n        // Recursive function to find differnet valid positions of \\'n\\' queens.\\n\\t\\tsolve(0,n,cols,LEFT_D,RIGHT_D,temp,ans);\\n\\t\\t\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\n***Let me know, if you like this article, by just upvoting it.***\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void solve(int row,int n,vector<bool> &cols,vector<bool> &LEFT_D,vector<bool> &RIGHT_D,vector<string> &temp,vector<vector<string>> &ans){\\n\\t\\t// Base Case \\n\\t\\t// if we have placed all n queens on the board, \\n\\t\\t// then just add the queens placements in our ans and return.\\n        if(row == n){    \\n            ans.push_back(temp);\\n            return;\\n        }\\n\\t\\t\\n        string str(n,\\'.\\');\\n\\t\\t// if n = 4 ,     str = \"....\"\\n\\t\\t// if n = 7 ,     str = \".......\"\\n\\t\\t\\n        for(int col = 0 ; col < n ; col++ ){  // Let\\'s check for all columns of current \\'row\\'\\n\\t\\t     //  if current cell is safe, we can place our queen there\\n            if(cols[col] == false && LEFT_D[row + col] == false && RIGHT_D[row - col + n - 1] == false){\\n\\t\\t\\t\\n\\t\\t\\t\\t// queen has blocked the current column and it\\'s left and right diagonal\\n                cols[col] = true;\\n                LEFT_D[row + col] = true;\\n                RIGHT_D[row - col + n - 1] = true;\\n\\t\\t\\t\\t\\n                str[col] = \\'Q\\'; //  \\'\\' . . . .\"   -->  \\'\\' . Q . .\" ( placed our queen )\\n                temp.push_back(str); \\n\\t\\t\\t\\t\\n                solve(row+1,n,cols,LEFT_D,RIGHT_D,temp,ans);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// We haven\\'t got our ans yet, so BACKTRACK ::\\n                temp.pop_back();\\n                str[col] = \\'.\\';  //  \\'\\' . Q . .\"   -->  \\'\\' . . . .\" \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// As, we have remove our queen from it\\'s position, \\n\\t\\t\\t\\t// release all blocked cells\\n                cols[col] = false;\\n                LEFT_D[row + col] = false;\\n                RIGHT_D[row - col + n - 1] = false;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) { \\n        vector<vector<string>> ans;\\n\\t\\t vector<string> temp;\\n\\t\\t\\n\\t\\t// COLS : To Track Blocked Columns  \\n        vector<bool> cols(n,false);\\n\\t\\t\\n\\t\\t// LEFT_D : To Track Blocked Left Diagonals  \\n        vector<bool> LEFT_D(2 * n + 1, false);\\n\\t\\t\\n\\t\\t// RIGHT_D : To Track Blocked Right Diagonals  \\n        vector<bool> RIGHT_D(2 * n + 1, false);\\n\\t\\t\\n        // Recursive function to find differnet valid positions of \\'n\\' queens.\\n\\t\\tsolve(0,n,cols,LEFT_D,RIGHT_D,temp,ans);\\n\\t\\t\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262826,
                "title": "python-dfs",
                "content": "We can use DFS here and keep searching next possible move until all queues have been allocated.\\n\\nThe rules here are for any two queues, they can\\'t share 1)same row, 2)same column, 3)same positive-slope diagonal (col.idx-row.idx), and 4)same negative-slope diagonal (col.idx+row.idx).\\n\\nWe can use an array to express a game state. Each index indicate queue\\'s row and each value indicate queue\\'s column.\\ne.g. [1,3,0,2] expressed a game state as:\\n```\\n\".Q..\"\\n\"...Q\"\\n\"Q...\"\\n\"..Q.\"\\n```\\nSo there is only one value in each index ensures rule #1. All values are unique ensures rule #2. I used another two sets pd and nd to store all visited (c-r) and (c+r) to ensures rules #3 and #4. During DFS, in each iteration, we add new column values to our current row array. Rule #1 is already fulfilled as we only add one column value in current iteration. Then we check rules #2, #3, #4. If the column value pass all three check, we add it as a candidate and keep DFS search.\\n\\nIf row array\\'s length == n, then we have allocated all queues and the state is one of valid state.\\n```\\ndef solveNQueens(n):\\n\\tsols = []\\n\\tdef dfs(state, pd, nd):\\n\\t\\tr = len(state)\\n\\t\\tif r < n:\\n\\t\\t\\tfor c in range(n):\\n\\t\\t\\t\\tif c not in state and c-r not in pd and c+r not in nd:\\n\\t\\t\\t\\t\\tdfs(state+[c], pd|{c-r}, nd|{c+r})\\n\\t\\telse: \\n\\t\\t\\tsols.append(state)\\n\\t\\n\\tdfs([], set(), set())\\n\\treturn [[f\"{\\'.\\'*p}Q{\\'.\\'*(n-p-1)}\" for p in sol] for sol in sols]\\n```",
                "solutionTags": [],
                "code": "```\\n\".Q..\"\\n\"...Q\"\\n\"Q...\"\\n\"..Q.\"\\n```\n```\\ndef solveNQueens(n):\\n\\tsols = []\\n\\tdef dfs(state, pd, nd):\\n\\t\\tr = len(state)\\n\\t\\tif r < n:\\n\\t\\t\\tfor c in range(n):\\n\\t\\t\\t\\tif c not in state and c-r not in pd and c+r not in nd:\\n\\t\\t\\t\\t\\tdfs(state+[c], pd|{c-r}, nd|{c+r})\\n\\t\\telse: \\n\\t\\t\\tsols.append(state)\\n\\t\\n\\tdfs([], set(), set())\\n\\treturn [[f\"{\\'.\\'*p}Q{\\'.\\'*(n-p-1)}\" for p in sol] for sol in sols]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 19962,
                "title": "concise-java-solution-based-on-dfs",
                "content": "**Explanation**\\n\\nThe basic idea is to check possible columns row by row based on DFS: If the column is already used or the column is on 45\\xb0 /135\\xb0  diagonals with the placed queens, then ignore it, otherwise place a queen on it and keep DFS procedure. As the following:\\n \\n    public List<List<String>> solveNQueens(int n) {\\n    \\tList<List<String>> res = new LinkedList<List<String>>();\\n    \\tint[] usedCols = new int[n];// usedCols[i]: Column of the queen in row i\\n    \\tArrays.fill(usedCols, -1);\\n    \\tDFS(usedCols, 0, res);\\n    \\treturn res;\\n    }    \\n    \\n    void DFS(int[] usedCols, int row, List<List<String>> res) {\\n    \\tint n = usedCols.length;\\n    \\tif (row == n) {\\n    \\t\\tres.add(drawGrids(usedCols));\\n    \\t\\treturn;\\n    \\t}     \\t\\n\\n    \\t// Check Possible columns for the inputed row.\\n    \\tfor (int col = 0; col < n; col++) {\\n    \\t\\tif (isValid(usedCols, row, col)) {\\n    \\t\\t\\tusedCols[row] = col;\\n    \\t\\t\\tDFS(usedCols, row + 1, res);// Move on to the next row\\t\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n    // Check if the column is valid to place queen for the row.\\n    boolean isValid(int[] usedCols, int row, int col) {\\n    \\tfor (int i = 0; i < row; i++) {\\n    \\t\\t// Excludes used columns and diagonal positions \\n    \\t\\t// (x2-x1)/(y2-y1) == 1 or -1\\n    \\t\\tif (usedCols[i] == col || row - i == Math.abs(col - usedCols[i]))    \\t\\t\\t\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n    \\n    List<String> drawGrids(int[] usedCols) {\\n    \\tList<String>res = new LinkedList<String>();\\n    \\tfor (int i : usedCols) {\\n        \\tchar[] line = new char[usedCols.length];\\n        \\tArrays.fill(line, '.');\\t    \\t\\n        \\tline[i] = 'Q'; \\n        \\tres.add(String.valueOf(line));\\n    \\t}    \\t\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is to check possible columns row by row based on DFS: If the column is already used or the column is on 45\\xb0 /135\\xb0  diagonals with the placed queens, then ignore it, otherwise place a queen on it and keep DFS procedure. As the following:\\n \\n    public List<List<String>> solveNQueens(int n) {\\n    \\tList<List<String>> res = new LinkedList<List<String>>();\\n    \\tint[] usedCols = new int[n];// usedCols[i]: Column of the queen in row i\\n    \\tArrays.fill(usedCols, -1);\\n    \\tDFS(usedCols, 0, res);\\n    \\treturn res;\\n    }    \\n    \\n    void DFS(int[] usedCols, int row, List<List<String>> res) {\\n    \\tint n = usedCols.length;\\n    \\tif (row == n) {\\n    \\t\\tres.add(drawGrids(usedCols));\\n    \\t\\treturn;\\n    \\t}     \\t\\n\\n    \\t// Check Possible columns for the inputed row.\\n    \\tfor (int col = 0; col < n; col++) {\\n    \\t\\tif (isValid(usedCols, row, col)) {\\n    \\t\\t\\tusedCols[row] = col;\\n    \\t\\t\\tDFS(usedCols, row + 1, res);// Move on to the next row\\t\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n    // Check if the column is valid to place queen for the row.\\n    boolean isValid(int[] usedCols, int row, int col) {\\n    \\tfor (int i = 0; i < row; i++) {\\n    \\t\\t// Excludes used columns and diagonal positions \\n    \\t\\t// (x2-x1)/(y2-y1) == 1 or -1\\n    \\t\\tif (usedCols[i] == col || row - i == Math.abs(col - usedCols[i]))    \\t\\t\\t\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n    \\n    List<String> drawGrids(int[] usedCols) {\\n    \\tList<String>res = new LinkedList<String>();\\n    \\tfor (int i : usedCols) {\\n        \\tchar[] line = new char[usedCols.length];\\n        \\tArrays.fill(line, '.');\\t    \\t\\n        \\tline[i] = 'Q'; \\n        \\tres.add(String.valueOf(line));\\n    \\t}    \\t\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3202683,
                "title": "java-1ms-recursive-optimized-bruteforce-100-99-8",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking, Recursion, An Optimized Include/Dont include bruteforce approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a well known include/dont include (Or for this problem: put queen at current cell, or dont put queen at current cell) approach.\\n\\nStart traversing the board from very first cell (0, 0) all the way to last cell while taking two decisions at every cell (include queen at current cell, or dont include queen at current cell)\\n\\nTo optimize above bruteforce, we can use following conditions to restrict our descision of including or not including the queen:\\n1. An exactly 1 queen must be present in each row and each column of the board, this means there shouldn\\'t be any row or column on board which does not have any queen in it, and, there shouldn\\'t be any row or column on the board which contains more than 1 queen in it.\\n2. There shouldn\\'t be any left or right diagonal on board which contains more than 1 queen in it.\\n\\nBased on above two conditions, to check if the row, column, or diagonal of current cell already contains a queen in it, we can make use of a `hasQueen[i]` variable where `i` represents the index of current row, col, or diagonal. Each time we take a desicion to include queen at current cell, we also update our `hasQueen` variable accordingly.\\n\\nTo figure out the index of the current left or right diagonal, we can make use of $$Y = MX + C$$ equation.\\nHere, $$Y$$ can be the row number of current cell,\\n$$X$$ can be the column number,\\n$$M$$ is slope of diagonal ($$1$$ for right diagonal and $$-1$$ for left diagonal).\\n$$C$$ will be the intersection point of the diagonal with the first column. This point can be used to index the diagonal.\\nSee below image to understand it better:\\n![image.png](https://assets.leetcode.com/users/images/ef45d608-3e17-4e82-86ef-d4ceccb79d32_1676735226.8587866.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public char[][] board;\\n    public List<List<String>> answer; //final answer (contains multiple valid combinations)\\n\\n    //to check if a row, column, or left or right diagonal already contains a queen in it\\n    public boolean[] rowHasQ;\\n    public boolean[] colHasQ;\\n    public boolean[] d1HasQ;\\n    public boolean[] d2HasQ;\\n\\n    public void solve(int row, int col, int queensLeft) {\\n        if (queensLeft == 0) {\\n            //we have found a valid combination on the board,\\n            //save board as answer and go back to figure out other combinations\\n            List<String> validBoard = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                validBoard.add(new String(board[i]));\\n            }\\n            answer.add(validBoard);\\n            return;\\n        }\\n\\n        //we\\'ve traversed the whole board\\n        //go back and figure out other combinations\\n        if (row >= board.length)\\n            return;\\n\\n        \\n        //right diagonal (slope = 1)\\n        int d1 = col - row + (board.length - 1);\\n        //added (board.length - 1) so that index does\\'t become negative\\n        \\n        \\n        //left diagonal (slope = -1)\\n        int d2 = row + col;\\n\\n\\n\\n        //Possibility 1. Include Q at current cell\\n        if (\\n            //Make sure that current row, col, or diagonal doesn\\'t already contain a Queen in it\\n            !rowHasQ[row] && !colHasQ[col] && !d1HasQ[d1] && !d2HasQ[d2]\\n        ) {\\n            //put a Queen at current cell\\n            board[row][col] = \\'Q\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = true;\\n\\n            //Continue traversing rest of the cells starting from next row.\\n            //Start from next row because current row already contains a Q now. (Optimized brute force)\\n            solve(row + 1, 0, queensLeft - 1);\\n\\n            //reset board\\n            board[row][col] = \\'.\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = false;\\n        }\\n\\n\\n\\n        //Possibility 2. dont include Q at current cell\\n        if (\\n            //Condition to optimize brute force\\n            //If we are at this positoin in the code, this means that none of previous cells in current row has any queen in it.\\n            //And because each row in the board must contain exactly 1 queen,\\n            //With the help of following condition we will make sure that current row must contain at least one queen.\\n            col < board.length - 1\\n        ) {\\n            //dont include queen at current cell and continue exploring starting from next cell (in same row)\\n            solve(row, col + 1, queensLeft);\\n        }\\n    }\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        answer = new ArrayList<>();\\n\\n        board = new char[n][n];\\n        for (int i = 0; i < board.length; i++)\\n            Arrays.fill(board[i], \\'.\\');\\n\\n        rowHasQ = new boolean[n];\\n        colHasQ = new boolean[n];\\n        d1HasQ = new boolean[n * 2 - 1];\\n        d2HasQ = new boolean[n * 2 - 1];\\n\\n        solve(0, 0, n);\\n\\n        return answer;\\n    }\\n}\\n```\\n# Note\\nTo optimize the memory consumption further, Since maximum size of the board is 9, we can have maximum 9 rows, 9 columns, and maximum of 17 left as well as 17 right diagonals. We can thus use bit manipulation to replace our `hasQ[]` variable with a single variable for each row, col, and diagonals.\\n\\nTo optimize memory a bit further, if you look closely in the code, you may be able to notice that we dont really need a `rowHasQ[]` array because with the help of optimized brute force, we are already making sure that we explore only those possibility where 1 row contains only 1 Queen. \\n\\n\\n**Please upvote if this solution helps :)**\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public char[][] board;\\n    public List<List<String>> answer; //final answer (contains multiple valid combinations)\\n\\n    //to check if a row, column, or left or right diagonal already contains a queen in it\\n    public boolean[] rowHasQ;\\n    public boolean[] colHasQ;\\n    public boolean[] d1HasQ;\\n    public boolean[] d2HasQ;\\n\\n    public void solve(int row, int col, int queensLeft) {\\n        if (queensLeft == 0) {\\n            //we have found a valid combination on the board,\\n            //save board as answer and go back to figure out other combinations\\n            List<String> validBoard = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                validBoard.add(new String(board[i]));\\n            }\\n            answer.add(validBoard);\\n            return;\\n        }\\n\\n        //we\\'ve traversed the whole board\\n        //go back and figure out other combinations\\n        if (row >= board.length)\\n            return;\\n\\n        \\n        //right diagonal (slope = 1)\\n        int d1 = col - row + (board.length - 1);\\n        //added (board.length - 1) so that index does\\'t become negative\\n        \\n        \\n        //left diagonal (slope = -1)\\n        int d2 = row + col;\\n\\n\\n\\n        //Possibility 1. Include Q at current cell\\n        if (\\n            //Make sure that current row, col, or diagonal doesn\\'t already contain a Queen in it\\n            !rowHasQ[row] && !colHasQ[col] && !d1HasQ[d1] && !d2HasQ[d2]\\n        ) {\\n            //put a Queen at current cell\\n            board[row][col] = \\'Q\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = true;\\n\\n            //Continue traversing rest of the cells starting from next row.\\n            //Start from next row because current row already contains a Q now. (Optimized brute force)\\n            solve(row + 1, 0, queensLeft - 1);\\n\\n            //reset board\\n            board[row][col] = \\'.\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = false;\\n        }\\n\\n\\n\\n        //Possibility 2. dont include Q at current cell\\n        if (\\n            //Condition to optimize brute force\\n            //If we are at this positoin in the code, this means that none of previous cells in current row has any queen in it.\\n            //And because each row in the board must contain exactly 1 queen,\\n            //With the help of following condition we will make sure that current row must contain at least one queen.\\n            col < board.length - 1\\n        ) {\\n            //dont include queen at current cell and continue exploring starting from next cell (in same row)\\n            solve(row, col + 1, queensLeft);\\n        }\\n    }\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        answer = new ArrayList<>();\\n\\n        board = new char[n][n];\\n        for (int i = 0; i < board.length; i++)\\n            Arrays.fill(board[i], \\'.\\');\\n\\n        rowHasQ = new boolean[n];\\n        colHasQ = new boolean[n];\\n        d1HasQ = new boolean[n * 2 - 1];\\n        d2HasQ = new boolean[n * 2 - 1];\\n\\n        solve(0, 0, n);\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882867,
                "title": "c-solution-with-hashing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int col,vector<vector<string>>&dev,vector<string>&ans,int n,vector<int>&left,vector<int>&upper,vector<int>&lower){\\n        if(col==n){\\n            dev.push_back(ans); \\n            return;\\n        }\\n        for(int row=0;row<n;row++){\\n            if(left[row]==0 && lower[row+col]==0 && upper[n-1+col-row]==0){\\n                ans[row][col]=\\'Q\\';\\n                left[row]=1;\\n                lower[row+col]=1;\\n                upper[n-1+col-row]=1;\\n                solve(col+1,dev,ans,n,left,upper,lower);\\n                ans[row][col]=\\'.\\';\\n                left[row]=0;\\n                lower[row+col]=0;\\n                upper[n-1+col-row]=0;\\n            }\\n        }\\n    }\\n    public:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>>dev;\\n        vector<string>ans(n);\\n        string s(n,\\'.\\');\\n        for(int i=0;i<n;i++){\\n            ans[i]=s;\\n        }\\n        vector<int>left(n,0),upper(2*n-1,0),lower(2*n-1,0);\\n        solve(0,dev,ans,n,left,upper,lower);\\n        return dev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int col,vector<vector<string>>&dev,vector<string>&ans,int n,vector<int>&left,vector<int>&upper,vector<int>&lower){\\n        if(col==n){\\n            dev.push_back(ans); \\n            return;\\n        }\\n        for(int row=0;row<n;row++){\\n            if(left[row]==0 && lower[row+col]==0 && upper[n-1+col-row]==0){\\n                ans[row][col]=\\'Q\\';\\n                left[row]=1;\\n                lower[row+col]=1;\\n                upper[n-1+col-row]=1;\\n                solve(col+1,dev,ans,n,left,upper,lower);\\n                ans[row][col]=\\'.\\';\\n                left[row]=0;\\n                lower[row+col]=0;\\n                upper[n-1+col-row]=0;\\n            }\\n        }\\n    }\\n    public:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>>dev;\\n        vector<string>ans(n);\\n        string s(n,\\'.\\');\\n        for(int i=0;i<n;i++){\\n            ans[i]=s;\\n        }\\n        vector<int>left(n,0),upper(2*n-1,0),lower(2*n-1,0);\\n        solve(0,dev,ans,n,left,upper,lower);\\n        return dev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740844,
                "title": "java-easy-solution-with-comments-faster-than-90",
                "content": "**Upvote if you like this**\\n* 1ms\\n* 90% faster\\n```\\nclass Solution {\\n    //dp\\n    \\n    boolean neg_dia[]; // negative diagonal\\n    boolean pos_dia[]; // positive diagoanl\\n    boolean col[]; //column\\n    //we are not taking array for rows because when we place a queen we just increment our i to go to next row\\n    \\n    public List<List<String>> solveNQueens(int n) {\\n        neg_dia=new boolean[2*n-1]; //if we observe going right down diagoanl \\u2197\\uFE0F keep r-col same\\n        pos_dia=new boolean[2*n-1]; //while going right upside diagonal \\u2198\\uFE0F keeps, r+col same\\n        col=new boolean[n];\\n        //if any of this position already filled means we can\\'t place queen here\\n        \\n        char board[][]=new char[n][n];\\n        //filling blank board\\n        \\n        for(char[] i:board)\\n            Arrays.fill(i,\\'.\\');\\n        \\n        List<List<String>> res=new ArrayList<>();        \\n        \\n        queen(board,0,res,n);\\n        \\n        return res;\\n    }\\n   \\n    private void queen(char board[][], int i,List<List<String>> ans,int n) {\\n        //if i go to the length means we have filled all the queen\\n\\t\\t\\n        if(i==n) {\\n            //all queen placed successfully\\n            \\n            List<String> temp=new ArrayList<>();\\n            //now this is our ans\\n            \\n            for(int ii=0;ii<n;ii++){\\n                //this is our row we convert it to string eg. [.Q..] and we add this to an\\n                //other ans is also possible and we again come here and add it to our ans\\n                temp.add(String.valueOf(board[ii]));\\n            \\n            }\\n\\t\\t\\t\\n            ans.add(temp);\\n\\t\\t\\t\\n            return;\\n\\t\\t}\\n\\t\\t\\n        for(int j=0;j<n;j++) {\\n            \\n            //traversing int ith row with jth position\\n            //means checking where we can place queen at this row\\n            \\n            if(neg_dia[i-j+n-1] || pos_dia[i+j] || col[j])\\n                continue;\\n            \\n            //if any of this boolean true means we can\\'t place queen here\\n            //col for column we can\\'t place at this column\\n            //positive diagoanl for pos_dia we are having i+j\\n            //negative diagoanl for neg_dia we are having i-j+n-1\\n            //if we take i-j we have [-3,-2,-1,0,1,2,3] which is not a valid index for array\\n            //adding n-1 will convert [0,1,2,3,4,5,6]\\n            \\n            //queen placed here ( so true means we can\\'t place other queen at any of this column, diagonally ) and check if we can place next queen in next row properly or not\\n            neg_dia[i-j+n-1]=true;\\n            pos_dia[i+j]=true;\\n            col[j]=true;\\n\\n            //queen placed\\n            board[i][j]=\\'Q\\';\\n            \\n            //checking for next row\\n            queen(board,i+1,ans,n);\\n            \\n            //means we placed queen at wrong location so we need to remove the queen\\n            board[i][j]=\\'.\\';\\n            \\n            //after removing the queen we can place next queen at this loaction\\n            //nothing present at this time ( because we removed queen ) so we convert this position to false (no queen present)\\n        \\n            neg_dia[i-j+n-1]=false;\\n            pos_dia[i+j]=false;\\n            col[j]=false;\\n\\t\\t\\n        }\\n        \\n\\t}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    //dp\\n    \\n    boolean neg_dia[]; // negative diagonal\\n    boolean pos_dia[]; // positive diagoanl\\n    boolean col[]; //column\\n    //we are not taking array for rows because when we place a queen we just increment our i to go to next row\\n    \\n    public List<List<String>> solveNQueens(int n) {\\n        neg_dia=new boolean[2*n-1]; //if we observe going right down diagoanl \\u2197\\uFE0F keep r-col same\\n        pos_dia=new boolean[2*n-1]; //while going right upside diagonal \\u2198\\uFE0F keeps, r+col same\\n        col=new boolean[n];\\n        //if any of this position already filled means we can\\'t place queen here\\n        \\n        char board[][]=new char[n][n];\\n        //filling blank board\\n        \\n        for(char[] i:board)\\n            Arrays.fill(i,\\'.\\');\\n        \\n        List<List<String>> res=new ArrayList<>();        \\n        \\n        queen(board,0,res,n);\\n        \\n        return res;\\n    }\\n   \\n    private void queen(char board[][], int i,List<List<String>> ans,int n) {\\n        //if i go to the length means we have filled all the queen\\n\\t\\t\\n        if(i==n) {\\n            //all queen placed successfully\\n            \\n            List<String> temp=new ArrayList<>();\\n            //now this is our ans\\n            \\n            for(int ii=0;ii<n;ii++){\\n                //this is our row we convert it to string eg. [.Q..] and we add this to an\\n                //other ans is also possible and we again come here and add it to our ans\\n                temp.add(String.valueOf(board[ii]));\\n            \\n            }\\n\\t\\t\\t\\n            ans.add(temp);\\n\\t\\t\\t\\n            return;\\n\\t\\t}\\n\\t\\t\\n        for(int j=0;j<n;j++) {\\n            \\n            //traversing int ith row with jth position\\n            //means checking where we can place queen at this row\\n            \\n            if(neg_dia[i-j+n-1] || pos_dia[i+j] || col[j])\\n                continue;\\n            \\n            //if any of this boolean true means we can\\'t place queen here\\n            //col for column we can\\'t place at this column\\n            //positive diagoanl for pos_dia we are having i+j\\n            //negative diagoanl for neg_dia we are having i-j+n-1\\n            //if we take i-j we have [-3,-2,-1,0,1,2,3] which is not a valid index for array\\n            //adding n-1 will convert [0,1,2,3,4,5,6]\\n            \\n            //queen placed here ( so true means we can\\'t place other queen at any of this column, diagonally ) and check if we can place next queen in next row properly or not\\n            neg_dia[i-j+n-1]=true;\\n            pos_dia[i+j]=true;\\n            col[j]=true;\\n\\n            //queen placed\\n            board[i][j]=\\'Q\\';\\n            \\n            //checking for next row\\n            queen(board,i+1,ans,n);\\n            \\n            //means we placed queen at wrong location so we need to remove the queen\\n            board[i][j]=\\'.\\';\\n            \\n            //after removing the queen we can place next queen at this loaction\\n            //nothing present at this time ( because we removed queen ) so we convert this position to false (no queen present)\\n        \\n            neg_dia[i-j+n-1]=false;\\n            pos_dia[i+j]=false;\\n            col[j]=false;\\n\\t\\t\\n        }\\n        \\n\\t}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436621,
                "title": "elegant-concise-backtracking-solution-explanation",
                "content": "* **THIS IS A VERY CLASSICAL & GOOD PROBLEM TO UNDERSTAND BACKTRACKING.**\\n* **List Of Some Problems to understand Backtracking More Better :**\\n**`1. Subsets I`  |  `2. Subsets II`  | `3. Generate Parentheses` | `4. Rat Maze` | `5.  Letter Combinations of a Phone Number` | `6. Combination Sum` | 7. [Partition to K Equal Sum Subsets](http://leetcode.com/problems/partition-to-k-equal-sum-subsets/)**\\n\\nif you **find any mistakes pls** drop a comment,\\nif it makes any sense **Please Upvote :)**\\n* \\t**[C++]**\\n```\\nclass Solution {\\nprivate: int N;\\nprivate: vector<vector<string>> res;\\nprivate:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        // 1. checking if there\\'s any queen placed at the same row\\n        for(int i = col; i >= 0; --i) if(board[row][i] == \\'Q\\') return false;\\n        \\n        // 2. check if there is any other queen placed at upper left diagonal\\n        for(int i = row, j = col; i >= 0 && j >= 0; --i, --j) if(board[i][j] == \\'Q\\') return false;\\n        \\n        // 3. checking if there\\'s any placed at the bottom left diagonal\\n        for(int i = row, j = col; i < N && j >= 0; ++i, --j) if(board[i][j] == \\'Q\\') return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    void dfs(vector<string> &board, int col){\\n        if(col >= N) res.push_back(board);  // push our board into our solution space, when column is Over\\n        for(int row = 0; row < N; ++row){   // traversing in row while putting a queen at single place(col).\\n            if(isSafe(board, row, col)){\\n                board[row][col] = \\'Q\\';      // Placing Queen if the cell pass the safty checks\\n                dfs(board, col + 1);        // recur for next column \\n                board[row][col] = \\'.\\';      // backtrack step, from that path, to find other possibilities!\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        N = n;\\n        vector<string> board(N, string(N, \\'.\\'));\\n        dfs(board, 0);\\n        return res;\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(N^N) `, where N is no. of Rows & Cols.` [Very Worst Case]`**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate: int N;\\nprivate: vector<vector<string>> res;\\nprivate:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        // 1. checking if there\\'s any queen placed at the same row\\n        for(int i = col; i >= 0; --i) if(board[row][i] == \\'Q\\') return false;\\n        \\n        // 2. check if there is any other queen placed at upper left diagonal\\n        for(int i = row, j = col; i >= 0 && j >= 0; --i, --j) if(board[i][j] == \\'Q\\') return false;\\n        \\n        // 3. checking if there\\'s any placed at the bottom left diagonal\\n        for(int i = row, j = col; i < N && j >= 0; ++i, --j) if(board[i][j] == \\'Q\\') return false;\\n        \\n        return true;\\n    }\\nprivate:\\n    void dfs(vector<string> &board, int col){\\n        if(col >= N) res.push_back(board);  // push our board into our solution space, when column is Over\\n        for(int row = 0; row < N; ++row){   // traversing in row while putting a queen at single place(col).\\n            if(isSafe(board, row, col)){\\n                board[row][col] = \\'Q\\';      // Placing Queen if the cell pass the safty checks\\n                dfs(board, col + 1);        // recur for next column \\n                board[row][col] = \\'.\\';      // backtrack step, from that path, to find other possibilities!\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        N = n;\\n        vector<string> board(N, string(N, \\'.\\'));\\n        dfs(board, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316514,
                "title": "javascript-solution-readable-backtrack-beats-100-of-submissions-89-memory",
                "content": "```javascript\\nvar solveNQueens = function(n) {\\n    const result = [];\\n    placeQueens(result, n);\\n    return result;\\n};\\n\\nfunction placeQueens(result, size, board = [], row = 0) {\\n  if (row === size) {\\n    buildResult(result, board, size);\\n    return;\\n  }\\n    \\n    for(let col = 0; col < size; col++) {\\n      if (checkValidPlace(board, row, col, size)) {\\n        board.push(col);\\n        placeQueens(result, size, board, row + 1);\\n        board.pop();\\n      }\\n    }\\n}\\n\\nfunction checkValidPlace(board, row1, col1, size) {\\n  for( let row2 = 0; row2 < row1; row2++) {\\n    const col2 = board[row2];\\n    \\n    if (col1 === col2) {\\n      return false;\\n    }\\n    \\n    const colDistance = Math.abs(col1 - col2);\\n    const rowDistance = row1 - row2;\\n    \\n    if (colDistance === rowDistance) {\\n      return false;\\n    }\\n  }\\n  \\n  return true;\\n}\\n\\nfunction buildResult(result, board, size) {\\n      const boardWithQueens = board.map(col => \\n                          \\'.\\'.repeat(col) + \\'Q\\' + \\'.\\'.repeat(size - col - 1)\\n                         )\\n      \\n      result.push(boardWithQueens);\\n}\\n```\\n\\nKeeping track of the position of queens in the board variable, we only need to store a map from row -> columns, since we know that they are not going to be in the same row, we don\\'t need a 2D array.\\nWe know 2 queens might be in the same diagonal if the row and col distance are equal.\\n\\nFeel free to ask any question if it\\'s not obvious what\\'s happening.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar solveNQueens = function(n) {\\n    const result = [];\\n    placeQueens(result, n);\\n    return result;\\n};\\n\\nfunction placeQueens(result, size, board = [], row = 0) {\\n  if (row === size) {\\n    buildResult(result, board, size);\\n    return;\\n  }\\n    \\n    for(let col = 0; col < size; col++) {\\n      if (checkValidPlace(board, row, col, size)) {\\n        board.push(col);\\n        placeQueens(result, size, board, row + 1);\\n        board.pop();\\n      }\\n    }\\n}\\n\\nfunction checkValidPlace(board, row1, col1, size) {\\n  for( let row2 = 0; row2 < row1; row2++) {\\n    const col2 = board[row2];\\n    \\n    if (col1 === col2) {\\n      return false;\\n    }\\n    \\n    const colDistance = Math.abs(col1 - col2);\\n    const rowDistance = row1 - row2;\\n    \\n    if (colDistance === rowDistance) {\\n      return false;\\n    }\\n  }\\n  \\n  return true;\\n}\\n\\nfunction buildResult(result, board, size) {\\n      const boardWithQueens = board.map(col => \\n                          \\'.\\'.repeat(col) + \\'Q\\' + \\'.\\'.repeat(size - col - 1)\\n                         )\\n      \\n      result.push(boardWithQueens);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937670,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<vector<string> > solveNQueens(int n) {\\n        vector<vector<string> > res;\\n        vector<string> nQueens(n, string(n, \\'.\\'));\\n        solveNQueens(res, nQueens, 0, n);\\n        return res;\\n    }\\nprivate:\\n    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {\\n        if (row == n) {\\n            res.push_back(nQueens);\\n            return;\\n        }\\n        for (int col = 0; col != n; ++col)\\n            if (isValid(nQueens, row, col, n)) {\\n                nQueens[row][col] = \\'Q\\';\\n                solveNQueens(res, nQueens, row + 1, n);\\n                nQueens[row][col] = \\'.\\';\\n            }\\n    }\\n    bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {\\n        for (int i = 0; i != row; ++i)\\n            if (nQueens[i][col] == \\'Q\\')\\n                return false;\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)\\n            if (nQueens[i][j] == \\'Q\\')\\n                return false;\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)\\n            if (nQueens[i][j] == \\'Q\\')\\n                return false;\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<vector<string> > solveNQueens(int n) {\\n        vector<vector<string> > res;\\n        vector<string> nQueens(n, string(n, \\'.\\'));\\n        solveNQueens(res, nQueens, 0, n);\\n        return res;\\n    }\\nprivate:\\n    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {\\n        if (row == n) {\\n            res.push_back(nQueens);\\n            return;\\n        }\\n        for (int col = 0; col != n; ++col)\\n            if (isValid(nQueens, row, col, n)) {\\n                nQueens[row][col] = \\'Q\\';\\n                solveNQueens(res, nQueens, row + 1, n);\\n                nQueens[row][col] = \\'.\\';\\n            }\\n    }\\n    bool isValid(std::vector<std::string> &nQueens, int row, int col, int &n) {\\n        for (int i = 0; i != row; ++i)\\n            if (nQueens[i][col] == \\'Q\\')\\n                return false;\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j)\\n            if (nQueens[i][j] == \\'Q\\')\\n                return false;\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j)\\n            if (nQueens[i][j] == \\'Q\\')\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115346,
                "title": "simple-backtracking-c",
                "content": "```\\n\\t void fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n\\t void fun(vector<vector<string>>& ans, vector<string>& temp, int r, set<int>& c, set<int>& d1, set<int>& d2, int n) {\\n        \\n        if(r == n) {\\n           ans.push_back(temp); \\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(c.find(i) == c.end() && d1.find(r-i) == d1.end() && d2.find(r+i) == d2.end()) {\\n                \\n                c.insert(i); d1.insert(r-i); d2.insert(r+i);\\n                \\n                temp[r][i] = \\'Q\\';\\n                fun(ans, temp, r+1, c, d1, d2, n);\\n                temp[r][i] = \\'.\\';\\n                \\n                c.erase(i); d1.erase(r-i); d2.erase(r+i);\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        set<int> c, d1, d2;\\n        string dots = \"\";\\n        for(int i=0;i<n;i++) dots.push_back(\\'.\\');\\n        \\n        vector<string> temp(n, dots);\\n        vector<vector<string>> ans;\\n        fun(ans, temp, 0, c, d1, d2, n);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2111288,
                "title": "javascript-efficient-solution-meme",
                "content": "There is canonic solution with backtracking for the nQueen problem. You can read more on [Wikepedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle), or even find a video with detailed explanation, **my role here is rather give you a meme**.\\n```\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nvar solveNQueens = function(n) {\\n    const solutions = [];\\n    \\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    \\n    const board = Array.from({ length: n }, () => new Array(n).fill(\\'.\\'));\\n  \\n    function backtrack (row) {\\n        if (row === n) {\\n            solutions.push(board.map(a => a.join(\\'\\')));\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            board[row][col] = \\'Q\\';\\n            \\n            backtrack(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n            board[row][col] = \\'.\\';\\n        }   \\n    }\\n    \\n    backtrack(0);\\n    \\n    return solutions;\\n};\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#8 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/4442f433-a4ff-4acd-a38f-55678e6b4794_1654377089.7597315.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nvar solveNQueens = function(n) {\\n    const solutions = [];\\n    \\n    const cols = new Set();\\n    const posDiag = new Set();\\n    const negDiag = new Set();\\n    \\n    const board = Array.from({ length: n }, () => new Array(n).fill(\\'.\\'));\\n  \\n    function backtrack (row) {\\n        if (row === n) {\\n            solutions.push(board.map(a => a.join(\\'\\')));\\n            return;\\n        }\\n        \\n        for (let col = 0; col < n; col += 1) {\\n            if (cols.has(col) || posDiag.has(row + col) || negDiag.has(row - col)) {\\n                continue;\\n            }\\n            \\n            cols.add(col);\\n            posDiag.add(row + col);\\n            negDiag.add(row - col);\\n            board[row][col] = \\'Q\\';\\n            \\n            backtrack(row + 1);\\n            \\n            cols.delete(col);\\n            posDiag.delete(row + col);\\n            negDiag.delete(row - col);\\n            board[row][col] = \\'.\\';\\n        }   \\n    }\\n    \\n    backtrack(0);\\n    \\n    return solutions;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2108334,
                "title": "eazy-beginer-explanation-for-all",
                "content": "We first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n# \\uD83D\\uDC0DPYTHON CODE\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/cde42ba8-3562-4478-a2c5-3c6433a1f0b8_1654314052.04698.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107998,
                "title": "c-easy-backtracking",
                "content": "The basic Idea here is there will be one queen in each row and each col. For diagonals we can observe that the sum of row index and col index is const for diagonals with +ve slope As for diagonals with -ve slope the difference between indices is constant.\\n=> i-j = k;\\n=> i+j = c;\\nhere is the implementation:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    unordered_set<int> col;\\n    unordered_set<int> negD;\\n    unordered_set<int> posD;\\n    int size;\\n    \\n    void help(int n, vector<string>& prev)\\n    {\\n        if(n < 0)\\n        {\\n            ans.push_back(prev);\\n            return;\\n        }\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(col.find(i) == col.end() && negD.find(n-i) == negD.end() && posD.find(n+i) == posD.end())\\n            {\\n                col.insert(i);\\n                negD.insert(n-i);\\n                posD.insert(n+i);\\n                string s = \"\";\\n                for(int j = 0; j < size; j++)\\n                {\\n                    if(i == j) s+=\\'Q\\';\\n                    else s+=\\'.\\';\\n                }\\n                prev.push_back(s);\\n                help(n-1,prev);\\n                \\n                // backtracking part\\n                prev.pop_back();\\n                col.erase(col.find(i));\\n                negD.erase(negD.find(n-i));\\n                posD.erase(posD.find(n+i));\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        size = n;\\n        vector<string> prev;\\n        help(n-1,prev);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    unordered_set<int> col;\\n    unordered_set<int> negD;\\n    unordered_set<int> posD;\\n    int size;\\n    \\n    void help(int n, vector<string>& prev)\\n    {\\n        if(n < 0)\\n        {\\n            ans.push_back(prev);\\n            return;\\n        }\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(col.find(i) == col.end() && negD.find(n-i) == negD.end() && posD.find(n+i) == posD.end())\\n            {\\n                col.insert(i);\\n                negD.insert(n-i);\\n                posD.insert(n+i);\\n                string s = \"\";\\n                for(int j = 0; j < size; j++)\\n                {\\n                    if(i == j) s+=\\'Q\\';\\n                    else s+=\\'.\\';\\n                }\\n                prev.push_back(s);\\n                help(n-1,prev);\\n                \\n                // backtracking part\\n                prev.pop_back();\\n                col.erase(col.find(i));\\n                negD.erase(negD.find(n-i));\\n                posD.erase(posD.find(n+i));\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        size = n;\\n        vector<string> prev;\\n        help(n-1,prev);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605590,
                "title": "c-100-faster-backtracking-with-dp",
                "content": "Hi there, this solution involves usage of Backtracking and DP.\\nBacktracking: We call \"validpostion\" function for the next row, after placing the Queen on Chessboard CB as \\'Q\\'. When we are placing the Queen, we are marking the left, right diagonals and column top element as 1 indicating that you can\\'t place any other Queen along those diagonals and column cant be placed now.\\nTake note of the indices used for the diagonals.\\nFor any cell in the matrix, the right diagonal\\'s element can be represented with row+col index, the left diagonal\\'s element can be represented with n+row-col, and for column the col index can be used.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool validposition(vector<string> & CB, vector<int> &ldiag, vector<int> &rdiag, vector<int> &coltop, int n, int row, vector<vector<string> > &ans){\\n\\t\\t\\tif(row == n){\\n\\t\\t\\t\\tans.push_back(CB);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j = 0; j<n; j++){\\n\\t\\t\\t\\tif(ldiag[n+row-j] || rdiag[row+j] || coltop[j])\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tldiag[n+row-j] = rdiag[row+j] = coltop[j] = 1, CB[row][j] = \\'Q\\';\\n\\t\\t\\t\\tif(validposition(CB,ldiag, rdiag, coltop, n, row+1, ans))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tldiag[n+row-j] = rdiag[row+j] = coltop[j] = 0, CB[row][j] = \\'.\\';\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvector<vector<string>> solveNQueens(int n) {\\n\\t\\t\\tstring init = \"\";\\n\\t\\t\\tfor(int i =0; i<n; i++)\\n\\t\\t\\t\\tinit += \\'.\\';\\n\\t\\t\\tvector<string> CB (n, init);\\n\\t\\t\\tvector<int> ldiag(2*n, 0), rdiag(2*n, 0), coltop(n, 0);\\n\\t\\t\\tvector<vector<string> > ans;\\n\\t\\t\\tvalidposition(CB, ldiag, rdiag, coltop, n, 0, ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\nI hope it was clear. Let me know in the comments if you have any doubt.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool validposition(vector<string> & CB, vector<int> &ldiag, vector<int> &rdiag, vector<int> &coltop, int n, int row, vector<vector<string> > &ans){\\n\\t\\t\\tif(row == n){\\n\\t\\t\\t\\tans.push_back(CB);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1417273,
                "title": "c-n-queen-code-fast-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    bool isSafe(vector<string> &board, int x, int y){\\n        for(int row = 0; row < x; row++){\\n            if(board[row][y] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int row = x;                             //for upper left diagonal\\n        int col = y;\\n        while(row >= 0 && col >= 0){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n        row = x;                                //for upper right diagonal\\n        col = y;\\n        while(row >= 0 && col < board.size()){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n        return true;\\n    }\\n    void NQueen(vector<string> &board, int x){\\n        if(x == board.size()){\\n            res.push_back(board);\\n            return;\\n        }\\n        for(int col = 0; col < board.size(); col++){\\n            if(isSafe(board,x,col)){\\n                board[x][col] = \\'Q\\';\\n                \\n                NQueen(board,x+1);\\n                board[x][col] = \\'.\\';                //backtracking\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        if(n <= 0){\\n            return {{}};\\n        }\\n        vector<string> board(n,string(n,\\'.\\'));\\n        NQueen(board,0);\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\nLike if you like it\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    bool isSafe(vector<string> &board, int x, int y){\\n        for(int row = 0; row < x; row++){\\n            if(board[row][y] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        int row = x;                             //for upper left diagonal\\n        int col = y;\\n        while(row >= 0 && col >= 0){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n        row = x;                                //for upper right diagonal\\n        col = y;\\n        while(row >= 0 && col < board.size()){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n        return true;\\n    }\\n    void NQueen(vector<string> &board, int x){\\n        if(x == board.size()){\\n            res.push_back(board);\\n            return;\\n        }\\n        for(int col = 0; col < board.size(); col++){\\n            if(isSafe(board,x,col)){\\n                board[x][col] = \\'Q\\';\\n                \\n                NQueen(board,x+1);\\n                board[x][col] = \\'.\\';                //backtracking\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        if(n <= 0){\\n            return {{}};\\n        }\\n        vector<string> board(n,string(n,\\'.\\'));\\n        NQueen(board,0);\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n\\nLike if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223346,
                "title": "js-python-java-c-easy-backtracking-bit-manipulation-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nA naive approach here would attempt every possible combination of locations, but there are **(N^2)! / (N^2 - N)!** different combinations, which is up to **~1e17** when **N = 9**. Instead, we need to make sure we only attempt to place queens where it\\'s feasible to do so, based on the instructions. This would seem to call for a **depth first search** (**DFS**) approach with a **recursive** helper function (**place**), so that we only pursue workable combinations without wasting time on known dead-ends.\\n\\nFirst, we should consider how the queens will be placed. Since each row can only have one queen, our basic process will be to **place** a queen and then recurse to the next row. On each row, we\\'ll have to iterate through the possible options, check the cell for validity, then **place** the queen on the **board**. Once the recursion **return**s, we can **backtrack** and iterate to the next cell in the row.\\n\\nSince a queen has four axes of attack, we\\'ll need to check the three remaining axes (other than the horizontal row, which our iteration will naturally take care of) for validity. There are **N** possible columns and **2 * N - 1** possible left-downward diagonals and right-downward diagonals. With a constraint of **1 <= N <= 9,** each of the two diagonal states represents up to **17 bits**\\' worth of data and the vertical state up to **9 bits**, so we can use **bit manipulation** to store these states efficiently.\\n\\nSo for each recursive call to **place** a queen, we should pass along the board state in the form of only three integers (**vert, ldiag, rdiag**). We can then use **bitmasks** to check for cell validity before attempting to recurse to the next row.\\n\\nSince our **board** is an **N^2** matrix, we can use backtracking here to good effect. If we successfully reach the end of the board without failing, we should push a copy of  board with the rows as strings onto our answer array (**ans**). _(**Note**: It is possible to lower the **extra space** to only the size of the recursion stack, **O(N)**, by procedurally generating the results directly in **ans**, but it doesn\\'t represent a great deal of space savings compared to the extra processing it requires.)_\\n\\n - _**Time Complexity: O(N!)** which represents the maximum number of queens placed_\\n - _**Space Complexity: O(N^2)** for the board_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 40.8MB** (beats 100% / 76%).\\n```javascript\\nvar solveNQueens = function(N) {\\n    let ans = [],\\n        board = Array.from({length: N}, () => new Array(N).fill(\\'.\\'))\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) {\\n            let res = new Array(N)\\n            for (let row = 0; row < N; row++)\\n                res[row] = board[row].join(\"\")\\n            ans.push(res)\\n            return\\n        }\\n        for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            board[i][j] = \\'Q\\'\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            board[i][j] = \\'.\\'\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **48ms / 14.4MB** (beats 97% / 93%).\\n```python\\nclass Solution:\\n    def solveNQueens(self, N: int) -> List[List[str]]:\\n        ans = []\\n        board = [[\\'.\\'] * N for _ in range(N)]\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N:\\n                ans.append([\"\".join(row) for row in board])\\n                return\\n            for j in range(N):\\n                vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                board[i][j] = \\'Q\\'\\n                place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n                board[i][j] = \\'.\\'\\n            \\n        place(0,0,0,0)\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.8MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    List<List<String>> ans;\\n    char[][] board;\\n    \\n    public List<List<String>> solveNQueens(int N) {\\n        ans = new ArrayList<>();\\n        board = new char[N][N];\\n        for (char[] row : board) Arrays.fill(row, \\'.\\');\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.length;\\n        if (i == N) {\\n            List<String> res = new ArrayList<>();\\n            for (char[] row : board) res.add(new String(row));\\n            ans.add(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.9MB** (beats 100% / 41%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int N) {\\n        ans.clear();\\n        board.resize(N, string(N, \\'.\\'));\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> ans;\\n    vector<string> board;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.size();\\n        if (i == N) {\\n            vector<string> res;\\n            for (auto row : board) res.push_back(row);\\n            ans.push_back(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar solveNQueens = function(N) {\\n    let ans = [],\\n        board = Array.from({length: N}, () => new Array(N).fill(\\'.\\'))\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) {\\n            let res = new Array(N)\\n            for (let row = 0; row < N; row++)\\n                res[row] = board[row].join(\"\")\\n            ans.push(res)\\n            return\\n        }\\n        for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            board[i][j] = \\'Q\\'\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            board[i][j] = \\'.\\'\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def solveNQueens(self, N: int) -> List[List[str]]:\\n        ans = []\\n        board = [[\\'.\\'] * N for _ in range(N)]\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N:\\n                ans.append([\"\".join(row) for row in board])\\n                return\\n            for j in range(N):\\n                vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                board[i][j] = \\'Q\\'\\n                place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n                board[i][j] = \\'.\\'\\n            \\n        place(0,0,0,0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<List<String>> ans;\\n    char[][] board;\\n    \\n    public List<List<String>> solveNQueens(int N) {\\n        ans = new ArrayList<>();\\n        board = new char[N][N];\\n        for (char[] row : board) Arrays.fill(row, \\'.\\');\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\n    private void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.length;\\n        if (i == N) {\\n            List<String> res = new ArrayList<>();\\n            for (char[] row : board) res.add(new String(row));\\n            ans.add(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if ((vert & vmask) + (ldiag & lmask) + (rdiag & rmask) > 0) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int N) {\\n        ans.clear();\\n        board.resize(N, string(N, \\'.\\'));\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> ans;\\n    vector<string> board;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.size();\\n        if (i == N) {\\n            vector<string> res;\\n            for (auto row : board) res.push_back(row);\\n            ans.push_back(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046112,
                "title": "runtime-1-ms-faster-than-99-72-of-java-online-submissions-for-n-queens",
                "content": "Runtime: 1 ms, faster than 99.72% of Java online submissions for N-Queens.\\n```\\nclass Solution {\\n    public List<String> constructString(char[][] board) {\\n        List<String> res = new ArrayList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n    \\n    public void nQueens(char[][] board, int row, boolean[]columns, boolean [] normalDiagonal, boolean [] reverseDiagonal, List<List<String>> result){\\n        if(row==board.length){\\n            result.add(constructString(board));\\n            return;\\n        }\\n        \\n        for(int col=0;col<board[0].length;col++){\\n            if(columns[col]==false && normalDiagonal[row+col]==false && reverseDiagonal[row-col+board.length-1]==false){\\n                board[row][col]= \\'Q\\';\\n                columns[col]=true;\\n                normalDiagonal[row+col]=true;\\n                reverseDiagonal[row-col+board.length-1]=true;\\n                nQueens(board, row+1, columns, normalDiagonal, reverseDiagonal, result);\\n                board[row][col]= \\'.\\';\\n                columns[col]=false;\\n                normalDiagonal[row+col]=false;\\n                reverseDiagonal[row-col+board.length-1]=false;\\n            }\\n        }\\n    }\\n    \\n    \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<>();\\n        char [][] board = new char[n][n];\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n        // We will be placing queens row-wise.\\n        boolean [] columns = new boolean[n]; // While placing queen we will check if that particular column already has queen(true).\\n        boolean [] normalDiagonal = new boolean[2*n-1];// Diagonal: / && Number of diagonals possible: 2*n-1\\n        boolean [] reverseDiagonal = new boolean[2*n-1];// Diagonal: \\\\ && Number of diagonals possible: 2*n-1\\n        nQueens(board, 0, columns, normalDiagonal, reverseDiagonal, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> constructString(char[][] board) {\\n        List<String> res = new ArrayList<String>();\\n        for(int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n    \\n    public void nQueens(char[][] board, int row, boolean[]columns, boolean [] normalDiagonal, boolean [] reverseDiagonal, List<List<String>> result){\\n        if(row==board.length){\\n            result.add(constructString(board));\\n            return;\\n        }\\n        \\n        for(int col=0;col<board[0].length;col++){\\n            if(columns[col]==false && normalDiagonal[row+col]==false && reverseDiagonal[row-col+board.length-1]==false){\\n                board[row][col]= \\'Q\\';\\n                columns[col]=true;\\n                normalDiagonal[row+col]=true;\\n                reverseDiagonal[row-col+board.length-1]=true;\\n                nQueens(board, row+1, columns, normalDiagonal, reverseDiagonal, result);\\n                board[row][col]= \\'.\\';\\n                columns[col]=false;\\n                normalDiagonal[row+col]=false;\\n                reverseDiagonal[row-col+board.length-1]=false;\\n            }\\n        }\\n    }\\n    \\n    \\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> result = new ArrayList<>();\\n        char [][] board = new char[n][n];\\n        for(int row=0;row<n;row++){\\n            for(int col=0;col<n;col++){\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n        // We will be placing queens row-wise.\\n        boolean [] columns = new boolean[n]; // While placing queen we will check if that particular column already has queen(true).\\n        boolean [] normalDiagonal = new boolean[2*n-1];// Diagonal: / && Number of diagonals possible: 2*n-1\\n        boolean [] reverseDiagonal = new boolean[2*n-1];// Diagonal: \\\\ && Number of diagonals possible: 2*n-1\\n        nQueens(board, 0, columns, normalDiagonal, reverseDiagonal, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19862,
                "title": "java-clean-accepted-solution-92-3",
                "content": "    public class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> list=new ArrayList<List<String>>();\\n        dfs(new int[n],0,n,list);\\n        return list;\\n    }\\n    public void dfs(int[] pos,int step,int n,List<List<String>> list) {\\n        if(step==n) {\\n            ArrayList<String> ls=printboard(pos,n);\\n            list.add(new ArrayList<String>(ls));\\n            return;\\n        }\\n        for(int i=0;i<n;i++) {\\n            pos[step]=i;\\n            if(isvalid(pos,step)) {\\n                dfs(pos,step+1,n,list);\\n            }\\n        }\\n    }\\n    public boolean isvalid(int[] pos, int step) {\\n        for(int i=0;i<step;i++) {\\n            if(pos[i]==pos[step]||(Math.abs(pos[i]-pos[step]))==(step-i)) return false;\\n            \\n        }\\n        return true;\\n    }\\n    public ArrayList<String> printboard(int[] pos,int n) {\\n        ArrayList<String> ls=new ArrayList<String>();\\n        for(int i=0;i<n;i++) {\\n            StringBuilder sb=new StringBuilder();\\n            for(int j=0;j<n-1;j++) sb.append('.');\\n            sb.insert(pos[i],'Q');\\n            ls.add(sb.toString());\\n            \\n        }\\n        return ls;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> list=new ArrayList<List<String>>();\\n        dfs(new int[n],0,n,list);\\n        return list;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 20018,
                "title": "accepted-python-solution-backtracking",
                "content": "    class Solution:\\n        # @return a list of lists of string\\n        def solveNQueens(self, n):\\n            self.result = []\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.result\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                solution = []\\n                for row in self.board:\\n                    string = \"\"\\n                    for char in row:\\n                        string += char\\n                    solution.append(string)\\n                self.result.append(solution)\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True",
                "solutionTags": [],
                "code": "    class Solution:\\n        # @return a list of lists of string\\n        def solveNQueens(self, n):\\n            self.result = []\\n            self.board = [[\".\" for x in range(n)] for x in range(n)]\\n            self.n = n\\n            self.solve(0)\\n            return self.result\\n        \\n        def solve(self, col):\\n            if col == self.n:\\n                solution = []\\n                for row in self.board:\\n                    string = \"\"\\n                    for char in row:\\n                        string += char\\n                    solution.append(string)\\n                self.result.append(solution)\\n                return\\n                \\n            for row in range(self.n):\\n                if self.isSafe(row, col):\\n                    self.board[row][col] = \"Q\"\\n                    self.solve(col+1)\\n                    self.board[row][col] = \".\"\\n            \\n        def isSafe(self, row, col):\\n            for c in range(col):\\n                if self.board[row][c] == \"Q\":\\n                    return False\\n            rup = row-1\\n            rdown = row+1\\n            c = col-1\\n            while c >= 0:\\n                if rup >= 0:\\n                    if self.board[rup][c] == \"Q\":\\n                        return False\\n                if rdown < self.n:\\n                    if self.board[rdown][c] == \"Q\":\\n                        return False\\n                rup -= 1\\n                rdown += 1\\n                c -= 1\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 20029,
                "title": "my-solution-based-on-dfs",
                "content": "First  write down the basic DFS Algorithm framework which is common  to all DFS problems.<br>\\nThen determine the constraint & bound function for this special DFS  problem. For N-Queen problem the constraint is the selection of column of current line should not be one of the columns of already       determined lines and also should not form a 45 angle with already determined queens.\\n\\n\\n   \\n\\n     class Solution {\\n            public:\\n                vector<vector<string> > solveNQueens(int n) {\\n                    if(n<1) return output;\\n                    vector<int> x(n);\\n                    DFS(0,x,n);\\n                    return output;\\n                }\\n                void DFS(int t, vector<int> &x, int n)\\n                {\\n                    if(t>=n)\\n                    {            \\n                        vector<string> matrix;\\n                        for(int i=0;i<n;i++)\\n                        {\\n                            string line(n,'.');\\n                            line[x[i]]='Q';\\n                            matrix.push_back(line);\\n                        }\\n                        output.push_back(matrix);\\n                    }\\n                    else\\n                    {\\n                        for(int i=0;i<n;i++)\\n                        {\\n                            bool skip =false;\\n                            for(int j=0;j<t;j++)\\n                            {\\n                                if(x[j]==i || abs(i-x[j])==abs(t-j))\\n                                {\\n                                    skip = true;\\n                                    break;\\n                                }\\n                            }\\n                            if(skip) continue;\\n                            x[t]= i;\\n                            DFS(t+1, x, n);\\n                        }\\n                    }\\n                }\\n                vector<vector<string>> output;\\n            };",
                "solutionTags": [],
                "code": "class Solution {\\n            public:\\n                vector<vector<string> > solveNQueens(int n) {\\n                    if(n<1) return output;\\n                    vector<int> x(n);\\n                    DFS(0,x,n);\\n                    return output;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3315401,
                "title": "backtracking-logic-solution",
                "content": "\\n# 1. BackTracking Solution\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        col,pos,neg,list1=set(),set(),set(),[]\\n        board=[[\".\"]*n for i in range(n)]\\n        def backtrack(r):\\n            if n==r:\\n                copy=[\"\".join(row) for row in board]\\n                list1.append(copy)\\n                return \\n            for c in range(n):\\n                if c in col or (r+c) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                board[r][c]=\"Q\"\\n                backtrack(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n                board[r][c]=\".\"\\n        backtrack(0)\\n        return list1\\n    //please upvote me it would encourage me alot\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        col,pos,neg,list1=set(),set(),set(),[]\\n        board=[[\".\"]*n for i in range(n)]\\n        def backtrack(r):\\n            if n==r:\\n                copy=[\"\".join(row) for row in board]\\n                list1.append(copy)\\n                return \\n            for c in range(n):\\n                if c in col or (r+c) in pos or (r-c) in neg:\\n                    continue\\n                col.add(c)\\n                pos.add(c+r)\\n                neg.add(r-c)\\n                board[r][c]=\"Q\"\\n                backtrack(r+1)\\n                col.remove(c)\\n                pos.remove(c+r)\\n                neg.remove(r-c)\\n                board[r][c]=\".\"\\n        backtrack(0)\\n        return list1\\n    //please upvote me it would encourage me alot\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479639,
                "title": "clean-concise-c-solution-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    int n;\\n\\t\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t    // storing the possible answers\\n            res.push_back(ans);\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int num) {\\n        n = num;\\n        vector<string> ans(n);\\n\\t\\t// initializing vector with \".......n\"\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> res;\\n    int n;\\n\\t\\n\\t// Check whether placing a new queen at given point is safe or not\\n    bool isSafe(vector<string> arr, int x, int y){\\n        for (int row=0; row<x; row++){\\n            if (arr[row][y]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n    \\n        int row = x;\\n        int col = y;\\n        while(row>=0 && col>=0){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n    \\n        row = x;\\n        col = y;\\n        while(row>=0 && col<n){\\n            if (arr[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col++;\\n        }\\n    \\n        return true;\\n    }\\n\\n    void nQueen(vector<string> &ans, int i){\\n        if (i>=n){\\n\\t\\t    // storing the possible answers\\n            res.push_back(ans);\\n            return;\\n        }\\n        \\n        for(int k=0;k<n;k++){\\n            if(isSafe(ans,i,k)){\\n                ans[i][k] = \\'Q\\';\\n                nQueen(ans,i+1);\\n                ans[i][k] = \\'.\\';  // backtracking\\n            }\\n        }        \\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int num) {\\n        n = num;\\n        vector<string> ans(n);\\n\\t\\t// initializing vector with \".......n\"\\n        string temp = \"\";\\n        for(int j=0;j<n;j++)\\n            temp+=\\'.\\';\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = temp;\\n        \\n        nQueen(ans,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109862,
                "title": "runtime-0-ms-faster-than-100-00-of-c-submissions-shortest-code-easy-to-understand",
                "content": "To avoid queens from attacking each other, there shouldn\\'t be any two queens on the same row, column, diagonal.\\n\\nIt is easy to determine if there are not two queens on the same row by selecting (recursing on) a different row every time. And regarding the column, you can just make a boolean array of size n and mark the jth cell as visited to avoid using this column again.\\n\\nWhat about the diagonals??\\n\\n![image](https://assets.leetcode.com/users/images/82d9d179-8ad2-43c3-8232-d2d464facb4a_1654349698.4062574.jpeg)\\n\\n\\nThere\\'s a relation between rows and columns of the main diagonal and secondary diagonal.\\nIf we looked at the main diagonal (marked with red) you will find that the summation of row+col of each cell will be equal to 7!!\\nwhat about the secondary diagonal?! the summation isn\\'t equal. But subtraction is ;) \\nDifference between each cell on the secondary diagonal equals to 2!\\n\\nThis might help you to mark columns and both diagonals ^^\\n\\nUp vote if you liked it <3 \\n\\n```\\nclass Solution {\\npublic:\\n    // Container that holds the answer\\n    vector< vector<string> >ans;\\n    // Boolean arrays to mark columns, and diagonals\\n    bool visCols[9],mainDiag[20],secDiag[20];    \\n    void doWork(int row,int n,vector<string>&board)\\n    {\\n        if(row==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        for(int col=0;col<n;col++)\\n        {\\n            if(!visCols[col] && !mainDiag[n+row-col] && !secDiag[row+col])\\n            {\\n                board[row][col]=\\'Q\\';\\n                visCols[col] = mainDiag[n+row-col] = secDiag[row+col] = true;\\n                doWork(row+1,n,board);\\n                visCols[col] = mainDiag[n+row-col] = secDiag[row+col] = false;\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string>board(n,string(n,\\'.\\'));\\n        doWork(0,n,board);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Container that holds the answer\\n    vector< vector<string> >ans;\\n    // Boolean arrays to mark columns, and diagonals\\n    bool visCols[9],mainDiag[20],secDiag[20];    \\n    void doWork(int row,int n,vector<string>&board)\\n    {\\n        if(row==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        for(int col=0;col<n;col++)\\n        {\\n            if(!visCols[col] && !mainDiag[n+row-col] && !secDiag[row+col])\\n            {\\n                board[row][col]=\\'Q\\';\\n                visCols[col] = mainDiag[n+row-col] = secDiag[row+col] = true;\\n                doWork(row+1,n,board);\\n                visCols[col] = mainDiag[n+row-col] = secDiag[row+col] = false;\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string>board(n,string(n,\\'.\\'));\\n        doWork(0,n,board);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310620,
                "title": "c-cleanest-no-bitmasking-improved-time-complexity",
                "content": "**IDEA:** To use row, col , ld ,rd vector to check previously occupied positions\\n**NOTE:**\\n* row vector check whether there\\'s another queen in the same row\\n* col vector check whether there\\'s another queen in the same col\\n* for **left diagonal** (originate from left-top) **difference=i-j is same** , cant store neg index so increment it by n\\n* for **right diagona**l of a matrix **i+j is same**\\n\\n\\n```\\nint size;\\nvector<int> row = vector<int>(10, 0);\\nvector<int> col = vector<int>(10, 0);\\nvector<int> ld = vector<int>(20, 0);\\nvector<int> rd = vector<int>(20, 0);\\nvector<vector<string> > res;\\n\\nbool safe(int i, int j){\\n    return row[i] == 0 && col[j] == 0 && rd[i + j] == 0 && ld[i - j + size ] == 0;   }\\n\\nvoid helper(int i, vector<string>& v)\\n{\\n    if (i == size) {\\n        res.push_back(v);\\n        return;\\n    }\\n\\n    // Placing at ith and jth position\\n    for (int j = 0; j < size; j++) {\\n\\n        if (safe(i, j)) {\\n            \\n            // Marking\\n            row[i] = col[j] = rd[i + j] = ld[i - j + size ] = 1;\\n\\n            v[i][j] = \\'Q\\'; // Placing\\n            helper(i + 1, v);   // Recursion\\n\\n            // BackTracking (Unmarking)\\n            row[i] = col[j] = rd[i + j] = ld[i - j + size ] = 0;\\n            v[i][j] = \\'.\\';\\n        }\\n    }\\n}\\nvector<vector<string> > solveNQueens(int n)\\n{\\n    size = n;\\n    string s(n,\\'.\\');\\n    vector<string> v(n, s);\\n    helper(0, v);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint size;\\nvector<int> row = vector<int>(10, 0);\\nvector<int> col = vector<int>(10, 0);\\nvector<int> ld = vector<int>(20, 0);\\nvector<int> rd = vector<int>(20, 0);\\nvector<vector<string> > res;\\n\\nbool safe(int i, int j){\\n    return row[i] == 0 && col[j] == 0 && rd[i + j] == 0 && ld[i - j + size ] == 0;   }\\n\\nvoid helper(int i, vector<string>& v)\\n{\\n    if (i == size) {\\n        res.push_back(v);\\n        return;\\n    }\\n\\n    // Placing at ith and jth position\\n    for (int j = 0; j < size; j++) {\\n\\n        if (safe(i, j)) {\\n            \\n            // Marking\\n            row[i] = col[j] = rd[i + j] = ld[i - j + size ] = 1;\\n\\n            v[i][j] = \\'Q\\'; // Placing\\n            helper(i + 1, v);   // Recursion\\n\\n            // BackTracking (Unmarking)\\n            row[i] = col[j] = rd[i + j] = ld[i - j + size ] = 0;\\n            v[i][j] = \\'.\\';\\n        }\\n    }\\n}\\nvector<vector<string> > solveNQueens(int n)\\n{\\n    size = n;\\n    string s(n,\\'.\\');\\n    vector<string> v(n, s);\\n    helper(0, v);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729239,
                "title": "python-clean-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    \\n    def isValid(self, location, queens):\\n        row, col = location\\n        for queen in queens:\\n            x, y = queen\\n            if abs(row - x) == abs(col - y):\\n                return False\\n            if row == x or col == y:\\n                return False\\n        return True\\n    \\n    def nextQueen(self, grid):\\n        for x in range(len(grid)):\\n            for y in range(len(grid[x])):\\n                if grid[x][y] == \\'.\\':\\n                    return (x, y)\\n        return None\\n    \\n    def solve(self, grid, n, col, queens, solution):\\n        if col >= n:\\n            solution.append([\\'\\'.join(reversed(row)) for row in grid])\\n        for i in range(n):\\n            if self.isValid((i, col), queens):\\n                grid[i][col] = \\'Q\\'\\n                queens.append((i, col))\\n                self.solve(grid, n, col + 1, queens, solution)\\n                grid[i][col] = \\'.\\'\\n                queens.remove((i, col))\\n        return\\n    \\n    def solveNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        queens = []\\n        grid = [[\\'.\\' for i1 in range(n)] for i2 in range(n)]\\n        solution = []\\n        self.solve(grid, n, 0, queens, solution)\\n        \\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def isValid(self, location, queens):\\n        row, col = location\\n        for queen in queens:\\n            x, y = queen\\n            if abs(row - x) == abs(col - y):\\n                return False\\n            if row == x or col == y:\\n                return False\\n        return True\\n    \\n    def nextQueen(self, grid):\\n        for x in range(len(grid)):\\n            for y in range(len(grid[x])):\\n                if grid[x][y] == \\'.\\':\\n                    return (x, y)\\n        return None\\n    \\n    def solve(self, grid, n, col, queens, solution):\\n        if col >= n:\\n            solution.append([\\'\\'.join(reversed(row)) for row in grid])\\n        for i in range(n):\\n            if self.isValid((i, col), queens):\\n                grid[i][col] = \\'Q\\'\\n                queens.append((i, col))\\n                self.solve(grid, n, col + 1, queens, solution)\\n                grid[i][col] = \\'.\\'\\n                queens.remove((i, col))\\n        return\\n    \\n    def solveNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        queens = []\\n        grid = [[\\'.\\' for i1 in range(n)] for i2 in range(n)]\\n        solution = []\\n        self.solve(grid, n, 0, queens, solution)\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359220,
                "title": "detailed-explanation-of-n-queens-problem-using-backtracking-c",
                "content": "Go through the code step by step by solveNQueens function !\\n```\\nclass Solution {\\npublic:\\n    string s;\\n    vector<string> board;\\n    //answer storing vector\\n    vector<vector<string>> v;\\n    //function to check whether a position is possible by taking into consideration of rest of the queens on the board\\n    bool isPossible(int n,int row,int col){\\n        //Checking for same column queen\\n        for(int i=row-1;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //Checking for left upper diagonal queen\\n        int i=0;\\n         while(col-i>=0&&row-i>=0){\\n            if(board[row-i][col-i]==\\'Q\\')\\n                return false;\\n             i++;\\n        }\\n        //checking for right upper diagonal queen\\n        i=0;\\n         while(col+i<n&&row-i>=0){\\n            if(board[row-i][col+i]==\\'Q\\')\\n                return false;\\n             i++;\\n        }\\n        return true;\\n    }\\n    \\n        void nQueenHelper(int n,int rowNo){\\n//if it exceeds the board and goes to nth indexed row ((n+1)th numbered row) then we need to print capture that result to answer \\n        if(n==rowNo){ \\n            v.push_back(board);\\n            return;\\n        }\\n//else we just have to start from zeroth column and start to check whether placement of a queen at a particular position is possible or not. If its possible then just placing the queen there itself and exploring for the next row. Make sure to place dot  after exploration of the path\\n            \\n        for(int i=0;i<n;i++){\\n            if(isPossible(n,rowNo,i)){\\n                board[rowNo][i]=\\'Q\\';\\n                nQueenHelper(n,rowNo+1);\\n                board[rowNo][i]=\\'.\\';\\n            }  \\n        }\\n        return;\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        //Initialising the board matrix with all dots \\'.\\' in it\\n        int y=n;s=\"\";\\n        while(y--){\\n            s+=\\'.\\';\\n        }\\n        for(int i=0;i<n;i++){\\n           board.push_back(s);\\n        } \\n        //Making a function that allows you to place in nXn board starting with zeroth row \\n        nQueenHelper(n,0);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string s;\\n    vector<string> board;\\n    //answer storing vector\\n    vector<vector<string>> v;\\n    //function to check whether a position is possible by taking into consideration of rest of the queens on the board\\n    bool isPossible(int n,int row,int col){\\n        //Checking for same column queen\\n        for(int i=row-1;i>=0;i--){\\n            if(board[i][col]==\\'Q\\')\\n                return false;\\n        }\\n        //Checking for left upper diagonal queen\\n        int i=0;\\n         while(col-i>=0&&row-i>=0){\\n            if(board[row-i][col-i]==\\'Q\\')\\n                return false;\\n             i++;\\n        }\\n        //checking for right upper diagonal queen\\n        i=0;\\n         while(col+i<n&&row-i>=0){\\n            if(board[row-i][col+i]==\\'Q\\')\\n                return false;\\n             i++;\\n        }\\n        return true;\\n    }\\n    \\n        void nQueenHelper(int n,int rowNo){\\n//if it exceeds the board and goes to nth indexed row ((n+1)th numbered row) then we need to print capture that result to answer \\n        if(n==rowNo){ \\n            v.push_back(board);\\n            return;\\n        }\\n//else we just have to start from zeroth column and start to check whether placement of a queen at a particular position is possible or not. If its possible then just placing the queen there itself and exploring for the next row. Make sure to place dot  after exploration of the path\\n            \\n        for(int i=0;i<n;i++){\\n            if(isPossible(n,rowNo,i)){\\n                board[rowNo][i]=\\'Q\\';\\n                nQueenHelper(n,rowNo+1);\\n                board[rowNo][i]=\\'.\\';\\n            }  \\n        }\\n        return;\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        //Initialising the board matrix with all dots \\'.\\' in it\\n        int y=n;s=\"\";\\n        while(y--){\\n            s+=\\'.\\';\\n        }\\n        for(int i=0;i<n;i++){\\n           board.push_back(s);\\n        } \\n        //Making a function that allows you to place in nXn board starting with zeroth row \\n        nQueenHelper(n,0);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307366,
                "title": "4ms-n-queens-c",
                "content": "The simplest approach to this problem would be to conduct a complete search over the search space. This brute force method would evaluate `(n^2)C(n)` possibilities. As an improvement, we wish to prune the search space. After recognizing that queens cannot lie on the same column or row, we eventually arrive at the one-dimensional representation of `row_grid`, where each index of the vector represents the column number, and its value the row number for a Queen. This is intuitive since we can now \"build\" the solution from left to right in a column sweeping motion to check for valid solutions, and prune solutions that violate the unique row and column stipulation. Notice that a valid solution must be a permutation of `n`, since the values themselves represent the row that a Queen is on, and Queens on the same row can attack each other (invalid). This reduces the solution to `O(n!)`, as we would only need to check all possible permutations of row_grid. By adding an additional check of diagonals in `isValid`, we obtain an improved **sub** `O(n!)` solution (another pruning condition). The code is shown below. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int grid_size) {\\n        n = grid_size; row_grid = vector<int> (n,0);\\n        current_board = vector<string> (n, string(n, \\'.\\'));\\n        buildNQueens(0);\\n        return res;\\n    }\\nprivate:\\n    int n; \\n    // row_grid is our current representation. \\n    // Example: for a grid of size 4, [a,b,c,d] would indicate that at column 0 (index 0 in row_grid) a queen is placed at row a (0 indexed), at column 1 a queen is placed at row b, and so on.\\n    vector<int> row_grid;\\n    vector<string> current_board;\\n    vector<vector<string>> res;\\n    \\n    // recursive helper to backtrack, sweeping from left to right (column wise).\\n    void buildNQueens(int col) {\\n        if (col == n) {\\n            res.push_back(current_board);\\n            return;\\n        }\\n        for (int row = 0; row != n; ++row) {\\n            // can we place a queen at (row, col)?\\n            if (isValid(row, col)) {\\n                // place the Queen at this row for this column.\\n                row_grid[col] = row;\\n                current_board[row][col] = \\'Q\\';\\n                buildNQueens(col+1);\\n                current_board[row][col] = \\'.\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    // check if the current board can accept a queen to be placed at (r,c)\\n    bool isValid(int r, int c) {\\n        // checking up to the current column that has been placed\\n        for(int prev = 0; prev < c; ++prev) {\\n            // check for violation of previous rows or if its on the same diagonal\\n            if(row_grid[prev] == r || (abs(row_grid[prev] - r) == abs(prev - c))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int grid_size) {\\n        n = grid_size; row_grid = vector<int> (n,0);\\n        current_board = vector<string> (n, string(n, \\'.\\'));\\n        buildNQueens(0);\\n        return res;\\n    }\\nprivate:\\n    int n; \\n    // row_grid is our current representation. \\n    // Example: for a grid of size 4, [a,b,c,d] would indicate that at column 0 (index 0 in row_grid) a queen is placed at row a (0 indexed), at column 1 a queen is placed at row b, and so on.\\n    vector<int> row_grid;\\n    vector<string> current_board;\\n    vector<vector<string>> res;\\n    \\n    // recursive helper to backtrack, sweeping from left to right (column wise).\\n    void buildNQueens(int col) {\\n        if (col == n) {\\n            res.push_back(current_board);\\n            return;\\n        }\\n        for (int row = 0; row != n; ++row) {\\n            // can we place a queen at (row, col)?\\n            if (isValid(row, col)) {\\n                // place the Queen at this row for this column.\\n                row_grid[col] = row;\\n                current_board[row][col] = \\'Q\\';\\n                buildNQueens(col+1);\\n                current_board[row][col] = \\'.\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    // check if the current board can accept a queen to be placed at (r,c)\\n    bool isValid(int r, int c) {\\n        // checking up to the current column that has been placed\\n        for(int prev = 0; prev < c; ++prev) {\\n            // check for violation of previous rows or if its on the same diagonal\\n            if(row_grid[prev] == r || (abs(row_grid[prev] - r) == abs(prev - c))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19815,
                "title": "1-line-python-solution",
                "content": "````\\n    def solveNQueens(self, n):\\n        return [['.' * v + 'Q' + '.' * (n - v - 1) for v in c] for c in itertools.permutations(range(n))\\n                if (len(set(i + v for i, v in enumerate(c))) == n) and\\n                (len(set(i - v for i, v in enumerate(c))) == n)]",
                "solutionTags": [],
                "code": "````\\n    def solveNQueens(self, n):\\n        return [['.' * v + 'Q' + '.' * (n - v - 1) for v in c] for c in itertools.permutations(range(n))\\n                if (len(set(i + v for i, v in enumerate(c))) == n) and\\n                (len(set(i - v for i, v in enumerate(c))) == n)]",
                "codeTag": "Python3"
            },
            {
                "id": 19859,
                "title": "modular-programming-c",
                "content": "```\\npublic class Solution {\\n    \\n    List<IList<string>> res = new List<IList<string>>();  \\n    int n;\\n    \\n    public IList<IList<string>> SolveNQueens(int n) {\\n        this.n = n;\\n        var arr = new char[n][];\\n        InitializeArray(arr);\\n        Helper(arr, 0);\\n        return res;\\n    }\\n    \\n    void Helper(char[][] arr, int col)\\n    {\\n        if(col == n)\\n        {\\n            ConvertStringArr(arr);\\n            return;\\n        }\\n        \\n        for(int row = 0; row < n; row++)\\n        {\\n            if(IsValid(arr, row, col))\\n            {\\n                arr[row][col] = 'Q';\\n                Helper(arr, col+1);   \\n                arr[row][col] = '.';\\n            }\\n        }\\n    }\\n    \\n    bool IsValid(char[][] arr, int x, int y)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < y; j++)\\n            {\\n                if(arr[i][j] == 'Q' && ((i == x) || x == (y-j) + i || x == i - (y-j)))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void ConvertStringArr(char[][] arr)\\n    {\\n        var list = new List<string>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            list.Add(new string(arr[i]));\\n        }\\n        res.Add(list);\\n    }\\n    \\n    void InitializeArray(char[][] arr)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = new char[n];\\n            for(int j = 0; j < n; j++)\\n            {\\n                arr[i][j] = '.';\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    List<IList<string>> res = new List<IList<string>>();  \\n    int n;\\n    \\n    public IList<IList<string>> SolveNQueens(int n) {\\n        this.n = n;\\n        var arr = new char[n][];\\n        InitializeArray(arr);\\n        Helper(arr, 0);\\n        return res;\\n    }\\n    \\n    void Helper(char[][] arr, int col)\\n    {\\n        if(col == n)\\n        {\\n            ConvertStringArr(arr);\\n            return;\\n        }\\n        \\n        for(int row = 0; row < n; row++)\\n        {\\n            if(IsValid(arr, row, col))\\n            {\\n                arr[row][col] = 'Q';\\n                Helper(arr, col+1);   \\n                arr[row][col] = '.';\\n            }\\n        }\\n    }\\n    \\n    bool IsValid(char[][] arr, int x, int y)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < y; j++)\\n            {\\n                if(arr[i][j] == 'Q' && ((i == x) || x == (y-j) + i || x == i - (y-j)))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void ConvertStringArr(char[][] arr)\\n    {\\n        var list = new List<string>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            list.Add(new string(arr[i]));\\n        }\\n        res.Add(list);\\n    }\\n    \\n    void InitializeArray(char[][] arr)\\n    {\\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = new char[n];\\n            for(int j = 0; j < n; j++)\\n            {\\n                arr[i][j] = '.';\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764185,
                "title": "backtracking-logic-solution",
                "content": "\\n# 1. BackTracking Solution\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board=[]\\n        ans=[]\\n        lrow=[0]*n\\n        upperd=[0]*(2*n-1)\\n        lowerd=[0]*(2*n-1)\\n        self.solve(0,board,ans,lrow,lowerd,upperd,n)\\n        return ans\\n    def solve(self,col,board,ans,lrow,lowerd,upperd,n):\\n        if col==n:\\n            ans.append(board[::])\\n            return\\n        for row in range(n):\\n            if lrow[row]==0 and upperd[n-1+col-row]==0 and lowerd[row+col]==0:\\n                board.append(\".\"*(row)+\"Q\"+\".\"*(n-row-1))\\n                lrow[row]=1\\n                upperd[n-1+col-row]=1\\n                lowerd[row+col]=1\\n                self.solve(col+1,board,ans,lrow,lowerd,upperd,n)\\n                board.pop()\\n                lrow[row]=0\\n                upperd[n-1+col-row]=0\\n                lowerd[row+col]=0\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board=[]\\n        ans=[]\\n        lrow=[0]*n\\n        upperd=[0]*(2*n-1)\\n        lowerd=[0]*(2*n-1)\\n        self.solve(0,board,ans,lrow,lowerd,upperd,n)\\n        return ans\\n    def solve(self,col,board,ans,lrow,lowerd,upperd,n):\\n        if col==n:\\n            ans.append(board[::])\\n            return\\n        for row in range(n):\\n            if lrow[row]==0 and upperd[n-1+col-row]==0 and lowerd[row+col]==0:\\n                board.append(\".\"*(row)+\"Q\"+\".\"*(n-row-1))\\n                lrow[row]=1\\n                upperd[n-1+col-row]=1\\n                lowerd[row+col]=1\\n                self.solve(col+1,board,ans,lrow,lowerd,upperd,n)\\n                board.pop()\\n                lrow[row]=0\\n                upperd[n-1+col-row]=0\\n                lowerd[row+col]=0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309804,
                "title": "2ms-backtracking-short-sweet-easy-to-understnd-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i,int j,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl){\\n        if(r[i]||c[j]||lr[i-j+n]||rl[i+j]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    void solve(int i,int n,vector<bool> &r,vector<bool> &c,vector<bool> &lr,vector<bool> &rl,vector<vector<string>> &ans,vector<string> &tmp){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(check(i,j,n,r,c,lr,rl)){\\n                string str(n,\\'.\\');\\n                str[j] = \\'Q\\';\\n                tmp.push_back(str);\\n                r[i] = true;\\n                c[j] = true;\\n                rl[i+j] = true;\\n                lr[i-j+n] = true;\\n                solve(i+1,n,r,c,lr,rl,ans,tmp);\\n                r[i] = false;\\n                c[j] = false;\\n                rl[i+j] = false;\\n                lr[i-j+n] = false;\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<bool> r(n,false);\\n        vector<bool> c(n,false);\\n        vector<bool> lr(2*n,false);\\n        vector<bool> rl(2*n,false);\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(0,n,r,c,lr,rl,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244489,
                "title": "beats-99-80-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe n-queens problem can be solved using backtracking. We can start with an empty chessboard and try to place queens one by one in each row such that no two queens attack each other. If we reach the last row and successfully place a queen, we have found a solution.\\n\\nTo check if a queen can be placed at a given position, we need to check if there is no other queen in the same column, diagonal, and anti-diagonal. We can keep track of the occupied columns and diagonals using arrays.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a recursive `backtrack` function that takes the current row as input.\\n- If we have reached the last row, add the current solution to the list of solutions and return.\\n- Try to place a queen in each column of the current row.\\n- If a queen can be placed at a given position, mark the column, diagonal, and anti-diagonal as occupied, and move to the next row.\\n- If we cannot place a queen at a given position, try the next position in the same row.\\n- If we have tried all positions in the current row and could not place a queen, backtrack to the previous row, unmark the column, diagonal, and anti-diagonal, and try the next position in the previous row.\\n- At the end, return the list of solutions.\\n# Complexity\\n- Time complexity: The time complexity of the `backtrack` function is exponential, as we need to try all possible combinations of queens on the board. The number of solutions for the n-queens problem is known to be O(n!), so the overall time complexity is O(n!).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is O(n^2), as we need to store the chessboard and the occupied columns and diagonals. The recursive stack also uses O(n) space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def backtrack(row):\\n            if row == n:\\n                solutions.append([\"\".join(row) for row in board])\\n                return\\n            for col in range(n):\\n                if not cols[col] and not diag[row+col] and not anti_diag[row-col]:\\n                    board[row][col] = \\'Q\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = True, True, True\\n                    backtrack(row+1)\\n                    board[row][col] = \\'.\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = False, False, False\\n        \\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        cols, diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\\n        solutions = []\\n        backtrack(0)\\n        return solutions\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def backtrack(row):\\n            if row == n:\\n                solutions.append([\"\".join(row) for row in board])\\n                return\\n            for col in range(n):\\n                if not cols[col] and not diag[row+col] and not anti_diag[row-col]:\\n                    board[row][col] = \\'Q\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = True, True, True\\n                    backtrack(row+1)\\n                    board[row][col] = \\'.\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = False, False, False\\n        \\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        cols, diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\\n        solutions = []\\n        backtrack(0)\\n        return solutions\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161174,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(int col, int n, vector<vector<string>> &ans, vector<string> &board, vector<int> &leftRow, vector<int> &lowDiagonal, vector<int> &upDiagonal) {\\n    if(col == n) {\\n        ans.push_back(board);\\n        return;\\n    }\\n    for(int row=0; row<n; row++){\\n        if(leftRow[row]==0 && lowDiagonal[row+col]==0 && upDiagonal[n-1-row+col]==0){\\n            board[row][col] = \\'Q\\';\\n            leftRow[row] = 1;\\n            lowDiagonal[row+col] = 1; \\n            upDiagonal[n-1-row+col] = 1;\\n            solve(col+1, n, ans, board, leftRow, lowDiagonal, upDiagonal);\\n            board[row][col] = \\'.\\';\\n            leftRow[row] = 0;\\n            lowDiagonal[row+col] = 0; \\n            upDiagonal[n-1-row+col] = 0;\\n        }\\n    }\\n}\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n    vector<string> board(n);\\n    string s = \"\";\\n    for(int i=0; i<n; i++){\\n        s.push_back(\\'.\\');\\n    }\\n    for(int i=0; i<n; i++){\\n        board[i] = s;\\n    }\\n    vector<int> leftRow(n, 0);\\n    vector<int> lowDiagonal(2*n - 1, 0);\\n    vector<int> upDiagonal(2*n - 1, 0);\\n\\n    solve(0, n, ans, board, leftRow, lowDiagonal, upDiagonal);\\n    return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def backtrack(row):\\n            if row == n:\\n                solutions.append([\"\".join(row) for row in board])\\n                return\\n            for col in range(n):\\n                if not cols[col] and not diag[row+col] and not anti_diag[row-col]:\\n                    board[row][col] = \\'Q\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = True, True, True\\n                    backtrack(row+1)\\n                    board[row][col] = \\'.\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = False, False, False\\n        \\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        cols, diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\\n        solutions = []\\n        backtrack(0)\\n        return solutions\\n```\\n\\n```Java []\\nclass Solution {\\n    public char[][] board;\\n    public List<List<String>> answer;\\n\\n    public boolean[] rowHasQ;\\n    public boolean[] colHasQ;\\n    public boolean[] d1HasQ;\\n    public boolean[] d2HasQ;\\n\\n    public void solve(int row, int col, int queensLeft) {\\n        if (queensLeft == 0) {\\n            List<String> validBoard = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                validBoard.add(new String(board[i]));\\n            }\\n            answer.add(validBoard);\\n            return;\\n        }\\n\\n        if (row >= board.length)\\n            return;\\n\\n        int d1 = col - row + (board.length - 1);\\n        int d2 = row + col;\\n\\n        if (\\n            !rowHasQ[row] && !colHasQ[col] && !d1HasQ[d1] && !d2HasQ[d2]\\n        ) {\\n            board[row][col] = \\'Q\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = true;\\n\\n            solve(row + 1, 0, queensLeft - 1);\\n\\n            board[row][col] = \\'.\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = false;\\n        }\\n\\n        if (\\n\\n            col < board.length - 1\\n        ) {\\n           \\n            solve(row, col + 1, queensLeft);\\n        }\\n    }\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        answer = new ArrayList<>();\\n\\n        board = new char[n][n];\\n        for (int i = 0; i < board.length; i++)\\n            Arrays.fill(board[i], \\'.\\');\\n\\n        rowHasQ = new boolean[n];\\n        colHasQ = new boolean[n];\\n        d1HasQ = new boolean[n * 2 - 1];\\n        d2HasQ = new boolean[n * 2 - 1];\\n\\n        solve(0, 0, n);\\n\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(int col, int n, vector<vector<string>> &ans, vector<string> &board, vector<int> &leftRow, vector<int> &lowDiagonal, vector<int> &upDiagonal) {\\n    if(col == n) {\\n        ans.push_back(board);\\n        return;\\n    }\\n    for(int row=0; row<n; row++){\\n        if(leftRow[row]==0 && lowDiagonal[row+col]==0 && upDiagonal[n-1-row+col]==0){\\n            board[row][col] = \\'Q\\';\\n            leftRow[row] = 1;\\n            lowDiagonal[row+col] = 1; \\n            upDiagonal[n-1-row+col] = 1;\\n            solve(col+1, n, ans, board, leftRow, lowDiagonal, upDiagonal);\\n            board[row][col] = \\'.\\';\\n            leftRow[row] = 0;\\n            lowDiagonal[row+col] = 0; \\n            upDiagonal[n-1-row+col] = 0;\\n        }\\n    }\\n}\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n    vector<string> board(n);\\n    string s = \"\";\\n    for(int i=0; i<n; i++){\\n        s.push_back(\\'.\\');\\n    }\\n    for(int i=0; i<n; i++){\\n        board[i] = s;\\n    }\\n    vector<int> leftRow(n, 0);\\n    vector<int> lowDiagonal(2*n - 1, 0);\\n    vector<int> upDiagonal(2*n - 1, 0);\\n\\n    solve(0, n, ans, board, leftRow, lowDiagonal, upDiagonal);\\n    return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def backtrack(row):\\n            if row == n:\\n                solutions.append([\"\".join(row) for row in board])\\n                return\\n            for col in range(n):\\n                if not cols[col] and not diag[row+col] and not anti_diag[row-col]:\\n                    board[row][col] = \\'Q\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = True, True, True\\n                    backtrack(row+1)\\n                    board[row][col] = \\'.\\'\\n                    cols[col], diag[row+col], anti_diag[row-col] = False, False, False\\n        \\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        cols, diag, anti_diag = [False]*n, [False]*(2*n-1), [False]*(2*n-1)\\n        solutions = []\\n        backtrack(0)\\n        return solutions\\n```\n```Java []\\nclass Solution {\\n    public char[][] board;\\n    public List<List<String>> answer;\\n\\n    public boolean[] rowHasQ;\\n    public boolean[] colHasQ;\\n    public boolean[] d1HasQ;\\n    public boolean[] d2HasQ;\\n\\n    public void solve(int row, int col, int queensLeft) {\\n        if (queensLeft == 0) {\\n            List<String> validBoard = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                validBoard.add(new String(board[i]));\\n            }\\n            answer.add(validBoard);\\n            return;\\n        }\\n\\n        if (row >= board.length)\\n            return;\\n\\n        int d1 = col - row + (board.length - 1);\\n        int d2 = row + col;\\n\\n        if (\\n            !rowHasQ[row] && !colHasQ[col] && !d1HasQ[d1] && !d2HasQ[d2]\\n        ) {\\n            board[row][col] = \\'Q\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = true;\\n\\n            solve(row + 1, 0, queensLeft - 1);\\n\\n            board[row][col] = \\'.\\';\\n            rowHasQ[row] = colHasQ[col] = d1HasQ[d1] = d2HasQ[d2] = false;\\n        }\\n\\n        if (\\n\\n            col < board.length - 1\\n        ) {\\n           \\n            solve(row, col + 1, queensLeft);\\n        }\\n    }\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        answer = new ArrayList<>();\\n\\n        board = new char[n][n];\\n        for (int i = 0; i < board.length; i++)\\n            Arrays.fill(board[i], \\'.\\');\\n\\n        rowHasQ = new boolean[n];\\n        colHasQ = new boolean[n];\\n        d1HasQ = new boolean[n * 2 - 1];\\n        d2HasQ = new boolean[n * 2 - 1];\\n\\n        solve(0, 0, n);\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142086,
                "title": "java-3ms-backtracking-easy",
                "content": "# Intuition: \\nUsing the concept of Backtracking, we will place Queen at different positions of the chessboard and find the right arrangement where all the n queens can be placed on the n*n grid.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n      List<List<String>> res=new ArrayList<>();\\n        char[][] board=new char[n][n];\\n        for (int i = 0; i <n ; i++) {\\n            for (int j = 0; j <n ; j++) {\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        place(0,board,res);  \\n        return res;\\n    }\\n    void place(int col, char[][] board, List<List<String>> res) {\\n        if (col==board.length){\\n            res.add(construct(board));\\n            return;\\n        }\\n        for (int row = 0; row < board.length; row++) {\\n            if (validateDup(board,row,col)){\\n                board[row][col]=\\'Q\\';\\n                place(col+1,board,res);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    static boolean validateDup(char[][] board, int row, int col) {\\n        int dupRow=row;\\n        int dupCol=col;\\n        while (row>=0&&col>=0){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n        row=dupRow;\\n        col=dupCol;\\n        while (col>=0){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n        }\\n        row=dupRow;\\n        col=dupCol;\\n        while (col>=0 && row< board.length){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n            row++;\\n        }\\n        return true;\\n    }\\n\\n    private static List<String> construct(char[][] board) {\\n        List < String > res = new ArrayList < String > ();\\n        for (int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n      List<List<String>> res=new ArrayList<>();\\n        char[][] board=new char[n][n];\\n        for (int i = 0; i <n ; i++) {\\n            for (int j = 0; j <n ; j++) {\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        place(0,board,res);  \\n        return res;\\n    }\\n    void place(int col, char[][] board, List<List<String>> res) {\\n        if (col==board.length){\\n            res.add(construct(board));\\n            return;\\n        }\\n        for (int row = 0; row < board.length; row++) {\\n            if (validateDup(board,row,col)){\\n                board[row][col]=\\'Q\\';\\n                place(col+1,board,res);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n\\n    static boolean validateDup(char[][] board, int row, int col) {\\n        int dupRow=row;\\n        int dupCol=col;\\n        while (row>=0&&col>=0){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            row--;\\n            col--;\\n        }\\n        row=dupRow;\\n        col=dupCol;\\n        while (col>=0){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n        }\\n        row=dupRow;\\n        col=dupCol;\\n        while (col>=0 && row< board.length){\\n            if (board[row][col]==\\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n            row++;\\n        }\\n        return true;\\n    }\\n\\n    private static List<String> construct(char[][] board) {\\n        List < String > res = new ArrayList < String > ();\\n        for (int i = 0; i < board.length; i++) {\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791965,
                "title": "java-easy-to-understand-modular-code-recursion-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] visited = new boolean[n][n]; //visited array\\n        List<List<String>> res = new ArrayList<>(); //resultant list\\n        List<String> way = new ArrayList<>();//one of the way\\n        solveNQueendHelper(0, n, visited, way, res);\\n        return res;\\n    }\\n    \\n    public void solveNQueendHelper(int row, int n, boolean[][] visited, List<String> way, List<List<String>> res){\\n        if(row == n){ //base case\\n            res.add(new ArrayList(way));\\n            return;\\n        }\\n        \\n        //coloumn as options\\n        for(int col = 0; col < n; ++col){\\n            if(isQueenSafe(row, col, visited) == true){\\n                visited[row][col] = true;\\n                sitQueen(col, n, way); //sit\\n                solveNQueendHelper(row + 1, n, visited, way, res);\\n                way.remove(way.size() - 1); //unsit\\n                visited[row][col] = false; //backtracking\\n            }\\n        }\\n    }\\n    \\n\\t//code to sit queen at provided col\\n    public void sitQueen(int col, int n, List<String> way){\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < n; ++j){\\n            if(j == col){\\n                sb.append(\"Q\");\\n            }else{\\n                sb.append(\".\");\\n            }\\n        }\\n        \\n        way.add(sb.toString());\\n    }\\n    \\n    public boolean isQueenSafe(int row, int col, boolean[][] visited){\\n        //vertically\\n        for(int r = row; r >= 0; --r){\\n            if(visited[r][col] == true){\\n                return false;\\n            }\\n        }\\n        \\n        //upward left diagonally\\n        int r = row, c = col;\\n        while(r >= 0 && c >= 0){\\n            if(visited[r][c] == true){\\n                return false;\\n            }\\n            --r;\\n            --c;\\n        }\\n        \\n        //upward left right diagonally\\n        r = row; c = col;\\n        while(r >= 0 && c < visited.length){\\n            if(visited[r][c] == true){\\n                return false;\\n            }\\n            --r;\\n            ++c;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] visited = new boolean[n][n]; //visited array\\n        List<List<String>> res = new ArrayList<>(); //resultant list\\n        List<String> way = new ArrayList<>();//one of the way\\n        solveNQueendHelper(0, n, visited, way, res);\\n        return res;\\n    }\\n    \\n    public void solveNQueendHelper(int row, int n, boolean[][] visited, List<String> way, List<List<String>> res){\\n        if(row == n){ //base case\\n            res.add(new ArrayList(way));\\n            return;\\n        }\\n        \\n        //coloumn as options\\n        for(int col = 0; col < n; ++col){\\n            if(isQueenSafe(row, col, visited) == true){\\n                visited[row][col] = true;\\n                sitQueen(col, n, way); //sit\\n                solveNQueendHelper(row + 1, n, visited, way, res);\\n                way.remove(way.size() - 1); //unsit\\n                visited[row][col] = false; //backtracking\\n            }\\n        }\\n    }\\n    \\n\\t//code to sit queen at provided col\\n    public void sitQueen(int col, int n, List<String> way){\\n        StringBuilder sb = new StringBuilder();\\n        for(int j = 0; j < n; ++j){\\n            if(j == col){\\n                sb.append(\"Q\");\\n            }else{\\n                sb.append(\".\");\\n            }\\n        }\\n        \\n        way.add(sb.toString());\\n    }\\n    \\n    public boolean isQueenSafe(int row, int col, boolean[][] visited){\\n        //vertically\\n        for(int r = row; r >= 0; --r){\\n            if(visited[r][col] == true){\\n                return false;\\n            }\\n        }\\n        \\n        //upward left diagonally\\n        int r = row, c = col;\\n        while(r >= 0 && c >= 0){\\n            if(visited[r][c] == true){\\n                return false;\\n            }\\n            --r;\\n            --c;\\n        }\\n        \\n        //upward left right diagonally\\n        r = row; c = col;\\n        while(r >= 0 && c < visited.length){\\n            if(visited[r][c] == true){\\n                return false;\\n            }\\n            --r;\\n            ++c;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701539,
                "title": "2-simple-approaches-and-codes-inspired-by-fraz-s-algorithm",
                "content": "Please read the entire post to get complete information.\\n\\nTime and space complexity for both approaches would be O(N! * N) and O(N) respectively.\\nAs the output has been demded in a 2D array format the space complexity would be O(N * N)\\n\\nApproach 1:\\n```\\n//Less optimized using isSafe function which contains multiple while loops\\n\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> answer = new ArrayList<>();\\n        int i = 0;\\n        char[][] chessBoard = new char[n][n];\\n        \\n        for(int a=0; a<n; a++){\\n            for(int b=0; b<n; b++){\\n                chessBoard[a][b] = \\'.\\';\\n            }\\n        }\\n        \\n        dfs(i, n, chessBoard, answer);\\n        return answer;\\n    }\\n    \\n    public static void dfs\\n        (int i, int n, char[][] chessBoard, List<List<String>> answer)\\n    {\\n\\t    //base case\\n        if(i == n){\\n\\t\\t    //to convert and add/insert the 2D array to type list \\n            answer.add(construct(chessBoard));\\n            return;\\n        }\\n        else{\\n            for(int j=0; j<n; j++){\\n\\t\\t\\t\\n\\t\\t\\t    //to check whether the queen will attacked at this specific co-ordinate\\n                if(isSafe(i, j, chessBoard)){\\n                    \\n\\t\\t\\t\\t\\t//establishing the queen in this i, j co-ordinates\\n                    chessBoard[i][j] = \\'Q\\';\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//recursive call\\n                    dfs(i+1, n, chessBoard, answer);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//backtrack procedure\\n                    chessBoard[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static List<String> construct(char[][] chessBoard){\\n        List<String> oneCombinationOfChessBoard = new ArrayList<>();\\n        \\n        for(int i=0; i<chessBoard.length; i++){\\n            String s = new String(chessBoard[i]);\\n            oneCombinationOfChessBoard.add(s);\\n        }\\n        return oneCombinationOfChessBoard;\\n    }\\n    \\n    public static boolean isSafe(int i, int j, char[][] chessBoard){\\n        \\n        int n = chessBoard.length;\\n        int tempI = i;\\n        int tempJ = j;\\n        \\n        while(tempI >= 0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n        }\\n        \\n        tempI = i;\\n        tempJ = j;\\n        \\n        while(tempI >=0 && tempJ <n && tempJ >=0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n            tempJ--;\\n        }\\n        \\n        tempI = i;\\n        tempJ = j;\\n        \\n        while(tempI >=0 && tempJ <n && tempJ >=0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n            tempJ++;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```\\n\\nApproach 2:\\n```\\n//Optimized using 3 additional arrays (using math) and eliminating those mutiple while loops/ isSafe function\\n\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> answer = new ArrayList<>();\\n        int i = 0;\\n        char[][] chessBoard = new char[n][n];\\n\\t\\t\\n\\t\\t//3 additional arrays for optimization and to eliminate isSafe function\\n        boolean[] UP = new boolean[n];\\n        boolean[] UL = new boolean[2*n-1];\\n        boolean[] UR = new boolean[2*n-1];\\n        \\n        for(int a=0; a<n; a++){\\n            for(int b=0; b<n; b++){\\n                chessBoard[a][b] = \\'.\\';\\n            }\\n        }\\n        \\n        dfs(i, n, chessBoard, answer, UP, UL, UR);\\n        return answer;\\n    }\\n    \\n    public static void dfs\\n        (int i, int n, char[][] chessBoard, List<List<String>> answer,boolean[] UP, boolean[]           UL, boolean[]UR)\\n    {\\n        if(i == n){\\n            answer.add(construct(chessBoard));\\n            return;\\n        }\\n        else{\\n            for(int j=0; j<n; j++){\\n                if(UP[j] == false && UR[i+j] == false && UL[i-j+n-1] == false){\\n                    \\n\\t\\t\\t\\t\\t//establishing the queen in this i, j co-ordinates\\n                    UP[j] = true;\\n                    UR[i+j] = true;\\n                    UL[i-j+n-1] = true;\\n                    chessBoard[i][j] = \\'Q\\';\\n                    \\n\\t\\t\\t\\t\\t//recursive call\\n                    dfs(i+1, n, chessBoard, answer, UP, UL, UR);\\n                    \\n\\t\\t\\t\\t\\t//backtrack procedure\\n                    chessBoard[i][j] = \\'.\\';\\n                    UP[j] = false;\\n                    UR[i+j] = false;\\n                    UL[i-j+n-1] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static List<String> construct(char[][] chessBoard){\\n        List<String> oneCombinationOfChessBoard = new ArrayList<>();\\n        \\n        for(int i=0; i<chessBoard.length; i++){\\n            String s = new String(chessBoard[i]);\\n            oneCombinationOfChessBoard.add(s);\\n        }\\n        return oneCombinationOfChessBoard;\\n    }\\n    \\n}\\n```\\nTo view diagramatic reference, click this link- https://takeuforward.org/data-structure/n-queen-problem-return-all-distinct-solutions-to-the-n-queens-puzzle/\\n(credits: Raj Vikram Aditya a.k.a Striver)\\n\\nFor video reference in CPP language:https://www.youtube.com/watch?v=VrySrTVAI3Y&t=602s\\n(cedits: Fraz leadCoding)\\n\\nIf this was shelpful, please upvote.\\n\\nTo view my series of LeetCode solutions, click this link- https://github.com/Afzhal-ahmed-s/Leetcode-solutions",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n//Less optimized using isSafe function which contains multiple while loops\\n\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> answer = new ArrayList<>();\\n        int i = 0;\\n        char[][] chessBoard = new char[n][n];\\n        \\n        for(int a=0; a<n; a++){\\n            for(int b=0; b<n; b++){\\n                chessBoard[a][b] = \\'.\\';\\n            }\\n        }\\n        \\n        dfs(i, n, chessBoard, answer);\\n        return answer;\\n    }\\n    \\n    public static void dfs\\n        (int i, int n, char[][] chessBoard, List<List<String>> answer)\\n    {\\n\\t    //base case\\n        if(i == n){\\n\\t\\t    //to convert and add/insert the 2D array to type list \\n            answer.add(construct(chessBoard));\\n            return;\\n        }\\n        else{\\n            for(int j=0; j<n; j++){\\n\\t\\t\\t\\n\\t\\t\\t    //to check whether the queen will attacked at this specific co-ordinate\\n                if(isSafe(i, j, chessBoard)){\\n                    \\n\\t\\t\\t\\t\\t//establishing the queen in this i, j co-ordinates\\n                    chessBoard[i][j] = \\'Q\\';\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//recursive call\\n                    dfs(i+1, n, chessBoard, answer);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//backtrack procedure\\n                    chessBoard[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static List<String> construct(char[][] chessBoard){\\n        List<String> oneCombinationOfChessBoard = new ArrayList<>();\\n        \\n        for(int i=0; i<chessBoard.length; i++){\\n            String s = new String(chessBoard[i]);\\n            oneCombinationOfChessBoard.add(s);\\n        }\\n        return oneCombinationOfChessBoard;\\n    }\\n    \\n    public static boolean isSafe(int i, int j, char[][] chessBoard){\\n        \\n        int n = chessBoard.length;\\n        int tempI = i;\\n        int tempJ = j;\\n        \\n        while(tempI >= 0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n        }\\n        \\n        tempI = i;\\n        tempJ = j;\\n        \\n        while(tempI >=0 && tempJ <n && tempJ >=0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n            tempJ--;\\n        }\\n        \\n        tempI = i;\\n        tempJ = j;\\n        \\n        while(tempI >=0 && tempJ <n && tempJ >=0){\\n            if(chessBoard[tempI][tempJ] == \\'Q\\')return false;\\n            tempI--;\\n            tempJ++;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```\n```\\n//Optimized using 3 additional arrays (using math) and eliminating those mutiple while loops/ isSafe function\\n\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> answer = new ArrayList<>();\\n        int i = 0;\\n        char[][] chessBoard = new char[n][n];\\n\\t\\t\\n\\t\\t//3 additional arrays for optimization and to eliminate isSafe function\\n        boolean[] UP = new boolean[n];\\n        boolean[] UL = new boolean[2*n-1];\\n        boolean[] UR = new boolean[2*n-1];\\n        \\n        for(int a=0; a<n; a++){\\n            for(int b=0; b<n; b++){\\n                chessBoard[a][b] = \\'.\\';\\n            }\\n        }\\n        \\n        dfs(i, n, chessBoard, answer, UP, UL, UR);\\n        return answer;\\n    }\\n    \\n    public static void dfs\\n        (int i, int n, char[][] chessBoard, List<List<String>> answer,boolean[] UP, boolean[]           UL, boolean[]UR)\\n    {\\n        if(i == n){\\n            answer.add(construct(chessBoard));\\n            return;\\n        }\\n        else{\\n            for(int j=0; j<n; j++){\\n                if(UP[j] == false && UR[i+j] == false && UL[i-j+n-1] == false){\\n                    \\n\\t\\t\\t\\t\\t//establishing the queen in this i, j co-ordinates\\n                    UP[j] = true;\\n                    UR[i+j] = true;\\n                    UL[i-j+n-1] = true;\\n                    chessBoard[i][j] = \\'Q\\';\\n                    \\n\\t\\t\\t\\t\\t//recursive call\\n                    dfs(i+1, n, chessBoard, answer, UP, UL, UR);\\n                    \\n\\t\\t\\t\\t\\t//backtrack procedure\\n                    chessBoard[i][j] = \\'.\\';\\n                    UP[j] = false;\\n                    UR[i+j] = false;\\n                    UL[i-j+n-1] = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static List<String> construct(char[][] chessBoard){\\n        List<String> oneCombinationOfChessBoard = new ArrayList<>();\\n        \\n        for(int i=0; i<chessBoard.length; i++){\\n            String s = new String(chessBoard[i]);\\n            oneCombinationOfChessBoard.add(s);\\n        }\\n        return oneCombinationOfChessBoard;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690378,
                "title": "java-solution-backtracking-bitmanipulation",
                "content": "```\\nclass Solution {\\n    private List<List<String>> res;\\n    private int N;\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        res = new ArrayList<>();\\n        N = n;\\n        char[][] emptyBoard = new char[N][N];\\n        for (char[] row: emptyBoard) Arrays.fill(row, \\'.\\');\\n        \\n        backtrack(emptyBoard, 0, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(char[][] board, int row, int cols, int diags, int antiDiags) {\\n        // if we\\'ve successfuly placed a Queen at all rows, we have a valid board state\\n        if (row == N) {\\n            res.add(toBoard(board));\\n            return;\\n        }\\n        \\n        for (int col=0; col<N; col++) {\\n            int currDiag = row-col+N;\\n            int currAntiDiag = row+col;\\n            \\n            // check if the current Queen placement is valid\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << currDiag)) != 0 || (antiDiags & (1 << currAntiDiag)) != 0) continue;\\n            \\n            // if so, add changes\\n            board[row][col] = \\'Q\\';\\n            cols |= (1 << col);\\n            diags |= (1 << currDiag);\\n            antiDiags |= (1 << currAntiDiag);\\n            \\n            // continue to the next row\\n            backtrack(board, row + 1, cols, diags, antiDiags);\\n            \\n            // undo changes and continue\\n            board[row][col] = \\'.\\';\\n            cols ^= (1 << col);\\n            diags ^= (1 << currDiag);\\n            antiDiags ^= (1 << currAntiDiag);\\n        }\\n    }\\n    \\n    private List<String> toBoard(char[][] board) {\\n        List<String> newBoard = new ArrayList<>();\\n        for (char[] row: board) newBoard.add(new String(row));\\n        return newBoard;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private List<List<String>> res;\\n    private int N;\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        res = new ArrayList<>();\\n        N = n;\\n        char[][] emptyBoard = new char[N][N];\\n        for (char[] row: emptyBoard) Arrays.fill(row, \\'.\\');\\n        \\n        backtrack(emptyBoard, 0, 0, 0, 0);\\n        return res;\\n    }\\n    \\n    private void backtrack(char[][] board, int row, int cols, int diags, int antiDiags) {\\n        // if we\\'ve successfuly placed a Queen at all rows, we have a valid board state\\n        if (row == N) {\\n            res.add(toBoard(board));\\n            return;\\n        }\\n        \\n        for (int col=0; col<N; col++) {\\n            int currDiag = row-col+N;\\n            int currAntiDiag = row+col;\\n            \\n            // check if the current Queen placement is valid\\n            if ((cols & (1 << col)) != 0 || (diags & (1 << currDiag)) != 0 || (antiDiags & (1 << currAntiDiag)) != 0) continue;\\n            \\n            // if so, add changes\\n            board[row][col] = \\'Q\\';\\n            cols |= (1 << col);\\n            diags |= (1 << currDiag);\\n            antiDiags |= (1 << currAntiDiag);\\n            \\n            // continue to the next row\\n            backtrack(board, row + 1, cols, diags, antiDiags);\\n            \\n            // undo changes and continue\\n            board[row][col] = \\'.\\';\\n            cols ^= (1 << col);\\n            diags ^= (1 << currDiag);\\n            antiDiags ^= (1 << currAntiDiag);\\n        }\\n    }\\n    \\n    private List<String> toBoard(char[][] board) {\\n        List<String> newBoard = new ArrayList<>();\\n        for (char[] row: board) newBoard.add(new String(row));\\n        return newBoard;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544417,
                "title": "java-solution-using-backtracking-explained",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        //create the chess board\\n        char[][] board = new char[n][n];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        // list to store the final answer\\n        List<List<String>> ans = new ArrayList<>();\\n        backtrack (0, board, ans);\\n        return ans;\\n    }\\n    \\n    public void backtrack (int col, char[][] board, List<List<String>> ans) {\\n        // base case\\n        if (col == board.length) {\\n            List<String> ds = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                String s = new String(board[i]);\\n                ds.add(s);\\n            }\\n            ans.add(ds);\\n            return;\\n        }\\n        // check if you can place a queen in that particular position or not\\n        for (int row = 0; row < board.length; row++) {\\n            if (isSafe(row, col, board)) {\\n                board[row][col] = \\'Q\\';\\n\\t\\t\\t\\t// if not then backtrack to its original state\\n                backtrack(col + 1, board, ans);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    public boolean isSafe(int row, int col, char[][] board) {\\n        // store in different variables bcz we\\'re gonna make changes in row and col\\n        // and we will further need the original values of row and col \\n        int r= row;\\n        int c = col;\\n        \\n        // Note- We are not checking anything on the right bcz we have to place a queen on the right col\\n        \\n        // check if Q can attack to its straight left \\n        while (col >= 0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            col--;\\n        }\\n        \\n        //  check if Q can attack to its upper left diagonal\\n        row = r;\\n        col = c;\\n        while (row >= 0 && col >=0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            row--;\\n            col--;\\n        }\\n        \\n        //  check if Q can attack to its lower left diagonal\\n        row = r;\\n        col = c;\\n        while (row < board.length && col >=0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            row++;\\n            col--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        //create the chess board\\n        char[][] board = new char[n][n];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                board[i][j] = \\'.\\';\\n        \\n        // list to store the final answer\\n        List<List<String>> ans = new ArrayList<>();\\n        backtrack (0, board, ans);\\n        return ans;\\n    }\\n    \\n    public void backtrack (int col, char[][] board, List<List<String>> ans) {\\n        // base case\\n        if (col == board.length) {\\n            List<String> ds = new ArrayList<>();\\n            for (int i = 0; i < board.length; i++) {\\n                String s = new String(board[i]);\\n                ds.add(s);\\n            }\\n            ans.add(ds);\\n            return;\\n        }\\n        // check if you can place a queen in that particular position or not\\n        for (int row = 0; row < board.length; row++) {\\n            if (isSafe(row, col, board)) {\\n                board[row][col] = \\'Q\\';\\n\\t\\t\\t\\t// if not then backtrack to its original state\\n                backtrack(col + 1, board, ans);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    public boolean isSafe(int row, int col, char[][] board) {\\n        // store in different variables bcz we\\'re gonna make changes in row and col\\n        // and we will further need the original values of row and col \\n        int r= row;\\n        int c = col;\\n        \\n        // Note- We are not checking anything on the right bcz we have to place a queen on the right col\\n        \\n        // check if Q can attack to its straight left \\n        while (col >= 0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            col--;\\n        }\\n        \\n        //  check if Q can attack to its upper left diagonal\\n        row = r;\\n        col = c;\\n        while (row >= 0 && col >=0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            row--;\\n            col--;\\n        }\\n        \\n        //  check if Q can attack to its lower left diagonal\\n        row = r;\\n        col = c;\\n        while (row < board.length && col >=0) {\\n            if (board[row][col] == \\'Q\\') \\n                return false;\\n            row++;\\n            col--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410027,
                "title": "easiest-solution-you-will-ever-see",
                "content": "Placing a queen at [r, c] imposes 4 bans on further placements.\\n\\n1. Can\\'t place another queen in row r.\\n2. Can\\'t place another queen in col c.\\n3. Can\\'t place another queen in [r\\',c\\'] where r\\'+c\\' == r+c (same diagonal, lets call it sum diagonal).\\n4. Can\\'t place another queen in [r\\',c\\'] where r\\'-c\\' == r-c (same diagonal, lets call it diff diagonal).\\n\\nTo take care of these 4 bans\\n\\n1. Let\\'s iterate from row 0 to row n-1\\n2. Keep a set of banned cols\\n3. Keep a set of banned sum diagonals\\n4. Keep a set of banned diff diagonals\\n\\nwe will place a Queen at [row,col] only when it is not banned. DFS is the heart of the solution.\\nWhen we reach nth row, it means we have sucessfully filled the rows 0,1,...,n-1 of the board. Hence we have a valid board which we will store in a global list.\\n\\n\\nplease also see  [my discussion on N-Queens-II](https://leetcode.com/problems/n-queens-ii/discuss/2404853/easiest-solution-you-will-ever-see), which is related.\\n\\n\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        valid_boards = []\\n        \\n        def check(row, banned_cols, banned_diag_sum, banned_diag_diff, board):\\n            if row==n:\\n                # means we have placed n queens (as we are using 0 based index), lets store the solution in the global list valid_boards.\\n                valid_boards.append(board)\\n                return\\n                \\n            \\n            for col in range(n):\\n                # can we place a queen given our banned columns and diagonals due to previous placements?\\n                can_place_at_row_col = (col not in banned_cols) and \\\\\\n                                       (row+col not in banned_diag_sum) and \\\\\\n                                       (row-col not in banned_diag_diff)\\n                # if yes, we place a queen at (row, col) and move to next row, update the banned column set and banned diagonal sets and add a rown in the board and check all the possibilities.\\n                if can_place_at_row_col:\\n                    check(row+1, \\n                        banned_cols.union({col}), \\n                        banned_diag_sum.union({row+col}), \\n                        banned_diag_diff.union({row-col}),\\n                        board+[\\'.\\'*col+\\'Q\\'+\\'.\\'*(n-col-1)])\\n            return\\n                    \\n        # initially nothing is banned\\n        check(0, banned_cols=set(), banned_diag_sum=set(), banned_diag_diff=set(), board=[])\\n        \\n        # return all the valid boards that we sotored\\n        return valid_boards\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        valid_boards = []\\n        \\n        def check(row, banned_cols, banned_diag_sum, banned_diag_diff, board):\\n            if row==n:\\n                # means we have placed n queens (as we are using 0 based index), lets store the solution in the global list valid_boards.\\n                valid_boards.append(board)\\n                return\\n                \\n            \\n            for col in range(n):\\n                # can we place a queen given our banned columns and diagonals due to previous placements?\\n                can_place_at_row_col = (col not in banned_cols) and \\\\\\n                                       (row+col not in banned_diag_sum) and \\\\\\n                                       (row-col not in banned_diag_diff)\\n                # if yes, we place a queen at (row, col) and move to next row, update the banned column set and banned diagonal sets and add a rown in the board and check all the possibilities.\\n                if can_place_at_row_col:\\n                    check(row+1, \\n                        banned_cols.union({col}",
                "codeTag": "Java"
            },
            {
                "id": 2108335,
                "title": "easy-c-sol-naive-efficient-approaches-backtracking-recursion",
                "content": "```\\n// Naive Solution as isSafe function takes O(3n) time, Resultant Time : O (N!*3N) :: Aux_Space : O(N^2)\\n  \\n  class Solution {\\npublic:\\n    \\n    bool isSafe(int row,int col, vector<string> board, int n){\\n        \\n        int duprow = row;\\n        int dupcol = col;\\n        \\n        // let\\'s check if there\\'s any queen or not on the upper diagonal \\n        \\n        while(row>=0 && col >= 0){\\n            \\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n            row--;\\n        }\\n        \\n        row = duprow;\\n        col = dupcol;\\n        \\n        // let\\'s check if there\\'s any queen or not on the right side\\n        \\n        while(col>=0){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            col--;\\n        }\\n        \\n        row = duprow;\\n        col = dupcol;\\n        \\n        // let\\'s check if there\\'s any queen or not on the lower diagonal \\n        \\n        while(row<n && col>=0){\\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n    \\n    // this function checks where we can put the queen without any fight\\n    \\n    void solve(int col,vector<string> &board, vector<vector<string>> &ans, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row = 0;row<n;row++){\\n            \\n            if(isSafe(row,col,board,n)){\\n                board[row][col] = \\'Q\\';\\n                solve(col+1,board,ans,n);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n        vector<vector<string>> res;\\n        vector<string> board(n);\\n        string s(n,\\'.\\');\\n        \\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        \\n        solve(0,board,res,n);\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution Using Hashing  // Time : O(N! * N) :: Aux_Space : O(N)\\n\\nclass Solution {\\npublic:\\n    \\n    void solve(int col, vector<string> &board, vector<vector<string>> &ans, vector<int> &leftRow, vector<int> &upperDiagonal, vector<int> &lowerDiagonal, int n){\\n        \\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        for(int row = 0; row<n; row++){\\n            \\n            if(leftRow[row] == 0 && lowerDiagonal[row+col] == 0 && upperDiagonal[n-1+col-row] == 0){\\n                \\n                board[row][col] = \\'Q\\';\\n                leftRow[row] = 1;\\n                lowerDiagonal[row+col] = 1;\\n                upperDiagonal[n-1 + col - row] = 1;\\n                solve(col+1,board,ans,leftRow,upperDiagonal,lowerDiagonal,n);\\n                \\n                board[row][col] = \\'.\\';\\n                leftRow[row] = 0;\\n                lowerDiagonal[row+col] = 0;\\n                upperDiagonal[n-1+col-row] = 0;\\n                \\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n        vector<vector<string>> res;\\n        vector<string> board(n);\\n        \\n        string s(n,\\'.\\');\\n        \\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        \\n        vector<int> leftRow(n,0),upperDiagonal(2*n-1,0),lowerDiagonal(2*n-1,0);\\n        solve(0,board,res,leftRow,upperDiagonal,lowerDiagonal,n);\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isSafe(int row,int col, vector<string> board, int n){\\n        \\n        int duprow = row;\\n        int dupcol = col;\\n        \\n        // let\\'s check if there\\'s any queen or not on the upper diagonal \\n        \\n        while(row>=0 && col >= 0){\\n            \\n            if(board[row][col] == \\'Q\\'){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2108009,
                "title": "cpp-easy-clean",
                "content": "```\\nclass Solution \\n{\\n    int n;\\n    string getNq(int p)\\n    {\\n        string s(n, \\'.\\');\\n        s[p] = \\'Q\\';\\n        return s;\\n    }\\n    void nQueens(int p, int l, int m, int r, vector<vector<string>> &res)\\n    {\\n        static vector<string> ans;\\n        if (p >= n)\\n        {\\n            res.push_back(ans);\\n            return ;\\n        }\\n        int mask = l | m | r;\\n        for (int i = 0, b = 1; i < n; ++ i, b <<= 1)\\n            if (!(mask & b))\\n            {\\n                ans.push_back(getNq(i));\\n                nQueens(p + 1, (l | b) >> 1, m | b, (r | b) << 1, res);\\n                ans.pop_back();\\n            }\\n    }\\npublic:\\n    vector<vector<string> > solveNQueens(int n) \\n    {\\n        this->n = n;\\n        vector<vector<string>> res;\\n        nQueens(0, 0, 0, 0, res);\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/34e3f680-7424-4ae0-8b04-7fdd5da20cd8_1654315155.4232652.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    int n;\\n    string getNq(int p)\\n    {\\n        string s(n, \\'.\\');\\n        s[p] = \\'Q\\';\\n        return s;\\n    }\\n    void nQueens(int p, int l, int m, int r, vector<vector<string>> &res)\\n    {\\n        static vector<string> ans;\\n        if (p >= n)\\n        {\\n            res.push_back(ans);\\n            return ;\\n        }\\n        int mask = l | m | r;\\n        for (int i = 0, b = 1; i < n; ++ i, b <<= 1)\\n            if (!(mask & b))\\n            {\\n                ans.push_back(getNq(i));\\n                nQueens(p + 1, (l | b) >> 1, m | b, (r | b) << 1, res);\\n                ans.pop_back();\\n            }\\n    }\\npublic:\\n    vector<vector<string> > solveNQueens(int n) \\n    {\\n        this->n = n;\\n        vector<vector<string>> res;\\n        nQueens(0, 0, 0, 0, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107969,
                "title": "backtracking-explained",
                "content": "We first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/8dc5e314-0a9f-4bb6-b7f3-5a2f386e5af6_1654314085.8460877.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107966,
                "title": "python-explained",
                "content": "We first create a **( n X n )** chess board and assign **0** to every index.\\nWhenever a queen will be placed, index will be made **1**.\\n\\nIn this approach , we fill queens **column-wise** starting from left side.\\n\\nWhenever a queen is placed, at first it is checked if it satisfies the conditions given that it is not under attack.\\n\\n**validMove** function.\\nFirst it check there are no other queen in row the queen is filled.\\nAs we are putting queen column wise so no need to check for column.\\nThen there are two diagonals to check for.\\n* Only left part of the diagonals are checked as positions to the right of the present column are still unfilled.\\n\\nIf conditions satisfied, Queen is placed and we move to next column.\\nIf no queen satisfy the problem, we backtrack and try to change the position of previous queen.\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/cde42ba8-3562-4478-a2c5-3c6433a1f0b8_1654314052.04698.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        \\n        def validMove(board,row,col):\\n            \\n            # check for queens in same row\\n            i=col\\n            while i>=0:\\n                if board[row][i]:\\n                    return False\\n                i-=1\\n            \\n            #check for diagonal that goes toward top-left\\n            i=row\\n            j=col\\n            while (i>=0 and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i-=1\\n                j-=1\\n            \\n            # check for diagonal that goes towards bottom-left\\n            i=row\\n            j=col\\n            while (i<n and j>=0):\\n                if board[i][j]:\\n                    return False\\n                i+=1\\n                j-=1\\n            return True\\n        \\n\\n        def solve(board,col):\\n\\n        \\t# if solution found i.e. all places filled\\n            if (col==n):\\n                res.append([])\\n                for i in range(n):\\n                    res[-1].append(\"\")\\n                    for j in range(n):\\n                        if board[i][j]:\\n                            res[-1][-1]+=\"Q\"\\n                        else:\\n                            res[-1][-1]+=\".\"\\n                return\\n            \\n            # try for all row values of that column\\n            for i in range(n):\\n                if validMove(board,i,col):\\n                    board[i][col]=1\\n                    solve(board,col+1)\\n                    board[i][col]=0\\n            return\\n        \\n        res=[]       # to store answers\\n        board=[]     # create the chess board\\n        for i in range(n):\\n            board.append([])\\n            for j in range(n):\\n                board[-1].append(0)\\n        solve(board,0)\\n        board.clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089007,
                "title": "100-faster-1ms-accepted-java-recursion-solution-easy-to-understand-with-explanation",
                "content": "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        \\n        \\n        List<List<String>> ans=new ArrayList<List<String>>();\\n        char [][]board=new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                board[i][j]=\\'.\\';\\n        \\n\\t\\t\\n\\t\\t\\n        int rowset[] = new int[n];\\n        int lowdiag[] = new int[2*n-1];\\n        int updiag[] = new int[2*n-1];\\n        Arrays.fill(rowset,0);\\n        Arrays.fill(lowdiag,0);\\n        Arrays.fill(updiag,0);\\n    \\n        solution(n,board,0,ans,rowset,lowdiag,updiag);\\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n     void solution(int n,char[][] board,int col,List<List<String>> ans,int rowset[],int lowdiag[],int updiag[])\\n     {\\n         \\n         \\n         if(col==n)\\n         {\\n             ans.add(construct(board));\\n             return;\\n         }\\n         \\n         for(int row=0;row<n;row++)\\n         {\\n             if(rowset[row] == 0 && lowdiag[row+col] == 0 && updiag[n-1+col-row] == 0){\\n                 \\n                 board[row][col] = \\'Q\\';\\n                 rowset[row] = 1;\\n                 lowdiag[row+col] = 1;\\n                 updiag[n-1+col-row] = 1;\\n                 solution(n,board,col+1,ans,rowset,lowdiag,updiag);\\n                 board[row][col] = \\'.\\';\\n                 rowset[row] = 0;\\n                 lowdiag[row+col] = 0;\\n                 updiag[n-1+col-row] = 0;\\n             }\\n             \\n             \\n             \\n         }\\n         \\n           \\n         \\n     }\\n    \\n    List<String> construct(char[][] board)\\n    {\\n        List<String> ans=new LinkedList<String>();\\n        for(int i=0;i<board.length;i++)\\n        {\\n            String s=new String(board[i]);\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n    \\n\\n}\\n\\n**rowset**\\n\\n![image](https://assets.leetcode.com/users/images/ed505adc-494f-4ec2-aa32-e65ed69be752_1653862635.010629.png)\\n\\nrowset is used to check if queens attack each other row-wise\\n\\nif there is not a Queen present we fill that respective cell with 1\\nwhen we encounter a queen in that row , we remove that queen fill that cell with 0 and check next row\\n\\n**lowdiag**\\n\\n![image](https://assets.leetcode.com/users/images/5a38258e-9db4-4d9f-a51e-d14bf3bbb09c_1653863712.884073.png)\\n\\n\\nlowdiag is used to check if queens attack each other lower-diagonal wise.\\nThe size of lowdiag will be 2n-1\\nand the cells can be accessed with the formula \"row + col\"\\n\\nsuppose n=8 so the no.of cells will be 2n-1 = 2 * 8 -1 = \\'15\\' \\n\\nif there is no queen present in the same lower diagonal , we fill that cell with 1\\nwhen we encounter a queen in that lower diagonal , we remove that queen fill that cell with 0 and check next row\\n\\n\\n**updiag**\\n\\n![image](https://assets.leetcode.com/users/images/ed898980-f2fa-4e1d-94b1-518235abe9fb_1653864076.2266638.png)\\n\\n\\nupdiag is used to check if queens attack each other upper-diagonal wise.\\nThe size of updiag will be 2n-1\\nand the cells can be accessed with the formula \"n-1+col-row\"\\n\\nsuppose n=8 so the no.of cells will be 2n-1 = 2 * 8 -1 = \\'15\\' \\n\\nif there is no queen present in the same upper diagonal , we fill that cell with 1\\nwhen we encounter a queen in that lower diagonal , we remove that queen fill that cell with 0 and check next row\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        \\n        \\n        List<List<String>> ans=new ArrayList<List<String>>();\\n        char [][]board=new char[n][n];\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n                board[i][j]=\\'.\\';\\n        \\n\\t\\t\\n\\t\\t\\n        int rowset[] = new int[n];\\n        int lowdiag[] = new int[2*n-1];\\n        int updiag[] = new int[2*n-1];\\n        Arrays.fill(rowset,0);\\n        Arrays.fill(lowdiag,0);\\n        Arrays.fill(updiag,0);\\n    \\n        solution(n,board,0,ans,rowset,lowdiag,updiag);\\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1699816,
                "title": "c-4ms-heavily-commented-clean-solution-fast-easy-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/bec20d68-2d88-4885-bac1-e2f701c3a9c3_1642510645.0060172.png)\\n```\\n// class Solution {\\n// public:\\n    \\n//     bool isSafe(int r,int c,vector<string> &board,int n){\\n//         int dr = r;\\n//         int dc = c;\\n//         //backward direction\\n//         while(c>=0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//         }\\n//         //upper diagonal\\n//         r=dr;\\n//         c=dc;\\n//         while(r>=0 and c>= 0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//             r--;\\n//         }\\n//         //downward diagonal\\n//         r=dr;\\n//         c=dc;\\n//         while(r<n and c>= 0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//             r++;\\n//         }\\n//         return true;\\n//     }\\n    \\n//     void solve(vector<vector<string>> &ans,vector<string> &board,int n,int col){\\n//         //base case\\n//         if(col == n){\\n//             ans.push_back(board);\\n//             return;\\n//         }\\n        \\n//         for(int row=0;row<n;row++){\\n//             if(isSafe(row,col,board,n)){\\n//                 board[row][col] = \\'Q\\';\\n//                 solve(ans,board,n,col+1);\\n//                 board[row][col] = \\'.\\';\\n//             }\\n//         }\\n//     }\\n    \\n//     vector<vector<string>> solveNQueens(int n) {\\n//         vector<vector<string>> ans;\\n//         vector<string> board(n);\\n//         string s(n,\\'.\\');\\n//         for(int i=0;i<n;i++){\\n//             board[i] = s;\\n//         }\\n//         solve(ans,board,n,0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\nclass Solution {\\npublic:\\n    //time complexity optimized\\n    \\n    void solve(int col,int n,vector<vector<string>> &ans,vector<string> &board,vector<bool> &back,vector<bool> &upperdiagonal,vector<bool> &lowerdiagonal){\\n        //base case\\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        //traversing through every row \\n        for(int row=0;row<n;row++){\\n            if(!back[row] and !upperdiagonal[n-1 + col - row] and !lowerdiagonal[col+row]){\\n                board[row][col] = \\'Q\\';\\n                back[row] = 1;\\n                upperdiagonal[n-1 + col - row] = 1;\\n                lowerdiagonal[row+col] = 1;\\n                solve(col+1,n,ans,board,back,upperdiagonal,lowerdiagonal);\\n                board[row][col] = \\'.\\';\\n                back[row] = 0;\\n                upperdiagonal[n-1 + col - row] = 0;\\n                lowerdiagonal[row+col] = 0;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n,\\'.\\');\\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        //using containers instead of is safe function\\n        //space optimized using bool vector instead of int\\n        // vector<int> back(n,0);\\n        // vector<int> upperdiagonal(2*n-1,0);\\n        // vector<int> lowerdiagonal(2*n-1,0);\\n        vector<bool> back(n,0);\\n        vector<bool> upperdiagonal(2*n-1,0);\\n        vector<bool> lowerdiagonal(2*n-1,0);\\n        solve(0,n,ans,board,back,upperdiagonal,lowerdiagonal);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n    \\n//     bool isSafe(int r,int c,vector<string> &board,int n){\\n//         int dr = r;\\n//         int dc = c;\\n//         //backward direction\\n//         while(c>=0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//         }\\n//         //upper diagonal\\n//         r=dr;\\n//         c=dc;\\n//         while(r>=0 and c>= 0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//             r--;\\n//         }\\n//         //downward diagonal\\n//         r=dr;\\n//         c=dc;\\n//         while(r<n and c>= 0){\\n//             if(board[r][c]==\\'Q\\') return false;\\n//             c--;\\n//             r++;\\n//         }\\n//         return true;\\n//     }\\n    \\n//     void solve(vector<vector<string>> &ans,vector<string> &board,int n,int col){\\n//         //base case\\n//         if(col == n){\\n//             ans.push_back(board);\\n//             return;\\n//         }\\n        \\n//         for(int row=0;row<n;row++){\\n//             if(isSafe(row,col,board,n)){\\n//                 board[row][col] = \\'Q\\';\\n//                 solve(ans,board,n,col+1);\\n//                 board[row][col] = \\'.\\';\\n//             }\\n//         }\\n//     }\\n    \\n//     vector<vector<string>> solveNQueens(int n) {\\n//         vector<vector<string>> ans;\\n//         vector<string> board(n);\\n//         string s(n,\\'.\\');\\n//         for(int i=0;i<n;i++){\\n//             board[i] = s;\\n//         }\\n//         solve(ans,board,n,0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\nclass Solution {\\npublic:\\n    //time complexity optimized\\n    \\n    void solve(int col,int n,vector<vector<string>> &ans,vector<string> &board,vector<bool> &back,vector<bool> &upperdiagonal,vector<bool> &lowerdiagonal){\\n        //base case\\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n        //traversing through every row \\n        for(int row=0;row<n;row++){\\n            if(!back[row] and !upperdiagonal[n-1 + col - row] and !lowerdiagonal[col+row]){\\n                board[row][col] = \\'Q\\';\\n                back[row] = 1;\\n                upperdiagonal[n-1 + col - row] = 1;\\n                lowerdiagonal[row+col] = 1;\\n                solve(col+1,n,ans,board,back,upperdiagonal,lowerdiagonal);\\n                board[row][col] = \\'.\\';\\n                back[row] = 0;\\n                upperdiagonal[n-1 + col - row] = 0;\\n                lowerdiagonal[row+col] = 0;\\n            }\\n        }\\n        \\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n,\\'.\\');\\n        for(int i=0;i<n;i++){\\n            board[i] = s;\\n        }\\n        //using containers instead of is safe function\\n        //space optimized using bool vector instead of int\\n        // vector<int> back(n,0);\\n        // vector<int> upperdiagonal(2*n-1,0);\\n        // vector<int> lowerdiagonal(2*n-1,0);\\n        vector<bool> back(n,0);\\n        vector<bool> upperdiagonal(2*n-1,0);\\n        vector<bool> lowerdiagonal(2*n-1,0);\\n        solve(0,n,ans,board,back,upperdiagonal,lowerdiagonal);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667183,
                "title": "java-backtracking-2ms-solution-most-basic-and-easily-understandable-code",
                "content": "This code is faster than 93.79% of Java Submissions.\\nThis is my first post and I am currently learning DSA so kindly upvote if you liked it.\\n\\n\\'\\'\\'\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        for(char[] row : board)\\n            Arrays.fill(row,\\'.\\');\\n        return nQueen(board,0,n);\\n    }\\n    \\n    public List<List<String>> nQueen(char[][] board, int r, int n)\\n    {\\n        List<List<String>> outer = new ArrayList<List<String>>();\\n        if(r == n)\\n        {\\n            List<String> inner = new ArrayList<String>();\\n            for(int i = 0; i < n; i++)\\n            {\\n                inner.add(String.valueOf(board[i]));\\n            }\\n            outer.add(inner);\\n            return outer;\\n        }\\n        for(int c = 0; c < n; c++)\\n        {\\n            if(isValid(board,r,c,n))\\n            {\\n                board[r][c] = \\'Q\\';\\n                outer.addAll(nQueen(board,r+1,n));\\n                board[r][c] = \\'.\\';\\n            }\\n        }\\n        return outer;\\n    }\\n    \\n    public boolean isValid(char[][] board, int r, int c, int n)\\n    {\\n        \\n        //Checking for Q in same column\\n        for(int i = 0; i < r; i++)\\n        {\\n            if(board[i][c] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        //Checking for Q in top left diagonal\\n        int x = r-1;\\n        int y = c-1;\\n        while(x>=0 && y>=0)\\n        {\\n            if(board[x][y] == \\'Q\\')\\n                return false;\\n            x--;\\n            y--;\\n        }\\n        \\n        //Checking for Q in top right diagonal\\n        x = r-1;\\n        y = c+1;\\n        while(x>=0 && y<=n-1)\\n        {\\n            if(board[x][y] == \\'Q\\')\\n                return false;\\n            x--;\\n            y++;\\n        }\\n        \\n        return true;   \\n    } \\n} \\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] board = new char[n][n];\\n        for(char[] row : board)\\n            Arrays.fill(row,\\'.\\');\\n        return nQueen(board,0,n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1586289,
                "title": "easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def in_range(r, c):\\n            return 0 <= r < n and 0 <= c < n\\n        \\n        def can_place(r, c, board):\\n            #check above\\n            for i in range(c):\\n                if board[r][i] == \\'Q\\':\\n                    return False\\n            #check upper left\\n            for i in range(1, c + 1):\\n                if not in_range(r - i, c - i):\\n                    break\\n                if board[r - i][c - i] == \\'Q\\':\\n                    return False\\n            #check lower left\\n            for i in range(1, c + 1):\\n                if not in_range(r + i, c - i):\\n                    break\\n                if board[r + i][c - i] == \\'Q\\':\\n                    return False\\n            return True\\n        \\n        def place_queens(c, board):\\n            if c == n:\\n                res.append([\\'\\'.join(line) for line in board])\\n                return\\n            \\n            for r in range(n):\\n                if can_place(r, c, board):\\n                    board[r][c] = \\'Q\\'\\n                    place_queens(c + 1, board)\\n                    board[r][c] = \\'.\\'\\n                    \\n        res = []\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        place_queens(0, board)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def in_range(r, c):\\n            return 0 <= r < n and 0 <= c < n\\n        \\n        def can_place(r, c, board):\\n            #check above\\n            for i in range(c):\\n                if board[r][i] == \\'Q\\':\\n                    return False\\n            #check upper left\\n            for i in range(1, c + 1):\\n                if not in_range(r - i, c - i):\\n                    break\\n                if board[r - i][c - i] == \\'Q\\':\\n                    return False\\n            #check lower left\\n            for i in range(1, c + 1):\\n                if not in_range(r + i, c - i):\\n                    break\\n                if board[r + i][c - i] == \\'Q\\':\\n                    return False\\n            return True\\n        \\n        def place_queens(c, board):\\n            if c == n:\\n                res.append([\\'\\'.join(line) for line in board])\\n                return\\n            \\n            for r in range(n):\\n                if can_place(r, c, board):\\n                    board[r][c] = \\'Q\\'\\n                    place_queens(c + 1, board)\\n                    board[r][c] = \\'.\\'\\n                    \\n        res = []\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        place_queens(0, board)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577714,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        // checking row\\n        for(int i = 0; i < row; ++i) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check left diagonal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(board[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check right diagonal\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < board.size()) {\\n            if(board[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(vector<vector<string>> &ans, vector<string> &board, int row, int target){\\n\\t\\t//if we come to the last row check\\n        if(row == board.size()){\\n\\t\\t\\t//do we have queens left?\\n            if(target == 0){\\n\\t\\t\\t\\t//if no push the answer\\n                ans.push_back(board);\\n            }\\n\\t\\t\\t//if queens are left return\\n            return;\\n        }\\n        for(int col=0; col < board.size(); col++){\\n\\t\\t\\t//checking if the location is safe\\n            if(isSafe(board, row, col)){\\n\\t\\t\\t\\t//if safe put queen \\n                board[row][col] = \\'Q\\';\\n\\t\\t\\t\\t//find recursive solution\\n                solve(ans, board, row + 1, target - 1);\\n\\t\\t\\t\\t//backtrack\\n                board[row][col] = \\'.\\';\\n            }\\n        } \\n        return;\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n, string(n, \\'.\\'));  //initialize the string to \\'.\\'\\n        solve(ans, board, 0, n);\\n        return ans;\\n    }\\n};\\n```\\n\\n**do upvote, if helpful !**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<string> &board, int row, int col){\\n        // checking row\\n        for(int i = 0; i < row; ++i) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // check left diagonal\\n        int r = row-1, c = col-1;\\n        while(r >= 0 && c >= 0) {\\n            if(board[r--][c--] == \\'Q\\') return false;\\n        }\\n        // check right diagonal\\n        r = row-1, c = col+1;\\n        while(r >= 0 && c < board.size()) {\\n            if(board[r--][c++] == \\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(vector<vector<string>> &ans, vector<string> &board, int row, int target){\\n\\t\\t//if we come to the last row check\\n        if(row == board.size()){\\n\\t\\t\\t//do we have queens left?\\n            if(target == 0){\\n\\t\\t\\t\\t//if no push the answer\\n                ans.push_back(board);\\n            }\\n\\t\\t\\t//if queens are left return\\n            return;\\n        }\\n        for(int col=0; col < board.size(); col++){\\n\\t\\t\\t//checking if the location is safe\\n            if(isSafe(board, row, col)){\\n\\t\\t\\t\\t//if safe put queen \\n                board[row][col] = \\'Q\\';\\n\\t\\t\\t\\t//find recursive solution\\n                solve(ans, board, row + 1, target - 1);\\n\\t\\t\\t\\t//backtrack\\n                board[row][col] = \\'.\\';\\n            }\\n        } \\n        return;\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n, string(n, \\'.\\'));  //initialize the string to \\'.\\'\\n        solve(ans, board, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569067,
                "title": "java-backtracking-intuition-easy-to-understand-code",
                "content": "**Intuition:**\\n- Recursively we\\'ll try to place 1 Queen at a time in each row, because 2 Queens can\\'t be placed on the same row as they\\'ll attack each other.\\n- After placing a Queen, if the next Queen cannot be placed in the next row, then definitely it doesn\\'t make sense to explore all the other remaining rows as one of the row will then have to accomodate more than one Queens which contradicts the previous statement. If such a situation arises then we backtrack and try to place the previous Queen in a different column of the same row and then continue the same process again.\\n- If all Queens were successfully placed in each rows, then we have found a way of placing the N queens. So we add the current grid into our final result.\\n- The process can be repeated until we have explored placing the first queen in each of the different columns of the first row.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] grid = new boolean[n][n];\\n        List<List<String>> result = new ArrayList<>();\\n        explore(grid, result, n, 0);\\n        return result;\\n    }\\n    \\n    void explore(boolean[][] grid, List<List<String>> result, int n, int row){\\n\\t    // When queens placed in all rows\\n        if(n == row){\\n            result.add(getGridAsListOfStrings(grid));\\n            return;\\n        }\\n        \\n        for(int i=0; i < n; i++){\\n            if(canPlaceQueen(grid, row, i, n)){\\n                grid[row][i] = true;\\n                explore(grid, result, n, row+1); // Explore next row\\n                grid[row][i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean canPlaceQueen(boolean[][] grid, int row, int col, int n){\\n        // Column check\\n        for(int i=row-1; i >=0; i--)\\n            if(grid[i][col]) return false;\\n        \\n        // Left Upper diagonal Check\\n        for(int i=row-1, j=col-1; i >=0 && j >= 0; i--, j--)\\n            if(grid[i][j]) return false;        \\n        \\n        // Right Upper diagonal Check\\n        for(int i=row-1, j=col+1; i >=0 && j < n; i--, j++)\\n            if(grid[i][j]) return false;\\n        \\n        return true;\\n    }\\n    \\n    List<String> getGridAsListOfStrings(boolean[][] grid){\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0; i < grid.length; i++){\\n            StringBuilder currRow = new StringBuilder();\\n            for(int j=0; j < grid.length; j++){\\n                if(grid[i][j]) \\n                    currRow.append(\"Q\");\\n                else\\n                    currRow.append(\".\");\\n            }\\n            ans.add(currRow.toString());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] grid = new boolean[n][n];\\n        List<List<String>> result = new ArrayList<>();\\n        explore(grid, result, n, 0);\\n        return result;\\n    }\\n    \\n    void explore(boolean[][] grid, List<List<String>> result, int n, int row){\\n\\t    // When queens placed in all rows\\n        if(n == row){\\n            result.add(getGridAsListOfStrings(grid));\\n            return;\\n        }\\n        \\n        for(int i=0; i < n; i++){\\n            if(canPlaceQueen(grid, row, i, n)){\\n                grid[row][i] = true;\\n                explore(grid, result, n, row+1); // Explore next row\\n                grid[row][i] = false;\\n            }\\n        }\\n    }\\n    \\n    boolean canPlaceQueen(boolean[][] grid, int row, int col, int n){\\n        // Column check\\n        for(int i=row-1; i >=0; i--)\\n            if(grid[i][col]) return false;\\n        \\n        // Left Upper diagonal Check\\n        for(int i=row-1, j=col-1; i >=0 && j >= 0; i--, j--)\\n            if(grid[i][j]) return false;        \\n        \\n        // Right Upper diagonal Check\\n        for(int i=row-1, j=col+1; i >=0 && j < n; i--, j++)\\n            if(grid[i][j]) return false;\\n        \\n        return true;\\n    }\\n    \\n    List<String> getGridAsListOfStrings(boolean[][] grid){\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0; i < grid.length; i++){\\n            StringBuilder currRow = new StringBuilder();\\n            for(int j=0; j < grid.length; j++){\\n                if(grid[i][j]) \\n                    currRow.append(\"Q\");\\n                else\\n                    currRow.append(\".\");\\n            }\\n            ans.add(currRow.toString());\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223128,
                "title": "n-queens-c-backtracking",
                "content": "**CODE:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n        \\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)  // found a possible position of queens\\n        {\\n            vector<string> tempp;\\n            for(int i=0;i<n;i++)\\n            {\\n                string temp=\"\";\\n                for(int j=0;j<n;j++)\\n                    temp+=board[i][j];\\n                tempp.push_back(temp);\\n            }\\n            ans.push_back(tempp);\\n            return;   \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))  // checks whether placing a new queend at (i,col) safe or not\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);  // placed the queen and called for next col\\n                board[i][col]=\".\";  // backtracking\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) \\n    {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```\\nDO **UPVOTE** IF YOU LIKED IT !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isSafe(int &row, int &col, vector<vector<string>> &board, int &n)\\n    {\\n        // same row\\n        for(int j=0;j<n;j++)\\n            if(board[row][j]==\"Q\")\\n                return false;\\n        \\n        // diagonals\\n        // since we are placing queens from left column to right column we need to check upper left and lower left diagonals only\\n        \\n        for(int i=row,j=col;i>=0 and j>=0; i--,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        for(int i=row,j=col;i<n and j>=0; i++,j--)\\n            if(board[i][j]==\"Q\")\\n                return false;\\n        \\n        return true;\\n    }\\n    void solve(int col, vector<vector<string>> &board, int &n)\\n    {\\n        if(col==n)  // found a possible position of queens\\n        {\\n            vector<string> tempp;\\n            for(int i=0;i<n;i++)\\n            {\\n                string temp=\"\";\\n                for(int j=0;j<n;j++)\\n                    temp+=board[i][j];\\n                tempp.push_back(temp);\\n            }\\n            ans.push_back(tempp);\\n            return;   \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(isSafe(i,col,board,n))  // checks whether placing a new queend at (i,col) safe or not\\n            {\\n                board[i][col]=\"Q\";\\n                solve(col+1, board, n);  // placed the queen and called for next col\\n                board[i][col]=\".\";  // backtracking\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) \\n    {\\n        // we will place every queen in different columns so that one of the possible clashes (vertically) do not occurs\\n        vector<vector<string>> board(n, vector<string> (n,\".\"));\\n        solve(0,board,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223006,
                "title": "n-queens-easy-backtracking-solution-w-explanation",
                "content": "\\u2714\\uFE0F ***Solution (Backtracking)***\\n\\nThis is a common backtracking problem. We can see than the number of ways to place a `N` queens on a `NxN` board can get very large since we have `N^2` choices at first, then `N^2 -1`, `N^2 -2` and so on... leading to overall time complexity of `O(N^2N)`.\\n\\nBut, we must realise that we don\\'t actually need to explore all `O(N^2)` options each time. Firstly, we have `N` Queens and all must be placed such that no queen attacks the other queen. This means, on each row only one queen can be placed and then we can move to the next row.\\n\\nSo for each row, we will place one queen (if its possible without violating the constraint) and then move on to the next row. This will be repeated till all `N` queens have been placed. We will use the *`check`* method to ensure that the queen is safe to place at *`(i, j)`*. Once, all `N` queens have been placed, we have got our first solution.\\n\\nTo get all the other possible solutions, we will need to remove the previously placed queen and try if its possible to place it at some other location, i.e, we need to **backtrack**. This will give us all the possible combinations to place `N` queens on the board as per the given constraints.\\n\\nA visualization from [wikipedia](https://en.wikipedia.org/wiki/File:Eight-queens-animation.gif) -\\n\\n<p align = center><img src=https://assets.leetcode.com/users/images/d2f3e045-6674-4828-bb23-8ccf3a0e1283_1621672263.6452782.gif /></p>\\n\\nAnother good visualization of N-Queens problem can be found [here](https://www.cs.usfca.edu/~galles/visualization/RecQueens.html)\\n\\n```\\nvector<vector<string> > sols;\\nvector<vector<string>> solveNQueens(int n) {    \\n\\tvector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\tsolve(board, 0);\\n\\treturn sols;\\n}\\nbool check(vector<string>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(board[i][col] == \\'Q\\') return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking all diagonals-\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false;\\n\\t}\\n\\treturn true;\\n}\\n// Recursive solver - Tries all possible placement of queen for current row & recurses for next row\\nvoid solve(vector<string>& board, int row) {\\n\\t// base condition. When we reach here, a valid placement combination has been formed. So insert it into ans\\n\\tif(row == size(board)) { \\n\\t\\tsols.push_back(board);\\n\\t\\treturn;\\n\\t}            \\n\\t// Try placing a queen on each column for a given row. Explore next row by placing Q at each valid column for the current row\\n\\tfor(int col = 0; col < size(board); col++) \\n\\t\\tif(check(board, row, col)) {\\n\\t\\t\\tboard[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\tsolve(board, row + 1);    // exploring next row\\n\\t\\t\\tboard[row][col] = \\'.\\';    // backtracking to get all possible solutions\\n\\t\\t}            \\n}\\n```\\n\\n***Time Complexity :*** **`O(N!)`**, we have *`N`* choices in the first row, *`N-1`* in the second row, *`N-2`* in the next and so on... which brings overall time complexity to `O(N!)`\\n***Time Complexity :*** **`O(N*N)`**. Required for board and recursive stack. This doesn\\'t include extra space used by *`ans`*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<string> > sols;\\nvector<vector<string>> solveNQueens(int n) {    \\n\\tvector<string> board(n, string(n, \\'.\\'));  // creating an empty board\\n\\tsolve(board, 0);\\n\\treturn sols;\\n}\\nbool check(vector<string>& board, int row, int col) {\\n\\tint n = size(board);\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(board[i][col] == \\'Q\\') return false; // checking if any queen already placed on same column previously\\n\\t\\t// checking all diagonals-\\n\\t\\tif(row - i >= 0 && col - i >= 0 && board[row - i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row - i >= 0 && col + i <  n && board[row - i][col + i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col - i >= 0 && board[row + i][col - i] == \\'Q\\') return false;\\n\\t\\tif(row + i <  n && col + i <  n && board[row + i][col + i] == \\'Q\\') return false;\\n\\t}\\n\\treturn true;\\n}\\n// Recursive solver - Tries all possible placement of queen for current row & recurses for next row\\nvoid solve(vector<string>& board, int row) {\\n\\t// base condition. When we reach here, a valid placement combination has been formed. So insert it into ans\\n\\tif(row == size(board)) { \\n\\t\\tsols.push_back(board);\\n\\t\\treturn;\\n\\t}            \\n\\t// Try placing a queen on each column for a given row. Explore next row by placing Q at each valid column for the current row\\n\\tfor(int col = 0; col < size(board); col++) \\n\\t\\tif(check(board, row, col)) {\\n\\t\\t\\tboard[row][col] = \\'Q\\';    // Queen placed on a valid cell\\n\\t\\t\\tsolve(board, row + 1);    // exploring next row\\n\\t\\t\\tboard[row][col] = \\'.\\';    // backtracking to get all possible solutions\\n\\t\\t}            \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185242,
                "title": "using-bitset-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\nvector<vector<string>> solveNQueens(int n) {\\n\\t vector<vector<string> > res;\\n        vector<string> nQueens(n, string(n, \\'.\\'));\\n        solveNQueens(res, nQueens, 0, n);\\n        return res;\\n    }\\nprivate:\\n      bitset<43>flag;//bitset\\n    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {\\n        if (row == n) {\\n            res.push_back(nQueens);\\n            return;\\n        }\\n        for (int col = 0; col != n; ++col)\\n            if (!flag[col] && !flag[n + row + col] && !flag[4 * n - 2 + col - row]) {\\n                //set\\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1;\\n                nQueens[row][col] = \\'Q\\';\\n                //next\\n                solveNQueens(res, nQueens, row + 1, n);\\n                //unset\\n                nQueens[row][col] = \\'.\\';\\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0;\\n            }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<vector<string>> solveNQueens(int n) {\\n\\t vector<vector<string> > res;\\n        vector<string> nQueens(n, string(n, \\'.\\'));\\n        solveNQueens(res, nQueens, 0, n);\\n        return res;\\n    }\\nprivate:\\n      bitset<43>flag;//bitset\\n    void solveNQueens(vector<vector<string> > &res, vector<string> &nQueens, int row, int &n) {\\n        if (row == n) {\\n            res.push_back(nQueens);\\n            return;\\n        }\\n        for (int col = 0; col != n; ++col)\\n            if (!flag[col] && !flag[n + row + col] && !flag[4 * n - 2 + col - row]) {\\n                //set\\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 1;\\n                nQueens[row][col] = \\'Q\\';\\n                //next\\n                solveNQueens(res, nQueens, row + 1, n);\\n                //unset\\n                nQueens[row][col] = \\'.\\';\\n                flag[col] = flag[n + row + col] = flag[4 * n - 2 + col - row] = 0;\\n            }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160884,
                "title": "c-backtracking-explanation",
                "content": "This is a Standard problem on backtracking.\\nFirst let me tell you what backtracking is?\\nWe all are familiar with brute force techniques to reach a solution. In brute force we try all possiblities upto considering all elements. But in backtracking we check at every point .. Is it valid to go to another step with this set of points ? if yes then we move forward accepting the previous set and if not valid then we discard the point.\\n\\nlet us look at the code..\\n\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int col ,int n, int row,  vector<string>&pos, vector<vector<string>>& ans)\\n    {\\n        \\n    for(int i=0;i!=row;i++)\\n    {\\n        if(pos[i][col]==\\'Q\\')\\n            return false;\\n    }\\n        \\n        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++)\\n        {\\n              if(pos[i][j]==\\'Q\\')\\n            return false;\\n        }\\n        \\n          for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)\\n        {\\n              if(pos[i][j]==\\'Q\\')\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void back(int n , int row, vector<string>&pos, vector<vector<string>>&ans)\\n    {\\n        \\n        if(row==n)\\n        {\\n            ans.push_back(pos);\\n            return;\\n        }\\n        int col;\\n        for(col=0;col<n;col++)\\n        {\\n            if(isvalid(col,n,row, pos, ans)){\\n                \\n                pos[row][col] =\\'Q\\';\\n                back(n, row+1, pos, ans);\\n                pos[row][col]= \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n        vector<vector<string>> ans;\\n        \\n       vector<string> pos(n,string(n,\\'.\\'));\\n        \\n        back(n,0,pos,ans);\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n\\n\\n\"\"\"\\nif you see in\"back\" function we try to check if the points we are considering are valid (Goes according to constraints or not) if they go accordingly then we make the pos[row][col]=\\'Q\\'; and vice versa.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvalid(int col ,int n, int row,  vector<string>&pos, vector<vector<string>>& ans)\\n    {\\n        \\n    for(int i=0;i!=row;i++)\\n    {\\n        if(pos[i][col]==\\'Q\\')\\n            return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 982384,
                "title": "python3-backtrack",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = []\\n    \\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        self.backtrack(board, 0)\\n        return self.ans\\n    \\n    def backtrack(self, board, row):\\n        \\n        if len(board) == row:\\n            layout = [\\'\\'.join(board[i]) for i in range(len(board))]\\n            self.ans.append(layout)\\n            return\\n        \\n        for c in range(len(board)):\\n            if not self.is_valid_pos(board, row, c):\\n                continue\\n            \\n            board[row][c] = \\'Q\\'\\n            self.backtrack(board, row + 1)\\n            # pop this path end\\n            board[row][c] = \\'.\\'\\n    \\n    def is_valid_pos(self, board, row, col):\\n        \\n        # from top to bottom\\n        for r in range(len(board)):\\n            if board[r][col] == \\'Q\\':\\n                return False\\n        \\n        # upper left\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n        \\n        # upper right\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < len(board):\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n        \\n        return True\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = []\\n    \\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        self.backtrack(board, 0)\\n        return self.ans\\n    \\n    def backtrack(self, board, row):\\n        \\n        if len(board) == row:\\n            layout = [\\'\\'.join(board[i]) for i in range(len(board))]\\n            self.ans.append(layout)\\n            return\\n        \\n        for c in range(len(board)):\\n            if not self.is_valid_pos(board, row, c):\\n                continue\\n            \\n            board[row][c] = \\'Q\\'\\n            self.backtrack(board, row + 1)\\n            # pop this path end\\n            board[row][c] = \\'.\\'\\n    \\n    def is_valid_pos(self, board, row, col):\\n        \\n        # from top to bottom\\n        for r in range(len(board)):\\n            if board[r][col] == \\'Q\\':\\n                return False\\n        \\n        # upper left\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n        \\n        # upper right\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < len(board):\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n        \\n        return True\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 902641,
                "title": "c-fast-99-backtracking",
                "content": "\\tpublic class Solution \\n\\t{\\n\\t\\tprivate int N;\\n\\t\\tpublic IList<IList<string>> SolveNQueens(int n) \\n\\t\\t{\\n\\t\\t\\tN = n;\\n\\t\\t\\tvar res = new List<IList<string>>();\\n\\t\\t\\tchar[][] board = new char[N][];\\n\\t\\t\\tfor (int i = 0; i < N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i] = new char[N];\\n\\t\\t\\t\\tArray.Fill(board[i], \\'.\\');\\n\\t\\t\\t}\\n\\n\\t\\t\\tHelper(res, board, 0);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tprivate void Helper(IList<IList<string>> res, char[][] board, int rowIndex)\\n\\t\\t{\\n\\t\\t\\tif (rowIndex == N)\\n\\t\\t\\t{\\n\\t\\t\\t\\tIList<string> list = new List<string>();\\n\\t\\t\\t\\tfor (int i = 0; i < N; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstring s = new string(board[i]);\\n\\t\\t\\t\\t\\tlist.Add(s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres.Add((list));\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int colIndex = 0; colIndex < N; colIndex++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (IsValid(board, rowIndex, colIndex))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tboard[rowIndex][colIndex] = \\'Q\\';\\n\\t\\t\\t\\t\\tHelper(res, board, rowIndex + 1);\\n\\t\\t\\t\\t\\tboard[rowIndex][colIndex] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate bool IsValid(char[][] board, int rowIndex, int colIndex)\\n\\t\\t{\\n\\t\\t\\tfor (int i = 0; i < rowIndex; i++)\\n\\t\\t\\t\\tif (board[i][colIndex] == \\'Q\\') return false;\\n\\n\\t\\t\\tfor (int i = rowIndex - 1, j = colIndex - 1; i >= 0 && j >= 0; i--, j--)\\n\\t\\t\\t\\tif (board[i][j] == \\'Q\\') return false;\\n\\n\\t\\t\\tfor (int i = rowIndex - 1, j = colIndex + 1; i >= 0 && j < N; i--, j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (board[i][j] == \\'Q\\') return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution \\n\\t{\\n\\t\\tprivate int N;\\n\\t\\tpublic IList<IList<string>> SolveNQueens(int n) \\n\\t\\t{\\n\\t\\t\\tN = n;\\n\\t\\t\\tvar res = new List<IList<string>>();\\n\\t\\t\\tchar[][] board = new char[N][];\\n\\t\\t\\tfor (int i = 0; i < N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tboard[i] = new char[N];\\n\\t\\t\\t\\tArray.Fill(board[i], \\'.\\');\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 595643,
                "title": "clean-and-readable-java-solution",
                "content": "```\\nclass Solution {\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> solutions = new ArrayList<>();\\n        List<Integer> queenCols = new ArrayList<>(n);\\n\\n        backtrack(0, n, queenCols, solutions);\\n\\n        return solutions;\\n    }\\n\\n    private void backtrack(int startRow, int n, List<Integer> queenCols, List<List<String>> solutions) {\\n        for (int row = startRow; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (canPlaceQueen(row, col, queenCols)) {\\n                    queenCols.add(col);\\n\\n                    if (queenCols.size() == n) {\\n                        solutions.add(convertSolution(n, queenCols));\\n                    } else {\\n                        backtrack(row + 1, n, queenCols, solutions);\\n                    }\\n\\n                    queenCols.remove(queenCols.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean canPlaceQueen(int row, int col, List<Integer> queenCols) {\\n        for (int queenRow = 0; queenRow < queenCols.size(); queenRow++) {\\n            int queenCol = queenCols.get(queenRow);\\n\\n            if (row == queenRow || col == queenCol || Math.abs(row - queenRow) == Math.abs(col - queenCol)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private List<String> convertSolution(int n, List<Integer> queenCols) {\\n        List<String> solution = new ArrayList<>(n);\\n        for (int row = 0; row < n; row++) {\\n            StringBuilder rowBuilder = new StringBuilder(n);\\n            for (int col = 0; col < n; col++) {\\n                rowBuilder.append(queenCols.get(row) == col ? \\'Q\\' : \\'.\\');\\n            }\\n            solution.add(rowBuilder.toString());\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> solutions = new ArrayList<>();\\n        List<Integer> queenCols = new ArrayList<>(n);\\n\\n        backtrack(0, n, queenCols, solutions);\\n\\n        return solutions;\\n    }\\n\\n    private void backtrack(int startRow, int n, List<Integer> queenCols, List<List<String>> solutions) {\\n        for (int row = startRow; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (canPlaceQueen(row, col, queenCols)) {\\n                    queenCols.add(col);\\n\\n                    if (queenCols.size() == n) {\\n                        solutions.add(convertSolution(n, queenCols));\\n                    } else {\\n                        backtrack(row + 1, n, queenCols, solutions);\\n                    }\\n\\n                    queenCols.remove(queenCols.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean canPlaceQueen(int row, int col, List<Integer> queenCols) {\\n        for (int queenRow = 0; queenRow < queenCols.size(); queenRow++) {\\n            int queenCol = queenCols.get(queenRow);\\n\\n            if (row == queenRow || col == queenCol || Math.abs(row - queenRow) == Math.abs(col - queenCol)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private List<String> convertSolution(int n, List<Integer> queenCols) {\\n        List<String> solution = new ArrayList<>(n);\\n        for (int row = 0; row < n; row++) {\\n            StringBuilder rowBuilder = new StringBuilder(n);\\n            for (int col = 0; col < n; col++) {\\n                rowBuilder.append(queenCols.get(row) == col ? \\'Q\\' : \\'.\\');\\n            }\\n            solution.add(rowBuilder.toString());\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368128,
                "title": "beats-99-python-solution-with-detailed-explanations",
                "content": "Everything is explained in comments, including my thought process.\\nEnjoy.\\n\\n```\\n\\nclass Solution:\\n\\n    def solveNQueens(self, n):\\n        \"\"\"\\n        Int -> [List String]\\n        \"\"\"\\n\\n        # IDEA:\\n        # 1. Each row contains 1 queen\\n        # 2. For each row, keep track of the valid columns for queen placement. \\n        #    (NOTE in a clever way)\\n        # 3. DFS, start from the first row, try each valid column and backtrack if necessary.\\n\\n        # NOTE that we can encode left/right diagonals as indexes in the following way\\n        # For any (r, c),\\n        # its top-left to bottom-right diagonal index is r - c, \\u2208 (-n, n)\\n        # its bottom-left to top-right diagonal index is r + c, \\u2208 [0, 2n)\\n\\n        # Each (r, c) takes the r-th row, c-th column, and the two diagonal indexes encoded above\\n        # Thus we can use 4 sets to indicate whether those row/col/diagonal have\\n        # been taken, if yes, a queen cannot be placed at (r, c) .\\n\\n        # Moreover, if we search via dfs, proceeding row by row, we can avoid keeping\\n        # the row set, getting away with 3 sets only (column, and 2 diagonals)\\n        # Each set indicates whether the column/diagonal with the specified index has been taken\\n        valid_columns = set([i for i in range(n)])\\n        valid_tl_to_brs = set([i for i in range(-n + 1, n)])\\n        valid_bl_to_trs = set([i for i in range(2*n)])\\n\\n        # will contain the solutions discovered during dfs\\n        solutions = []\\n        # an global accumulator used during dfs to determine\\n        # the previously selected (row, col) placements\\n        # (i, previous_cols[i]) is the coordinate encoding.\\n        previous_cols = []\\n\\n        def dfs(row):\\n            # Int [List Int] -> Void\\n            # try to place (n-row) queens in the [row, n) rows.\\n            # Add the answer to the solutions list if one is found.\\n\\n            # all rows have been searched, append a copy of the solution\\n            if row >= n:\\n                answer = [\"\".join([\"Q\" if col == previous_cols[row] else \".\" for col in range(n)]) for row in range(n)]\\n                solutions.append(answer)\\n                return \\n\\n            # try each column candidates and place queen at (row, col)\\n            for col in valid_columns:\\n                # calculate the diagonal indexes\\n                tl_to_br_index = row - col\\n                bl_to_tr_index = row + col\\n\\n                # check if it\\'s valid to place at (row, col)\\n                if tl_to_br_index in valid_tl_to_brs and bl_to_tr_index in valid_bl_to_trs:\\n                    # update the three sets and preivous_cols\\n                    valid_columns.remove(col)\\n                    valid_tl_to_brs.remove(tl_to_br_index)\\n                    valid_bl_to_trs.remove(bl_to_tr_index)\\n                    previous_cols.append(col)\\n                    # continue dfs\\n                    dfs(row + 1)\\n                    # undo the updates \\n                    valid_columns.add(col)\\n                    valid_tl_to_brs.add(tl_to_br_index)\\n                    valid_bl_to_trs.add(bl_to_tr_index)\\n                    previous_cols.pop()\\n                    \\n        dfs(0)\\n        return solutions\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n\\n    def solveNQueens(self, n):\\n        \"\"\"\\n        Int -> [List String]\\n        \"\"\"\\n\\n        # IDEA:\\n        # 1. Each row contains 1 queen\\n        # 2. For each row, keep track of the valid columns for queen placement. \\n        #    (NOTE in a clever way)\\n        # 3. DFS, start from the first row, try each valid column and backtrack if necessary.\\n\\n        # NOTE that we can encode left/right diagonals as indexes in the following way\\n        # For any (r, c),\\n        # its top-left to bottom-right diagonal index is r - c, \\u2208 (-n, n)\\n        # its bottom-left to top-right diagonal index is r + c, \\u2208 [0, 2n)\\n\\n        # Each (r, c) takes the r-th row, c-th column, and the two diagonal indexes encoded above\\n        # Thus we can use 4 sets to indicate whether those row/col/diagonal have\\n        # been taken, if yes, a queen cannot be placed at (r, c) .\\n\\n        # Moreover, if we search via dfs, proceeding row by row, we can avoid keeping\\n        # the row set, getting away with 3 sets only (column, and 2 diagonals)\\n        # Each set indicates whether the column/diagonal with the specified index has been taken\\n        valid_columns = set([i for i in range(n)])\\n        valid_tl_to_brs = set([i for i in range(-n + 1, n)])\\n        valid_bl_to_trs = set([i for i in range(2*n)])\\n\\n        # will contain the solutions discovered during dfs\\n        solutions = []\\n        # an global accumulator used during dfs to determine\\n        # the previously selected (row, col) placements\\n        # (i, previous_cols[i]) is the coordinate encoding.\\n        previous_cols = []\\n\\n        def dfs(row):\\n            # Int [List Int] -> Void\\n            # try to place (n-row) queens in the [row, n) rows.\\n            # Add the answer to the solutions list if one is found.\\n\\n            # all rows have been searched, append a copy of the solution\\n            if row >= n:\\n                answer = [\"\".join([\"Q\" if col == previous_cols[row] else \".\" for col in range(n)]) for row in range(n)]\\n                solutions.append(answer)\\n                return \\n\\n            # try each column candidates and place queen at (row, col)\\n            for col in valid_columns:\\n                # calculate the diagonal indexes\\n                tl_to_br_index = row - col\\n                bl_to_tr_index = row + col\\n\\n                # check if it\\'s valid to place at (row, col)\\n                if tl_to_br_index in valid_tl_to_brs and bl_to_tr_index in valid_bl_to_trs:\\n                    # update the three sets and preivous_cols\\n                    valid_columns.remove(col)\\n                    valid_tl_to_brs.remove(tl_to_br_index)\\n                    valid_bl_to_trs.remove(bl_to_tr_index)\\n                    previous_cols.append(col)\\n                    # continue dfs\\n                    dfs(row + 1)\\n                    # undo the updates \\n                    valid_columns.add(col)\\n                    valid_tl_to_brs.add(tl_to_br_index)\\n                    valid_bl_to_trs.add(bl_to_tr_index)\\n                    previous_cols.pop()\\n                    \\n        dfs(0)\\n        return solutions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134512,
                "title": "10-line-solution-68ms-solution-easy-to-understand-explanation",
                "content": "Full discussion of n-queens and backtracking and how to go from standard to 10 liner solution:\\nhttps://fizzbuzzed.com/top-interview-questions-3/\\n\\n10 liner\\n```python\\ndef solveNQueens(n):\\n    output = []\\n    def dfs(row, queens, diags):\\n        if row == n:\\n            output.append([\\'.\\'*x + \\'Q\\' + \\'.\\'*(n-x-1) for x in queens])\\n            return\\n        for col in range(n):\\n            if not any([row+col in diags, row-col-n-1 in diags, col in queens]):\\n                dfs(row + 1, queens + [col], diags | {row+col, row-col-n-1})\\n    dfs(0, [], set())\\n    return output\\n```\\n\\nExplanation of diagonals: https://fizzbuzzed.com/top-interview-questions-3/#diagonals\\n\\n68ms and easier to understand (I think):\\n\\n```python\\nclass Board:\\n    def __init__(self, n):\\n        self.cols = set()\\n        self.right_diags = set()\\n        self.left_diags = set()\\n        self.queen_locations = []\\n        self.n = n\\n    def add(self, row, col):\\n        self.cols.add(col)\\n        self.right_diags.add(row + col)\\n        self.left_diags.add(row - col)\\n        self.queen_locations.append(col)\\n    def remove(self, row, col):\\n        self.cols.remove(col)\\n        self.right_diags.remove(row + col)\\n        self.left_diags.remove(row - col)\\n        self.queen_locations.pop()\\n    def isValidPlacement(self, row, col):\\n        return col not in self.cols and \\\\\\n                row + col not in self.right_diags and \\\\\\n                row - col not in self.left_diags\\n    def outputFormat(self):\\n        return [\\'.\\'*x + \\'Q\\' + \\'.\\'*(self.n-x-1) for x in self.queen_locations]\\n\\ndef solveNQueens(n):\\n    output = []\\n    board = Board(n)\\n    def solveNQueensRecursive(row):\\n        if row == n:\\n            output.append(board.outputFormat())\\n        for col in range(n):\\n            if board.isValidPlacement(row, col):\\n                board.add(row, col)\\n                solveNQueensRecursive(row + 1)\\n                board.remove(row, col)\\n    solveNQueensRecursive(0)\\n    return output\\n```\\n\\n\\n\\nTips for going from longer easy to understand to short solution: https://fizzbuzzed.com/top-interview-questions-3/#shortsolution\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef solveNQueens(n):\\n    output = []\\n    def dfs(row, queens, diags):\\n        if row == n:\\n            output.append([\\'.\\'*x + \\'Q\\' + \\'.\\'*(n-x-1) for x in queens])\\n            return\\n        for col in range(n):\\n            if not any([row+col in diags, row-col-n-1 in diags, col in queens]):\\n                dfs(row + 1, queens + [col], diags | {row+col, row-col-n-1})\\n    dfs(0, [], set())\\n    return output\\n```\n```python\\nclass Board:\\n    def __init__(self, n):\\n        self.cols = set()\\n        self.right_diags = set()\\n        self.left_diags = set()\\n        self.queen_locations = []\\n        self.n = n\\n    def add(self, row, col):\\n        self.cols.add(col)\\n        self.right_diags.add(row + col)\\n        self.left_diags.add(row - col)\\n        self.queen_locations.append(col)\\n    def remove(self, row, col):\\n        self.cols.remove(col)\\n        self.right_diags.remove(row + col)\\n        self.left_diags.remove(row - col)\\n        self.queen_locations.pop()\\n    def isValidPlacement(self, row, col):\\n        return col not in self.cols and \\\\\\n                row + col not in self.right_diags and \\\\\\n                row - col not in self.left_diags\\n    def outputFormat(self):\\n        return [\\'.\\'*x + \\'Q\\' + \\'.\\'*(self.n-x-1) for x in self.queen_locations]\\n\\ndef solveNQueens(n):\\n    output = []\\n    board = Board(n)\\n    def solveNQueensRecursive(row):\\n        if row == n:\\n            output.append(board.outputFormat())\\n        for col in range(n):\\n            if board.isValidPlacement(row, col):\\n                board.add(row, col)\\n                solveNQueensRecursive(row + 1)\\n                board.remove(row, col)\\n    solveNQueensRecursive(0)\\n    return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 19935,
                "title": "java-5ms-backtracking",
                "content": "    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ret = new ArrayList<>();\\n        if (n <= 0) return ret;\\n        char[][] curr = new char[n][n];\\n        for (char[] row : curr) {\\n            Arrays.fill(row, '.');\\n        }\\n        boolean[] col_occupied = new boolean[n];\\n        helper(ret, curr, col_occupied, 0, n);\\n        return ret;\\n    }\\n    private void helper(List<List<String>> ret, char[][] curr, boolean[] col_occupied, int r, int n) {\\n        if (r == n) {\\n            List<String> list = new ArrayList<String>();\\n            for (char[] row : curr) {\\n                list.add(new String(row));\\n            }\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (isValid(curr, col_occupied, r, i, n)){\\n                curr[r][i] = 'Q';\\n                col_occupied[i] = true;\\n                helper(ret, curr, col_occupied, r+1, n);\\n                curr[r][i] = '.';\\n                col_occupied[i] = false;\\n            }\\n        }\\n    }\\n    private boolean isValid(char[][]curr, boolean[] col_occupied, int row, int col, int n) {\\n        if (col_occupied[col]) return false;\\n        for (int i=1; row-i>=0 && col-i>=0; i++) {\\n            if (curr[row-i][col-i] == 'Q') return false;\\n        }\\n        for (int i=1; row-i>=0 && col+i<n; i++) {\\n            if (curr[row-i][col+i] == 'Q') return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ret = new ArrayList<>();\\n        if (n <= 0) return ret;\\n        char[][] curr = new char[n][n];\\n        for (char[] row : curr) {\\n            Arrays.fill(row, '.');\\n        }\\n        boolean[] col_occupied = new boolean[n];\\n        helper(ret, curr, col_occupied, 0, n);\\n        return ret;\\n    }\\n    private void helper(List<List<String>> ret, char[][] curr, boolean[] col_occupied, int r, int n) {\\n        if (r == n) {\\n            List<String> list = new ArrayList<String>();\\n            for (char[] row : curr) {\\n                list.add(new String(row));\\n            }\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i=0; i<n; i++) {\\n            if (isValid(curr, col_occupied, r, i, n)){\\n                curr[r][i] = 'Q';\\n                col_occupied[i] = true;\\n                helper(ret, curr, col_occupied, r+1, n);\\n                curr[r][i] = '.';\\n                col_occupied[i] = false;\\n            }\\n        }\\n    }\\n    private boolean isValid(char[][]curr, boolean[] col_occupied, int row, int col, int n) {\\n        if (col_occupied[col]) return false;\\n        for (int i=1; row-i>=0 && col-i>=0; i++) {\\n            if (curr[row-i][col-i] == 'Q') return false;\\n        }\\n        for (int i=1; row-i>=0 && col+i<n; i++) {\\n            if (curr[row-i][col+i] == 'Q') return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20013,
                "title": "why-i-cannot-use-memset-function",
                "content": "    bool valid_q( int row, int col, int* board, int size ); \\n    void do_solve( int row, int n, int* answer, vector<vector<string> >& result_vector );\\n    \\n    class Solution {\\n    public:\\n        vector<vector<string> > solveNQueens(int n) {\\n        const int INITIAL = -999;\\n    \\tvector<vector<string> > re_so;\\n    \\n        //When I use memset here, the answer went wrong,\\n        //I can only assign the value one by one\\n        //there is no compile error nor the runtime error\\n        //it cannot pass the test case when n = 4\\n    \\tint* a = new int[n]; //the answer set \\n    \\t//memset( a, INITIAL, n );\\n    \\tfor( int i = 0; i < n; i++ )\\n    \\t    a[i] = INITIAL;\\n    \\n    \\n    \\tdo_solve( 0, n, a, re_so );\\n    \\treturn re_so;\\n        \\n            \\n        }\\n    };\\n    \\n    void do_solve( int row, int n, int* board, vector<vector<string> >& re_so)\\n    {\\n    \\tconst int INITIAL = -999;\\n    \\n    \\tif( row == n )\\n    \\t{\\n    \\t\\t//get one result\\n    \\t\\tvector<string> temp_so;\\n    \\t\\t//we first record the solution, then find the next\\n    \\t\\tfor( int index = 0; index < n; index++ )\\n    \\t\\t{\\n    \\t\\t\\tstring temp( n, '.' );\\n    \\t\\t\\ttemp[board[index]] = 'Q';\\n    \\t\\t\\ttemp_so.push_back(temp);\\n    \\t\\t}\\n    \\t\\tre_so.push_back( temp_so );\\n    \\t\\treturn;\\n    \\n    \\t}\\n    \\n    \\tfor( int k = 0; k < n; k++ ) //test for each col\\n    \\t{\\n    \\t\\tif( valid_q( row, k, board, n) )\\t//we can put the queen here\\n    \\t\\t{\\n    \\t\\t\\tboard[row] = k;\\n    \\t\\t\\tdo_solve( row+1, n, board, re_so ); //we find place for next line\\n    \\t\\t\\tboard[row] = INITIAL;\\t//when we back to this line, reset it\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n    //test if row i and col j is able to set a queen\\n    //a simple way to test, though exists many other ways\\n    bool valid_q( int row, int col, int* board, int size )\\n    {\\n    \\tfor( int i = 0; i < size; i++ )\\n    \\t{\\n    \\t\\t//we write seprately, sometimes do one less judge\\n    \\t\\tif( *(board+i) == col ) //means this col is used already\\n    \\t\\t\\treturn false;\\n    \\t\\telse if( abs(row - i) == abs(col - *(board+i)) ) //in the same diagonal\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\n    \\treturn true;\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<string> > solveNQueens(int n) {\\n        const int INITIAL = -999;\\n    \\tvector<vector<string> > re_so;\\n    \\n        //When I use memset here, the answer went wrong,\\n        //I can only assign the value one by one\\n        //there is no compile error nor the runtime error\\n        //it cannot pass the test case when n = 4\\n    \\tint* a = new int[n]; //the answer set \\n    \\t//memset( a, INITIAL, n );\\n    \\tfor( int i = 0; i < n; i++ )\\n    \\t    a[i] = INITIAL;\\n    \\n    \\n    \\tdo_solve( 0, n, a, re_so );\\n    \\treturn re_so;\\n        \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20019,
                "title": "1d-array-solution-java-version-for-reference",
                "content": "N-Queen solution Java version using one dimentional array colQ[] to store indices of the rows. Same logic , different language for your reference.\\n\\n    public class Solution {\\n    \\n    List<String[]> result = new LinkedList<String[]>();\\n    public List<String[]> solveNQueens(int n) {\\n        int[] colQ = new int[n];\\n        findNQ(colQ,0);\\n        return result;\\n    }\\n    \\n    public void findNQ(int[] colQ, int curcol)\\n    {\\n        if(curcol == colQ.length) result.add(getOutput(colQ));\\n        for(int j = 0; j < colQ.length; j++)\\n        {\\n            if(isSafe(colQ,j,curcol))\\n            {\\n                colQ[curcol] = j;\\n                findNQ(colQ,curcol+1);\\n            }\\n        }\\n    }\\n    \\n    public boolean isSafe(int[] colQ, int row, int curcol)\\n    {\\n        int i = 0;\\n        int j = 0;\\n        for(i = curcol-1, j = 1; i >= 0; i--, j++)\\n        {\\n            if(row == colQ[i] || row+j == colQ[i] || row-j == colQ[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public String[] getOutput(int[] colQ)\\n    {\\n        String[] outstr = new String[colQ.length];\\n        StringBuilder strbd = new StringBuilder();\\n        for(int i = 0; i < colQ.length; i++) strbd.append('.');\\n        for(int i = 0; i < colQ.length; i++)\\n        {\\n            strbd.setCharAt(i,'Q');\\n            outstr[colQ[i]] = strbd.toString();\\n            strbd.setCharAt(i,'.');\\n        }\\n        return outstr;\\n    }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    List<String[]> result = new LinkedList<String[]>();\\n    public List<String[]> solveNQueens(int n) {\\n        int[] colQ = new int[n];\\n        findNQ(colQ,0);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3972196,
                "title": "most-efficient-solution-with-complete-explanation",
                "content": "\\n\\n# Approach\\n**solveNQueens Function Setup:**\\n\\n- Initialize an empty vector of vector of strings named ans to store the solutions.\\n- Create a vector of strings named board to represent the current state of the chessboard. Initialize each string with N \\'.\\' characters.\\n - Create three vectors of integers:\\n    - lr (leftrow): To keep track of whether a row is occupied or not.\\n    - ud (upperDiagonal): To keep track of whether an upper diagonal is occupied or not.\\n    - ld (lowerDiagonal): To keep track of whether a lower diagonal is occupied or not.\\n- Call the solve function with appropriate parameters to start solving the puzzle.\\n\\n**solve Function:**\\n\\n- The solve function is a recursive backtracking function that tries to place queens column by column.\\n- The base case is when col reaches N. This means all columns have been successfully filled with queens, so the current board configuration is added to the ans vector.\\n- For each row in the current column (col), the function checks if the current cell can be a valid position for a queen. It checks if the corresponding row, upper diagonal, and lower diagonal are unoccupied.\\n- If the position is valid, it places a queen in that cell, updates the tracking vectors (lr, ud, ld), and proceeds to the next column by making a recursive call.\\n- After exploring all possible placements for the current column, it backtracks by removing the queen from the cell and resetting the tracking vectors.\\n\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void solve(int col, vector<string>& board, vector<vector<string>>& ans, vector<int>& lr, vector<int>& ud, vector<int>& ld, int n) {\\n        if (col == n) {\\n            ans.push_back(board);\\n            return;\\n        }\\n        for (int row = 0; row < n; row++) {\\n            if (lr[row] == 0 && ld[row + col] == 0 && ud[n - 1 + col - row] == 0) {\\n                board[row][col] = \\'Q\\';\\n                lr[row] = 1;\\n                ld[row + col] = 1;\\n                ud[n - 1 + col - row] = 1;\\n                \\n                solve(col + 1, board, ans, lr, ud, ld, n);\\n                \\n                board[row][col] = \\'.\\';\\n                lr[row] = 0;\\n                ld[row + col] = 0;\\n                ud[n - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');\\n        for (int i = 0; i < n; i++) {\\n            board[i] = s;\\n        }\\n        vector<int> leftrow(n, 0), upperDiagonal(2 * n - 1, 0), lowerDiagonal(2 * n - 1, 0);\\n        \\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n```JAVA []\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<>();\\n        String[] board = new String[n];\\n        Arrays.fill(board, \".\".repeat(n));\\n        int[] leftrow = new int[n];\\n        int[] upperDiagonal = new int[2 * n - 1];\\n        int[] lowerDiagonal = new int[2 * n - 1];\\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);\\n        return ans;\\n    }\\n\\n    private void solve(int col, String[] board, List<List<String>> ans, int[] lr, int[] ud, int[] ld, int n) {\\n        if (col == n) {\\n            ans.add(new ArrayList<>(Arrays.asList(board)));\\n            return;\\n        }\\n        for (int row = 0; row < n; row++) {\\n            if (lr[row] == 0 && ld[row + col] == 0 && ud[n - 1 + col - row] == 0) {\\n                char[] charArray = board[row].toCharArray();\\n                charArray[col] = \\'Q\\';\\n                board[row] = new String(charArray);\\n                lr[row] = 1;\\n                ld[row + col] = 1;\\n                ud[n - 1 + col - row] = 1;\\n                \\n                solve(col + 1, board, ans, lr, ud, ld, n);\\n                \\n                charArray[col] = \\'.\\';\\n                board[row] = new String(charArray);\\n                lr[row] = 0;\\n                ld[row + col] = 0;\\n                ud[n - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def solve(col, board, ans, lr, ud, ld, n):\\n            if col == n:\\n                ans.append([\\'\\'.join(row) for row in board])\\n                return\\n            for row in range(n):\\n                if lr[row] == 0 and ld[row - col] == 0 and ud[row + col] == 0:\\n                    board[row][col] = \\'Q\\'\\n                    lr[row] = 1\\n                    ld[row - col] = 1\\n                    ud[row + col] = 1\\n                    \\n                    solve(col + 1, board, ans, lr, ud, ld, n)\\n                    \\n                    board[row][col] = \\'.\\'\\n                    lr[row] = 0\\n                    ld[row - col] = 0\\n                    ud[row + col] = 0\\n        \\n        ans = []\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        leftrow = [0] * n\\n        upperDiagonal = [0] * (2 * n - 1)\\n        lowerDiagonal = [0] * (2 * n - 1)\\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n)\\n        return ans\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(int col, vector<string>& board, vector<vector<string>>& ans, vector<int>& lr, vector<int>& ud, vector<int>& ld, int n) {\\n        if (col == n) {\\n            ans.push_back(board);\\n            return;\\n        }\\n        for (int row = 0; row < n; row++) {\\n            if (lr[row] == 0 && ld[row + col] == 0 && ud[n - 1 + col - row] == 0) {\\n                board[row][col] = \\'Q\\';\\n                lr[row] = 1;\\n                ld[row + col] = 1;\\n                ud[n - 1 + col - row] = 1;\\n                \\n                solve(col + 1, board, ans, lr, ud, ld, n);\\n                \\n                board[row][col] = \\'.\\';\\n                lr[row] = 0;\\n                ld[row + col] = 0;\\n                ud[n - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');\\n        for (int i = 0; i < n; i++) {\\n            board[i] = s;\\n        }\\n        vector<int> leftrow(n, 0), upperDiagonal(2 * n - 1, 0), lowerDiagonal(2 * n - 1, 0);\\n        \\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);\\n        \\n        return ans;\\n    }\\n};\\n\\n```\n```JAVA []\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ans = new ArrayList<>();\\n        String[] board = new String[n];\\n        Arrays.fill(board, \".\".repeat(n));\\n        int[] leftrow = new int[n];\\n        int[] upperDiagonal = new int[2 * n - 1];\\n        int[] lowerDiagonal = new int[2 * n - 1];\\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n);\\n        return ans;\\n    }\\n\\n    private void solve(int col, String[] board, List<List<String>> ans, int[] lr, int[] ud, int[] ld, int n) {\\n        if (col == n) {\\n            ans.add(new ArrayList<>(Arrays.asList(board)));\\n            return;\\n        }\\n        for (int row = 0; row < n; row++) {\\n            if (lr[row] == 0 && ld[row + col] == 0 && ud[n - 1 + col - row] == 0) {\\n                char[] charArray = board[row].toCharArray();\\n                charArray[col] = \\'Q\\';\\n                board[row] = new String(charArray);\\n                lr[row] = 1;\\n                ld[row + col] = 1;\\n                ud[n - 1 + col - row] = 1;\\n                \\n                solve(col + 1, board, ans, lr, ud, ld, n);\\n                \\n                charArray[col] = \\'.\\';\\n                board[row] = new String(charArray);\\n                lr[row] = 0;\\n                ld[row + col] = 0;\\n                ud[n - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def solve(col, board, ans, lr, ud, ld, n):\\n            if col == n:\\n                ans.append([\\'\\'.join(row) for row in board])\\n                return\\n            for row in range(n):\\n                if lr[row] == 0 and ld[row - col] == 0 and ud[row + col] == 0:\\n                    board[row][col] = \\'Q\\'\\n                    lr[row] = 1\\n                    ld[row - col] = 1\\n                    ud[row + col] = 1\\n                    \\n                    solve(col + 1, board, ans, lr, ud, ld, n)\\n                    \\n                    board[row][col] = \\'.\\'\\n                    lr[row] = 0\\n                    ld[row - col] = 0\\n                    ud[row + col] = 0\\n        \\n        ans = []\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        leftrow = [0] * n\\n        upperDiagonal = [0] * (2 * n - 1)\\n        lowerDiagonal = [0] * (2 * n - 1)\\n        solve(0, board, ans, leftrow, upperDiagonal, lowerDiagonal, n)\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587894,
                "title": "striver-type-c-most-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int& n,vector<string> &tmp, vector<vector<string>> &ans,vector<bool> &c,vector<bool> &md,vector<bool> &td){\\n        if(i==n){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        string str(n,\\'.\\');\\n        for(int j = 0; j < n; j++){\\n            if((c[j]==false&&md[i-j+n]==false&&td[i+j]==false)){\\n                str[j] = \\'Q\\';\\n                c[j] = true;md[i-j+n]=true;td[i+j] = true;\\n                tmp.push_back(str);\\n                solve(i+1,n,tmp,ans,c,md,td);\\n                tmp.pop_back();\\n                str[j] = \\'.\\';\\n                c[j] = false;md[i-j+n]=false;td[i+j] = false;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> tmp;\\n        vector<bool> c(n,false),md(2*n+3,false),td(2*n+3,false);\\n        solve(0,n,tmp,ans,c,md,td);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464197,
                "title": "java-100-faster-solution-most-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n^2)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/82f18dac-b6da-495b-b355-d08d5a6bbfe5_1682703846.32556.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        // Initialize the chess board with empty cells represented by \\'.\\'\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n\\n        // Initialize lists to store the solutions\\n        List<List<String>> res = new ArrayList<>();\\n\\n        // Initialize arrays to keep track of used rows and diagonals\\n        int[] usedRows = new int[n];\\n        int[] usedLowerDiagonal = new int[2 * n - 1];\\n        int[] usedUpperDiagonal = new int[2 * n - 1];\\n\\n        // Call the recursive solve method\\n        solve(0, board, res, usedRows, usedLowerDiagonal, usedUpperDiagonal);\\n\\n        // Return the solutions\\n        return res;\\n    }\\n\\n    // Recursive function to solve the N-Queens problem\\n    public void solve(int col, char[][] board, List<List<String>> res, int[] usedRows, int[] usedLowerDiagonal, int[] usedUpperDiagonal){\\n\\n        // If all columns are filled with queens, add the solution to the list and return\\n        if(col == board.length){\\n            res.add(construct(board));\\n            return;\\n        }\\n\\n        // Try placing a queen in each row of the current column\\n        for(int row = 0; row < board.length; row++){\\n\\n            // Check if the current cell is safe for a queen\\n            \\n            if(usedRows[row] == 0 && usedLowerDiagonal[row + col] == 0 && usedUpperDiagonal[board.length - 1 + col - row] == 0){\\n\\n                // Place the queen in the current cell\\n                board[row][col] = \\'Q\\';\\n\\n                // Mark the used row and diagonals\\n                usedRows[row] = 1;\\n                usedLowerDiagonal[row + col] = 1;\\n                usedUpperDiagonal[board.length - 1 + col - row] = 1;\\n\\n                // Recursively solve for the next column\\n                solve(col + 1, board, res, usedRows, usedLowerDiagonal, usedUpperDiagonal);\\n\\n                // Remove the queen from the current cell\\n                board[row][col] = \\'.\\';\\n\\n                // Unmark the used row and diagonals\\n                usedRows[row] = 0;\\n                usedLowerDiagonal[row + col] = 0;\\n                usedUpperDiagonal[board.length - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n\\n    // Helper function to construct a list of strings representing the chess board\\n    public List<String> construct(char board[][]){\\n\\n        List<String> res = new LinkedList<>();\\n\\n        for(int i = 0; i < board.length; i++){\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        // Initialize the chess board with empty cells represented by \\'.\\'\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n\\n        // Initialize lists to store the solutions\\n        List<List<String>> res = new ArrayList<>();\\n\\n        // Initialize arrays to keep track of used rows and diagonals\\n        int[] usedRows = new int[n];\\n        int[] usedLowerDiagonal = new int[2 * n - 1];\\n        int[] usedUpperDiagonal = new int[2 * n - 1];\\n\\n        // Call the recursive solve method\\n        solve(0, board, res, usedRows, usedLowerDiagonal, usedUpperDiagonal);\\n\\n        // Return the solutions\\n        return res;\\n    }\\n\\n    // Recursive function to solve the N-Queens problem\\n    public void solve(int col, char[][] board, List<List<String>> res, int[] usedRows, int[] usedLowerDiagonal, int[] usedUpperDiagonal){\\n\\n        // If all columns are filled with queens, add the solution to the list and return\\n        if(col == board.length){\\n            res.add(construct(board));\\n            return;\\n        }\\n\\n        // Try placing a queen in each row of the current column\\n        for(int row = 0; row < board.length; row++){\\n\\n            // Check if the current cell is safe for a queen\\n            \\n            if(usedRows[row] == 0 && usedLowerDiagonal[row + col] == 0 && usedUpperDiagonal[board.length - 1 + col - row] == 0){\\n\\n                // Place the queen in the current cell\\n                board[row][col] = \\'Q\\';\\n\\n                // Mark the used row and diagonals\\n                usedRows[row] = 1;\\n                usedLowerDiagonal[row + col] = 1;\\n                usedUpperDiagonal[board.length - 1 + col - row] = 1;\\n\\n                // Recursively solve for the next column\\n                solve(col + 1, board, res, usedRows, usedLowerDiagonal, usedUpperDiagonal);\\n\\n                // Remove the queen from the current cell\\n                board[row][col] = \\'.\\';\\n\\n                // Unmark the used row and diagonals\\n                usedRows[row] = 0;\\n                usedLowerDiagonal[row + col] = 0;\\n                usedUpperDiagonal[board.length - 1 + col - row] = 0;\\n            }\\n        }\\n    }\\n\\n    // Helper function to construct a list of strings representing the chess board\\n    public List<String> construct(char board[][]){\\n\\n        List<String> res = new LinkedList<>();\\n\\n        for(int i = 0; i < board.length; i++){\\n            String s = new String(board[i]);\\n            res.add(s);\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410454,
                "title": "solution-python-easy-backtracking",
                "content": "```class Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        arr = []\\n        result = []\\n        def helper(row, placed):\\n            if row == n:\\n                result.append(arr.copy())\\n                return\\n            \\n            for col in range(0, n):\\n                breaked = False\\n                for colum, rown in placed:\\n                        if colum == col or abs(rown - row) == abs(colum - col):\\n                            breaked = True\\n                            break\\n                if not breaked:\\n                    placed.append((col, row))\\n                    string = \".\" * (col) + \"Q\" + \".\" * (n - col - 1)\\n                    arr.append(string)\\n                    helper(row + 1, placed)\\n                    placed.pop()\\n                    arr.pop()\\n            \\n        helper(0, [])\\n        return result```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```class Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        arr = []\\n        result = []\\n        def helper(row, placed):\\n            if row == n:\\n                result.append(arr.copy())\\n                return\\n            \\n            for col in range(0, n):\\n                breaked = False\\n                for colum, rown in placed:\\n                        if colum == col or abs(rown - row) == abs(colum - col):\\n                            breaked = True\\n                            break\\n                if not breaked:\\n                    placed.append((col, row))\\n                    string = \".\" * (col) + \"Q\" + \".\" * (n - col - 1)\\n                    arr.append(string)\\n                    helper(row + 1, placed)\\n                    placed.pop()\\n                    arr.pop()\\n            \\n        helper(0, [])\\n        return result```",
                "codeTag": "Java"
            },
            {
                "id": 3366025,
                "title": "easy-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // we don\\'t need to check up \\u2191 before placing the queen, because in a col, we will fill \\n    // a queen only once\\n    // we need to check in only 3 directions out of 8 \\u2196 \\u2191 \\u2197 \\u2190 \\xB7 \\u2192 \\u2199 \\u2193 \\u2198\\n    // \\u2196 Q \\n    // \\u2190 Q\\n    // \\u2199 Q\\n    bool isSafe(int row, int col, vector<string> board, int n){\\n        // check upper diagonal\\n        int duprow = row;\\n        int dupcol =col;\\n         \\n        while(row>=0 && col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            row--;\\n            col--;\\n        }\\n        col=dupcol;\\n        row=duprow;\\n        while(col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            col--;\\n        }\\n        row = duprow;\\n        col = dupcol;\\n        while(row<n && col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n    void solve(int col, vector<string>& board, vector<vector<string>>& ans, int n)\\n    {\\n        if(col==n){     // the last col you fill will be of the n-1 index, when you reach n, it is over\\n            ans.push_back(board);\\n            return;\\n        }\\n        // for every row check if it is safe to place a Queen there\\n        for(int row=0; row<n; row++)\\n        {\\n            if(isSafe(row, col, board, n)){\\n                board[row][col]=\\'Q\\';     // place a queen\\n                solve(col+1, board, ans, n);        // call recursion for the next column\\n                board[row][col]=\\'.\\';        // backtrack, you remove the queen, because int\\n                            // the next step of the for loop, you will try for the next row\\n            }\\n        }\\n    }\\n    // return a nxn chess board in a vector of vector of strings\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');       // n sized strings of \\'.\\'\\n        for(int i=0; i<n; i++)      // putting the strings into the vector of vector of strings\\n        {\\n            board[i]=s;\\n        }\\n        solve(0, board, ans, n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // we don\\'t need to check up \\u2191 before placing the queen, because in a col, we will fill \\n    // a queen only once\\n    // we need to check in only 3 directions out of 8 \\u2196 \\u2191 \\u2197 \\u2190 \\xB7 \\u2192 \\u2199 \\u2193 \\u2198\\n    // \\u2196 Q \\n    // \\u2190 Q\\n    // \\u2199 Q\\n    bool isSafe(int row, int col, vector<string> board, int n){\\n        // check upper diagonal\\n        int duprow = row;\\n        int dupcol =col;\\n         \\n        while(row>=0 && col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            row--;\\n            col--;\\n        }\\n        col=dupcol;\\n        row=duprow;\\n        while(col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            col--;\\n        }\\n        row = duprow;\\n        col = dupcol;\\n        while(row<n && col>=0){\\n            if(board[row][col] == \\'Q\\')  return false;\\n            row++;\\n            col--;\\n        }\\n        return true;\\n    }\\n    void solve(int col, vector<string>& board, vector<vector<string>>& ans, int n)\\n    {\\n        if(col==n){     // the last col you fill will be of the n-1 index, when you reach n, it is over\\n            ans.push_back(board);\\n            return;\\n        }\\n        // for every row check if it is safe to place a Queen there\\n        for(int row=0; row<n; row++)\\n        {\\n            if(isSafe(row, col, board, n)){\\n                board[row][col]=\\'Q\\';     // place a queen\\n                solve(col+1, board, ans, n);        // call recursion for the next column\\n                board[row][col]=\\'.\\';        // backtrack, you remove the queen, because int\\n                            // the next step of the for loop, you will try for the next row\\n            }\\n        }\\n    }\\n    // return a nxn chess board in a vector of vector of strings\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');       // n sized strings of \\'.\\'\\n        for(int i=0; i<n; i++)      // putting the strings into the vector of vector of strings\\n        {\\n            board[i]=s;\\n        }\\n        solve(0, board, ans, n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350336,
                "title": "c-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int row,int col,vector<string> arr)\\n    {\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[row][i]!=\\'.\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i][col]!=\\'.\\'){\\n                return false;\\n            }\\n        }\\n\\n        int i=row;\\n        int j=col;\\n        while(i>=0 && j>=0)\\n        {\\n            if(arr[i][j]!=\\'.\\'){\\n                return false;\\n            }\\n            i--;\\n            j--;\\n        }\\n        i=row;\\n        j=col;\\n        while(i>=0 && j<n)\\n        {\\n            if(arr[i][j]!=\\'.\\'){\\n                return false;\\n            }\\n            i--;\\n            j++;\\n        }\\n\\n        return true;\\n    }\\n    void dfs(int index,int count,int n,vector<string> arr,vector<vector<string>> &ans)\\n    {\\n        if(count==n)\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        if(index>=n)\\n        {\\n            return;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(valid(index,i,arr))\\n            {\\n                arr[index][i] = \\'Q\\';\\n                dfs(index+1,count+1,n,arr,ans);\\n                arr[index][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> arr;\\n        string curr;\\n        vector<vector<string>> ans;\\n        for(int i=0;i<n;i++){\\n            curr+=\\'.\\';\\n        }\\n        for(int i=0;i<n;i++){\\n            arr.push_back(curr);\\n        }\\n\\n        dfs(0,0,n,arr,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int row,int col,vector<string> arr)\\n    {\\n        int n = arr.size();\\n        for(int i=0;i<n;i++){\\n            if(arr[row][i]!=\\'.\\'){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i][col]!=\\'.\\'){\\n                return false;\\n            }\\n        }\\n\\n        int i=row;\\n        int j=col;\\n        while(i>=0 && j>=0)\\n        {\\n            if(arr[i][j]!=\\'.\\'){\\n                return false;\\n            }\\n            i--;\\n            j--;\\n        }\\n        i=row;\\n        j=col;\\n        while(i>=0 && j<n)\\n        {\\n            if(arr[i][j]!=\\'.\\'){\\n                return false;\\n            }\\n            i--;\\n            j++;\\n        }\\n\\n        return true;\\n    }\\n    void dfs(int index,int count,int n,vector<string> arr,vector<vector<string>> &ans)\\n    {\\n        if(count==n)\\n        {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        if(index>=n)\\n        {\\n            return;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(valid(index,i,arr))\\n            {\\n                arr[index][i] = \\'Q\\';\\n                dfs(index+1,count+1,n,arr,ans);\\n                arr[index][i] = \\'.\\';\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string> arr;\\n        string curr;\\n        vector<vector<string>> ans;\\n        for(int i=0;i<n;i++){\\n            curr+=\\'.\\';\\n        }\\n        for(int i=0;i<n;i++){\\n            arr.push_back(curr);\\n        }\\n\\n        dfs(0,0,n,arr,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306160,
                "title": "1ms-100-faster-java-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][]board=new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        List<List<String>>ans=new ArrayList<>();\\n        \\n        int leftrow[]=new int[n];\\n        int upperDiagonal[]=new int[2*n-1];\\n        int lowerDiagonal[]=new int[2*n-1];\\n\\n        solve(0,ans,board,leftrow,upperDiagonal,lowerDiagonal);\\n        return ans;\\n    }\\n\\n    public void solve(int col,List<List<String>>ans,char[][]board,int leftrow[],int upperDiagonal[],int lowerDiagonal[]){\\n        if(col==board.length){\\n            ans.add(construct(board));//adding the constructed list in a list of list.\\n            return;\\n        }\\n\\n        for(int row=0;row<board.length;row++){\\n            if(leftrow[row]==0 && upperDiagonal[board.length-1+col-row]==0 && lowerDiagonal[row+col]==0){\\n                board[row][col]=\\'Q\\';\\n                leftrow[row]=1;\\n                upperDiagonal[board.length-1+col-row]=1;\\n                lowerDiagonal[row+col]=1;\\n                solve(col+1,ans,board,leftrow,upperDiagonal,lowerDiagonal);//recursion call\\n\\n                //for backtrack\\n                board[row][col]=\\'.\\';\\n                leftrow[row]=0;\\n                upperDiagonal[board.length-1+col-row]=0;\\n                lowerDiagonal[row+col]=0;\\n            }\\n        }\\n    }\\n\\n    //construct the string from every row and add them in a list;\\n    public List<String> construct(char [][] board){\\n        List<String>cur=new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String str=new String(board[i]);\\n            cur.add(str);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][]board=new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        List<List<String>>ans=new ArrayList<>();\\n        \\n        int leftrow[]=new int[n];\\n        int upperDiagonal[]=new int[2*n-1];\\n        int lowerDiagonal[]=new int[2*n-1];\\n\\n        solve(0,ans,board,leftrow,upperDiagonal,lowerDiagonal);\\n        return ans;\\n    }\\n\\n    public void solve(int col,List<List<String>>ans,char[][]board,int leftrow[],int upperDiagonal[],int lowerDiagonal[]){\\n        if(col==board.length){\\n            ans.add(construct(board));//adding the constructed list in a list of list.\\n            return;\\n        }\\n\\n        for(int row=0;row<board.length;row++){\\n            if(leftrow[row]==0 && upperDiagonal[board.length-1+col-row]==0 && lowerDiagonal[row+col]==0){\\n                board[row][col]=\\'Q\\';\\n                leftrow[row]=1;\\n                upperDiagonal[board.length-1+col-row]=1;\\n                lowerDiagonal[row+col]=1;\\n                solve(col+1,ans,board,leftrow,upperDiagonal,lowerDiagonal);//recursion call\\n\\n                //for backtrack\\n                board[row][col]=\\'.\\';\\n                leftrow[row]=0;\\n                upperDiagonal[board.length-1+col-row]=0;\\n                lowerDiagonal[row+col]=0;\\n            }\\n        }\\n    }\\n\\n    //construct the string from every row and add them in a list;\\n    public List<String> construct(char [][] board){\\n        List<String>cur=new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String str=new String(board[i]);\\n            cur.add(str);\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269638,
                "title": "easy-understanding-python-solution-beats-97-of-other-solutions",
                "content": "Please Upvote if you like it.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def b(a):\\n            if a == n:\\n                ans.append([\"\".join(a) for a in c])\\n                return\\n            for i in range(n):\\n                if not e[i] and not d[a+i] and not rev[a-i]:\\n                    c[a][i] = \\'Q\\'\\n                    e[i], d[a+i], rev[a-i] = True, True, True\\n                    b(a+1)\\n                    c[a][i] = \\'.\\'\\n                    e[i], d[a+i], rev[a-i] = False, False, False\\n        \\n        c= [[\\'.\\' for j in range(n)] for j in range(n)]\\n        e, d, rev = [False]*n, [False]*(2*n), [False]*(2*n-1)\\n        ans = []\\n        b(0)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Please Upvote if you like it.\\n\\nPython Code:\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def b(a):\\n            if a == n:\\n                ans.append([\"\".join(a) for a in c])\\n                return\\n            for i in range(n):\\n                if not e[i] and not d[a+i] and not rev[a-i]:\\n                    c[a][i] = \\'Q\\'\\n                    e[i], d[a+i], rev[a-i] = True, True, True\\n                    b(a+1)\\n                    c[a][i] = \\'.\\'\\n                    e[i], d[a+i], rev[a-i] = False, False, False\\n        \\n        c= [[\\'.\\' for j in range(n)] for j in range(n)]\\n        e, d, rev = [False]*n, [False]*(2*n), [False]*(2*n-1)\\n        ans = []\\n        b(0)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3176302,
                "title": "51-n-queens-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis is a python implementation of the backtracking algorithm to solve the N-Queens problem. The idea is to generate all possible combinations of queen placement and validate the solution at the end.\\n\\nThe function solveNQueens takes an integer n as an input which is the number of queens to be placed on the chessboard.\\n\\nThe function dfs takes three arguments:\\n\\n- queens is a list representing the column position of each row where a queen is placed.\\n- dif is a list representing the diagonal that runs from top-left to bottom-right.\\n- sum is a list representing the diagonal that runs from top-right to bottom-left.\\n\\nThe function dfs does the following:\\n\\n1. If the length of queens is equal to n, it means all queens are placed on the chessboard and the placement is a valid solution. So, the queens list is appended to the result list.\\n2. If the length of queens is not equal to n, it means there are still some queens left to be placed on the chessboard. So, the function generates all possible combinations of queen placement in the current row.\\n3. For each possible placement in the current row, the function checks if the column, the top-left to bottom-right diagonal, and the top-right to bottom-left diagonal are not occupied by any other queen. If all three conditions are met, the function places a queen in that position and continues to the next row by calling the dfs function recursively.\\n\\nAfter the backtracking, the function returns the result in the desired format. The solution is represented by a list of strings where each string represents a row of the chessboard, and \\'Q\\' represents a queen, and \\'.\\' represents an empty cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                result.append(queens)\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        result = []\\n        dfs([],[],[])\\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        def dfs(queens, dif, sum):\\n            p = len(queens)\\n            if p == n:\\n                result.append(queens)\\n                return None\\n            for q in range(n):\\n                if q not in queens and p-q not in dif and p+q not in sum:\\n                    dfs(queens+[q], dif+[p-q], sum+[p+q])\\n        result = []\\n        dfs([],[],[])\\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954156,
                "title": "c-2ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nbool issafe(int r,int c,vector<string> &s,int n){\\n    int i=r;\\n    int j=c;\\n    //upperdiagonal\\n    while(r>=0 && c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        r--;\\n        c--;\\n    }\\n    //left\\n    r=i;\\n    c=j;\\n    while(c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        c--;\\n    }\\n    //lowerdiagonal\\n    r=i;\\n    c=j;\\n    while(r<n && c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        r++;\\n        c--;\\n    }\\n    return true;\\n\\n}\\n\\n\\n\\n\\nvoid helper(int c,vector<string> &s,vector<vector<string>> &v,int n){\\n    if(c==n){\\n        v.push_back(s);\\n        return;\\n    }\\n    for(int r=0;r<n;++r){\\n        if(issafe(r,c,s,n)){\\n            s[r][c]=\\'Q\\';\\n            helper(c+1,s,v,n);\\n            //backtracking step after that function returns\\n            s[r][c]=\\'.\\';\\n        }\\n    }\\n}\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> v;\\n        vector<string> s(n);\\n        string s1(n,\\'.\\');\\n        for(int i=0;i<n;++i){\\n            s[i]=s1;\\n        }\\n        helper(0,s,v,n);\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nbool issafe(int r,int c,vector<string> &s,int n){\\n    int i=r;\\n    int j=c;\\n    //upperdiagonal\\n    while(r>=0 && c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        r--;\\n        c--;\\n    }\\n    //left\\n    r=i;\\n    c=j;\\n    while(c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        c--;\\n    }\\n    //lowerdiagonal\\n    r=i;\\n    c=j;\\n    while(r<n && c>=0){\\n        if(s[r][c]==\\'Q\\'){\\n            return false;\\n        }\\n        r++;\\n        c--;\\n    }\\n    return true;\\n\\n}\\n\\n\\n\\n\\nvoid helper(int c,vector<string> &s,vector<vector<string>> &v,int n){\\n    if(c==n){\\n        v.push_back(s);\\n        return;\\n    }\\n    for(int r=0;r<n;++r){\\n        if(issafe(r,c,s,n)){\\n            s[r][c]=\\'Q\\';\\n            helper(c+1,s,v,n);\\n            //backtracking step after that function returns\\n            s[r][c]=\\'.\\';\\n        }\\n    }\\n}\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> v;\\n        vector<string> s(n);\\n        string s1(n,\\'.\\');\\n        for(int i=0;i<n;++i){\\n            s[i]=s1;\\n        }\\n        helper(0,s,v,n);\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818336,
                "title": "java-explained-step-by-step-using-comments",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] board=new boolean[n][n];\\n        List<List<String>> output = new ArrayList<>();\\n        NQueens(board,0,output);\\n        return output;\\n    }\\n    void NQueens(boolean[][] board,int row,List<List<String>> res)\\n\\t{\\n\\t    //if row exceeds the board range we will get an answer\\n\\t    if(row==board.length)\\n\\t    {\\n            ArrayList<String> x=adder(board);\\n            res.add(x);\\n            return;\\n\\t    }\\n\\t    for(int col=0;col<board.length;col++)\\n\\t    {\\n\\t        if(isSafe(board,row,col))//check if the current pos is ok to place the queen without attacking other queens\\n\\t        {\\n\\t            board[row][col]=true; //marking the pos as true if the queen is placed\\n\\t            NQueens(board,row+1,res);\\n\\t            board[row][col]=false; //this is where backtracking happens we comeback when we are no longer able to move forward\\n\\t        }\\n\\t    }\\n\\t    return;\\n\\t    \\n\\t}\\n    boolean isSafe(boolean[][] board,int row,int col)\\n\\t{\\n\\t    //checking the vertical part\\n\\t    for(int i=0;i<row;i++)\\n\\t    {\\n\\t        if(board[i][col])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //checking the left diagonal\\n\\t    int maxLeft=Math.min(row,col);\\n\\t    for(int i=1;i<=maxLeft;i++)\\n\\t    {\\n\\t        if(board[row-i][col-i])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //checking the right diagonal\\n\\t    int maxRight=Math.min(row,board.length-col-1);\\n\\t    for(int i=1;i<=maxRight;i++)\\n\\t    {\\n\\t        if(board[row-i][col+i])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //we donot check the lower part cuz we are filling row by row, so by the time we fill a row the below rows will be empty\\n\\t    return true;\\n\\t}\\n    ArrayList<String> adder(boolean[][] board)\\n\\t{\\n        ArrayList<String> inner=new ArrayList<>();\\n\\t    for(boolean[] row:board)\\n\\t    {\\n            String s=\"\";\\n\\t        for(boolean ele:row)\\n\\t        {\\n\\t            if(ele)\\n\\t            {\\n\\t                s+=\"Q\";\\n\\t            }\\n\\t            else\\n\\t            {\\n\\t                s+=\".\";\\n\\t            }\\n\\t        }\\n\\t        inner.add(s);\\n\\t    }\\n        return inner;\\n\\t}\\n\\n\\n\\n}\\n```\\n\\n*Please upvote if it helps*",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[][] board=new boolean[n][n];\\n        List<List<String>> output = new ArrayList<>();\\n        NQueens(board,0,output);\\n        return output;\\n    }\\n    void NQueens(boolean[][] board,int row,List<List<String>> res)\\n\\t{\\n\\t    //if row exceeds the board range we will get an answer\\n\\t    if(row==board.length)\\n\\t    {\\n            ArrayList<String> x=adder(board);\\n            res.add(x);\\n            return;\\n\\t    }\\n\\t    for(int col=0;col<board.length;col++)\\n\\t    {\\n\\t        if(isSafe(board,row,col))//check if the current pos is ok to place the queen without attacking other queens\\n\\t        {\\n\\t            board[row][col]=true; //marking the pos as true if the queen is placed\\n\\t            NQueens(board,row+1,res);\\n\\t            board[row][col]=false; //this is where backtracking happens we comeback when we are no longer able to move forward\\n\\t        }\\n\\t    }\\n\\t    return;\\n\\t    \\n\\t}\\n    boolean isSafe(boolean[][] board,int row,int col)\\n\\t{\\n\\t    //checking the vertical part\\n\\t    for(int i=0;i<row;i++)\\n\\t    {\\n\\t        if(board[i][col])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //checking the left diagonal\\n\\t    int maxLeft=Math.min(row,col);\\n\\t    for(int i=1;i<=maxLeft;i++)\\n\\t    {\\n\\t        if(board[row-i][col-i])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //checking the right diagonal\\n\\t    int maxRight=Math.min(row,board.length-col-1);\\n\\t    for(int i=1;i<=maxRight;i++)\\n\\t    {\\n\\t        if(board[row-i][col+i])\\n\\t        {\\n\\t            return false;\\n\\t        }\\n\\t    }\\n\\t    //we donot check the lower part cuz we are filling row by row, so by the time we fill a row the below rows will be empty\\n\\t    return true;\\n\\t}\\n    ArrayList<String> adder(boolean[][] board)\\n\\t{\\n        ArrayList<String> inner=new ArrayList<>();\\n\\t    for(boolean[] row:board)\\n\\t    {\\n            String s=\"\";\\n\\t        for(boolean ele:row)\\n\\t        {\\n\\t            if(ele)\\n\\t            {\\n\\t                s+=\"Q\";\\n\\t            }\\n\\t            else\\n\\t            {\\n\\t                s+=\".\";\\n\\t            }\\n\\t        }\\n\\t        inner.add(s);\\n\\t    }\\n        return inner;\\n\\t}\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798711,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    vector<vector<string>> solveNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    int nl;\\n\\n    bool check(vector<string> &v, int row, int col) {\\n        /* Check this row on left side */\\n        for(int i=0; i<col; i++) if(v[row][i] == \\'Q\\') return false;\\n        /* Check upper diagonal on left side */\\n        for(int i=row, j=col; i>=0 and j>=0; i--, j--) if(v[i][j] == \\'Q\\') return false;\\n        /* Check lower diagonal on left side */\\n        for(int i=row, j=col; j>=0 and i<nl; i++, j--) if(v[i][j] == \\'Q\\') return false;\\n\\n        return true;\\n    }\\n\\n    void solve(vector<string> &v, int col) {\\n        if(col >= nl) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=0; i<nl; i++) {\\n            if(check(v, i, col)) {\\n                v[i][col] = \\'Q\\';\\n                solve(v, col+1);\\n                v[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    vector<vector<string>> solveNQueens(int n) {\\n        nl = n;\\n        vector<string> v(nl, string(nl, \\'.\\'));\\n        solve(v, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720438,
                "title": "java-easy-code-recursion-backtracking",
                "content": "Solved using a Boolean Matrix of N size. In recusive calls it will check if putting the Queen is Safe if not Backtrack.\\n\\n\\n\\n   \\n    class Solution {\\n      public List<List<String>> solveNQueens(int n) {\\n        boolean[][] board = new boolean[n][n];\\n        List<List<String>> answer = new ArrayList<>();\\n        queens(board,0,answer);\\n        return answer;\\n    }\\n    void queens(boolean[][] board,int row,List<List<String>> answer){\\n        \\n        if(row==board.length){\\n            List<String> res = insert(board);\\n            answer.add(res);\\n            return;\\n        }\\n        \\n        // Placing Queens and Checking for every row and column\\n        for(int col=0;col<board.length;col++){\\n            //place queen if Safe\\n            if(isSafe(board,row,col)){\\n                board[row][col] = true;\\n                queens(board,row+1,answer); //Recursive call\\n                board[row][col] = false;    // Backtrack\\n            }\\n        }\\n    }\\n    \\n    boolean isSafe(boolean[][] board, int row ,int col){\\n        \\n        // Vertical row\\n        for(int i=0;i<row;i++){\\n            if(board[i][col])\\n                return false;\\n        }\\n        \\n        // Left diagonal\\n        int maxLeft = Math.min(row,col);\\n        for(int i=1;i<=maxLeft;i++){\\n            if(board[row-i][col-i]){\\n                return false;\\n            }\\n        }\\n        \\n        // Right diagonal\\n        int maxRight = Math.min(row,board.length-col-1);\\n        for(int i=1;i<=maxRight;i++){\\n            if(board[row-i][col+i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n     \\n      List<String> insert(boolean[][] board){\\n          \\n        List<String> ans = new ArrayList<>();\\n        for(boolean[] row: board){\\n            String S = \"\";\\n            for(boolean element:row){\\n                if(element){\\n                    S += \"Q\";\\n                }\\n                else\\n                    S += \".\";\\n            }\\n            ans.add(S);\\n        }\\n          return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n      public List<List<String>> solveNQueens(int n) {\\n        boolean[][] board = new boolean[n][n];\\n        List<List<String>> answer = new ArrayList<>();\\n        queens(board,0,answer);\\n        return answer;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2640273,
                "title": "c-n-queen-with-explanation",
                "content": "* put **one queen in each column** and move to the next col \\n* try all possibility i.e. try to **put \\'Q\\' at every position (every row)** in each col \\n* **check** if the curr position **is valid** if valid then fill it with \\'Q\\' but this may provide us one soln so to check for other soln backtrack it and put grid[row][col]=\\'.\\'\\n* if we are **able to fill the \\'Q\\' in a column then move to the next col** i.e. call dfs for next col\\n* Since we are placing **only one queen in each column** so **no need to check the validity for curr col**\\n* Also we **haven\\'t placed yet any queen in right** side so **no need to check** for **upper right and lower right digonal**\\n* is valid function will check for left , upper left digonal ,upper right digonal\\n\\n<img src=\"https://assets.leetcode.com/uploads/2020/11/13/queens.jpg\" alt=\"drawing\" width=\"500\">\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int row,int col,vector<string>&grid,int n)\\n    {\\n        // left check\\n        for(int i=0;i<col;i++)\\n        {\\n            if(grid[row][i]==\\'Q\\') return false;\\n        }\\n        // upper left check \\n        for(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n        {\\n            if(grid[i][j]==\\'Q\\') return false;\\n        }\\n        // lower left check\\n        for(int i=row,j=col;i<n && j>=0;i++,j--)\\n        {\\n            if(grid[i][j]==\\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n    void dfs(int col,vector<vector<string>>&ans,vector<string>&grid,int n)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(grid);\\n            return;\\n        }\\n        for(int row=0;row<n;row++)\\n        {\\n            if(isvalid(row,col,grid,n))\\n            {\\n                grid[row][col]=\\'Q\\';\\n                dfs(col+1,ans,grid,n);\\n                grid[row][col]=\\'.\\'; \\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string>grid(n,string(n,\\'.\\'));\\n        vector<vector<string>>ans;\\n        int col=0;\\n        dfs(col,ans,grid,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int row,int col,vector<string>&grid,int n)\\n    {\\n        // left check\\n        for(int i=0;i<col;i++)\\n        {\\n            if(grid[row][i]==\\'Q\\') return false;\\n        }\\n        // upper left check \\n        for(int i=row,j=col;i>=0 && j>=0;i--,j--)\\n        {\\n            if(grid[i][j]==\\'Q\\') return false;\\n        }\\n        // lower left check\\n        for(int i=row,j=col;i<n && j>=0;i++,j--)\\n        {\\n            if(grid[i][j]==\\'Q\\') return false;\\n        }\\n        return true;\\n    }\\n    void dfs(int col,vector<vector<string>>&ans,vector<string>&grid,int n)\\n    {\\n        if(col==n)\\n        {\\n            ans.push_back(grid);\\n            return;\\n        }\\n        for(int row=0;row<n;row++)\\n        {\\n            if(isvalid(row,col,grid,n))\\n            {\\n                grid[row][col]=\\'Q\\';\\n                dfs(col+1,ans,grid,n);\\n                grid[row][col]=\\'.\\'; \\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<string>grid(n,string(n,\\'.\\'));\\n        vector<vector<string>>ans;\\n        int col=0;\\n        dfs(col,ans,grid,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502561,
                "title": "javascript-solution-clean-and-well-explained",
                "content": "**`\\tPlease upvote if it helped`**\\n\\t\\n\\tvar solveNQueens = function (n) {\\n\\t\\t//creating an empty board(2d matrix) without referential equality\\n\\t\\tconst board = Array(n).fill().map((item) => Array(n).fill(\".\"));\\n  \\n  \\n    //recursive funtion to find all the combinations of queens for each row and column\\n    const recursive = (board, row) => {\\n        \\n      if (row === n) {\\n          //if a queen is set in all n rows\\n      let strArray=[]\\n      \\n      //creating an array of strings from the board to match sample output\\n       for(let i=0;i<n;i++){\\n         let tempStr=\"\"\\n         for(let j=0;j<n;j++){\\n           tempStr+=board[i][j]\\n         }\\n         strArray.push(tempStr)\\n       }\\n        return [strArray];\\n      }\\n        \\n      let result=[]\\n      //i will represent all the columns of the row in the current recursive call\\n      for (let i = 0; i < n; i++) {\\n          //checking wether the current cell is safe to put a queen or not\\n        if (isSafe(row, i)) {\\n            \\n          board[row][i] = \"Q\";\\n          let temp=recursive(board, row + 1);\\n            //if the above call will not transition into a valid combination then\\n            //empty array will be returned and nothing will be added to the current recursive call\\'s result\\n          result.push(...temp)     //array of string will be added to current recursive call if a valid combination is returned\\n          board[row][i] = \".\";     //will backtrack or clear the marked queens positions once the combination is found or even not found\\n            \\n        }\\n        \\n      }\\n  \\n     \\n      return result;\\n    };\\n  \\n    //function to check whether the current position is safe to put a queen or not\\n    const isSafe = (row, col) => {\\n\\n      //checking vertically\\n      for (let i = 0; i < n; i++) {\\n          if(board[i][col]===\"Q\"){\\n              return false;\\n          }     \\n      }\\n        \\n      //checking horizontally\\n      for (let i = 0; i < n; i++) {\\n          if(board[row][i]===\"Q\"){\\n              return false;\\n          }     \\n      }\\n        \\n      let steps;\\n        \\n      //top left diagonal\\n      steps=Math.min(row,col)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row-i][col-i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //bottom left diagonal\\n      steps=Math.min(n-row-1,col)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row+i][col-i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //bottom right diagonal\\n      steps=Math.min(n-row-1,n-col-1)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row+i][col+i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //top right diagonal\\n      steps=Math.min(row,n-col-1)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row-i][col+i]===\"Q\"){\\n          return false\\n        }\\n      }\\n      \\n      return true;\\n  \\n    };\\n  \\n    return recursive(board, 0);\\n\\t  };\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**`\\tPlease upvote if it helped`**\\n\\t\\n\\tvar solveNQueens = function (n) {\\n\\t\\t//creating an empty board(2d matrix) without referential equality\\n\\t\\tconst board = Array(n).fill().map((item) => Array(n).fill(\".\"));\\n  \\n  \\n    //recursive funtion to find all the combinations of queens for each row and column\\n    const recursive = (board, row) => {\\n        \\n      if (row === n) {\\n          //if a queen is set in all n rows\\n      let strArray=[]\\n      \\n      //creating an array of strings from the board to match sample output\\n       for(let i=0;i<n;i++){\\n         let tempStr=\"\"\\n         for(let j=0;j<n;j++){\\n           tempStr+=board[i][j]\\n         }\\n         strArray.push(tempStr)\\n       }\\n        return [strArray];\\n      }\\n        \\n      let result=[]\\n      //i will represent all the columns of the row in the current recursive call\\n      for (let i = 0; i < n; i++) {\\n          //checking wether the current cell is safe to put a queen or not\\n        if (isSafe(row, i)) {\\n            \\n          board[row][i] = \"Q\";\\n          let temp=recursive(board, row + 1);\\n            //if the above call will not transition into a valid combination then\\n            //empty array will be returned and nothing will be added to the current recursive call\\'s result\\n          result.push(...temp)     //array of string will be added to current recursive call if a valid combination is returned\\n          board[row][i] = \".\";     //will backtrack or clear the marked queens positions once the combination is found or even not found\\n            \\n        }\\n        \\n      }\\n  \\n     \\n      return result;\\n    };\\n  \\n    //function to check whether the current position is safe to put a queen or not\\n    const isSafe = (row, col) => {\\n\\n      //checking vertically\\n      for (let i = 0; i < n; i++) {\\n          if(board[i][col]===\"Q\"){\\n              return false;\\n          }     \\n      }\\n        \\n      //checking horizontally\\n      for (let i = 0; i < n; i++) {\\n          if(board[row][i]===\"Q\"){\\n              return false;\\n          }     \\n      }\\n        \\n      let steps;\\n        \\n      //top left diagonal\\n      steps=Math.min(row,col)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row-i][col-i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //bottom left diagonal\\n      steps=Math.min(n-row-1,col)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row+i][col-i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //bottom right diagonal\\n      steps=Math.min(n-row-1,n-col-1)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row+i][col+i]===\"Q\"){\\n          return false\\n        }\\n      }\\n\\n      //top right diagonal\\n      steps=Math.min(row,n-col-1)\\n      for(let i=1;i<=steps;i++){\\n        if(board[row-i][col+i]===\"Q\"){\\n          return false\\n        }\\n      }\\n      \\n      return true;\\n  \\n    };\\n  \\n    return recursive(board, 0);\\n\\t  };\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2450517,
                "title": "python-backtrack-with-three-sets",
                "content": "**Solution**:\\nSolve this problem using backtracking. In order to maintain invalid cells, we will use 3 sets: column (col), positive diagonal (row-col), and negative diagonal (row+col). Iterate through every row and try to place a queen at an available column. Once, we are able to reach nth row, we have found a solution. Save such solution before backtracking. \\n\\n**Complexity**:\\n    Time: O(n!)\\n    Space: O(n!)\\n\\t\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> list[list[str]]:\\n\\n        # Initialize a board of all \".\"\\n        board = [[\".\" for _ in range(n)] for _ in range(n)]\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Initialize the three invalid sets\\n        cols, posDiag, negDiag = set(), set(), set()\\n\\n        # Perform backtracking\\n        def backtrack(row):\\n\\n            # Once we reached nth row, we have found a solution\\n            if row == n:\\n\\n                # Add such board to the result\\n                res.append([\"\".join(r) for r in board])\\n                return\\n\\n            # Iterate through all columns at the current row\\n            for col in range(n):\\n\\n                # If the current column isn\\'t in any of the three invalid set\\n                if (\\n                    col not in cols\\n                    and (row - col) not in posDiag\\n                    and (row + col) not in negDiag\\n                ):\\n\\n                    # Add the current column to the three sets\\n                    cols.add(col)\\n                    posDiag.add(row - col)\\n                    negDiag.add(row + col)\\n\\n                    # Place a queen\\n                    board[row][col] = \"Q\"\\n\\n                    # Go to the next row\\n                    backtrack(row + 1)\\n\\n                    # Once we come back\\n                    # Remove the current column from the three sets before we are going to the next column\\n                    cols.remove(col)\\n                    posDiag.remove(row - col)\\n                    negDiag.remove(row + col)\\n\\n                    # Remove the queen\\n                    board[row][col] = \".\"\\n\\n        backtrack(0)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> list[list[str]]:\\n\\n        # Initialize a board of all \".\"\\n        board = [[\".\" for _ in range(n)] for _ in range(n)]\\n\\n        # Initialize the result\\n        res = []\\n\\n        # Initialize the three invalid sets\\n        cols, posDiag, negDiag = set(), set(), set()\\n\\n        # Perform backtracking\\n        def backtrack(row):\\n\\n            # Once we reached nth row, we have found a solution\\n            if row == n:\\n\\n                # Add such board to the result\\n                res.append([\"\".join(r) for r in board])\\n                return\\n\\n            # Iterate through all columns at the current row\\n            for col in range(n):\\n\\n                # If the current column isn\\'t in any of the three invalid set\\n                if (\\n                    col not in cols\\n                    and (row - col) not in posDiag\\n                    and (row + col) not in negDiag\\n                ):\\n\\n                    # Add the current column to the three sets\\n                    cols.add(col)\\n                    posDiag.add(row - col)\\n                    negDiag.add(row + col)\\n\\n                    # Place a queen\\n                    board[row][col] = \"Q\"\\n\\n                    # Go to the next row\\n                    backtrack(row + 1)\\n\\n                    # Once we come back\\n                    # Remove the current column from the three sets before we are going to the next column\\n                    cols.remove(col)\\n                    posDiag.remove(row - col)\\n                    negDiag.remove(row + col)\\n\\n                    # Remove the queen\\n                    board[row][col] = \".\"\\n\\n        backtrack(0)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398922,
                "title": "golang-rust-java-python-bitmask-solution",
                "content": "for each row, I stored the selected col, finally convert the path into string array.\\n\\nUsing bitmask\\n\\nGo\\n```go []\\nfunc solveNQueens(n int) [][]string {\\n\\tvar res [][]string\\n\\tdfs(0, 0, 0, n, []int{}, &res)\\n\\treturn res\\n}\\nfunc dfs(\\n\\tcolMask,\\n\\tdiagonal135,\\n\\tdiagonal45,\\n\\tn int,\\n\\tpath []int,\\n\\tres *[][]string) {\\n\\tbitmask := (1 << n) - 1\\n\\tif colMask == bitmask {\\n\\t\\t*res = append(*res, construct(path, n))\\n\\t\\treturn\\n\\t}\\n\\tavailable := bitmask & (^(colMask | diagonal135 | diagonal45))\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tbitInfo := 1 << i\\n\\t\\tif (bitInfo & available) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(\\n\\t\\t\\tcolMask|bitInfo,\\n\\t\\t\\t(diagonal135|bitInfo)>>1,\\n\\t\\t\\t(diagonal45|bitInfo)<<1,\\n\\t\\t\\tn,\\n\\t\\t\\tappend(path, i),\\n\\t\\t\\tres)\\n\\t}\\n}\\nfunc construct(path []int, n int) []string {\\n\\tboard := make([][]byte, n)\\n\\tfor i := range board {\\n\\t\\tboard[i] = make([]byte, n)\\n\\t\\tfor j := range board[i] {\\n\\t\\t\\tif j == path[i] {\\n\\t\\t\\t\\tboard[i][j] = \\'Q\\'\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tboard[i][j] = \\'.\\'\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar result []string\\n\\tfor i := range board {\\n\\t\\tresult = append(result, string(board[i]))\\n\\t}\\n\\treturn result\\n}\\n```\\n\\n``` Rust []\\nuse std::iter::FromIterator;\\nimpl Solution {\\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\\n        let mut res = vec![];\\n        Solution::dfs(n as usize, 0, 0, 0, &mut res, &mut vec![]);\\n        res\\n    }\\n    fn dfs(n: usize, diagonal_135: i32, diagonal_45: i32, col_mask: i32, res: &mut Vec<Vec<String>>, path: &mut Vec<usize>) {\\n        let bitmask = (1 << n) - 1;\\n        if bitmask == col_mask {\\n            res.push(Solution::decode(path, n));\\n            return;\\n        }\\n        let available = bitmask & (!(diagonal_135 | diagonal_45 | col_mask));\\n        for i in 0..n {\\n            let bit_info = 1 << i;\\n            if available & bit_info == 0 {\\n                continue;\\n            }\\n            path.push(i);\\n            Solution::dfs(\\n                n,\\n                (diagonal_135 | bit_info) >> 1,\\n                (diagonal_45 | bit_info) << 1,\\n                col_mask | bit_info,\\n                res,\\n                path, );\\n            path.pop();\\n        }\\n    }\\n    fn decode(path: &Vec<usize>, n: usize) -> Vec<String> {\\n        let board = path.iter().enumerate().fold(vec![vec![\\'.\\'; n]; n], |mut acc, (i, &j)| {\\n            acc[i][j] = \\'Q\\';\\n            acc\\n        });\\n        board.iter().map(|x| String::from_iter(x)).collect()\\n    }\\n}\\n```\\n\\n```java []\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(n, res, 0, 0, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void dfs(int n, List<List<String>> res, int diagonal135, int diagonal45, int colMask, List<Integer> path) {\\n        int bitmask = (1 << n) - 1;\\n        if (bitmask == colMask) {\\n            res.add(decode(path, n));\\n            return;\\n        }\\n        int available = ((1 << n) - 1) & (~(diagonal45 | diagonal135 | colMask));\\n        for (int i = 0; i < n; i++) {\\n            int bitInfo = 1 << i;\\n            if ((bitInfo & available) == 0) {\\n                continue;\\n            }\\n            path.add(i);\\n            dfs(n, res, (diagonal135 | bitInfo) << 1, (diagonal45 | bitInfo) >> 1, colMask | bitInfo, path);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n\\n    List<String> decode(List<Integer> path, int n) {\\n        char[][] board = new char[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == path.get(i)) {\\n                    board[i][j] = \\'Q\\';\\n                } else {\\n                    board[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        return Arrays.stream(board).map(String::valueOf).collect(Collectors.toList());\\n    }\\n}\\n```\\n\\n```python []\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        res = []\\n        self.dfs(res, [], 0, 0, 0, n)\\n        return res\\n\\n    def dfs(self, res: List[List[str]], path: List[int], diagonal45: int, diagonal135: int, col_mask: int, n: int):\\n        bit_mask = (1 << n) - 1\\n        if bit_mask == col_mask:\\n            res.append(self.decode(path))\\n            return\\n        available = bit_mask & (~(diagonal45 | diagonal135 | col_mask))\\n        for i in range(n):\\n            bit = 1 << i\\n            if bit & available == 0:\\n                continue\\n            self.dfs(res, path + [i], (diagonal45 | bit) << 1, (diagonal135 | bit) >> 1, col_mask | bit, n)\\n\\n    def decode(self, path: List[int]) -> List[str]:\\n        n = len(path)\\n        board = [[\\'.\\'] * n for _ in range(n)]\\n        for (i, j) in enumerate(path):\\n            board[i][j] = \\'Q\\'\\n        return [\\'\\'.join(i) for i in board]\\n",
                "solutionTags": [
                    "Java",
                    "Go",
                    "Rust",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```go []\\nfunc solveNQueens(n int) [][]string {\\n\\tvar res [][]string\\n\\tdfs(0, 0, 0, n, []int{}, &res)\\n\\treturn res\\n}\\nfunc dfs(\\n\\tcolMask,\\n\\tdiagonal135,\\n\\tdiagonal45,\\n\\tn int,\\n\\tpath []int,\\n\\tres *[][]string) {\\n\\tbitmask := (1 << n) - 1\\n\\tif colMask == bitmask {\\n\\t\\t*res = append(*res, construct(path, n))\\n\\t\\treturn\\n\\t}\\n\\tavailable := bitmask & (^(colMask | diagonal135 | diagonal45))\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tbitInfo := 1 << i\\n\\t\\tif (bitInfo & available) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdfs(\\n\\t\\t\\tcolMask|bitInfo,\\n\\t\\t\\t(diagonal135|bitInfo)>>1,\\n\\t\\t\\t(diagonal45|bitInfo)<<1,\\n\\t\\t\\tn,\\n\\t\\t\\tappend(path, i),\\n\\t\\t\\tres)\\n\\t}\\n}\\nfunc construct(path []int, n int) []string {\\n\\tboard := make([][]byte, n)\\n\\tfor i := range board {\\n\\t\\tboard[i] = make([]byte, n)\\n\\t\\tfor j := range board[i] {\\n\\t\\t\\tif j == path[i] {\\n\\t\\t\\t\\tboard[i][j] = \\'Q\\'\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tboard[i][j] = \\'.\\'\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tvar result []string\\n\\tfor i := range board {\\n\\t\\tresult = append(result, string(board[i]))\\n\\t}\\n\\treturn result\\n}\\n```\n``` Rust []\\nuse std::iter::FromIterator;\\nimpl Solution {\\n    pub fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\\n        let mut res = vec![];\\n        Solution::dfs(n as usize, 0, 0, 0, &mut res, &mut vec![]);\\n        res\\n    }\\n    fn dfs(n: usize, diagonal_135: i32, diagonal_45: i32, col_mask: i32, res: &mut Vec<Vec<String>>, path: &mut Vec<usize>) {\\n        let bitmask = (1 << n) - 1;\\n        if bitmask == col_mask {\\n            res.push(Solution::decode(path, n));\\n            return;\\n        }\\n        let available = bitmask & (!(diagonal_135 | diagonal_45 | col_mask));\\n        for i in 0..n {\\n            let bit_info = 1 << i;\\n            if available & bit_info == 0 {\\n                continue;\\n            }\\n            path.push(i);\\n            Solution::dfs(\\n                n,\\n                (diagonal_135 | bit_info) >> 1,\\n                (diagonal_45 | bit_info) << 1,\\n                col_mask | bit_info,\\n                res,\\n                path, );\\n            path.pop();\\n        }\\n    }\\n    fn decode(path: &Vec<usize>, n: usize) -> Vec<String> {\\n        let board = path.iter().enumerate().fold(vec![vec![\\'.\\'; n]; n], |mut acc, (i, &j)| {\\n            acc[i][j] = \\'Q\\';\\n            acc\\n        });\\n        board.iter().map(|x| String::from_iter(x)).collect()\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(n, res, 0, 0, 0, new ArrayList<>());\\n        return res;\\n    }\\n\\n    void dfs(int n, List<List<String>> res, int diagonal135, int diagonal45, int colMask, List<Integer> path) {\\n        int bitmask = (1 << n) - 1;\\n        if (bitmask == colMask) {\\n            res.add(decode(path, n));\\n            return;\\n        }\\n        int available = ((1 << n) - 1) & (~(diagonal45 | diagonal135 | colMask));\\n        for (int i = 0; i < n; i++) {\\n            int bitInfo = 1 << i;\\n            if ((bitInfo & available) == 0) {\\n                continue;\\n            }\\n            path.add(i);\\n            dfs(n, res, (diagonal135 | bitInfo) << 1, (diagonal45 | bitInfo) >> 1, colMask | bitInfo, path);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n\\n    List<String> decode(List<Integer> path, int n) {\\n        char[][] board = new char[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (j == path.get(i)) {\\n                    board[i][j] = \\'Q\\';\\n                } else {\\n                    board[i][j] = \\'.\\';\\n                }\\n            }\\n        }\\n        return Arrays.stream(board).map(String::valueOf).collect(Collectors.toList());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300315,
                "title": "java-89-easy",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> res = new ArrayList<>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        dfs(0,board,res);\\n        return res;\\n    }\\n    public void dfs(int col, char[][] board, List<List<String>> res){\\n        if(col==board[0].length){\\n            List<String> pres = new ArrayList<>();\\n            for(int i=0;i<board.length;i++){\\n                String s= new String(board[i]);\\n                pres.add(s);\\n            }\\n            res.add(pres);\\n            return;\\n        }\\n        for(int i=0;i<board.length;i++){\\n            if(validate(i,col,board)){\\n                board[i][col] = \\'Q\\';\\n                dfs(col+1,board,res);\\n                board[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    public boolean validate(int row, int col, char[][] board){\\n        int dupr = row;\\n        int dupc = col;\\n        \\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;col--;\\n        }\\n        row = dupr;col = dupc;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row = dupr; col = dupc;\\n        while(col>=0 && row<board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;col--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> res = new ArrayList<>();\\n        char[][] board = new char[n][n];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                board[i][j]=\\'.\\';\\n            }\\n        }\\n        dfs(0,board,res);\\n        return res;\\n    }\\n    public void dfs(int col, char[][] board, List<List<String>> res){\\n        if(col==board[0].length){\\n            List<String> pres = new ArrayList<>();\\n            for(int i=0;i<board.length;i++){\\n                String s= new String(board[i]);\\n                pres.add(s);\\n            }\\n            res.add(pres);\\n            return;\\n        }\\n        for(int i=0;i<board.length;i++){\\n            if(validate(i,col,board)){\\n                board[i][col] = \\'Q\\';\\n                dfs(col+1,board,res);\\n                board[i][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    public boolean validate(int row, int col, char[][] board){\\n        int dupr = row;\\n        int dupc = col;\\n        \\n        while(row>=0 && col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row--;col--;\\n        }\\n        row = dupr;col = dupc;\\n        while(col>=0){\\n            if(board[row][col]==\\'Q\\')return false;\\n            col--;\\n        }\\n        row = dupr; col = dupc;\\n        while(col>=0 && row<board.length){\\n            if(board[row][col]==\\'Q\\')return false;\\n            row++;col--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255282,
                "title": "n-queen-i-java-o-n-n-easy-to-understand",
                "content": "This is a simple explanation for the N-Queen board problem, which may help in understanding the concepts more easily.\\nAs, we can create a isSafe function to check if the position of the queen is safe or, not safe to be placed.\\nA safeBoard function to assign the correct board to be returned ,as there may be multiple solutions.\\nA helper function is used to solve the problem and their backtracking is used here.\\n\\n```\\nclass Solution {\\n    public void safeBoard(char [][]board,List<List<String>> ansBoard){\\n        List<String> dupBoard=new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String row=\"\";\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'Q\\'){\\n                    row+=\\'Q\\';\\n                }\\n                else{\\n                    row+=\\'.\\';\\n                }\\n            }\\n            dupBoard.add(row);\\n        }\\n        ansBoard.add(dupBoard);\\n    }\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ansBoard=new ArrayList<>();\\n        char [][] board =new char[n][n];\\n        helper(board,ansBoard,0);\\n        return ansBoard;\\n    }\\n    public void helper(char [][]board,List<List<String>> ansBoard,int col){\\n        if(col==board.length){\\n            safeBoard(board,ansBoard);\\n            return;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(isSafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                helper(board,ansBoard,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public boolean isSafe(int row,int col, char [][]board){\\n        //horizontal\\n        for(int i=0;i<board.length;i++){\\n            if(board[row][i]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //vertical\\n        for(int i=0;i<board.length;i++){\\n            if(board[i][col]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //upper left\\n        int r=row;\\n        for(int c=col;c>=0 && r>=0;c--,r--){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //upper right\\n        r=row;\\n        for(int c=col;c<board.length && r>=0;c++,r--){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //lower left\\n        r=row;\\n        for(int c=col;c>=0 && r<board.length;c--,r++){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //lower right\\n        r=row;\\n        for(int c=col;c<board.length && r<board.length;c++,r++){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nPlease upvote , if you liked it!!!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void safeBoard(char [][]board,List<List<String>> ansBoard){\\n        List<String> dupBoard=new ArrayList<>();\\n        for(int i=0;i<board.length;i++){\\n            String row=\"\";\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'Q\\'){\\n                    row+=\\'Q\\';\\n                }\\n                else{\\n                    row+=\\'.\\';\\n                }\\n            }\\n            dupBoard.add(row);\\n        }\\n        ansBoard.add(dupBoard);\\n    }\\n    public List<List<String>> solveNQueens(int n) {\\n        List<List<String>> ansBoard=new ArrayList<>();\\n        char [][] board =new char[n][n];\\n        helper(board,ansBoard,0);\\n        return ansBoard;\\n    }\\n    public void helper(char [][]board,List<List<String>> ansBoard,int col){\\n        if(col==board.length){\\n            safeBoard(board,ansBoard);\\n            return;\\n        }\\n        for(int row=0;row<board.length;row++){\\n            if(isSafe(row,col,board)){\\n                board[row][col]=\\'Q\\';\\n                helper(board,ansBoard,col+1);\\n                board[row][col]=\\'.\\';\\n            }\\n        }\\n    }\\n    public boolean isSafe(int row,int col, char [][]board){\\n        //horizontal\\n        for(int i=0;i<board.length;i++){\\n            if(board[row][i]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //vertical\\n        for(int i=0;i<board.length;i++){\\n            if(board[i][col]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //upper left\\n        int r=row;\\n        for(int c=col;c>=0 && r>=0;c--,r--){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //upper right\\n        r=row;\\n        for(int c=col;c<board.length && r>=0;c++,r--){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //lower left\\n        r=row;\\n        for(int c=col;c>=0 && r<board.length;c--,r++){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        //lower right\\n        r=row;\\n        for(int c=col;c<board.length && r<board.length;c++,r++){\\n            if(board[r][c]==\\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109671,
                "title": "java-easy-solution-using-backtracking-explained-each-line-with-comments",
                "content": "class Solution {\\n    \\n    List<List<String>> answer;\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        answer = new ArrayList<>();\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        placeNQueens(board, 0, n); // 0 is row number(we will fill rowwise)\\n        \\n        return answer;\\n    }\\n    \\n    private void placeNQueens(char[][] board, int row, int n){\\n        \\n        // base case\\n        if(row == n){\\n            List<String> ans = generateList(board);\\n            answer.add(ans);\\n            return;\\n        }\\n        \\n        // check for all columns\\n            // check if its safe to place queen\\n                // if its safe -> then place the queen and move to next row\\n        for(int col = 0; col < n ; col++){\\n            if (isSafe(board, row, col, n)){\\n                board[row][col] = \\'Q\\';\\n                placeNQueens(board, row+1, n);\\n                board[row][col] = \\'.\\'; // remove queen while backtracking\\n            }\\n        }\\n    }\\n    \\n    private List<String> generateList(char[][] board){\\n        \\n        List<String> list = new ArrayList<>();\\n        for(char[] arr : board){\\n            list.add(String.valueOf(arr));\\n        }\\n        return list;\\n    }\\n    \\n    private boolean isSafe(char[][] board, int row, int col, int n){\\n\\n        // check column on upper side\\n        for (int i = row; i >= 0; i--){\\n            if (board[i][col] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on left side\\n        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        // check upper diagonal on right side\\n        for (int i = row, j = col; i >= 0 && j < n; i--, j++){\\n            if (board[i][j] == \\'Q\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    List<List<String>> answer;\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        answer = new ArrayList<>();\\n        \\n        // create a n*n chessboard\\n        char[][] board = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                board[i][j] = \\'.\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2108958,
                "title": "backtracking-bitmask",
                "content": "![image](https://assets.leetcode.com/users/images/eabdd3ed-7095-4425-87d3-d3daf0c5e509_1654329776.4947937.png)\\nTo quickly check the possibility of putting the queen on the cell `(i, j)`, we need three arrays: `columns[n]` (because there are `n` columns on the board according to the condition), `left_diagonals[2 * n - 1]` (we can encode left diagonal number as `j + i`; numbers will be in `[0 .. 2 * n - 2]`) and `right_diagonals[2 * n - 1]` (we can encode right diagonal as `j - i` and translate from range `[-n + 1 .. n - 1]` to `[0 .. 2 * n - 2]` by encoding as `n - 1 + j - i`).\\n  \\nIn order to optimize memory consumption, it is possible to store all values in a single array of size `n + (2 * n - 1) + (2 * n - 1) = 5 * n - 2`. Also considering constrain `1 <= n <= 9` you can create `std::bitset<43>` to store all flags. Using a bitset will be more efficient, since if its size is less than `64`, then one `long` number is used for implementation.\\n\\n\\tclass Solution {      \\n\\tpublic:\\n\\t\\tvector<vector<string>> solveNQueens(int n) {\\n\\t\\t\\tvector<vector<string>> result;\\n\\t\\t\\tvector<string> board(n, string(n, \\'.\\'));\\n\\t\\t\\tbitset<43> flags;\\n\\t\\t\\tflags.set();\\n\\t\\t\\tbacktrack(result, board, flags, 0, n);\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tvoid backtrack(\\n\\t\\t\\tvector<vector<string>>& result,\\n\\t\\t\\tvector<string>& board,\\n\\t\\t\\tbitset<43>& flags,\\n\\t\\t\\tint i,\\n\\t\\t\\tint n\\n\\t\\t) {\\n\\t\\t\\tif (i == n) {\\n\\t\\t\\t\\tresult.push_back(board);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint column, left_diagonal, right_diagonal;\\n\\n\\t\\t\\tfor (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\tcolumn = j;\\n\\t\\t\\t\\tleft_diagonal = n + j + i;\\n\\t\\t\\t\\tright_diagonal = 4 * n - 2 + j - i;\\n\\n\\t\\t\\t\\tif (flags[column] && flags[left_diagonal] && flags[right_diagonal]) {\\n\\n\\t\\t\\t\\t\\t// put queen on board\\n\\t\\t\\t\\t\\tflags[column] = flags[left_diagonal] = flags[right_diagonal] = false;\\n\\t\\t\\t\\t\\tboard[i][j] = \\'Q\\';\\n\\n\\t\\t\\t\\t\\tbacktrack(result, board, flags, i + 1, n);\\n\\n\\t\\t\\t\\t\\t// remove queen from board\\n\\t\\t\\t\\t\\tboard[i][j] = \\'.\\';\\n\\t\\t\\t\\t\\tflags[column] = flags[left_diagonal] = flags[right_diagonal] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {      \\n\\tpublic:\\n\\t\\tvector<vector<string>> solveNQueens(int n) {\\n\\t\\t\\tvector<vector<string>> result;\\n\\t\\t\\tvector<string> board(n, string(n, \\'.\\'));\\n\\t\\t\\tbitset<43> flags;\\n\\t\\t\\tflags.set();\\n\\t\\t\\tbacktrack(result, board, flags, 0, n);\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2107807,
                "title": "c-easily-understandable-detailed-explanation-daily-leetcoding-challenge-june-day-4",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int col,int n,vector<string> &board,vector<vector<string>> &ans,vector<int> &left,vector<int> &upperDigonal,vector<int> &lowerDigonal)\\n    {\\n        // if we reached to the boundry then return the board into the ans\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        // cheking for each row of given col\\n        for(int row=0;row<n;row++)\\n        {\\n            // if our hash value is 0 it means we can place a queen over there there is no collison (in left , upper & lower digonal)\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[n-1+col-row]==0)\\n            {\\n                board[row][col]=\\'Q\\';                 // store Q afetr checking all three condition\\n                \\n                // make the hashmap from 0 to 1 after considering current position as a queen\\n                left[row]=1; \\n                upperDigonal[row+col]=1;\\n                lowerDigonal[n-1+col-row]=1;\\n                \\n                // after filling current column successfully go to next one\\n                solve(col+1,n,board,ans,left,upperDigonal,lowerDigonal);\\n                \\n                // BackTracking\\n                board[row][col]=\\'.\\';\\n                left[row]=0;\\n                upperDigonal[row+col]=0;\\n                lowerDigonal[n-1+col-row]=0;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) \\n    {\\n        // we have to check three conditions\\n        // 1. each row has one queen\\n        // 2. each column has one queen\\n        // 3. any queen will not attack on any other queen (queen can go in 8 directions)\\n        \\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        solve(0,n,board,ans,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int col,int n,vector<string> &board,vector<vector<string>> &ans,vector<int> &left,vector<int> &upperDigonal,vector<int> &lowerDigonal)\\n    {\\n        // if we reached to the boundry then return the board into the ans\\n        if(col==n)\\n        {\\n            ans.push_back(board);\\n            return;\\n        }\\n        \\n        // cheking for each row of given col\\n        for(int row=0;row<n;row++)\\n        {\\n            // if our hash value is 0 it means we can place a queen over there there is no collison (in left , upper & lower digonal)\\n            if(left[row]==0 && upperDigonal[row+col]==0 && lowerDigonal[n-1+col-row]==0)\\n            {\\n                board[row][col]=\\'Q\\';                 // store Q afetr checking all three condition\\n                \\n                // make the hashmap from 0 to 1 after considering current position as a queen\\n                left[row]=1; \\n                upperDigonal[row+col]=1;\\n                lowerDigonal[n-1+col-row]=1;\\n                \\n                // after filling current column successfully go to next one\\n                solve(col+1,n,board,ans,left,upperDigonal,lowerDigonal);\\n                \\n                // BackTracking\\n                board[row][col]=\\'.\\';\\n                left[row]=0;\\n                upperDigonal[row+col]=0;\\n                lowerDigonal[n-1+col-row]=0;\\n            }\\n        }\\n    }\\n    vector<vector<string>> solveNQueens(int n) \\n    {\\n        // we have to check three conditions\\n        // 1. each row has one queen\\n        // 2. each column has one queen\\n        // 3. any queen will not attack on any other queen (queen can go in 8 directions)\\n        \\n        vector<vector<string>> ans;                 // created the data structure for storing the complete final ans\\n        vector<string> board(n);                    // store the current queue value\\n        string s(n,\\'.\\');                            // [\\'.\\',\\'.\\',\\'.\\',\\'.\\'] (n=4)\\n        \\n        for(int i=0;i<n;i++)                        // initialize whole board as a empty string\\n        {\\n            board[i]=s;\\n        }\\n        \\n        // we are going from left to right\\n        // so we need to check only behind the current cell because all the cells after current cell will surely empty\\n        // we can not check for upper and lower direction for current cell also because each column and row has only one queen\\n        \\n        // using hashing for check the collision\\n        vector<int> left(n,0);                      // for cheking the left side we will maintaining an array that will tell which row has already taken for placing queen\\n        vector<int> upperDigonal(2*n-1,0);          // for checking the upper digonal we will maintaiing an array that will tell which upperdigonal has already taken\\n        vector<int> lowerDigonal(2*n-1,0);          // for checking the lower digonal we will maintaiing an array that will tell which lowerdigonal has already taken\\n        \\n        solve(0,n,board,ans,left,upperDigonal,lowerDigonal);  // called the function\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107710,
                "title": "python-backtracking-with-bitmasks",
                "content": "A queen blocks an entire row, so **there can be at most one queen per row**. We will backtrack based on the possible position of a queen in each row.\\n\\nWe will keep track of the board with an array of integers `board` of size `n`.  `board[i] = 0`  if there are no queens at row `i`, and `board[i] = j` if the queen in row `i` is in column `j` (1-indexed columns).\\n\\nGiven a `board` state, we identify the available squares with the aid of three integers: `columns` (`n` bits), `downDiagonals` (`2n - 1` bits), and `upDiagonlas` (`2n - 1` bits).\\n* `columns & 1 << j - 1 == 1` iff there is a queen at column `j`\\n* `downDiagonals & 1 << i - j + n` iff there is a queeen at the diagonal given by *y = x + b* where *b = j - i*\\n* `upDiagonals & 1 << i + j - 1 == 1` iff there is a queen at the diagonal given by *y = -x + b* where *b = i + j + 1*\\n\\n\\n![image](https://assets.leetcode.com/users/images/93aee485-4e4d-4ccf-a936-6b7fbbbfca0d_1654306175.475418.png)\\n<hr>\\n\\n```\\nclass Solution:\\n    def availableSquares(self, board: List[int], row: int):\\n        n = len(board)\\n        columns, downDiagonals, upDiagonals = 0, 0, 0\\n        \\n        for i, j in enumerate(board):\\n\\t\\t\\t# there is a queen at j in row i\\n            if j != 0:\\n                columns |= 1 << j - 1\\n                downDiagonals |= 1 << i - j + n\\n                upDiagonals |= 1 << i + j - 1\\n        \\n        for j in range(n):\\n\\t\\t\\t# if square j in row is not blocked\\n            if columns & 1 << j == 0 and downDiagonals & 1 << (row - j + n - 1) == 0 and upDiagonals & 1 << (row + j) == 0:\\n                yield j + 1\\n    \\n    def backtrack(self, board: List[int], k: int = 0,):\\n        n = len(board)\\n        if k == n:\\n\\t\\t\\t# we\\'ve successfully placed n queens on the board, append board to solutions\\n            self.solutions.append([\"\".join(\"Q\" if i == rowQ else \".\" for i in range(1, n + 1)) for rowQ in board])\\n        else:\\n\\t\\t\\t# for each available square in row k\\n            for j in self.availableSquares(board, k):\\n                board[k] = j                  # add queen at position j in row k\\n                self.backtrack(board, k + 1)  # move on to the next row\\n                board[k] = 0                  # remove queen from row k\\n    \\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        self.solutions = []\\n        self.backtrack([0 for _ in range(n)])\\n        return self.solutions\\n```\\n\\n* The performance of this solution could be improved by passing `columns`, `downDiagonals`, and `upDiagonals` as arguments to `availableSquares` and `backtrack`, and modifying them as we add/remove a queen to a row, so they don\\'t need to be calculated from scratch in each iteration.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def availableSquares(self, board: List[int], row: int):\\n        n = len(board)\\n        columns, downDiagonals, upDiagonals = 0, 0, 0\\n        \\n        for i, j in enumerate(board):\\n\\t\\t\\t# there is a queen at j in row i\\n            if j != 0:\\n                columns |= 1 << j - 1\\n                downDiagonals |= 1 << i - j + n\\n                upDiagonals |= 1 << i + j - 1\\n        \\n        for j in range(n):\\n\\t\\t\\t# if square j in row is not blocked\\n            if columns & 1 << j == 0 and downDiagonals & 1 << (row - j + n - 1) == 0 and upDiagonals & 1 << (row + j) == 0:\\n                yield j + 1\\n    \\n    def backtrack(self, board: List[int], k: int = 0,):\\n        n = len(board)\\n        if k == n:\\n\\t\\t\\t# we\\'ve successfully placed n queens on the board, append board to solutions\\n            self.solutions.append([\"\".join(\"Q\" if i == rowQ else \".\" for i in range(1, n + 1)) for rowQ in board])\\n        else:\\n\\t\\t\\t# for each available square in row k\\n            for j in self.availableSquares(board, k):\\n                board[k] = j                  # add queen at position j in row k\\n                self.backtrack(board, k + 1)  # move on to the next row\\n                board[k] = 0                  # remove queen from row k\\n    \\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        self.solutions = []\\n        self.backtrack([0 for _ in range(n)])\\n        return self.solutions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984349,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\npublic class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[] \\n            //ocp0 = new boolean[n], //whether there\\'s a queen ocupying nth row, I don\\'t need it\\n            ocp90 = new boolean[n], //whether there\\'s a queen ocupying nth column\\n            ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation\\n            ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] map = new char[n][n];\\n        for (char[] tmp : map) Arrays.fill(tmp, \\'.\\'); //init\\n        \\n        solve(0, n, map, ans, ocp45, ocp90, ocp135);\\n        return ans;\\n    }\\n    \\n    private void solve(int depth, int n, char[][] map, List<List<String>> ans, \\n    boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) {\\n        if (depth == n) {\\n            addSolution(ans, map);\\n            return;\\n        }\\n        \\n        for (int j = 0; j < n; j++)\\n            if (!ocp90[j] && !ocp45[depth + j] && !ocp135[j - depth + n - 1]) {\\n                ocp90[j] = true;\\n                ocp45[depth + j] = true;\\n                ocp135[j - depth + n - 1] = true;\\n                map[depth][j] = \\'Q\\';\\n                solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135);\\n                ocp90[j] = false;\\n                ocp45[depth + j] = false;\\n                ocp135[j - depth + n - 1] = false;\\n                map[depth][j] = \\'.\\';\\n            }\\n    }\\n    \\n    private void addSolution(List<List<String>> ans, char[][] map) {\\n        List<String> cur = new ArrayList<String>();\\n        for (char[] i : map) cur.add(String.valueOf(i));\\n        ans.add(cur);\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int N) {\\n        ans.clear();\\n        board.resize(N, string(N, \\'.\\'));\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> ans;\\n    vector<string> board;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.size();\\n        if (i == N) {\\n            vector<string> res;\\n            for (auto row : board) res.push_back(row);\\n            ans.push_back(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def solveNQueens(self, N: int) -> List[List[str]]:\\n        ans = []\\n        board = [[\\'.\\'] * N for _ in range(N)]\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N:\\n                ans.append([\"\".join(row) for row in board])\\n                return\\n            for j in range(N):\\n                vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                board[i][j] = \\'Q\\'\\n                place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n                board[i][j] = \\'.\\'\\n            \\n        place(0,0,0,0)\\n        return ans\\n```\\n\\n***JavaScript***\\n```\\nvar solveNQueens = function(N) {\\n    let ans = [],\\n        board = Array.from({length: N}, () => new Array(N).fill(\\'.\\'))\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) {\\n            let res = new Array(N)\\n            for (let row = 0; row < N; row++)\\n                res[row] = board[row].join(\"\")\\n            ans.push(res)\\n            return\\n        }\\n        for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            board[i][j] = \\'Q\\'\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            board[i][j] = \\'.\\'\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun solveNQueens(N: Int): List<List<String>> {\\n        val result = mutableListOf<List<String>>()\\n        val board = Array(N) { CharArray(N) { \\'.\\' } }\\n\\n        fun isValid(row: Int, col: Int): Boolean { // check only top rows and cols\\n            for (i in 0 until row) {\\n                if (board[i][col] == \\'Q\\')\\n                    return false\\n            }\\n            // top right \\n            var (i, j) = row - 1 to col + 1\\n            while (i >= 0 && j < N) {\\n                if (board[i--][j++] == \\'Q\\')\\n                    return false\\n            }\\n            // top left\\n            i = row - 1\\n            j = col - 1\\n            while (i >= 0 && j >= 0) {\\n                if (board[i--][j--] == \\'Q\\')\\n                    return false\\n            }\\n            return true\\n        }\\n\\n        fun construct() {\\n            val list = mutableListOf<String>()\\n            for (row in board) list.add(String(row))\\n            result.add(list)\\n        }\\n\\n        fun backtrack(row: Int) {\\n            if (row == N) {\\n                construct()\\n                return\\n            }\\n            for (col in 0 until N) {\\n                if (isValid(row, col)) {\\n                    board[row][col] = \\'Q\\'\\n                    backtrack(row + 1)\\n                    board[row][col] = \\'.\\'\\n                }\\n            }\\n        }\\n        \\n        backtrack(0)\\n        \\n        return result\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path)  }\\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.map({ (path: [Int]) -> [String] in\\n            var res: [String] = []\\n            for i in path {\\n                var string = \"\"\\n                for j in 0..<n { string += (i == j ? \"Q\" : \".\") }\\n                res.append(string)\\n            }\\n            return res\\n        })\\n    }\\n    \\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\npublic class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        boolean[] \\n            //ocp0 = new boolean[n], //whether there\\'s a queen ocupying nth row, I don\\'t need it\\n            ocp90 = new boolean[n], //whether there\\'s a queen ocupying nth column\\n            ocp45 = new boolean[2 * n - 1], // mark 45 degree occupation\\n            ocp135 = new boolean[2 * n - 1]; // mark 135 degree occupation\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        char[][] map = new char[n][n];\\n        for (char[] tmp : map) Arrays.fill(tmp, \\'.\\'); //init\\n        \\n        solve(0, n, map, ans, ocp45, ocp90, ocp135);\\n        return ans;\\n    }\\n    \\n    private void solve(int depth, int n, char[][] map, List<List<String>> ans, \\n    boolean[] ocp45, boolean[] ocp90, boolean[] ocp135) {\\n        if (depth == n) {\\n            addSolution(ans, map);\\n            return;\\n        }\\n        \\n        for (int j = 0; j < n; j++)\\n            if (!ocp90[j] && !ocp45[depth + j] && !ocp135[j - depth + n - 1]) {\\n                ocp90[j] = true;\\n                ocp45[depth + j] = true;\\n                ocp135[j - depth + n - 1] = true;\\n                map[depth][j] = \\'Q\\';\\n                solve(depth + 1, n, map, ans, ocp45, ocp90, ocp135);\\n                ocp90[j] = false;\\n                ocp45[depth + j] = false;\\n                ocp135[j - depth + n - 1] = false;\\n                map[depth][j] = \\'.\\';\\n            }\\n    }\\n    \\n    private void addSolution(List<List<String>> ans, char[][] map) {\\n        List<String> cur = new ArrayList<String>();\\n        for (char[] i : map) cur.add(String.valueOf(i));\\n        ans.add(cur);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int N) {\\n        ans.clear();\\n        board.resize(N, string(N, \\'.\\'));\\n        place(0,0,0,0);\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> ans;\\n    vector<string> board;\\n    \\n    void place(int i, int vert, int ldiag, int rdiag) {\\n        int N = board.size();\\n        if (i == N) {\\n            vector<string> res;\\n            for (auto row : board) res.push_back(row);\\n            ans.push_back(res);\\n            return;\\n        }\\n        for (int j = 0; j < N; j++) {\\n            int vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j);\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue;\\n            board[i][j] = \\'Q\\';\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask);\\n            board[i][j] = \\'.\\';\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def solveNQueens(self, N: int) -> List[List[str]]:\\n        ans = []\\n        board = [[\\'.\\'] * N for _ in range(N)]\\n        \\n        def place(i: int, vert: int, ldiag: int, rdiag:int) -> None:\\n            if i == N:\\n                ans.append([\"\".join(row) for row in board])\\n                return\\n            for j in range(N):\\n                vmask, lmask, rmask = 1 << j, 1 << (i+j), 1 << (N-i-1+j)\\n                if vert & vmask or ldiag & lmask or rdiag & rmask: continue\\n                board[i][j] = \\'Q\\'\\n                place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n                board[i][j] = \\'.\\'\\n            \\n        place(0,0,0,0)\\n        return ans\\n```\n```\\nvar solveNQueens = function(N) {\\n    let ans = [],\\n        board = Array.from({length: N}, () => new Array(N).fill(\\'.\\'))\\n    \\n    const place = (i, vert, ldiag, rdiag) => {\\n        if (i === N) {\\n            let res = new Array(N)\\n            for (let row = 0; row < N; row++)\\n                res[row] = board[row].join(\"\")\\n            ans.push(res)\\n            return\\n        }\\n        for (let j = 0; j < N; j++) {\\n            let vmask = 1 << j, lmask = 1 << (i+j), rmask = 1 << (N-i-1+j)\\n            if (vert & vmask || ldiag & lmask || rdiag & rmask) continue\\n            board[i][j] = \\'Q\\'\\n            place(i+1, vert | vmask, ldiag | lmask, rdiag | rmask)\\n            board[i][j] = \\'.\\'\\n        }\\n    }\\n\\n    place(0,0,0,0)\\n    return ans\\n};\\n```\n```\\nclass Solution {\\n    fun solveNQueens(N: Int): List<List<String>> {\\n        val result = mutableListOf<List<String>>()\\n        val board = Array(N) { CharArray(N) { \\'.\\' } }\\n\\n        fun isValid(row: Int, col: Int): Boolean { // check only top rows and cols\\n            for (i in 0 until row) {\\n                if (board[i][col] == \\'Q\\')\\n                    return false\\n            }\\n            // top right \\n            var (i, j) = row - 1 to col + 1\\n            while (i >= 0 && j < N) {\\n                if (board[i--][j++] == \\'Q\\')\\n                    return false\\n            }\\n            // top left\\n            i = row - 1\\n            j = col - 1\\n            while (i >= 0 && j >= 0) {\\n                if (board[i--][j--] == \\'Q\\')\\n                    return false\\n            }\\n            return true\\n        }\\n\\n        fun construct() {\\n            val list = mutableListOf<String>()\\n            for (row in board) list.add(String(row))\\n            result.add(list)\\n        }\\n\\n        fun backtrack(row: Int) {\\n            if (row == N) {\\n                construct()\\n                return\\n            }\\n            for (col in 0 until N) {\\n                if (isValid(row, col)) {\\n                    board[row][col] = \\'Q\\'\\n                    backtrack(row + 1)\\n                    board[row][col] = \\'.\\'\\n                }\\n            }\\n        }\\n        \\n        backtrack(0)\\n        \\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func solveNQueens(_ n: Int) -> [[String]] {\\n        var res: [[Int]] = []\\n        \\n        \\n        func backtarck(_ path: [Int]) {\\n            if path.count == n { res.append(path)  }\\n            var path = path\\n            var available: [Int] = []\\n            for i in 0..<n { available.append(i) }\\n            \\n            for (i, val) in path.enumerated() {\\n                if let index = available.firstIndex(of: val - path.count + i) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val) {\\n                    available.remove(at: index)\\n                }\\n                \\n                if let index = available.firstIndex(of: val + path.count - i) {\\n                    available.remove(at: index)\\n                }\\n            }\\n            \\n            for i in 0..<n {\\n                if available.contains(i) == false { continue }\\n                path.append(i)\\n                backtarck(path)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        backtarck([])\\n        \\n        return res.map({ (path: [Int]) -> [String] in\\n            var res: [String] = []\\n            for i in path {\\n                var string = \"\"\\n                for j in 0..<n { string += (i == j ? \"Q\" : \".\") }\\n                res.append(string)\\n            }\\n            return res\\n        })\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942241,
                "title": "c-backtracking-recursion",
                "content": "Here is my solution of this problem hope you would like the approach.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool check(vector<string>c, int row, int col, int n){\\n        int i, j;\\n        for(i=0; i<=row; i++){    //checking int the each rows, if queens is present then will return false so next queen cannot be placed int the same row.\\n            if(c[i][col] == \\'Q\\')\\n                return false;\\n        }\\n        for(i=row, j=col-1; i>=0 && j>=0; i--, j--){  // checking in diagonals which goes left side, so row will be decremented till it becomes zero and same for column.\\n            if(c[i][j] == \\'Q\\')    //so if queen is already present then we will return false means nest queen cannot be placed at that position. \\n                return false;\\n        }\\n        for(i=row, j=col+1; i>=0 && j<n; i--, j++){  // same process is done for right side diadonal with respect to that position.\\n            if(c[i][j] == \\'Q\\')\\n                return false;\\n        }     \\n    \\n        return true;  // after going through all these conditions if none goes false means the given paticular co ordinates i.e. row, col, is safe place for the next queen to be placed.\\n    }\\n\\n    void check_place(vector<vector<string>> &q, vector<string>c, int ind, int n){\\n        if(ind == n){    // this is the base condition for this recursive function, so if all the queens are placed so will insert all the vector of strings formed int the final one which has to be returned. \\n            q.push_back(c);\\n            return;\\n        }\\n        string s(n, \\'.\\');  // a string is declared .\\n        for(int i=0; i<n; i++){   // here we are iterating through each of the column and at given position we are inserting \\'Q\\' and move further to check whether it is safe position to be placed if not then again we will be replacing \\'Q\\' by \\'.\\'.\\n            s[i] = \\'Q\\';\\n            if(check(c, ind-1, i, n)){\\n                c.push_back(s);\\n                check_place(q, c, ind+1, n);\\n                c.pop_back();\\n            }\\n            s[i] = \\'.\\';\\n        }\\n    \\n        return;\\n    }\\n\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> q; // declaring a vector of vector of string in which final choices of position of queens will be inserted.\\n        vector<string> c;  \\n    \\n        check_place(q, c, 0, n);\\n    \\n        return q;\\n    }\\n};\\n\\'\\'\\'\\nSo this is the entire logic of my code hope you liked it!!",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool check(vector<string>c, int row, int col, int n){\\n        int i, j;\\n        for(i=0; i<=row; i++){    //checking int the each rows, if queens is present then will return false so next queen cannot be placed int the same row.\\n            if(c[i][col] == \\'Q\\')\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1866699,
                "title": "n-queens-backtracking-hashing-c",
                "content": "This Post Contains two solution to the N-Queens Problem. One by Backtracking and another by the concept of Hashing.\\nSolution 1 By Backtracking\\nIn N-Queens Problem, Three Conditions need to be satisfied\\n1) Each Column Should contain one queen\\n2) Each Row Should contain one queen\\n3) No Two Queens Should Attack Each Other\\n```\\nbool isSafe(int row, int col, vector<string>& board, int n){\\n//We need to check for three cases only, i.e, Left column, Upper diagonal, Lower Diagonal for a corresponding block.\\n//If we are checking for a current block, no need to check rows below or above it and neither is the need to check in right half\\n       int duprow = row;\\n       int dupcol = col;\\n       \\n       while(row>=0 && col >= 0){ //Check if any queen is placed in upper diagonal or not\\n           if(board[row][col] == \\'Q\\') return false; //If placed we cannot place the queen in this diagonal\\n           row--;\\n           col--;\\n       }\\n       \\n       row = duprow;\\n       col = dupcol;\\n       while(col >=0){ //Check if queen is placed earlier in column before or not\\n           if(board[row][col] == \\'Q\\') return false;\\n           col--;\\n       }\\n       \\n       row = duprow;\\n       col = dupcol;\\n       while(col >=0 && row <n){ //Checking for lower diagonal\\n           if(board[row][col] == \\'Q\\') return false;\\n           col--;\\n           row++;\\n       }\\n       \\n       return true; //If all conditions are met, we return true\\n   } \\n    \\n    void solve(int col, vector<vector<string>>& ans, vector<string>& board, int n){\\n        if(col == n){ //If column goes out of boundary or in other word every column has one queen placed\\n            ans.push_back(board); //We have one answer\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++){ //Iterating through if every row to see if a queen can be placed at that row, col or not\\n            if(isSafe(row, col, board, n)){ //If it is safe to place the queen we place it\\n                board[row][col] = \\'Q\\';\\n                solve(col+1, ans, board, n); //Then we check for next queen to be placed in next column\\n                board[row][col] = \\'.\\'; //Finally marking the block with \\'.\\' as we are bactracking to try further alternatives\\n            }\\n        }\\n    }\\n\\t\\n\\tvector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans; //2D Vector to store final ans\\n        vector<string> board(n); //Helper vector to store individual answer one at a time\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        solve(0, ans, board, n); //Starting by column number 0 (Assuming 0-indexed)\\n        return ans;\\n    }\\n\\t\\n\\t//This solution is not better due to extra 3 O(n) loops in isSafe Function\\n```\\n\\nSolution 2 By Hashing Concept (Much Better)\\n```\\nvoid solve(int col, vector<vector<string>>& ans, vector<string>& board, int n, vector<int>& lR, vector<int>& upDg, vector<int>& lwDg){\\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n\\n        for(int row=0; row<n; row++){\\n            if(lR[row] == 0 && lwDg[row+col] == 0 && upDg[n-1+col-row] == 0){\\n                board[row][col] = \\'Q\\';\\n                lR[row] = 1;\\n                lwDg[row+col] = 1;\\n                upDg[n-1+col-row] = 1;\\n                solve(col+1, ans, board, n, lR, upDg, lwDg);\\n                board[row][col] = \\'.\\';\\n                lR[row] = 0;\\n                lwDg[row+col] = 0;\\n                upDg[n-1+col-row] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        vector<int> leftRow(n, 0), upDg(2*n - 1, 0), lwDg(2*n - 1, 0);\\n        solve(0, ans, board, n, leftRow, upDg, lwDg);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nbool isSafe(int row, int col, vector<string>& board, int n){\\n//We need to check for three cases only, i.e, Left column, Upper diagonal, Lower Diagonal for a corresponding block.\\n//If we are checking for a current block, no need to check rows below or above it and neither is the need to check in right half\\n       int duprow = row;\\n       int dupcol = col;\\n       \\n       while(row>=0 && col >= 0){ //Check if any queen is placed in upper diagonal or not\\n           if(board[row][col] == \\'Q\\') return false; //If placed we cannot place the queen in this diagonal\\n           row--;\\n           col--;\\n       }\\n       \\n       row = duprow;\\n       col = dupcol;\\n       while(col >=0){ //Check if queen is placed earlier in column before or not\\n           if(board[row][col] == \\'Q\\') return false;\\n           col--;\\n       }\\n       \\n       row = duprow;\\n       col = dupcol;\\n       while(col >=0 && row <n){ //Checking for lower diagonal\\n           if(board[row][col] == \\'Q\\') return false;\\n           col--;\\n           row++;\\n       }\\n       \\n       return true; //If all conditions are met, we return true\\n   } \\n    \\n    void solve(int col, vector<vector<string>>& ans, vector<string>& board, int n){\\n        if(col == n){ //If column goes out of boundary or in other word every column has one queen placed\\n            ans.push_back(board); //We have one answer\\n            return;\\n        }\\n        \\n        for(int row=0; row<n; row++){ //Iterating through if every row to see if a queen can be placed at that row, col or not\\n            if(isSafe(row, col, board, n)){ //If it is safe to place the queen we place it\\n                board[row][col] = \\'Q\\';\\n                solve(col+1, ans, board, n); //Then we check for next queen to be placed in next column\\n                board[row][col] = \\'.\\'; //Finally marking the block with \\'.\\' as we are bactracking to try further alternatives\\n            }\\n        }\\n    }\\n\\t\\n\\tvector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans; //2D Vector to store final ans\\n        vector<string> board(n); //Helper vector to store individual answer one at a time\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        solve(0, ans, board, n); //Starting by column number 0 (Assuming 0-indexed)\\n        return ans;\\n    }\\n\\t\\n\\t//This solution is not better due to extra 3 O(n) loops in isSafe Function\\n```\n```\\nvoid solve(int col, vector<vector<string>>& ans, vector<string>& board, int n, vector<int>& lR, vector<int>& upDg, vector<int>& lwDg){\\n        if(col == n){\\n            ans.push_back(board);\\n            return;\\n        }\\n\\n        for(int row=0; row<n; row++){\\n            if(lR[row] == 0 && lwDg[row+col] == 0 && upDg[n-1+col-row] == 0){\\n                board[row][col] = \\'Q\\';\\n                lR[row] = 1;\\n                lwDg[row+col] = 1;\\n                upDg[n-1+col-row] = 1;\\n                solve(col+1, ans, board, n, lR, upDg, lwDg);\\n                board[row][col] = \\'.\\';\\n                lR[row] = 0;\\n                lwDg[row+col] = 0;\\n                upDg[n-1+col-row] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> ans;\\n        vector<string> board(n);\\n        string s(n, \\'.\\');\\n        for(int i=0; i<n; i++){\\n            board[i] = s;\\n        }\\n        vector<int> leftRow(n, 0), upDg(2*n - 1, 0), lwDg(2*n - 1, 0);\\n        solve(0, ans, board, n, leftRow, upDg, lwDg);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1763969,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> results;\\n\\n        vector<string> positions(n, string(n, \\'.\\'));\\n        \\n        int row = 0;\\n        \\n        NQueens(results, positions, n, row);\\n        \\n        return results;\\n    }\\n    \\n    void NQueens(vector<vector<string>> &results, vector<string> &positions, int &n, int row) {\\n        if(row == n) {\\n            results.push_back(positions);\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(positions, row, col, n) == true) {\\n                positions[row][col] = \\'Q\\';\\n                NQueens(results, positions, n, row + 1);\\n                positions[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n    }\\n    \\n    bool IsQueenSafe(vector<string> &positions, int row, int col, int &n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> results;\\n\\n        vector<string> positions(n, string(n, \\'.\\'));\\n        \\n        int row = 0;\\n        \\n        NQueens(results, positions, n, row);\\n        \\n        return results;\\n    }\\n    \\n    void NQueens(vector<vector<string>> &results, vector<string> &positions, int &n, int row) {\\n        if(row == n) {\\n            results.push_back(positions);\\n            return;\\n        }\\n        \\n        for(int col = 0; col < n; ++col) {\\n            if(IsQueenSafe(positions, row, col, n) == true) {\\n                positions[row][col] = \\'Q\\';\\n                NQueens(results, positions, n, row + 1);\\n                positions[row][col] = \\'.\\';\\n            }\\n        }\\n        \\n    }\\n    \\n    bool IsQueenSafe(vector<string> &positions, int row, int col, int &n) {\\n        for(int i = row - 1, j = col; i >= 0; --i) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        \\n        for(int i = row - 1, j = col + 1; i >= 0 && j <= (n - 1); --i, ++j) {\\n            if(positions[i][j] == \\'Q\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694900,
                "title": "python-solution-backtracking-recursion-o-n",
                "content": "#### Time Complexity = O(n!)\\n#### Space Complexity = O(n)\\n\\n## Step:\\ni]  Create a board.\\n```Finalboard = [[]*n for _ in range(n)]``` this will create a list of list [[],[],[],[]] ```# when n = 4```\\n\\nii] Create a list to keep track of --> In which column the queen is placed at a particular row.\\n``` \\n# each index is considered to be a row\\n        queenTracker = [0] * n # keep track of col in which queen is placed\\n```\\n\\niii] Call the Validate function -> to check if all the queens are placed in correct position.\\n - Queens are placed in correct position --- when we have completed our recursice call.  ie.,  after placing queen at right column in each and every row. We will reach a condition, where we have placed our queen at right column in every row.\\n - at this time we would have gone through every row : \\n``` \\nif row == n:\\n            self.board(queenTracker,Finalboard,n,ans)\\n            return 1\\n# this will form the base case and we add queen at to the board. and we return 1 stating that we have completed placing all queen in their right position -- (this is just like an acknowlegment)\\n```\\n\\niv] validate function will call  \\'is valid position function\\' to check if the queen is not being placed in the same col and in the same diagonal as the previous queens.\\n\\nv] place the \".\" and \"q\" in the board  --  once we know position of all the queen in their right place. ie., when we are about to return 1 or when we have traversed every row in the board.\\n\\n## Code:\\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        # creating a board\\n        ans = []\\n        Finalboard = [[]*n for _ in range(n)]\\n        \\n        # each index is considered to be a row\\n        queenTracker = [0] * n # keep track of col in which queen is placed\\n        self.validate(0 , n , queenTracker,Finalboard,ans)\\n        \\n        return ans\\n    \\n    def validate(self,row,n,queenTracker,Finalboard,ans):\\n        # base case: when i move out of the last row. I have finished placing every queen in right position.\\n        if row == n:\\n            self.board(queenTracker,Finalboard,n,ans)\\n            return 1\\n        \\n        validPositionCount = 0\\n        \\n        for col in range(n):\\n            if self.isValidPosition(row,col,queenTracker):\\n                queenTracker[row] = col\\n                validPositionCount +=  self.validate(row+1,n,queenTracker,Finalboard,ans)\\n                \\n        return validPositionCount\\n    \\n    # check if there are no queen in particular col and in diagonal col\\n    def isValidPosition(self,row,col,queenTracker):\\n        for previousRow in range(row):\\n            colToCheck = queenTracker[previousRow]\\n            \\n            # check if they are in same col\\n            sameCol = False\\n            if col == colToCheck:\\n                sameCol = True\\n            \\'\\'\\'\\n            This can be written as\\n            sameCol = (col == colToCheck)\\n            \\'\\'\\'\\n\\n            # check diagonal => abs(x2 - x1) = abd(y2 - y1)\\n            sameDiagonal = False\\n            if abs(col - colToCheck) == abs(row - previousRow):\\n                sameDiagonal = True\\n            \\n            \\'\\'\\'\\n            This can be written as\\n            sameDiagonal = abs(col - colToCheck) == abs(row - previousRow)\\n            \\'\\'\\'\\n\\n            if sameCol or sameDiagonal:\\n                return False\\n            \\n        return True\\n    \\n    \\n    def board(self,queenTracker,Finalboard,n,ans):\\n        for row in range(len(queenTracker)):\\n            Finalboard[row] = \\'.\\'*(queenTracker[row]) + \\'Q\\' + \\'.\\'*(n-(queenTracker[row]) -1 )\\n        copy = Finalboard[:]\\n        ans.append(copy)\\n        \\n        return ans\\n\\t\\t\\n```\\n\\n### So basically we traverse the board, check if the queens are in right position. If yes then place the queen on baord. Else go back change the position of previous queen. check again and repeat until we get the right position.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```Finalboard = [[]*n for _ in range(n)]```\n```# when n = 4```\n``` \\n# each index is considered to be a row\\n        queenTracker = [0] * n # keep track of col in which queen is placed\\n```\n``` \\nif row == n:\\n            self.board(queenTracker,Finalboard,n,ans)\\n            return 1\\n# this will form the base case and we add queen at to the board. and we return 1 stating that we have completed placing all queen in their right position -- (this is just like an acknowlegment)\\n```\n```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        # creating a board\\n        ans = []\\n        Finalboard = [[]*n for _ in range(n)]\\n        \\n        # each index is considered to be a row\\n        queenTracker = [0] * n # keep track of col in which queen is placed\\n        self.validate(0 , n , queenTracker,Finalboard,ans)\\n        \\n        return ans\\n    \\n    def validate(self,row,n,queenTracker,Finalboard,ans):\\n        # base case: when i move out of the last row. I have finished placing every queen in right position.\\n        if row == n:\\n            self.board(queenTracker,Finalboard,n,ans)\\n            return 1\\n        \\n        validPositionCount = 0\\n        \\n        for col in range(n):\\n            if self.isValidPosition(row,col,queenTracker):\\n                queenTracker[row] = col\\n                validPositionCount +=  self.validate(row+1,n,queenTracker,Finalboard,ans)\\n                \\n        return validPositionCount\\n    \\n    # check if there are no queen in particular col and in diagonal col\\n    def isValidPosition(self,row,col,queenTracker):\\n        for previousRow in range(row):\\n            colToCheck = queenTracker[previousRow]\\n            \\n            # check if they are in same col\\n            sameCol = False\\n            if col == colToCheck:\\n                sameCol = True\\n            \\'\\'\\'\\n            This can be written as\\n            sameCol = (col == colToCheck)\\n            \\'\\'\\'\\n\\n            # check diagonal => abs(x2 - x1) = abd(y2 - y1)\\n            sameDiagonal = False\\n            if abs(col - colToCheck) == abs(row - previousRow):\\n                sameDiagonal = True\\n            \\n            \\'\\'\\'\\n            This can be written as\\n            sameDiagonal = abs(col - colToCheck) == abs(row - previousRow)\\n            \\'\\'\\'\\n\\n            if sameCol or sameDiagonal:\\n                return False\\n            \\n        return True\\n    \\n    \\n    def board(self,queenTracker,Finalboard,n,ans):\\n        for row in range(len(queenTracker)):\\n            Finalboard[row] = \\'.\\'*(queenTracker[row]) + \\'Q\\' + \\'.\\'*(n-(queenTracker[row]) -1 )\\n        copy = Finalboard[:]\\n        ans.append(copy)\\n        \\n        return ans\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650553,
                "title": "backtracking-with-time-and-space-complexity-explained",
                "content": "/*\\nTime Complexity : O(N!), we have N choices in the first row, N-1 in the second row, N-2 in the next and so on... which brings overall time complexity to O(N!)\\nspace Complexity : O(N*N). Required for board .\\n*/\\nclass Solution {\\npublic:\\n    bool isvalid(  vector< string > &grid, int row, int col)\\n    {\\n        //check for col\\n        for( int i=row;i>=0;i--)\\n            if(grid[i][col]==\\'Q\\')return false;\\n                 \\n        //check for left diag\\n        for( int i=row,j=col;i>=0 and j>=0;i--,j--)\\n            if(grid[i][j]==\\'Q\\')return false;\\n        \\n        //check for right diag\\n       for( int i=row,j=col;i>=0 and j<grid.size();i--,j++)\\n            if(grid[i][j]==\\'Q\\')return false; \\n        \\n        return true;\\n    }\\n    \\n    void dfs(  vector< string > &grid, int row, vector< vector< string > > &ret)\\n    {\\n       if(row==grid.size())  //if row==n that mean we have placed all queens at their corr pos\\n       {\\n           ret.push_back(grid);  // push the possible ans int ret vector\\n           return;\\n       }\\n       for( int col=0;col<grid.size();col++){ // check all possiblities int the given row\\n           if(isvalid(grid,row,col))  //check if it is valid or not\\n           {\\n               grid[row][col]=\\'Q\\';    //place the queen at valid pos\\n               dfs(grid,row+1,ret);    // solve rest sub problem \\n               grid[row][col]=\\'.\\';    // backtracking \\n               \\n           }\\n       }   \\n        \\n    }\\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n       vector< string >  grid( n,string(n,\\'.\\')); // 2d n*n matrix full of \\'.\\' \\n       vector< vector< string > > ret;\\n        dfs(grid,0,ret);\\n        return ret;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    bool isvalid(  vector< string > &grid, int row, int col)\\n    {\\n        //check for col\\n        for( int i=row;i>=0;i--)\\n            if(grid[i][col]==\\'Q\\')return false;\\n                 \\n        //check for left diag\\n        for( int i=row,j=col;i>=0 and j>=0;i--,j--)\\n            if(grid[i][j]==\\'Q\\')return false;\\n        \\n        //check for right diag\\n       for( int i=row,j=col;i>=0 and j<grid.size();i--,j++)\\n            if(grid[i][j]==\\'Q\\')return false; \\n        \\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1502327,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        res = []\\n        self.backtrack(board, 0, n, res)\\n        return res\\n    \\n    def backtrack(self, board, row, nq, res):\\n\\t\\t\\tif nq == 0:  #nq is number of queens, we start with n queens and keep reducing 1 each time we place a queen\\n            res.append([\"\".join(list) for list in board])\\n            return \\n        \\n        n = len(board)\\n        for i in range(n):  #trying to place Q in every col in this row\\n            board[row][i] = \"Q\"\\n            if self.isValid(board, row, i):  #if it is valid position, we go to next row( row+1) and try to place Q there\\n                self.backtrack(board, row+1, nq-1, res)  #nq represents num of queens we have not placed\\n            board[row][i] = \".\"  #backtracking, if this location is not valid or we have already obtained a solution\\n\\t\\t\\t\\t\\t\\t\\t\\t#with this location , we remove it to test other possiblities\\n    \\n    def isValid(self, board, i, j):\\n        n = len(board)\\n\\t\\t#since we are placing 1 queen in each row by backtracking, we don\\'t need to check the row \\n        \\n        for row in range(i):  #checking we have placed a Q in this column in previous rows\\n            if board[row][j] == \"Q\":\\n                return False\\n            \\n        row, col = i, j  \\n        while 0 <= row < n and 0<= col < n: # checking diagonally top-left\\n            if board[row][col] == \"Q\" and (row,col) != (i,j):\\n                return False\\n            row,col = row-1, col-1\\n        \\n        row, col = i, j\\n        while 0 <= row < n and 0<= col < n: # checking diagonally top-right\\n            if board[row][col] == \"Q\" and (row,col) != (i,j):\\n                return False\\n            row,col = row-1, col+1\\n\\n        return True\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def solveNQueens(self, n: int) -> List[List[str]]:\\n        board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n        res = []\\n        self.backtrack(board, 0, n, res)\\n        return res\\n    \\n    def backtrack(self, board, row, nq, res):\\n\\t\\t\\tif nq == 0:  #nq is number of queens, we start with n queens and keep reducing 1 each time we place a queen\\n            res.append([\"\".join(list) for list in board])\\n            return \\n        \\n        n = len(board)\\n        for i in range(n):  #trying to place Q in every col in this row\\n            board[row][i] = \"Q\"\\n            if self.isValid(board, row, i):  #if it is valid position, we go to next row( row+1) and try to place Q there\\n                self.backtrack(board, row+1, nq-1, res)  #nq represents num of queens we have not placed\\n            board[row][i] = \".\"  #backtracking, if this location is not valid or we have already obtained a solution\\n\\t\\t\\t\\t\\t\\t\\t\\t#with this location , we remove it to test other possiblities\\n    \\n    def isValid(self, board, i, j):\\n        n = len(board)\\n\\t\\t#since we are placing 1 queen in each row by backtracking, we don\\'t need to check the row \\n        \\n        for row in range(i):  #checking we have placed a Q in this column in previous rows\\n            if board[row][j] == \"Q\":\\n                return False\\n            \\n        row, col = i, j  \\n        while 0 <= row < n and 0<= col < n: # checking diagonally top-left\\n            if board[row][col] == \"Q\" and (row,col) != (i,j):\\n                return False\\n            row,col = row-1, col-1\\n        \\n        row, col = i, j\\n        while 0 <= row < n and 0<= col < n: # checking diagonally top-right\\n            if board[row][col] == \"Q\" and (row,col) != (i,j):\\n                return False\\n            row,col = row-1, col+1\\n\\n        return True\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367750,
                "title": "java-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> result= new ArrayList<>();\\n        placeQueen(n,Board,0,result);\\n        return result;\\n    }\\n    public void placeQueen(int n, char Board[][],int row, List<List<String>> result)\\n    {\\n        //Base Case\\n        if(row==n)\\n        {\\n            result.add(build(Board));\\n            return;\\n        }\\n         for(int col=0;col<n;col++)\\n         {\\n             if(canPlaceQueen(n,Board,row, col))\\n             {\\n                 Board[row][col]=\\'Q\\';\\n                 placeQueen(n,Board,row+1,result);\\n                 Board[row][col]=\\'.\\';\\n             }\\n         }\\n        \\n    }\\n    public Boolean canPlaceQueen(int n,char Board[][],int row, int col)\\n    {\\n       // check all rows for the current column\\n        for (int i = 0; i < row; i++) \\n        {\\n            if (Board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //check for 45 degree positions\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        //check for 135 positions\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (Board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n    public List build(char Board[][])\\n    {\\n        List<String> path = new ArrayList<>();\\n        for (int i = 0; i < Board.length; i++) {\\n            path.add(new String(Board[i]));\\n        }\\n        return path;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char Board[][]=new char[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                Board[i][j] = \\'.\\';\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1343559,
                "title": "java-recursion-backtracking-1ms-faster-than-80",
                "content": "```\\nclass Solution {\\n    List<List<String>> list;\\n    public List<List<String>> solveNQueens(int n) {\\n        list = new ArrayList<>();\\n        boolean[][] placed = new boolean[n][n];\\n        helper(0, n, placed);\\n        return list;\\n    }\\n    public void helper(int i, int n, boolean[][] placed) {\\n        if(i == n){\\n            List<String> al = new ArrayList<>();\\n            for(int x = 0; x < n; x++){\\n                String str = \"\";\\n                for(int y = 0; y < n; y++){\\n                    if(placed[x][y])\\n                        str += \\'Q\\';\\n                    else\\n                        str += \\'.\\';\\n                }\\n                al.add(str);\\n            }\\n            list.add(al);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(isSafe(i, j, placed)){\\n                placed[i][j] = true;\\n                helper(i+1, n, placed);\\n                placed[i][j] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] placed){\\n        for(int x = i-1; x >= 0; x--)\\n            if(placed[x][j])\\n                return false;\\n        for(int x = i-1, y = j-1; x >= 0 && y >= 0; x--, y--)\\n            if(placed[x][y])\\n                return false;\\n        for(int x = i-1, y = j+1; x >= 0 && y < placed.length; x--, y++)\\n            if(placed[x][y])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<List<String>> list;\\n    public List<List<String>> solveNQueens(int n) {\\n        list = new ArrayList<>();\\n        boolean[][] placed = new boolean[n][n];\\n        helper(0, n, placed);\\n        return list;\\n    }\\n    public void helper(int i, int n, boolean[][] placed) {\\n        if(i == n){\\n            List<String> al = new ArrayList<>();\\n            for(int x = 0; x < n; x++){\\n                String str = \"\";\\n                for(int y = 0; y < n; y++){\\n                    if(placed[x][y])\\n                        str += \\'Q\\';\\n                    else\\n                        str += \\'.\\';\\n                }\\n                al.add(str);\\n            }\\n            list.add(al);\\n            return;\\n        }\\n        for(int j = 0; j < n; j++){\\n            if(isSafe(i, j, placed)){\\n                placed[i][j] = true;\\n                helper(i+1, n, placed);\\n                placed[i][j] = false;\\n            }\\n        }\\n    }\\n    public boolean isSafe(int i, int j, boolean[][] placed){\\n        for(int x = i-1; x >= 0; x--)\\n            if(placed[x][j])\\n                return false;\\n        for(int x = i-1, y = j-1; x >= 0 && y >= 0; x--, y--)\\n            if(placed[x][y])\\n                return false;\\n        for(int x = i-1, y = j+1; x >= 0 && y < placed.length; x--, y++)\\n            if(placed[x][y])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280074,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<int> col;\\n    unordered_set<int> diag;\\n    unordered_set<int> antiDiag;\\n    void solve(vector<vector<string>> &result, vector<string> &cand, int row) {\\n        if (row >= cand.size()) {\\n            result.push_back(cand);\\n        } else {\\n            for(int c=0; c<cand.size(); c++) {\\n                if (!col.count(c) && !diag.count(row+c) && !antiDiag.count(row-c)) {\\n                    col.insert(c); diag.insert(row+c); antiDiag.insert(row-c);\\n                    cand[row][c] = \\'Q\\';\\n                    solve(result, cand, row+1);\\n                    col.erase(c); diag.erase(row+c); antiDiag.erase(row-c);\\n                    cand[row][c] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> cand(n, string(n, \\'.\\'));\\n        solve(result, cand, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_set<int> col;\\n    unordered_set<int> diag;\\n    unordered_set<int> antiDiag;\\n    void solve(vector<vector<string>> &result, vector<string> &cand, int row) {\\n        if (row >= cand.size()) {\\n            result.push_back(cand);\\n        } else {\\n            for(int c=0; c<cand.size(); c++) {\\n                if (!col.count(c) && !diag.count(row+c) && !antiDiag.count(row-c)) {\\n                    col.insert(c); diag.insert(row+c); antiDiag.insert(row-c);\\n                    cand[row][c] = \\'Q\\';\\n                    solve(result, cand, row+1);\\n                    col.erase(c); diag.erase(row+c); antiDiag.erase(row-c);\\n                    cand[row][c] = \\'.\\';\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> result;\\n        vector<string> cand(n, string(n, \\'.\\'));\\n        solve(result, cand, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195243,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    \\n    bool isSafe(int &r, int &c, int dp[][10], int &n)\\n    {\\n        // Col check\\n        for(int i=0; i<r; i++)\\n        {\\n            if(dp[i][c])\\n                return false;\\n        }\\n        \\n        // left diagonal\\n        for(int i=r, j=c; i>=0 and j>=0; i--, j--)\\n        {\\n            if(dp[i][j])\\n                return false;\\n        }\\n        \\n        // Right diagonal\\n        for(int i=r, j=c; i>=0 and j<n; i--, j++)\\n        {\\n            if(dp[i][j])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void nQueen(int dp[][10], int r, int &n)\\n    {\\n        if(r == n)\\n        {\\n            vector<string>oneSoln; \\n            string oneR;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                for(int j=0; j<n; j++)\\n                {\\n                    if(dp[i][j])\\n                        oneR += \\'Q\\';\\n                    else\\n                        oneR += \\'.\\';\\n                }\\n                oneSoln.push_back(oneR);\\n                oneR = \"\";\\n            }\\n            \\n            ans.push_back(oneSoln);\\n            return;\\n        }\\n        \\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            if(isSafe(r, j, dp, n))\\n            {\\n                dp[r][j] = 1;        \\n                nQueen(dp, r+1, n);\\n                dp[r][j] = 0;\\n            }\\n        }\\n\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n        int dp[10][10] = {0};    \\n        \\n        nQueen(dp, 0, n);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    \\n    bool isSafe(int &r, int &c, int dp[][10], int &n)\\n    {\\n        // Col check\\n        for(int i=0; i<r; i++)\\n        {\\n            if(dp[i][c])\\n                return false;\\n        }\\n        \\n        // left diagonal\\n        for(int i=r, j=c; i>=0 and j>=0; i--, j--)\\n        {\\n            if(dp[i][j])\\n                return false;\\n        }\\n        \\n        // Right diagonal\\n        for(int i=r, j=c; i>=0 and j<n; i--, j++)\\n        {\\n            if(dp[i][j])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void nQueen(int dp[][10], int r, int &n)\\n    {\\n        if(r == n)\\n        {\\n            vector<string>oneSoln; \\n            string oneR;\\n            \\n            for(int i=0; i<n; i++)\\n            {\\n                for(int j=0; j<n; j++)\\n                {\\n                    if(dp[i][j])\\n                        oneR += \\'Q\\';\\n                    else\\n                        oneR += \\'.\\';\\n                }\\n                oneSoln.push_back(oneR);\\n                oneR = \"\";\\n            }\\n            \\n            ans.push_back(oneSoln);\\n            return;\\n        }\\n        \\n        \\n        for(int j=0; j<n; j++)\\n        {\\n            if(isSafe(r, j, dp, n))\\n            {\\n                dp[r][j] = 1;        \\n                nQueen(dp, r+1, n);\\n                dp[r][j] = 0;\\n            }\\n        }\\n\\n    }\\n    \\n    vector<vector<string>> solveNQueens(int n) {\\n        \\n        int dp[10][10] = {0};    \\n        \\n        nQueen(dp, 0, n);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428325,
                "title": "1ms-java-solution-beat-99-with-explanations",
                "content": "First thought for solving this problem is Brute force. We just pick all the cell for each Queen and check if the board is valid or not. The big O complexity will n^2 * (n^2 \\u2013 1) * \\u2026 (n ^2 \\u2013 n + 1) which is n ^ (2n)\\nHere is the code and the running time is 167ms:\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        String[][] board = new String[n][n];\\n        for(int i = 0; i < board.length; i ++) {\\n            for(int j = 0; j < board[0].length; j ++) {\\n                board[i][j] = \".\";\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<List<String>> ();\\n        backTrack(board, result, n, 0, 0, n);\\n        return result;\\n    }\\n    \\n    public void backTrack(String[][] board, List<List<String>> result, int number, int row, int col, int total) {\\n    \\tif(col >= total) {\\n    \\t\\tcol = 0;\\n    \\t\\trow ++;\\n    \\t}\\n    \\t\\n    \\tif(row >= total) {\\n    \\t\\treturn;\\n    \\t}\\n    \\t\\n    \\tif(board[row][col] == \".\") {\\n    \\t\\tboard[row][col] = \"Q\";\\n    \\t\\tif(isValidBoard(board, row, col)) {\\n    \\t\\t\\tif(number == 1) {\\n    \\t\\t\\t\\taddToList(board, result);\\n    \\t\\t\\t} else {\\n        \\t\\t\\tbackTrack(board, result, number - 1, row, col + 1, total);    \\t\\t\\t\\t\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tboard[row][col] = \".\";\\n    \\t\\tbackTrack(board, result, number, row, col + 1, total);\\n    \\t} else {\\n    \\t\\tbackTrack(board, result, number, row, col + 1, total);\\n    \\t}\\n    }\\n  \\n    \\n    private boolean isValidBoard(String[][] board, int row, int col) {\\n    \\tfor(int i = 0; i < board.length; i++) {\\n    \\t\\tif(i != col && board[row][i] == \"Q\") {\\n    \\t\\t\\t//System.out.println(col + \",\" + i + \", \" + board[row][i]);\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"row...\");\\n    \\tfor(int i = 0; i < board[0].length; i++) {\\n    \\t\\tif(i != row && board[i][col] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"col...\");\\n    \\t//left up\\n    \\tint i = row - 1;\\n    \\tint j = col - 1;\\n    \\twhile(i >= 0 && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj --;\\n    \\t}\\n    \\t\\n    \\t//right down\\n    \\ti = row + 1;\\n    \\tj = col + 1;\\n    \\twhile(i < board.length && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\t//left down\\n    \\ti = row - 1;\\n    \\tj = col + 1;\\n    \\twhile(i >= 0 && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\ti = row + 1;\\n    \\tj = col - 1;\\n    \\twhile(i < board.length && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj --;\\n    \\t}\\n    \\treturn true;\\n    }\\n    \\n    private void addToList(String[][] board, List<List<String>> result) {\\n    \\tList<String> temp = new ArrayList<String> ();\\n    \\tfor(int i = 0; i < board.length; i ++) {\\n    \\t\\tStringBuilder sb = new StringBuilder();\\n    \\t\\tfor(int j = 0; j < board[0].length; j++) {\\n    \\t\\t\\tsb.append(board[i][j]);\\n    \\t\\t}\\n    \\t\\ttemp.add(sb.toString());\\n    \\t}\\n    \\tresult.add(new ArrayList<String>(temp));\\n    }\\n}\\n```\\n\\nHow do we improve it? Because we know for each row there could only be one Queen, we can take advantage of this. Instead of picking each cell for one Queen, we only need to pick the column number for each Queen. For one queen, the possibility will be n. And the total complexity will down from n ^ (2n) to n ^ n or n! . \\nHere is the code and the running time is 4ms:\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        String[][] board = new String[n][n];\\n        for(int i = 0; i < board.length; i ++) {\\n            for(int j = 0; j < board[0].length; j ++) {\\n                board[i][j] = \".\";\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<List<String>> ();\\n        helper(board, result, 0);\\n        return result;\\n    }\\n    \\n    public void helper(String[][] board, List<List<String>> result, int row) {\\n    \\tif(row == board.length) {\\n    \\t\\taddToList(board, result);\\n    \\t} else {\\n    \\t\\tfor(int c = 0; c < board.length; c ++) {\\n    \\t\\t\\tif(isValidBoard(board, row, c)) {\\n    \\t\\t\\t\\tboard[row][c] = \"Q\";\\n        \\t\\t\\thelper(board, result, row + 1);\\n        \\t\\t\\tboard[row][c] = \".\";\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n\\n  \\n    \\n    private boolean isValidBoard(String[][] board, int row, int col) {\\n    \\tfor(int i = 0; i < board.length; i++) {\\n    \\t\\tif(i != col && board[row][i] == \"Q\") {\\n    \\t\\t\\t//System.out.println(col + \",\" + i + \", \" + board[row][i]);\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"row...\");\\n    \\tfor(int i = 0; i < board[0].length; i++) {\\n    \\t\\tif(i != row && board[i][col] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"col...\");\\n    \\t//left up\\n    \\tint i = row - 1;\\n    \\tint j = col - 1;\\n    \\twhile(i >= 0 && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj --;\\n    \\t}\\n    \\t\\n    \\t//right down\\n    \\ti = row + 1;\\n    \\tj = col + 1;\\n    \\twhile(i < board.length && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\t//left down\\n    \\ti = row - 1;\\n    \\tj = col + 1;\\n    \\twhile(i >= 0 && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\ti = row + 1;\\n    \\tj = col - 1;\\n    \\twhile(i < board.length && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj --;\\n    \\t}\\n    \\treturn true;\\n    }\\n\\n    private void addToList(String[][] board, List<List<String>> result) {\\n    \\tList<String> temp = new ArrayList<String> ();\\n    \\tfor(int i = 0; i < board.length; i ++) {\\n    \\t\\tStringBuilder sb = new StringBuilder();\\n    \\t\\tfor(int j = 0; j < board[0].length; j++) {\\n    \\t\\t\\tsb.append(board[i][j]);\\n    \\t\\t}\\n    \\t\\ttemp.add(sb.toString());\\n    \\t}\\n    \\tresult.add(new ArrayList<String>(temp));\\n    }\\n}\\n```\\n\\nThe validation method is taking up to Big(0) n to validate the board. What if we can sacrifice some memory space and improve our validating speed.\\nSince we use row number to identify each unique Queen, we can guarantee each row will only have one Queen. Which means we only need to validate column and two diagonals.\\nFor column, it is easy, we just need a 1-D Boolean array to check if there is any Queen in that column,\\nFor diagonals, I find it hard to find any patterns that we can use to use only O(1) to validate until I draw the example.\\n(0,0),(0,1),(0,2),(0,3)\\n(1,0),(1,1),(1,2),(1,3)\\n(2,0),(2,1),(2,2),(2,3)\\n(3,0),(3,1),(3,2),(3,3)\\nI find for diagonals left top to right down (0,0), (1,1), (2,2),(3,3) / (0,1), (1,2), (2,3) \\u2026 The difference between row and column are always the same: 0 \\u2013 0 = 0, 1 \\u2013 1 = 0, 2 \\u2013 2 = 0\\u2026.. 0 \\u2013 1 = - 1, 1 \\u2013 2 = -1, 2 \\u2013 3 = -1, so we can create a Boolean array to record the difference between row and col.\\nFor diagonals right top to left down, the patterns are the sums are always the same. (0,3), (1,2), (2,1), (3,0), so that we can create a Boolean array to record the sum of row and col.\\nHere is the final 1ms code with the O(1) validation method:\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        String[][] board = new String[n][n];\\n        boolean[] cols = new boolean[n];\\n        boolean[] sums  = new boolean[n + n];\\n        boolean[] diffs = new boolean[n + n];// + n to avoid negative index\\n        for(int i = 0; i < board.length; i ++) {\\n            for(int j = 0; j < board[0].length; j ++) {\\n                board[i][j] = \".\";\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<List<String>> ();\\n        helper(board, result, 0, cols, sums, diffs);\\n        return result;\\n    }\\n    \\n    public void helper(String[][] board, List<List<String>> result, int row, boolean[] cols, boolean[] sums, boolean[] diffs) {\\n    \\tif(row == board.length) {\\n    \\t\\taddToList(board, result);\\n    \\t} else {\\n    \\t\\tfor(int c = 0; c < board.length; c ++) {\\n    \\t\\t\\tif(isValidBoard(board, row, c, cols, sums, diffs)) {\\n    \\t\\t\\t\\tboard[row][c] = \"Q\";\\n        \\t\\t\\tcols[c] = true;\\n        \\t\\t\\tsums[row + c] = true;;\\n        \\t\\t\\tdiffs[row - c + board.length] = true;\\n        \\t\\t\\thelper(board, result, row + 1, cols, sums, diffs);\\n        \\t\\t\\tcols[c] = false;\\n        \\t\\t\\tsums[row + c] = false;\\n        \\t\\t\\tdiffs[row - c + board.length] = false;\\n        \\t\\t\\tboard[row][c] = \".\";\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n\\n  \\n    \\n    private boolean isValidBoard(String[][] board, int row, int col, boolean[] cols, boolean[] sums, boolean[] diffs) {\\n    \\tif(cols[col]) {\\n    \\t\\treturn false;\\n    \\t}\\n\\n    \\tif(sums[row + col]) {\\n    \\t\\treturn false;\\n    \\t}\\n\\n    \\tif(diffs[row - col + board.length]) {\\n    \\t\\treturn false;\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n    \\n    private void addToList(String[][] board, List<List<String>> result) {\\n    \\tList<String> temp = new ArrayList<String> ();\\n    \\tfor(int i = 0; i < board.length; i ++) {\\n    \\t\\tStringBuilder sb = new StringBuilder();\\n    \\t\\tfor(int j = 0; j < board[0].length; j++) {\\n    \\t\\t\\tsb.append(board[i][j]);\\n    \\t\\t}\\n    \\t\\ttemp.add(sb.toString());\\n    \\t}\\n    \\tresult.add(new ArrayList<String>(temp));\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        String[][] board = new String[n][n];\\n        for(int i = 0; i < board.length; i ++) {\\n            for(int j = 0; j < board[0].length; j ++) {\\n                board[i][j] = \".\";\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<List<String>> ();\\n        backTrack(board, result, n, 0, 0, n);\\n        return result;\\n    }\\n    \\n    public void backTrack(String[][] board, List<List<String>> result, int number, int row, int col, int total) {\\n    \\tif(col >= total) {\\n    \\t\\tcol = 0;\\n    \\t\\trow ++;\\n    \\t}\\n    \\t\\n    \\tif(row >= total) {\\n    \\t\\treturn;\\n    \\t}\\n    \\t\\n    \\tif(board[row][col] == \".\") {\\n    \\t\\tboard[row][col] = \"Q\";\\n    \\t\\tif(isValidBoard(board, row, col)) {\\n    \\t\\t\\tif(number == 1) {\\n    \\t\\t\\t\\taddToList(board, result);\\n    \\t\\t\\t} else {\\n        \\t\\t\\tbackTrack(board, result, number - 1, row, col + 1, total);    \\t\\t\\t\\t\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tboard[row][col] = \".\";\\n    \\t\\tbackTrack(board, result, number, row, col + 1, total);\\n    \\t} else {\\n    \\t\\tbackTrack(board, result, number, row, col + 1, total);\\n    \\t}\\n    }\\n  \\n    \\n    private boolean isValidBoard(String[][] board, int row, int col) {\\n    \\tfor(int i = 0; i < board.length; i++) {\\n    \\t\\tif(i != col && board[row][i] == \"Q\") {\\n    \\t\\t\\t//System.out.println(col + \",\" + i + \", \" + board[row][i]);\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"row...\");\\n    \\tfor(int i = 0; i < board[0].length; i++) {\\n    \\t\\tif(i != row && board[i][col] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"col...\");\\n    \\t//left up\\n    \\tint i = row - 1;\\n    \\tint j = col - 1;\\n    \\twhile(i >= 0 && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj --;\\n    \\t}\\n    \\t\\n    \\t//right down\\n    \\ti = row + 1;\\n    \\tj = col + 1;\\n    \\twhile(i < board.length && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\t//left down\\n    \\ti = row - 1;\\n    \\tj = col + 1;\\n    \\twhile(i >= 0 && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\ti = row + 1;\\n    \\tj = col - 1;\\n    \\twhile(i < board.length && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj --;\\n    \\t}\\n    \\treturn true;\\n    }\\n    \\n    private void addToList(String[][] board, List<List<String>> result) {\\n    \\tList<String> temp = new ArrayList<String> ();\\n    \\tfor(int i = 0; i < board.length; i ++) {\\n    \\t\\tStringBuilder sb = new StringBuilder();\\n    \\t\\tfor(int j = 0; j < board[0].length; j++) {\\n    \\t\\t\\tsb.append(board[i][j]);\\n    \\t\\t}\\n    \\t\\ttemp.add(sb.toString());\\n    \\t}\\n    \\tresult.add(new ArrayList<String>(temp));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        String[][] board = new String[n][n];\\n        for(int i = 0; i < board.length; i ++) {\\n            for(int j = 0; j < board[0].length; j ++) {\\n                board[i][j] = \".\";\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<List<String>> ();\\n        helper(board, result, 0);\\n        return result;\\n    }\\n    \\n    public void helper(String[][] board, List<List<String>> result, int row) {\\n    \\tif(row == board.length) {\\n    \\t\\taddToList(board, result);\\n    \\t} else {\\n    \\t\\tfor(int c = 0; c < board.length; c ++) {\\n    \\t\\t\\tif(isValidBoard(board, row, c)) {\\n    \\t\\t\\t\\tboard[row][c] = \"Q\";\\n        \\t\\t\\thelper(board, result, row + 1);\\n        \\t\\t\\tboard[row][c] = \".\";\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n\\n  \\n    \\n    private boolean isValidBoard(String[][] board, int row, int col) {\\n    \\tfor(int i = 0; i < board.length; i++) {\\n    \\t\\tif(i != col && board[row][i] == \"Q\") {\\n    \\t\\t\\t//System.out.println(col + \",\" + i + \", \" + board[row][i]);\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"row...\");\\n    \\tfor(int i = 0; i < board[0].length; i++) {\\n    \\t\\tif(i != row && board[i][col] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t}\\n    \\t//System.out.println(\"col...\");\\n    \\t//left up\\n    \\tint i = row - 1;\\n    \\tint j = col - 1;\\n    \\twhile(i >= 0 && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj --;\\n    \\t}\\n    \\t\\n    \\t//right down\\n    \\ti = row + 1;\\n    \\tj = col + 1;\\n    \\twhile(i < board.length && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\t//left down\\n    \\ti = row - 1;\\n    \\tj = col + 1;\\n    \\twhile(i >= 0 && j < board.length) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti --;\\n    \\t\\tj ++;\\n    \\t}\\n    \\t\\n    \\ti = row + 1;\\n    \\tj = col - 1;\\n    \\twhile(i < board.length && j >= 0) {\\n    \\t\\tif(board[i][j] == \"Q\") {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\ti ++;\\n    \\t\\tj --;\\n    \\t}\\n    \\treturn true;\\n    }\\n\\n    private void addToList(String[][] board, List<List<String>> result) {\\n    \\tList<String> temp = new ArrayList<String> ();\\n    \\tfor(int i = 0; i < board.length; i ++) {\\n    \\t\\tStringBuilder sb = new StringBuilder();\\n    \\t\\tfor(int j = 0; j < board[0].length; j++) {\\n    \\t\\t\\tsb.append(board[i][j]);\\n    \\t\\t}\\n    \\t\\ttemp.add(sb.toString());\\n    \\t}\\n    \\tresult.add(new ArrayList<String>(temp));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413253,
                "title": "my-easy-understand-n-queens-solutions-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/n-queens/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n\\n## Problem\\n\\n> The n-queens puzzle is the problem of placing `n` queens on an `n\\xD7n` chessboard such that no two queens attack each other.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/rk4qd.jpg \"From LeetCode\")\\n\\n> Given an integer `n`, return all distinct solutions to the n-queens puzzle.\\n\\n> Each solution contains a distinct board configuration of the n-queens\\' placement, where `Q` and `.` both indicate a queen and an empty space respectively.\\n\\n**Note:** A queen can attack other queens that are at the same `row` or `column` or at the `diagonal` line.\\n\\n**Example:** \\n\\n```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nEnumerate all possible placements of queens on a `nxn` chessboard and check if each is valid.\\n\\n**Time:** `O(N^N)`\\n**Space:** `O(1)` if we do not consider the output list.\\n\\n\\n### Backtracking\\n\\nThe basic idea is to examine each row and use an array `attack` to restrict the possibilities in the future searching.\\n\\nCheck out the comments. Be careful about the following aspects:\\n\\n- Why will we stop? In other words, what is the base case?\\n- How do we make string generation more efficiently? `StringBuilder`\\n- Why should we initialize `attack` array with `int` type rather than `boolean`?\\n\\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\\n\\nThe graph is from LeetCode solution section.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/1sasw.jpg)\\n\\nEach time we pick a queen `(i, j)` we need to update all the attacked positions below it, which include three cases as shown in the graph:\\n\\n- Left-Below positions\\n- Below positions\\n- Right-Below positions\\n\\nNotice that we cannot use `boolean` since some attacked positions might be overlapped.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/owjlb.png)\\n\\nIn the example above, when we restore attacked position for queen `B`, the orange position will be restored to no-attack state if we use `true/false`; however, it is still under attack by queen `A`.\\n\\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/a2rtf.jpg)\\n\\n**Time:** `O(N x N!)`. There is `N` possibilities to put the first queen, then no more than `N(N-2)` to put the second one, and no more than `N(N-2)(N-4)` to put the third one, and so forth. In total, there are `N` layers. The number of calls of `backtracking` at each layer is upper bounded by `N!`. (not consider string construction)\\n**Space:** `O(N^2)` since there are call stacks and `attack` array (do not consider output).\\n\\nThe space complexity can be optimized by using `N`-size array `rows`, `dale`, and `hill`. Each element of them denotes a specific vertical line or diagonal line that a queen can attack.\\n\\nFrom LeetCode solution section:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/oujkh.jpg)\\n\\n\\n\\n\\n## N-Queens II\\n\\nReturns the number of solutions. Modify based on the above solution.\\n\\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nInput: 4\\nOutput: [\\n [\".Q..\",  // Solution 1\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",  // Solution 2\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above.\\n```\n```java\\npublic List<List<String>> solveNQueens(int n) {\\n  List<List<String>> result = new ArrayList<>();\\n  List<Integer> queens = new ArrayList<>(); // store (i, j) where to place queens\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  backtrack(0, n, queens, attack, result);\\n  return result;\\n}\\n\\n// d is the depth (here it means the current row)\\n// queens stores the col of a placed queen\\nprivate void backtrack(int d, int n, List<Integer> queens, int[][] attack, List<List<String>> result) {\\n  // base case\\n  if (d == n) {\\n    // Init dot builder\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(\".\");\\n    // Set queen\\n    List<String> strList = new ArrayList<>();\\n    for (int row = 0; row < n; ++row) {\\n      int col = queens.get(row);\\n      sb.setCharAt(col, \\'Q\\');\\n      strList.add(sb.toString());\\n      sb.setCharAt(col, \\'.\\');\\n    }\\n    result.add(strList);\\n    return;\\n  }\\n  // backtrack\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      // pick\\n      queens.add(i);\\n      updateAttack(d, i, n, attack);\\n      backtrack(d + 1, n, queens, attack, result);\\n      // restore\\n      queens.remove(queens.size() - 1);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n}\\n```\n```java\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```\n```java\\npublic int totalNQueens(int n) {\\n  int[][] attack = new int[n][n];  // > 0 -> could be attacked\\n  return backtrack(0, n, attack);\\n}\\n\\n// d is the depth (here it means the current row)\\nprivate int backtrack(int d, int n, int[][] attack) {\\n  // base case\\n  if (d == n) {\\n    return 1;\\n  }\\n  // backtrack\\n  int count = 0;\\n  for (int i = 0; i < n; ++i) {\\n    if (attack[d][i] == 0) {\\n      updateAttack(d, i, n, attack);\\n      count += backtrack(d + 1, n, attack);\\n      restoreAttack(d, i, n, attack);\\n    }\\n  }\\n  return count;\\n}\\n\\n\\nprivate void updateAttack(int i, int j, int n, int[][] attack) {\\n  // update all below/hill/dale positions by +1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] += 1; // mid\\n    if (j - offset >= 0) attack[k][j - offset] += 1; // left\\n    if (j + offset < n) attack[k][j + offset] += 1; // right\\n  }\\n}\\n\\nprivate void restoreAttack(int i, int j, int n, int[][] attack) {\\n  // restore all below/hill/dale positions by -1\\n  for (int k = i + 1, offset = 1; k < n; ++k, ++offset) {\\n    attack[k][j] -= 1;\\n    if (j - offset >= 0) attack[k][j - offset] -= 1; // left\\n    if (j + offset < n) attack[k][j + offset] -= 1; // right\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336479,
                "title": "2ms-java-backtracking-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] chess = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                chess[i][j] = \\'.\\';\\n            }\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        backtrack(res, chess, 0);\\n        return res;\\n        \\n    }\\n    \\n    private void backtrack(List<List<String>> res, char[][] chess, int row){\\n        if(row == chess.length){\\n            List<String> temp = new ArrayList<>();\\n            for(char[] ch: chess){\\n                temp.add(new String(ch));\\n            }\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        for(int col = 0; col < chess[0].length; col++){\\n            if(valid(chess, row, col)){\\n                chess[row][col] = \\'Q\\';\\n                backtrack(res, chess, row + 1);\\n                chess[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    private boolean valid(char[][] chess, int row, int col){\\n        for(int i = 0; i < row; i++)\\n            if(chess[i][col] == \\'Q\\') return false;\\n        for(int i = row - 1, j = col + 1; i >= 0 && j < chess.length; i--, j++)\\n            if(chess[i][j] == \\'Q\\') return false;\\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\\n            if(chess[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n}\\n```\\nBecause the building is from top to bottom, no need to check -135 degree and -45 degree.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        char[][] chess = new char[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                chess[i][j] = \\'.\\';\\n            }\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        backtrack(res, chess, 0);\\n        return res;\\n        \\n    }\\n    \\n    private void backtrack(List<List<String>> res, char[][] chess, int row){\\n        if(row == chess.length){\\n            List<String> temp = new ArrayList<>();\\n            for(char[] ch: chess){\\n                temp.add(new String(ch));\\n            }\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        for(int col = 0; col < chess[0].length; col++){\\n            if(valid(chess, row, col)){\\n                chess[row][col] = \\'Q\\';\\n                backtrack(res, chess, row + 1);\\n                chess[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n    \\n    private boolean valid(char[][] chess, int row, int col){\\n        for(int i = 0; i < row; i++)\\n            if(chess[i][col] == \\'Q\\') return false;\\n        for(int i = row - 1, j = col + 1; i >= 0 && j < chess.length; i--, j++)\\n            if(chess[i][j] == \\'Q\\') return false;\\n        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\\n            if(chess[i][j] == \\'Q\\') return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270575,
                "title": "javascript-solution-using-dfs-with-explanation",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nvar solveNQueens = function(n) {\\n    const boards = [];\\n    /*\\n        board example:\\n            [\\n                [. . . .],\\n                [. . . .],\\n                [. . . .],\\n                [. . . .],\\n            ]\\n\\n        col_occupied:\\n            n = 4, [false, false, false, false]\\n    */\\n    const col_occupied = Array(n-1).fill(false);\\n    \\n    /*\\n        slash_diagonal_occupied:\\n            n = 4, 2*n-2 = 6, [false, false, false, false, false, false]\\n\\t\\t\\tmax col,row = 3,3, therefore we only need 6.  eg: [0,1,2,3,4,5].length === 6\\n    */\\n    const slash_diag_top_right_occupied = Array(2*n-2).fill(false);\\n    \\n    /*\\n        back_slash_diagonal_occupied:\\n            n = 4, 2*n-2 = 6, [false, false, false, false, false, false]\\n\\t\\t\\tmax col,row = 3,3, therefore we only need 6.  eg: [0,1,2,3,4,5].length === 6\\n    */\\n    const back_slash_top_left_occupied = Array(2*n-2).fill(false);\\n    \\n    function isValid(row, col) {\\n        /* \\n            if column, slash, or backslash is occupied it is set to true since we initialize false(not placed)\\n            since we are placing a queen into this row,col spot, if there is a conflict return true and use\\n            the bang(!) to return false, therefore isValid is false if spot is unavailable\\n       */\\n        return !(col_occupied[col] || slash_diag_top_right_occupied[row+col] || back_slash_top_left_occupied[row-col+n-1]);\\n    }\\n    \\n    function nQueens(board, row) {\\n        \\n        // if base case is hit, then there is a valid queens board\\n        if(row === n) {\\n            // create board copy and push into boards(results)\\n            const result = [];\\n            for(let r of board) result.push(r.join(\\'\\'))\\n            boards.push(result);\\n            return;\\n        }\\n        \\n        for(let col = 0; col < n; col++) {\\n            /*\\n                if there is no placement, then do not continue board placement / recursion calls\\n                otherwise, continue until it hits the base case\\n            */\\n            if (isValid(row, col)) {\\n                board[row][col] = \\'Q\\';\\n                col_occupied[col] = true;\\n                slash_diag_top_right_occupied[row+col] = true;\\n                back_slash_top_left_occupied[row-col+n-1] = true\\n                \\n                nQueens(board, row+1);\\n                \\n                // reset board\\n                board[row][col] = \\'.\\';\\n                col_occupied[col] = false;\\n                slash_diag_top_right_occupied[row+col] = false;\\n                back_slash_top_left_occupied[row-col+n-1] = false;\\n            }\\n        }\\n    }\\n\\n    const board = createBoard(n);\\n    nQueens(board, 0);\\n    \\n    return boards;\\n};\\n\\nfunction createBoard(n) {\\n    const board = [];\\n\\n    for(let i = 0; i < n; i++) {\\n        board.push(\\'.\\'.repeat(n).split(\\'\\'));\\n    }\\n\\n    return board;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nvar solveNQueens = function(n) {\\n    const boards = [];\\n    /*\\n        board example:\\n            [\\n                [. . . .],\\n                [. . . .],\\n                [. . . .],\\n                [. . . .],\\n            ]\\n\\n        col_occupied:\\n            n = 4, [false, false, false, false]\\n    */\\n    const col_occupied = Array(n-1).fill(false);\\n    \\n    /*\\n        slash_diagonal_occupied:\\n            n = 4, 2*n-2 = 6, [false, false, false, false, false, false]\\n\\t\\t\\tmax col,row = 3,3, therefore we only need 6.  eg: [0,1,2,3,4,5].length === 6\\n    */\\n    const slash_diag_top_right_occupied = Array(2*n-2).fill(false);\\n    \\n    /*\\n        back_slash_diagonal_occupied:\\n            n = 4, 2*n-2 = 6, [false, false, false, false, false, false]\\n\\t\\t\\tmax col,row = 3,3, therefore we only need 6.  eg: [0,1,2,3,4,5].length === 6\\n    */\\n    const back_slash_top_left_occupied = Array(2*n-2).fill(false);\\n    \\n    function isValid(row, col) {\\n        /* \\n            if column, slash, or backslash is occupied it is set to true since we initialize false(not placed)\\n            since we are placing a queen into this row,col spot, if there is a conflict return true and use\\n            the bang(!) to return false, therefore isValid is false if spot is unavailable\\n       */\\n        return !(col_occupied[col] || slash_diag_top_right_occupied[row+col] || back_slash_top_left_occupied[row-col+n-1]);\\n    }\\n    \\n    function nQueens(board, row) {\\n        \\n        // if base case is hit, then there is a valid queens board\\n        if(row === n) {\\n            // create board copy and push into boards(results)\\n            const result = [];\\n            for(let r of board) result.push(r.join(\\'\\'))\\n            boards.push(result);\\n            return;\\n        }\\n        \\n        for(let col = 0; col < n; col++) {\\n            /*\\n                if there is no placement, then do not continue board placement / recursion calls\\n                otherwise, continue until it hits the base case\\n            */\\n            if (isValid(row, col)) {\\n                board[row][col] = \\'Q\\';\\n                col_occupied[col] = true;\\n                slash_diag_top_right_occupied[row+col] = true;\\n                back_slash_top_left_occupied[row-col+n-1] = true\\n                \\n                nQueens(board, row+1);\\n                \\n                // reset board\\n                board[row][col] = \\'.\\';\\n                col_occupied[col] = false;\\n                slash_diag_top_right_occupied[row+col] = false;\\n                back_slash_top_left_occupied[row-col+n-1] = false;\\n            }\\n        }\\n    }\\n\\n    const board = createBoard(n);\\n    nQueens(board, 0);\\n    \\n    return boards;\\n};\\n\\nfunction createBoard(n) {\\n    const board = [];\\n\\n    for(let i = 0; i < n; i++) {\\n        board.push(\\'.\\'.repeat(n).split(\\'\\'));\\n    }\\n\\n    return board;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205794,
                "title": "javascript-o-n-time-o-n-space-per-solution-backtracking",
                "content": "```javascript\\n/**\\n * Time: O(n!)\\n * Space: O(n) per solution\\n * n - # of queens\\n */\\n\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nfunction solveNQueens(n) {\\n  const solutions = [];\\n  explore(n, solutions, 0, []);\\n  return solutions.map(solution =>\\n    solution.map(col => \\'.\\'.repeat(col) + \\'Q\\' + \\'.\\'.repeat(n - col - 1))\\n  );\\n}\\n\\n/**\\n * @param {number[]} colPlacements\\n * @param {number} col\\n * @return {boolean}\\n */\\nfunction isValid(colPlacements, col) {\\n  for (let row = 0; row < colPlacements.length; row++) {\\n    const diffX = Math.abs(colPlacements[row] - col);\\n    const diffY = colPlacements.length - row;\\n\\n    if (!diffX || diffX === diffY) { // same column or diagonal\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} solutions\\n * @param {number} row\\n * @param {number[]} colPlacements\\n * @return {void}\\n */\\nfunction explore(n, solutions, row, colPlacements) {\\n  if (row === n) {\\n    return solutions.push(colPlacements.slice());\\n  }\\n\\n  for (let col = 0; col < n; col++) {\\n    if (!isValid(colPlacements, col)) {\\n      continue;\\n    }\\n\\n    colPlacements.push(col);\\n    explore(n, solutions, row + 1, colPlacements);\\n    colPlacements.pop();\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n!)\\n * Space: O(n) per solution\\n * n - # of queens\\n */\\n\\n/**\\n * @param {number} n\\n * @return {string[][]}\\n */\\nfunction solveNQueens(n) {\\n  const solutions = [];\\n  explore(n, solutions, 0, []);\\n  return solutions.map(solution =>\\n    solution.map(col => \\'.\\'.repeat(col) + \\'Q\\' + \\'.\\'.repeat(n - col - 1))\\n  );\\n}\\n\\n/**\\n * @param {number[]} colPlacements\\n * @param {number} col\\n * @return {boolean}\\n */\\nfunction isValid(colPlacements, col) {\\n  for (let row = 0; row < colPlacements.length; row++) {\\n    const diffX = Math.abs(colPlacements[row] - col);\\n    const diffY = colPlacements.length - row;\\n\\n    if (!diffX || diffX === diffY) { // same column or diagonal\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n/**\\n * @param {number} n\\n * @param {number[][]} solutions\\n * @param {number} row\\n * @param {number[]} colPlacements\\n * @return {void}\\n */\\nfunction explore(n, solutions, row, colPlacements) {\\n  if (row === n) {\\n    return solutions.push(colPlacements.slice());\\n  }\\n\\n  for (let col = 0; col < n; col++) {\\n    if (!isValid(colPlacements, col)) {\\n      continue;\\n    }\\n\\n    colPlacements.push(col);\\n    explore(n, solutions, row + 1, colPlacements);\\n    colPlacements.pop();\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 138262,
                "title": "omg-my-simple-c-solution-beats-100-just-4ms-no-recursion",
                "content": "\\'\\'\\'\\nPlease comment your concerns/opinion. Thanks.\\nI consider the board as one dimensional, where the index represent row & the value in array represents the column. Thats why it runs faster.\\n\\npublic: vector<vector<string> > solveNQueens(int n) {\\n        \\n        vector<vector<string> > Sol;\\n        int X[n+1] = {0}, k=1, i, t=0;  //  X[1 to n] array will represent every solution. \"X[i] = j\" represents a queen at board[i][j]\\n\\t                                    //  This is one dimensional array carrys two dimensional info.\\n\\t    while(k > 0) {\\n\\n\\t\\t    X[k]++;\\n\\n\\t\\t    while(X[k] <= n && !(place(k, X))) X[k]++;\\n\\n\\t\\t    if(X[k] <= n) {\\n\\t\\t\\t    \\n                if(k == n) {    //  here we got a solution, now filling up the board as needed and will insert to Solution.\\n\\t\\t\\t\\t\\n                    vector<string> board (n, string(n,\\'.\\'));\\n                \\n\\t\\t\\tfor(i=1; i<=n; i++) board[i-1][X[i]-1] = \\'Q\\';  // every entry in X means one Q.\\n                \\n                    Sol.push_back(board);               \\n\\t\\t\\t    }\\n\\t\\t\\t    else { k++; X[k] = 0; }\\n\\t\\t    }\\n\\t\\t    else k--;\\n\\t    }\\n        return Sol;\\n    }\\n\\n        \\n    int place(int k, int Xx[])  //  this function will check to place k-th queen provided that k-1 queens alreay in the board\\n    {\\n\\t    int i;\\n\\n\\t    for(i=1; i<k; i++)\\n\\t\\t    if((Xx[i] == Xx[k]) || (abs(Xx[i]-Xx[k]) == abs(i-k))) return 0;\\n\\t\\t\\t    \\n\\t    return 1;\\n    }        \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nPlease comment your concerns/opinion. Thanks.\\nI consider the board as one dimensional, where the index represent row & the value in array represents the column. Thats why it runs faster.\\n\\npublic: vector<vector<string> > solveNQueens(int n) {\\n        \\n        vector<vector<string> > Sol;\\n        int X[n+1] = {0}, k=1, i, t=0;  //  X[1 to n] array will represent every solution. \"X[i] = j\" represents a queen at board[i][j]\\n\\t                                    //  This is one dimensional array carrys two dimensional info.\\n\\t    while(k > 0) {\\n\\n\\t\\t    X[k]++;\\n\\n\\t\\t    while(X[k] <= n && !(place(k, X))) X[k]++;\\n\\n\\t\\t    if(X[k] <= n) {\\n\\t\\t\\t    \\n                if(k == n) {    //  here we got a solution, now filling up the board as needed and will insert to Solution.\\n\\t\\t\\t\\t\\n                    vector<string> board (n, string(n,\\'.\\'));\\n                \\n\\t\\t\\tfor(i=1; i<=n; i++) board[i-1][X[i]-1] = \\'Q\\';  // every entry in X means one Q.\\n                \\n                    Sol.push_back(board);               \\n\\t\\t\\t    }\\n\\t\\t\\t    else { k++; X[k] = 0; }\\n\\t\\t    }\\n\\t\\t    else k--;\\n\\t    }\\n        return Sol;\\n    }\\n\\n        \\n    int place(int k, int Xx[])  //  this function will check to place k-th queen provided that k-1 queens alreay in the board\\n    {\\n\\t    int i;\\n\\n\\t    for(i=1; i<k; i++)\\n\\t\\t    if((Xx[i] == Xx[k]) || (abs(Xx[i]-Xx[k]) == abs(i-k))) return 0;\\n\\t\\t\\t    \\n\\t    return 1;\\n    }        \\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 19892,
                "title": "backtracing-python-solution-very-self-explained",
                "content": "```\\nclass Solution(object):\\n    def solveNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        \\n        solutions=[]\\n        # generate the solution in list format\\n        self.helper(n,solutions,[])\\n        \\n        ret=[]\\n        \\n        # draw the board\\n        for sltn in solutions:\\n            board=[]\\n            for s in sltn:\\n                board_row=\"\"\\n                for i in range(n):\\n                    if s==i:\\n                        board_row+='Q'\\n                    else:\\n                        board_row+='.'\\n                board.append(board_row[:])\\n            ret.append(board[:])\\n        \\n        return ret\\n        \\n    def helper(self,n,solutions,solution):\\n        if self.cnflct(solution)==True:\\n            # test if there is a conflict\\n            return\\n        else:\\n            if len(solution)==n:\\n                solutions.append(solution[:])\\n\\n            \\n        for i in range(n):\\n            # place a queen\\n            solution.append(i)\\n            self.helper(n,solutions,solution)\\n            solution.pop()\\n        \\n    def cnflct(self,solution):\\n        if len(solution)==1 or len(solution)==0:\\n            return False\\n        else:\\n            r=len(solution)-1\\n            c=solution[r]\\n            for i in range(len(solution)-1):\\n                # conflict if only two queens are on the same row/column/diagonal line\\n                if i==r or solution[i]==c or solution[i]+i==c+r or solution[i]-i==c-r:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def solveNQueens(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        \\n        solutions=[]\\n        # generate the solution in list format\\n        self.helper(n,solutions,[])\\n        \\n        ret=[]\\n        \\n        # draw the board\\n        for sltn in solutions:\\n            board=[]\\n            for s in sltn:\\n                board_row=\"\"\\n                for i in range(n):\\n                    if s==i:\\n                        board_row+='Q'\\n                    else:\\n                        board_row+='.'\\n                board.append(board_row[:])\\n            ret.append(board[:])\\n        \\n        return ret\\n        \\n    def helper(self,n,solutions,solution):\\n        if self.cnflct(solution)==True:\\n            # test if there is a conflict\\n            return\\n        else:\\n            if len(solution)==n:\\n                solutions.append(solution[:])\\n\\n            \\n        for i in range(n):\\n            # place a queen\\n            solution.append(i)\\n            self.helper(n,solutions,solution)\\n            solution.pop()\\n        \\n    def cnflct(self,solution):\\n        if len(solution)==1 or len(solution)==0:\\n            return False\\n        else:\\n            r=len(solution)-1\\n            c=solution[r]\\n            for i in range(len(solution)-1):\\n                # conflict if only two queens are on the same row/column/diagonal line\\n                if i==r or solution[i]==c or solution[i]+i==c+r or solution[i]-i==c-r:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1843419,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1753508,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1564694,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1573828,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1573053,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1935626,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1957019,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1566446,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1719713,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1568052,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1843419,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1753508,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1564694,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1573828,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1573053,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1935626,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1957019,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1566446,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1719713,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 1568052,
                "content": [
                    {
                        "username": "Jeetaksh",
                        "content": "The king is getting smart. None of his queens could see each other and he could go and see anyone;)"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "the King has made a harem of the chess board"
                    },
                    {
                        "username": "thesatender",
                        "content": "Can I report those idiots who are still posting solutions in discussion tab??"
                    },
                    {
                        "username": "harchetsingh12",
                        "content": "sure\\n"
                    },
                    {
                        "username": "mlfxbroker",
                        "content": "Yup. Two strikes you're out."
                    },
                    {
                        "username": "aqin",
                        "content": "queens can attack other queen in the same row, same column, but i forget the  diagonal.. = \\u3002="
                    },
                    {
                        "username": "minkowskiq",
                        "content": "[@yooorifeng](/yooorifeng) 2014 was 9 years ago @_@ "
                    },
                    {
                        "username": "yooorifeng",
                        "content": "bro commented 9 years ago"
                    },
                    {
                        "username": "amnghdr",
                        "content": "Here is a nice visualizer for understanding each method\\nhttps://haseebq.com/n-queens-visualizer/"
                    },
                    {
                        "username": "user0411bt",
                        "content": "This is very informative. Thanks."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "thank u so much!"
                    },
                    {
                        "username": "kaku770",
                        "content": "help\\nin which case the two queen will attack each other?  Sorry, I don\\'t know the chessboard game."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "[@__1](/__1) bro she asked 4 years ago I guess by now she might defeat u in chess game XD"
                    },
                    {
                        "username": "__1",
                        "content": "if they are in the same row or the same column or the same diagonal "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "For n=2 and n=3, I think it is impossible to place queen by following the conditions.\\nProblem description should have mentioned these constraints. Do we need to return empty list  for the same?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "I made a video to visualize the backtracking process based on my solution. [https://youtu.be/JTHHu49T-_Q](https://youtu.be/JTHHu49T-_Q)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@mihir2310](/mihir2310) I\\'ve remade it"
                    },
                    {
                        "username": "mihir2310",
                        "content": "can you make it a little slower?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 4.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/n-queens/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "so what do I return when there is no solution? (e.g. n =2, n=3) do I return a list of an empty list? or do I return dots?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "apparently it should return just an empty list. WTF didn\\'t they specify that"
                    },
                    {
                        "username": "daocrossover",
                        "content": "If the number of queens is less than N, how to solve this problem? When N is large, the backtracking takes a long time to run."
                    },
                    {
                        "username": "NyKnight",
                        "content": "There is no other way to solve this These problems like n queens and sudoku are np so we just have a better way to solve them yet."
                    },
                    {
                        "username": "lakhansingh16",
                        "content": "N only goes till 9 in this problem. Ans if there exists a solution, number of queens will be equal to the number of rows or columns."
                    }
                ]
            },
            {
                "id": 2025930,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2024804,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2000557,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 1573861,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2059171,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2035068,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2029576,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2029457,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2025649,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2020946,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "add this test case\\n\\nif n greater than 9, print (\"NA\")\\n\\ni give NA test case always in collage coding test but students programming logic is week."
                    },
                    {
                        "username": "chirag123490",
                        "content": "When i looked at the question, i know what to do , but did not know  how to code.\n"
                    },
                    {
                        "username": "thomasjablonski",
                        "content": "What a question."
                    },
                    {
                        "username": "john_112",
                        "content": "Refer below for backtracking solution in C++, Java and Python\\nhttps://www.techiedelight.com/print-possible-solutions-n-queens-problem/"
                    },
                    {
                        "username": "icefox137",
                        "content": "misclick submit instead of run "
                    },
                    {
                        "username": "chaudharykeshu9",
                        "content": "Queen can move in any direction : )."
                    },
                    {
                        "username": "layyy",
                        "content": "fix a row for each queen and then check column positions"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this is not as hard . try to visualize the problem then code \\n"
                    },
                    {
                        "username": "Anubhab2003",
                        "content": "Here is simple Java solution\\npublic class NQueens {\\n    public static void nqueen(char board[][], int row) {\\n        // Base Case\\n        if (row == board.length) {\\n            printboard(board);\\n            return;\\n        }\\n\\n        // Recursion step column loop\\n        for (int j = 0; j < board.length; j++) {\\n            if (issafe(board, row, j)) {\\n                board[row][j] = \\'Q\\';\\n                nqueen(board, row + 1); // Recursive step\\n                board[row][j] = \\'X\\'; // Backtracking step\\n            }\\n        }\\n    }\\n\\n    public static void printboard(char board[][]) {\\n        System.out.println(\"________________Chess Board____________\");\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board.length; j++) {\\n                System.out.print(board[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }\\n    }\\n\\n    public static boolean issafe(char board[][], int row, int col) {\\n        // Vertical up\\n        for (int i = row - 1; i >= 0; i--) {\\n            if (board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal left up\\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        // Diagonal right up\\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\\n            if (board[i][j] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static void main(String args[]) {\\n        int n = 4;\\n        char board[][] = new char[n][n];\\n        // Initialize\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = \\'X\\';\\n            }\\n        }\\n        nqueen(board, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "For `n = 2` & `n= 3` , there exists no valid configurations.\\nFor these testcases you have to return the empty list / array / vector."
                    }
                ]
            },
            {
                "id": 2009339,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1998069,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1995203,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1995202,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1931991,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1900141,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1857391,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1843605,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1752635,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            },
            {
                "id": 1703523,
                "content": [
                    {
                        "username": "chavansushil153",
                        "content": "i am week in recursion. how to approch the same?"
                    },
                    {
                        "username": "Nurbolatsnk",
                        "content": "Please add to the description, how queens attack each other, never played chess))"
                    },
                    {
                        "username": "alkindi77",
                        "content": "For the special case where `n = 1`, there is only one cell on the chessboard, and we can place a single queen in that cell. The queen cannot attack any other queen since there are no other cells in the chessboard.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 1\\nprint(solveNQueens(n))\\n```\\n\\nThe output for `n = 1` will be:\\n\\n```\\n[[\\'Q\\']]\\n```\\n\\nIn this case, there is only one possible solution with a single queen placed on the chessboard of size 1 \\xD7 1. The queen is represented as \\'Q\\', and there are no other queens on the chessboard for it to attack."
                    },
                    {
                        "username": "alkindi77",
                        "content": "To solve the N-Queens problem using backtracking, we start from the first row and place a queen in the first column. Then, we check if the placement is valid. If it\\'s valid, we move to the next row and continue the process until we reach the last row and successfully place all queens. If the placement is not valid at any point, we backtrack and try placing the queen in a different position.\\n\\nHere\\'s the solution in Python:\\n\\n```python\\ndef solveNQueens(n):\\n    def is_safe(board, row, col):\\n        # Check if there is any queen in the current column\\n        for i in range(row):\\n            if board[i][col] == \\'Q\\':\\n                return False\\n\\n        # Check upper diagonal on the left side\\n        i, j = row - 1, col - 1\\n        while i >= 0 and j >= 0:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j -= 1\\n\\n        # Check upper diagonal on the right side\\n        i, j = row - 1, col + 1\\n        while i >= 0 and j < n:\\n            if board[i][j] == \\'Q\\':\\n                return False\\n            i -= 1\\n            j += 1\\n\\n        return True\\n\\n    def backtrack(row):\\n        if row == n:\\n            result.append([\"\".join(row) for row in board])\\n            return\\n\\n        for col in range(n):\\n            if is_safe(board, row, col):\\n                board[row][col] = \\'Q\\'\\n                backtrack(row + 1)\\n                board[row][col] = \\'.\\'\\n\\n    board = [[\\'.\\' for _ in range(n)] for _ in range(n)]\\n    result = []\\n    backtrack(0)\\n    return result\\n\\n# Example\\nn = 4\\nprint(solveNQueens(n))\\n```\\n\\nThe output will be a list of different solutions to the N-Queens problem with size `n = 4`. Each solution is represented as a set of strings, where each string represents the placement of queens in a specific row. For example, the solutions mentioned in the example will be:\\n\\n```\\n[\\n [\".Q..\",\\n  \"...Q\",\\n  \"Q...\",\\n  \"..Q.\"],\\n\\n [\"..Q.\",\\n  \"Q...\",\\n  \"...Q\",\\n  \".Q..\"]\\n]\\n```\\n\\nThese are the possible solutions to the N-Queens problem, where queens are placed such that they do not attack each other on a chessboard of size 4 \\xD7 4."
                    },
                    {
                        "username": "user2218my",
                        "content": "Hi guys,\\n\\nin my solution (written in C) I allocate memory space for the arrays in the solution. I get the following error message: \\n\\nruntime error: store to misaligned address 0xbebebebebebebec6 for type \\'char *\\', \\nwhich requires 8 byte alignment [solution.c] \\n0xbebebebebebebec6: note: pointer points here\\n<memory cannot be printed>\\n\\nCan someone help me out with this?\\n\\nI have allocated memory the following way: \\n\\nchar *** result = (char ***) malloc(10 * sizeof(char **));\\nresult[*returnSize] = (char **) malloc(n * sizeof(char *));\\nfor (k = 0; k < n; k++)\\n                {\\n                    result[*returnSize][k] = (char *) malloc((n+1) * sizeof(char));\\n                    ...\\n                }\\n\\nIt works for k == 0, but for k == 1 I get the error message.\\n"
                    },
                    {
                        "username": "langweilig",
                        "content": "Why does the result for test case 5 not containing following answers:\\n[\"..Q..\",\"....Q\",\"Q....\",\"...Q.\",\".Q...\"]\\n[\"...Q.\",\".Q...\",\"....Q\",\"Q....\",\"..Q..\"]\\nAltogether I have 4 more solutions than the result. Are they not distinct? They cannot be!"
                    },
                    {
                        "username": "langweilig",
                        "content": "[@Wambyat](/Wambyat) Thank you wambyat. I realized it, the diagonals would go through the entire board! I have fixed my solution then."
                    },
                    {
                        "username": "Wambyat",
                        "content": "The 2 answers listed by you are incorrect. This is because, in the first solution, the queen in row 1 can attack the queen in row 3 (diagonally). Similarly in the second answer, the queen in row 3 can attack the queen in row 5."
                    },
                    {
                        "username": "Soumik10",
                        "content": "while printing it is coming:\\n[[..Q., Q..., ...Q, .Q..], [..Q., Q..., ...Q, .Q..]]\\nbut when returned the same its coming:\\n[[],[]]"
                    },
                    {
                        "username": "bietdoikiem",
                        "content": "Be careful of reference when adding the array list to the solution array as it may get clear out when you do the backtracking."
                    },
                    {
                        "username": "prakhar432",
                        "content": "HINT: While deleting the boxes affected by the ith queen, do not delete the boxes which are still under attack by any of the previous (i-1) queens. Find some way so that only the boxes affected ONLY by the ith queen are deleted during backtracking. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "entheo",
                        "content": "Not sure why my code isn\\'t working. It passes the test cases (n = 1, n = 4), then when I submit, it says wrong answer for n = 5 and my output is [], although in Visual Studio it gives the expected output for that test case as well. How could it return nothing for n = 5, but return the correct values for n = 4?"
                    },
                    {
                        "username": "charonme",
                        "content": "You probably made the same mistake as me: when backtracking and removing the previously placed queen I was clearing fields threatened by other queens"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse Words in a String",
        "question_content": "<p>Given an input string <code>s</code>, reverse the order of the <strong>words</strong>.</p>\n\n<p>A <strong>word</strong> is defined as a sequence of non-space characters. The <strong>words</strong> in <code>s</code> will be separated by at least one space.</p>\n\n<p>Return <em>a string of the words in reverse order concatenated by a single space.</em></p>\n\n<p><b>Note</b> that <code>s</code> may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;the sky is blue&quot;\n<strong>Output:</strong> &quot;blue is sky the&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;  hello world  &quot;\n<strong>Output:</strong> &quot;world hello&quot;\n<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;a good   example&quot;\n<strong>Output:</strong> &quot;example good a&quot;\n<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> contains English letters (upper-case and lower-case), digits, and spaces <code>&#39; &#39;</code>.</li>\n\t<li>There is <strong>at least one</strong> word in <code>s</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b data-stringify-type=\"bold\">Follow-up:&nbsp;</b>If the string data type is mutable in your language, can&nbsp;you solve it&nbsp;<b data-stringify-type=\"bold\">in-place</b>&nbsp;with&nbsp;<code data-stringify-type=\"code\">O(1)</code>&nbsp;extra space?</p>\n",
        "solutions": [
            {
                "id": 47720,
                "title": "clean-java-two-pointers-solution-no-trim-no-split-no-stringbuilder",
                "content": "    public class Solution {\\n      \\n      public String reverseWords(String s) {\\n        if (s == null) return null;\\n        \\n        char[] a = s.toCharArray();\\n        int n = a.length;\\n        \\n        // step 1. reverse the whole string\\n        reverse(a, 0, n - 1);\\n        // step 2. reverse each word\\n        reverseWords(a, n);\\n        // step 3. clean up spaces\\n        return cleanSpaces(a, n);\\n      }\\n      \\n      void reverseWords(char[] a, int n) {\\n        int i = 0, j = 0;\\n          \\n        while (i < n) {\\n          while (i < j || i < n && a[i] == ' ') i++; // skip spaces\\n          while (j < i || j < n && a[j] != ' ') j++; // skip non spaces\\n          reverse(a, i, j - 1);                      // reverse the word\\n        }\\n      }\\n      \\n      // trim leading, trailing and multiple spaces\\n      String cleanSpaces(char[] a, int n) {\\n        int i = 0, j = 0;\\n          \\n        while (j < n) {\\n          while (j < n && a[j] == ' ') j++;             // skip spaces\\n          while (j < n && a[j] != ' ') a[i++] = a[j++]; // keep non spaces\\n          while (j < n && a[j] == ' ') j++;             // skip spaces\\n          if (j < n) a[i++] = ' ';                      // keep only one space\\n        }\\n      \\n        return new String(a).substring(0, i);\\n      }\\n      \\n      // reverse a[] from a[i] to a[j]\\n      private void reverse(char[] a, int i, int j) {\\n        while (i < j) {\\n          char t = a[i];\\n          a[i++] = a[j];\\n          a[j--] = t;\\n        }\\n      }\\n      \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      \\n      public String reverseWords(String s) {\\n        if (s == null) return null;\\n        \\n        char[] a = s.toCharArray();\\n        int n = a.length;\\n        \\n        // step 1. reverse the whole string\\n        reverse(a, 0, n - 1);\\n        // step 2. reverse each word\\n        reverseWords(a, n);\\n        // step 3. clean up spaces\\n        return cleanSpaces(a, n);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1531693,
                "title": "c-2-solutions-o-1-space-picture-explain-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Split words then Join words in reverse order**\\n```c++\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> words;\\n        stringstream ss(s);\\n        string tmp;\\n        while (ss >> tmp)\\n            words.push_back(tmp);\\n\\n        string ans;\\n        for (int i = words.size() - 1; i >= 0; --i) {\\n            if (i != words.size() - 1) ans += \" \";\\n            ans += words[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nComplexity\\n- Time: `O(N)`, where `N <= 10^4` is length of string `s`.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse whole string then reverse word by word - O(1) in Space Complexity**\\n- Reverse the whole string.\\n- Then we iterate characters in string `s`, fill found word into `s` then reverse it, word by word.\\n\\t- Let `l` keep the starting index of the current word, `r` keep the next index for filling the current word.\\n\\t- Reverse the current word, which is `s[l..r-1]`\\n\\t- Set space character for character `s[r]` if `r < s.size()`\\n- Finally, resize the string `s` to remove redundant chars.\\n\\n![image](https://assets.leetcode.com/users/images/b62b1a27-3688-41eb-b294-c26a5ba11d19_1634751350.7162225.png)\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(), s.end());\\n        int l = 0, r = 0, i = 0, n = s.size();\\n        while (i < n) {\\n            while (i < n && s[i] != \\' \\')\\n                s[r++] = s[i++];\\n\\n            if (l < r) { // if we can find a non-empty word then\\n                reverse(s.begin() + l, s.begin() + r); // reverse current word\\n                if (r == n) break;\\n                s[r++] = \\' \\'; // set empty space\\n                l = r;\\n            }\\n            ++i; // now i == n or s[i] == \\' \\', so we skip that character!\\n        }\\n        if (r > 0 && s[r-1] == \\' \\') --r; // skip last empty character if have\\n        s.resize(r);\\n        return s;\\n    }\\n};\\n```\\nComplexity\\n- Time: `O(N)`, where `N <= 10^4` is length of string `s`.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> words;\\n        stringstream ss(s);\\n        string tmp;\\n        while (ss >> tmp)\\n            words.push_back(tmp);\\n\\n        string ans;\\n        for (int i = words.size() - 1; i >= 0; --i) {\\n            if (i != words.size() - 1) ans += \" \";\\n            ans += words[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(), s.end());\\n        int l = 0, r = 0, i = 0, n = s.size();\\n        while (i < n) {\\n            while (i < n && s[i] != \\' \\')\\n                s[r++] = s[i++];\\n\\n            if (l < r) { // if we can find a non-empty word then\\n                reverse(s.begin() + l, s.begin() + r); // reverse current word\\n                if (r == n) break;\\n                s[r++] = \\' \\'; // set empty space\\n                l = r;\\n            }\\n            ++i; // now i == n or s[i] == \\' \\', so we skip that character!\\n        }\\n        if (r > 0 && s[r-1] == \\' \\') --r; // skip last empty character if have\\n        s.resize(r);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47740,
                "title": "in-place-simple-solution",
                "content": "First, reverse the whole string, then reverse each word.\\n\\n    void reverseWords(string &s) {\\n        reverse(s.begin(), s.end());\\n        int storeIndex = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != ' ') {\\n                if (storeIndex != 0) s[storeIndex++] = ' ';\\n                int j = i;\\n                while (j < s.size() && s[j] != ' ') { s[storeIndex++] = s[j++]; }\\n                reverse(s.begin() + storeIndex - (j - i), s.begin() + storeIndex);\\n                i = j;\\n            }\\n        }\\n        s.erase(s.begin() + storeIndex, s.end());\\n    }",
                "solutionTags": [],
                "code": "First, reverse the whole string, then reverse each word.\\n\\n    void reverseWords(string &s) {\\n        reverse(s.begin(), s.end());\\n        int storeIndex = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] != ' ') {\\n                if (storeIndex != 0) s[storeIndex++] = ' ';\\n                int j = i;\\n                while (j < s.size() && s[j] != ' ') { s[storeIndex++] = s[j++]; }\\n                reverse(s.begin() + storeIndex - (j - i), s.begin() + storeIndex);\\n                i = j;\\n            }\\n        }\\n        s.erase(s.begin() + storeIndex, s.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47781,
                "title": "java-3-line-builtin-solution",
                "content": "    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \", words);\\n    }",
                "solutionTags": [],
                "code": "    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \", words);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3593904,
                "title": "5-line-simple-solution-with-full-explanation",
                "content": "# Intuition\\nThe intuition behind this solution is to split the input string into individual words, reverse their order, and then concatenate them back together with a single space between each word.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The input string `s` is trimmed to remove any leading or trailing spaces using the `trim()` method.\\n2. The trimmed string is then split into an array of words using the `split(\"\\\\\\\\s+\")` method. The regular expression \"\\\\s+\" matches one or more whitespace characters, effectively separating the words.\\n3. A variable `out` is initialized as an empty string to store the reversed words.\\n4. Starting from the last word in the array (`str.length - 1`), the loop iterates backwards until the first word (index 0) is reached.\\n5. In each iteration, the current word `str[i]` is appended to `out` along with a space (\" \") to separate the words.\\n6. Finally, the first word `str[0]` is appended to `out`.\\n7. The reversed string of words, stored in `out`, is returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // Trim the input string to remove leading and trailing spaces\\n        String[] str = s.trim().split(\"\\\\\\\\s+\");\\n\\n        // Initialize the output string\\n        String out = \"\";\\n\\n        // Iterate through the words in reverse order\\n        for (int i = str.length - 1; i > 0; i--) {\\n            // Append the current word and a space to the output\\n            out += str[i] + \" \";\\n        }\\n\\n        // Append the first word to the output (without trailing space)\\n        return out + str[0];\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/4f5fe67c-eee3-4c09-b247-3aa31f77b0fb_1685814898.277616.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // Trim the input string to remove leading and trailing spaces\\n        String[] str = s.trim().split(\"\\\\\\\\s+\");\\n\\n        // Initialize the output string\\n        String out = \"\";\\n\\n        // Iterate through the words in reverse order\\n        for (int i = str.length - 1; i > 0; i--) {\\n            // Append the current word and a space to the output\\n            out += str[i] + \" \";\\n        }\\n\\n        // Append the first word to the output (without trailing space)\\n        return out + str[0];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47840,
                "title": "c-solution-in-place-runtime-o-n-memory-o-1",
                "content": "The idea is to ignore the extra spaces, reverse words one by one and reverse the whole string in the end.\\nI think for the interview it is good to show that substr or istringstream can be used too.\\n[The idea is taken from here][1]\\n\\n    class Solution {\\n    public:\\n    \\n        // function to reverse any part of string from i to j (just one word or entire string)\\n        void reverseword(string &s, int i, int j){\\n            while(i<j){\\n              char t=s[i];\\n              s[i++]=s[j];\\n              s[j--]=t;\\n            } \\n        }\\n        \\n        void reverseWords(string &s) {\\n            \\n            int i=0, j=0;\\n            int l=0;\\n            int len=s.length();\\n            int wordcount=0;\\n            \\n            while(true){\\n                while(i<len && s[i] == ' ') i++;  // skip spaces in front of the word\\n                if(i==len) break;\\n                if(wordcount) s[j++]=' ';\\n                l=j;\\n                while(i<len && s[i] != ' ') {s[j]=s[i]; j++; i++;} \\n                reverseword(s,l,j-1);                // reverse word in place\\n                wordcount++;\\n                \\n            }\\n            \\n            s.resize(j);                           // resize result string\\n            reverseword(s,0,j-1);                  // reverse whole string\\n        }\\n    };\\n\\n\\n  [1]: http://www.ardendertat.com/2011/10/31/programming-interview-questions-12-reverse-words-in-a-string/",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        // function to reverse any part of string from i to j (just one word or entire string)\\n        void reverseword(string &s, int i, int j){\\n            while(i<j){\\n              char t=s[i];\\n              s[i++]=s[j];\\n              s[j--]=t;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 47706,
                "title": "my-accepted-java-solution",
                "content": "    String[] parts = s.trim().split(\"\\\\\\\\s+\");\\n    String out = \"\";\\n    for (int i = parts.length - 1; i > 0; i--) {\\n        out += parts[i] + \" \";\\n    }\\n    return out + parts[0];\\n\\nI'm splitting on the regex for one-or-more whitespace, this takes care of multiple spaces/tabs/newlines/etc in the input. Since the input could have leading/trailing whitespace, which would result in empty matches, I first trim the input string.\\n\\nNow there could be three possibilities:\\n\\n 1. The input is empty: \"\", parts will contain [\"\"]. The for loop is skipped and \"\" + \"\" is returned.\\n 2. The input contains only one part: \"a\", parts will contain [\"a\"]. The for loop is skipped and \"\" + \"a\" is returned.\\n 3. The input contains multiple parts: \"a b c\", reverse the order of all but the first part: \"c b \" in the for loop and return \"c b \" + \"a\".\\n\\nObviously this is not the fastest or most memory efficient way to solve the problem, but optimizations should *only* be done when they are needed. Readable code is usually more important than efficient code.\\n\\nHow to make it efficient?\\n\\n 1. Use a StringBuilder to concatenate the string parts, instead of concatenating strings directly. This will (I assume) build something like a linked-list of string parts, and only allocate the new string when you need it, instead of on each concatenation.\\n 2. Iterate over the string, instead of using trim/split. Store the index of the last character in the word, when you find the first character, copy the substring to the output string.\\n 3. Instead of using substring, insert the word-characters directly in the StringBuilder. Assuming they're using a linked-list or tree, this could be a whole last faster.",
                "solutionTags": [],
                "code": "    String[] parts = s.trim().split(\"\\\\\\\\s+\");\\n    String out = \"\";\\n    for (int i = parts.length - 1; i > 0; i--) {\\n        out += parts[i] + \" \";\\n    }\\n    return out + parts[0];\\n\\nI'm splitting on the regex for one-or-more whitespace, this takes care of multiple spaces/tabs/newlines/etc in the input. Since the input could have leading/trailing whitespace, which would result in empty matches, I first trim the input string.\\n\\nNow there could be three possibilities:\\n\\n 1. The input is empty: \"\", parts will contain [\"\"]. The for loop is skipped and \"\" + \"\" is returned.\\n 2. The input contains only one part: \"a\", parts will contain [\"a\"]. The for loop is skipped and \"\" + \"a\" is returned.\\n 3. The input contains multiple parts: \"a b c\", reverse the order of all but the first part: \"c b \" in the for loop and return \"c b \" + \"a\".\\n\\nObviously this is not the fastest or most memory efficient way to solve the problem, but optimizations should *only* be done when they are needed. Readable code is usually more important than efficient code.\\n\\nHow to make it efficient?\\n\\n 1. Use a StringBuilder to concatenate the string parts, instead of concatenating strings directly. This will (I assume) build something like a linked-list of string parts, and only allocate the new string when you need it, instead of on each concatenation.\\n 2. Iterate over the string, instead of using trim/split. Store the index of the last character in the word, when you find the first character, copy the substring to the output string.\\n 3. Instead of using substring, insert the word-characters directly in the StringBuilder. Assuming they're using a linked-list or tree, this could be a whole last faster.",
                "codeTag": "Unknown"
            },
            {
                "id": 1666108,
                "title": "c-solution-understandable-for-beginners",
                "content": "![image](https://assets.leetcode.com/users/images/6694935b-6d53-4fd1-a8da-1022df51dce5_1641286196.908024.jpeg)\\n\\n```\\nstring reverseWords(string s) {\\n        string result;\\n        int i = 0, n = s.length();\\n        \\n        while(i < n){\\n\\t\\t\\t//to detect spaces and ignore them\\n            while(i < n && s[i] == \\' \\') i++;\\n            \\n            if(i >= n) break;\\n            \\n            int j = i;\\n            \\n\\t\\t\\t//to detect characters and break when we detect any space\\n            while(j < n && s[j] != \\' \\') j++;\\n            \\n\\t\\t\\t//to take out the first word\\n            string sub = s.substr(i, j-i);\\n            \\n            if(result.length() == 0) result = sub;\\n            \\n            else result = sub + \" \" + result;\\n            \\n            i = j+1;\\n        }\\n        \\n        return result;\\n```\\nIf you understood and liked this solution encourage me by giving me a vote up :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring reverseWords(string s) {\\n        string result;\\n        int i = 0, n = s.length();\\n        \\n        while(i < n){\\n\\t\\t\\t//to detect spaces and ignore them\\n            while(i < n && s[i] == \\' \\') i++;\\n            \\n            if(i >= n) break;\\n            \\n            int j = i;\\n            \\n\\t\\t\\t//to detect characters and break when we detect any space\\n            while(j < n && s[j] != \\' \\') j++;\\n            \\n\\t\\t\\t//to take out the first word\\n            string sub = s.substr(i, j-i);\\n            \\n            if(result.length() == 0) result = sub;\\n            \\n            else result = sub + \" \" + result;\\n            \\n            i = j+1;\\n        }\\n        \\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172258,
                "title": "python-two-pointers-no-cheating",
                "content": "### 151. Reverse Words in a String\n\nnot using any built-in python function, otherwise what is the purpose of doing this problem with python in an actual interview...\nThough, I highly recommend asking if you can use partial built-in function, even you can just do `''.join(s.split())` at the beginning would save tons of time since it takes care of trimming. \nAlso, express that using built-in functions actually provide better performance because they are written in C.\n\n```python\nclass Solution(object):\n    def reverseWords(self, s):\n        arr = list(s)\n        self.reverse_string(arr, 0, len(arr)-1)\n        self.reverse_word(arr)\n        word = self.trim_sides(arr)\n        res = self.trim_space(word)\n        return ''.join(res)\n\n\n    def reverse_string(self, arr, l, r):\n        '''reverse a given string'''\n        while l < r:\n            arr[l], arr[r] = arr[r], arr[l]\n            l += 1 ; r -= 1\n        return arr\n    \n    \n    def reverse_word(self, arr):\n        '''reverse every words in a string'''\n        l, r = 0 , 0\n        while r < len(arr):\n            while r < len(arr) and not arr[r].isspace(): r += 1\n            self.reverse_string(arr, l, r-1)\n            r += 1; l = r\n        return arr\n    \n    def trim_sides(self, arr):\n        '''str.strip() basically'''\n        if ''.join(arr).isspace(): return []\n        l , r = 0, len(arr) - 1\n        while l < r and arr[l].isspace(): l += 1\n        while l < r and arr[r].isspace(): r -= 1\n        return arr[l:r+1]\n    \n    def trim_space(self, word):\n        '''remove duplicating space in a word'''\n        if not word: return []\n        res = [word[0]]            \n        for i in range(1, len(word)):\n            if res[-1].isspace() and word[i].isspace(): continue\n            res.append(word[i])\n        return res\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution(object):\n    def reverseWords(self, s):\n        arr = list(s)\n        self.reverse_string(arr, 0, len(arr)-1)\n        self.reverse_word(arr)\n        word = self.trim_sides(arr)\n        res = self.trim_space(word)\n        return ''.join(res)\n\n\n    def reverse_string(self, arr, l, r):\n        '''reverse a given string'''\n        while l < r:\n            arr[l], arr[r] = arr[r], arr[l]\n            l += 1 ; r -= 1\n        return arr\n    \n    \n    def reverse_word(self, arr):\n        '''reverse every words in a string'''\n        l, r = 0 , 0\n        while r < len(arr):\n            while r < len(arr) and not arr[r].isspace(): r += 1\n            self.reverse_string(arr, l, r-1)\n            r += 1; l = r\n        return arr\n    \n    def trim_sides(self, arr):\n        '''str.strip() basically'''\n        if ''.join(arr).isspace(): return []\n        l , r = 0, len(arr) - 1\n        while l < r and arr[l].isspace(): l += 1\n        while l < r and arr[r].isspace(): r -= 1\n        return arr[l:r+1]\n    \n    def trim_space(self, word):\n        '''remove duplicating space in a word'''\n        if not word: return []\n        res = [word[0]]            \n        for i in range(1, len(word)):\n            if res[-1].isspace() and word[i].isspace(): continue\n            res.append(word[i])\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 521670,
                "title": "c-easy-stack-solution-beats-98",
                "content": "```\\nstring reverseWords(string s) {\\n        if(s.size() == 0) return s;\\n        stack<string> stack;\\n        string result;\\n        for(int i=0; i<s.size(); i++) {\\n            string word;\\n            if(s[i]==\\' \\') continue; //skip spaces\\n            while(i<s.size() && s[i]!=\\' \\' ) { //store continuous letters into word\\n                word += s[i]; i++;\\n            }\\n            stack.push(word); //push word to the stack\\n        }\\n        while(!stack.empty()) {\\n            result += stack.top(); stack.pop();\\n            if(!stack.empty()) result += \" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring reverseWords(string s) {\\n        if(s.size() == 0) return s;\\n        stack<string> stack;\\n        string result;\\n        for(int i=0; i<s.size(); i++) {\\n            string word;\\n            if(s[i]==\\' \\') continue; //skip spaces\\n            while(i<s.size() && s[i]!=\\' \\' ) { //store continuous letters into word\\n                word += s[i]; i++;\\n            }\\n            stack.push(word); //push word to the stack\\n        }\\n        while(!stack.empty()) {\\n            result += stack.top(); stack.pop();\\n            if(!stack.empty()) result += \" \";\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3198745,
                "title": "best-c-2-solution-ever-in-place-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1.  Solved using String + Two Pointers. In-place.\\n2. Solved using String with extra space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), where n is the total number of characters in the given string.\\n\\n    Space Complexity : O(1), Constant space. In-place solution.\\n\\n    Solved using String + Two Pointers.\\n\\n/*\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void reverse(string &s, int i, int j){\\n        while(i<j){\\n          char temp=s[i];\\n          s[i++]=s[j];\\n          s[j--]=temp;\\n        } \\n    }\\npublic:\\n    string reverseWords(string &s) {\\n        int i=0, j=0;\\n        int l=0;\\n        int len=s.length();\\n        int wordcount=0;\\n        while(true){\\n            while(i<len && s[i] == \\' \\') i++;\\n            if(i==len) break;\\n            if(wordcount) s[j++]=\\' \\';\\n            l=j;\\n            while(i<len && s[i] != \\' \\') {s[j]=s[i]; j++; i++;} \\n            reverse(s,l,j-1);                \\n            wordcount++;   \\n        }\\n        s.resize(j);                           \\n        reverse(s,0,j-1);  \\n        return s;        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), where n is the total number of characters in the given string.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String. \\n\\n/*\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string &s){\\n        stringstream ss(s);\\n        string word, ans;\\n        while(ss >> word){\\n            ans = word + \" \" + ans;\\n        }\\n        return ans.substr(0, ans.size()-1);;     \\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), where n is the total number of characters in the given string.\\n\\n    Space Complexity : O(1), Constant space. In-place solution.\\n\\n    Solved using String + Two Pointers.\\n\\n/*\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    void reverse(string &s, int i, int j){\\n        while(i<j){\\n          char temp=s[i];\\n          s[i++]=s[j];\\n          s[j--]=temp;\\n        } \\n    }\\npublic:\\n    string reverseWords(string &s) {\\n        int i=0, j=0;\\n        int l=0;\\n        int len=s.length();\\n        int wordcount=0;\\n        while(true){\\n            while(i<len && s[i] == \\' \\') i++;\\n            if(i==len) break;\\n            if(wordcount) s[j++]=\\' \\';\\n            l=j;\\n            while(i<len && s[i] != \\' \\') {s[j]=s[i]; j++; i++;} \\n            reverse(s,l,j-1);                \\n            wordcount++;   \\n        }\\n        s.resize(j);                           \\n        reverse(s,0,j-1);  \\n        return s;        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), where n is the total number of characters in the given string.\\n\\n    Space Complexity : O(1), Constant space. Extra space is only allocated for the String(ans), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using String. \\n\\n/*\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string &s){\\n        stringstream ss(s);\\n        string word, ans;\\n        while(ss >> word){\\n            ans = word + \" \" + ans;\\n        }\\n        return ans.substr(0, ans.size()-1);;     \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47726,
                "title": "my-accept-answer-of-python-with-one-line",
                "content": "My Python code using the function of array and string. Both time and memory is O(n).\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return a string\\n    def reverseWords(self, s):\\n        return \" \".join(s.strip().split()[::-1])",
                "solutionTags": [
                    "Python"
                ],
                "code": "My Python code using the function of array and string. Both time and memory is O(n).\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return a string\\n    def reverseWords(self, s):\\n        return \" \".join(s.strip().split()[::-1])",
                "codeTag": "Java"
            },
            {
                "id": 737148,
                "title": "c-small-code-explain",
                "content": "Idea is -->\\n\\ntake a String -- \"the sky is blue\" For Example\\nUse stringstream For Extract Each Word \\nTake A new string ```ans``` with empty value\\nThen Do ```ans = each_word + \" \" + ans``` \\n\\nLet\\'s See The All Process below Exapmle\\n```ans = \"\"``` all  the words are ```[ \"the\" \"sky\" \"is\" \"blue\"\\']```\\n\\n```\\n\\t\\t\\t\\t\\t  \\tword     space      pre_ans \\t\\t   new_ans\\n\\n\\t\\t1st Itr:  \\t  \\t\"the\"  +  \" \"   +    \"\"         \\t\\t\"the \"\\n\\t\\t2nd Itr: \\t \\t\"sky\"  +  \" \"   +    \"the \"\\t\\t\\t  \\t\"sky the \"\\n\\t\\t3rd Itr:  \\t\\t\"is\"   +  \" \"   +    \"sky the \"\\t\\t  \\t\"is sky the \" \\n\\t\\t4th Itr: \\t\\t\"blue\" +  \" \"   +    \"is sky the \"\\t\\t\"blue is sky the \"\\n```\\n\\nAs we can see  Ans Have One Extra Space so Use Substr And return```  \"blue is sky the\" ```\\n\\n``` \\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream all(s); \\n        string word,ans = \"\";\\n        while (all >> word)\\n            ans = word + \" \" + ans;\\n        return ans.substr(0,ans.length()-1);\\n    }\\n};\\n```\\nIf you Like It Please Upvote\\nAny doubt ask in comments\\nThank You",
                "solutionTags": [],
                "code": "```ans```\n```ans = each_word + \" \" + ans```\n```ans = \"\"```\n```[ \"the\" \"sky\" \"is\" \"blue\"\\']```\n```\\n\\t\\t\\t\\t\\t  \\tword     space      pre_ans \\t\\t   new_ans\\n\\n\\t\\t1st Itr:  \\t  \\t\"the\"  +  \" \"   +    \"\"         \\t\\t\"the \"\\n\\t\\t2nd Itr: \\t \\t\"sky\"  +  \" \"   +    \"the \"\\t\\t\\t  \\t\"sky the \"\\n\\t\\t3rd Itr:  \\t\\t\"is\"   +  \" \"   +    \"sky the \"\\t\\t  \\t\"is sky the \" \\n\\t\\t4th Itr: \\t\\t\"blue\" +  \" \"   +    \"is sky the \"\\t\\t\"blue is sky the \"\\n```\n```  \"blue is sky the\" ```\n``` \\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream all(s); \\n        string word,ans = \"\";\\n        while (all >> word)\\n            ans = word + \" \" + ans;\\n        return ans.substr(0,ans.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47777,
                "title": "5-lines-c-using-stringstream",
                "content": "    void reverseWords(string &s) {\\n        istringstream is(s);\\n        string tmp;\\n        is >> s;\\n        while(is >> tmp) s = tmp + \" \" + s;\\n        if(s[0] == ' ') s = \"\";\\n    }",
                "solutionTags": [],
                "code": "    void reverseWords(string &s) {\\n        istringstream is(s);\\n        string tmp;\\n        is >> s;\\n        while(is >> tmp) s = tmp + \" \" + s;\\n        if(s[0] == ' ') s = \"\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2809108,
                "title": "python3-one-liner-o-n-follow-up-question-explained",
                "content": "Doing what the question is asking for. First, split the words by space. Second, reverse the order of the words and then join these words with space.\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(s.split()[::-1])\\n```\\n\\nor if you prefer to see it in sperate lines\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split()\\n        s = s[::-1]\\n        return \\' \\'.join(s)\\n```\\n\\n***Follow-up***: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?\\n\\nNote that string in python is not mutable, but we should still think about the solution to this follow up question **since we are preparing for an interview!** In python, list is mutable, so let\\'s convert s to a list and solve this problem. \\n\\n**Algorithm**\\n(1) remove leading and trailing spaces\\n(2) reverse the entire ```s```\\n(3) reverse each word in the reversed ```s```\\n(4) reduce multiple spaces to single space in ```s```\\n\\n**TC:** O(n) since we just traversed the list a constant number of times\\n**O(1) space** assuming the given ```s``` is already a list\\n```python\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        ### convert s to a list so that s is mutable\\n        s = list(s)\\n        \\n        ### remove leading and trailing spaces\\n        while s[0]==\\' \\':\\n            s.pop(0)\\n        while s[-1]==\\' \\':\\n            s.pop(-1)\\n        \\n        ### reverse a part of a list given the start and the end indices of part.\\n        def reverseList(arr,start,end):\\n            i,j = start,end\\n            while i<j:\\n                arr[i],arr[j] = arr[j],arr[i]\\n                i+=1\\n                j-=1\\n        \\n        ### reverse the entire s\\n        reverseList(s,0,len(s)-1)\\n        \\n        ### reverse each word in s\\n        start = end = 0\\n        while start < len(s):\\n            while start<len(s) and s[start]==\\' \\':\\n                start += 1\\n                end += 1\\n            while end<len(s) and s[end] != \\' \\':\\n                end += 1\\n            reverseList(s,start,end-1)\\n            start = end\\n        \\n        ### reduce multiple spaces to single space\\n        cur = space = 0\\n        for i in range(len(s)):\\n            space = space + 1 if s[i] == \\' \\' else 0\\n            if space <= 1:\\n                s[cur] = s[i]\\n                cur += 1\\n        \\n        ### note that since multiple spaces are removed\\n        ### the valid length is only up to cur\\n        return \\'\\'.join(s[:cur])\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join(s.split()[::-1])\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.split()\\n        s = s[::-1]\\n        return \\' \\'.join(s)\\n```\n```s```\n```s```\n```s```\n```s```\n```python\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        ### convert s to a list so that s is mutable\\n        s = list(s)\\n        \\n        ### remove leading and trailing spaces\\n        while s[0]==\\' \\':\\n            s.pop(0)\\n        while s[-1]==\\' \\':\\n            s.pop(-1)\\n        \\n        ### reverse a part of a list given the start and the end indices of part.\\n        def reverseList(arr,start,end):\\n            i,j = start,end\\n            while i<j:\\n                arr[i],arr[j] = arr[j],arr[i]\\n                i+=1\\n                j-=1\\n        \\n        ### reverse the entire s\\n        reverseList(s,0,len(s)-1)\\n        \\n        ### reverse each word in s\\n        start = end = 0\\n        while start < len(s):\\n            while start<len(s) and s[start]==\\' \\':\\n                start += 1\\n                end += 1\\n            while end<len(s) and s[end] != \\' \\':\\n                end += 1\\n            reverseList(s,start,end-1)\\n            start = end\\n        \\n        ### reduce multiple spaces to single space\\n        cur = space = 0\\n        for i in range(len(s)):\\n            space = space + 1 if s[i] == \\' \\' else 0\\n            if space <= 1:\\n                s[cur] = s[i]\\n                cur += 1\\n        \\n        ### note that since multiple spaces are removed\\n        ### the valid length is only up to cur\\n        return \\'\\'.join(s[:cur])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757540,
                "title": "1ms-easy-java-solution-using-stack",
                "content": "``` \\npublic String reverseWords(String s) {\\n        Stack<String> st = new Stack<String>();\\n        for (String a : s.trim().split(\" \")) {\\n            if (!a.isEmpty())\\n                st.push(a);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty()) {\\n            sb.append(st.pop());\\n            sb.append(\" \");            \\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\npublic String reverseWords(String s) {\\n        Stack<String> st = new Stack<String>();\\n        for (String a : s.trim().split(\" \")) {\\n            if (!a.isEmpty())\\n                st.push(a);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty()) {\\n            sb.append(st.pop());\\n            sb.append(\" \");            \\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 47834,
                "title": "my-10-line-java-code-that-beats-73-of-the-submissions",
                "content": "Here is my concise and fast code that beats 73% of Java submissions. \\n\\nI scan from the end to make the concatenation logic clear and use `StringBuilder` to make the String concatenation faster. I also use `trim` when returning the results to avoid boundary checking.\\n\\nHope it helps.\\n\\n\\n    public static String reverseWords(String s) {\\n        StringBuilder res = new StringBuilder();\\n        for (int start = s.length() - 1; start >= 0; start--) {\\n            if (s.charAt(start) == ' ') continue;\\n            int end = start;\\n            while (start >= 0 && s.charAt(start) != ' ') start--;\\n            res.append(s.substring(start + 1, end + 1)).append(\" \");\\n        }\\n        return res.toString().trim();\\n    }",
                "solutionTags": [],
                "code": "Here is my concise and fast code that beats 73% of Java submissions. \\n\\nI scan from the end to make the concatenation logic clear and use `StringBuilder` to make the String concatenation faster. I also use `trim` when returning the results to avoid boundary checking.\\n\\nHope it helps.\\n\\n\\n    public static String reverseWords(String s) {\\n        StringBuilder res = new StringBuilder();\\n        for (int start = s.length() - 1; start >= 0; start--) {\\n            if (s.charAt(start) == ' ') continue;\\n            int end = start;\\n            while (start >= 0 && s.charAt(start) != ' ') start--;\\n            res.append(s.substring(start + 1, end + 1)).append(\" \");\\n        }\\n        return res.toString().trim();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 737124,
                "title": "python-2-solutions-oneliner-inplace-for-list-of-chars-explained",
                "content": "If you use python, this problem becomes not medium, but rather easy: all you need to do is to `split()` you data and take elements in negative order. `split()` is smart enough to ignore several spaces in a row as well as extra spaces in the begin and in the end.\\n\\n**Complexity**: both time and memory complexity is `O(n)`, because we traverse all string and we create new with size `O(n)`.\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s):\\n        return \" \".join(s.split()[::-1]) \\n```\\n\\n**Futher discussion**:  We can not do better than `O(n)` space in python, because strings are immutable. However if we are given not string, but array of symbols, we can remove all extra spaces, using **Two pointers** approach, reverse full string and then reverse each word. Time complexity will be `O(n)` and space will be `O(1)`.\\n\\nHere is the python code:\\n1. We traverse `chars` with two pointers and rewrite symbols in the beginning.\\n2. Cut our `chars`, removing last elements (in my code it is not really inplace, but you can use `del` to do it in place)\\n3. Reverse list using `chars.reverse()`.\\n4. Use two pointers to reverse each word.\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s):       \\n        chars = [t for t in s]\\n        slow, n = 0, len(s)\\n        for fast in range(n):\\n            if chars[fast] != \" \" or (fast > 0 and chars[fast] == \" \" and chars[fast-1] != \" \"):\\n                chars[slow] = chars[fast]\\n                slow += 1\\n                \\n        if slow == 0: return \"\"       \\n        chars = chars[:slow-1] if chars[-1] == \" \" else chars[:slow]\\n        chars.reverse()\\n        \\n        slow, m = 0, len(chars)\\n        for fast in range(m + 1):\\n            if fast == m or chars[fast] == \" \":\\n                chars[slow:fast] = chars[slow:fast][::-1]\\n                slow = fast + 1\\n                \\n        return \"\".join(chars)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s):\\n        return \" \".join(s.split()[::-1]) \\n```\n```\\nclass Solution:\\n    def reverseWords(self, s):       \\n        chars = [t for t in s]\\n        slow, n = 0, len(s)\\n        for fast in range(n):\\n            if chars[fast] != \" \" or (fast > 0 and chars[fast] == \" \" and chars[fast-1] != \" \"):\\n                chars[slow] = chars[fast]\\n                slow += 1\\n                \\n        if slow == 0: return \"\"       \\n        chars = chars[:slow-1] if chars[-1] == \" \" else chars[:slow]\\n        chars.reverse()\\n        \\n        slow, m = 0, len(chars)\\n        for fast in range(m + 1):\\n            if fast == m or chars[fast] == \" \":\\n                chars[slow:fast] = chars[slow:fast][::-1]\\n                slow = fast + 1\\n                \\n        return \"\".join(chars)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47973,
                "title": "accepted-python-answer-without-split-join-or-strip",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @return a string\\n        def reverseWords(self, s):\\n            # First reverse entire string, then iterate over reversed string\\n            # and again reverse order of characters within a word. Append each word to words.\\n            word = \"\"\\n            words = \"\"\\n            s = s[::-1]\\n            for j, i in enumerate(s):\\n                # character is not space, a current word exists, \\n                # and previous character is space, e.g. i=b in \" a b\":\\n                if i != \" \" and word != \"\" and s[j-1] == \" \":\\n                    # add current word to words and append \" \" to later add this i\\n                    words += (word + \" \")\\n                    word = i\\n                # character is not space, but it's either first character in string\\n                # or is part of current word, e.g. i=b in \"b\", \" b\" \"ab\", \"a ab \"\\n                elif i != \" \":\\n                    word = i + word\\n                else:\\n                    continue\\n    \\n            words += word\\n            \\n            return(words)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @return a string\\n        def reverseWords(self, s):\\n            # First reverse entire string, then iterate over reversed string\\n            # and again reverse order of characters within a word. Append each word to words.\\n            word = \"\"\\n            words = \"\"\\n            s = s[::-1]\\n            for j, i in enumerate(s):\\n                # character is not space, a current word exists, \\n                # and previous character is space, e.g. i=b in \" a b\":\\n                if i != \" \" and word != \"\" and s[j-1] == \" \":\\n                    # add current word to words and append \" \" to later add this i\\n                    words += (word + \" \")\\n                    word = i\\n                # character is not space, but it's either first character in string\\n                # or is part of current word, e.g. i=b in \"b\", \" b\" \"ab\", \"a ab \"\\n                elif i != \" \":\\n                    word = i + word\\n                else:\\n                    continue\\n    \\n            words += word\\n            \\n            return(words)",
                "codeTag": "Java"
            },
            {
                "id": 47797,
                "title": "in-place-java-solution-with-comments-just-for-fun",
                "content": "Hi guys!\\n\\nJust to keep it more interesting made it in-place in Java without using any additional library functions except converting String to char[]. Check it out. :)\\n\\n    // reverses the part of an array and returns the input array for convenience\\n    public char[] reverse(char[] arr, int i, int j) {\\n        while (i < j) {\\n            char tmp = arr[i];\\n            arr[i++] = arr[j];\\n            arr[j--] = tmp;\\n        }\\n        return arr;\\n    }\\n\\n    public String reverseWords(String s) {\\n        // reverse the whole string and convert to char array\\n        char[] str = reverse(s.toCharArray(), 0, s.length()-1);\\n        int start = 0, end = 0; // start and end positions of a current word\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] != ' ') { // if the current char is letter \\n                str[end++] = str[i]; // just move this letter to the next free pos\\n            } else if (i > 0 && str[i-1] != ' ') { // if the first space after word\\n                reverse(str, start, end-1); // reverse the word\\n                str[end++] = ' '; // and put the space after it\\n                start = end; // move start position further for the next word\\n            }\\n        }\\n        reverse(str, start, end-1); // reverse the tail word if it's there\\n        // here's an ugly return just because we need to return Java's String\\n        // also as there could be spaces at the end of original string \\n        // we need to consider redundant space we have put there before\\n        return new String(str, 0, end > 0 && str[end-1] == ' ' ? end-1 : end);\\n    }\\n\\nHave a nice coding there!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi guys!\\n\\nJust to keep it more interesting made it in-place in Java without using any additional library functions except converting String to char[]. Check it out. :)\\n\\n    // reverses the part of an array and returns the input array for convenience\\n    public char[] reverse(char[] arr, int i, int j) {\\n        while (i < j) {\\n            char tmp = arr[i];\\n            arr[i++] = arr[j];\\n            arr[j--] = tmp;\\n        }\\n        return arr;\\n    }\\n\\n    public String reverseWords(String s) {\\n        // reverse the whole string and convert to char array\\n        char[] str = reverse(s.toCharArray(), 0, s.length()-1);\\n        int start = 0, end = 0; // start and end positions of a current word\\n        for (int i = 0; i < str.length; i++) {\\n            if (str[i] != ' ') { // if the current char is letter \\n                str[end++] = str[i]; // just move this letter to the next free pos\\n            } else if (i > 0 && str[i-1] != ' ') { // if the first space after word\\n                reverse(str, start, end-1); // reverse the word\\n                str[end++] = ' '; // and put the space after it\\n                start = end; // move start position further for the next word\\n            }\\n        }\\n        reverse(str, start, end-1); // reverse the tail word if it's there\\n        // here's an ugly return just because we need to return Java's String\\n        // also as there could be spaces at the end of original string \\n        // we need to consider redundant space we have put there before\\n        return new String(str, 0, end > 0 && str[end-1] == ' ' ? end-1 : end);\\n    }\\n\\nHave a nice coding there!",
                "codeTag": "Unknown"
            },
            {
                "id": 47915,
                "title": "accepted-simple-cpp-code-in-just-a-few-lines",
                "content": "    class Solution {\\n    public:\\n        void reverseWords(string &s) {\\n            string result;\\n            int pos = 0;\\n            for (int i = 0; i < s.size(); i ++){\\n                if (s[i] == ' '){\\n                    if (i > pos )\\n                        result = s.substr(pos,i-pos)+ \" \" + result ;\\n                    pos = i + 1;\\n                }\\n                else if (i == s.size()-1)\\n                    result = s.substr(pos,s.size()-pos)+\" \"+result;\\n            }\\n            s = result.substr(0,result.size()-1) ;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void reverseWords(string &s) {\\n            string result;\\n            int pos = 0;\\n            for (int i = 0; i < s.size(); i ++){\\n                if (s[i] == ' '){\\n                    if (i > pos )\\n                        result = s.substr(pos,i-pos)+ \" \" + result ;\\n                    pos = i + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2808588,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=hFwi6gofSno\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(), s.end());\\n        int n = s.size();\\n        int strt = 0, end = 0;\\n        int itrtr = 0;\\n        while (itrtr < n) {\\n            while (itrtr < n && s[itrtr] != \\' \\')\\n                s[end++] = s[itrtr++];\\n\\n            if (strt < end) {\\n                reverse(s.begin() + strt, s.begin() + end); \\n                if (end == n) break;\\n                s[end++] = \\' \\';\\n                strt = end;\\n            }\\n            itrtr++; \\n        }\\n        if (end > 0 && s[end-1] == \\' \\')   s.resize(end-1);\\n       else  s.resize(end);\\n        return s;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(), s.end());\\n        int n = s.size();\\n        int strt = 0, end = 0;\\n        int itrtr = 0;\\n        while (itrtr < n) {\\n            while (itrtr < n && s[itrtr] != \\' \\')\\n                s[end++] = s[itrtr++];\\n\\n            if (strt < end) {\\n                reverse(s.begin() + strt, s.begin() + end); \\n                if (end == n) break;\\n                s[end++] = \\' \\';\\n                strt = end;\\n            }\\n            itrtr++; \\n        }\\n        if (end > 0 && s[end-1] == \\' \\')   s.resize(end-1);\\n       else  s.resize(end);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47826,
                "title": "simple-java-solution",
                "content": "    public class Solution {\\n        public String reverseWords(String s) {\\n            String [] words = s.split(\" \");\\n            StringBuilder sb = new StringBuilder();\\n            int end = words.length - 1;\\n            for(int i = 0; i<= end; i++){\\n                if(!words[i].isEmpty()) {\\n                    sb.insert(0, words[i]);\\n                    if(i < end) sb.insert(0, \" \");\\n                }\\n            }\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String reverseWords(String s) {\\n            String [] words = s.split(\" \");\\n            StringBuilder sb = new StringBuilder();\\n            int end = words.length - 1;\\n            for(int i = 0; i<= end; i++){\\n                if(!words[i].isEmpty()) {\\n                    sb.insert(0, words[i]);\\n                    if(i < end) sb.insert(0, \" \");\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2808775,
                "title": "easiest-sol-java-string-split",
                "content": "## Upvote if Helpful\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String reverseWords(String s) {\\n        \\n        String[] words = s.split(\"\\\\\\\\s+\");\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = words.length - 1; i >= 0; --i){\\n            str.append(words[i] + \" \");\\n        }\\n\\n        return str.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String reverseWords(String s) {\\n        \\n        String[] words = s.split(\"\\\\\\\\s+\");\\n        StringBuilder str = new StringBuilder();\\n\\n        for(int i = words.length - 1; i >= 0; --i){\\n            str.append(words[i] + \" \");\\n        }\\n\\n        return str.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808468,
                "title": "python3-faster-than-97-without-using-split",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        res = []\\n        temp = \"\"\\n        for c in s:\\n            if c != \" \":\\n                temp += c \\n            elif temp != \"\":\\n                res.append(temp)\\n                temp = \"\"\\n        if temp != \"\":\\n            res.append(temp)\\n        return \" \".join(res[::-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        res = []\\n        temp = \"\"\\n        for c in s:\\n            if c != \" \":\\n                temp += c \\n            elif temp != \"\":\\n                res.append(temp)\\n                temp = \"\"\\n        if temp != \"\":\\n            res.append(temp)\\n        return \" \".join(res[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687313,
                "title": "c-solution-containing-both-approaches-with-intuition-and-complexities-time-o-n-space-o-1",
                "content": "Hey there, I would discuss 2 solutions in this post.\\n**Do upvote it if you like it!!**\\n\\n## Approach1:\\nlet\\'s first understand what we need to achieve, We need to separate the words from the given string and also reverse their order.\\n\\n**Intutiveness:**\\nIf we are able to bring the words out of the given string then to reversal of order is quite simple. We will keep inserting at the starting of the new string.\\n\\n**Algorithm:**\\n- Maintain two indices one i,j pointing at starting and ending of each word.\\n- In this way we will go to each word, and add it to starting of our new string.\\n- Some of the additional steps we need to do in the meanwhile is to remove leading spaces in each word.\\n\\n**Code:**\\n```\\nstring reverseWords(string s) {\\n        string ans=\"\";\\n        int i,j,n=s.length();\\n        i=0;\\n        while(i<n){\\n            // Do not include leading spaces\\n            while(i<n && s[i]==\\' \\')\\n                i++;\\n            j=i;\\n            //Till when we do not reach a space, means we are currently on a word\\n            while(j<n && s[j]!=\\' \\')\\n                j++;\\n\\t\\t   // Here j is pointing to the next index of the ending of the current word, Due to this when passing length as 2nd parameter in substr fn, We pass j-i not j-i+1\\n            ans=\" \"+s.substr(i,j-i)+ans;\\n            i=j+1;\\n        }\\n\\n// Remove leading spaces\\n        i=0;\\n        while(i<n && ans[i]==\\' \\')\\n            i++;\\n        ans=ans.substr(i);\\n        return ans;\\n    }\\n\\n```\\n\\n**Time complexity:O(N)**\\n**Space complexity:O(N)**\\n\\n## Approach2:\\nThis is the inplace solution,\\n\\n**Intuitivess:**\\nAgain let\\'s see what we were doing in the prev approach. We were taking out words and then appending it to starting to reverse the order.\\nBut in this since we want to perform this in-place we cannot add it in front. So the question is how do we achieve it?\\nApproach which I came out for this is I reversed the whole string, Then while bringing out each word I reversed them as well.\\nExample:\\n\"the sky is blue\"\\n\\nReversed string:\\n\"eulb si yks eth\"\\n\\nOne more thing which got left out in this is how to handle case of leading and trailing spaces since calling remove method to remove then would result very costly.\\nApproach which I came out for this is to somehow put all of the space,let them be leading or trailing to trailing ones. Then remove trailing ones using pop_back fn(O(1) complexity)\\n\\n**Algorithm:**\\n- Reverse whole string.\\n- Again maintain two indices i and j for starting and ending of word, Twist is this time i will not point to starting of word but instead to the first leading space, Reason for the same is when we will call reverse on i..j, It will brinng word in the front and spaces to the back, In this way we will make all space to the trailing ones.\\n- One more thing is we will rev(i,j) when i==0. Reason is in this there might not be a single space, For other cases it is clearly mentioned that there will be at least 1 space b/w words.\\n \\n**Code for the above:**\\n\\n```\\nvoid rev(string &s,int l,int r){\\n        while(l<r)\\n            swap(s[l++],s[r--]);\\n    }\\n    string reverseWords(string s) {\\n        int i,j,n=s.length();\\n        i=0;\\n        \\n        rev(s,0,n-1);\\n        while(i<n){\\n            \\n            // Remove leading spaces\\n            j=i;\\n            while(j<n && s[j]==\\' \\')\\n                j++;\\n            \\n            int cnt=0;\\n            \\n            while(j<n && s[j]!=\\' \\'){\\n                j++;\\n                cnt++;\\n            }\\n            \\n            if(j>n)\\n                break;\\n            j--;\\n            \\n            if(i==0) \\n            rev(s,i,j);\\n            else     rev(s,i+1,j);\\n            \\n            if(cnt==0)\\n                i=j+1;\\n            else\\n                i=i+cnt;\\n        }\\n        \\n        j=n-1;\\n        while(j>=0 && s[j]==\\' \\'){\\n            j--;\\n            s.pop_back();\\n        }\\n        return s;\\n        \\n    }\\n```\\n\\n**Time complexity:O(N)**\\n**Space complexity:O(1)**\\n\\nHope you liked it!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring reverseWords(string s) {\\n        string ans=\"\";\\n        int i,j,n=s.length();\\n        i=0;\\n        while(i<n){\\n            // Do not include leading spaces\\n            while(i<n && s[i]==\\' \\')\\n                i++;\\n            j=i;\\n            //Till when we do not reach a space, means we are currently on a word\\n            while(j<n && s[j]!=\\' \\')\\n                j++;\\n\\t\\t   // Here j is pointing to the next index of the ending of the current word, Due to this when passing length as 2nd parameter in substr fn, We pass j-i not j-i+1\\n            ans=\" \"+s.substr(i,j-i)+ans;\\n            i=j+1;\\n        }\\n\\n// Remove leading spaces\\n        i=0;\\n        while(i<n && ans[i]==\\' \\')\\n            i++;\\n        ans=ans.substr(i);\\n        return ans;\\n    }\\n\\n```\n```\\nvoid rev(string &s,int l,int r){\\n        while(l<r)\\n            swap(s[l++],s[r--]);\\n    }\\n    string reverseWords(string s) {\\n        int i,j,n=s.length();\\n        i=0;\\n        \\n        rev(s,0,n-1);\\n        while(i<n){\\n            \\n            // Remove leading spaces\\n            j=i;\\n            while(j<n && s[j]==\\' \\')\\n                j++;\\n            \\n            int cnt=0;\\n            \\n            while(j<n && s[j]!=\\' \\'){\\n                j++;\\n                cnt++;\\n            }\\n            \\n            if(j>n)\\n                break;\\n            j--;\\n            \\n            if(i==0) \\n            rev(s,i,j);\\n            else     rev(s,i+1,j);\\n            \\n            if(cnt==0)\\n                i=j+1;\\n            else\\n                i=i+cnt;\\n        }\\n        \\n        j=n-1;\\n        while(j>=0 && s[j]==\\' \\'){\\n            j--;\\n            s.pop_back();\\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126820,
                "title": "swift-reverse-words-in-a-string",
                "content": "**Syntactic sugar in Swift in the truest sense** \\uD83D\\uDE04\\n```swift\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        s.split(separator: \" \").reversed().joined(separator: \" \")\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.reverseWords(\"the sky is blue\") == \"blue is sky the\") // good\\n    assert(s.reverseWords(\"  hello world  \") == \"world hello\") // good\\n    assert(s.reverseWords(\"a good   example\") == \"example good a\") // good\\n    assert(s.reverseWords(\"  Bob    Loves  Alice   \") == \"Alice Loves Bob\") // good\\n    assert(s.reverseWords(\"Alice does not even like bob\") == \"bob like even not does Alice\") // good\\n}\\n\\ntests()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        s.split(separator: \" \").reversed().joined(separator: \" \")\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.reverseWords(\"the sky is blue\") == \"blue is sky the\") // good\\n    assert(s.reverseWords(\"  hello world  \") == \"world hello\") // good\\n    assert(s.reverseWords(\"a good   example\") == \"example good a\") // good\\n    assert(s.reverseWords(\"  Bob    Loves  Alice   \") == \"Alice Loves Bob\") // good\\n    assert(s.reverseWords(\"Alice does not even like bob\") == \"bob like even not does Alice\") // good\\n}\\n\\ntests()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47883,
                "title": "in-place-java-solution-with-detailed-explanation",
                "content": "We can reverse each word first, then reverse the whole string, finnaly trim the string.\\n\\nLet us consider a general case:\\n\\nStep 1:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | a | b |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 2:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | b | a |   | c |   | e | d |   |   |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 3:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | d | e |   | c |   | a | b |   |   |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 4:\\n\\n            +---+---+---+---+---+---+---+\\n            | d | e |   | c |   | a | b |\\n            +---+---+---+---+---+---+---+\\n\\nWe can reverse a part of a string easily:\\n\\n    private void reverseString(char[] chars, int s, int e) {\\n        if (chars == null || s >= e || e >= chars.length) {\\n            return;\\n        }\\n\\n        while (s < e) {\\n            char tmp = chars[s];\\n            chars[s] = chars[e];\\n            chars[e] = tmp;\\n            s++;\\n            e--;\\n        }\\n    }\\n\\nThe hardest part is from step 1 to step 2.\\n\\nFor a string, we introduce 4 variables:\\n\\n1.  `len`, the lenth of the string.\\n2.  `last`, the index of the last character in the string.\\n3.  `chars`, the character array of a string.\\n4.  `i`, the iteration pointer, from 0 to `len`:\\n\\nWe can iterate the whole string from the start to the end, during the iteration process, we reverse every word.\\n\\nWe introduce 3 variables:\\n\\n    start        end\\n      |           |\\n      v           v\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | a | b |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n              ^\\n              |\\n            first\\n\\n1. `start`, the first position where a part of the string should be reversed.\\n2. `end`, the last position where a part of the string should be reversed.\\n    If the next character is blank and current blank is not blank, we mark current `i` as `end`:\\n\\n        while (i < last && chars[i] != ' ' && chars[i + 1] != ' ') {\\n            i++;\\n        }\\n        end = i;\\n\\n3. `first`, the first position where the character is not blank.\\n\\n        while (i < len && chars[i] == ' ') {\\n            i++;\\n        }\\n        first = i;\\n\\nNow we reverse the string for `start` to `end` and then we leave a blank after the last character, next round we reverse another part of the string:\\n\\n                start        end\\n                  |           |\\n                  v           v\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    | b | a |   |   |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n                              ^\\n                              |\\n                            first\\nWe can know the the position of the last character is:\\n\\n    start + (end - first)\\n\\nand the position of the blank will be:\\n\\n    start + (end - first) + 1\\n\\nNext round, we reverse the part of the string from the next position after the blank.\\n\\nThe code is here:\\n\\n\\n    public String reverseWords(String s) {\\n        if (s == null) {\\n            return s;\\n        }\\n        char[] chars = s.toCharArray();\\n\\n        int len = chars.length;\\n        int last = len - 1;\\n\\n        int i = 0;\\n        int start = 0;\\n        int first = 0;\\n        int end = 0;\\n\\n        while (i < len) {\\n\\n            start = i;\\n\\n            while (i < len && chars[i] == ' ') {\\n                i++;\\n            }\\n            first = i;\\n\\n            while (i < last && chars[i] != ' ' && chars[i + 1] != ' ') {\\n                i++;\\n            }\\n            end = i;\\n\\n            reverseString(chars, start, end);\\n\\n            i = start + (end - first) + 1;\\n\\n            // move to next\\n            i++;\\n        }\\n\\n        reverseString(chars, 0, len - 1);\\n\\n        return String.valueOf(chars).trim();\\n    }",
                "solutionTags": [],
                "code": "We can reverse each word first, then reverse the whole string, finnaly trim the string.\\n\\nLet us consider a general case:\\n\\nStep 1:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | a | b |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 2:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | b | a |   | c |   | e | d |   |   |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 3:\\n\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | d | e |   | c |   | a | b |   |   |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n\\nStep 4:\\n\\n            +---+---+---+---+---+---+---+\\n            | d | e |   | c |   | a | b |\\n            +---+---+---+---+---+---+---+\\n\\nWe can reverse a part of a string easily:\\n\\n    private void reverseString(char[] chars, int s, int e) {\\n        if (chars == null || s >= e || e >= chars.length) {\\n            return;\\n        }\\n\\n        while (s < e) {\\n            char tmp = chars[s];\\n            chars[s] = chars[e];\\n            chars[e] = tmp;\\n            s++;\\n            e--;\\n        }\\n    }\\n\\nThe hardest part is from step 1 to step 2.\\n\\nFor a string, we introduce 4 variables:\\n\\n1.  `len`, the lenth of the string.\\n2.  `last`, the index of the last character in the string.\\n3.  `chars`, the character array of a string.\\n4.  `i`, the iteration pointer, from 0 to `len`:\\n\\nWe can iterate the whole string from the start to the end, during the iteration process, we reverse every word.\\n\\nWe introduce 3 variables:\\n\\n    start        end\\n      |           |\\n      v           v\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    |   |   | a | b |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n              ^\\n              |\\n            first\\n\\n1. `start`, the first position where a part of the string should be reversed.\\n2. `end`, the last position where a part of the string should be reversed.\\n    If the next character is blank and current blank is not blank, we mark current `i` as `end`:\\n\\n        while (i < last && chars[i] != ' ' && chars[i + 1] != ' ') {\\n            i++;\\n        }\\n        end = i;\\n\\n3. `first`, the first position where the character is not blank.\\n\\n        while (i < len && chars[i] == ' ') {\\n            i++;\\n        }\\n        first = i;\\n\\nNow we reverse the string for `start` to `end` and then we leave a blank after the last character, next round we reverse another part of the string:\\n\\n                start        end\\n                  |           |\\n                  v           v\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n    | b | a |   |   |   |   | c |   |   | d | e |\\n    +---+---+---+---+---+---+---+---+---+---+---+\\n                              ^\\n                              |\\n                            first\\nWe can know the the position of the last character is:\\n\\n    start + (end - first)\\n\\nand the position of the blank will be:\\n\\n    start + (end - first) + 1\\n\\nNext round, we reverse the part of the string from the next position after the blank.\\n\\nThe code is here:\\n\\n\\n    public String reverseWords(String s) {\\n        if (s == null) {\\n            return s;\\n        }\\n        char[] chars = s.toCharArray();\\n\\n        int len = chars.length;\\n        int last = len - 1;\\n\\n        int i = 0;\\n        int start = 0;\\n        int first = 0;\\n        int end = 0;\\n\\n        while (i < len) {\\n\\n            start = i;\\n\\n            while (i < len && chars[i] == ' ') {\\n                i++;\\n            }\\n            first = i;\\n\\n            while (i < last && chars[i] != ' ' && chars[i + 1] != ' ') {\\n                i++;\\n            }\\n            end = i;\\n\\n            reverseString(chars, start, end);\\n\\n            i = start + (end - first) + 1;\\n\\n            // move to next\\n            i++;\\n        }\\n\\n        reverseString(chars, 0, len - 1);\\n\\n        return String.valueOf(chars).trim();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 436062,
                "title": "python-two-pointers-no-builtin-functions",
                "content": "```\\ndef reverseWords(self, s: str) -> str:\\n        res = \"\"\\n        s = \" \" + s + \" \"\\n        start = end = -1\\n        for i in range(len(s) - 2, 0, -1):\\n            if s[i + 1] == \" \" and s[i] != \" \":\\n                end = i\\n            if s[i - 1] == \" \" and s[i] != \" \": \\n                start = i\\n                res = res + \" \" + s[start: end + 1]\\n        return res[1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef reverseWords(self, s: str) -> str:\\n        res = \"\"\\n        s = \" \" + s + \" \"\\n        start = end = -1\\n        for i in range(len(s) - 2, 0, -1):\\n            if s[i + 1] == \" \" and s[i] != \" \":\\n                end = i\\n            if s[i - 1] == \" \" and s[i] != \" \": \\n                start = i\\n                res = res + \" \" + s[start: end + 1]\\n        return res[1:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 737908,
                "title": "c-solutions",
                "content": "## Approach 1: Two-pointer\\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        if(s == \"\")\\n            return s;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] == \\' \\')\\n                continue;\\n            \\n            int start = i;\\n            while(i < s.Length && s[i] != \\' \\')\\n                i++;\\n            \\n            if(sb.Length == 0)\\n                sb.Append(s.Substring(start, i - start));\\n            else\\n                sb.Insert(0, s.Substring(start, i - start) + \" \");\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```\\n\\n## Approach 2: Built-in Split + Reverse + Join\\n* Time complexity: O(N) where N is the number of characters in s\\n  - String.Split() essentially uses a two-pass solution. StringSplitOption will take another pass. Overall time complexity is O(N)\\n  - Array.Reverse has O(N) time complexity.\\n  - String.Join() is built on top of StringBuilder. It has O(N) time complexity.\\n* Space complexity: O(N)\\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        string[] arr = s.Split(\" \", StringSplitOptions.RemoveEmptyEntries);\\n        \\n        Array.Reverse(arr);\\n           \\n        return String.Join(\" \", arr); \\n    }\\n}\\n```\\n\\n## Approach 3: String.Split() & StringBuilder\\n* Time complexity: O(N)\\n* Space complexity: O(N)\\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        string[] arr = s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = arr.Length - 1; i >= 0; i--)\\n        {\\n            sb.Append(arr[i]);\\n            sb.Append(\" \");\\n        }\\n        \\n        return sb.ToString().Trim();\\n    }\\n}\\n```\\n\\n## Approach 4: Split + Stack\\n* Time complexity: O(N)\\n* Space complexity: O(N)\\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        s = s.Trim().TrimStart();\\n        \\n        string[] arr = s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries);\\n        Stack<string> stack = new Stack<string>();\\n        \\n        foreach(string str in arr)\\n        {\\n            stack.Push(str);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n            sb.Append(\" \");\\n        }\\n        \\n        return sb.ToString().Trim();\\t\\t\\n\\t\\t//return String.Join(\\' \\', stack);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        if(s == \"\")\\n            return s;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] == \\' \\')\\n                continue;\\n            \\n            int start = i;\\n            while(i < s.Length && s[i] != \\' \\')\\n                i++;\\n            \\n            if(sb.Length == 0)\\n                sb.Append(s.Substring(start, i - start));\\n            else\\n                sb.Insert(0, s.Substring(start, i - start) + \" \");\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        string[] arr = s.Split(\" \", StringSplitOptions.RemoveEmptyEntries);\\n        \\n        Array.Reverse(arr);\\n           \\n        return String.Join(\" \", arr); \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        string[] arr = s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = arr.Length - 1; i >= 0; i--)\\n        {\\n            sb.Append(arr[i]);\\n            sb.Append(\" \");\\n        }\\n        \\n        return sb.ToString().Trim();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n        \\n        s = s.Trim().TrimStart();\\n        \\n        string[] arr = s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries);\\n        Stack<string> stack = new Stack<string>();\\n        \\n        foreach(string str in arr)\\n        {\\n            stack.Push(str);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(stack.Count > 0)\\n        {\\n            sb.Append(stack.Pop());\\n            sb.Append(\" \");\\n        }\\n        \\n        return sb.ToString().Trim();\\t\\t\\n\\t\\t//return String.Join(\\' \\', stack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975824,
                "title": "javascript-solution-no-split-reverse-methods",
                "content": "I see that there are many split-find-reverse solutions in the discussions here. But I assume this is not what an interviewer wants to see when they ask this question.\\n\\n*Runtime: 72 ms, faster than 97.25% of JavaScript online submissions for Reverse Words in a String.\\nMemory Usage: 40.8 MB, less than 18.28% of JavaScript online submissions for Reverse Words in a String.*\\n\\n**The runtime of this code snippet is totally random each time:**\\n\\n*12/17/2020 15:03\\tAccepted\\t72 ms\\t40.8 MB\\tjavascript\\n12/17/2020 15:03\\tAccepted\\t104 ms\\t40.6 MB\\tjavascript\\n12/17/2020 15:03\\tAccepted\\t148 ms\\t40.8 MB\\tjavascript\\n12/17/2020 15:03\\tAccepted\\t88 ms\\t40.6 MB\\tjavascript\\n12/17/2020 15:03\\tAccepted\\t88 ms\\t40.7 MB\\tjavascript\\n12/17/2020 15:03\\tAccepted\\t132 ms\\t40.5 MB\\tjavascript*\\n\\n```\\nfunction reverseWords(s) {\\n  const ret = [];\\n  let word = [];\\n  for (let i = 0; i < s.length; ++i) {\\n    if (s.charAt(i) === \\' \\') {\\n\\t    // We found the space, put word in front (if there is any)\\n        word.length > 0 && ret.unshift(word.join(\\'\\'));\\n\\t\\t// Reset the current word\\n        word = [];\\n      }\\n    else {\\n\\t  // Add characters to the current word\\n      word.push(s.charAt(i));\\n    }\\n  }\\n  // If there is current word exists, add it in front\\n  word.length > 0 && ret.unshift(word.join(\\'\\'));\\n  return ret.join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction reverseWords(s) {\\n  const ret = [];\\n  let word = [];\\n  for (let i = 0; i < s.length; ++i) {\\n    if (s.charAt(i) === \\' \\') {\\n\\t    // We found the space, put word in front (if there is any)\\n        word.length > 0 && ret.unshift(word.join(\\'\\'));\\n\\t\\t// Reset the current word\\n        word = [];\\n      }\\n    else {\\n\\t  // Add characters to the current word\\n      word.push(s.charAt(i));\\n    }\\n  }\\n  // If there is current word exists, add it in front\\n  word.length > 0 && ret.unshift(word.join(\\'\\'));\\n  return ret.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807118,
                "title": "c-simple-and-clean-solution-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> vec;\\n        stringstream str(s);\\n        string word;\\n        while (str >> word) // store separated words in vector\\n            vec.push_back(word);\\n        \\n        reverse(vec.begin(), vec.end()); // reverse vector\\n        \\n        string res;\\n        for (const auto &it : vec) // concatenate strings\\n            res+=\" \"+it;\\n        res.erase(0,1); // first place is always a space - extra\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> vec;\\n        stringstream str(s);\\n        string word;\\n        while (str >> word) // store separated words in vector\\n            vec.push_back(word);\\n        \\n        reverse(vec.begin(), vec.end()); // reverse vector\\n        \\n        string res;\\n        for (const auto &it : vec) // concatenate strings\\n            res+=\" \"+it;\\n        res.erase(0,1); // first place is always a space - extra\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632928,
                "title": "intuitive-two-pointers-in-python-without-strip-or-split",
                "content": "**Help me by pushing this up! Appreciate any feedback!**\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        #Time: O(n) since we scan through the input, where n = len(s)\\n        #Space: O(n)\\n        words = []\\n        slow, fast = 0, 0\\n        \\n        #Use the first char to determine if we\\'re starting on a \" \" or a word\\n        mode = \\'blank\\' if s[0] == \\' \\' else \\'word\\'\\n        \\n        while fast < len(s):\\n            #If we start on a word and our fast ptr lands on a white space\\n            #means that we have singled out a word\\n            if mode == \\'word\\' and s[fast] == \\' \\':\\n                words.append(s[slow:fast])\\n                slow = fast #Make the slow ptr catch up\\n                mode = \\'blank\\'\\n                \\n            #If we start on a white space and our fast ptr runs into a character\\n            #means we are at the start of a word   \\n            elif mode == \\'blank\\' and s[fast] != \\' \\':\\n                slow = fast #Make the slow ptr catch up\\n                mode = \\'word\\'\\n        \\n            fast += 1 #Increment the fast pointer\\n        \\n        #Append the last word\\n        #Edge cases where the last chunk of string are white spaces\\n        if (lastWord := s[slow:fast]).isalnum():\\n            words.append(lastWord)\\n        \\n        return \\' \\'.join(words[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        #Time: O(n) since we scan through the input, where n = len(s)\\n        #Space: O(n)\\n        words = []\\n        slow, fast = 0, 0\\n        \\n        #Use the first char to determine if we\\'re starting on a \" \" or a word\\n        mode = \\'blank\\' if s[0] == \\' \\' else \\'word\\'\\n        \\n        while fast < len(s):\\n            #If we start on a word and our fast ptr lands on a white space\\n            #means that we have singled out a word\\n            if mode == \\'word\\' and s[fast] == \\' \\':\\n                words.append(s[slow:fast])\\n                slow = fast #Make the slow ptr catch up\\n                mode = \\'blank\\'\\n                \\n            #If we start on a white space and our fast ptr runs into a character\\n            #means we are at the start of a word   \\n            elif mode == \\'blank\\' and s[fast] != \\' \\':\\n                slow = fast #Make the slow ptr catch up\\n                mode = \\'word\\'\\n        \\n            fast += 1 #Increment the fast pointer\\n        \\n        #Append the last word\\n        #Edge cases where the last chunk of string are white spaces\\n        if (lastWord := s[slow:fast]).isalnum():\\n            words.append(lastWord)\\n        \\n        return \\' \\'.join(words[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531025,
                "title": "java-simple-o-n-trim-flag",
                "content": "**Java Solutions**\\n\\ntrim() function is used to remove side spaces of whole string!\\nfg is used to check space if it is already added in between words!\\n\\n**Approach 1**\\n\\nStore words and add them in reverse order to answer with single space! \\n\\nJava Solution 1\\n\\n    public String reverseWords(String s) {\\n        \\n        s=s.trim()+\" \";\\n        String ans=\"\",word=\"\";\\n        int fg=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=\\' \\')\\n            {\\n                fg=0;\\n                word+=s.charAt(i);\\n            }\\n            else if(fg==0)\\n            {\\n                fg=1;\\n                ans=word+\" \"+ans;\\n                word=\"\";\\n            }\\n        }\\n        return ans.trim();\\n    }\\n\\t\\n**Approach 2**\\n\\nReverse the String and store words in reverse order and add it to answer with single space!\\n\\nJava Solution 2\\n\\n    public String reverseWords(String s) {\\n        \\n        StringBuilder str=new StringBuilder(s);\\n        \\n        //reverse the string and trim the side spaces!\\n        s=str.reverse().toString().trim()+\" \";\\n        \\n        String word=\"\",ans=\"\"; int fg=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tif(s.charAt(i)!=\\' \\')\\n            {\\n                fg=0;\\n                word=s.charAt(i)+word;\\n            }\\n        \\telse if(fg==0) \\n        \\t{\\n        \\t\\tans+=\" \"+word;\\n        \\t\\tfg=1;\\n        \\t\\tword=\"\";\\n        \\t}\\n        }\\n        return ans.trim();\\n    }\\n\\t\\nIf you found it **helpful** then please **upvote** my solution:))\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Java Solutions**\\n\\ntrim() function is used to remove side spaces of whole string!\\nfg is used to check space if it is already added in between words!\\n\\n**Approach 1**\\n\\nStore words and add them in reverse order to answer with single space! \\n\\nJava Solution 1\\n\\n    public String reverseWords(String s) {\\n        \\n        s=s.trim()+\" \";\\n        String ans=\"\",word=\"\";\\n        int fg=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)!=\\' \\')\\n            {\\n                fg=0;\\n                word+=s.charAt(i);\\n            }\\n            else if(fg==0)\\n            {\\n                fg=1;\\n                ans=word+\" \"+ans;\\n                word=\"\";\\n            }\\n        }\\n        return ans.trim();\\n    }\\n\\t\\n**Approach 2**\\n\\nReverse the String and store words in reverse order and add it to answer with single space!\\n\\nJava Solution 2\\n\\n    public String reverseWords(String s) {\\n        \\n        StringBuilder str=new StringBuilder(s);\\n        \\n        //reverse the string and trim the side spaces!\\n        s=str.reverse().toString().trim()+\" \";\\n        \\n        String word=\"\",ans=\"\"; int fg=0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tif(s.charAt(i)!=\\' \\')\\n            {\\n                fg=0;\\n                word=s.charAt(i)+word;\\n            }\\n        \\telse if(fg==0) \\n        \\t{\\n        \\t\\tans+=\" \"+word;\\n        \\t\\tfg=1;\\n        \\t\\tword=\"\";\\n        \\t}\\n        }\\n        return ans.trim();\\n    }\\n\\t\\nIf you found it **helpful** then please **upvote** my solution:))\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 47821,
                "title": "is-my-solution-good-enough",
                "content": "Following is my accepted solution. However I found it quite long and not concise. Can someone help me improving my code?\\n\\n    void reverseStr(string &s, int start, int end)\\n        {\\n            int i = start;\\n            int j = end;\\n            while(i<j)\\n            {\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n        }\\n        void reverseStr(string &s)\\n        {\\n            reverseStr(s, 0, s.size()-1);\\n        }\\n        void reverseWords(string &s) {\\n            //reverse entire\\n            reverseStr(s);\\n            //reverse each word\\n            int start = 0;\\n            int end = 0;\\n            int i = 0;\\n            //remove leading space\\n            while(s.size() >0 && s[0] == ' ')\\n            {\\n                s.erase(0,1);\\n            }\\n            //add one space to the end so that it is easy to read word\\n            s += ' ';\\n            for(int i = 0; i < s.size(); ++i)\\n            {\\n                if(s[i] != ' ')\\n                    end++;\\n                //remove multiple space\\n                while(s[i] == ' ' && i < s.size()-1 && s[i+1] == ' ')\\n                {\\n                    s.erase(i,1);\\n                }\\n                //reverse word\\n                if(s[i] == ' ')\\n                {\\n                    if(end>start)\\n                    {\\n                        reverseStr(s, start, end-1);\\n                        start = end + 1;\\n                        end = start;\\n                    }\\n                }\\n            }\\n            //remove last ' '\\n            s.erase(s.size()-1, 1);\\n            \\n            \\n        }",
                "solutionTags": [],
                "code": "Following is my accepted solution. However I found it quite long and not concise. Can someone help me improving my code?\\n\\n    void reverseStr(string &s, int start, int end)\\n        {\\n            int i = start;\\n            int j = end;\\n            while(i<j)\\n            {\\n                swap(s[i],s[j]);\\n                i++;\\n                j--;\\n            }\\n        }\\n        void reverseStr(string &s)\\n        {\\n            reverseStr(s, 0, s.size()-1);\\n        }\\n        void reverseWords(string &s) {\\n            //reverse entire\\n            reverseStr(s);\\n            //reverse each word\\n            int start = 0;\\n            int end = 0;\\n            int i = 0;\\n            //remove leading space\\n            while(s.size() >0 && s[0] == ' ')\\n            {\\n                s.erase(0,1);\\n            }\\n            //add one space to the end so that it is easy to read word\\n            s += ' ';\\n            for(int i = 0; i < s.size(); ++i)\\n            {\\n                if(s[i] != ' ')\\n                    end++;\\n                //remove multiple space\\n                while(s[i] == ' ' && i < s.size()-1 && s[i+1] == ' ')\\n                {\\n                    s.erase(i,1);\\n                }\\n                //reverse word\\n                if(s[i] == ' ')\\n                {\\n                    if(end>start)\\n                    {\\n                        reverseStr(s, start, end-1);\\n                        start = end + 1;\\n                        end = start;\\n                    }\\n                }\\n            }\\n            //remove last ' '\\n            s.erase(s.size()-1, 1);\\n            \\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2808415,
                "title": "c-using-a-stack-string-view-fast-0ms",
                "content": "# Approach 1: stack\\n\\nFirst we split up the input into words and put them on a stack, and then we pull them of the stack one by one and stich together the result. By using a ```string_view``` we avoid copying the content of the string twice. I wish LC would include the boost and/or absl library, which both have functions to split strings and join vectors with separators. With functions like this solving this problem would be as straighforward as it is with other languages.\\n\\n```cpp\\n    static string reverseWords(const string_view s) {\\n        // Breakup the input into words and put them on a stack.\\n        stack<string_view> st;\\n        size_t start = 0;\\n        size_t end = 0;\\n        while ((start = s.find_first_not_of(\\' \\', end)) != string::npos) {\\n            end = s.find_first_of(\\' \\', start);\\n            st.push(s.substr(start, end - start));\\n        }\\n        // Stitch the answer together.\\n        string ans;\\n        ans.reserve(size(s));\\n        while (!empty(st)) {\\n            if (!empty(ans)) ans.push_back(\\' \\');\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n)$$\\n  * Space Complexity: $$O(n)$$ for the stack and the output\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```string_view```\n```cpp\\n    static string reverseWords(const string_view s) {\\n        // Breakup the input into words and put them on a stack.\\n        stack<string_view> st;\\n        size_t start = 0;\\n        size_t end = 0;\\n        while ((start = s.find_first_not_of(\\' \\', end)) != string::npos) {\\n            end = s.find_first_of(\\' \\', start);\\n            st.push(s.substr(start, end - start));\\n        }\\n        // Stitch the answer together.\\n        string ans;\\n        ans.reserve(size(s));\\n        while (!empty(st)) {\\n            if (!empty(ans)) ans.push_back(\\' \\');\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689485,
                "title": "beginner-friendly-most-optimal-c-solution-time-o-n-space-o-1",
                "content": "# Intuition\\n There can be 4 cases of spaces (\" \"). All 4 need to be taken care of.\\n1. Before the first non space character\\n2. Exactly one space in between two words\\n3. Extra spaces in between two words \\n4. After the last non space character\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take two pointers (left and right) and make them point to the first and last non space characters respectively.\\n- Now start the traversal from left to right. When you get a space, check if the character just before it was also a space or not. If yes, ignore it and continue; (A good example where this is useful is testcase 3)\\n- Else add the current word (temp) before the current ans (ans = temp + \" \" + ans)\\n- Once you reach the end, i.e. left == right, append the last word before the ans (similar to what is discussed in the above point)\\n- Remember to erase the last extra space in the final ans (ans.erase(ans.begin() + ans.length() - 1);)\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n\\n        string temp = \"\";\\n        string ans = \"\";\\n\\n        // making left point to first non space char\\n        int left = 0;\\n        while (s[left] == \\' \\') {\\n            left++;\\n        }\\n\\n        // making right point to last non space char\\n        int right = s.length() - 1;\\n        while (s[right] == \\' \\') {\\n            right--;\\n        }\\n\\n        while (left <= right) {\\n            if (s[left] != \\' \\') {\\n                temp += s[left];\\n            }\\n            else {\\n                if (s[left - 1] == \\' \\') {\\n                    left++;\\n                    continue;\\n                }\\n                else {\\n                    ans = temp + \" \" + ans;\\n                    temp = \"\";\\n                }\\n            }\\n            left++;\\n        }\\n        ans = temp + \" \" + ans;\\n        ans.erase(ans.begin() + ans.length() - 1); // to erase extra space at the end\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n\\n        string temp = \"\";\\n        string ans = \"\";\\n\\n        // making left point to first non space char\\n        int left = 0;\\n        while (s[left] == \\' \\') {\\n            left++;\\n        }\\n\\n        // making right point to last non space char\\n        int right = s.length() - 1;\\n        while (s[right] == \\' \\') {\\n            right--;\\n        }\\n\\n        while (left <= right) {\\n            if (s[left] != \\' \\') {\\n                temp += s[left];\\n            }\\n            else {\\n                if (s[left - 1] == \\' \\') {\\n                    left++;\\n                    continue;\\n                }\\n                else {\\n                    ans = temp + \" \" + ans;\\n                    temp = \"\";\\n                }\\n            }\\n            left++;\\n        }\\n        ans = temp + \" \" + ans;\\n        ans.erase(ans.begin() + ans.length() - 1); // to erase extra space at the end\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545212,
                "title": "c-java-o-1-space-clean-concise-easy-to-understand",
                "content": "# Intuition:\\nThe given solution aims to reverse the words in a given string while maintaining the order of the words. The approach is to first reverse the entire string, then iterate through the reversed string to reverse individual words.\\n\\n# Approach:\\n1. Reverse the entire string using the `reverse()` function from the STL library. This will reverse the order of all characters in the string.\\n2. Initialize variables: `start` to keep track of the start index of the current word, `end` to keep track of the end index of the current word, `i` as the current index, and `n` as the size of the string.\\n3. Iterate through the reversed string using a while loop until `i` reaches the end of the string:\\n   - Skip leading spaces by incrementing `i` while `i` is less than `n` and `s[i]` is equal to a space character.\\n   - Find the end of the current word by incrementing `end` while `i` is less than `n` and `s[i]` is not a space character. This will determine the range of characters representing the current word.\\n   - If the start index (`start`) is less than the end index (`end`), it means a word is found:\\n     - Reverse the characters in the current word by using the `reverse()` function with the range from `s.begin() + start` to `s.begin() + end`.\\n     - Add a space character after the reversed word by setting `s[end++]` to a space.\\n     - Update the start index (`start`) for the next word by assigning it the value of `end`.\\n   - Increment `i` to move to the next character in the string.\\n4. Check if there is an extra space at the end of the reversed string and remove it by resizing the string if `end` is greater than 0.\\n5. Return the reversed and reversed-words string.\\n\\n# Complexity:\\n- Time Complexity: The time complexity of this solution is O(n), where n is the length of the input string. Reversing the entire string takes O(n) time, and iterating through the string takes O(n) time as well.\\n- Space Complexity: The space complexity is O(1) since the operations are performed in-place, and no additional space is used apart from the input string itself.\\n\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        // Reverse the entire string\\n        reverse(s.begin(), s.end());\\n\\n        int start = 0; // Start index of the current word\\n        int end = 0;   // End index of the current word\\n        int i = 0;     // Current index\\n        int n = s.size(); // Size of the string\\n\\n        while (i < n) {\\n            // Skip leading spaces\\n            while (i < n && s[i] == \\' \\')\\n                i++;\\n\\n            // Find the end of the current word\\n            while (i < n && s[i] != \\' \\')\\n                s[end++] = s[i++];\\n\\n            if (start < end) {\\n                // Reverse the current word\\n                reverse(s.begin() + start, s.begin() + end);\\n\\n                // Add a space after the reversed word\\n                s[end++] = \\' \\';\\n\\n                // Update the start index for the next word\\n                start = end;\\n            }\\n            i++;\\n        }\\n\\n        // Remove extra space at the end if present\\n        if (end > 0)\\n            s.resize(end - 1);\\n\\n        return s;\\n    }\\n};\\n```\\n# Java\\n```java\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // Reverse the entire string\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        s = sb.toString();\\n\\n        int start = 0; // Start index of the current word\\n        int end = 0;   // End index of the current word\\n        int i = 0;     // Current index\\n        int n = s.length(); // Length of the string\\n\\n        sb = new StringBuilder(); // Create a new StringBuilder to store the result\\n\\n        while (i < n) {\\n            // Skip leading spaces\\n            while (i < n && s.charAt(i) == \\' \\')\\n                i++;\\n\\n            // Find the end of the current word\\n            start = i;\\n            while (i < n && s.charAt(i) != \\' \\')\\n                i++;\\n\\n            if (start < i) {\\n                // Reverse the current word\\n                StringBuilder reversedWord = new StringBuilder(s.substring(start, i));\\n                reversedWord.reverse();\\n\\n                // Add the reversed word to the result StringBuilder\\n                sb.append(reversedWord);\\n\\n                // Add a space after the reversed word\\n                sb.append(\\' \\');\\n            }\\n        }\\n\\n        // Remove extra space at the end if present\\n        if (sb.length() > 0)\\n            sb.setLength(sb.length() - 1);\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        // Reverse the entire string\\n        reverse(s.begin(), s.end());\\n\\n        int start = 0; // Start index of the current word\\n        int end = 0;   // End index of the current word\\n        int i = 0;     // Current index\\n        int n = s.size(); // Size of the string\\n\\n        while (i < n) {\\n            // Skip leading spaces\\n            while (i < n && s[i] == \\' \\')\\n                i++;\\n\\n            // Find the end of the current word\\n            while (i < n && s[i] != \\' \\')\\n                s[end++] = s[i++];\\n\\n            if (start < end) {\\n                // Reverse the current word\\n                reverse(s.begin() + start, s.begin() + end);\\n\\n                // Add a space after the reversed word\\n                s[end++] = \\' \\';\\n\\n                // Update the start index for the next word\\n                start = end;\\n            }\\n            i++;\\n        }\\n\\n        // Remove extra space at the end if present\\n        if (end > 0)\\n            s.resize(end - 1);\\n\\n        return s;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public String reverseWords(String s) {\\n        // Reverse the entire string\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        s = sb.toString();\\n\\n        int start = 0; // Start index of the current word\\n        int end = 0;   // End index of the current word\\n        int i = 0;     // Current index\\n        int n = s.length(); // Length of the string\\n\\n        sb = new StringBuilder(); // Create a new StringBuilder to store the result\\n\\n        while (i < n) {\\n            // Skip leading spaces\\n            while (i < n && s.charAt(i) == \\' \\')\\n                i++;\\n\\n            // Find the end of the current word\\n            start = i;\\n            while (i < n && s.charAt(i) != \\' \\')\\n                i++;\\n\\n            if (start < i) {\\n                // Reverse the current word\\n                StringBuilder reversedWord = new StringBuilder(s.substring(start, i));\\n                reversedWord.reverse();\\n\\n                // Add the reversed word to the result StringBuilder\\n                sb.append(reversedWord);\\n\\n                // Add a space after the reversed word\\n                sb.append(\\' \\');\\n            }\\n        }\\n\\n        // Remove extra space at the end if present\\n        if (sb.length() > 0)\\n            sb.setLength(sb.length() - 1);\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808541,
                "title": "python-c-java-rust-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs split, reverse and join operations to rearrange words in a string. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Python #1.** Split, reverse, check that not empty, join.\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([ss for ss in reversed(s.split(\" \")) if ss])\\n```\\n\\n**Python #2.** Here, we implicitly use a generator, thus, `if ss`-type of legth-check (i.e., `if len(ss) > 0`) is performed under the hood.\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```\\n\\n**C++.** No one-liner here :(\\n```\\nclass Solution \\n{\\npublic:\\n    string reverseWords(string s) \\n    {\\n        stringstream ss(s);\\n        string rev, w;\\n        \\n        ss >> rev;\\n        while (ss >> w) rev = w + \" \" + rev;\\n        \\n        return rev.substr(0, rev.length());\\n    }\\n};\\n```\\n\\n**Rust #1.**\\n```\\nimpl Solution \\n{\\n    pub fn reverse_words(s: String) -> String \\n    {\\n        s.rsplit(\\' \\')\\n         .filter(|ss| !ss.is_empty())   // need to filter zero-length chunks\\n         .collect::<Vec<&str>>()\\n         .join(\" \")\\n    }\\n}\\n```\\n\\n**Rust #2.**\\n```\\nimpl Solution \\n{\\n    pub fn reverse_words(s: String) -> String \\n    {\\n        s.split_whitespace()       // this one removes zero-length chunks\\n         .rev()\\n         .collect::<Vec<&str>>()\\n         .join(\" \")\\n    }\\n}\\n```\\n\\n**Java.**\\n```\\nclass Solution \\n{\\n    public String reverseWords(String s) \\n    {\\n        return Arrays.stream(s.trim().split(\"\\\\\\\\s+\"))\\n                     .reduce((ss, w) -> w + \" \" + ss)\\n                     .orElse(\"\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join([ss for ss in reversed(s.split(\" \")) if ss])\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string reverseWords(string s) \\n    {\\n        stringstream ss(s);\\n        string rev, w;\\n        \\n        ss >> rev;\\n        while (ss >> w) rev = w + \" \" + rev;\\n        \\n        return rev.substr(0, rev.length());\\n    }\\n};\\n```\n```\\nimpl Solution \\n{\\n    pub fn reverse_words(s: String) -> String \\n    {\\n        s.rsplit(\\' \\')\\n         .filter(|ss| !ss.is_empty())   // need to filter zero-length chunks\\n         .collect::<Vec<&str>>()\\n         .join(\" \")\\n    }\\n}\\n```\n```\\nimpl Solution \\n{\\n    pub fn reverse_words(s: String) -> String \\n    {\\n        s.split_whitespace()       // this one removes zero-length chunks\\n         .rev()\\n         .collect::<Vec<&str>>()\\n         .join(\" \")\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public String reverseWords(String s) \\n    {\\n        return Arrays.stream(s.trim().split(\"\\\\\\\\s+\"))\\n                     .reduce((ss, w) -> w + \" \" + ss)\\n                     .orElse(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941870,
                "title": "100-fastest-swift-solution-time-o-n-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of words in the input string.\\n    //   - space: O(m), where m is the length of the input string.\\n    \\n    func reverseWords(_ s: String) -> String {\\n        var ans = s.split(separator: \" \")\\n        var start = 0\\n        var end = ans.count - 1\\n\\n        while start < end {\\n            ans.swapAt(start, end)\\n            start += 1\\n            end -= 1\\n        }\\n\\n        return ans.joined(separator: \" \")\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of words in the input string.\\n    //   - space: O(m), where m is the length of the input string.\\n    \\n    func reverseWords(_ s: String) -> String {\\n        var ans = s.split(separator: \" \")\\n        var start = 0\\n        var end = ans.count - 1\\n\\n        while start < end {\\n            ans.swapAt(start, end)\\n            start += 1\\n            end -= 1\\n        }\\n\\n        return ans.joined(separator: \" \")\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490161,
                "title": "js-4-solutions-with-and-without-built-in-functions-and-optimised",
                "content": "**Solution 1:**\\n\\n```\\nvar reverseWords = function(s) {\\n\\t// 1. split the string with a space to form an array of words\\n\\t// 2. reverse the words\\n\\t// 3. filter out the words that are empty\\n\\t// 4. join the array to form the resultant string\\n    return s.split(\" \").reverse().filter(w => w !== \"\").join(\" \");\\n};\\n```\\nTime Complexity = O(n) [n - length of `s`]\\nSpace Complexity = O(n)\\n\\n----\\n\\n**Solution 2:**\\n\\n```\\nvar reverseWords = function(s) {\\n\\t// traverse the string, form words as encountered and add to the dictionary when a space is found\\n    let wordsInS = [];\\n    let word = \"\";\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n) [n - length of `s`]\\n        if(idx > 0 && s[idx] === \" \" && s[idx - 1] !== \" \") {\\n            wordsInS.push(word);\\n            word = \"\";\\n        } else if(s[idx] !== \" \") {\\n            word += s[idx];\\n        }\\n    }\\n\\t// this is required to add the last word after which no space is there\\n    if(word !== \"\") {\\n        wordsInS.push(word);    \\n    }\\n\\t// finally construct the resultant string by traversing the dictionary in reverse\\n    let result = \"\";\\n    for(let i = wordsInS.length - 1; i >= 0; --i) {    // O(m) [m = number of words (m < n)]\\n        result += wordsInS[i]\\n        if(i > 0) {\\n            result += \" \";\\n        }\\n    }\\n    return result;\\n}\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(n)\\n\\n----\\n\\n**Solution 3: Constant space**\\n\\n```\\nvar reverseWords = function(s) {\\n    let word = \"\";\\n    let right = s.length - 1,\\n        left = right;\\n    \\n\\t// start from the end of the string\\n    while(right >= 0) {\\n\\t\\t// ignore the spaces\\n        while(s[right] === \" \") {\\n            --right;\\n            --left;\\n        }\\n\\t\\t// since we have ignored the spaces, this will either be the start of the string or a character\\n\\t\\t// if it is a character, we start moving the left pointer until we either reach the start of the string or\\n\\t\\t// we reach a space\\n        while(left >= 0 && s[left] !== \" \") {\\n            --left;\\n        }\\n\\t\\t// we need to add the word we just found, so we traverse from (left, right] and add the characters to the final word\\n\\t\\t// this will ensure that the characters in a word are added in the correct order\\n        let i = left + 1;\\n        while(i <= right) {\\n\\t\\t\\t// this is required to add a space in between the words\\n\\t\\t\\t// -- i == left + 1 when we are at the first character of the current word\\n\\t\\t\\t// -- word !== \"\" when this is not the first word of the whole sentence \\n            if(i == left + 1 && word !== \"\") {\\n                word += \" \";    \\n            }\\n            word += s[i]\\n            ++i;\\n        }\\n\\t\\t// move the right pointer to the left position and continue\\n        right = left;\\n    }\\n    return word;   \\n}\\n```\\nTime Complexity = O(n) [ at max it wil traverse the string twice]\\nSpace Complexity = O(1) (not considering the resultant string)\\n\\n----\\n\\nEdit: \\n**Solution 4:**\\n`If the string data type is mutable in your language, can you solve it in-place with O(1) extra space?`\\n- Considering the string data type as mutable, so converted it into an array.\\n\\n```\\nvar reverseWords = function(s) {\\n    s = Array.from(s).reverse();    // converted the string to an array and reversed the string\\n    const n = s.length;\\n\\t// clearing the extra spaces within the str\\n    let ptr = 0, idx = 0;\\n    while(idx < n) {    // O(n)\\n        while(idx < n && s[idx] !== \\' \\') {\\n            s[ptr++] = s[idx++];\\n        }\\n        if(ptr > 0) {\\n            s[ptr++] = \\' \\';    \\n        }\\n        while(idx < n && s[idx] === \\' \\') {\\n            ++idx;\\n        }\\n    }\\n\\t// the string lies within the range [0, ptr - 1)\\n\\t// now reversing the words within the string\\n    let start = 0, end = 0;\\n    while(end < ptr - 1) {    // O(n)\\n        while(end < n && s[end] !== \\' \\') {\\n            ++end;\\n        }\\n        let i = end - 1;\\n        while(i >= start) {\\n            [s[start], s[i]] = [s[i], s[start]];\\n            ++start;\\n            --i;\\n        }\\n        ++end;\\n        start = end;\\n    }\\n    return s.splice(0, ptr - 1).join(\\'\\');    // O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n\\t// 1. split the string with a space to form an array of words\\n\\t// 2. reverse the words\\n\\t// 3. filter out the words that are empty\\n\\t// 4. join the array to form the resultant string\\n    return s.split(\" \").reverse().filter(w => w !== \"\").join(\" \");\\n};\\n```\n```\\nvar reverseWords = function(s) {\\n\\t// traverse the string, form words as encountered and add to the dictionary when a space is found\\n    let wordsInS = [];\\n    let word = \"\";\\n    for(let idx = 0; idx < s.length; ++idx) {    // O(n) [n - length of `s`]\\n        if(idx > 0 && s[idx] === \" \" && s[idx - 1] !== \" \") {\\n            wordsInS.push(word);\\n            word = \"\";\\n        } else if(s[idx] !== \" \") {\\n            word += s[idx];\\n        }\\n    }\\n\\t// this is required to add the last word after which no space is there\\n    if(word !== \"\") {\\n        wordsInS.push(word);    \\n    }\\n\\t// finally construct the resultant string by traversing the dictionary in reverse\\n    let result = \"\";\\n    for(let i = wordsInS.length - 1; i >= 0; --i) {    // O(m) [m = number of words (m < n)]\\n        result += wordsInS[i]\\n        if(i > 0) {\\n            result += \" \";\\n        }\\n    }\\n    return result;\\n}\\n```\n```\\nvar reverseWords = function(s) {\\n    let word = \"\";\\n    let right = s.length - 1,\\n        left = right;\\n    \\n\\t// start from the end of the string\\n    while(right >= 0) {\\n\\t\\t// ignore the spaces\\n        while(s[right] === \" \") {\\n            --right;\\n            --left;\\n        }\\n\\t\\t// since we have ignored the spaces, this will either be the start of the string or a character\\n\\t\\t// if it is a character, we start moving the left pointer until we either reach the start of the string or\\n\\t\\t// we reach a space\\n        while(left >= 0 && s[left] !== \" \") {\\n            --left;\\n        }\\n\\t\\t// we need to add the word we just found, so we traverse from (left, right] and add the characters to the final word\\n\\t\\t// this will ensure that the characters in a word are added in the correct order\\n        let i = left + 1;\\n        while(i <= right) {\\n\\t\\t\\t// this is required to add a space in between the words\\n\\t\\t\\t// -- i == left + 1 when we are at the first character of the current word\\n\\t\\t\\t// -- word !== \"\" when this is not the first word of the whole sentence \\n            if(i == left + 1 && word !== \"\") {\\n                word += \" \";    \\n            }\\n            word += s[i]\\n            ++i;\\n        }\\n\\t\\t// move the right pointer to the left position and continue\\n        right = left;\\n    }\\n    return word;   \\n}\\n```\n```\\nvar reverseWords = function(s) {\\n    s = Array.from(s).reverse();    // converted the string to an array and reversed the string\\n    const n = s.length;\\n\\t// clearing the extra spaces within the str\\n    let ptr = 0, idx = 0;\\n    while(idx < n) {    // O(n)\\n        while(idx < n && s[idx] !== \\' \\') {\\n            s[ptr++] = s[idx++];\\n        }\\n        if(ptr > 0) {\\n            s[ptr++] = \\' \\';    \\n        }\\n        while(idx < n && s[idx] === \\' \\') {\\n            ++idx;\\n        }\\n    }\\n\\t// the string lies within the range [0, ptr - 1)\\n\\t// now reversing the words within the string\\n    let start = 0, end = 0;\\n    while(end < ptr - 1) {    // O(n)\\n        while(end < n && s[end] !== \\' \\') {\\n            ++end;\\n        }\\n        let i = end - 1;\\n        while(i >= start) {\\n            [s[start], s[i]] = [s[i], s[start]];\\n            ++start;\\n            --i;\\n        }\\n        ++end;\\n        start = end;\\n    }\\n    return s.splice(0, ptr - 1).join(\\'\\');    // O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809323,
                "title": "c-stringstream-6-line-code-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream str(s);\\n        string word, ans = \"\";\\n        while(str >> word)\\n            ans = word + \" \" + ans;\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream str(s);\\n        string word, ans = \"\";\\n        while(str >> word)\\n            ans = word + \" \" + ans;\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401211,
                "title": "c-solutions-multiple-approaches-o-n-brute-force-space-o-n-optimal-space-o-1",
                "content": "```\\n/*  USING STACK */\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size() == 0) return s;\\n        stack<string> stack;\\n        string result;\\n        for(int i=0; i<s.size(); i++) {\\n            string word;\\n            if(s[i]==\\' \\') continue; //skip spaces\\n            while(i<s.size() && s[i]!=\\' \\' ) { //store continuous letters into word\\n                word += s[i]; i++;\\n            }\\n            stack.push(word); //push word to the stack\\n        }\\n        while(!stack.empty()) {\\n            result += stack.top(); stack.pop();\\n            if(!stack.empty()) result += \" \";\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\n/*  TWO POINTER METHOD USING EXTRA SPACE */\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j, n=s.size();\\n        string str;\\n        while(i<n)\\n        {\\n            while(i<n && s[i]==\\' \\') i++;\\n            if(i==n) break;\\n            j = i+1;\\n            while(j<n && s[j]!=\\' \\')j++;\\n            string sub = s.substr(i, j-i);\\n            if(str.size()==0)str = sub;\\n            else str = sub + \" \" + str;\\n            i = j+1;\\n        }\\n        return str;\\n    }\\n};\\n\\n```\\n```\\n/* USING STRINGSTREAM */\\n\\nclass Solution {\\npublic:\\n    \\n    //  MUST INCLUDE Header File: #include<sstream>\\n    \\n    string reverseWords(string str) {\\n        \\n        string word, ans=\"\";\\n        stringstream ss(str); //Created a stringstream object for str\\n        \\n        while(ss>>word){\\n            ans = word + \" \" + ans;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n.\\n\\n***Space Complexity = O(1)***\\n\\nSay, s = \" . . . a . . good . . . example . .\"         [ dot (.) means space here ]\\n\\nStep 1: Remove spaces from the beginning and ending. Now, s = \"a . . good . . . example\"\\nStep 2: Now remove extra spaces from middle. Now, s = \"a good example\"\\nStep 3: Reverse the string. Now, s = \"elpmaxe doog a\"\\nStep 4: Now reverse each word. Final s = \"example good a\"\\n\\n\\n```\\n//Space Complexity = O(1)\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        while(s[0] == \\' \\') s.erase(0, 1); //Remove spaces from the beginning\\n        while(s[s.size()-1]==\\' \\') s.erase(s.size()-1); //Remove spaces from the ending\\n        \\n        int i = 0, space_count = 0;\\n\\t\\t/*Now we count the middle spaces between two words, if more than one space\\n\\t\\tfound between two words, then remove it*/\\n        while(s[i])\\n        {\\n\\t\\t\\n\\t\\t   /*if the character is not space, then this is the starting of a new word. \\n\\t\\t   So, make the space count 0.*/\\n\\t\\t   \\n            if(s[i] == \\' \\') space_count++;\\n            else space_count = 0; \\n            if(space_count > 1) //more than one space found\\n            {\\n                s.erase(i,1);\\n                continue;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin(),s.end());\\n        int left = 0;\\n        for(i=1;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\') // space found means we have a word in our left and we have to reverse it\\n            {\\n                reverse(s.begin()+left, s.begin()+i);\\n                left = i+1;\\n            }\\n            else if(i == s.size()-1)\\n            {\\n                reverse(s.begin()+left, s.begin()+i+1);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n*If you like the solution **Please Upvote !***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*  USING STACK */\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        if(s.size() == 0) return s;\\n        stack<string> stack;\\n        string result;\\n        for(int i=0; i<s.size(); i++) {\\n            string word;\\n            if(s[i]==\\' \\') continue; //skip spaces\\n            while(i<s.size() && s[i]!=\\' \\' ) { //store continuous letters into word\\n                word += s[i]; i++;\\n            }\\n            stack.push(word); //push word to the stack\\n        }\\n        while(!stack.empty()) {\\n            result += stack.top(); stack.pop();\\n            if(!stack.empty()) result += \" \";\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n/*  TWO POINTER METHOD USING EXTRA SPACE */\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i=0, j, n=s.size();\\n        string str;\\n        while(i<n)\\n        {\\n            while(i<n && s[i]==\\' \\') i++;\\n            if(i==n) break;\\n            j = i+1;\\n            while(j<n && s[j]!=\\' \\')j++;\\n            string sub = s.substr(i, j-i);\\n            if(str.size()==0)str = sub;\\n            else str = sub + \" \" + str;\\n            i = j+1;\\n        }\\n        return str;\\n    }\\n};\\n\\n```\n```\\n/* USING STRINGSTREAM */\\n\\nclass Solution {\\npublic:\\n    \\n    //  MUST INCLUDE Header File: #include<sstream>\\n    \\n    string reverseWords(string str) {\\n        \\n        string word, ans=\"\";\\n        stringstream ss(str); //Created a stringstream object for str\\n        \\n        while(ss>>word){\\n            ans = word + \" \" + ans;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\n```\\n//Space Complexity = O(1)\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        while(s[0] == \\' \\') s.erase(0, 1); //Remove spaces from the beginning\\n        while(s[s.size()-1]==\\' \\') s.erase(s.size()-1); //Remove spaces from the ending\\n        \\n        int i = 0, space_count = 0;\\n\\t\\t/*Now we count the middle spaces between two words, if more than one space\\n\\t\\tfound between two words, then remove it*/\\n        while(s[i])\\n        {\\n\\t\\t\\n\\t\\t   /*if the character is not space, then this is the starting of a new word. \\n\\t\\t   So, make the space count 0.*/\\n\\t\\t   \\n            if(s[i] == \\' \\') space_count++;\\n            else space_count = 0; \\n            if(space_count > 1) //more than one space found\\n            {\\n                s.erase(i,1);\\n                continue;\\n            }\\n            i++;\\n        }\\n        reverse(s.begin(),s.end());\\n        int left = 0;\\n        for(i=1;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\') // space found means we have a word in our left and we have to reverse it\\n            {\\n                reverse(s.begin()+left, s.begin()+i);\\n                left = i+1;\\n            }\\n            else if(i == s.size()-1)\\n            {\\n                reverse(s.begin()+left, s.begin()+i+1);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1163738,
                "title": "swift-reverse-words-in-a-string",
                "content": "```swift\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.split(separator: \" \").reversed().joined(separator: \" \")\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 1 test, with 0 failures (0 unexpected) in 0.003 (0.005) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test() {\\n        XCTAssert(s.reverseWords(\"the sky is blue\") == \"blue is sky the\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.split(separator: \" \").reversed().joined(separator: \" \")\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 1 test, with 0 failures (0 unexpected) in 0.003 (0.005) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test() {\\n        XCTAssert(s.reverseWords(\"the sky is blue\") == \"blue is sky the\") // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737228,
                "title": "c-simple-2-index-solution-explained",
                "content": "I proceed with 2 indexes, `i` and `j`, that I keep moving to have them wrapped around each word, moving `i` as long as I find spaces and `j` as long as I find every other characters; if either reaches the end of the string, I stop.\\n\\nI then compose gradually my string `res` as the reverse of all those findings, adding a single space in the middle for each new word after the first (ie; when `res.size() != 0`).\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res, tmp;\\n        int i = 0, j, len = s.size();\\n        while (true) {\\n            // advancing i and j indexes around the next word\\n            while (i < len && s[i] == \\' \\') i++;\\n            // exit condition - we are done in case\\n            if (i >= len) break;\\n            j = i + 1;\\n            while (j < len && s[j] != \\' \\') j++;\\n            tmp = s.substr(i, j - i);\\n            res = tmp + (res.size() ? \" \" : \"\") + res;\\n            // moving to the next word\\n            i = j + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res, tmp;\\n        int i = 0, j, len = s.size();\\n        while (true) {\\n            // advancing i and j indexes around the next word\\n            while (i < len && s[i] == \\' \\') i++;\\n            // exit condition - we are done in case\\n            if (i >= len) break;\\n            j = i + 1;\\n            while (j < len && s[j] != \\' \\') j++;\\n            tmp = s.substr(i, j - i);\\n            res = tmp + (res.size() ? \" \" : \"\") + res;\\n            // moving to the next word\\n            i = j + 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294078,
                "title": "clean-c-3-approaches-stack-stringstream-o-1-space",
                "content": "----\\n*Everything in single post, please give it upvote if you find this helpful*\\n\\n----\\n**1. Using stringstream class**\\n**`Time : 12ms`** \\n```\\nclass Solution {\\npublic:\\n    \\n    //  MUST INCLUDE Header File: #include<sstream>\\n    // My solution \\n    string reverseWords(string str) {\\n        \\n        string word, ans=\"\";\\n        stringstream ss(str);\\n        \\n        while(ss>>word){\\n            ans = word + \" \" + ans;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n\\n----\\n\\n*Without stringstream class*\\n**2. Using STACK**\\n**`Time 16ms`** \\nSpace complexity and Time complexity both are **`O(n)`**\\n\\n```\\nclass Solution{\\npublic: \\n    \\n    string reverseWords(string s) \\n    {    \\n        stack<string>st;\\n        string tmp = \"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch = s[i];\\n            if(ch==\\' \\'){\\n                \\n                if(tmp!=\"\")\\n                    st.push(tmp);\\n                tmp = \"\";\\n            }\\n            else \\n                tmp += ch;\\n        }\\n        \\n        if(tmp!=\"\")\\n            st.push(tmp);\\n            \\n        string ans=\"\";\\n        while(st.size()>1)\\n        {\\n            ans +=  (st.top()+\" \");\\n            st.pop();\\n        }\\n        ans += st.top();\\n        return ans;\\n    }\\n};\\n```\\n\\n----\\n**3. Without stringstream class  and Without STACK**\\n**`Time : 15ms`**\\nTime complexity : **`O(N)`**\\nSpace complexity : **`O(1)`**\\n```\\nclass Solution{\\npublic: \\n    \\n    string reverseWords(string s) \\n    {\\n        string tmp=\"\", ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch = s[i];\\n            if(ch==\\' \\')\\n            {\\n                if(tmp!=\"\")\\n                    ans = tmp + \" \" + ans;\\n                tmp = \"\";        \\n            }\\n            else \\n                tmp += ch;\\n        }\\n        \\n        if(tmp!=\"\")\\n            ans = tmp + \" \" + ans;\\n        ans.pop_back();\\n        \\n        return ans;      \\n    }\\n};\\n```\\n*Thanks for upvoting !*\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //  MUST INCLUDE Header File: #include<sstream>\\n    // My solution \\n    string reverseWords(string str) {\\n        \\n        string word, ans=\"\";\\n        stringstream ss(str);\\n        \\n        while(ss>>word){\\n            ans = word + \" \" + ans;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic: \\n    \\n    string reverseWords(string s) \\n    {    \\n        stack<string>st;\\n        string tmp = \"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch = s[i];\\n            if(ch==\\' \\'){\\n                \\n                if(tmp!=\"\")\\n                    st.push(tmp);\\n                tmp = \"\";\\n            }\\n            else \\n                tmp += ch;\\n        }\\n        \\n        if(tmp!=\"\")\\n            st.push(tmp);\\n            \\n        string ans=\"\";\\n        while(st.size()>1)\\n        {\\n            ans +=  (st.top()+\" \");\\n            st.pop();\\n        }\\n        ans += st.top();\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic: \\n    \\n    string reverseWords(string s) \\n    {\\n        string tmp=\"\", ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char ch = s[i];\\n            if(ch==\\' \\')\\n            {\\n                if(tmp!=\"\")\\n                    ans = tmp + \" \" + ans;\\n                tmp = \"\";        \\n            }\\n            else \\n                tmp += ch;\\n        }\\n        \\n        if(tmp!=\"\")\\n            ans = tmp + \" \" + ans;\\n        ans.pop_back();\\n        \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1487847,
                "title": "cpp-short-n-simple-stacks-85-fast-solution",
                "content": "```\\n string reverseWords(string s) {\\n        stack<string>st;\\n        for(int i =0;i<s.length();i++){\\n            string word=\"\"; \\n            if(s[i]==\\' \\')continue;\\n            while(s[i]!=\\' \\' and i<s.length()){\\n                word+=s[i];\\n                i++;\\n            }\\n            st.push(word);\\n           \\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n            if(!st.empty())ans+=\" \";\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\n string reverseWords(string s) {\\n        stack<string>st;\\n        for(int i =0;i<s.length();i++){\\n            string word=\"\"; \\n            if(s[i]==\\' \\')continue;\\n            while(s[i]!=\\' \\' and i<s.length()){\\n                word+=s[i];\\n                i++;\\n            }\\n            st.push(word);\\n           \\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n            if(!st.empty())ans+=\" \";\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737794,
                "title": "c-solution-using-stringstream-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        stringstream obj(s); // breaking input string into word using string stream \\n                            \\n        string ans = \"\";\\n        string str;\\n        \\n        vector<string> v;\\n        while(obj>>str)     // read individual word in string str \\n        {\\n           v.push_back(str);    \\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        for(auto j : v)\\n        {\\n            if(ans.size())  ans+=\\' \\';\\n            ans+=j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        stringstream obj(s); // breaking input string into word using string stream \\n                            \\n        string ans = \"\";\\n        string str;\\n        \\n        vector<string> v;\\n        while(obj>>str)     // read individual word in string str \\n        {\\n           v.push_back(str);    \\n        }\\n        \\n        reverse(v.begin(),v.end());\\n        \\n        for(auto j : v)\\n        {\\n            if(ans.size())  ans+=\\' \\';\\n            ans+=j;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47927,
                "title": "comparison-java-string-joining",
                "content": "Motivated by [some discussion](https://leetcode.com/discuss/76026/java-short-and-sweet-7-lines?show=77286#a77286), I wrote a little test to compare different ways of joining strings in Java. The first results:\\n\\n        repeated += [71, 74, 75, 79, 80, 84, 86, 92, 92, 280, 282, 286, 286, 288, 289, 290, 293, 296, 321, 384]\\n      StringBuilder [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 8]\\n       StringBuffer [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]\\n       StringJoiner [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5]\\n        String.join [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4]\\n\\nThings to note:\\n\\n- Naive repeated joining with `+=`, as expected, is very slow due to the quadratic time complexity.\\n- The 384 and 321 apparently are warmup flukes. Always happens.\\n- Also interesting here is a different Java issue, that at the twelfth run, the tests suddenly become three times as fast (from ~280 ms to ~86 ms). Apparently that's [JIT compilation kicking in](http://stackoverflow.com/questions/9964361/performance-of-algorithm-suddenly-increases-by-a-factor-of-10).\\n\\nNext results, with larger tests, only testing the faster ways:\\n    \\n    Joining \"1\"...\"10000000\", times in ms, sorted 20 attempts:\\n      StringBuilder [371, 372, 372, 372, 372, 373, 373, 374, 375, 375, 375, 376, 381, 391, 395, 406, 409, 414, 425, 510]\\n       StringBuffer [388, 388, 388, 389, 389, 389, 389, 390, 390, 390, 390, 390, 391, 391, 392, 392, 394, 401, 405, 419]\\n       StringJoiner [475, 476, 476, 476, 477, 478, 478, 479, 479, 479, 479, 481, 481, 481, 481, 482, 483, 488, 493, 504]\\n        String.join [411, 411, 411, 412, 412, 412, 412, 413, 413, 413, 413, 414, 414, 415, 415, 416, 417, 419, 428, 446]\\n\\nAnd backwards, in case it's advantageous to be first or last:\\n    \\n    Joining \"1\"...\"10000000\", times in ms, sorted 20 attempts:\\n        String.join [408, 408, 408, 408, 408, 409, 409, 409, 409, 410, 410, 410, 410, 410, 410, 410, 411, 414, 428, 439]\\n       StringJoiner [471, 472, 474, 474, 474, 475, 475, 475, 475, 475, 475, 475, 476, 476, 476, 476, 477, 477, 488, 505]\\n       StringBuffer [384, 384, 384, 384, 384, 384, 385, 385, 385, 386, 386, 386, 387, 388, 388, 388, 389, 404, 406, 418]\\n      StringBuilder [367, 367, 368, 368, 368, 368, 369, 369, 369, 369, 369, 369, 371, 371, 371, 371, 371, 371, 372, 391]\\n\\nSo `StringBuilder` was fastest, followed by `StringBuffer` (which is synchronized, and apparently that costs time), followed by `String.join` and then `StringJoiner`. I'm surprised about the order of these last two, as `String.join` uses `StringJoiner` (which btw uses `StringBuilder`).\\n\\n---\\n\\nThe Code\\n---\\n\\n    import java.util.*;\\n\\n    public class JoinTest {\\n            \\n        public static void main(String[] args) {\\n            Test naive = new Test(\"repeated +=\") { void test() {\\n                result = \"\";\\n                for (String s : strings)\\n                    result += s;\\n            }};\\n            Test builder = new Test(\"StringBuilder\") { void test() {\\n                StringBuilder builder = new StringBuilder();\\n                for (String s : strings)\\n                    builder.append(s);\\n                result = builder.toString();\\n            }};\\n            Test buffer = new Test(\"StringBuffer\") { void test() {\\n                StringBuffer buffer = new StringBuffer();\\n                for (String s : strings)\\n                    buffer.append(s);\\n                result = buffer.toString();\\n            }};\\n            Test joiner = new Test(\"StringJoiner\") { void test() {\\n                StringJoiner joiner = new StringJoiner(\"\");\\n                for (String s : strings)\\n                    joiner.add(s);\\n                result = joiner.toString();\\n            }};\\n            Test join = new Test(\"String.join\") { void test() {\\n                result = String.join(\"\", strings);\\n            }};\\n            \\n            warmup();\\n            test(10000, new Test[] {naive, builder, buffer, joiner, join});\\n            test(10000000, new Test[] {builder, buffer, joiner, join});\\n            test(10000000, new Test[] {join, joiner, buffer, builder});\\n        }\\n        \\n        static void warmup() {\\n            int sum = 0;\\n            for (int i=0; i<100000000; i++)\\n                sum += (i + \"\").length();\\n            if (sum != 788888890)\\n                throw new RuntimeException(\"Warmup failed\");\\n        }\\n        \\n        static void test(int n, Test[] tests) {\\n            Test.setup(n);\\n            for (Test test : tests)\\n                test.run();\\n        }\\n\\n        abstract static class Test {\\n            static int attempts = 20;\\n            static int n;\\n            static String[] strings;\\n            static String first, result;\\n            static void setup(int n) {\\n                Test.n = n;\\n                System.out.println();\\n                System.out.println(\"Joining \\\\\"1\\\\\"...\\\\\"\" + n + \"\\\\\"\" +\\n                                   \", times in ms\" +\\n                                   \", sorted \" + attempts + \" attempts:\");\\n                strings = new String[n];\\n                for (int i=0; i<n; i++)\\n                    strings[i] = i+1 + \"\";\\n                first = null;\\n            };\\n            String name;\\n            Test(String name) {\\n                this.name = name;\\n            }\\n            abstract void test();\\n            void run() {\\n                List<Long> times = new ArrayList<>();\\n                for (int i=0; i<attempts; i++) {\\n                    System.gc();\\n                    long t0 = System.currentTimeMillis();\\n                    test();\\n                    long t = System.currentTimeMillis() - t0;\\n                    times.add(t);\\n                    if (first == null)\\n                        first = result;\\n                    else if (!result.equals(first))\\n                        throw new RuntimeException(\"OMG it's wrong.\");\\n                }\\n                Collections.sort(times);\\n                System.out.println(String.format(\"%15s\", name) + \" \" + times);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Motivated by [some discussion](https://leetcode.com/discuss/76026/java-short-and-sweet-7-lines?show=77286#a77286), I wrote a little test to compare different ways of joining strings in Java. The first results:\\n\\n        repeated += [71, 74, 75, 79, 80, 84, 86, 92, 92, 280, 282, 286, 286, 288, 289, 290, 293, 296, 321, 384]\\n      StringBuilder [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 8]\\n       StringBuffer [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]\\n       StringJoiner [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 5]\\n        String.join [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4]\\n\\nThings to note:\\n\\n- Naive repeated joining with `+=`, as expected, is very slow due to the quadratic time complexity.\\n- The 384 and 321 apparently are warmup flukes. Always happens.\\n- Also interesting here is a different Java issue, that at the twelfth run, the tests suddenly become three times as fast (from ~280 ms to ~86 ms). Apparently that's [JIT compilation kicking in](http://stackoverflow.com/questions/9964361/performance-of-algorithm-suddenly-increases-by-a-factor-of-10).\\n\\nNext results, with larger tests, only testing the faster ways:\\n    \\n    Joining \"1\"...\"10000000\", times in ms, sorted 20 attempts:\\n      StringBuilder [371, 372, 372, 372, 372, 373, 373, 374, 375, 375, 375, 376, 381, 391, 395, 406, 409, 414, 425, 510]\\n       StringBuffer [388, 388, 388, 389, 389, 389, 389, 390, 390, 390, 390, 390, 391, 391, 392, 392, 394, 401, 405, 419]\\n       StringJoiner [475, 476, 476, 476, 477, 478, 478, 479, 479, 479, 479, 481, 481, 481, 481, 482, 483, 488, 493, 504]\\n        String.join [411, 411, 411, 412, 412, 412, 412, 413, 413, 413, 413, 414, 414, 415, 415, 416, 417, 419, 428, 446]\\n\\nAnd backwards, in case it's advantageous to be first or last:\\n    \\n    Joining \"1\"...\"10000000\", times in ms, sorted 20 attempts:\\n        String.join [408, 408, 408, 408, 408, 409, 409, 409, 409, 410, 410, 410, 410, 410, 410, 410, 411, 414, 428, 439]\\n       StringJoiner [471, 472, 474, 474, 474, 475, 475, 475, 475, 475, 475, 475, 476, 476, 476, 476, 477, 477, 488, 505]\\n       StringBuffer [384, 384, 384, 384, 384, 384, 385, 385, 385, 386, 386, 386, 387, 388, 388, 388, 389, 404, 406, 418]\\n      StringBuilder [367, 367, 368, 368, 368, 368, 369, 369, 369, 369, 369, 369, 371, 371, 371, 371, 371, 371, 372, 391]\\n\\nSo `StringBuilder` was fastest, followed by `StringBuffer` (which is synchronized, and apparently that costs time), followed by `String.join` and then `StringJoiner`. I'm surprised about the order of these last two, as `String.join` uses `StringJoiner` (which btw uses `StringBuilder`).\\n\\n---\\n\\nThe Code\\n---\\n\\n    import java.util.*;\\n\\n    public class JoinTest {\\n            \\n        public static void main(String[] args) {\\n            Test naive = new Test(\"repeated +=\") { void test() {\\n                result = \"\";\\n                for (String s : strings)\\n                    result += s;\\n            }};\\n            Test builder = new Test(\"StringBuilder\") { void test() {\\n                StringBuilder builder = new StringBuilder();\\n                for (String s : strings)\\n                    builder.append(s);\\n                result = builder.toString();\\n            }};\\n            Test buffer = new Test(\"StringBuffer\") { void test() {\\n                StringBuffer buffer = new StringBuffer();\\n                for (String s : strings)\\n                    buffer.append(s);\\n                result = buffer.toString();\\n            }};\\n            Test joiner = new Test(\"StringJoiner\") { void test() {\\n                StringJoiner joiner = new StringJoiner(\"\");\\n                for (String s : strings)\\n                    joiner.add(s);\\n                result = joiner.toString();\\n            }};\\n            Test join = new Test(\"String.join\") { void test() {\\n                result = String.join(\"\", strings);\\n            }};\\n            \\n            warmup();\\n            test(10000, new Test[] {naive, builder, buffer, joiner, join});\\n            test(10000000, new Test[] {builder, buffer, joiner, join});\\n            test(10000000, new Test[] {join, joiner, buffer, builder});\\n        }\\n        \\n        static void warmup() {\\n            int sum = 0;\\n            for (int i=0; i<100000000; i++)\\n                sum += (i + \"\").length();\\n            if (sum != 788888890)\\n                throw new RuntimeException(\"Warmup failed\");\\n        }\\n        \\n        static void test(int n, Test[] tests) {\\n            Test.setup(n);\\n            for (Test test : tests)\\n                test.run();\\n        }\\n\\n        abstract static class Test {\\n            static int attempts = 20;\\n            static int n;\\n            static String[] strings;\\n            static String first, result;\\n            static void setup(int n) {\\n                Test.n = n;\\n                System.out.println();\\n                System.out.println(\"Joining \\\\\"1\\\\\"...\\\\\"\" + n + \"\\\\\"\" +\\n                                   \", times in ms\" +\\n                                   \", sorted \" + attempts + \" attempts:\");\\n                strings = new String[n];\\n                for (int i=0; i<n; i++)\\n                    strings[i] = i+1 + \"\";\\n                first = null;\\n            };\\n            String name;\\n            Test(String name) {\\n                this.name = name;\\n            }\\n            abstract void test();\\n            void run() {\\n                List<Long> times = new ArrayList<>();\\n                for (int i=0; i<attempts; i++) {\\n                    System.gc();\\n                    long t0 = System.currentTimeMillis();\\n                    test();\\n                    long t = System.currentTimeMillis() - t0;\\n                    times.add(t);\\n                    if (first == null)\\n                        first = result;\\n                    else if (!result.equals(first))\\n                        throw new RuntimeException(\"OMG it's wrong.\");\\n                }\\n                Collections.sort(times);\\n                System.out.println(String.format(\"%15s\", name) + \" \" + times);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 47980,
                "title": "simple-and-clean-c-solution-only-0ms-no-extra-space-very-tricky-to-eliminate-extra-whitespaces",
                "content": "Basic procedure is: Reversing each word individually , and then reversing the whole sentence. For example:\\n\\n\" abc uvw xyz \" --> \"cba wvu zyx\" --> \"xyz uvw abc\"\\n\\nThe AC code:\\n\\n    void reverse(char *p, char *q) {\\n        while (p < --q) {\\n            char tmp = *p;\\n            *p++ = *q;\\n            *q = tmp;\\n        }\\n    }\\n\\n    void reverseWords(char *s) {\\n        char *p = s, *q = s, *r;\\n\\n        while (1) {\\n            while (*q == ' ' || *q == '\\\\t') q++;\\n\\n            if (*q == '\\\\0') break;\\n\\n            r = q + 1;\\n            while (*r != '\\\\0' && *r != ' ' && *r != '\\\\t') r++;\\n\\n            reverse(p, r);\\n            p = r - (q - p) + 1;\\n            q = r;\\n        }\\n\\n        if (p == s) {\\n            *p = '\\\\0';\\n        } else {\\n            *(--p) = '\\\\0';\\n            reverse(s, p);\\n        }\\n    }\\n\\n\\nThe tricky is how eliminating the extra whitespaces. Below are two loops of scanning and reversing:\\n\\n    Initial state:\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    | | |a|b|c| | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n     ^   ^     ^\\n     p   q     r\\n\\n    After \"reverse(p, r)\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n     ^   ^     ^\\n     p   q     r\\n\\n    After \"p = r - (q - p) + 1\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n         ^   ^ ^\\n         q   p r\\n\\n    Next state:\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n             ^     ^     ^\\n             p     q     r\\n\\n    After \"reverse(p, r)\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| |w|v|u| | | | | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n             ^     ^     ^\\n             p     q     r\\n\\n    After \"p = r - (q - p) + 1\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| |w|v|u| | | | | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n                   ^ ^   ^\\n                   q p   r",
                "solutionTags": [],
                "code": "Basic procedure is: Reversing each word individually , and then reversing the whole sentence. For example:\\n\\n\" abc uvw xyz \" --> \"cba wvu zyx\" --> \"xyz uvw abc\"\\n\\nThe AC code:\\n\\n    void reverse(char *p, char *q) {\\n        while (p < --q) {\\n            char tmp = *p;\\n            *p++ = *q;\\n            *q = tmp;\\n        }\\n    }\\n\\n    void reverseWords(char *s) {\\n        char *p = s, *q = s, *r;\\n\\n        while (1) {\\n            while (*q == ' ' || *q == '\\\\t') q++;\\n\\n            if (*q == '\\\\0') break;\\n\\n            r = q + 1;\\n            while (*r != '\\\\0' && *r != ' ' && *r != '\\\\t') r++;\\n\\n            reverse(p, r);\\n            p = r - (q - p) + 1;\\n            q = r;\\n        }\\n\\n        if (p == s) {\\n            *p = '\\\\0';\\n        } else {\\n            *(--p) = '\\\\0';\\n            reverse(s, p);\\n        }\\n    }\\n\\n\\nThe tricky is how eliminating the extra whitespaces. Below are two loops of scanning and reversing:\\n\\n    Initial state:\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    | | |a|b|c| | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n     ^   ^     ^\\n     p   q     r\\n\\n    After \"reverse(p, r)\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n     ^   ^     ^\\n     p   q     r\\n\\n    After \"p = r - (q - p) + 1\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n         ^   ^ ^\\n         q   p r\\n\\n    Next state:\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| | | | |u|v|w| | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n             ^     ^     ^\\n             p     q     r\\n\\n    After \"reverse(p, r)\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| |w|v|u| | | | | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n             ^     ^     ^\\n             p     q     r\\n\\n    After \"p = r - (q - p) + 1\":\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\\n    |c|b|a| |w|v|u| | | | | | |x|y|z| | |\\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  \\n                   ^ ^   ^\\n                   q p   r",
                "codeTag": "Unknown"
            },
            {
                "id": 2809104,
                "title": "java-easy-short-code",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \",words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \",words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808444,
                "title": "python3-one-liner-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFirst of all we split our string by spaces. Than we filter out all empty words that can came out of multiple spaces staying together in the initial string. In the end, we simply join words with space as a separator.\\n\\n*Runtime: 46 ms, faster than 80.65% of Python3 online submissions for Reverse Words in a String.\\nMemory Usage: 13.9 MB, less than 97.78% of Python3 online submissions for Reverse Words in a String.*\\n\\n*Time:* O(n) - linear\\n*Space:* O(n) - for the array containing splitted chunk of string\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([ch for ch in reversed(s.split()) if ch])\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \\' \\'.join([ch for ch in reversed(s.split()) if ch])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634231,
                "title": "100-faster-c-solution-easy-o-n-code-explanation-with-comments",
                "content": "**1. Time Complexity of the approach = O(N) as we are traversing the input string only once in the complete program**\\n\\n**2. Space Complexity of the approach is O(N) as we are using an auxillary string ans for storing the ans**\\n\\nApproach Intuition: In this approach we will traverse the string from the front, we will store each word in a different string and then attatch those individual string of word with the ans word.\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n\\t\\n\\t//we make an answer string, that we have to return\\n        string ans = \"\";\\n\\t\\t\\n\\t//variable for traversing the input string\\n        int i = 0;\\n\\t\\n\\t//here we are traversing the input string\\n        while(i<s.size()){\\n\\t\\t//this is the string to store the individual words\\n            string w;\\n\\t\\t\\t//when the spaces occur keep on going further\\n            while(s[i] == \\' \\'){\\n                i++;\\n            }\\n            \\n\\t\\t\\t//as we detect a char we start putting into our w string for storing the word\\n\\t\\t\\t//this will keep going on until we detect a space\\n            while(i<s.size() and s[i]!=\\' \\'){\\n                w.push_back(s[i]);\\n                i++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// i was stopped on the sight of space so now time to increment i from the current space index\\n\\t\\t\\t//this can be neglected as well because we are taking care of the spaces before the starting of the loop\\n            i++;\\n            \\n\\t\\t\\t//if the word is empty then do nothing, otherwise attatch it to the front of actual ans string with a space\\n            if(w.empty() == false){\\n                ans = w + \" \" + ans;\\n            }\\n        }\\n        \\n\\t\\t//this is a pop to pop the space at the end of the ans, because we are inserting w + space + ans\\n\\t\\t//so when the ans was empty then space was inserted before the word so we need to take care of it.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n\\t\\n\\t//we make an answer string, that we have to return\\n        string ans = \"\";\\n\\t\\t\\n\\t//variable for traversing the input string\\n        int i = 0;\\n\\t\\n\\t//here we are traversing the input string\\n        while(i<s.size()){\\n\\t\\t//this is the string to store the individual words\\n            string w;\\n\\t\\t\\t//when the spaces occur keep on going further\\n            while(s[i] == \\' \\'){\\n                i++;\\n            }\\n            \\n\\t\\t\\t//as we detect a char we start putting into our w string for storing the word\\n\\t\\t\\t//this will keep going on until we detect a space\\n            while(i<s.size() and s[i]!=\\' \\'){\\n                w.push_back(s[i]);\\n                i++;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// i was stopped on the sight of space so now time to increment i from the current space index\\n\\t\\t\\t//this can be neglected as well because we are taking care of the spaces before the starting of the loop\\n            i++;\\n            \\n\\t\\t\\t//if the word is empty then do nothing, otherwise attatch it to the front of actual ans string with a space\\n            if(w.empty() == false){\\n                ans = w + \" \" + ans;\\n            }\\n        }\\n        \\n\\t\\t//this is a pop to pop the space at the end of the ans, because we are inserting w + space + ans\\n\\t\\t//so when the ans was empty then space was inserted before the word so we need to take care of it.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47879,
                "title": "java-in-place",
                "content": "class Solution {\\n  \\n\\n> Blockquote\\n\\n/**\\nIn place word reverse ignoring new String object built. Idea is to reverse each word then reverse the whole string. Space is tackled by trimming and shifting chars to left i.e if i points to space and i-1 also point to space shift chars starting from i+1 left by one place. Decrement end pointer pointing to end of string.\\n\\nExample steps: \\n\\n 1. s =\"  Hello World    \"\\n\\n 2. Trim s = \"Hello World\"\\n\\n 3. Reverse each word - s =\"olleH dlroW\" \\n\\n 4. Reverse whole string s= \"World Hello\" \\n\\n@param s\\n\\n@return reversed string object\\n*/\\n\\n> Blockquote\\n\\n\\tpublic static String reverseWords(String s) {\\n\\t\\tif (s == null)\\n\\t\\t\\treturn null;\\n\\n\\t\\tchar[] str = s.toCharArray();\\n\\t\\tint start = 0, end = str.length - 1;\\n\\n\\t\\t// Trim start of string\\n\\t\\twhile (start <= end && str[start] == ' ')\\n\\t\\t\\tstart++;\\n\\n\\t\\t//Trim end of string\\n\\t\\twhile (end >= 0 && str[end] == ' ')\\n\\t\\t\\tend--;\\n\\n\\t\\tif (start > end)\\n\\t\\t\\treturn new String(\"\");\\n\\n\\t\\tint i = start;\\n\\t\\twhile (i <= end) {\\n\\t\\t\\tif (str[i] != ' ') {\\n\\t\\t\\t\\t// case when i points to a start of word -  find the word reverse it\\n\\t\\t\\t\\tint j = i + 1;\\n\\t\\t\\t\\twhile (j <= end && str[j] != ' ')\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\treverse(str, i, j - 1);\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (str[i - 1] == ' ') {\\n\\t\\t\\t\\t\\t//case when prev char is also space - shift char to left by 1 and decrease end pointer\\n\\t\\t\\t\\t\\tint j = i;\\n\\t\\t\\t\\t\\twhile (j <= end - 1) {\\n\\t\\t\\t\\t\\t\\tstr[j] = str[j + 1];\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t} else\\n\\t\\t\\t\\t\\t// case when there is just single space\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//Now that all words are reversed, time to reverse the entire string pointed by start and end - This step reverses the words in string\\n\\t\\treverse(str, start, end);\\n\\t\\t// return new string object pointed by start with len = end -start + 1\\n\\t\\treturn new String(str, start, end - start + 1);\\n\\t}\\n\\n\\tprivate static void reverse(char[] str, int begin, int end) {\\n\\t\\twhile (begin < end) {\\n\\t\\t\\tchar temp = str[begin];\\n\\t\\t\\tstr[begin] = str[end];\\n\\t\\t\\tstr[end] = temp;\\n\\t\\t\\tbegin++;\\n\\t\\t\\tend--;\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  \\n\\n> Blockquote\\n\\n/**\\nIn place word reverse ignoring new String object built. Idea is to reverse each word then reverse the whole string. Space is tackled by trimming and shifting chars to left i.e if i points to space and i-1 also point to space shift chars starting from i+1 left by one place. Decrement end pointer pointing to end of string.\\n\\nExample steps: \\n\\n 1. s =\"  Hello World    \"\\n\\n 2. Trim s = \"Hello World\"\\n\\n 3. Reverse each word - s =\"olleH dlroW\" \\n\\n 4. Reverse whole string s= \"World Hello\" \\n\\n@param s\\n\\n@return reversed string object\\n*/\\n\\n> Blockquote\\n\\n\\tpublic static String reverseWords(String s) {\\n\\t\\tif (s == null)\\n\\t\\t\\treturn null;\\n\\n\\t\\tchar[] str = s.toCharArray();\\n\\t\\tint start = 0, end = str.length - 1;\\n\\n\\t\\t// Trim start of string\\n\\t\\twhile (start <= end && str[start] == ' ')\\n\\t\\t\\tstart++;\\n\\n\\t\\t//Trim end of string\\n\\t\\twhile (end >= 0 && str[end] == ' ')\\n\\t\\t\\tend--;\\n\\n\\t\\tif (start > end)\\n\\t\\t\\treturn new String(\"\");\\n\\n\\t\\tint i = start;\\n\\t\\twhile (i <= end) {\\n\\t\\t\\tif (str[i] != ' ') {\\n\\t\\t\\t\\t// case when i points to a start of word -  find the word reverse it\\n\\t\\t\\t\\tint j = i + 1;\\n\\t\\t\\t\\twhile (j <= end && str[j] != ' ')\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\treverse(str, i, j - 1);\\n\\t\\t\\t\\ti = j;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3617268,
                "title": "c-easy-solution-beats-87-73-t-c",
                "content": "# Solution Using Stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       \\n       string temp = \"\";\\n       stack<string>st;\\n       for(int i=0; i<s.size();i++){\\n           char ch = s[i];\\n           if(ch == \\' \\'){\\n               if(temp != \"\")\\n                   st.push(temp);\\n               temp = \"\";\\n           }\\n\\n           else\\n            temp+=ch;\\n       }\\n\\n       if(temp!=\"\"){\\n           st.push(temp);\\n       }\\n       string ans = \"\";\\n\\n       while(!st.empty()){\\n           ans+=(st.top()+\" \");\\n           st.pop();\\n       }\\n       ans.pop_back();\\n\\n       return ans;\\n      \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       \\n       string temp = \"\";\\n       stack<string>st;\\n       for(int i=0; i<s.size();i++){\\n           char ch = s[i];\\n           if(ch == \\' \\'){\\n               if(temp != \"\")\\n                   st.push(temp);\\n               temp = \"\";\\n           }\\n\\n           else\\n            temp+=ch;\\n       }\\n\\n       if(temp!=\"\"){\\n           st.push(temp);\\n       }\\n       string ans = \"\";\\n\\n       while(!st.empty()){\\n           ans+=(st.top()+\" \");\\n           st.pop();\\n       }\\n       ans.pop_back();\\n\\n       return ans;\\n      \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737225,
                "title": "javascript-one-line-solution",
                "content": "```\\nvar reverseWords = function(s) {\\n    return s.split(\" \").filter(Boolean).reverse().join(\" \");\\n};\\n```\\n\\n1. We divide the string into an array of substrings using space as a separator\\n2. We remove empty tokens from the array\\n3. We reverse the array\\n4. We put the string back together using space as a delimiter",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseWords = function(s) {\\n    return s.split(\" \").filter(Boolean).reverse().join(\" \");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 47729,
                "title": "c-o-1-space",
                "content": "In-place.\\n```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        // Reverse string\\n        reverse(s.begin(), s.end());\\n        // Reverse every word\\n        int i = 0, j = 0;\\n        while(i != s.size()){\\n            while(j < s.size() && s[j] != ' ') j++;\\n            reverse(s.begin() + i, s.begin() + j);\\n            i = j;\\n            while(i < s.size() && s[i] == ' ') i++, j++;\\n        }\\n        // Remove extra ' '\\n        i = 0, j = 0;\\n        while(j < s.size()){\\n            bool new_word = false;\\n            while(j < s.size() && s[j] == ' '){\\n                new_word = true;\\n                j++;\\n            }\\n            if(j == s.size()) break;\\n            if(new_word && i > 0) s[i++] = ' ';\\n            s[i++] = s[j++];\\n        }\\n        s = s.substr(0, i);\\n    }\\n};\\n```\\n***\\nAnd with extra space.\\n```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        string res = \"\";\\n        string word = \"\";\\n        int j = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            while(s[i] == ' ') i++;\\n            j = i;\\n            while(s[j] != ' ') j++;\\n            word = s.substr(i, j - i);\\n            if(res != \"\" && word != \"\") word += \" \";\\n            res = word + res;\\n            i = j;\\n        }\\n        s = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        // Reverse string\\n        reverse(s.begin(), s.end());\\n        // Reverse every word\\n        int i = 0, j = 0;\\n        while(i != s.size()){\\n            while(j < s.size() && s[j] != ' ') j++;\\n            reverse(s.begin() + i, s.begin() + j);\\n            i = j;\\n            while(i < s.size() && s[i] == ' ') i++, j++;\\n        }\\n        // Remove extra ' '\\n        i = 0, j = 0;\\n        while(j < s.size()){\\n            bool new_word = false;\\n            while(j < s.size() && s[j] == ' '){\\n                new_word = true;\\n                j++;\\n            }\\n            if(j == s.size()) break;\\n            if(new_word && i > 0) s[i++] = ' ';\\n            s[i++] = s[j++];\\n        }\\n        s = s.substr(0, i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        string res = \"\";\\n        string word = \"\";\\n        int j = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            while(s[i] == ' ') i++;\\n            j = i;\\n            while(s[j] != ' ') j++;\\n            word = s.substr(i, j - i);\\n            if(res != \"\" && word != \"\") word += \" \";\\n            res = word + res;\\n            i = j;\\n        }\\n        s = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48034,
                "title": "a-clean-c-solution-with-time-o-n-space-o-1",
                "content": "Works for Reverse Words in a String II, too.\\n\\n    class Solution {\\n    public:\\n        void reverseWords(string &s) {\\n            int i, len, start, end;\\n            // remove leading spaces\\n            for (i = 0; i < s.size() && ' ' == s[i]; i++)\\n                ;\\n            start = i;\\n            // remove trailing spaces\\n            for (i = s.size() - 1; i >= 0 && ' ' == s[i]; i--)\\n                ;\\n            end = i;\\n            // remove multiple spaces btw. words\\n            for (i = start, len = 0; i <= end; i++) {\\n                if (' ' == s[i] && ' ' == s[i - 1])\\n                    continue;\\n                s[len++] = s[i];\\n            }\\n            s.erase(s.begin() + len, s.end());\\n    \\n            reverse(s.begin(), s.end());\\n            for (i = 0, start = 0; i < s.size(); i++) {\\n                if (s[i] == ' ') {\\n                    reverse(s.begin() + start, s.begin() + i);\\n                    start = i + 1;\\n                }\\n            }\\n            // last word\\n            reverse(s.begin() + start, s.end());\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void reverseWords(string &s) {\\n            int i, len, start, end;\\n            // remove leading spaces\\n            for (i = 0; i < s.size() && ' ' == s[i]; i++)\\n                ;\\n            start = i;\\n            // remove trailing spaces\\n            for (i = s.size() - 1; i >= 0 && ' ' == s[i]; i--)\\n                ;\\n            end = i;\\n            // remove multiple spaces btw. words\\n            for (i = start, len = 0; i <= end; i++) {\\n                if (' ' == s[i] && ' ' == s[i - 1])\\n                    continue;\\n                s[len++] = s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3666063,
                "title": "python-o-1-spatial-complexity",
                "content": "# Intuition\\n\\nExample :\\n```\\n\"ABCDEF 123 abc\" (input)\\n\"abc 123 ABCDEF\" (expected output)\\n```\\n\\n\\nIf you try to reverse the input you will get :\\n```\\n\"cba 321 FEDCBA\"\\n```\\nNow compare the reversed with expected output :\\n```\\n\"cba 321 FEDCBA\"\\n  |   |     |\\n\"abc 123 ABCDEF\" (expected output)\\n```\\nYou see you only need to reverse each words to get the expected output.\\n\\n\\n# Approach\\n\\n- Reverse all the input (reverseOneWord function).\\n- Reverse each word (reverseWords function).\\n- Supress the space series (deleteSpacesSeries function using two pointer method to stay in O(1) in spatial complexity).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Spatial complextiy: O(1)  if we don\\'t take account of str to  list conversion (in fact you can\\'t get O(1) in python because the conversion is O(n) and you need it because str are immuable in python) and list to str\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseOneWord(self, s: list, debut: int, fin: int):\\n        i = 0\\n        while i < (fin-debut)//2:\\n            s[debut+i],s[fin-1-i]=s[fin-1-i],s[debut+i]\\n            i+=1\\n\\n    def deleteSpacesSeries(self, s: list):\\n        i = len(s)-1\\n        while i>=0 and s[i]==\" \":\\n            s.pop()\\n            i-=1\\n\\n        i = 0\\n        while i < len(s) and s[i]==\" \":\\n            i+=1\\n\\n        write_i = 0\\n\\n        while i < len(s):\\n            if not (s[i-1]==s[i]==\" \"):\\n                s[write_i] = s[i]\\n                write_i += 1\\n            i += 1\\n\\n\\n        for _ in range(len(s)-write_i):\\n            s.pop()\\n\\n\\n\\n    def reverseWords(self, s: str) -> str:\\n        s = list(s)\\n\\n        self.reverseOneWord(s, 0, len(s))\\n\\n        i = 0\\n        motDebut = 0\\n        motFin = 0\\n        estMotFini = False\\n\\n        while i < len(s):\\n            if s[i]==\" \":\\n                if estMotFini:\\n                    self.reverseOneWord(s, motDebut, motFin+1)\\n                    estMotFini = False\\n            else:\\n                if not estMotFini:\\n                    estMotFini = True\\n                    motDebut = i\\n                    motFin = i\\n                else:\\n                    motFin += 1\\n            i+=1\\n\\n        if estMotFini:\\n            self.reverseOneWord(s, motDebut, motFin+1)\\n\\n        self.deleteSpacesSeries(s)\\n\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\"ABCDEF 123 abc\" (input)\\n\"abc 123 ABCDEF\" (expected output)\\n```\n```\\n\"cba 321 FEDCBA\"\\n```\n```\\n\"cba 321 FEDCBA\"\\n  |   |     |\\n\"abc 123 ABCDEF\" (expected output)\\n```\n```\\nclass Solution:\\n    def reverseOneWord(self, s: list, debut: int, fin: int):\\n        i = 0\\n        while i < (fin-debut)//2:\\n            s[debut+i],s[fin-1-i]=s[fin-1-i],s[debut+i]\\n            i+=1\\n\\n    def deleteSpacesSeries(self, s: list):\\n        i = len(s)-1\\n        while i>=0 and s[i]==\" \":\\n            s.pop()\\n            i-=1\\n\\n        i = 0\\n        while i < len(s) and s[i]==\" \":\\n            i+=1\\n\\n        write_i = 0\\n\\n        while i < len(s):\\n            if not (s[i-1]==s[i]==\" \"):\\n                s[write_i] = s[i]\\n                write_i += 1\\n            i += 1\\n\\n\\n        for _ in range(len(s)-write_i):\\n            s.pop()\\n\\n\\n\\n    def reverseWords(self, s: str) -> str:\\n        s = list(s)\\n\\n        self.reverseOneWord(s, 0, len(s))\\n\\n        i = 0\\n        motDebut = 0\\n        motFin = 0\\n        estMotFini = False\\n\\n        while i < len(s):\\n            if s[i]==\" \":\\n                if estMotFini:\\n                    self.reverseOneWord(s, motDebut, motFin+1)\\n                    estMotFini = False\\n            else:\\n                if not estMotFini:\\n                    estMotFini = True\\n                    motDebut = i\\n                    motFin = i\\n                else:\\n                    motFin += 1\\n            i+=1\\n\\n        if estMotFini:\\n            self.reverseOneWord(s, motDebut, motFin+1)\\n\\n        self.deleteSpacesSeries(s)\\n\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809928,
                "title": "c-java-simple-solution-and-in-place-also-easy-solution-o-1",
                "content": "**C++**\\n**Approach 1: With extra Space \\u2705**\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result;\\n        int i=0;\\n        int n = s.length();\\n        while(i<n){\\n            while(i<n && s[i] == \\' \\'){  // skip space in front\\n                i++;\\n            }\\n            if(i >= n) break;\\n            int j = i+1;\\n            while(j < n && s[j] != \\' \\'){ // place the word at the starting , removing spaces\\n                j++;\\n            }\\n            string sub = s.substr(i,j-i);\\n            if(result.length() == 0) result = sub;\\n            else\\n            {\\n                result = sub + \" \"+result;\\n            \\n            }\\n            i = j+1;\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Approach 2: Inplace \\u2705**\\n```\\nclass Solution {\\npublic:\\n     void reverseword(string &s, int i, int j){  //reverse string from i to j\\n        while(i<j){\\n            char t = s[i];\\n            s[i++] = s[j];\\n            s[j--] = t;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int i =0,j=0;\\n        int l =0;\\n        int len = s.size();\\n        \\n        int wordcount = 0;\\n        \\n        while(true){\\n            while(i < len && s[i] == \\' \\')  // skip space in front\\n                i++;\\n            if(i == len)\\n                break;\\n            if(wordcount)   // add space between the middle words\\n                s[j++] = \\' \\';\\n            l = j;\\n            while(i < len && s[i] != \\' \\'){ // place the word at the starting , removing spaces\\n                s[j] = s[i];\\n                j++;\\n                i++;\\n            }\\n            reverseword(s,l,j-1); // reverse word\\n            wordcount++;\\n        }\\n        s.resize(j);  // resize s to smaller string after removing spaces\\n        reverse(s.begin(),s.end()); //finally , reverse entire string to get the result\\n        return s;\\n    }\\n};\\n```\\n**Java \\u2705**\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result = new String();\\n        int i=0;\\n        int n = s.length();\\n        while(i<n){\\n            while(i<n && s.charAt(i) == \\' \\'){\\n                i++;\\n            }\\n            if(i >= n) break;\\n            int j = i+1;\\n            while(j < n && s.charAt(j) != \\' \\'){\\n                j++;\\n            }\\n            String sub = s.substring(i,j);\\n            if(result.length() == 0) result = sub;\\n            else\\n            {\\n                result = sub + \" \"+result;\\n            \\n            }\\n            i = j+1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result;\\n        int i=0;\\n        int n = s.length();\\n        while(i<n){\\n            while(i<n && s[i] == \\' \\'){  // skip space in front\\n                i++;\\n            }\\n            if(i >= n) break;\\n            int j = i+1;\\n            while(j < n && s[j] != \\' \\'){ // place the word at the starting , removing spaces\\n                j++;\\n            }\\n            string sub = s.substr(i,j-i);\\n            if(result.length() == 0) result = sub;\\n            else\\n            {\\n                result = sub + \" \"+result;\\n            \\n            }\\n            i = j+1;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     void reverseword(string &s, int i, int j){  //reverse string from i to j\\n        while(i<j){\\n            char t = s[i];\\n            s[i++] = s[j];\\n            s[j--] = t;\\n        }\\n    }\\n    string reverseWords(string s) {\\n        int i =0,j=0;\\n        int l =0;\\n        int len = s.size();\\n        \\n        int wordcount = 0;\\n        \\n        while(true){\\n            while(i < len && s[i] == \\' \\')  // skip space in front\\n                i++;\\n            if(i == len)\\n                break;\\n            if(wordcount)   // add space between the middle words\\n                s[j++] = \\' \\';\\n            l = j;\\n            while(i < len && s[i] != \\' \\'){ // place the word at the starting , removing spaces\\n                s[j] = s[i];\\n                j++;\\n                i++;\\n            }\\n            reverseword(s,l,j-1); // reverse word\\n            wordcount++;\\n        }\\n        s.resize(j);  // resize s to smaller string after removing spaces\\n        reverse(s.begin(),s.end()); //finally , reverse entire string to get the result\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result = new String();\\n        int i=0;\\n        int n = s.length();\\n        while(i<n){\\n            while(i<n && s.charAt(i) == \\' \\'){\\n                i++;\\n            }\\n            if(i >= n) break;\\n            int j = i+1;\\n            while(j < n && s.charAt(j) != \\' \\'){\\n                j++;\\n            }\\n            String sub = s.substring(i,j);\\n            if(result.length() == 0) result = sub;\\n            else\\n            {\\n                result = sub + \" \"+result;\\n            \\n            }\\n            i = j+1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809269,
                "title": "python-3-line-code-easy-solution",
                "content": "\\n        l=s.split()\\n        l=l[::-1]\\n        return \\' \\'.join(l)",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\n        l=s.split()\\n        l=l[::-1]\\n        return \\' \\'.join(l)",
                "codeTag": "Unknown"
            },
            {
                "id": 2809062,
                "title": "java-easy-simple-and-fast-solution-using-stringbuilders",
                "content": "# Approach\\nTaking 2 StringBuilders , one which stores the overall answer and the other which stores that specific word, once we have the specific word we add it to the answer after reversing it as we are moving from right to left.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n        int n = s.length();\\n        StringBuilder ans = new StringBuilder(\"\");\\n        StringBuilder temp = new StringBuilder(\"\");\\n\\n        for( int i=n-1; i>=0; i-- ) {\\n            char ch = s.charAt(i);\\n\\n            if( ch!=\\' \\' ) temp.append(ch);\\n            \\n            if( (ch==\\' \\' || i==0 ) && temp.length()>0 ) {\\n                if( ans.length()>0 ) ans.append(\" \");\\n                temp.reverse();\\n                ans.append(temp);\\n                temp.setLength(0);\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n        int n = s.length();\\n        StringBuilder ans = new StringBuilder(\"\");\\n        StringBuilder temp = new StringBuilder(\"\");\\n\\n        for( int i=n-1; i>=0; i-- ) {\\n            char ch = s.charAt(i);\\n\\n            if( ch!=\\' \\' ) temp.append(ch);\\n            \\n            if( (ch==\\' \\' || i==0 ) && temp.length()>0 ) {\\n                if( ans.length()>0 ) ans.append(\" \");\\n                temp.reverse();\\n                ans.append(temp);\\n                temp.setLength(0);\\n            }\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752338,
                "title": "easy-c-solution-using-stack-in-o-n-complexity",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re taking a stack to store the words & with this, we\\u2019ll create the ans string as it follows LIFO order.\\n- Iterate all the elements from the given string. There can be 3 possible cases:\\n    - `s[i] == \\' \\' && word.size() != 0` Here we find an space and also we have element in our word string. So, we\\u2019ll push the element to our stack & make word empty string.\\n    - `s[i] == \\' \\' && word.size() == 0` Here also we get spaces but this time there\\u2019s no element in out word sting, so we\\u2019ll simply ignore this.\\n    - `word += s[i]` else add current character to our word string.\\n- After the loop end, if a word has an element inside it then simply push it to the stack.\\n- Now iterate the stack elements and add this to our ans string with a space.\\n- After that simply remove the last space from ans, `ans.erase(ans.size()-1)`\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string ans, word;\\n        int n = s.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\' \\' && word.size() != 0){\\n                st.push(word); \\n                word = \"\";\\n            }\\n            else if(s[i] == \\' \\' && word.size() == 0){\\n                continue;\\n            }\\n            else\\n                word += s[i];\\n        }\\n        if(word.size() != 0){\\n            st.push(word); \\n            word = \"\";\\n        }      \\n        while(!st.empty()){\\n            string temp = st.top();\\n            ans += temp + \\' \\';\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string ans, word;\\n        int n = s.size();\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\' \\' && word.size() != 0){\\n                st.push(word); \\n                word = \"\";\\n            }\\n            else if(s[i] == \\' \\' && word.size() == 0){\\n                continue;\\n            }\\n            else\\n                word += s[i];\\n        }\\n        if(word.size() != 0){\\n            st.push(word); \\n            word = \"\";\\n        }      \\n        while(!st.empty()){\\n            string temp = st.top();\\n            ans += temp + \\' \\';\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142231,
                "title": "python-without-built-in-split",
                "content": "Of course the problem could be easily solved by using built in split function.However, it is better for us to practice the algorithm by not doing so. In real world, it is better to use built-ins as they are usually optimized in C\\nHere is my solution without split function\\n```\\n new_string = \"\"\\n        j = len(s)\\n        # iterate the str in a reversed order\\n        for i in range(len(s)-1,-1,-1):\\n            # trim the trailing space\\n            if s[i] == \" \":\\n                j = i\\n            # if we encountered a \" \" before the worlds, we know a word ended here, append \" \" or the word\\n            elif i == 0 or s[i-1] == \" \":\\n                if len(new_string) != 0:\\n                    new_string += \" \"\\n                new_string += s[i:j]\\n        return new_string\\n        ```",
                "solutionTags": [],
                "code": "```\\n new_string = \"\"\\n        j = len(s)\\n        # iterate the str in a reversed order\\n        for i in range(len(s)-1,-1,-1):\\n            # trim the trailing space\\n            if s[i] == \" \":\\n                j = i\\n            # if we encountered a \" \" before the worlds, we know a word ended here, append \" \" or the word\\n            elif i == 0 or s[i-1] == \" \":\\n                if len(new_string) != 0:\\n                    new_string += \" \"\\n                new_string += s[i:j]\\n        return new_string\\n        ```",
                "codeTag": "Unknown"
            },
            {
                "id": 47846,
                "title": "one-line-python-code",
                "content": "``` \\ndef reverseWords(self, s):\\n        return ' '.join(reversed(s.split()))",
                "solutionTags": [],
                "code": "``` \\ndef reverseWords(self, s):\\n        return ' '.join(reversed(s.split()))",
                "codeTag": "Python3"
            },
            {
                "id": 47958,
                "title": "python-solution-reverse-word-by-word",
                "content": "        \\n    def reverseWords(self, s):\\n        s = list(\" \".join(s.split()))[::-1]\\n        i = 0 \\n        while i < len(s):\\n            start = i \\n            while i < len(s) and not s[i].isspace():\\n                i += 1\\n            self.reverse(s, start, i-1)\\n            i += 1\\n        return \"\".join(s)\\n    \\n    def reverse(self, s, i, j):\\n        while i < j:\\n            s[i], s[j] = s[j], s[i]\\n            i += 1; j -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def reverseWords(self, s):\\n        s = list(\" \".join(s.split()))[::-1]\\n        i = 0 \\n        while i < len(s):\\n            start = i \\n            while i < len(s) and not s[i].isspace():\\n                i += 1\\n            self.reverse(s, start, i-1)\\n            i += 1\\n        return \"\".join(s)\\n    \\n    def reverse(self, s, i, j):\\n        while i < j:\\n            s[i], s[j] = s[j], s[i]\\n            i += 1; j -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 3528022,
                "title": "very-easy-and-step-by-step-explained-java",
                "content": "# Intuition\\nA StringBuilder Can be used to achieve this solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Split all spaces and store it in a string array (`str`).\\n2) Now, our `str` array has words and some empty spaces`\"\"` due to multiple spaces in String. So we need to ignore it.\\n3) Only add those str[i] that is not `\"\"`. So add all these is reverse order so run a for loop backward.\\n4) After addign all elements now you have a space in last of the string builder.\\n5) So use this trick to delete that space.\\n```\\nsb.setLength(sb.length() - 1);\\n```\\n> It actually reduces stringbuilder length so the last space delete automatically.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$ (n is the length of str array)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Upvote if you find this code unique.\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = str.length - 1; i >= 0; i--){\\n            if(str[i] != \"\"){\\n                sb.append(str[i]); // add word\\n                sb.append(\" \"); // add space after that word\\n            }\\n        }\\n        sb.setLength(sb.length() - 1); //delete last space by reducing size\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nsb.setLength(sb.length() - 1);\\n```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] str = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = str.length - 1; i >= 0; i--){\\n            if(str[i] != \"\"){\\n                sb.append(str[i]); // add word\\n                sb.append(\" \"); // add space after that word\\n            }\\n        }\\n        sb.setLength(sb.length() - 1); //delete last space by reducing size\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809039,
                "title": "python-3-line-solution-with-explanation-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.strip()\\n        s = s.split()\\n        return \" \".join(s[::-1])\\n```\\n\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/program-to-reverse-words-in-string.html\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s = s.strip()\\n        s = s.split()\\n        return \" \".join(s[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47988,
                "title": "0-ms-easy-solution-in-c",
                "content": "    void reverse(char *start,char *end)\\n    {\\n        while(end > start)\\n        {\\n            char temp = *start;\\n            *start = *end;\\n            *end = temp;\\n            start++,end--;\\n        }\\n    }\\n    \\n    void trim(char *S)\\n    {\\n        int count = 0;\\n        int N = strlen(S);\\n        int flag = 1;\\n        for(int i=0;i<N;i++)\\n        {\\n            if(S[i] != ' ')\\n            {\\n                S[count++] = S[i];\\n                flag = 0;\\n            }\\n            else\\n            {\\n                if(!flag)\\n                {\\n                    S[count++] = S[i];\\n                    flag = 1;\\n                }\\n            }\\n        }\\n        if(count >= 1 && S[count-1] == ' ')\\n            S[count-1] = '\\\\0';\\n        else\\n            S[count] = '\\\\0';\\n    }\\n    \\n    void reverseWords(char *S)\\n    {\\n        trim(S);\\n        char *temp = S,*prev = S;\\n        while(*temp)\\n        {\\n            temp++;\\n            if(*temp == ' ')\\n            {\\n                reverse(prev,temp-1);\\n                prev = temp+1;\\n            }\\n            else if(*temp == '\\\\0')\\n            {\\n                reverse(prev,temp-1);\\n            }\\n        }\\n        reverse(S,temp-1);\\n    }",
                "solutionTags": [],
                "code": "    void reverse(char *start,char *end)\\n    {\\n        while(end > start)\\n        {\\n            char temp = *start;\\n            *start = *end;\\n            *end = temp;\\n            start++,end--;\\n        }\\n    }\\n    \\n    void trim(char *S)\\n    {\\n        int count = 0;\\n        int N = strlen(S);\\n        int flag = 1;\\n        for(int i=0;i<N;i++)\\n        {\\n            if(S[i] != ' ')\\n            {\\n                S[count++] = S[i];\\n                flag = 0;\\n            }\\n            else\\n            {\\n                if(!flag)\\n                {\\n                    S[count++] = S[i];\\n                    flag = 1;\\n                }\\n            }\\n        }\\n        if(count >= 1 && S[count-1] == ' ')\\n            S[count-1] = '\\\\0';\\n        else\\n            S[count] = '\\\\0';\\n    }\\n    \\n    void reverseWords(char *S)\\n    {\\n        trim(S);\\n        char *temp = S,*prev = S;\\n        while(*temp)\\n        {\\n            temp++;\\n            if(*temp == ' ')\\n            {\\n                reverse(prev,temp-1);\\n                prev = temp+1;\\n            }\\n            else if(*temp == '\\\\0')\\n            {\\n                reverse(prev,temp-1);\\n            }\\n        }\\n        reverse(S,temp-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48209,
                "title": "are-we-allowed-to-use-java-build-in-functions",
                "content": "Hi all,<br>\\nI solved this problem by using java build-in functions: split and trim. I'm wondering if we are expected to use them or not, because this problem may become too easy by using these functions.\\n\\n    public String reverseWords(String s) {\\n        if (s == null || s.length() <= 0) return s;\\n        String[] words = s.split(\" +\");\\n        StringBuilder ret = new StringBuilder();\\n        for (int i = words.length - 1; i >= 0; i--)\\n            if (words[i].length() > 0) ret.append(words[i]).append(\" \");\\n        return ret.toString().trim();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi all,<br>\\nI solved this problem by using java build-in functions: split and trim. I'm wondering if we are expected to use them or not, because this problem may become too easy by using these functions.\\n\\n    public String reverseWords(String s) {\\n        if (s == null || s.length() <= 0) return s;\\n        String[] words = s.split(\" +\");\\n        StringBuilder ret = new StringBuilder();\\n        for (int i = words.length - 1; i >= 0; i--)\\n            if (words[i].length() > 0) ret.append(words[i]).append(\" \");\\n        return ret.toString().trim();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4008711,
                "title": "js-5-liner-easy-approach-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly you have to split the string with space to iterate to each word.\\n- In for loop, if the word is other than space then the word will be added to the output and if output it not empty then it will add one extra space at the beginning of the word to separate the words. ( first time during iteration, we don\\'t have to add extra space otherwise it will become like \" the sky is blue\" ) \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function (s) {\\n    let str = s.split(\" \");\\n    let output = \"\";\\n    for (let i = str.length - 1; i >= 0; i--)\\n        if (str[i]) output += (output ? \" \" : \"\") + str[i];\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = function (s) {\\n    let str = s.split(\" \");\\n    let output = \"\";\\n    for (let i = str.length - 1; i >= 0; i--)\\n        if (str[i]) output += (output ? \" \" : \"\") + str[i];\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876256,
                "title": "easy-c-solution-two-pointer-approach-basic-solution-and-self-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string p;\\n        int i=0;\\n        int n=s.length();\\n        while(i<n)\\n        {\\n            while(i<n&& s[i]==\\' \\')\\n            {\\n                i++;\\n            }\\n            if(i>=n)\\n            break;\\n            int j=i+1;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                j++;\\n            }\\n            string sub=s.substr(i,j-i);\\n            if(p.length()==0)\\n            {\\n                p=sub+p;\\n            }\\n            else{p=sub+\" \"+p;}\\n            i=j+1;\\n        } \\n        return p; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string p;\\n        int i=0;\\n        int n=s.length();\\n        while(i<n)\\n        {\\n            while(i<n&& s[i]==\\' \\')\\n            {\\n                i++;\\n            }\\n            if(i>=n)\\n            break;\\n            int j=i+1;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                j++;\\n            }\\n            string sub=s.substr(i,j-i);\\n            if(p.length()==0)\\n            {\\n                p=sub+p;\\n            }\\n            else{p=sub+\" \"+p;}\\n            i=j+1;\\n        } \\n        return p; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771663,
                "title": "simple-code-with-explanation",
                "content": "# Please upvote if you feel it easy \\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        //Removing all the spaces and adding the words \\n        // in the string array.\\n        String[] words = s.split(\" +\");\\n        //Creating stringbuilder so that we can modify immutable \\n        //string to mutable string\\n        StringBuilder sb = new StringBuilder();\\n        //reverse the words array\\n        for(int i=words.length-1;i>=0;i--) {\\n            sb.append(words[i]);\\n            sb.append(\" \");\\n        }\\n        //converting stringbuilder to string and removing all \\n        // head and trail spaces using trim() function\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        //Removing all the spaces and adding the words \\n        // in the string array.\\n        String[] words = s.split(\" +\");\\n        //Creating stringbuilder so that we can modify immutable \\n        //string to mutable string\\n        StringBuilder sb = new StringBuilder();\\n        //reverse the words array\\n        for(int i=words.length-1;i>=0;i--) {\\n            sb.append(words[i]);\\n            sb.append(\" \");\\n        }\\n        //converting stringbuilder to string and removing all \\n        // head and trail spaces using trim() function\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645754,
                "title": "100-faster-in-runtime-for-c-95-for-java-easy-to-understand-tc-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition involves iterating through the string from the end, identifying words by spaces, reversing each word, and appending them to the final list. By reversing the words in this manner, the resulting string will have the words in reversed order while maintaining the relative order of characters within each word.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty list ans to store the reversed words.\\n- Start iterating from the last character of the input string s.\\n- Check if the current character is a space. If it is, move to the next character.\\n- If the current character is not a space, initialize a temporary list temp with a space character.\\n- Iterate backwards from the current position until either a space is encountered or the beginning of the string is reached.\\n- Append each character to the temp list in reverse order.\\n- Reverse the temp list and extend it to the ans list.\\n- Update the index to continue from the next word.\\n- Repeat steps 3 to 8 until all characters in s have been processed.\\n- Remove the extra space character appended at the end of the ans list.\\n- Convert the ans list to a string by joining the elements without any delimiter.\\n- Return the resulting string as the reversed words.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each character in the input string s once, starting from the last character and moving towards the first character.\\nWithin each iteration, the code performs a constant amount of operations to check for spaces and build temporary lists.\\nThe time complexity is therefore O(n), where n is the length of the input string s.\\n\\n- Space complexity: O(m*n) / O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses additional space to store the reversed words in a list ans and the temporary list temp.\\nThe space required by the lists depends on the number of words in the input string and their lengths.\\nIn the worst case, if the input string has all words separated by spaces and each word is of length m, the space complexity is O(m*n), where n is the number of words in the input string.\\nHowever, if the input string has no spaces or only one word, the space complexity reduces to O(n) as there are no temporary lists created for each word.\\nOverall, the space complexity can be approximated as O(m*n) or O(n), depending on the characteristics of the input string.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        ios_base::sync_with_stdio(false);   // Disable synchronization between C++ input/output streams and C standard streams for improved execution speed\\n        cout.tie(nullptr);   // Untie the cout stream from other streams for improved execution speed\\n        cin.tie(nullptr);    // Untie the cin stream from other streams for improved execution speed\\n\\n        int n = s.size();   // Get the size of the input string\\n        string ans = \"\";   // Initialize an empty string to store the reversed words\\n        int i = n - 1;   // Start from the last character of the input string\\n\\n        while (i >= 0) {\\n            if (s[i] == \\' \\') {\\n                i--;   // If the current character is a space, move to the next character\\n            }\\n            else {\\n                string temp = \" \";   // Initialize a temporary string with a space character\\n                int j = i;\\n                while (j >= 0 && s[j] != \\' \\') {\\n                    temp += s[j];   // Append each character to the temporary string in reverse order\\n                    j--;\\n                }\\n                reverse(temp.begin(), temp.end());   // Reverse the characters in the temporary string\\n                ans += temp;   // Append the reversed word to the final string\\n                i = j;   // Update the index to continue from the next word\\n            }\\n        }\\n\\n        ans.pop_back();   // Remove the extra space character appended at the end\\n\\n        return ans;   // Return the reversed words as the output\\n    }\\n};\\n\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int n = s.length(); // Get the length of the input string\\n        StringBuilder ans = new StringBuilder(); // Initialize a StringBuilder to store the reversed words\\n        int i = n - 1; // Start from the last character of the input string\\n\\n        while (i >= 0) {\\n            if (s.charAt(i) == \\' \\') {\\n                i--; // If the current character is a space, move to the next character\\n            } else {\\n                StringBuilder temp = new StringBuilder(\" \"); // Initialize a temporary StringBuilder with a space character\\n                int j = i;\\n                while (j >= 0 && s.charAt(j) != \\' \\') {\\n                    temp.append(s.charAt(j)); // Append each character to the temporary StringBuilder in reverse order\\n                    j--;\\n                }\\n                ans.append(temp.reverse()); // Reverse the characters in the temporary StringBuilder and append to the final StringBuilder\\n                i = j; // Update the index to continue from the next word\\n            }\\n        }\\n\\n        ans.deleteCharAt(ans.length() - 1); // Remove the extra space character appended at the end\\n\\n        return ans.toString(); // Return the reversed words as a string\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        n = len(s)  # Get the length of the input string\\n        ans = []  # Initialize a list to store the reversed words\\n        i = n - 1  # Start from the last character of the input string\\n\\n        while i >= 0:\\n            if s[i] == \\' \\':\\n                i -= 1  # If the current character is a space, move to the next character\\n            else:\\n                temp = [\\' \\']  # Initialize a temporary list with a space character\\n                j = i\\n                while j >= 0 and s[j] != \\' \\':\\n                    temp.append(s[j])  # Append each character to the temporary list in reverse order\\n                    j -= 1\\n                ans.extend(reversed(temp))  # Reverse the characters in the temporary list and append to the final list\\n                i = j  # Update the index to continue from the next word\\n\\n        ans.pop()  # Remove the extra space character appended at the end\\n\\n        return \\'\\'.join(ans)  # Return the reversed words as a string\\n```\\n\\n#Please upvode if you like.\\u2764 it motivate us how we can modify my Approch  for easy understandable.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        ios_base::sync_with_stdio(false);   // Disable synchronization between C++ input/output streams and C standard streams for improved execution speed\\n        cout.tie(nullptr);   // Untie the cout stream from other streams for improved execution speed\\n        cin.tie(nullptr);    // Untie the cin stream from other streams for improved execution speed\\n\\n        int n = s.size();   // Get the size of the input string\\n        string ans = \"\";   // Initialize an empty string to store the reversed words\\n        int i = n - 1;   // Start from the last character of the input string\\n\\n        while (i >= 0) {\\n            if (s[i] == \\' \\') {\\n                i--;   // If the current character is a space, move to the next character\\n            }\\n            else {\\n                string temp = \" \";   // Initialize a temporary string with a space character\\n                int j = i;\\n                while (j >= 0 && s[j] != \\' \\') {\\n                    temp += s[j];   // Append each character to the temporary string in reverse order\\n                    j--;\\n                }\\n                reverse(temp.begin(), temp.end());   // Reverse the characters in the temporary string\\n                ans += temp;   // Append the reversed word to the final string\\n                i = j;   // Update the index to continue from the next word\\n            }\\n        }\\n\\n        ans.pop_back();   // Remove the extra space character appended at the end\\n\\n        return ans;   // Return the reversed words as the output\\n    }\\n};\\n\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        int n = s.length(); // Get the length of the input string\\n        StringBuilder ans = new StringBuilder(); // Initialize a StringBuilder to store the reversed words\\n        int i = n - 1; // Start from the last character of the input string\\n\\n        while (i >= 0) {\\n            if (s.charAt(i) == \\' \\') {\\n                i--; // If the current character is a space, move to the next character\\n            } else {\\n                StringBuilder temp = new StringBuilder(\" \"); // Initialize a temporary StringBuilder with a space character\\n                int j = i;\\n                while (j >= 0 && s.charAt(j) != \\' \\') {\\n                    temp.append(s.charAt(j)); // Append each character to the temporary StringBuilder in reverse order\\n                    j--;\\n                }\\n                ans.append(temp.reverse()); // Reverse the characters in the temporary StringBuilder and append to the final StringBuilder\\n                i = j; // Update the index to continue from the next word\\n            }\\n        }\\n\\n        ans.deleteCharAt(ans.length() - 1); // Remove the extra space character appended at the end\\n\\n        return ans.toString(); // Return the reversed words as a string\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        n = len(s)  # Get the length of the input string\\n        ans = []  # Initialize a list to store the reversed words\\n        i = n - 1  # Start from the last character of the input string\\n\\n        while i >= 0:\\n            if s[i] == \\' \\':\\n                i -= 1  # If the current character is a space, move to the next character\\n            else:\\n                temp = [\\' \\']  # Initialize a temporary list with a space character\\n                j = i\\n                while j >= 0 and s[j] != \\' \\':\\n                    temp.append(s[j])  # Append each character to the temporary list in reverse order\\n                    j -= 1\\n                ans.extend(reversed(temp))  # Reverse the characters in the temporary list and append to the final list\\n                i = j  # Update the index to continue from the next word\\n\\n        ans.pop()  # Remove the extra space character appended at the end\\n\\n        return \\'\\'.join(ans)  # Return the reversed words as a string\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3493969,
                "title": "very-easy-java-solution-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans=new StringBuilder();\\n        for(int start = s.length()-1; start >=0 ; start--) {\\n            if(s.charAt(start)==\\' \\'){\\n                continue;\\n            }\\n            int end=start;\\n            while(start>=0 && s.charAt(start)!=\\' \\'){\\n                start--;\\n            }\\n            ans.append(s.substring(start+1,end+1)).append(\" \");\\n        }\\n        return ans.toString().strip();\\n    }\\n}\\n```\\nUP   VOTE if       you Like it \\u2B06\\uFE0F\\uD83D\\uDE0A",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans=new StringBuilder();\\n        for(int start = s.length()-1; start >=0 ; start--) {\\n            if(s.charAt(start)==\\' \\'){\\n                continue;\\n            }\\n            int end=start;\\n            while(start>=0 && s.charAt(start)!=\\' \\'){\\n                start--;\\n            }\\n            ans.append(s.substring(start+1,end+1)).append(\" \");\\n        }\\n        return ans.toString().strip();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811307,
                "title": "combining-the-power-of-stringstream-stack",
                "content": "Think Easy!.\\nWhile its good to think of approaches using indices to find a blank space, I\\'ll present an alternative solution using stringstream.\\n\\nSo, `stringstream` considers a string as a stream of characters with a **blank space as a delimiter by default**, when a string is passed into it. Stringstream will break parts of the string and treat it as seperate strings wherever it encounters a blank space.\\n\\n**You can pass these seperated strings into a string using the `>>` operator.**\\n\\nNow, since the words passed would **not change the order** and we want to **reverse** it, we use a stack to store the most frequent word at the top and go backwards, appending the words to the final answer\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string word;\\n        \\n        stack<string> st;\\n        while(ss >> word) {\\n            st.push(word);\\n        }\\n        \\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans += st.top() + \" \";\\n            st.pop();\\n        }\\n        ans.pop_back(); // removes the trailing whitespace (1 character)\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity - `O(n)`\\nSpace Complexity - `O(n)`\\n\\nIf alternatives to `stringstream` used in other languages (java, python, etc..) exists, then someone can post the solution below.",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stringstream ss(s);\\n        string word;\\n        \\n        stack<string> st;\\n        while(ss >> word) {\\n            st.push(word);\\n        }\\n        \\n        string ans = \"\";\\n        while(!st.empty()) {\\n            ans += st.top() + \" \";\\n            st.pop();\\n        }\\n        ans.pop_back(); // removes the trailing whitespace (1 character)\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809990,
                "title": "c-medium-nah-easy-yeah",
                "content": "# Thought Process:\\nFind all the words while traversing the string and store it in a vector. For next step, there are 3 ways to do this: -\\n1. Reverse the vector and traverse it from ```i = 0``` and consecutively add spaces.\\n2. Traverse the vector from ```i = v.size()-1``` and consecutively add spaces.\\n3. Traverse from start i.e. ```i = 0``` but add each word in front of the previous result.\\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        int n = s.size();\\n        vector<string> v;        \\n        \\n        while (i < n){            \\n            string res = \"\";\\n            \\n            while (i < n && s[i] == \\' \\') i++; // to avoid white space\\n            while (i < n && s[i] != \\' \\') res+=s[i++];\\n            \\n            if (res == \"\" || res == \" \") continue; // for safety if the condition result in true value.\\n            v.push_back (res);\\n        }\\n        \\n        string ans = v[0];\\n        \\n        for (int i = 1; i < v.size(); i++){\\n            ans = v[i] + \" \" + ans; // used 3rd method frm above\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexities:\\n**TC:** O(N^2) // correction suggested by @heder.\\n**SC:** O(number of words in the string) = O(N).\\n\\n\\n***UPDATED***\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        int n = s.size();\\n        vector<string> v;\\n        \\n        \\n        while (i < n){            \\n            string res = \"\";\\n            \\n            while (i < n && s[i] == \\' \\') i++;\\n            while (i < n && s[i] != \\' \\') res+=s[i++];\\n            \\n            if (res == \"\" || res == \" \") continue;\\n            v.push_back (res);\\n        }\\n        \\n        reverse (v.begin (), v.end ()); // change 1\\n        string ans = v[0];\\n        \\n        for (int i = 1; i < v.size(); i++){\\n            \\n            ans += (\" \" + v[i]); // change 2\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexities:\\n**TC:** O(N)\\n**SC:** O(number of words in the string) = O(N).\\n\\nIf confused about the *difference between time complexities of concatenation using shorthand and operator\\'+\\'*\\nCheckout https://stackoverflow.com/questions/61890892/is-there-difference-in-string-concatenation-using-shortand-operator\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```i = 0```\n```i = v.size()-1```\n```i = 0```\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        int n = s.size();\\n        vector<string> v;        \\n        \\n        while (i < n){            \\n            string res = \"\";\\n            \\n            while (i < n && s[i] == \\' \\') i++; // to avoid white space\\n            while (i < n && s[i] != \\' \\') res+=s[i++];\\n            \\n            if (res == \"\" || res == \" \") continue; // for safety if the condition result in true value.\\n            v.push_back (res);\\n        }\\n        \\n        string ans = v[0];\\n        \\n        for (int i = 1; i < v.size(); i++){\\n            ans = v[i] + \" \" + ans; // used 3rd method frm above\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int i = 0;\\n        int n = s.size();\\n        vector<string> v;\\n        \\n        \\n        while (i < n){            \\n            string res = \"\";\\n            \\n            while (i < n && s[i] == \\' \\') i++;\\n            while (i < n && s[i] != \\' \\') res+=s[i++];\\n            \\n            if (res == \"\" || res == \" \") continue;\\n            v.push_back (res);\\n        }\\n        \\n        reverse (v.begin (), v.end ()); // change 1\\n        string ans = v[0];\\n        \\n        for (int i = 1; i < v.size(); i++){\\n            \\n            ans += (\" \" + v[i]); // change 2\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808720,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n      s = s.trim() + \" \";\\n       String ans = \"\", word = \"\";\\n    int fg = 0;\\n    for(int i = 0; i < s.length(); i ++)\\n    {\\n        if(s.charAt(i) != \\' \\')\\n        {\\n            fg = 0;\\n            word += s.charAt(i);\\n        }\\n        else if(fg == 0)\\n        {\\n            fg = 1;\\n            ans = word + \" \" + ans;\\n            word = \"\";\\n        }\\n    }\\n    return ans.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n      s = s.trim() + \" \";\\n       String ans = \"\", word = \"\";\\n    int fg = 0;\\n    for(int i = 0; i < s.length(); i ++)\\n    {\\n        if(s.charAt(i) != \\' \\')\\n        {\\n            fg = 0;\\n            word += s.charAt(i);\\n        }\\n        else if(fg == 0)\\n        {\\n            fg = 1;\\n            ans = word + \" \" + ans;\\n            word = \"\";\\n        }\\n    }\\n    return ans.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592992,
                "title": "reverse-words-in-a-string",
                "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n          string ans;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\' \\')\\n                i++;\\n            else\\n            {\\n                string curr;\\n                while(i<s.length() && s[i]!=\\' \\')\\n                {\\n                    curr+=s[i];\\n                    \\n                    i++;\\n                }\\n                if(ans.length()==0) \\n                    ans=curr;\\n                else\\n                    ans=curr+\\' \\'+ans; \\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n**please upvote if u found this helpful**",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n          string ans;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\' \\')\\n                i++;\\n            else\\n            {\\n                string curr;\\n                while(i<s.length() && s[i]!=\\' \\')\\n                {\\n                    curr+=s[i];\\n                    \\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2414919,
                "title": "python-easy-solution",
                "content": "```\\ndef reverseWords(self, s: str) -> str:\\n        array = s.split()\\n        return \" \".join(reversed(array))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef reverseWords(self, s: str) -> str:\\n        array = s.split()\\n        return \" \".join(reversed(array))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1948896,
                "title": "simple-c-solution",
                "content": "```\\n \\nchar * reverseWords(char * s){\\n    int i = 0;\\n    int j = 0;\\n    int a = strlen(s);\\n    char *res = malloc(a + 1);\\n    a--;\\n    int len = a;\\n    while (len >= 0)\\n    {\\n        while (len >= 0 && s[len] == \\' \\')\\n            len--;\\n        while (len >= 0 && s[len] != \\' \\' && ++i)\\n            len--;\\n        a = len + 1;\\n        while(--i >= 0)\\n            res[j++] = s[a++];\\n        res[j++] = \\' \\';\\n        i = 0;\\n    }\\n    if(res[j-2] == \\' \\')\\n        res[j-2] = \\'\\\\0\\';\\n\\tres[j-1] = \\'\\\\0\\';\\n    return (res);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n \\nchar * reverseWords(char * s){\\n    int i = 0;\\n    int j = 0;\\n    int a = strlen(s);\\n    char *res = malloc(a + 1);\\n    a--;\\n    int len = a;\\n    while (len >= 0)\\n    {\\n        while (len >= 0 && s[len] == \\' \\')\\n            len--;\\n        while (len >= 0 && s[len] != \\' \\' && ++i)\\n            len--;\\n        a = len + 1;\\n        while(--i >= 0)\\n            res[j++] = s[a++];\\n        res[j++] = \\' \\';\\n        i = 0;\\n    }\\n    if(res[j-2] == \\' \\')\\n        res[j-2] = \\'\\\\0\\';\\n\\tres[j-1] = \\'\\\\0\\';\\n    return (res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530606,
                "title": "easy-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder result = new StringBuilder();\\n        StringBuilder current = new StringBuilder();\\n        int N = s.length();\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            current.setLength(0);\\n            while(i >= 0 && s.charAt(i) != \\' \\') {\\n                current.append(s.charAt(i));\\n                i--;\\n            }\\n            if(current.length() > 0) {\\n                result.append(result.length() == 0 ? \"\": \" \");\\n                result.append(current.reverse().toString());\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\\n\\n**Another Approach without StringBuilder**\\n\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result = \"\";\\n        String current = \"\";\\n        int N = s.length();\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            current = \"\";\\n            while(i >= 0 && s.charAt(i) != \\' \\') {\\n                current = s.charAt(i) + current;\\n                i--;\\n            }\\n            if(current.length() > 0) {\\n                result += (result.length() == 0 ? \"\": \" \") + current;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder result = new StringBuilder();\\n        StringBuilder current = new StringBuilder();\\n        int N = s.length();\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            current.setLength(0);\\n            while(i >= 0 && s.charAt(i) != \\' \\') {\\n                current.append(s.charAt(i));\\n                i--;\\n            }\\n            if(current.length() > 0) {\\n                result.append(result.length() == 0 ? \"\": \" \");\\n                result.append(current.reverse().toString());\\n            }\\n        }\\n        \\n        return result.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result = \"\";\\n        String current = \"\";\\n        int N = s.length();\\n        \\n        for(int i = N - 1; i >= 0; i--) {\\n            current = \"\";\\n            while(i >= 0 && s.charAt(i) != \\' \\') {\\n                current = s.charAt(i) + current;\\n                i--;\\n            }\\n            if(current.length() > 0) {\\n                result += (result.length() == 0 ? \"\": \" \") + current;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089444,
                "title": "o-1-space-complexity-o-n-time-complexity-explained-with-comments",
                "content": "```\\n string reverseWords(string s) {\\n        //Removing all extra spaces\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==s[i-1]&&s[i]==\\' \\'){\\n                s.erase(s.begin()+i-1);\\n                i--;\\n            }\\n        }\\n        //removing the space in first pos\\n        if(s[0]==\\' \\')\\n            s.erase(s.begin());\\n        \\n        int n=s.length();\\n        //removing the space of last pos\\n        if(s[n-1]==\\' \\'){\\n             s.erase(s.begin()+n-1);\\n            n--;\\n        }\\n        \\n        //Reverseing the whole string\\n        for(int i=0;i<n/2;i++){\\n           swap(s[i],s[n-i-1]);\\n        }\\n        \\n        //finding words and reversing them\\n        //if if it not last word than word will end in \\' \\'(space)\\n        //st-> starting position of the word\\n        int st=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                //we have found a word starting from st and ending in i-1\\n                //reveresing each word\\n                for(int j=i-1;j>st;j--){\\n                    swap(s[j],s[st]);\\n                    st++;\\n                }\\n                //updating st to the start pos of next word \\n                st=i+1;\\n            }\\n        }\\n        //reversing the last word as it will not have space in the end\\n        //we need to reverse it separately\\n        for(int j=n-1;j>st;j--){\\n            swap(s[j],s[st]);\\n            st++;\\n        }\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string reverseWords(string s) {\\n        //Removing all extra spaces\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==s[i-1]&&s[i]==\\' \\'){\\n                s.erase(s.begin()+i-1);\\n                i--;\\n            }\\n        }\\n        //removing the space in first pos\\n        if(s[0]==\\' \\')\\n            s.erase(s.begin());\\n        \\n        int n=s.length();\\n        //removing the space of last pos\\n        if(s[n-1]==\\' \\'){\\n             s.erase(s.begin()+n-1);\\n            n--;\\n        }\\n        \\n        //Reverseing the whole string\\n        for(int i=0;i<n/2;i++){\\n           swap(s[i],s[n-i-1]);\\n        }\\n        \\n        //finding words and reversing them\\n        //if if it not last word than word will end in \\' \\'(space)\\n        //st-> starting position of the word\\n        int st=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\' \\'){\\n                //we have found a word starting from st and ending in i-1\\n                //reveresing each word\\n                for(int j=i-1;j>st;j--){\\n                    swap(s[j],s[st]);\\n                    st++;\\n                }\\n                //updating st to the start pos of next word \\n                st=i+1;\\n            }\\n        }\\n        //reversing the last word as it will not have space in the end\\n        //we need to reverse it separately\\n        for(int j=n-1;j>st;j--){\\n            swap(s[j],s[st]);\\n            st++;\\n        }\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850327,
                "title": "one-liner-and-manual-approaches-comparison",
                "content": "For all those of you still wondering if they should use build-in functions of not... Make your own tests in other languages / frameworks if necessarry\\n\\n1. One-liner using build-in framework functions\\n    Runtime: **84 ms**, faster than 94.18% of C# online submissions for Reverse Words in a String.\\n    Memory Usage: **24.5 MB**, less than 81.66% of C# online submissions for Reverse Words in a String.\\n\\n\\t```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s) => \\n\\t\\t\\tstring.Join(\\' \\', s.Split(\\' \\').Reverse().Where(e => e.Length > 0));\\n    }\\n\\t```\\n\\n2. Semi-manual approach but still using some framework datastructures (e.g. StringBuilder and string.Split)\\n    Runtime: **88 ms**, faster than 84.66% of C# online submissions for Reverse Words in a String.\\n    Memory Usage: **24.5 MB**, less than 79.19% of C# online submissions for Reverse Words in a String.\\n\\n\\t```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            var arr = s.Split(\\' \\');\\n            for (int i = arr.Length - 1; i >= 0; i--)\\n                if (arr[i].Length > 0)\\n                {\\n                    sb.Append(arr[i]);\\n                    sb.Append(\\' \\');\\n                }\\n\\n            if(sb.Length > 0)\\n                sb.Remove(sb.Length-1, 1);\\n\\n            return sb.ToString();\\n        }\\n    }\\n\\t```\\n\\n3. Full manuall approach, no Split, no Trim, etc.\\nRuntime: **172 ms**, faster than 12.52% of C# online submissions for Reverse Words in a String.\\nMemory Usage: **43.8 MB**, less than 6.34% of C# online submissions for Reverse Words in a String.\\n\\t```\\n\\tpublic class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            Stack<string> stack = new Stack<string>();\\n            string temp = \"\";\\n            for(int i=0; i<s.Length; i++)\\n            {\\n                char c = s[i];\\n                if(c == \\' \\')\\n                {\\n                    if(temp.Length > 0)\\n                    {\\n                        stack.Push(temp);\\n                        temp = \"\";\\n                    }\\n                }\\n                else\\n                    temp += c;\\n            }\\n            if(temp.Length > 0)\\n                stack.Push(temp);\\n\\n            string res = \"\";\\n            while(stack.Count > 0)\\n                res += stack.Pop() + \" \";\\n\\n            //TrimEnd\\n            if(res.Length > 0)\\n                res = res.Remove(res.Length - 1, 1);\\n\\n            return res;\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s) => \\n\\t\\t\\tstring.Join(\\' \\', s.Split(\\' \\').Reverse().Where(e => e.Length > 0));\\n    }\\n\\t```\n```\\n    public class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            var arr = s.Split(\\' \\');\\n            for (int i = arr.Length - 1; i >= 0; i--)\\n                if (arr[i].Length > 0)\\n                {\\n                    sb.Append(arr[i]);\\n                    sb.Append(\\' \\');\\n                }\\n\\n            if(sb.Length > 0)\\n                sb.Remove(sb.Length-1, 1);\\n\\n            return sb.ToString();\\n        }\\n    }\\n\\t```\n```\\n\\tpublic class Solution\\n    {\\n        public string ReverseWords(string s)\\n        {\\n            Stack<string> stack = new Stack<string>();\\n            string temp = \"\";\\n            for(int i=0; i<s.Length; i++)\\n            {\\n                char c = s[i];\\n                if(c == \\' \\')\\n                {\\n                    if(temp.Length > 0)\\n                    {\\n                        stack.Push(temp);\\n                        temp = \"\";\\n                    }\\n                }\\n                else\\n                    temp += c;\\n            }\\n            if(temp.Length > 0)\\n                stack.Push(temp);\\n\\n            string res = \"\";\\n            while(stack.Count > 0)\\n                res += stack.Pop() + \" \";\\n\\n            //TrimEnd\\n            if(res.Length > 0)\\n                res = res.Remove(res.Length - 1, 1);\\n\\n            return res;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 738652,
                "title": "go-golang-clean-solutions",
                "content": "```go\\nfunc reverseWords(s string) string {\\n    words := strings.Fields(s)\\n    reverse(words)\\n    return strings.Join(words, \" \")\\n}\\n\\nfunc reverse(arr []string) {\\n    if len(arr) == 0 { return }\\n    l, r := 0, len(arr) - 1\\n    for l < r {\\n        arr[l], arr[r] = arr[r], arr[l]\\n        l++\\n        r--\\n    }\\n}\\n```\\n\\n```go\\nfunc reverseWords(s string) string {\\n    i, n, res := 0, len(s), \"\"\\n    for i < n {\\n        for i < n && s[i] == \\' \\' { i++ }\\n        if i == n { break }\\n        j := i\\n        for j < n && s[j] != \\' \\' { j++ }\\n        if len(res) == 0 {\\n            res = s[i : j]\\n        } else {\\n            res = s[i : j] + \" \" + res\\n        }\\n        i = j + 1\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc reverseWords(s string) string {\\n    words := strings.Fields(s)\\n    reverse(words)\\n    return strings.Join(words, \" \")\\n}\\n\\nfunc reverse(arr []string) {\\n    if len(arr) == 0 { return }\\n    l, r := 0, len(arr) - 1\\n    for l < r {\\n        arr[l], arr[r] = arr[r], arr[l]\\n        l++\\n        r--\\n    }\\n}\\n```\n```go\\nfunc reverseWords(s string) string {\\n    i, n, res := 0, len(s), \"\"\\n    for i < n {\\n        for i < n && s[i] == \\' \\' { i++ }\\n        if i == n { break }\\n        j := i\\n        for j < n && s[j] != \\' \\' { j++ }\\n        if len(res) == 0 {\\n            res = s[i : j]\\n        } else {\\n            res = s[i : j] + \" \" + res\\n        }\\n        i = j + 1\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 47951,
                "title": "in-place-o-1-c-solution-clear-3-step-algorithm",
                "content": "    void swapC(char *a, char *b)\\n    {\\n      char tmp = *a; *a = *b; *b=tmp;\\n    }\\n    \\n    void rev(char* start, char* end)\\n    {\\n      while(end>start)  swapC(end--, start++);\\n    }\\n    \\n    void reverseWords(char *s)\\n    {\\n      /* For C programmers: Try to solve it in-place in O(1) space. */\\n      /* 3-step algorthm\\n         1. use runner/chaser to eliminate all unnecessary spaces\\n         2. rev the entire string\\n         3. rev word by word*/\\n      int len = strlen(s);\\n      if(len < 2 && !isspace(*s)) return;\\n      \\n      /* 1. trim off all unnecessary spaces */\\n      char* runner, *chaser;\\n      for(runner = s, chaser=s; *runner!='\\\\0'; runner++)\\n      {\\n        if(isspace(*runner))\\n        {\\n          while(isspace(*(runner+1)) && *(runner+1)!=0) runner++;\\n          if(*(runner+1) == 0) break;\\n          if(chaser == s) continue;\\n        }\\n        if(runner!=chaser)    swapC(runner, chaser);\\n        chaser++;\\n      }\\n      *chaser = 0;\\n      len = strlen(s);\\n    \\n      /* 2. rev the entire string */\\n      rev(s, s+len-1);\\n      \\n      /* 3. rev word by word */\\n      for(char *wHead =s, *wTail=s; wHead < s+len; wHead = wTail+2)\\n      {\\n        for(wTail=wHead; !isspace(*(wTail+1)) && *(wTail+1) != 0; wTail++);\\n        rev(wHead, wTail);\\n      }\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "    void swapC(char *a, char *b)\\n    {\\n      char tmp = *a; *a = *b; *b=tmp;\\n    }\\n    \\n    void rev(char* start, char* end)\\n    {\\n      while(end>start)  swapC(end--, start++);\\n    }\\n    \\n    void reverseWords(char *s)\\n    {\\n      /* For C programmers: Try to solve it in-place in O(1) space. */\\n      /* 3-step algorthm\\n         1. use runner/chaser to eliminate all unnecessary spaces\\n         2. rev the entire string\\n         3. rev word by word*/\\n      int len = strlen(s);\\n      if(len < 2 && !isspace(*s)) return;\\n      \\n      /* 1. trim off all unnecessary spaces */\\n      char* runner, *chaser;\\n      for(runner = s, chaser=s; *runner!='\\\\0'; runner++)\\n      {\\n        if(isspace(*runner))\\n        {\\n          while(isspace(*(runner+1)) && *(runner+1)!=0) runner++;\\n          if(*(runner+1) == 0) break;\\n          if(chaser == s) continue;\\n        }\\n        if(runner!=chaser)    swapC(runner, chaser);\\n        chaser++;\\n      }\\n      *chaser = 0;\\n      len = strlen(s);\\n    \\n      /* 2. rev the entire string */\\n      rev(s, s+len-1);\\n      \\n      /* 3. rev word by word */\\n      for(char *wHead =s, *wTail=s; wHead < s+len; wHead = wTail+2)\\n      {\\n        for(wTail=wHead; !isspace(*(wTail+1)) && *(wTail+1) != 0; wTail++);\\n        rev(wHead, wTail);\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3810724,
                "title": "easiest-solution-exist-on-leetcode",
                "content": "class Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int n=s.length(),last=n;\\n        for(int i=n-1;i>=0;i--){\\n           if(s.charAt(i)==\\' \\'){\\n               sb.append(s.substring(i,last));\\n               last=i;\\n           } \\n        }\\n        sb.append(\\' \\'+s.substring(0,last));\\n        return sb.toString().replaceAll(\"\\\\\\\\s+\",\" \").trim();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "class Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder sb=new StringBuilder();\\n        int n=s.length(),last=n;\\n        for(int i=n-1;i>=0;i--){\\n           if(s.charAt(i)==\\' \\'){\\n               sb.append(s.substring(i,last));\\n               last=i;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3525898,
                "title": "easy-clean-solution-c-java-o-n",
                "content": "**Code of Optimal solution which is using two pointer\\'s is in the end.**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can traverse through the given string and keep adding the word we find at the beginning of a result string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep two string: result and temp.\\n\\nTraverse through the string using a loop, inside the loop, use another loop to find word and store in temp string, then add that word at beginning of result string. And reset the temporary string to *null*.\\nSince we cannot have any leading or trailing space, while adding space we need to take care of two conditions.\\n1. The result string is empty. `result = temporary_string`\\n2. Result string is non-empty. `result = temporary_stirng + \" \" + result`\\n\\nCondition to avoid leading and trailing white space while finding words:\\n`while (i < s.size() && s[i] != \\' \\')`\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res = \"\";\\n        string temp = \"\";\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            while (i < s.size() && s[i] != \\' \\') {\\n                temp += s[i];\\n                ++i;\\n            }\\n\\n            if (temp != \"\") {\\n                // If we find a word, will add it at beginning of result.\\n                if (res != \"\") {\\n                    res = temp + \" \" + res;\\n                } else {\\n                    res = temp;\\n                }\\n                temp = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            while (i < s.length() && s.charAt(i) != \\' \\') {\\n                temp.append(s.charAt(i));\\n                ++i;\\n            }\\n\\n            if (temp.length() != 0) {\\n                // If we find a word we will add it at beginning of result.\\n                if (res.length() != 0) {\\n                    res.insert(0, \" \");\\n                    res.insert(0, temp);\\n                } else {\\n                    res.append(temp);\\n                }\\n                temp.setLength(0);\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n# Using array\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string temp = \"\";\\n        vector<string> arr;\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            while (i < s.size() && s[i] != \\' \\') {\\n                temp += s[i];\\n                ++i;\\n            }\\n\\n            if (temp != \"\") {\\n                // If we find a word we will add it to the vector.\\n                arr.push_back(temp);\\n                temp = \"\";\\n            }\\n        }\\n        string res = \"\";\\n        for (int i = arr.size() - 1; i >= 0; --i) {\\n            if (i == arr.size() - 1) {\\n                res = arr[i];\\n            } else {\\n                res += \" \" + arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder temp = new StringBuilder();\\n        List<String> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            while (i < s.length() && s.charAt(i) != \\' \\') {\\n                temp.append(s.charAt(i));\\n                ++i;\\n            }\\n\\n            if (temp.length() != 0) {\\n                // If we find a word we will add to arrayList.\\n                arr.add(temp.toString());\\n                temp.setLength(0);\\n            }\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for (int i = arr.size() - 1; i >= 0; --i) {\\n            if (i == arr.size() - 1) {\\n                res.append(arr.get(i));\\n            } else {\\n                res.append(\" \").append(arr.get(i));\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\\n\\n# Two Pointers\\nWe traverse throught the string once bringing the time complexity to $$O(n)$$, which is a significant update over other methods.\\n\\nWe start our traversal from the end of the string and skip through empty spaces till we find any word, let\\'s say with variable named `i`.\\nWhen we find any word we will initialize another variable let\\'s assume `j` and traverse throught that word in reverse order till the condintion `j >= 0 && s[j] != \\' \\'` is satisfied, which means we will find the start index of the word which will be `j + 1`.\\nThen, we can add the substring j + 1 to i, including index i, into the resultant string, and reassign i = j;\\n\\n# Complexity\\n- Time complexity: O(n)\\n$$ We \\\\hspace{0.2cm} are \\\\hspace{0.2cm} traversing \\\\hspace{0.2cm} the \\\\hspace{0.2cm} string \\\\hspace{0.2cm} once. $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n$$ We \\\\hspace{0.2cm} are \\\\hspace{0.2cm} not \\\\hspace{0.2cm} using \\\\hspace{0.2cm} any \\\\hspace{0.2cm} extra \\\\hspace{0.2cm} space \\\\hspace{0.2cm} other \\\\hspace{0.2cm} than \\\\hspace{0.2cm} resultant \\\\hspace{0.2cm} string. $$\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\";\\n        if (s.size() == 1 && s[0] == \\' \\') {\\n            return ans;\\n        }\\n        int i = s.size() - 1;\\n        while (i >= 0) {\\n            if (s[i] == \\' \\') {\\n                --i;\\n            } else {\\n                int j = i;\\n                if (ans.size() > 0) {\\n                    ans += \" \";\\n                }\\n                while (j >= 0 && s[j] != \\' \\') {\\n                    --j;\\n                }\\n                int length = i - j;\\n                ans += s.substr(j + 1, length);\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        if (s.length() == 1 && s.charAt(0) == \\' \\') {\\n            return ans.toString();\\n        }\\n        int i = s.length() - 1;\\n        while (i >= 0) {\\n            if (s.charAt(i) == \\' \\') {\\n                --i;\\n            } else {\\n                int j = i;\\n                if (ans.length() > 0) {\\n                    ans.append(\" \");\\n                }\\n                while (j >= 0 && s.charAt(j) != \\' \\') {\\n                    --j;\\n                }\\n                ans.append(s.substring(j + 1, i + 1));\\n                i = j;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n**Will you upvote if the solution was helpful?**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res = \"\";\\n        string temp = \"\";\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            while (i < s.size() && s[i] != \\' \\') {\\n                temp += s[i];\\n                ++i;\\n            }\\n\\n            if (temp != \"\") {\\n                // If we find a word, will add it at beginning of result.\\n                if (res != \"\") {\\n                    res = temp + \" \" + res;\\n                } else {\\n                    res = temp;\\n                }\\n                temp = \"\";\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder res = new StringBuilder();\\n        StringBuilder temp = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            while (i < s.length() && s.charAt(i) != \\' \\') {\\n                temp.append(s.charAt(i));\\n                ++i;\\n            }\\n\\n            if (temp.length() != 0) {\\n                // If we find a word we will add it at beginning of result.\\n                if (res.length() != 0) {\\n                    res.insert(0, \" \");\\n                    res.insert(0, temp);\\n                } else {\\n                    res.append(temp);\\n                }\\n                temp.setLength(0);\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string temp = \"\";\\n        vector<string> arr;\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            while (i < s.size() && s[i] != \\' \\') {\\n                temp += s[i];\\n                ++i;\\n            }\\n\\n            if (temp != \"\") {\\n                // If we find a word we will add it to the vector.\\n                arr.push_back(temp);\\n                temp = \"\";\\n            }\\n        }\\n        string res = \"\";\\n        for (int i = arr.size() - 1; i >= 0; --i) {\\n            if (i == arr.size() - 1) {\\n                res = arr[i];\\n            } else {\\n                res += \" \" + arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder temp = new StringBuilder();\\n        List<String> arr = new ArrayList<>();\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            while (i < s.length() && s.charAt(i) != \\' \\') {\\n                temp.append(s.charAt(i));\\n                ++i;\\n            }\\n\\n            if (temp.length() != 0) {\\n                // If we find a word we will add to arrayList.\\n                arr.add(temp.toString());\\n                temp.setLength(0);\\n            }\\n        }\\n        StringBuilder res = new StringBuilder();\\n        for (int i = arr.size() - 1; i >= 0; --i) {\\n            if (i == arr.size() - 1) {\\n                res.append(arr.get(i));\\n            } else {\\n                res.append(\" \").append(arr.get(i));\\n            }\\n        }\\n        return res.toString();\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\";\\n        if (s.size() == 1 && s[0] == \\' \\') {\\n            return ans;\\n        }\\n        int i = s.size() - 1;\\n        while (i >= 0) {\\n            if (s[i] == \\' \\') {\\n                --i;\\n            } else {\\n                int j = i;\\n                if (ans.size() > 0) {\\n                    ans += \" \";\\n                }\\n                while (j >= 0 && s[j] != \\' \\') {\\n                    --j;\\n                }\\n                int length = i - j;\\n                ans += s.substr(j + 1, length);\\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        if (s.length() == 1 && s.charAt(0) == \\' \\') {\\n            return ans.toString();\\n        }\\n        int i = s.length() - 1;\\n        while (i >= 0) {\\n            if (s.charAt(i) == \\' \\') {\\n                --i;\\n            } else {\\n                int j = i;\\n                if (ans.length() > 0) {\\n                    ans.append(\" \");\\n                }\\n                while (j >= 0 && s.charAt(j) != \\' \\') {\\n                    --j;\\n                }\\n                ans.append(s.substring(j + 1, i + 1));\\n                i = j;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438608,
                "title": "o-1-space-and-o-n-solution-without-converting-string-into-array",
                "content": "\\n# Approach\\n**step-1**: take a variable i and j and initialized to 0.\\n\\n**step-2**: run a loop till length of string s.\\n\\n**step-3**:keep on incrementing i if there is a white space here 32(askii value of space) means a white space.\\n\\n**step-4**: once white space is over means string is starting so store the starting index of string in variable j.\\n\\n**step-5**: keep on incrementing j once we do not get the next white space once we get the white space means part of string is ending here. so take a substring from index i to j and store **prepend to result**.\\n\\n**step-6**: now initialize i again to the end place of string that we had read.\\n\\n**please upvote if you like the solution hApPY CoDiNG**\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result=\"\";\\n        int i=0,j=0,len = s.length();\\n        \\n        while(i<len){\\n            while(i<len&&s.charAt(i)==32){\\n                i++;\\n            }\\n            j=i;\\n\\n            while(j<len&&s.charAt(j)!=32){\\n                j++;\\n            }\\n            result=s.substring(i,j)+\" \"+result;\\n            \\n            i=j;\\n        }\\n    return result.trim();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String result=\"\";\\n        int i=0,j=0,len = s.length();\\n        \\n        while(i<len){\\n            while(i<len&&s.charAt(i)==32){\\n                i++;\\n            }\\n            j=i;\\n\\n            while(j<len&&s.charAt(j)!=32){\\n                j++;\\n            }\\n            result=s.substring(i,j)+\" \"+result;\\n            \\n            i=j;\\n        }\\n    return result.trim();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208130,
                "title": "151-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can start by removing any leading or trailing spaces from the input string, as well as reducing multiple spaces between words to a single space. Then, we can split the string into individual words using the space as a delimiter and store them in a list. Finally, we can reverse the order of the words in the list and concatenate them back into a string separated by a single space.\\n\\nThis solution has a time complexity of O(n), where n is the length of the input string, because it involves only a single pass through the string to split it into words and a single pass through the list to reverse the order of the words. The space complexity is O(n) as well, because we store the words in a list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        # Remove leading and trailing spaces, and reduce multiple spaces to a single space\\n        s = \\' \\'.join(s.split())\\n\\n        # Split the string into individual words and store them in a list\\n        words = s.split()\\n\\n        # Reverse the order of the words in the list\\n        words.reverse()\\n\\n        # Concatenate the words into a string separated by a single space\\n        return \\' \\'.join(words)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        # Remove leading and trailing spaces, and reduce multiple spaces to a single space\\n        s = \\' \\'.join(s.split())\\n\\n        # Split the string into individual words and store them in a list\\n        words = s.split()\\n\\n        # Reverse the order of the words in the list\\n        words.reverse()\\n\\n        # Concatenate the words into a string separated by a single space\\n        return \\' \\'.join(words)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181528,
                "title": "c-code-for-lc-151-100-faster-tc-beats-80-in-sc",
                "content": "# Intuition\\nRemove extra spaces, then reverse it.\\n\\n# Approach\\nGiven code for the same is self explanatory.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        //this is the code for removing extra spaces\\n        int left = 0;\\n        int right= 0;\\n        bool space_found = false;\\n\\n        while ((s[right] == \\' \\') && (right < s.size())) right++;\\n\\n        while (right < s.size()){\\n            if (s[right] != \\' \\'){\\n                s[left++] = s[right++];\\n                space_found = false;\\n            }\\n            else{\\n                if (s[right] == \\' \\' && !(space_found)){\\n                    s[left++] = s[right++];\\n                    space_found = true;\\n                }else right++;\\n            }\\n        }\\n        if (left != s.size()){\\n            s.erase(s.begin() + left, s.end());\\n        }\\n        if(s[--left] == \\' \\') s.erase(s.begin() + left, s.end());\\n\\n        // this is part for reversing\\n\\n        reverse(s.begin(), s.end());\\n        int i = 0, j = 0;\\n        for (j = 0; j < s.length(); j++){\\n            if (s[j] == \\' \\'){\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        //this is the code for removing extra spaces\\n        int left = 0;\\n        int right= 0;\\n        bool space_found = false;\\n\\n        while ((s[right] == \\' \\') && (right < s.size())) right++;\\n\\n        while (right < s.size()){\\n            if (s[right] != \\' \\'){\\n                s[left++] = s[right++];\\n                space_found = false;\\n            }\\n            else{\\n                if (s[right] == \\' \\' && !(space_found)){\\n                    s[left++] = s[right++];\\n                    space_found = true;\\n                }else right++;\\n            }\\n        }\\n        if (left != s.size()){\\n            s.erase(s.begin() + left, s.end());\\n        }\\n        if(s[--left] == \\' \\') s.erase(s.begin() + left, s.end());\\n\\n        // this is part for reversing\\n\\n        reverse(s.begin(), s.end());\\n        int i = 0, j = 0;\\n        for (j = 0; j < s.length(); j++){\\n            if (s[j] == \\' \\'){\\n                reverse(s.begin() + i, s.begin() + j);\\n                i = j + 1;\\n            }\\n        }\\n        reverse(s.begin() + i, s.end());\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809077,
                "title": "java-two-pointer-solution-faster-80-few-lines-code",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0,j=0;i<s.length();i++){\\n            if(j<s.length() && s.charAt(j)==\\' \\'){\\n                 while(j<s.length() && s.charAt(j)==\\' \\'){\\n                     j++;\\n                     i=j-1;\\n                 }\\n            }\\n            else if(j<s.length()){\\n                while(j<s.length() && s.charAt(j)!=\\' \\'){\\n                    j++;\\n                }\\n                sb.insert(0,s.substring(i,j)+\" \");\\n            }\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(int i=0,j=0;i<s.length();i++){\\n            if(j<s.length() && s.charAt(j)==\\' \\'){\\n                 while(j<s.length() && s.charAt(j)==\\' \\'){\\n                     j++;\\n                     i=j-1;\\n                 }\\n            }\\n            else if(j<s.length()){\\n                while(j<s.length() && s.charAt(j)!=\\' \\'){\\n                    j++;\\n                }\\n                sb.insert(0,s.substring(i,j)+\" \");\\n            }\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808521,
                "title": "all-language-only-1-line-include-java-python-rust-kotlin-swift-javascript-typescript",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```\\n\\n```java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        return Arrays.stream(s.split(\" \"))\\n                    .map(String::trim)\\n                    .filter(word -> !word.isEmpty())\\n                    .reduce((word1, word2) -> word2 + \" \" + word1)\\n                    .orElse(\"\");\\n    }\\n}\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \", words);\\n    }\\n}\\n```\\n\\n\\n\\n```rust []\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        s.split(\\' \\')\\n            .rev()\\n            .filter(|x| !x.is_empty())\\n            .collect::<Vec<&str>>()\\n            .join(\" \")\\n    }\\n}\\n```\\n\\n```javascript []\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\')\\n            .map(item => item.trim())\\n            .filter(item => item !== \\'\\')\\n            .reverse()\\n            .join(\\' \\')\\n};\\n```\\n\\n\\n```typescript []\\nfunction reverseWords(s: string): string {\\n    return s.split(\\' \\')\\n            .map(item => item.trim())\\n            .filter(item => item !== \\'\\')\\n            .reverse()\\n            .join(\\' \\')\\n};\\n```\\n\\n\\n```Kotlin []\\nclass Solution {\\n    fun reverseWords(s: String): String {\\n        return Arrays.stream(s.split(\" \".toRegex()).dropLastWhile { it.isEmpty() }\\n                .toTypedArray())\\n                .map { obj: String -> obj.trim { it <= \\' \\' } }\\n                .filter { word: String -> !word.isEmpty() }\\n                .reduce { word1: String, word2: String -> \"$word2 $word1\" }\\n                .orElse(\"\")\\n    }\\n}\\n```\\n\\n```swift []\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.split(separator: \" \")\\n                .reversed()\\n                .joined(separator: \" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Swift",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```\n```java []\\nclass Solution {\\n    public String reverseWords(String s) {\\n        return Arrays.stream(s.split(\" \"))\\n                    .map(String::trim)\\n                    .filter(word -> !word.isEmpty())\\n                    .reduce((word1, word2) -> word2 + \" \" + word1)\\n                    .orElse(\"\");\\n    }\\n}\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words = s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \", words);\\n    }\\n}\\n```\n```rust []\\nimpl Solution {\\n    pub fn reverse_words(s: String) -> String {\\n        s.split(\\' \\')\\n            .rev()\\n            .filter(|x| !x.is_empty())\\n            .collect::<Vec<&str>>()\\n            .join(\" \")\\n    }\\n}\\n```\n```javascript []\\nvar reverseWords = function(s) {\\n    return s.split(\\' \\')\\n            .map(item => item.trim())\\n            .filter(item => item !== \\'\\')\\n            .reverse()\\n            .join(\\' \\')\\n};\\n```\n```typescript []\\nfunction reverseWords(s: string): string {\\n    return s.split(\\' \\')\\n            .map(item => item.trim())\\n            .filter(item => item !== \\'\\')\\n            .reverse()\\n            .join(\\' \\')\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun reverseWords(s: String): String {\\n        return Arrays.stream(s.split(\" \".toRegex()).dropLastWhile { it.isEmpty() }\\n                .toTypedArray())\\n                .map { obj: String -> obj.trim { it <= \\' \\' } }\\n                .filter { word: String -> !word.isEmpty() }\\n                .reduce { word1: String, word2: String -> \"$word2 $word1\" }\\n                .orElse(\"\")\\n    }\\n}\\n```\n```swift []\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.split(separator: \" \")\\n                .reversed()\\n                .joined(separator: \" \")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808399,
                "title": "daily-leetcoding-challenge-november-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-words-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Built-in Split + Reverse\n\n  \n**Approach 2:** Reverse the Whole String and Then Reverse Each Word\n\n  \n**Approach 3:** Deque of Words\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-words-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2476991,
                "title": "java-stringbuilder-simple-logic",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim();\\n        s=s.replaceAll(\"\\\\\\\\s+\",\" \");\\n        String str[] = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=str.length-1;i>=0;i--){\\n            sb=sb.append(str[i]);\\n            if(i>0)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim();\\n        s=s.replaceAll(\"\\\\\\\\s+\",\" \");\\n        String str[] = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=str.length-1;i>=0;i--){\\n            sb=sb.append(str[i]);\\n            if(i>0)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082399,
                "title": "100-faster-than-c-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\t//first : clear current back space.\\n    string reverseWords(string s) {\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n\\t\\t//reverse the whole string.\\n        reverse(s.begin(), s.end()); \\n\\t\\t//second :  clear current back space after reverse the string\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n\\t\\t//third : reverse the word with out space \\n        int l = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\' \\'){\\n                reverse(s.begin()+l, s.begin()+i);\\n                l = i+1;\\n            }\\n        }\\n        reverse(s.begin()+l, s.end());\\n        //third : swap the element if there are more then one space\\n        int st = 0;\\n        for(int i=0; i<s.size()-st; i++){\\n            swap(s[i], s[i+st]);\\n            if(s[i] == \\' \\'){\\n                int l = i;\\n                while(s[i] == \\' \\')i++;\\n                st = ((i-l)-1);\\n                i = l;\\n            }\\n        }\\n        // if there are space after the last word then remove the space\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//first : clear current back space.\\n    string reverseWords(string s) {\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n\\t\\t//reverse the whole string.\\n        reverse(s.begin(), s.end()); \\n\\t\\t//second :  clear current back space after reverse the string\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n\\t\\t//third : reverse the word with out space \\n        int l = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\' \\'){\\n                reverse(s.begin()+l, s.begin()+i);\\n                l = i+1;\\n            }\\n        }\\n        reverse(s.begin()+l, s.end());\\n        //third : swap the element if there are more then one space\\n        int st = 0;\\n        for(int i=0; i<s.size()-st; i++){\\n            swap(s[i], s[i+st]);\\n            if(s[i] == \\' \\'){\\n                int l = i;\\n                while(s[i] == \\' \\')i++;\\n                st = ((i-l)-1);\\n                i = l;\\n            }\\n        }\\n        // if there are space after the last word then remove the space\\n        while(true){\\n            if(s.back() == \\' \\')s.pop_back();\\n            else break;\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531118,
                "title": "python-one-liner-c-simple-and-easy-solutions-explained",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> vec;\\n        stringstream str(s);\\n        string word;\\n        \\n        while (str >> word) // store separated words in vector\\n            vec.push_back(word);\\n        \\n        reverse(vec.begin(), vec.end()); // reverse vector\\n        \\n        string res;\\n        for (const auto &it : vec) // concatenate strings\\n            res += \" \" + it;\\n        \\n        res.erase(0,1); // first place is always a space - extra\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**Python:**\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector<string> vec;\\n        stringstream str(s);\\n        string word;\\n        \\n        while (str >> word) // store separated words in vector\\n            vec.push_back(word);\\n        \\n        reverse(vec.begin(), vec.end()); // reverse vector\\n        \\n        string res;\\n        for (const auto &it : vec) // concatenate strings\\n            res += \" \" + it;\\n        \\n        res.erase(0,1); // first place is always a space - extra\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397239,
                "title": "all-approach-s-discussed-java-code",
                "content": "**Approach 1: Built-in Split + Reverse**\\n\\n```\\nclass Solution {\\n  public String reverseWords(String s) {\\n    // remove leading spaces\\n    s = s.trim();\\n    // split by multiple spaces\\n    List<String> wordList = Arrays.asList(s.split(\"\\\\\\\\s+\"));\\n    Collections.reverse(wordList);\\n    return String.join(\" \", wordList);\\n  }\\n}\\n```\\n*Complexity Analysis*\\n\\nTime complexity: O(N), where N is a number of characters in the input string.\\n\\nSpace complexity: O(N), to store the result of split by spaces.\\n   \\n    \\n**Approach 2: Reverse the Whole String and Then Reverse Each Word**\\n```\\nclass Solution {\\n  public StringBuilder trimSpaces(String s) {\\n    int left = 0, right = s.length() - 1;\\n    // remove leading spaces\\n    while (left <= right && s.charAt(left) == \\' \\') ++left;\\n\\n    // remove trailing spaces\\n    while (left <= right && s.charAt(right) == \\' \\') --right;\\n\\n    // reduce multiple spaces to single one\\n    StringBuilder sb = new StringBuilder();\\n    while (left <= right) {\\n      char c = s.charAt(left);\\n\\n      if (c != \\' \\') sb.append(c);\\n      else if (sb.charAt(sb.length() - 1) != \\' \\') sb.append(c);\\n\\n      ++left;\\n    }\\n    return sb;\\n  }\\n\\n  public void reverse(StringBuilder sb, int left, int right) {\\n    while (left < right) {\\n      char tmp = sb.charAt(left);\\n      sb.setCharAt(left++, sb.charAt(right));\\n      sb.setCharAt(right--, tmp);\\n    }\\n  }\\n\\n  public void reverseEachWord(StringBuilder sb) {\\n    int n = sb.length();\\n    int start = 0, end = 0;\\n\\n    while (start < n) {\\n      // go to the end of the word\\n      while (end < n && sb.charAt(end) != \\' \\') ++end;\\n      // reverse the word\\n      reverse(sb, start, end - 1);\\n      // move to the next word\\n      start = end + 1;\\n      ++end;\\n    }\\n  }\\n\\n  public String reverseWords(String s) {\\n    // converst string to string builder \\n    // and trim spaces at the same time\\n    StringBuilder sb = trimSpaces(s);\\n\\n    // reverse the whole string\\n    reverse(sb, 0, sb.length() - 1);\\n\\n    // reverse each word\\n    reverseEachWord(sb);\\n\\n    return sb.toString();\\n  }\\n}\\n```\\n*Complexity Analysis*\\n\\nTime complexity: O(N).\\n\\nSpace complexity: O(N).\\n    \\n    \\n    \\n**Approach 3: Deque of Words**\\n\\n```\\nclass Solution {\\n  public String reverseWords(String s) {\\n    int left = 0, right = s.length() - 1;\\n    // remove leading spaces\\n    while (left <= right && s.charAt(left) == \\' \\') ++left;\\n\\n    // remove trailing spaces\\n    while (left <= right && s.charAt(right) == \\' \\') --right;\\n\\n    Deque<String> d = new ArrayDeque();\\n    StringBuilder word = new StringBuilder();\\n    // push word by word in front of deque\\n    while (left <= right) {\\n      char c = s.charAt(left);\\n\\n      if ((word.length() != 0) && (c == \\' \\')) {\\n        d.offerFirst(word.toString());\\n        word.setLength(0);\\n      } else if (c != \\' \\') {\\n        word.append(c);\\n      }\\n      ++left;\\n    }\\n    d.offerFirst(word.toString());\\n\\n    return String.join(\" \", d);\\n  }\\n}\\n```\\n*Complexity Analysis*\\n\\nTime complexity: O(N).\\n\\nSpace complexity: O(N).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String reverseWords(String s) {\\n    // remove leading spaces\\n    s = s.trim();\\n    // split by multiple spaces\\n    List<String> wordList = Arrays.asList(s.split(\"\\\\\\\\s+\"));\\n    Collections.reverse(wordList);\\n    return String.join(\" \", wordList);\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public StringBuilder trimSpaces(String s) {\\n    int left = 0, right = s.length() - 1;\\n    // remove leading spaces\\n    while (left <= right && s.charAt(left) == \\' \\') ++left;\\n\\n    // remove trailing spaces\\n    while (left <= right && s.charAt(right) == \\' \\') --right;\\n\\n    // reduce multiple spaces to single one\\n    StringBuilder sb = new StringBuilder();\\n    while (left <= right) {\\n      char c = s.charAt(left);\\n\\n      if (c != \\' \\') sb.append(c);\\n      else if (sb.charAt(sb.length() - 1) != \\' \\') sb.append(c);\\n\\n      ++left;\\n    }\\n    return sb;\\n  }\\n\\n  public void reverse(StringBuilder sb, int left, int right) {\\n    while (left < right) {\\n      char tmp = sb.charAt(left);\\n      sb.setCharAt(left++, sb.charAt(right));\\n      sb.setCharAt(right--, tmp);\\n    }\\n  }\\n\\n  public void reverseEachWord(StringBuilder sb) {\\n    int n = sb.length();\\n    int start = 0, end = 0;\\n\\n    while (start < n) {\\n      // go to the end of the word\\n      while (end < n && sb.charAt(end) != \\' \\') ++end;\\n      // reverse the word\\n      reverse(sb, start, end - 1);\\n      // move to the next word\\n      start = end + 1;\\n      ++end;\\n    }\\n  }\\n\\n  public String reverseWords(String s) {\\n    // converst string to string builder \\n    // and trim spaces at the same time\\n    StringBuilder sb = trimSpaces(s);\\n\\n    // reverse the whole string\\n    reverse(sb, 0, sb.length() - 1);\\n\\n    // reverse each word\\n    reverseEachWord(sb);\\n\\n    return sb.toString();\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public String reverseWords(String s) {\\n    int left = 0, right = s.length() - 1;\\n    // remove leading spaces\\n    while (left <= right && s.charAt(left) == \\' \\') ++left;\\n\\n    // remove trailing spaces\\n    while (left <= right && s.charAt(right) == \\' \\') --right;\\n\\n    Deque<String> d = new ArrayDeque();\\n    StringBuilder word = new StringBuilder();\\n    // push word by word in front of deque\\n    while (left <= right) {\\n      char c = s.charAt(left);\\n\\n      if ((word.length() != 0) && (c == \\' \\')) {\\n        d.offerFirst(word.toString());\\n        word.setLength(0);\\n      } else if (c != \\' \\') {\\n        word.append(c);\\n      }\\n      ++left;\\n    }\\n    d.offerFirst(word.toString());\\n\\n    return String.join(\" \", d);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806511,
                "title": "python-easiest-one-liner-solution",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        return \" \".join(s.split()[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328921,
                "title": "swift-o-n-one-liner-85-beatings-smooth-like-butter-butter-for-your-roll",
                "content": "```\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.components(separatedBy: \" \").compactMap { $0.count > 0 ? $0 : nil }.reversed().joined(separator: \" \")\\n    }\\n}\\n```\\n\\nHere\\'s one instance where Swift really shines. Very cool.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseWords(_ s: String) -> String {\\n        return s.components(separatedBy: \" \").compactMap { $0.count > 0 ? $0 : nil }.reversed().joined(separator: \" \")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47947,
                "title": "clean-java-solution-using-split-o-n-time-and-o-n-space",
                "content": "    public class Solution {\\n        public String reverseWords(String s) {\\n            StringBuilder sb = new StringBuilder();\\n            if(s.length() == 0 || s == null)\\n                return sb.toString();\\n            String[] tmp = s.split(\"\\\\\\\\s{1,}\");\\n            for(int i = tmp.length-1; i>=0; i--) {\\n                sb.append(tmp[i] + \" \");\\n            }\\n            return sb.toString().trim();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String reverseWords(String s) {\\n            StringBuilder sb = new StringBuilder();\\n            if(s.length() == 0 || s == null)\\n                return sb.toString();\\n            String[] tmp = s.split(\"\\\\\\\\s{1,}",
                "codeTag": "Java"
            },
            {
                "id": 47901,
                "title": "one-line-accepted-python-code",
                "content": "One line accepted python code, although that is no the interview goal. \\n\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return a string\\n    def reverseWords(self, s):\\n        return ' '.join(reversed(s.split()))",
                "solutionTags": [],
                "code": "One line accepted python code, although that is no the interview goal. \\n\\n\\n    class Solution:\\n    # @param s, a string\\n    # @return a string\\n    def reverseWords(self, s):\\n        return ' '.join(reversed(s.split()))",
                "codeTag": "Java"
            },
            {
                "id": 4068550,
                "title": "best-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeSpaces(string s) {\\n        int n = s.size();\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            if (s[j] != \\' \\' || (j != 0 && s[j - 1] != \\' \\')) {\\n                s[i] = s[j];\\n                i++;\\n            }\\n            j++;\\n        }\\n        if (s[i - 1] == \\' \\')\\n            i--;\\n        return s.substr(0, i);\\n    }\\n\\n    string reverseWords(string s) {\\n        s = removeSpaces(s);\\n        int n = s.size();\\n        int end = 0;\\n        while (end < n) {\\n            int start = end;\\n            while (end < n && s[end] != \\' \\')\\n                end++;\\n            reverse(s.begin() + start, s.begin() + end);\\n            end++;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeSpaces(string s) {\\n        int n = s.size();\\n        int i = 0, j = 0;\\n        while (j < n) {\\n            if (s[j] != \\' \\' || (j != 0 && s[j - 1] != \\' \\')) {\\n                s[i] = s[j];\\n                i++;\\n            }\\n            j++;\\n        }\\n        if (s[i - 1] == \\' \\')\\n            i--;\\n        return s.substr(0, i);\\n    }\\n\\n    string reverseWords(string s) {\\n        s = removeSpaces(s);\\n        int n = s.size();\\n        int end = 0;\\n        while (end < n) {\\n            int start = end;\\n            while (end < n && s[end] != \\' \\')\\n                end++;\\n            reverse(s.begin() + start, s.begin() + end);\\n            end++;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920466,
                "title": "java-3-line-easy-to-understand-by-split-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n       String words[]=s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \",words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n       String words[]=s.trim().split(\" +\");\\n        Collections.reverse(Arrays.asList(words));\\n        return String.join(\" \",words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843025,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\n- Initialize an empty string temp to store the reversed words.\\n\\n- Initialize an integer i to 0, representing the current position in the input string s.\\n\\n- Calculate the length of the input string s and store it in the integer variable n.\\n\\n- Enter a while loop that continues until i reaches the end of the input string (i < n).\\n\\n- Inside the loop, skip any leading spaces in the input string by incrementing i while s[i] is a space.\\n\\n- Check if i has reached the end of the string (i >= n). If it has, break out of the loop.\\n\\n- Otherwise, continue to find the end of the current word by incrementing j while s[j] is not a space.\\n\\n- Extract the current word from the input string using s.substr(i, j - i) and store it in the string variable ans.\\n\\n- Check if temp is empty. If it is, set temp to the current word ans.\\n\\n- If temp is not empty, append the current word to temp, separated by a space, with the current word coming before the existing contents of temp.\\n\\n- Move i to the next position after the current word (i.e., j+1) to continue searching for the next word.\\n\\n- Once the loop ends, return the temp string, which contains the reversed words of the input string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        string temp;\\n        int i =0; \\n        int n  = s.length();\\n        while(i<n)\\n        {\\n            while(i<n && s[i]==\\' \\')\\n            {\\n                i++;\\n            }\\n            if(i>=n)\\n            {\\n                break; \\n            }\\n            int j=i+1;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                j++;\\n            }\\n            string ans= s.substr(i,j-i);\\n            if(temp.length()== 0) temp =ans;\\n            else \\n            temp = ans + \" \" + temp; \\n            i=j+1;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s)\\n    {\\n        string temp;\\n        int i =0; \\n        int n  = s.length();\\n        while(i<n)\\n        {\\n            while(i<n && s[i]==\\' \\')\\n            {\\n                i++;\\n            }\\n            if(i>=n)\\n            {\\n                break; \\n            }\\n            int j=i+1;\\n            while(j<n && s[j]!=\\' \\')\\n            {\\n                j++;\\n            }\\n            string ans= s.substr(i,j-i);\\n            if(temp.length()== 0) temp =ans;\\n            else \\n            temp = ans + \" \" + temp; \\n            i=j+1;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793605,
                "title": "easiest-solution-in-c-with-100-beats",
                "content": "# Intuition\\nstore all words in string vector.\\n\\n# Approach\\nfirst of all idea is simple, we have to store the all words in vector of type string. after that we add all words which are stored in vector to answer string and space after each word except last word.\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string str=\"\";\\n        string temp=\"\";\\n        vector<string> ans;\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                temp=\"\";\\n            }\\n        \\n            while(s[i]!=\\' \\' && i<s.length())\\n            {\\n                temp+=s[i];\\n                i++;\\n            }\\n            if(temp!=\"\")\\n                ans.push_back(temp);\\n            temp=\"\";  \\n        }\\n\\n        for(int i=ans.size()-1;i>=0;i--)\\n        {\\n            str+=ans[i];\\n            if(i!=0)\\n                str+=\\' \\';\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string str=\"\";\\n        string temp=\"\";\\n        vector<string> ans;\\n\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                temp=\"\";\\n            }\\n        \\n            while(s[i]!=\\' \\' && i<s.length())\\n            {\\n                temp+=s[i];\\n                i++;\\n            }\\n            if(temp!=\"\")\\n                ans.push_back(temp);\\n            temp=\"\";  \\n        }\\n\\n        for(int i=ans.size()-1;i>=0;i--)\\n        {\\n            str+=ans[i];\\n            if(i!=0)\\n                str+=\\' \\';\\n        }\\n\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734674,
                "title": "c-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n){\\n            while(i<n && s[i]==\\' \\') i++;\\n            if(i==n) break;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') j++;\\n            string str=s.substr(i,j-i);\\n            if(result.size()==0) result=str;\\n            else result=str+\" \"+result;\\n            i=j+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n=s.size();\\n        int i=0;\\n        while(i<n){\\n            while(i<n && s[i]==\\' \\') i++;\\n            if(i==n) break;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') j++;\\n            string str=s.substr(i,j-i);\\n            if(result.size()==0) result=str;\\n            else result=str+\" \"+result;\\n            i=j+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418953,
                "title": "simplest-faster-than-90",
                "content": "# Intuition\\nSIMPLE BRUTE FORCE\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(N):\\n      O(N) for traversing the string + O(N) for reversing\\n\\n- Space complexity:\\n O(N) :\\n      For storing the result \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res=\"\"; // to store the final result\\n        int i=s.length()-1;\\n\\n        while(i>=0){\\n            if(s[i]==\\' \\') i--; // ignore the spaces\\n            else{\\n                int j=i;\\n                string temp=\" \"; // whenever adding a word start with a space\\n                while(j>=0 && s[j]!=\\' \\'){\\n                    temp+=s[j--];\\n                }\\n                reverse(temp.begin(),temp.end());\\n                // since we added the word in reverse order so we need to reverse it\\n                res+=temp;\\n                i=j;\\n            }\\n        }\\n        res.pop_back(); \\n        /* last character will be a space since we are adding a space each time we\\n           add a word */\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string res=\"\"; // to store the final result\\n        int i=s.length()-1;\\n\\n        while(i>=0){\\n            if(s[i]==\\' \\') i--; // ignore the spaces\\n            else{\\n                int j=i;\\n                string temp=\" \"; // whenever adding a word start with a space\\n                while(j>=0 && s[j]!=\\' \\'){\\n                    temp+=s[j--];\\n                }\\n                reverse(temp.begin(),temp.end());\\n                // since we added the word in reverse order so we need to reverse it\\n                res+=temp;\\n                i=j;\\n            }\\n        }\\n        res.pop_back(); \\n        /* last character will be a space since we are adding a space each time we\\n           add a word */\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413189,
                "title": "without-stringstream-faster-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        // we need to do, three types of trimming\\n        // 1. trimming spaces from front\\n        // 2. trimmnig spaces from end\\n        // 3. trimming spaces from middle\\n        \\n        // and first of all, lets reverse each word of the string, don\\'t trim now\\n        \\n        vector<string> res;\\n        string str = \"\";\\n        int n = s.size();\\n        for(int i = n-1 ; i >= 0 ; i--) {\\n            if(s[i] != \\' \\') str += s[i];\\n            else {\\n                reverse(str.begin(), str.end());\\n                res.push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        \\n        // let\\'s convert the vector into a string with spaces\\n        \\n        string ans = \"\";\\n        for(int i = 0 ; i < res.size() ; i++) {\\n            ans += res[i];\\n            ans += \\' \\';\\n        }\\n        \\n        // below step is to add the last string if got missed while adding, eg- if \"abc def  adj\"\\n        // here last string may got missed\\n        \\n        if(str.size() != 0) {\\n            reverse(str.begin(), str.end());\\n            ans += str;\\n        }\\n        \\n        // remove space from front (find the index where words start from beginning)\\n        \\n        string st = \"\";\\n        int ind1 = 0;\\n        while(ans[ind1] == \\' \\'){\\n            ind1++;\\n        }\\n        \\n        // remove space from end (find the index from back where words starts)\\n        \\n        int ind2 = ans.length()-1;\\n        while(ans[ind2] == \\' \\'){\\n            ind2--;\\n        }\\n      \\n        // let\\'s make a new updated string\\n        \\n        for(int i = ind1 ; i <= ind2 ; i++) st += ans[i];\\n        \\n        // remove space from middle\\n        \\n        string finl = \"\";\\n        int j = 0;\\n\\n        string final_ans = \"\";\\n        for(int i = 0 ; i < st.size() ; i++) {\\n            if(st[i] != \\' \\') {\\n                // cout << st[i];\\n                final_ans += st[i];\\n            }\\n            else{\\n                while(st[i] == \\' \\') i++;\\n                // cout << \\' \\';\\n                final_ans += \\' \\';\\n                i--;\\n            }\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        // we need to do, three types of trimming\\n        // 1. trimming spaces from front\\n        // 2. trimmnig spaces from end\\n        // 3. trimming spaces from middle\\n        \\n        // and first of all, lets reverse each word of the string, don\\'t trim now\\n        \\n        vector<string> res;\\n        string str = \"\";\\n        int n = s.size();\\n        for(int i = n-1 ; i >= 0 ; i--) {\\n            if(s[i] != \\' \\') str += s[i];\\n            else {\\n                reverse(str.begin(), str.end());\\n                res.push_back(str);\\n                str = \"\";\\n            }\\n        }\\n        \\n        // let\\'s convert the vector into a string with spaces\\n        \\n        string ans = \"\";\\n        for(int i = 0 ; i < res.size() ; i++) {\\n            ans += res[i];\\n            ans += \\' \\';\\n        }\\n        \\n        // below step is to add the last string if got missed while adding, eg- if \"abc def  adj\"\\n        // here last string may got missed\\n        \\n        if(str.size() != 0) {\\n            reverse(str.begin(), str.end());\\n            ans += str;\\n        }\\n        \\n        // remove space from front (find the index where words start from beginning)\\n        \\n        string st = \"\";\\n        int ind1 = 0;\\n        while(ans[ind1] == \\' \\'){\\n            ind1++;\\n        }\\n        \\n        // remove space from end (find the index from back where words starts)\\n        \\n        int ind2 = ans.length()-1;\\n        while(ans[ind2] == \\' \\'){\\n            ind2--;\\n        }\\n      \\n        // let\\'s make a new updated string\\n        \\n        for(int i = ind1 ; i <= ind2 ; i++) st += ans[i];\\n        \\n        // remove space from middle\\n        \\n        string finl = \"\";\\n        int j = 0;\\n\\n        string final_ans = \"\";\\n        for(int i = 0 ; i < st.size() ; i++) {\\n            if(st[i] != \\' \\') {\\n                // cout << st[i];\\n                final_ans += st[i];\\n            }\\n            else{\\n                while(st[i] == \\' \\') i++;\\n                // cout << \\' \\';\\n                final_ans += \\' \\';\\n                i--;\\n            }\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3047889,
                "title": "java-6-lines-using-stringbuilder-94-faster",
                "content": "```please upvote, if you find it useful```\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> words = Arrays.asList(s.trim().split(\" \"));\\n        Collections.reverse(words);\\n        StringBuilder sb = new StringBuilder();\\n        for (String w : words) if(w.length() > 0) sb.append(w).append(\" \");\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```please upvote, if you find it useful```\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> words = Arrays.asList(s.trim().split(\" \"));\\n        Collections.reverse(words);\\n        StringBuilder sb = new StringBuilder();\\n        for (String w : words) if(w.length() > 0) sb.append(w).append(\" \");\\n        sb.setLength(sb.length() - 1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948608,
                "title": "clean-straight-forward-step-by-step-concise-python-solution-with-approach-and-complexity",
                "content": "# Intuition\\nStraight forward - \\n\\n1. Split the words by space\\n2. Reverse the order of the words\\n3. Join these words with space\\n\\n# Approach\\n\\'self.split\\' is developed in such a way that, trim() and strip() are automatically handled. \\'self.reverse_list\\' just reverses list in-place using two pointers.\\n\\n# Complexity\\n- Time & Space : O(n), O(n) to store the splitted words of a string \\n\\n# Code\\n```\\nclass Solution:\\n    def split(self, s: str, delimiter=\" \") -> List[str]:\\n        start, end = 0, 0\\n\\n        res = []\\n        for ch in s:\\n            if ch == delimiter:\\n                if start == end:\\n                    start += 1\\n                else:\\n                    res.append(s[start:end])\\n                    start  = end + 1\\n            \\n            end += 1\\n        \\n        if start != end:\\n            res.append(s[start:end])\\n\\n        return res\\n\\n    def reverse_list(self, ll: List[str]) -> List[str]:\\n        l, r = 0, len(ll) - 1\\n\\n        while l < r:\\n            ll[l], ll[r] = ll[r], ll[l]\\n            l += 1\\n            r -= 1\\n        \\n        return ll\\n\\n    def reverseWords(self, s: str) -> str:\\n\\n        # split first\\n        splitted_str_list = self.split(s)\\n\\n        # reverse splitted list\\n        reversed_str_list = self.reverse_list(splitted_str_list)\\n\\n        # join an return\\n        return \" \".join(reversed_str_list)\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def split(self, s: str, delimiter=\" \") -> List[str]:\\n        start, end = 0, 0\\n\\n        res = []\\n        for ch in s:\\n            if ch == delimiter:\\n                if start == end:\\n                    start += 1\\n                else:\\n                    res.append(s[start:end])\\n                    start  = end + 1\\n            \\n            end += 1\\n        \\n        if start != end:\\n            res.append(s[start:end])\\n\\n        return res\\n\\n    def reverse_list(self, ll: List[str]) -> List[str]:\\n        l, r = 0, len(ll) - 1\\n\\n        while l < r:\\n            ll[l], ll[r] = ll[r], ll[l]\\n            l += 1\\n            r -= 1\\n        \\n        return ll\\n\\n    def reverseWords(self, s: str) -> str:\\n\\n        # split first\\n        splitted_str_list = self.split(s)\\n\\n        # reverse splitted list\\n        reversed_str_list = self.reverse_list(splitted_str_list)\\n\\n        # join an return\\n        return \" \".join(reversed_str_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810825,
                "title": "adding-another-vague-solution-to-this-pool",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String words[] = s.split(\" \"), res = \"\";\\n        for(String word : words){ \\n            if(!word.equals(\"\"))\\n                res = word+\" \"+res;\\n        }\\n        return res.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String words[] = s.split(\" \"), res = \"\";\\n        for(String word : words){ \\n            if(!word.equals(\"\"))\\n                res = word+\" \"+res;\\n        }\\n        return res.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810458,
                "title": "c-one-line",
                "content": "```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n         return String.Join(\" \", s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries).Reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string ReverseWords(string s) {\\n         return String.Join(\" \", s.Split(\\' \\', StringSplitOptions.RemoveEmptyEntries).Reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991265,
                "title": "python-two-liner-91-faster-and-beats-81-memory-usage",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        new = s.split()\\n        return \" \".join(new[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        new = s.split()\\n        return \" \".join(new[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533474,
                "title": "easy-understanding-c-using-stack-85-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> rev;\\n        string word;\\n        for(int i = 0; i < s.length(); ++i){\\n            if(s[i] != \\' \\'){\\n                word.push_back(s[i]);\\n            }else if(!word.empty()){\\n                rev.push(word);\\n                word.clear();\\n            }\\n        }\\n        \\n        if(!word.empty()){\\n            rev.push(word);\\n            word.clear();\\n        }\\n        \\n        while(!rev.empty()){\\n            word.append(rev.top());\\n            word.append(\" \");\\n            rev.pop();\\n        }\\n        \\n        word.pop_back();\\n        \\n        return word;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> rev;\\n        string word;\\n        for(int i = 0; i < s.length(); ++i){\\n            if(s[i] != \\' \\'){\\n                word.push_back(s[i]);\\n            }else if(!word.empty()){\\n                rev.push(word);\\n                word.clear();\\n            }\\n        }\\n        \\n        if(!word.empty()){\\n            rev.push(word);\\n            word.clear();\\n        }\\n        \\n        while(!rev.empty()){\\n            word.append(rev.top());\\n            word.append(\" \");\\n            rev.pop();\\n        }\\n        \\n        word.pop_back();\\n        \\n        return word;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252154,
                "title": "short-concise-c-code-no-stack-reverse-anything",
                "content": "Just use stringstream to pick up each word. stringstream ignores spaces. and just delete the leading space that\\'ll be there.\\n\\n```class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans=\"\",word=\"\";\\n        stringstream ss(s);\\n        while(ss>>word){\\n            ans=\" \"+word+ans;\\n        }\\n        ans.erase(ans.begin()+0);\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans=\"\",word=\"\";\\n        stringstream ss(s);\\n        while(ss>>word){\\n            ans=\" \"+word+ans;\\n        }\\n        ans.erase(ans.begin()+0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738678,
                "title": "c-solution-simple-approach",
                "content": "Let\\'s take the string **s** : **the sky is blue**. We can take another string **ans** and append every word of **s** to start of **ans**.\\nThis way :\\nans : the\\nans : sky + \" \" + the\\nans : is + \" \" + sky the\\nans : blue + \" \" + is sky the\\nAnd, We have ans : **blue is sky the**\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\", temp = \"\";\\n        for(int i = 0; i <= s.length(); i++){\\n            if(i == s.length() || s[i] == \\' \\'){\\n                if(temp.empty() == false){\\n                    if(ans.empty()) ans = temp;\\n                    else ans = temp + \" \" + ans;\\n                }\\n                temp.clear();\\n            }\\n            else{\\n                temp += s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string ans = \"\", temp = \"\";\\n        for(int i = 0; i <= s.length(); i++){\\n            if(i == s.length() || s[i] == \\' \\'){\\n                if(temp.empty() == false){\\n                    if(ans.empty()) ans = temp;\\n                    else ans = temp + \" \" + ans;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 724385,
                "title": "stringstream-solution",
                "content": "```\\nstring reverseWords(string s) \\n{\\n\\tstring out;\\n\\tstringstream ss(s);\\n\\tfor(ss>>out; ss>>s; out = move(s.append(\" \"s.append(out)))); \\n\\treturn out;\\n}\\n```\\n||\\n```\\nstring reverseWords(string s) \\n{\\n\\tstring out;\\n\\tstringstream ss(s);\\n\\tfor(ss>>out; ss>>s; out = s+\" \"+out); \\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring reverseWords(string s) \\n{\\n\\tstring out;\\n\\tstringstream ss(s);\\n\\tfor(ss>>out; ss>>s; out = move(s.append(\" \"s.append(out)))); \\n\\treturn out;\\n}\\n```\n```\\nstring reverseWords(string s) \\n{\\n\\tstring out;\\n\\tstringstream ss(s);\\n\\tfor(ss>>out; ss>>s; out = s+\" \"+out); \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248105,
                "title": "c-solution-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> stk;\\n        int pos = 0;\\n        string res;\\n\\n        while (pos < s.length()) {\\n            int end, start;\\n            \\n            while(s[pos] == \\' \\' && pos < s.length())\\n                pos++;\\n            \\n            start = pos;\\n            \\n            while (s[pos] != \\' \\' && pos < s.length())\\n                pos++;\\n            \\n            end = pos;\\n\\n            if (end == start)\\n                break;\\n            \\n            stk.push(s.substr(start, end - start));\\n        }\\n\\n        while (!stk.empty()) {\\n            res += stk.top();\\n            stk.pop();\\n            if (!stk.empty())\\n                res += \" \";\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> stk;\\n        int pos = 0;\\n        string res;\\n\\n        while (pos < s.length()) {\\n            int end, start;\\n            \\n            while(s[pos] == \\' \\' && pos < s.length())\\n                pos++;\\n            \\n            start = pos;\\n            \\n            while (s[pos] != \\' \\' && pos < s.length())\\n                pos++;\\n            \\n            end = pos;\\n\\n            if (end == start)\\n                break;\\n            \\n            stk.push(s.substr(start, end - start));\\n        }\\n\\n        while (!stk.empty()) {\\n            res += stk.top();\\n            stk.pop();\\n            if (!stk.empty())\\n                res += \" \";\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163683,
                "title": "one-line-javascript-lambda-using-method-chains-and-a-regex",
                "content": "```\\nconst reverseWords = str => str.trim().split(/\\\\s+/).reverse().join(\\' \\');\\n```\\n- Remove all leading/trailing whitespace\\n- Split the string by whitespace\\n- Reverse the array\\n- Join the array of words in reverse",
                "solutionTags": [],
                "code": "```\\nconst reverseWords = str => str.trim().split(/\\\\s+/).reverse().join(\\' \\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134021,
                "title": "c-string-solution-in-place-beat-99-runtime-o-n-memory-0",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        int start = 0;\\n        int i = 0;\\n        while( s[i] == \\' \\') s.erase(i, 1);\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        while( s[i] == \\' \\') s.erase(i, 1);\\n\\n        int size = s.size();\\n        for(i = 0; i < size - 1; i++){\\n            if( s[i] == \\' \\'){\\n                if( i == start ){\\n                    s.erase(i--,1);\\n                    size--;\\n                }\\n                else{\\n                    reverse(s.begin()+start, s.begin()+i);\\n                    start = i+1;\\n                }\\n            }\\n        }\\n        \\n        reverse(s.begin() + start, s.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseWords(string &s) {\\n        int start = 0;\\n        int i = 0;\\n        while( s[i] == \\' \\') s.erase(i, 1);\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        while( s[i] == \\' \\') s.erase(i, 1);\\n\\n        int size = s.size();\\n        for(i = 0; i < size - 1; i++){\\n            if( s[i] == \\' \\'){\\n                if( i == start ){\\n                    s.erase(i--,1);\\n                    size--;\\n                }\\n                else{\\n                    reverse(s.begin()+start, s.begin()+i);\\n                    start = i+1;\\n                }\\n            }\\n        }\\n        \\n        reverse(s.begin() + start, s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 47823,
                "title": "javascript-o-1-space-on-character-array",
                "content": "Inspired by other O(1) space solutions.  As others have mentioned, Strings are immutable in JS, so we have to split the input into an Array of 1 character Strings to do in-place modifications.\\n\\n```\\n/**\\n * Operates on an array of characters in O(N) time, O(1) space.\\n * @param {string} str\\n * @returns {string}\\n */\\nfunction reverseWords(str) {\\n    // This part is not O(1) space, but it's just our integration code with LeetCode.\\n    // Outside this sandbox, we'd ask callers to pass an a character Array instead of a String\\n    // for best performance.\\n    return _reverseWords(str.split('')).join('');\\n}\\n\\nfunction _reverseWords(chars) {\\n    // Reverse the whole string\\n    reverse(chars);\\n\\n    let spaceCount = 0;\\n    let wordCount = 0;\\n    for(let i=0; i<chars.length; i++) {\\n        // Consume spaces\\n        if(chars[i] === ' ') {\\n            spaceCount++;\\n            continue;\\n        }\\n\\n        // Re-reverse a word\\n        let j; // word end index\\n        for(j=i; j<chars.length && chars[j] !== ' '; j++) {}\\n        j -= 1;\\n        reverse(chars, i, j);\\n        wordCount += 1;\\n\\n        // Shift the word left to collapse extra space\\n        shiftLeft(chars, i, j, spaceCount - wordCount + 1);\\n\\n        // Advance through the word\\n        i=j;\\n    }\\n\\n    // Remove trailing space\\n    while(spaceCount > wordCount - 1) {\\n      spaceCount--;\\n      chars.pop();\\n    }\\n\\n    return chars;\\n}\\n\\n// In place reverse, both indicies inclusive\\nfunction reverse(chars, lo, hi) {\\n    lo = lo || 0;\\n    if(typeof hi === 'undefined') hi = chars.length - 1;\\n    while(lo < hi){\\n        tmp = chars[lo];\\n        chars[lo] = chars[hi];\\n        chars[hi] = tmp;\\n        lo++; hi--;\\n    }\\n}\\n\\n// In place shift, both indicies inclusive\\nfunction shiftLeft(chars, start, end, offset) {\\n    for(let k=start-offset; k<=end-offset; k++) {\\n        chars[k] = chars[k+offset];\\n    }\\n    // Add a trailing space\\n    if(offset) {\\n      chars[end - offset + 1] = ' ';\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Operates on an array of characters in O(N) time, O(1) space.\\n * @param {string} str\\n * @returns {string}\\n */\\nfunction reverseWords(str) {\\n    // This part is not O(1) space, but it's just our integration code with LeetCode.\\n    // Outside this sandbox, we'd ask callers to pass an a character Array instead of a String\\n    // for best performance.\\n    return _reverseWords(str.split('')).join('');\\n}\\n\\nfunction _reverseWords(chars) {\\n    // Reverse the whole string\\n    reverse(chars);\\n\\n    let spaceCount = 0;\\n    let wordCount = 0;\\n    for(let i=0; i<chars.length; i++) {\\n        // Consume spaces\\n        if(chars[i] === ' ') {\\n            spaceCount++;\\n            continue;\\n        }\\n\\n        // Re-reverse a word\\n        let j; // word end index\\n        for(j=i; j<chars.length && chars[j] !== ' '; j++) {}\\n        j -= 1;\\n        reverse(chars, i, j);\\n        wordCount += 1;\\n\\n        // Shift the word left to collapse extra space\\n        shiftLeft(chars, i, j, spaceCount - wordCount + 1);\\n\\n        // Advance through the word\\n        i=j;\\n    }\\n\\n    // Remove trailing space\\n    while(spaceCount > wordCount - 1) {\\n      spaceCount--;\\n      chars.pop();\\n    }\\n\\n    return chars;\\n}\\n\\n// In place reverse, both indicies inclusive\\nfunction reverse(chars, lo, hi) {\\n    lo = lo || 0;\\n    if(typeof hi === 'undefined') hi = chars.length - 1;\\n    while(lo < hi){\\n        tmp = chars[lo];\\n        chars[lo] = chars[hi];\\n        chars[hi] = tmp;\\n        lo++; hi--;\\n    }\\n}\\n\\n// In place shift, both indicies inclusive\\nfunction shiftLeft(chars, start, end, offset) {\\n    for(let k=start-offset; k<=end-offset; k++) {\\n        chars[k] = chars[k+offset];\\n    }\\n    // Add a trailing space\\n    if(offset) {\\n      chars[end - offset + 1] = ' ';\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 47898,
                "title": "java-solution-no-trim-split-are-used",
                "content": "        \\n    \\n    // no trim(), split() are used\\n    public String reverseWords2(String s) {\\n        if (s.equals(null) || s.equals(\"\"))\\n            return s;\\n        String ret = \"\";\\n        int i = 0;\\n        int l = s.length();\\n        while (i < l) {\\n            while (i < l && s.charAt(i) == ' ')\\n                i++;\\n            String w = \"\";\\n            while (i < l && s.charAt(i) != ' ') {\\n                w += s.charAt(i);\\n                i++;\\n            }\\n            if (!w.equals(\"\"))\\n                ret = w + \" \" + ret;\\n        }\\n        return ret.isEmpty()?\"\":ret.substring(0, ret.length()-1);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    \\n    // no trim(), split() are used\\n    public String reverseWords2(String s) {\\n        if (s.equals(null) || s.equals(\"\"))\\n            return s;\\n        String ret = \"\";\\n        int i = 0;\\n        int l = s.length();\\n        while (i < l) {\\n            while (i < l && s.charAt(i) == ' ')\\n                i++;\\n            String w = \"\";\\n            while (i < l && s.charAt(i) != ' ') {\\n                w += s.charAt(i);\\n                i++;\\n            }\\n            if (!w.equals(\"\"))\\n                ret = w + \" \" + ret;\\n        }\\n        return ret.isEmpty()?\"\":ret.substring(0, ret.length()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47950,
                "title": "short-java-solution",
                "content": "    \\n    public String reverseWords(String s) {\\n    \\tif (s.trim().isEmpty()) \\n    \\t\\treturn s.trim();\\n    \\tStringBuffer ans = new StringBuffer();   \\t\\n        String[] words = s.trim().split(\"[ ]+\");\\n        for (int i = words.length - 1; i >= 0; i--) {\\n        \\tans.append(words[i]).append(\" \");\\n        }\\n        return ans.toString().trim();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    \\n    public String reverseWords(String s) {\\n    \\tif (s.trim().isEmpty()) \\n    \\t\\treturn s.trim();\\n    \\tStringBuffer ans = new StringBuffer();   \\t\\n        String[] words = s.trim().split(\"[ ]+\");\\n        for (int i = words.length - 1; i >= 0; i--) {\\n        \\tans.append(words[i]).append(\" \");\\n        }\\n        return ans.toString().trim();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 47959,
                "title": "python-3-lines-40ms-solution",
                "content": "    class Solution(object):\\n        def reverseWords(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            s=s.strip()\\n            sl=s.split()\\n            return ' '.join(reversed(sl))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseWords(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            s=s.strip()\\n            sl=s.split()\\n            return ' '.join(reversed(sl))",
                "codeTag": "Java"
            },
            {
                "id": 3948287,
                "title": "simple-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i = s.size()-1; i>=0; i--){\\n\\n            if(s[i] != \\' \\'){\\n                temp = s[i] + temp;\\n            }\\n            else{\\n                while( i>=0   &&   s[i] == \\' \\'){\\n                    i--;\\n                }\\n\\n                if(i>=0 && temp.size()>0){\\n                    ans = ans + temp;\\n                    ans = ans + \\' \\';\\n                }\\n\\n                if(i>=0){\\n                    temp = s[i];\\n                }\\n            }\\n        }\\n\\n        if(temp.size() > 0 ){\\n            ans = ans + temp;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        \\n        string ans = \"\";\\n        string temp = \"\";\\n        for(int i = s.size()-1; i>=0; i--){\\n\\n            if(s[i] != \\' \\'){\\n                temp = s[i] + temp;\\n            }\\n            else{\\n                while( i>=0   &&   s[i] == \\' \\'){\\n                    i--;\\n                }\\n\\n                if(i>=0 && temp.size()>0){\\n                    ans = ans + temp;\\n                    ans = ans + \\' \\';\\n                }\\n\\n                if(i>=0){\\n                    temp = s[i];\\n                }\\n            }\\n        }\\n\\n        if(temp.size() > 0 ){\\n            ans = ans + temp;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939363,
                "title": "best-solution-with-easy-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate over the string and check.\\n2. If there are characters assign them to temp and move forward.\\n3. If space is encountered then break from above loop.\\n4. Now check if temp size >0\\n5. If ans size is e then assign temp to the ans.\\nElse do ans temp+\" \"+ans\\n\\n6. If space is encountered just move the pointer forward. */\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size(),i =0 ;\\n        string ans = \"\";\\n        while(i<n){\\n            string temp = \"\";\\n            while(s[i] == \\' \\' && i<n) i++;\\n            while(s[i] != \\' \\' && i<n ){\\n                temp+=s[i];\\n                i++;\\n            }\\n            if(temp.size()>0){\\n                if(ans.size()==0){\\n                    ans=temp;\\n                }\\n                else{\\n                    ans=temp+\" \"+ans;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ba6d4f53-b04f-4bbb-808a-a8a589e1d1b1_1692597047.217575.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size(),i =0 ;\\n        string ans = \"\";\\n        while(i<n){\\n            string temp = \"\";\\n            while(s[i] == \\' \\' && i<n) i++;\\n            while(s[i] != \\' \\' && i<n ){\\n                temp+=s[i];\\n                i++;\\n            }\\n            if(temp.size()>0){\\n                if(ans.size()==0){\\n                    ans=temp;\\n                }\\n                else{\\n                    ans=temp+\" \"+ans;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938767,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string temp=\"\",ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\' \\' && temp!=\"\"){\\n                ans=temp+\" \"+ans;\\n                temp=\"\";\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(temp!=\"\"){\\n            ans=temp+\" \"+ans;\\n        }\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string temp=\"\",ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]!=\\' \\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\' \\' && temp!=\"\"){\\n                ans=temp+\" \"+ans;\\n                temp=\"\";\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n        if(temp!=\"\"){\\n            ans=temp+\" \"+ans;\\n        }\\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935658,
                "title": "two-pointer-approach-0ms-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result = \"\";\\n        int end = s.size() - 1;\\n\\n        while (end >= 0) {\\n            while (end >= 0 && s[end] == \\' \\') {\\n                end--;\\n            }\\n\\n            if (end < 0) {\\n                break;\\n            }\\n\\n            if (!result.empty()) {\\n                result += \" \";\\n            }\\n\\n            int start = end;\\n            while (start >= 0 && s[start] != \\' \\') {\\n                start--;\\n            }\\n\\n            result += s.substr(start + 1, end - start);\\n            end = start;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result = \"\";\\n        int end = s.size() - 1;\\n\\n        while (end >= 0) {\\n            while (end >= 0 && s[end] == \\' \\') {\\n                end--;\\n            }\\n\\n            if (end < 0) {\\n                break;\\n            }\\n\\n            if (!result.empty()) {\\n                result += \" \";\\n            }\\n\\n            int start = end;\\n            while (start >= 0 && s[start] != \\' \\') {\\n                start--;\\n            }\\n\\n            result += s.substr(start + 1, end - start);\\n            end = start;\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848691,
                "title": "python3-soution-90-beats-in-runtime-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/1b68b5d8-fa19-4451-b506-bfa0baaa8015_1690902817.7787874.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s=s.split();s=s[::-1];p=\" \".join(s);return str(p)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        s=s.split();s=s[::-1];p=\" \".join(s);return str(p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714303,
                "title": "java-easy-solution-using-trim",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n     s = s.trim();\\n     int left = 0, right = s.length() - 1;\\n     String ans = \"\";\\n     String temp = \"\";\\n     //Iterate the string and keep on adding to form a word\\n\\t//If empty space is encountered then add the current word to the result\\n     while(left <= right) {\\n         char ch = s.charAt(left);\\n         if(ch != \\' \\')\\n         temp += ch;\\n         else if(ch == \\' \\') {\\n             if(!ans.equals(\"\"))\\n             ans = temp.trim() + \" \" + ans.trim();\\n             else \\n             ans = temp.trim();\\n             temp = \"\";\\n         }\\n         left ++;\\n     }\\n//If not empty string then add to the result(Last word is added)\\n     if(!temp.equals(\"\")) {\\n         if(!ans.equals(\"\"))\\n          ans = temp.trim() + \" \" + ans.trim();\\n         else \\n          ans = temp.trim();\\n     }\\n     return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n     s = s.trim();\\n     int left = 0, right = s.length() - 1;\\n     String ans = \"\";\\n     String temp = \"\";\\n     //Iterate the string and keep on adding to form a word\\n\\t//If empty space is encountered then add the current word to the result\\n     while(left <= right) {\\n         char ch = s.charAt(left);\\n         if(ch != \\' \\')\\n         temp += ch;\\n         else if(ch == \\' \\') {\\n             if(!ans.equals(\"\"))\\n             ans = temp.trim() + \" \" + ans.trim();\\n             else \\n             ans = temp.trim();\\n             temp = \"\";\\n         }\\n         left ++;\\n     }\\n//If not empty string then add to the result(Last word is added)\\n     if(!temp.equals(\"\")) {\\n         if(!ans.equals(\"\"))\\n          ans = temp.trim() + \" \" + ans.trim();\\n         else \\n          ans = temp.trim();\\n     }\\n     return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644759,
                "title": "t-c-o-n-s-c-o-n-beginners-friendly-c-and-python-3-code",
                "content": "# Intuition\\n\\n---\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size();\\n        int i = 0 ;\\n        string ans = \"\";\\n        \\n        while(  i < n )\\n        {\\n            while( i < n and s[i] == \\' \\')\\n            i++;\\n            if( i >= n)\\n            break;\\n            int j = i + 1;\\n            while( j < n and s[j]  != \\' \\')\\n            j++;\\n            string add = s.substr( i , j -i);\\n            if(ans == \"\")\\n            ans = add;\\n            else\\n            ans = add + \" \" + ans;\\n            i = j+ 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        n = len(s)\\n        i , ans  = 0 , \"\"\\n        while i < n :\\n            while i < n and s[i]== \\' \\':\\n                i+=1\\n            if  i == n:\\n                break\\n            j = i + 1\\n            while j < n and s[j] != \\' \\':\\n                j+= 1\\n            add = s[i : j  ]\\n            ans = add + \" \" + ans\\n            i = j + 1\\n        return ans[0 : len(ans)-1]\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int n = s.size();\\n        int i = 0 ;\\n        string ans = \"\";\\n        \\n        while(  i < n )\\n        {\\n            while( i < n and s[i] == \\' \\')\\n            i++;\\n            if( i >= n)\\n            break;\\n            int j = i + 1;\\n            while( j < n and s[j]  != \\' \\')\\n            j++;\\n            string add = s.substr( i , j -i);\\n            if(ans == \"\")\\n            ans = add;\\n            else\\n            ans = add + \" \" + ans;\\n            i = j+ 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        n = len(s)\\n        i , ans  = 0 , \"\"\\n        while i < n :\\n            while i < n and s[i]== \\' \\':\\n                i+=1\\n            if  i == n:\\n                break\\n            j = i + 1\\n            while j < n and s[j] != \\' \\':\\n                j+= 1\\n            add = s[i : j  ]\\n            ans = add + \" \" + ans\\n            i = j + 1\\n        return ans[0 : len(ans)-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565936,
                "title": "without-split-and-strip-python-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        i = 0\\n        j = len(s) - 1\\n        ans = \"\"\\n\\n        # Remove trailing spaces from the end\\n        while i < j and s[j] == \" \":\\n            j = j - 1\\n\\n        # Remove leading spaces from the beginning\\n        while i < j and s[i] == \" \":\\n            i = i + 1\\n\\n        k = j\\n        while k >= i:\\n            temp = 0\\n\\n            # Process non-space characters\\n            if s[k] != \" \":\\n                while k >= i and s[k] != \" \":\\n                    temp = temp + 1\\n                    k = k - 1\\n\\n                # Append the word to the answer string\\n                ans = ans + (s[k + 1 : k + temp + 1]) + \" \"\\n\\n            # Skip additional spaces\\n            while k >= i and s[k] == \" \":\\n                k = k - 1\\n\\n        # Remove trailing space from the end of the answer\\n        return ans[0 : len(ans) - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        i = 0\\n        j = len(s) - 1\\n        ans = \"\"\\n\\n        # Remove trailing spaces from the end\\n        while i < j and s[j] == \" \":\\n            j = j - 1\\n\\n        # Remove leading spaces from the beginning\\n        while i < j and s[i] == \" \":\\n            i = i + 1\\n\\n        k = j\\n        while k >= i:\\n            temp = 0\\n\\n            # Process non-space characters\\n            if s[k] != \" \":\\n                while k >= i and s[k] != \" \":\\n                    temp = temp + 1\\n                    k = k - 1\\n\\n                # Append the word to the answer string\\n                ans = ans + (s[k + 1 : k + temp + 1]) + \" \"\\n\\n            # Skip additional spaces\\n            while k >= i and s[k] == \" \":\\n                k = k - 1\\n\\n        # Remove trailing space from the end of the answer\\n        return ans[0 : len(ans) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506936,
                "title": "java-solution-for-reverse-words-in-a-string-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to reverse the order of words in a given string \"s\" while ignoring leading/trailing spaces and handling multiple consecutive spaces between words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, check if the input string \"s\" is null or empty. If true, return an empty string.\\n- Split the string \"s\" into individual words using the space character as the delimiter. This creates an array of words.\\n- Initialize a StringBuilder \"sb\" to store the reversed words.\\n- Iterate through the array of words in reverse order, starting from the last word.\\n- Check if the current word is not an empty string. If true, append it to the StringBuilder followed by a space.\\n- After the loop, check if the StringBuilder \"sb\" is empty. If true, return an empty string.\\n- If the StringBuilder is not empty, use the substring method to remove the trailing space at the end and return the reversed string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the length of the input string \"s\". This is because splitting the string and iterating through the words both take linear time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the length of the input string \"s\". This is primarily due to the StringBuilder \"sb\", which stores the reversed words.\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        if (s == null || s.length() == 0) \\n        {\\n            return \"\";\\n        }\\n        // split to words by space\\n        String[] arr = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = arr.length - 1; i >= 0; --i) \\n        {\\n            if (!arr[i].equals(\"\")) \\n            {\\n                sb.append(arr[i]).append(\" \");\\n            }\\n        }\\n    return sb.length() == 0 ? \"\" : sb.substring(0, sb.length() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        if (s == null || s.length() == 0) \\n        {\\n            return \"\";\\n        }\\n        // split to words by space\\n        String[] arr = s.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = arr.length - 1; i >= 0; --i) \\n        {\\n            if (!arr[i].equals(\"\")) \\n            {\\n                sb.append(arr[i]).append(\" \");\\n            }\\n        }\\n    return sb.length() == 0 ? \"\" : sb.substring(0, sb.length() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184544,
                "title": "simplest-c-code-using-substring-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string &s) {\\n        string str = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int c = i;\\n            while (i < s.length() && s[i] != \\' \\') i++;\\n            if (str.length() > 0) str = \\' \\' + str;\\n            str = s.substr(c, i - c) + str;\\n            i--;\\n        }\\n        return str;\\n    }\\n};\\nDo UPVOTE if you like\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string &s) {\\n        string str = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s[i] == \\' \\') continue;\\n            int c = i;\\n            while (i < s.length() && s[i] != \\' \\') i++;\\n            if (str.length() > 0) str = \\' \\' + str;\\n            str = s.substr(c, i - c) + str;\\n            i--;\\n        }\\n        return str;\\n    }\\n};\\nDo UPVOTE if you like\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886196,
                "title": "simple-python-solution",
                "content": "# Intuition\\nUsing Python in-built functions\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        temp=s.split()\\n        temp.reverse()\\n        ans=\" \".join(temp)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        temp=s.split()\\n        temp.reverse()\\n        ans=\" \".join(temp)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849980,
                "title": "decoding-medium-in-an-easy-way",
                "content": "# Intuition\\nStore all the words in the string into a string vector and making a string out of it in reverse order.\\n\\n# Approach\\nDeclare a string vector and an empty string which will continously update itself with thw words coming up. Iterate in the string and add the character into the string if it is not equal to \\' \\'. If the character is equal to \\' \\' then push the string into the vector and clear the string. After the loop again push the string into the vector if it is not empty. Declare a fresh string which will now contain our answer. Iterate in the vector in reverse order and add the string present in the vector into the final string following by a space character(\\' \\'). Return the string as an answer. Code is attached for your reference.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) \\n    {\\n        vector<string> ans; \\n        string temp =\"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\' \\' && temp != \"\")\\n            {\\n                ans.push_back(temp);\\n                temp = \"\";\\n            }\\n            else if(s[i] != \\' \\')\\n            {\\n                temp += s[i];\\n            }\\n        }   \\n        if(temp != \"\")  ans.push_back(temp);\\n        string val = \"\";\\n        for(int i = ans.size() - 1; i >= 0; i--)\\n        {\\n            val += ans[i];\\n            if(i)   val += \\' \\';\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) \\n    {\\n        vector<string> ans; \\n        string temp =\"\";\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\' \\' && temp != \"\")\\n            {\\n                ans.push_back(temp);\\n                temp = \"\";\\n            }\\n            else if(s[i] != \\' \\')\\n            {\\n                temp += s[i];\\n            }\\n        }   \\n        if(temp != \"\")  ans.push_back(temp);\\n        string val = \"\";\\n        for(int i = ans.size() - 1; i >= 0; i--)\\n        {\\n            val += ans[i];\\n            if(i)   val += \\' \\';\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812094,
                "title": "javascript-one-liner",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = (str) => \\n    str\\n        .split(\\' \\')\\n        .filter((word) => word.length > 0)\\n        .reverse()\\n        .join(\\' \\');\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar reverseWords = (str) => \\n    str\\n        .split(\\' \\')\\n        .filter((word) => word.length > 0)\\n        .reverse()\\n        .join(\\' \\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809051,
                "title": "c-code-and-short-explanation-2-pointers",
                "content": "\\nCollect all the characters bounded by two pointers: i & j and store the resultant string in a vector.\\n\\nIf a space is encountered, ignore it.\\n\\nTraverse the vector of strings from the end and append each string followed by a space character.\\n\\nRemove the last space character and return the string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector <string> v;\\n        int n = s.size(), i = 0, j = 0;\\n        string ans;\\n        while(i < n) {\\n\\n            while(j != n && s[j] != \\' \\')\\n                j++;\\n            \\n            if(j != i)\\n                v.push_back(s.substr(i, j - i));\\n            \\n            i = j + 1;\\n            j = i;\\n        }\\n\\n        for(int i = v.size() - 1; i >= 0; i--) {\\n            ans += v[i];\\n            ans.push_back(\\' \\');\\n        }\\n\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        vector <string> v;\\n        int n = s.size(), i = 0, j = 0;\\n        string ans;\\n        while(i < n) {\\n\\n            while(j != n && s[j] != \\' \\')\\n                j++;\\n            \\n            if(j != i)\\n                v.push_back(s.substr(i, j - i));\\n            \\n            i = j + 1;\\n            j = i;\\n        }\\n\\n        for(int i = v.size() - 1; i >= 0; i--) {\\n            ans += v[i];\\n            ans.push_back(\\' \\');\\n        }\\n\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677650,
                "title": "java-solution-intuitive-easy",
                "content": "APPROACH :\\nStep 1 : Trim Original String as Asked in question\\nStep 2 : Make a String Array , put words of string in String Array using split method.\\nStep 3 : reverse String Array \\nStep 4 : Return a string of the words in reverse order concatenated by a single space. Convert String Array back to string using Join Operator\\n\\n```\\nclass Solution\\n{\\n    public String reverseWords(String s) \\n    {\\n        \\n        String[] arr = s.trim().split(\"\\\\\\\\s+\");  // \\n      \\n        int len = arr.length;\\n        for(int i=0; i<len/2; i++)  // reverse the order of the words in array\\n        {\\n            String tmp = arr[i];\\n            arr[i] = arr[len-(i+1)];\\n            arr[len-(i+1)] = tmp;\\n        }\\n        \\n        return String.join(\" \", arr);  // convert to string \\n        \\n    }\\n}\\n```\\n\\n// NOTE: for reversing the array herer we can also use Collections.reverse(Arrays.asList(words)) but from interview point of view this is better\\n\\n\\njoin() : The join() method creates and returns a new string by concatenating all of the elements in an array (or an array-like object), separated by commas or a specified separator string. If the array has only one item, then that item will be returned without using the separator.\\n\\ntrim() : The trim() method in Java String is a built-in function that eliminates leading and trailing spaces\\n\\nsplit(\"\\\\\\\\s\")  or split(\" +\")  : It will remove multiple white spaces from string \\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public String reverseWords(String s) \\n    {\\n        \\n        String[] arr = s.trim().split(\"\\\\\\\\s+\");  // \\n      \\n        int len = arr.length;\\n        for(int i=0; i<len/2; i++)  // reverse the order of the words in array\\n        {\\n            String tmp = arr[i];\\n            arr[i] = arr[len-(i+1)];\\n            arr[len-(i+1)] = tmp;\\n        }\\n        \\n        return String.join(\" \", arr);  // convert to string \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610121,
                "title": "java-simple-solution",
                "content": "```\\npublic String reverseWords(String s) {\\n        String ans = \"\";\\n        String[] arr = s.split(\" \");\\n        \\n        for(String str : arr){\\n            if(str.trim().isEmpty()) continue;\\n            ans = str +\" \"+ans;\\n        }\\n        return ans.trim();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\npublic String reverseWords(String s) {\\n        String ans = \"\";\\n        String[] arr = s.split(\" \");\\n        \\n        for(String str : arr){\\n            if(str.trim().isEmpty()) continue;\\n            ans = str +\" \"+ans;\\n        }\\n        return ans.trim();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2418038,
                "title": "c-easy-understandable-o-1-space",
                "content": "**Please Do upvote :)**\\n\\nC++ solution - \\n\\n```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        int i = 0,j = 0;\\n        while(j<s.size()+1)\\n        {\\n            if(s[j] == \\' \\' || j == s.size())\\n            {\\n                reverse(s.begin()+i,s.begin()+j);\\n                i = j+1;\\n            }\\n            j++;\\n        }\\n        // leading and trailing triming\\n        i = 0;\\n        while(s[i] == \\' \\')\\n        {\\n                i++;\\n        }\\n        s.erase(s.begin(),s.begin()+i);\\n        \\n        i = s.size()-1;\\n        while(s[i] == \\' \\')\\n        {\\n            i--;\\n        }\\n        s.erase(s.begin()+i+1,s.end());\\n        //Removing extra spaces in btw\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                int k = i+1;\\n                while(s[k] == \\' \\')\\n                {\\n                    k++;\\n                }\\n                s.erase(s.begin()+i+1,s.begin()+k);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nTime Complexity - O(N) \\nSpace Complexity - O(1)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        int i = 0,j = 0;\\n        while(j<s.size()+1)\\n        {\\n            if(s[j] == \\' \\' || j == s.size())\\n            {\\n                reverse(s.begin()+i,s.begin()+j);\\n                i = j+1;\\n            }\\n            j++;\\n        }\\n        // leading and trailing triming\\n        i = 0;\\n        while(s[i] == \\' \\')\\n        {\\n                i++;\\n        }\\n        s.erase(s.begin(),s.begin()+i);\\n        \\n        i = s.size()-1;\\n        while(s[i] == \\' \\')\\n        {\\n            i--;\\n        }\\n        s.erase(s.begin()+i+1,s.end());\\n        //Removing extra spaces in btw\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] == \\' \\')\\n            {\\n                int k = i+1;\\n                while(s[k] == \\' \\')\\n                {\\n                    k++;\\n                }\\n                s.erase(s.begin()+i+1,s.begin()+k);\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323811,
                "title": "java-stack",
                "content": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n       String[] arr=s.trim().split(\"\\\\\\\\s+\");\\n        StringBuilder sb=new StringBuilder();\\n        Stack<String> st=new Stack<String>();\\n        for(int i=0;i<arr.length;i++){\\n            st.push(arr[i]);\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n            sb.append(\" \");\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseWords(String s) {\\n       String[] arr=s.trim().split(\"\\\\\\\\s+\");\\n        StringBuilder sb=new StringBuilder();\\n        Stack<String> st=new Stack<String>();\\n        for(int i=0;i<arr.length;i++){\\n            st.push(arr[i]);\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n            sb.append(\" \");\\n        }\\n        sb.deleteCharAt(sb.length()-1);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157919,
                "title": "c-easy-to-understand-with-stack",
                "content": "Simple and easy to understand Using **stack of string**.\\n```\\n// We iterate throght the string while there is no white space and,\\nAs we detect a char the we build a string and push it into the stack and destck it and build a new string named ans and return it.\\nclass Solution {\\npublic:\\n    void split(stack<string> &v, string s){\\n        int i=0;\\n        while(i < s.size()){\\n            if(s[i] != \\' \\'){\\n                string t = \"\";\\n                while(i < s.size() && s[i] != \\' \\'){\\n                    t += s[i];\\n                    i++;\\n                }\\n                cout << t << \\' \\';\\n                v.push(t);\\n            }\\n            else\\n                i++;\\n        }\\n    }\\n    \\n    string reverseWords(string s) {\\n        stack<string> v;\\n        split(v, s);\\n        string ans = \"\";\\n        while(v.size() > 1){\\n            ans += v.top() + \\' \\';\\n            v.pop();\\n        }\\n        ans += v.top();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\n// We iterate throght the string while there is no white space and,\\nAs we detect a char the we build a string and push it into the stack and destck it and build a new string named ans and return it.\\nclass Solution {\\npublic:\\n    void split(stack<string> &v, string s){\\n        int i=0;\\n        while(i < s.size()){\\n            if(s[i] != \\' \\'){\\n                string t = \"\";\\n                while(i < s.size() && s[i] != \\' \\'){\\n                    t += s[i];\\n                    i++;\\n                }\\n                cout << t << \\' \\';\\n                v.push(t);\\n            }\\n            else\\n                i++;\\n        }\\n    }\\n    \\n    string reverseWords(string s) {\\n        stack<string> v;\\n        split(v, s);\\n        string ans = \"\";\\n        while(v.size() > 1){\\n            ans += v.top() + \\' \\';\\n            v.pop();\\n        }\\n        ans += v.top();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2154988,
                "title": "java-solution-w-explanation",
                "content": "Here\\'s my Java solution below. Because String in Java is **immutable** so my solution is **not done in-place**. String is immutable in Java because of the concept, String pool. Also, split(\"\\\\s+\") using the idea of the regular expression. It means slicing the string into a string array separated by one or more whitespaces.\\n  Basically I use trim( ) to get rid of the leading and tailing whitespace from the input string, and convert it into the string array by using split(\"\\\\s+\") to get rid of the whitespace existing between the words. Hope it helps !\\n\\n```\\nclass Solution \\n{\\n    public String reverseWords(String s) \\n    {\\n        // O(n) time | O(n) space\\n        String[] strs = s.trim().split(\"\\\\\\\\s+\");\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = strs.length-1; i >= 0; i--)\\n            res.append(strs[i]).append(\" \");\\n\\n        return res.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public String reverseWords(String s) \\n    {\\n        // O(n) time | O(n) space\\n        String[] strs = s.trim().split(\"\\\\\\\\s+\");\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = strs.length-1; i >= 0; i--)\\n            res.append(strs[i]).append(\" \");\\n\\n        return res.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081852,
                "title": "c-string-unique-solution",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    concept: ALGORITHM\\n    1.traverse from end of string\\n    2.ignore white space char\\n    3.store each \"word\" while traversing the string from end\\n    4.Add \"whitespace\" and \"reverse\" the \"word\" and add it our \"ans\" string\\n    5.Don\\'t add \\' \\', if it is the first word\\n    */\\n    string reverseWords(string s) {\\n        int n=s.length();\\n        \\n        string ans=\"\";\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(s[i]==\\' \\') continue;\\n            \\n            else{\\n                string word=\"\";\\n                \\n                while(i>=0 && s[i] != \\' \\'){\\n                    word += s[i];\\n                    i--;\\n                }\\n               \\n                reverse(word.begin(),word.end());\\n                \\n                if(ans.length()==0){\\n                    ans.append(word);\\n                }\\n                \\n                else{\\n                    ans += \" \"; //add space bw two words\\n                    ans.append(word);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote, if this has been any help to you!**",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    concept: ALGORITHM\\n    1.traverse from end of string\\n    2.ignore white space char\\n    3.store each \"word\" while traversing the string from end\\n    4.Add \"whitespace\" and \"reverse\" the \"word\" and add it our \"ans\" string\\n    5.Don\\'t add \\' \\', if it is the first word\\n    */\\n    string reverseWords(string s) {\\n        int n=s.length();\\n        \\n        string ans=\"\";\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(s[i]==\\' \\') continue;\\n            \\n            else{\\n                string word=\"\";\\n                \\n                while(i>=0 && s[i] != \\' \\'){\\n                    word += s[i];\\n                    i--;\\n                }\\n               \\n                reverse(word.begin(),word.end());\\n                \\n                if(ans.length()==0){\\n                    ans.append(word);\\n                }\\n                \\n                else{\\n                    ans += \" \"; //add space bw two words\\n                    ans.append(word);\\n                }\\n                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808083,
                "title": "easy-c-solution-substring",
                "content": "**If you like the solution please upvote it.**\\n\\n\\tstring reverseWords(string s) {\\n        int n = s.length();\\n        int i=0, j;\\n        string res = \"\";\\n        while(i < n) {\\n            while(i<n && s[i]==\\' \\')\\n                i++;\\n            if(i>=n)    break;\\n            j = i+1;\\n            while(j<n && s[j]!=\\' \\')\\n                j++;\\n            string w = s.substr(i, j-i);\\n            if(res.length()==0)\\n                res = w;\\n            else {\\n                res = w+\" \"+res;\\n            }\\n            i = j+1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "**If you like the solution please upvote it.**\\n\\n\\tstring reverseWords(string s) {\\n        int n = s.length();\\n        int i=0, j;\\n        string res = \"\";\\n        while(i < n) {\\n            while(i<n && s[i]==\\' \\')\\n                i++;\\n            if(i>=n)    break;\\n            j = i+1;\\n            while(j<n && s[j]!=\\' \\')\\n                j++;\\n            string w = s.substr(i, j-i);\\n            if(res.length()==0)\\n                res = w;\\n            else {\\n                res = w+\" \"+res;\\n            }\\n            i = j+1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1730659,
                "title": "2-methods-using-java",
                "content": "Method 1: Reverse the words using trim function and StringBuilder:\\n\\n\\tpublic String reverseWords(String s) {\\n        String[] words = s.split(\" \");\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=words.length-1; i>=0; i--) {\\n            if(words[i] != \"\") {\\n                sb.append(words[i].trim() + \" \");\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n\\t\\nMethod 2: In place solution:\\n\\t\\t\\n\\t\\tpublic String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        reverse(c, 0, c.length-1);\\n        int startIndex = 0;\\n        for(int i=0; i<c.length; i++) {\\n            if(c[i] == \\' \\') {\\n                continue;\\n            }\\n            int begin = startIndex;\\n            if(c[i] != \\' \\' && i != 0) {\\n                c[++startIndex] = \\' \\';\\n                begin = ++startIndex;\\n            }\\n            while(i<c.length && c[i] != \\' \\') {\\n                c[startIndex++] = c[i++];\\n            }\\n            startIndex--;\\n            i--;\\n            reverse(c, begin, startIndex);\\n        }\\n        \\n        return new String(c, 0, startIndex+1).trim();\\n    }\\n    \\n    public char[] reverse(char[] c, int begin, int end) {\\n        for(int i=begin, j=end; i<j; i++, j--) {\\n            char temp = c[i];\\n            c[i] = c[j];\\n            c[j] = temp;\\n        }\\n        return c;\\n    }\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "Method 1: Reverse the words using trim function and StringBuilder:\\n\\n\\tpublic String reverseWords(String s) {\\n        String[] words = s.split(\" \");\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=words.length-1; i>=0; i--) {\\n            if(words[i] != \"\") {\\n                sb.append(words[i].trim() + \" \");\\n            }\\n        }\\n        \\n        return sb.toString().trim();\\n    }\\n\\t\\nMethod 2: In place solution:\\n\\t\\t\\n\\t\\tpublic String reverseWords(String s) {\\n        char[] c = s.toCharArray();\\n        reverse(c, 0, c.length-1);\\n        int startIndex = 0;\\n        for(int i=0; i<c.length; i++) {\\n            if(c[i] == \\' \\') {\\n                continue;\\n            }\\n            int begin = startIndex;\\n            if(c[i] != \\' \\' && i != 0) {\\n                c[++startIndex] = \\' \\';\\n                begin = ++startIndex;\\n            }\\n            while(i<c.length && c[i] != \\' \\') {\\n                c[startIndex++] = c[i++];\\n            }\\n            startIndex--;\\n            i--;\\n            reverse(c, begin, startIndex);\\n        }\\n        \\n        return new String(c, 0, startIndex+1).trim();\\n    }\\n    \\n    public char[] reverse(char[] c, int begin, int end) {\\n        for(int i=begin, j=end; i<j; i++, j--) {\\n            char temp = c[i];\\n            c[i] = c[j];\\n            c[j] = temp;\\n        }\\n        return c;\\n    }\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1531309,
                "title": "simple-c-solution-just-with-o-1-extra-space-and-explanation",
                "content": "```\\nvoid reverse(char * s, int start, int end)\\n{\\n    for(int i=start; i<=(start + end)/2; i++)\\n    {\\n        char temp = s[i];\\n        s[i] = s[end-i + start];\\n        s[end-i + start] = temp;\\n    }\\n}\\n\\nchar * reverseWords(char * s){\\n    int start = 0, end = strlen(s) - 1;\\n    while(s[start] == \\' \\' || s[end] == \\' \\') //remove leading and trailing spaces\\n    {\\n        if(s[start] == \\' \\')\\n        {\\n            s += 1*sizeof(char);\\n        }\\n        end = strlen(s) - 1;\\n        if(s[end] == \\' \\')\\n        {\\n            s[end] = 0;\\n            end--;\\n        }\\n    }\\n    int k = 0, j;\\n    for(j=1; j+k<strlen(s); j++) //remove multiples spaces between 2 words\\n    {\\n     \\ts[j]=s[j+k];\\n     \\tif(s[j] == \\' \\' && s[j-1] == \\' \\')\\n     \\t{\\n\\t\\t  k++;\\n\\t\\t  j--;\\n\\t    }\\t\\n    }\\n    s[j] = 0;\\n    reverse(s, 0, strlen(s) - 1); //reverse all s\\n    start = 0; end = 0;\\n    for(int i=0; i<strlen(s); i++) //reverse each word again\\n    {\\n        if(s[i] == \\' \\' || i == strlen(s) - 1)\\n        {\\n            if(i == strlen(s) - 1) \\n                end = i;\\n            else \\n                end = i - 1;\\n            reverse(s, start, end);\\n            start = i + 1;\\n        }\\n    }\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(char * s, int start, int end)\\n{\\n    for(int i=start; i<=(start + end)/2; i++)\\n    {\\n        char temp = s[i];\\n        s[i] = s[end-i + start];\\n        s[end-i + start] = temp;\\n    }\\n}\\n\\nchar * reverseWords(char * s){\\n    int start = 0, end = strlen(s) - 1;\\n    while(s[start] == \\' \\' || s[end] == \\' \\') //remove leading and trailing spaces\\n    {\\n        if(s[start] == \\' \\')\\n        {\\n            s += 1*sizeof(char);\\n        }\\n        end = strlen(s) - 1;\\n        if(s[end] == \\' \\')\\n        {\\n            s[end] = 0;\\n            end--;\\n        }\\n    }\\n    int k = 0, j;\\n    for(j=1; j+k<strlen(s); j++) //remove multiples spaces between 2 words\\n    {\\n     \\ts[j]=s[j+k];\\n     \\tif(s[j] == \\' \\' && s[j-1] == \\' \\')\\n     \\t{\\n\\t\\t  k++;\\n\\t\\t  j--;\\n\\t    }\\t\\n    }\\n    s[j] = 0;\\n    reverse(s, 0, strlen(s) - 1); //reverse all s\\n    start = 0; end = 0;\\n    for(int i=0; i<strlen(s); i++) //reverse each word again\\n    {\\n        if(s[i] == \\' \\' || i == strlen(s) - 1)\\n        {\\n            if(i == strlen(s) - 1) \\n                end = i;\\n            else \\n                end = i - 1;\\n            reverse(s, start, end);\\n            start = i + 1;\\n        }\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1530748,
                "title": "simple-c-o-1-extra-space-with-linear-time-complexity-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void removespace(string &s){    // in O(1) space removed all spaces\\n        int n=s.length();\\n        if(n==0)return ;\\n        \\n        int i=0,j=n-1,k=0;\\n        while(i<n && s[i]==\\' \\'){\\n            i++;\\n        }\\n        while(j>=0 && s[j]==\\' \\'){\\n            j--;\\n        }\\n\\n        for(int t=i;t<=j;t++){\\n            \\n            if(isalnum(s[t])){\\n                s[k++]=s[t];\\n            }\\n            else{\\n                s[k++]=s[t];\\n                while(t+1<=j && s[t+1]==\\' \\'){\\n                    t++;\\n                }\\n            }\\n        }\\n       \\n       s.erase(k,n-k) ;\\n          \\n    }\\n    \\n    void reverse(string &s,int x,int y){\\n        \\n        int i=x,j=y;\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;j--;    \\n        }   \\n    }\\n    \\n    string reverseWords(string s) {\\n        \\n        removespace(s);        //remove extra spaces\\n        \\n        int n=s.length();\\n        int i=0,j=n-1;\\n        \\n        reverse(s,i,j);        //reverse whole string \\n        \\n      \\n        while(i<n){            //now reverse each word of string \\n            \\n            int j=i;\\n            while(j<n && s[j]!=\\' \\'){\\n                j++;\\n            }\\n            reverse(s,i,j-1);\\n            i=j+1;\\n        }\\n        \\n        return s;       //finally return ans O(1) Space. Good luck.\\n     }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void removespace(string &s){    // in O(1) space removed all spaces\\n        int n=s.length();\\n        if(n==0)return ;\\n        \\n        int i=0,j=n-1,k=0;\\n        while(i<n && s[i]==\\' \\'){\\n            i++;\\n        }\\n        while(j>=0 && s[j]==\\' \\'){\\n            j--;\\n        }\\n\\n        for(int t=i;t<=j;t++){\\n            \\n            if(isalnum(s[t])){\\n                s[k++]=s[t];\\n            }\\n            else{\\n                s[k++]=s[t];\\n                while(t+1<=j && s[t+1]==\\' \\'){\\n                    t++;\\n                }\\n            }\\n        }\\n       \\n       s.erase(k,n-k) ;\\n          \\n    }\\n    \\n    void reverse(string &s,int x,int y){\\n        \\n        int i=x,j=y;\\n        while(i<j){\\n            swap(s[i],s[j]);\\n            i++;j--;    \\n        }   \\n    }\\n    \\n    string reverseWords(string s) {\\n        \\n        removespace(s);        //remove extra spaces\\n        \\n        int n=s.length();\\n        int i=0,j=n-1;\\n        \\n        reverse(s,i,j);        //reverse whole string \\n        \\n      \\n        while(i<n){            //now reverse each word of string \\n            \\n            int j=i;\\n            while(j<n && s[j]!=\\' \\'){\\n                j++;\\n            }\\n            reverse(s,i,j-1);\\n            i=j+1;\\n        }\\n        \\n        return s;       //finally return ans O(1) Space. Good luck.\\n     }\\n    \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564876,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1874766,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1575876,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1568982,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1571339,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1570388,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1565526,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1963105,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1567893,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1567894,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1564876,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1874766,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1575876,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1568982,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1571339,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1570388,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1565526,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1963105,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1567893,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1567894,
                "content": [
                    {
                        "username": "harry.freebox@gmail.com",
                        "content": "I got \"Wrong answer\" as:\\nInput:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\"\\n\\nI think for input \" \", the output is supposed to be \" \" when reversing the string, am I missing something here?"
                    },
                    {
                        "username": "shaikhsaif_codx",
                        "content": "Input: s = \"a good   example\"\\nOutput: \"example good a\"\\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
                    },
                    {
                        "username": "Neeleshjha",
                        "content": "Input"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 you have no ignore white spaces"
                    },
                    {
                        "username": "rohithpatel568",
                        "content": "NO leading and trailing spaces*"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Only I read this ???  \"There is at least one word in s.\""
                    },
                    {
                        "username": "Ak_15",
                        "content": "use str.trim() method for removing the extra space bro"
                    },
                    {
                        "username": "DevK2002",
                        "content": "[@Vikas-56](/Vikas-56)  May be it\\'s mean that we shouldn\\'t use more than one spaces at once."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "justenjoythejourneyagain",
                        "content": "You need to return reverse words, but in the above test case, you don\\'t have any words which result in an empty string (rather than a string with a space character)."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You have to reverse all the words and ouput them with a single space between them, your input does\\'nt even have a word so return an empty string\\n"
                    },
                    {
                        "username": "Vikas-56",
                        "content": "you are right but in this problem we have to remove un-neccessary spaces"
                    },
                    {
                        "username": "vlope093",
                        "content": "This question is extremely easy if you use JS. Literally 5 lines of code. It should take no more than 10min. Why is this a medium when I have seen very complex ones as easy??? "
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "[@omeirr13](/omeirr13) You are right, solving it using built in functions does not prove the fact that you know how to solve the problem."
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@animesh21](/animesh21) can you show it"
                    },
                    {
                        "username": "omeirr13",
                        "content": "[@animesh21](/animesh21) are you really satisfied with solving it with a one liner? when clearly they want u to make the logic yourself"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "if its easy just shutup and carry on for some its tough "
                    },
                    {
                        "username": "lazarevzubov",
                        "content": "[@animesh21](/animesh21) Number of lines depends on formatting. IMO, you should count functions, operators, and initialized variables instead."
                    },
                    {
                        "username": "animesh21",
                        "content": "yeah, it is relatively easier. With Python I could do it in just one line."
                    },
                    {
                        "username": "gyanendrarawat200",
                        "content": "Why this Problem has got more number of Dislikes??"
                    },
                    {
                        "username": "bhakti_khokad",
                        "content": "[@algoacer](/algoacer) Your from which college?? your leetcode profile is very good"
                    },
                    {
                        "username": "TwoNoughts",
                        "content": "In C/C++, the extra criteria for removing the extra whitespace is more difficult than the process of word reversal itself, making the added requirement feel arbitrary. Other languages, such as Python and JS, have more robust standard library functions for working with strings which make that process trivial, hence the myopic comments here stating that it\\'s an easy problem."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 doing it using cpp can put you in  little trouble you have to take care of all the corner cases"
                    },
                    {
                        "username": "algoacer",
                        "content": "maybe because those people got rejected with this question in an interview."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "arirarahma",
                        "content": "yeah, there are numerous easy problems that are harder than this for real"
                    },
                    {
                        "username": "mrinal41",
                        "content": "maybe because this question needs to be in the easy section."
                    },
                    {
                        "username": "jedihy",
                        "content": "Python is unable to do in-place string operations and then a naive one line code can solve this problem."
                    },
                    {
                        "username": "MrDLt000",
                        "content": "[@Anshul29](/Anshul29) return \" \".join(s.split()[::-1])"
                    },
                    {
                        "username": "Anshul29",
                        "content": "whats that"
                    },
                    {
                        "username": "roneil_PMH",
                        "content": "I meet a test case whose input is None and expected  is \"a\".\\n\\nHow is this possible?![0_1480802425220_Screen Shot 2016-12-03 at 4.58.28 PM.png](/uploads/files/1480802425962-screen-shot-2016-12-03-at-4.58.28-pm.png) \\n\\n@administrators"
                    },
                    {
                        "username": "SirTarragon",
                        "content": "\\uD83D\\uDE06"
                    },
                    {
                        "username": "_alert",
                        "content": "Java method semantics needs to be changed to make O(1) for space possible from:\\n\\npublic String reverseWords(String s)\\n\\nto\\n\\npublic char[] reverseWords(char[] s) or public void reverseWords(char[] s)\\n\\nStrings in java are immutable so it\\'s technicaly not possible to solve with no extra space."
                    },
                    {
                        "username": "Charliex",
                        "content": "how to post my answer in discussion area?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Either post your answer in the Solutions section or put a link to your answer here. Do not copy any solutions in this section."
                    },
                    {
                        "username": "yashubana789",
                        "content": "Please don\\'t post any solutions in this discussion."
                    },
                    {
                        "username": "oligenious",
                        "content": "copy paste your code and wrap it with ``` before and after it to highlight your it. "
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very simple using java or python"
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@chrisangelov7](/chrisangelov7) you will have to personally add all the words and spaces in the string from the array"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Can you please help me i use  \"return Arrays.toString(sentenceReversed);\" after i have created an array with the reversed sentence but it doesnt take it as an answer cause it gives it like this\"[blue, is, sky, the]\""
                    },
                    {
                        "username": "lccpc10",
                        "content": "When I first working on this question, I just convert it to word array, reverse it, then join them together, it gives me errors for the case '  ' should be '', not '  '. I think the question is not making it clear that you should trim the white spaces.\\nI believe what it actually wants is '   this     is     a     tree   ', should be 'tree a is this', should trim the extra space in between. This should be decalred more clear in the question."
                    },
                    {
                        "username": "hu.cao1",
                        "content": "    Input:\\t\" \"\\n    Output:\\t\" \"\\n    Expected:\\t\"\"\\n\\nThe extra blank space is trimmed. I dont' think that it is correct"
                    }
                ]
            },
            {
                "id": 1984544,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1968636,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1569374,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1571341,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1974444,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1957399,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1872560,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1870739,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1807304,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1575337,
                "content": [
                    {
                        "username": "araguma",
                        "content": "Please let me get this problem in an interview."
                    },
                    {
                        "username": "Limon020",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "RexDrw",
                        "content": "some of the easy one looks medium , medium one looks easy .... did anyone feel like that"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "springathing",
                        "content": "I\\'ve noticed throughout Leetcode there are problems without the \\'Run\\' button to check for compilation errors or to run custom testcases. Why is this the case for some of the problems?"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I haven\\'t encountered any of them can someone specify the problem "
                    },
                    {
                        "username": "abhig7",
                        "content": "\\nWhy my  output is wrong ? :(\\n\\n\\nInput: \" \"\\nOutput: \" \"\\nExpected: \"\""
                    },
                    {
                        "username": "ankit_92110",
                        "content": "Yes ,in the ans we don\\'t need to extra space if its not necesaary\\nhere input:\" \";\\nso first we trim the space  => now input=\"\";\\nnow if we calculate res it become=\"\";"
                    },
                    {
                        "username": "alishabhale",
                        "content": "\n\nIs this approach valid for interview  ?  Please let me know your views and areas of improvement \n\n\n/**\n * @param {string} s\n * @return {string}\n */\n\n  \n var reverseWords = function(s) {\n  // Step 1: Trim leading and trailing whitespace, and remove extra spaces between words\nconst trimmedString = s.trim().replace(/\\s+/g, ' ');\n\n  // Step 2: Split the trimmed string into an array of words\n  const words = trimmedString.split(' ');\n\n  // Step 3: Reverse the order of the words in the array\n  const reversedWords = [];\n  for (let i = words.length - 1; i >= 0; i--) {\n    reversedWords.push(words[i]);\n  }\n\n  // Step 4: Join the reversed words array back into a string\n  const reversedString = reversedWords.join(' ');\n\n  // Step 5: Return the reversed string\n  return reversedString;\n};\n\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": "[@RexDrw](/RexDrw)  Thanks "
                    },
                    {
                        "username": "RexDrw",
                        "content": "sure bro"
                    },
                    {
                        "username": "Nik6174",
                        "content": "Python implementation for this question is really easy. First split sentence into words, now for each word (str), trim (strip) extra spaces from either sides, finally reverse and join the resultant list into a string while using a single space as the joining string. I finished the code in just two lines. "
                    },
                    {
                        "username": "Bhimashankar01",
                        "content": "Hello guy\\'s, When we use String memory beats decreases because it takes extara memory every iteration string take new memory beacuse it is immutable. So we need to use StringBulder it is mutable..."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "This is super easy in languages like js which have `split()` and `join()` functions inbuilt, but harder in languages like C/C++. This is why I think we need to know an alternate language for scenarios like these."
                    },
                    {
                        "username": "psionl0",
                        "content": "It is more instructive to use C even for problems like these."
                    },
                    {
                        "username": "imranansari9835",
                        "content": "Java Eassy:\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] words=s.trim().replaceAll(\" +\",\" \").split(\" \");\\n        StringBuilder reverse=new StringBuilder(\" \");\\n        for(int i=words.length-1;i>=0;i--)\\n        {\\n            reverse.append(words[i]+\" \");\\n        }\\n        return reverse.toString().trim();//\"blue is sky the\"\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "[@rayrogar](/rayrogar) If you rescue for solution, you go to Solutions section.\\nIf you go to Discussions, you see the rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@shevartsoft](/shevartsoft) I think that if anyone comes here for solution is because he/she wants to compare with there own solution, in any other case, she/he is lieying it self"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "416486188",
                        "content": "In place Java solution is not possible as string is immutable in java. Remove this requirement, ot change input to `char[]`. **Covert string to `char[]` manually does not call in-place**"
                    }
                ]
            },
            {
                "id": 1575242,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 1571340,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 1571342,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2074317,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2070580,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2070578,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2065882,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2055847,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2047625,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2045121,
                "content": [
                    {
                        "username": "jessicachen1168",
                        "content": "return \" \".join([i for i in s.split(\" \")[::-1] if i])"
                    },
                    {
                        "username": "qiuping345",
                        "content": "i.e. a test case  \"______________a_________b____\", there're heading and tailing spaces, and multiple spaces between 'a' and 'b'. but the expected result is \"b a\" only one space between them. I've met several question of the same case. sigh...."
                    },
                    {
                        "username": "newjunwei",
                        "content": "Input:\\t\" \"\\nOutput:\\t\" \"\\nExpected:\\t\"\""
                    },
                    {
                        "username": "ermiasmenase",
                        "content": "would\\'ve been easy in js if not for the multiple spaces thing"
                    },
                    {
                        "username": "aleetshef",
                        "content": "c++ solution\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string word=\"\";\\n        string sen = \"\";\\n        int c=0;\\n        for(int i=0;i<=s.length();i++){\\n          if((s[i]==\\' \\' && s[i+1]!=\\' \\' && c!=0 &&s[i+1]!=\\'\\\\0\\')){\\n              sen = \\' \\'+ word + sen ;\\n              word = \"\";          \\n          }\\n          else if(s[i]==\\'\\\\0\\' || (s[i]==\\' \\' && s[i+1]==\\'\\\\0\\')){\\n              sen = word + sen ;\\n              word = \"\";\\n          }\\n          else if(s[i]!=\\' \\'){\\n            word = word+s[i];\\n            c++;\\n          }\\n\\n        }\\n        return sen;\\n    }\\n};"
                    },
                    {
                        "username": "aleetshef",
                        "content": "sen = \\' \\'+ word + sen ;\\n              word = \"\";"
                    },
                    {
                        "username": "Vithesh",
                        "content": "an good example for an annoying problems...."
                    },
                    {
                        "username": "Gokulraj_menon",
                        "content": "Doesnt deserve to be in medium level tbh. Its a lot easy question if you know how to split."
                    },
                    {
                        "username": "robeca07",
                        "content": "is it just me or in C it\\'s really hard?"
                    },
                    {
                        "username": "cd007",
                        "content": "class Solution{\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        int j , k =0;\\n        string temp;\\n        int m = 0;\\n        int x = 0;\\n        while(s[m] == \\' \\')\\n            m++;\\n        for(int i = size - 1; i >= m ; i--)\\n        {\\n            while(s[i]== \\' \\')\\n                i--;\\n            j = i;\\n            while(s[j] != \\' \\')\\n                j--;\\n            for(x = j+1 ; x <= i ; x++)\\n                temp.push_back(s[x]);\\n            temp.push_back(\\' \\');\\n            i = j;\\n        }\\n        temp.pop_back();\\n        return temp;\\n    }\\n};\\n\\n\\n\\nI am getting the below error in above code to reverse words in a string  it is working fine in my compiler\\n\\nLine 1065: Char 9: runtime error: addition of unsigned offset to 0x7ffe839ae1e0 overflowed to 0x7ffe839ae1df (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1074:9"
                    }
                ]
            },
            {
                "id": 2039710,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2030132,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2025950,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2025562,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2020331,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2020178,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2010436,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2009754,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2008749,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 2001757,
                "content": [
                    {
                        "username": "Aditya_kaaltatva",
                        "content": "It has Wrong answer even I tries anythionh"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "55 seconds were spent on this \"medium\" question. Are you kidding me?!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go hug your Ego, bro :)"
                    },
                    {
                        "username": "shegz",
                        "content": "Here is my solution:\\n\"\"\"\\n1. Remove trailing and leading spaces\\n2. split the word - thereby each word is appended to an array\\n3. Reverse the order of the words in the array\\n4. Join the reversed words with a single space in between\\n\"\"\"\\nclass Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip() #remove trailing and leading spaces\\n\\n        #get and append each word to an array\\n        each_word = s.split()\\n        n = len(each_word) - 1\\n\\n        reversed_words = [] \\n\\n        for i in range(n, -1, -1):\\n            reversed_words.append(each_word[i])\\n        \\n        reversed_str = \\' \\'.join(reversed_words)\\n\\n        return reversed_str "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Some people just don\\'t read problem description and come directly to the discussion.\\nWhile some rather than admitting that their English is not so good, blame the description.\\nDon\\'t get me wrong, sometimes the descriptions are really unclear and confusing (and worse - misleading), but for example here I see no problem in the description. It sounds good to me and I know I am not the only one."
                    },
                    {
                        "username": "dianciao_wu",
                        "content": "why this question so many down votes?"
                    },
                    {
                        "username": "LesterX",
                        "content": "Was thinking about O(1) space with Java and couldn\\'t do anything there. Using StringBuilder or converting to array will take O(n) space."
                    },
                    {
                        "username": "tor_es",
                        "content": "weird, but easy problems in leetcode 75 seems to be harder than medium ones (so far) :D"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "How is this medium????"
                    },
                    {
                        "username": "neeldoshii",
                        "content": "Input\\ns =\"EPY2giL\"\\n\\nExpected\\n\"EPY2giL\"\\n\\nCan anyone explain me this? [@Gyanendra Rawat](/gyanendrarawat200) [@Devesh Kumar](/devesh_kumar_kushwaha)"
                    },
                    {
                        "username": "user0283e",
                        "content": "Why this is medium, and other much more complex problems are easy?"
                    }
                ]
            },
            {
                "id": 1993631,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1980657,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1980476,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1975523,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1960661,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1949165,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1945342,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1939813,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1937785,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1935959,
                "content": [
                    {
                        "username": "nazimazhaan17",
                        "content": "but it is not possible in O(1) in java , cuz string in java is immutable  "
                    },
                    {
                        "username": "shivansh5551",
                        "content": "Hey can any one tell we can solve this question with the help of queue?"
                    },
                    {
                        "username": "ishant05",
                        "content": "We cannot use split method,I guess?\\n"
                    },
                    {
                        "username": "alishabhale",
                        "content": " const words = trimmedString.split(\\' \\') like this ?"
                    },
                    {
                        "username": "Anshi_1006",
                        "content": "1. Reverse each word in the string. \\n2. Reverse the entire string.\\n3. Eliminate extra whitespaces."
                    },
                    {
                        "username": "rajveer_09",
                        "content": "I have been trying the reversing approach but it just feels easy to do so, but in reality i had wasted hours and can not solve this question using that approach because the index manipulation and the working of while loops and reverse function is just toooo confusing"
                    },
                    {
                        "username": "noobengineer",
                        "content": "Why can I use the malloc for this problem?\\nI can only use the calloc function.\\nI survey on the internet, and I only know that calloc will make the memory to zero.\\nBut I don\\'t know what the relation for my problem.\\n\\nThe following is my code.\\n `char* ans = calloc(length + 1,sizeof(char));`"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need malloc/calloc if you are programming this in C. You can modify the input string in place."
                    },
                    {
                        "username": "kushang31",
                        "content": "Can anyone resolve runtime error in this code\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string> st;\\n        string k = NULL;\\n        for(int i = 0;i<s.length();i++){\\n            if(s[i]!=\\' \\'){\\n                k  = k + s[i];\\n                continue;\\n            }\\n            st.push(k);\\n            k.clear();\\n        }\\n\\n        string m = NULL;\\n        while(!st.empty()){\\n            m = m+ st.top() + \" \";\\n            st.pop();\\n\\n        }\\n\\n        return m;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "mohdbilal7825",
                        "content": "stack<<string>string>st;"
                    },
                    {
                        "username": "liviii_43",
                        "content": "Using stack in java \\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        Stack<String> ans  =  new Stack<>();\\n    \\n        boolean flag = true;\\n        StringBuilder word = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i) == \\' \\'){\\n                    continue;\\n            }else\\n            {\\n                word.append(s.charAt(i));\\n                if(i==s.length()-1 && s.charAt(i) != \\' \\'){\\n                    ans.push(word.toString());\\n                    continue;\\n                }\\n                if(s.charAt(i+1) == \\' \\'){\\n                    ans.push(word.toString());\\n                    word.setLength(0);\\n                }\\n                \\n            }\\n        }\\n        word.setLength(0);\\n        while(ans.size()!=1){\\n          word.append(ans.pop());\\n          word.append(\\' \\');\\n\\n        }\\n        word.append(ans.pop());\\n       return word.toString(); \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Using rules in Discussions.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rolrios1",
                        "content": "hi everyone, i\\'m using two pointers, but I\\'m having the wrong output, heres my code     `public static String reversedString(String words) {\\n\\n        String[] newWord = words.trim().split(\"\");\\n        \\n        for (int i = 0, j = newWord.length - 1; i <= j; i++, j--) {\\n                String temp = newWord[i];\\n                newWord[i] = newWord[j];\\n                newWord[j] = temp;\\n        }\\n\\n        String reversedString = String.join(\"\", newWord);\\n\\n         return reversedString;\\n    }\\n`\\nthe output it\\'s giving me it\\'s dlroW olleH\\n\\nwhats wrong?"
                    },
                    {
                        "username": "nerdstv",
                        "content": "Use stack to store words and then use top and pop respectively, make sure to check for spaces when you are storing in the stack."
                    }
                ]
            },
            {
                "id": 1931839,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1931837,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1914864,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1912275,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1908786,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1889384,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1833995,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1795516,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786864,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1784493,
                "content": [
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion "
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "could we do this question using recursion?"
                    },
                    {
                        "username": "aaryankakkar",
                        "content": "class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int wordEnd;\\n        string reversedString = \"\";\\n        int k = s.length() - 1;\\n        while(k != -1){\\n            if(s[k] != \\' \\'){\\n                wordEnd = k;\\n                // cout << wordEnd;\\n                int wordLength = 0;\\n                for(int j = k; j > -1; j-- , wordLength++ , k--){\\n                    if(s[j] == \\' \\'){\\n                        wordLength--;\\n                        j = -1;\\n                    }\\n                }\\n                // cout << wordLength;\\n                reversedString = reversedString + s.substr((wordEnd - wordLength) + 1 , wordLength);\\n                reversedString = reversedString + \" \";\\n            }\\n            cout << k << endl;\\n            cout << reversedString << endl;\\n        }\\n        return reversedString;\\n    }\\n};\\n\\nWhy in god\\'s name is this not working? I know the code is redundant at times, I\\'m gonna work on that when it works but, outputting the value of \\'k\\' gives me -1 which is the condition to break the while loop so how does it not break out? Also, I\\'m not that eccentric, I just tried using \\'k\\' cuz \\'i\\' was giving me the same problem and at this point I\\'m ready to try anything including using a \\'while\\' loop instead of a \\'for\\'\\n"
                    },
                    {
                        "username": "abdallahnagy773",
                        "content": "for c# people, you can solve this problem with one line of code using LINQ."
                    },
                    {
                        "username": "Ne0t0N",
                        "content": "Why is this a \"medium\" problem?"
                    },
                    {
                        "username": "Anshu102",
                        "content": " why i am not able to use trim here ????"
                    },
                    {
                        "username": "iammsm",
                        "content": "C++ TWO-POINTER Approach\\n  ```string reverseWords(string s) { //using 2-pointer approach\\n        int n = s.length();\\n        string ans;\\n        int i=n-1;\\n        int j=n-1;\\n        while(i>=0)\\n        {\\n            while(i>=0 && s[i]!=\\' \\')\\n            {\\n                i--;\\n            }\\n            if(ans==\"\"){ //if ans is empty ,insert substring without space\\n                ans += s.substr(i+1, (j-i));\\n            }\\n            else if(ans!=\"\")\\n            {// if ans is non-empty insert substring after a space\\n                ans+=\" \";\\n                ans+= s.substr(i+1,(j-i));\\n            }\\n            while(i>=0 && s[i]==\\' \\')\\n            { \\n                i--;\\n                j=i;\\n            } \\n        }\\n        return ans;```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "I see no question here"
                    },
                    {
                        "username": "shevartsoft",
                        "content": " stupid action - posting the solution here"
                    },
                    {
                        "username": "digga",
                        "content": "Java Simple Solution\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] stringList = s.split(\" \");\\n        StringBuilder strBuilder = new StringBuilder();\\n        for(int i= stringList.length-1;i>=0;i--) {\\n            if(!stringList[i].isEmpty()) {\\n                strBuilder.append(stringList[i]);\\n                strBuilder.append(\" \");\\n            }\\n        }\\n        return strBuilder.toString().substring(0,strBuilder.toString().length()-1);\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "fyang017",
                        "content": "A relatively concise JavaScript solution:\\n\\nvar reverseWords = function(s) {\\n  let str=s.split(\\' \\')\\n  let res=[];\\n  for(let i=0;i<str.length;i++){\\n    if(str[i]!==\\'\\'){\\n      res.push(str[i])\\n    }\\n  }\\n  return res.reverse().join(\\' \\');\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "malstuti3",
                        "content": "why my code is giving empty character constant error . i checked the solution we can access the spaces by this method.\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n        string result=\"\";\\n        int n =s.length();\\n        int i=0;\\n        while(i<n){\\n           \\n            while(i<n&&s[i]==\\'\\'){\\n                i++;\\n            }\\n            if(i>=n)break;\\n            int j =i+1;\\n            while(j<n&&s[j]!=\\'\\'){\\n                j++;\\n            }\\n            string word=s.substr(i,j-i);\\n            if(result.length()==0){\\n                result=word;\\n            }\\n            else{\\n                result=word+\" \"+result;\\n            }\\n            i=j+1;\\n        }\\nreturn result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1777709,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1736022,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1735013,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1711919,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1708826,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1703499,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1702863,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1689207,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1688227,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1683066,
                "content": [
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public String reverseWords(String s) {\\n        s=s.trim().replaceAll(\" +\", \" \");\\n        String[] x=s.split(\" \");\\n        String z=\"\";\\n        for(int i=x.length-1;i>=0;i--){\\n            if(x[i].contains(\"  \")) {\\n                i++;\\n            }\\n            z=z.concat(x[i]);\\n            if(i!=0) {\\n z=z.concat(\" \");\\n            }\\n        }\\n        return z;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "inavars",
                        "content": "address sanitizer"
                    },
                    {
                        "username": "23shukla",
                        "content": "Without inbuild || java \\nclass Solution {\\n    public String reverseWords(String s) {\\n        \\n        int i = s.length() -1 ;\\n        String shukla = \"\";\\n        while(i >= 0){\\n\\n            // first remoove the  whitspace from the last of the given string \\n            while(i >=0 && s.charAt(i)== \\' \\'){\\n                i--;\\n            }\\n            // Apply the condition to check whether the string end or not end \\n            if(i< 0) {\\n                break ;\\n            }\\n            // Store the last index in some other variable \\n            int j = i ;\\n            while(i >=0 && s.charAt(i) != \\' \\'){\\n               i-- ;\\n            }\\n\\n            if(shukla.length() == 0){\\n                shukla = shukla.concat(s.substring(i+1 , j+1));\\n            }else{\\n                shukla = shukla.concat(\\' \\' + s.substring(i +1 , j+ 1));\\n            }\\n\\n        }\\n        return shukla ;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "singhdiv044",
                        "content": " def reverseWords(self, s: str) -> str:\\n        list1= s.replace(\" \", \"-\").split(\"-\")[::-1]\\n        str1 = \"\"\\n        for item in list1:\\n            str1=str1+\\' \\'+item\\n        str2 = str1.strip(\" \")\\n        return str2\\n\\n\\nwhy the code is not correct"
                    },
                    {
                        "username": "shinebayar999",
                        "content": "Using only one pointer is possible.\\n**Idea** is building string **tmp = s[r] + tmp** that way.\\nSolution link: https://leetcode.com/problems/reverse-words-in-a-string/solutions/2887928/intiutive-way-using-only-one-pointer-in-javascript/"
                    },
                    {
                        "username": "classicpaul",
                        "content": "return \\' \\'.join([i for i in s.split()[::-1]])"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\nhttps://leetcode.com/problems/reverse-words-in-a-string/solutions/2869290/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "KARTIK_2002",
                        "content": "NOT working can anyone tell why?\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n       int i=0;\\n       int n=s.length();\\n       string res;\\n\\n       while(i<n){\\n       while(i<n && s[i]==\\' \\') \\n       i++;\\n\\n      \\n       \\n       int j=i+1;\\n\\n        while(j<n && s[j]!=\\' \\') \\n        j++;\\n       \\n       string sub=s.substr(i, j-1);\\n\\n       if(res.length()==0) \\n       res=sub;\\n\\n       else\\n        res=sub + \" \" + res;\\n\\n       i=j+1;\\n       }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "_Kunal_10",
                        "content": "For this code, I am getting same output as the expected output. But still it is giving me wrong answer.. Can somebody please help me figure out the error in this code.\\n\\n\\nclass Solution {\\npublic:\\n\\n    string reverseWords(string s) {\\n        int n= s.size();\\n        string ans = \"\";\\n        int j=n-1;\\n\\n        while(s[n-1]==\\' \\'){\\n            s.erase(s.end()-1,s.end());\\n            n= s.size();\\n        }\\n\\n        while(s[0]== \\' \\'){\\n            s.erase(s.begin(),s.begin()+1);\\n        }\\n\\n\\n        for(int i=n-1; i>=0; i--){\\n            \\n            if(isspace(s[i]) && isspace(s[i-1])){\\n                s.erase(s.begin()+i, s.begin()+i+1);\\n            }\\n\\n            else if(isspace(s[i])){\\n                for(int a=i+1; a<=j; a++){\\n                    ans.push_back(s[a]);\\n                }\\n                ans.append(\" \");\\n                j=i-1;\\n            }\\n\\n            \\n        }\\n\\n        for(int i=0; i<=j ; i++){\\n            ans.push_back(s[i]);\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harshitparashar",
                        "content": "Those who are asking why this is the expected output :\\n `Input: \" \"\\nOutput: \" \"\\nExpected: \"\"`\\n\\nA word is defined as a sequence of non-space characters.Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words.\\n\\nRead this line properly, there shouldn\\'t be any leading or trailing spaces.\\n"
                    }
                ]
            },
            {
                "id": 1683028,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682877,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682874,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682870,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682671,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682666,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682650,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682526,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682473,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1682017,
                "content": [
                    {
                        "username": "vaibhav_cpp",
                        "content": "Brute force simple approach :-> {C++}\\n\\n1. first remove all the leading spaces from the original string using -> \\nauto pos = s.find_first_not_of(\\' \\');\\n        auto Trimmed = s.substr(pos != std::string::npos ? pos : 0);\\n        s=Trimmed;\\n\\n2. then solve the basic question using stack \\n3. Add a condition in the main loop \\nif(st.empty()){\\n                    continue;\\n                }\\n::Ping me if any doubt on twitter -> twt_vaibhav\\n\\n"
                    },
                    {
                        "username": "kumadhir",
                        "content": "class Solution(object):\\n    def reverseWords(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        s = s.strip().split()[::-1]\\n        new_str = \\'\\'\\n        for i in s:\\n            new_str = new_str+i+\\' \\'\\n            \\n        return new_str.rstrip()"
                    },
                    {
                        "username": "raphiquemcmaster",
                        "content": "i have the correct answer printed but how do i get it in the output"
                    },
                    {
                        "username": "Leonardo-Lima-Pontes",
                        "content": "A readable aproach"
                    },
                    {
                        "username": "oligenious",
                        "content": "Complexity in Java Code:\\nDoes any of these \"Options\" I commented in my code when joining String have a better or worse time complexity or are they about the same?\\n\\n``` \\nclass Solution {\\n    public String reverseWords(String s) {\\n        List<String> wordList = Arrays.asList(s.trim().split(\" +\"));\\n        Collections.reverse(wordList);\\n\\n        // return String.join(\" \", wordList);  Option #1\\n\\n        // return wordList.stream().collect(Collectors.joining(\" \")); Option #2\\n\\n        return join(\" \", wordList); // Option #3\\n    }\\n\\nprivate static String join(String separator, List<String> input) {\\n        if (input == null || input.size() <= 0) return \"\";\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < input.size(); i++) {\\n            sb.append(input.get(i));\\n            if (i != input.size() - 1) {\\n                sb.append(separator);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "prathambhatiapersonal",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def reverseWords(self, s: str) -> str:\\n        rev_String=s.split()[::-1]\\n        return \" \".join(rev_String)\\n    print(reverseWords)"
                    },
                    {
                        "username": "deva01",
                        "content": "why can\\'t I use StringTokenizer here??\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "a lot of stack questions in these daily challenges lately!"
                    },
                    {
                        "username": "xqcow",
                        "content": "for java, the regex involves `s.split(\"\\\\\\\\s+\")` so i see the `\\\\s` is any whitespace character, and `+` means 1 or more. is the first `\\\\` saying to \"escape\" the characters following it? what are other useful regex to know? thanks!"
                    },
                    {
                        "username": "himanshu_210",
                        "content": "Why this Problem has got more number of Dislikes ?"
                    },
                    {
                        "username": "xqcow",
                        "content": "i\\'m guessing if you know the trick it\\'s easy"
                    }
                ]
            },
            {
                "id": 1681983,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1681685,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1680190,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1679880,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1679858,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1663668,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1653967,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1653966,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1633403,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            },
            {
                "id": 1910922,
                "content": [
                    {
                        "username": "Vikas-56",
                        "content": "// simplest  C++ Solution with comments\\nstring reverseWords(string s) {\\n        reverse(s.begin(),s.end());\\n        string ans=\"\",temp=\"\";\\n        for(int i=0;i<s.size();i++){\\n             if(s[i]!=\\' \\'){\\n              temp +=s[i];\\n             }\\n             else{\\n                   if(temp!=\"\"){   // first we have to check temp is non empty\\n                   reverse(temp.begin(),temp.end());\\n                   if(ans==\"\")  // if  starting ans is empty then add without space\\n                   ans +=temp;\\n                   else         // else we add with space\\n                   ans =ans+\\' \\'+temp;;\\n               }\\n               temp=\"\";\\n             }\\n        }\\n        if(temp!=\"\"){\\n             reverse(temp.begin(),temp.end());\\n            if(ans==\"\")\\n            ans +=temp;\\n            else\\n            ans +=\\' \\'+temp;\\n        }\\n               return ans;"
                    },
                    {
                        "username": "chaudhm3",
                        "content": "\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDD8\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDE06 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDF2\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\u2028\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/2dI5G9zmYOo?t=359"
                    },
                    {
                        "username": "psparamjeet21",
                        "content": " String result = \"\";\\n\\t\\tString[] str = s.split(\" \");\\n\\t\\tfor (int i = str.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (!(str[i].trim().isEmpty())) {\\n\\t\\t\\t\\tresult = result.concat(str[i] + \" \");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result.trim();"
                    },
                    {
                        "username": "tigerashwani",
                        "content": "there should a test case if s=\"the  \";\\nthis is self generated test case and its giving me error (even I didn\\'t understand ) but when a submitted the code it accepted easily . `your inline code...your inline code...` `your inline code...your inline code...`class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        stack<string>st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(i==s.size()-1){\\n                res+=s[i]; \\n                 st.push(res);\\n                 break;\\n            }\\n            if(s[i]!=\\' \\' ){\\n                res+=s[i]; \\n            }\\n            else{\\n                if(res.size()>0)\\n                st.push(res);\\n                res=\"\";\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            if(st.top()!=\" \")\\n            ans+=st.top()+\" \";\\n            st.pop();\\n        }\\n        ans.erase(ans.size()-1);\\n        \\n        return ans;\\n    } \\n};\\n//if any one have idea about this pls comment "
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Why is my code not working for the second testcase??\\ninput: \"  hello world  \"\\nmy output is : \"world hello \" \\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String reverseWords(String s) {\\n\\n       s.trim();\\n       String rev=\"\";\\n       String word[]=s.split(\"\\\\\\\\s+\");\\n       \\n       \\n        for(int i=word.length-1 ; i>0 ;i--)\\n        {\\n            rev=rev  + word[i] +\" \"  ;\\n        }\\n\\n        rev=rev+word[0];\\n        \\n        return rev;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "You have 1 blank in the tail of your output. (after \\'hello\\' word)\\nIf you delete the blank, your solution will work."
                    },
                    {
                        "username": "utkarshjain",
                        "content": "Python 5 line solution | beats 99% \\n `class Solution:\\n    def reverseWords(self, s: str) -> str:\\n        l= s.split()\\n        n= len(l)\\n        for i in range(n//2):\\n            l[i],l[n-i-1] = l[n-i-1],l[i]\\n        return \\' \\'.join(l)`"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "please help me i am very close to my ans"
                    },
                    {
                        "username": "sunnysrivastava258",
                        "content": "v+=res[res.size()-1];\\n                return v;"
                    },
                    {
                        "username": "rahulIsLeet",
                        "content": "#OneLinerJsSolution\n#javascript\n#oneliner\n\n(  [ ]+ ) ==> regex to split for any number of whitespaces \nvar reverseWords = function(s) {\n    return s.trim().split(/[ ]+/).reverse().join(\" \")\n};"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "public String reverseWords(String s) {\\n        String[] data = s.split(\"\\\\\\\\s+\");\\n        String res= \"\";\\n        for(int i=data.length-1;i>=0;--i){\\n            if(data[i].length()!=0){\\n                res+=data[i]+\" \";\\n            }\\n        }\\n        return res.substring(0,res.length()-1);\\n    }"
                    }
                ]
            }
        ]
    }
]