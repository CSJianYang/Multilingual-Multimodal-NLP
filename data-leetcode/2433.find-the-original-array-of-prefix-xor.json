[
    {
        "title": "Find The Original Array of Prefix Xor",
        "question_content": "You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n\tpref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\nIt can be proven that the answer is unique.\n&nbsp;\nExample 1:\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\nExample 2:\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n&nbsp;\nConstraints:\n\n\t1 <= pref.length <= 105\n\t0 <= pref[i] <= 106",
        "solutions": [
            {
                "id": 2678904,
                "title": "java-c-python-easy-and-concise-with-explantion",
                "content": "# **Intuition**\\nDo this first:\\nGiven `pref`, find `arr` that\\n`pref[i] = arr[0] + arr[1] + ... + arr[i]`\\n`pref` is prefix sum of `arr`\\n\\nThe solution is simple:\\n```cpp\\nfor(int i = A.size() - 1; i > 0; --i)\\n    A[i] -= A[i - 1];\\nreturn A;\\n```\\n\\nNow we are doing something similar for this problem.\\n<br>\\n\\n# **Explanation**\\nSince `pref` is the prefix array,\\nit\\'s calculated from `arr` one by one,\\nwe can doing this process reverssely to recover the original array.\\n\\nSince\\n`pref[i] = pref[i-1] ^ A[i]`\\nso we have\\n`pref[i] ^ pref[i-1] = A[i]`\\n\\nSo we simply change `-` to `^` in the intuition solution\\n\\nThe reverse operation of `+` is `-`\\nThe reverse operation of `^` is still `^`\\nMore general, we can apply this solution to prefix of any operation.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int[] findArray(int[] A) {\\n        for (int i = A.length - 1; i > 0; --i)\\n            A[i] ^= A[i - 1];\\n        return A;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> findArray(vector<int>& A) {\\n        for (int i = A.size() - 1; i > 0; --i)\\n            A[i] ^= A[i - 1];\\n        return A;\\n    }\\n```\\n**Python**\\n```py\\n    def findArray(self, A):\\n        for i in range(len(A) - 1, 0, -1):\\n            A[i] ^= A[i - 1]\\n        return A\\n```\\n**Pythonic2**\\n```py\\n    def findArray(self, A):\\n        return map(xor, A, [0] + A[:-1])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nfor(int i = A.size() - 1; i > 0; --i)\\n    A[i] -= A[i - 1];\\nreturn A;\\n```\n```java\\n    public int[] findArray(int[] A) {\\n        for (int i = A.length - 1; i > 0; --i)\\n            A[i] ^= A[i - 1];\\n        return A;\\n    }\\n```\n```cpp\\n    vector<int> findArray(vector<int>& A) {\\n        for (int i = A.size() - 1; i > 0; --i)\\n            A[i] ^= A[i - 1];\\n        return A;\\n    }\\n```\n```py\\n    def findArray(self, A):\\n        for i in range(len(A) - 1, 0, -1):\\n            A[i] ^= A[i - 1]\\n        return A\\n```\n```py\\n    def findArray(self, A):\\n        return map(xor, A, [0] + A[:-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2679377,
                "title": "python3-if-c-a-b-then-b-c-a-beginner-friendly",
                "content": "The key to this problem is to know the reverse XOR!\\nif `c = a^b` then `a = c^b` and `b = c^a`\\nThen we can go through the `pref`, keep the XOR of all elements in `res` so far, and compute the next element in `res`, append it to `res`.\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        last = pref[0]\\n        res = [last] ### the first element in the result is the same as pref\\n        for n in pref[1:]:\\n            cur = n^last ### compute the current element in result\\n            res.append(cur) \\n            last ^= cur ### update the XOR of all elements in result so far\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        last = pref[0]\\n        res = [last] ### the first element in the result is the same as pref\\n        for n in pref[1:]:\\n            cur = n^last ### compute the current element in result\\n            res.append(cur) \\n            last ^= cur ### update the XOR of all elements in result so far\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678847,
                "title": "reverse-xor",
                "content": "\\n**C++**\\n```cpp\\nvector<int> findArray(vector<int>& pref) {\\n    for (int i = 0, prev = 0; i < pref.size(); ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0pref[i] ^= prev;\\n \\xA0 \\xA0 \\xA0 \\xA0prev ^= pref[i];\\n    }    \\n    return pref;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> findArray(vector<int>& pref) {\\n    for (int i = 0, prev = 0; i < pref.size(); ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0pref[i] ^= prev;\\n \\xA0 \\xA0 \\xA0 \\xA0prev ^= pref[i];\\n    }    \\n    return pref;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678785,
                "title": "c-simple-approach",
                "content": "***Please upvote if it helps :)***\\n\\n**Logic:**\\nif c = a^b then a = b^c\\nso, ans[i] = ans[0]^ans[1]^...^ans[i-1]^pref[i]\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        int n = pref.size();\\n        int pre_xor=0;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            pre_xor ^= pref[i-1];\\n            pref[i] = pre_xor^pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        int n = pref.size();\\n        int pre_xor=0;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            pre_xor ^= pref[i-1];\\n            pref[i] = pre_xor^pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679959,
                "title": "xor-is-self-inverting-associative-commutative",
                "content": "##### Java\\n```java\\npublic int[] findArray(int[] pref) {\\n        int[] result = new int[pref.length];\\n        result[0] = pref[0];\\n        for (int i = 1; i < pref.length; ++i) {\\n            result[i] = pref[i] ^ pref[i - 1];\\n        }\\n        \\n        return result;\\n    }\\n```\\n\\n##### C++\\n```cpp\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> result(pref.size());\\n        result[0] = pref[0];\\n        for (int i = 1; i < pref.size(); ++i) {\\n            result[i] = pref[i] ^ pref[i - 1];\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int[] findArray(int[] pref) {\\n        int[] result = new int[pref.length];\\n        result[0] = pref[0];\\n        for (int i = 1; i < pref.length; ++i) {\\n            result[i] = pref[i] ^ pref[i - 1];\\n        }\\n        \\n        return result;\\n    }\\n```\n```cpp\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> result(pref.size());\\n        result[0] = pref[0];\\n        for (int i = 1; i < pref.size(); ++i) {\\n            result[i] = pref[i] ^ pref[i - 1];\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662134,
                "title": "python3-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        if len(pref)==1:\\n            return pref\\n        ans=[pref[0]]\\n        for i in range(len(pref)-1):\\n            ans.append(pref[i]^pref[i+1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        if len(pref)==1:\\n            return pref\\n        ans=[pref[0]]\\n        for i in range(len(pref)-1):\\n            ans.append(pref[i]^pref[i+1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679107,
                "title": "original-array-profix-xor-explanation",
                "content": "Hi,\\n\\nUnderstanding my solution is as follows:\\n\\n**pref[i] = pref[i-1] ^ res[i];**\\n\\nso we have to find the value of \\'res[i]\\', so we move the xor operation to the other side:\\n\\n**res[i] = pref[i] ^ pref[i-1];**\\n\\nWhen i=0 the xor res value will be same as given array.\\n\\nHappy learning, kindly upvote if helps:\\n\\n```\\n    public int[] findArray(int[] pref) {\\n        int res[] = new int[pref.length];\\n        res[0]=pref[0];\\n        for(int i=1; i<pref.length; i++){\\n        \\tres[i]=pref[i]^pref[i-1];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nUnderstanding my solution is as follows:\\n\\n**pref[i] = pref[i-1] ^ res[i];**\\n\\nso we have to find the value of \\'res[i]\\', so we move the xor operation to the other side:\\n\\n**res[i] = pref[i] ^ pref[i-1];**\\n\\nWhen i=0 the xor res value will be same as given array.\\n\\nHappy learning, kindly upvote if helps:\\n\\n```\\n    public int[] findArray(int[] pref) {\\n        int res[] = new int[pref.length];\\n        res[0]=pref[0];\\n        for(int i=1; i<pref.length; i++){\\n        \\tres[i]=pref[i]^pref[i-1];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2681242,
                "title": "prefix-xor",
                "content": "# Intuition\\nTo compute the current element we need the prefix `xor` of previous elements.\\n`orig[i] = prefix[i - 1] xor prefix[i]`\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe maintian a variable `x` which is the prefix xor of all the elements before it.\\n\\nAfter the operation the resultant array will be the original array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int x = pref[0], n = pref.size();\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = x ^ pref[i];\\n            x ^= pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int x = pref[0], n = pref.size();\\n        for(int i = 1; i < n; i++) {\\n            pref[i] = x ^ pref[i];\\n            x ^= pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678959,
                "title": "c-simple-approach-5-lines-of-code-explained",
                "content": "Idea : If you see test cases resultant array is just xor of pref[i] and pref[i-1] \\nAlso remember XOR operator follows associativity \\n\\npush_back(pref[0]);\\nthen res[i] is xor of all elements upto ith element\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> res;  // this will be our result array\\n        res.push_back(pref[0]);\\n        \\n        for(int i=1;i<pref.size();i++){\\n            res.push_back(pref[i] xor pref[i-1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> res;  // this will be our result array\\n        res.push_back(pref[0]);\\n        \\n        for(int i=1;i<pref.size();i++){\\n            res.push_back(pref[i] xor pref[i-1]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291167,
                "title": "java-1-liner-code-100-faster-2-approach-explained",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS**\\n\\n# Code\\n```\\nFirst Approach:\\n\\nTime complexity : O(N);\\nSpace complexity: O(N);\\n\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] res = new int[pref.length];\\n        for (int i = 0, j = 1; i < pref.length - 1; i++, j++) {\\n            int storeValue = pref[j];\\n            res[j] = pref[i] ^ pref[j];\\n        }\\n        res[0] = pref[0];\\n        return res;\\n    }\\n}\\n```\\n```\\nSecond Approach:\\n\\nTime complexity : O(N);\\nSpace complexity: O(1);\\n\\npublic static int[] findArray(int[] pref) {\\n        for(int i = pref.length - 1; i > 0; i--) pref[i] = pref[i] ^ pref[i-1];\\n        return pref;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFirst Approach:\\n\\nTime complexity : O(N);\\nSpace complexity: O(N);\\n\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] res = new int[pref.length];\\n        for (int i = 0, j = 1; i < pref.length - 1; i++, j++) {\\n            int storeValue = pref[j];\\n            res[j] = pref[i] ^ pref[j];\\n        }\\n        res[0] = pref[0];\\n        return res;\\n    }\\n}\\n```\n```\\nSecond Approach:\\n\\nTime complexity : O(N);\\nSpace complexity: O(1);\\n\\npublic static int[] findArray(int[] pref) {\\n        for(int i = pref.length - 1; i > 0; i--) pref[i] = pref[i] ^ pref[i-1];\\n        return pref;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699599,
                "title": "python-c-java-faster-than-100-simple-short-solution-easy-to-understand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2433. Find The Original Array of Prefix Xor***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        for i in range(len(pref)-1,0,-1):\\n            pref[i]^=pref[i-1]\\n        return pref\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        for(int i=pref.length-1;i>0;--i)\\n            pref[i]^=pref[i-1];\\n        return pref;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for(int i=pref.size()-1;i>0;--i)\\n            pref[i]^=pref[i-1];\\n        return pref;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        for i in range(len(pref)-1,0,-1):\\n            pref[i]^=pref[i-1]\\n        return pref\\n```\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        for(int i=pref.length-1;i>0;--i)\\n            pref[i]^=pref[i-1];\\n        return pref;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for(int i=pref.size()-1;i>0;--i)\\n            pref[i]^=pref[i-1];\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682328,
                "title": "c-in-place-re-write-from-the-back-fast-100-98ms",
                "content": "### Approach 1:  in-place re-write from the back\\n\\n$$pref[i] = arr[0] \\\\oplus arr[1] \\\\oplus \\\\ldots \\\\oplus arr[i]$$ and if we xor this with $$pref[i - 1] = arr[0] \\\\oplus arr[1] \\\\oplus \\\\ldots \\\\oplus arr[i - 1]$$ we get $$arr[i]$$, and in the end $$arr[0] = pref[0]$$ already.\\n\\n```cpp\\n    static vector<int> findArray(vector<int>& pref) {\\n        for (int i = size(pref) - 1; i > 0; --i) {\\n            pref[i] ^= pref[i - 1];\\n        }\\n        return pref;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$, where $$n$$ is ```size(pref)```.\\n  * Space complexity: $$O(1)$$ as we are not generating a new output vector.\\n\\n### Approach 2: std::adjacent_difference\\n\\nThis is based on a [post](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/discuss/2682613/1-liner) by @andrii_khlevniuk, which is a great use of ```std::adjacent_difference```.\\n\\n```cpp\\n    static vector<int> findArray(vector<int>& pref) {\\n        adjacent_difference(begin(pref), end(pref), begin(pref), bit_xor());\\n        return pref;\\n    }\\n```\\n\\nThe complexity is the same as above.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static vector<int> findArray(vector<int>& pref) {\\n        for (int i = size(pref) - 1; i > 0; --i) {\\n            pref[i] ^= pref[i - 1];\\n        }\\n        return pref;\\n    }\\n```\n```size(pref)```\n```std::adjacent_difference```\n```cpp\\n    static vector<int> findArray(vector<int>& pref) {\\n        adjacent_difference(begin(pref), end(pref), begin(pref), bit_xor());\\n        return pref;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678949,
                "title": "one-for-loop-that-s-it-o-n-solution",
                "content": "**Idea ::**\\n\\nXor property::\\n\\nb = a^c => a=b^c;\\n\\nSince pref[i] = pref[i-1]^array[i] ,\\ntherefore, array[i] = pref[i]^pre[i-1] \\n\\nwhere array[i] is ith element in desired array\\n\\n\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        for(int i=pref.size()-1;i>=1;i--)\\n            pref[i]=pref[i]^pref[i-1];\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        for(int i=pref.size()-1;i>=1;i--)\\n            pref[i]=pref[i]^pref[i-1];\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656362,
                "title": "time-o-n-space-o-1-c-prefix-xor-most-optimized",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int x = pref[0],y;\\n        for(int i = 1; i < pref.size(); i++){\\n            y = pref[i];\\n            pref[i] = (pref[i]^x);\\n            x = y;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int x = pref[0],y;\\n        for(int i = 1; i < pref.size(); i++){\\n            y = pref[i];\\n            pref[i] = (pref[i]^x);\\n            x = y;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687190,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int xor = pref[0];\\n        for(int i=1; i<pref.length; i++){\\n            pref[i] ^= xor;\\n            xor ^= pref[i];\\n        }\\n        return pref;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar findArray = function(pref) {\\n    let xor = pref[0];\\n    for(let i=1; i<pref.length; i++){\\n        pref[i] ^= xor;\\n        xor ^= pref[i];\\n    }\\n    return pref;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        xor = pref[0]\\n        for i in range(1,len(pref)):\\n            pref[i] ^= xor\\n            xor ^= pref[i]\\n        return pref\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int xor = pref[0];\\n        for(int i=1; i<pref.length; i++){\\n            pref[i] ^= xor;\\n            xor ^= pref[i];\\n        }\\n        return pref;\\n    }\\n}\\n```\n```\\nvar findArray = function(pref) {\\n    let xor = pref[0];\\n    for(let i=1; i<pref.length; i++){\\n        pref[i] ^= xor;\\n        xor ^= pref[i];\\n    }\\n    return pref;\\n};\\n```\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        xor = pref[0]\\n        for i in range(1,len(pref)):\\n            pref[i] ^= xor\\n            xor ^= pref[i]\\n        return pref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679089,
                "title": "python-explained-o-n",
                "content": "# Intuition \\n- If we focus on a pattern :\\n- `a = 5 [0 1 0]`\\n- `b = 7 [1 1 1]`\\n- `c = a^b -> 2 [0 1 0]`\\n- `c^a = 7 -> [1 1 1] = b`\\n\\n- so for every pair of digits we are already given `a` and `c` we just have to find `b`, that we can easily calculate with the aforementioned method.\\n\\n- It is just similar to we are given `a = 5`, `b = 7` and `c = a+b`  and we have to find the value of `c`.\\n- So `c = a+b` that is `c = 12.`\\n\\n# Approach\\n- here we need to calculate prefix xor repeatedly so we can use a variable `XOR` to save time.\\n- We will iterate through the array and we already have prefix xor in our `XOR` varible so `ans[i] = array[i]^XOR`.\\n- then we will update `XOR` to `XOR = XOR^ans[i]`.\\n\\n- Here `a = arra[i]`, `b = XOR`, `c = a^b` and we have to find the value of `c` that is `ans[i]`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        xor = 0\\n        ans = []\\n        for i in range(len(pref)):\\n            ans.append(pref[i]^xor)\\n            xor ^= ans[i]\\n        return ans\\n```\\n------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        xor = 0\\n        ans = []\\n        for i in range(len(pref)):\\n            ans.append(pref[i]^xor)\\n            xor ^= ans[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678930,
                "title": "c-simple-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        \\n        vector<int> cnt;\\n        \\n        cnt.push_back(pref[0]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            \\n            cnt.push_back(pref[i]^pref[i+1]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        \\n        vector<int> cnt;\\n        \\n        cnt.push_back(pref[0]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            \\n            cnt.push_back(pref[i]^pref[i+1]);\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678879,
                "title": "kotlin-opposite-of-xor-is-xor-easy",
                "content": "```\\nfun findArray(pref: IntArray): IntArray {\\n\\tvar curr = pref[0]\\n\\tvar result = mutableListOf(curr)\\n\\tfor (i in 1 until pref.size) {\\n\\t\\tval new = curr xor pref[i]\\n\\t\\tresult.add(new)\\n\\t\\tcurr = curr xor (new)\\n\\t}\\n\\treturn result.toIntArray()\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun findArray(pref: IntArray): IntArray {\\n\\tvar curr = pref[0]\\n\\tvar result = mutableListOf(curr)\\n\\tfor (i in 1 until pref.size) {\\n\\t\\tval new = curr xor pref[i]\\n\\t\\tresult.add(new)\\n\\t\\tcurr = curr xor (new)\\n\\t}\\n\\treturn result.toIntArray()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678828,
                "title": "c-simple-4-line-o-n-o-1",
                "content": "```\\nvector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        \\n        vector<int> arr(n);\\n        arr[0] = pref[0];\\n        \\n        for( int i=1 ; i<pref.size() ; i++ ){\\n            \\n            arr[i] = pref[i-1]^pref[i] ;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        \\n        vector<int> arr(n);\\n        arr[0] = pref[0];\\n        \\n        for( int i=1 ; i<pref.size() ; i++ ){\\n            \\n            arr[i] = pref[i-1]^pref[i] ;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685511,
                "title": "2-easy-c-solution-beginner-and-advanced-approach-beats-90",
                "content": "From the \\n\\n# Code\\n```\\n// Beginner approach\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int ans = 0;\\n        vector<int> a;\\n        for(int i=0; i<pref.size(); i++){\\n            a.push_back(ans^pref[i]);\\n            ans=pref[i];\\n        }\\n        return a;\\n    }\\n};\\n\\n// Better approach (Not that advanced tbh)\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for(int i=pref.size()-1; i>0; i--){\\n            pref[i]^=pref[i-1];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Beginner approach\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int ans = 0;\\n        vector<int> a;\\n        for(int i=0; i<pref.size(); i++){\\n            a.push_back(ans^pref[i]);\\n            ans=pref[i];\\n        }\\n        return a;\\n    }\\n};\\n\\n// Better approach (Not that advanced tbh)\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for(int i=pref.size()-1; i>0; i--){\\n            pref[i]^=pref[i-1];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351292,
                "title": "one-pass-easy-to-understand-short-sweet-c",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int a = pref[0],b=pref[0];\\n        for(int i = 1; i < pref.size(); i++){\\n            a = pref[i];\\n            pref[i] = (pref[i]^b);\\n            b = a;\\n        }\\n        return pref;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int a = pref[0],b=pref[0];\\n        for(int i = 1; i < pref.size(); i++){\\n            a = pref[i];\\n            pref[i] = (pref[i]^b);\\n            b = a;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814312,
                "title": "java-2-liner-easiest-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n      for(int i = pref.length - 1; i > 0; i --) {\\n          pref[i] ^= pref[i - 1]; \\n      }  \\n      return pref;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n      for(int i = pref.length - 1; i > 0; i --) {\\n          pref[i] ^= pref[i - 1]; \\n      }  \\n      return pref;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678941,
                "title": "reverse-xor",
                "content": "**Please upvote if find helpful :)**\\n\\n```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\\npref[i] is the calculated XOR array of 0 to i elements\\n\\nNow let\\'s analyze the input\\n```\\nInput: pref = [5,2,0,3,1]\\nOutput: [5,7,2,3,2]\\nExplanation: From the array [5,7,2,3,2] we have the following:\\n- pref[0] = 5.\\n- pref[1] = 5 ^ 7 = 2.\\n- pref[2] = 5 ^ 7 ^ 2 = 0.\\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\\n\\nfor i=0 , 5 is the answer\\nfor i=1 , 5 ^ x = 2 , we need value of x , to get value of x we can do XOR on both sides with 5\\n            5 ^ x ^ 5 =2 ^5 , x=2^5 , x=2 ^ prev\\nfor i=2 , 5 ^ 7 ^ x = 0 , to get x same XOR on both sides with ( 5 ^ 7 ) but 5 ^ 7 can be represented with 2 which is the last value of pref             \\n```\\n\\n#### CODE\\n```\\nvector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        int prev=0;\\n        for(int &p:pref){\\n            ans.push_back(p^prev);\\n            prev=p;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\n```\\nInput: pref = [5,2,0,3,1]\\nOutput: [5,7,2,3,2]\\nExplanation: From the array [5,7,2,3,2] we have the following:\\n- pref[0] = 5.\\n- pref[1] = 5 ^ 7 = 2.\\n- pref[2] = 5 ^ 7 ^ 2 = 0.\\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\\n\\nfor i=0 , 5 is the answer\\nfor i=1 , 5 ^ x = 2 , we need value of x , to get value of x we can do XOR on both sides with 5\\n            5 ^ x ^ 5 =2 ^5 , x=2^5 , x=2 ^ prev\\nfor i=2 , 5 ^ 7 ^ x = 0 , to get x same XOR on both sides with ( 5 ^ 7 ) but 5 ^ 7 can be represented with 2 which is the last value of pref             \\n```\n```\\nvector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        int prev=0;\\n        for(int &p:pref){\\n            ans.push_back(p^prev);\\n            prev=p;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678853,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> ans(n);\\n        ans[0] = pref[0];\\n        for(int i = 1;i<n;i++)\\n            ans[i] = pref[i-1] ^ pref[i];\\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> ans(n);\\n        ans[0] = pref[0];\\n        for(int i = 1;i<n;i++)\\n            ans[i] = pref[i-1] ^ pref[i];\\n        return ans; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3715868,
                "title": "simple-approach-c-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nin problem statement it is given that :-\\n**pref[i] = arr[0]^arr[1]^arr[2]......arr[i-1]^arr[i]**\\nwe can write the statement in another way :-\\n**arr[i] =  arr[0]^arr[1].....arr[i-2]^arr[i-1]^pref[i]**\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size(),xorvalue = pref[0];\\n        for(int i = 1;i<pref.size();i++)\\n        {\\n           int tmp = xorvalue^pref[i];\\n           pref[i] = tmp;\\n           xorvalue = xorvalue^pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/94d900a8-78fe-4548-874a-52de0e627eb3_1688452375.9702466.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size(),xorvalue = pref[0];\\n        for(int i = 1;i<pref.size();i++)\\n        {\\n           int tmp = xorvalue^pref[i];\\n           pref[i] = tmp;\\n           xorvalue = xorvalue^pref[i];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632069,
                "title": "java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n=pref.length;\\n        int ans[]=new int[n];\\n        ans[0]=pref[0];\\n        for(int i=1;i<n;i++){\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n=pref.length;\\n        int ans[]=new int[n];\\n        ans[0]=pref[0];\\n        for(int i=1;i<n;i++){\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523252,
                "title": "simple-java-solution",
                "content": "Simple Java Solution\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] originArray = new int[pref.length];\\n        originArray[0] = pref[0];\\n\\n        for (int elementIndex = 1; elementIndex < pref.length; elementIndex++) {\\n            originArray[elementIndex] = pref[elementIndex] ^ pref[elementIndex - 1];\\n        }\\n\\n        return originArray;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] originArray = new int[pref.length];\\n        originArray[0] = pref[0];\\n\\n        for (int elementIndex = 1; elementIndex < pref.length; elementIndex++) {\\n            originArray[elementIndex] = pref[elementIndex] ^ pref[elementIndex - 1];\\n        }\\n\\n        return originArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418254,
                "title": "find-the-original-array-of-prefix-xor-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int i;\\n        vector<int> arr;\\n        arr.push_back(pref[0]);\\n        for(i=1 ; i<pref.size() ; i++)\\n        {\\n            arr.push_back(pref[i-1]^pref[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int i;\\n        vector<int> arr;\\n        arr.push_back(pref[0]);\\n        for(i=1 ; i<pref.size() ; i++)\\n        {\\n            arr.push_back(pref[i-1]^pref[i]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207291,
                "title": "easy-approach",
                "content": "# Intuition\\nRecall the concepts of XOR.\\n\\n# Approach\\n```\\na ^ b = c\\n```\\nThen the following relations will also be true,\\n```\\na ^ c = b\\nb ^ c = a\\n```\\n\\n# Complexity\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> res;\\n\\n        res.push_back(pref[0]);\\n        for(int i=1; i<n; i++){\\n            res.push_back(pref[i-1]^pref[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\na ^ b = c\\n```\n```\\na ^ c = b\\nb ^ c = a\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> res;\\n\\n        res.push_back(pref[0]);\\n        for(int i=1; i<n; i++){\\n            res.push_back(pref[i-1]^pref[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206629,
                "title": "java-100-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int len = pref.length;\\n        for(int i = len - 1; i > 0; i--){\\n            pref[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int len = pref.length;\\n        for(int i = len - 1; i > 0; i--){\\n            pref[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153585,
                "title": "easy-cpp-solution-a-b-c-then-a-c-b",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n(a^b=c then a^c=b)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i =0; i<nums.size()-1; i++){\\n            arr.push_back(nums[i]^nums[i+1]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int>arr;\\n        arr.push_back(nums[0]);\\n        for(int i =0; i<nums.size()-1; i++){\\n            arr.push_back(nums[i]^nums[i+1]);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051165,
                "title": "simple-c-o-n-solution-beats-others",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>org;\\n        org.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            org.push_back(pref[i]^pref[i-1]);\\n        }\\n        return org;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>org;\\n        org.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            org.push_back(pref[i]^pref[i-1]);\\n        }\\n        return org;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020675,
                "title": "easy-solution-python3-beats-99",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        lst=[pref[0]]\\n        for i in range(len(pref)-1):\\n            lst.append(pref[i]^pref[i+1])\\n        return lst\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        lst=[pref[0]]\\n        for i in range(len(pref)-1):\\n            lst.append(pref[i]^pref[i+1])\\n        return lst\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816642,
                "title": "one-liner-python-3-simple-solution-easy-to-understand",
                "content": "```class Solution:\\n    def findArray(self, p: List[int]) -> List[int]:\\n        return [p[0]] +[p[i]^p[i-1]for i in range(1,len(p))]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def findArray(self, p: List[int]) -> List[int]:\\n        return [p[0]] +[p[i]^p[i-1]for i in range(1,len(p))]",
                "codeTag": "Java"
            },
            {
                "id": 2750396,
                "title": "java-2ms-fast-and-easy-solution",
                "content": "```\\n\\t\\tint n=pref.length;\\n        int[] arr=new int [n];\\n        arr[0]=pref[0];\\n        \\n        for(int i=(n-1);i>0;i--){\\n            arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\tint n=pref.length;\\n        int[] arr=new int [n];\\n        arr[0]=pref[0];\\n        \\n        for(int i=(n-1);i>0;i--){\\n            arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682613,
                "title": "1-liner",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nvector<int> findArray(vector<int>& p)\\n{\\n\\treturn {begin(p), adjacent_difference(begin(p), end(p), begin(p), bit_xor{})};\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> findArray(vector<int>& p)\\n{\\n\\treturn {begin(p), adjacent_difference(begin(p), end(p), begin(p), bit_xor{})};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679807,
                "title": "explained-intuition-for-xor-2-line-solution",
                "content": "**XOR PROPERTY :** \\n```\\n\\tFor a,b,c if (a ^ b = c) then (a ^ c = b), (b ^ c = a) \\n    let variable XOR store ,xor of all previous elements of our ans array.\\n    let ans[i] be x. //we have to find ans[i].\\n      =>XOR ^ x = p[i] //XOR property\\n      => x = p[i] ^ XOR \\n```\\nWe have to insert p[i] ^ XOR in our ans array!\\n    \\nApproach 1: forward iteration\\n```\\nvector<int> findArray(vector<int>& p) { \\n\\tint n = p.size();\\n\\tint XOR = 0;\\n\\n\\tfor(int i = 0; i < n; i++) \\n\\t{\\n\\t\\tp[i] ^= XOR; //ans[i] = p[i] ^ XOR\\n\\t\\tXOR ^=  p[i]; //update XOR to include curr element as well\\n\\t}\\n\\treturn p;\\n}\\n```\\n   2 lines! - we know p[0] will be 1 so we can save one iteration!\\n   \\n    vector<int> findArray(vector<int>& p) {\\n        for(int i=1,XOR=p[0]; i<size(p); XOR^=p[i++])   p[i] ^= XOR;\\n        return p;\\n    }\\nAPPROACH 2 : backward itertion without  XOR variable! : [@lee215](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/discuss/2678904/JavaC%2B%2BPython-Easy-and-Concise-with-Explantion) discussion: same intuition.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tFor a,b,c if (a ^ b = c) then (a ^ c = b), (b ^ c = a) \\n    let variable XOR store ,xor of all previous elements of our ans array.\\n    let ans[i] be x. //we have to find ans[i].\\n      =>XOR ^ x = p[i] //XOR property\\n      => x = p[i] ^ XOR \\n```\n```\\nvector<int> findArray(vector<int>& p) { \\n\\tint n = p.size();\\n\\tint XOR = 0;\\n\\n\\tfor(int i = 0; i < n; i++) \\n\\t{\\n\\t\\tp[i] ^= XOR; //ans[i] = p[i] ^ XOR\\n\\t\\tXOR ^=  p[i]; //update XOR to include curr element as well\\n\\t}\\n\\treturn p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679774,
                "title": "java-3-ms-100-faster-simplest-solution",
                "content": "# class Solution {\\n    public int[] findArray(int[] pre) {\\n        int[] ans=new int[pre.length];\\n        ans[0]=pre[0];\\n        for(int i=1;i<pre.length;i++)\\n        {\\n            ans[i]=pre[i-1]^pre[i];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findArray(int[] pre) {\\n        int[] ans=new int[pre.length];\\n        ans[0]=pre[0];\\n        for(int i=1;i<pre.length;i++)\\n        {\\n            ans[i]=pre[i-1]^pre[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2679252,
                "title": "2-solutions-one-liner-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n      \\n      // beginner friendly\\n      // time -> O(N)   space -> O(N)\\n      \\n      vector<int>ans;\\n      ans.push_back(pref[0]);\\n      int xr = pref[0];\\n      for(int i = 1 ; i < pref.size() ; i++) {\\n        xr = pref[i]^pref[i-1];\\n        ans.push_back(xr);\\n      }\\n      return ans;\\n      \\n      // one liner\\n      // time -> O(N)   space -> O\\n      for (int i = pref.size() - 1; i > 0; --i) pref[i] = pref[i]^pref[i - 1];\\n      return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n      \\n      // beginner friendly\\n      // time -> O(N)   space -> O(N)\\n      \\n      vector<int>ans;\\n      ans.push_back(pref[0]);\\n      int xr = pref[0];\\n      for(int i = 1 ; i < pref.size() ; i++) {\\n        xr = pref[i]^pref[i-1];\\n        ans.push_back(xr);\\n      }\\n      return ans;\\n      \\n      // one liner\\n      // time -> O(N)   space -> O\\n      for (int i = pref.size() - 1; i > 0; --i) pref[i] = pref[i]^pref[i - 1];\\n      return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679243,
                "title": "java-2ms-beats-100",
                "content": "Simple observation:\\n\\nIf c = a^b then we know a = b^c\\n5 ^ 2 = 7 can be written as 5 = 7 ^ 2\\n5 ^ 7 = 2 can be written as 7 = 2 ^ 5\\nBasic maths LHS = RHS\\n\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int xor = pref[0];\\n        for(int i = 1;i<pref.length;i++)\\n        {\\n            int temp = xor ^ pref[i];\\n            xor = pref[i];\\n            pref[i] = temp;\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int xor = pref[0];\\n        for(int i = 1;i<pref.length;i++)\\n        {\\n            int temp = xor ^ pref[i];\\n            xor = pref[i];\\n            pref[i] = temp;\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679238,
                "title": "2-solution-one-liner-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n      \\n      // beginner friendly\\n      \\n      vector<int>ans;\\n      ans.push_back(pref[0]);\\n      int xr = pref[0];\\n      for(int i = 1 ; i < pref.size() ; i++) {\\n        xr = pref[i]^pref[i-1];\\n        pref[i] = xr;\\n      }\\n      return ans;\\n      \\n      // one liner\\n      \\n      for (int i = pref.size() - 1; i > 0; --i) pref[i] = pref[i]^pref[i - 1];\\n      return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n      \\n      // beginner friendly\\n      \\n      vector<int>ans;\\n      ans.push_back(pref[0]);\\n      int xr = pref[0];\\n      for(int i = 1 ; i < pref.size() ; i++) {\\n        xr = pref[i]^pref[i-1];\\n        pref[i] = xr;\\n      }\\n      return ans;\\n      \\n      // one liner\\n      \\n      for (int i = pref.size() - 1; i > 0; --i) pref[i] = pref[i]^pref[i - 1];\\n      return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679039,
                "title": "easy-java-solution",
                "content": "# Find The Original Array of Prefix Xor\\n# Easy Java Solution\\n\\n**Approach:**\\n1.) The resultant array can be found by doing the Xor of the prev ans with current pref[i].\\n2.) Initially prev would be 0.\\n\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        //Creating an ans array\\n        int[] ans=new int[pref.length];\\n        int prev=0;\\n        for(int i=0;i<pref.length;i++){\\n            //Getting the prev XOR pref[i] as our current answer\\n            ans[i]=prev^pref[i];\\n            //Storing pref[i] as prev\\n            prev=pref[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        //Creating an ans array\\n        int[] ans=new int[pref.length];\\n        int prev=0;\\n        for(int i=0;i<pref.length;i++){\\n            //Getting the prev XOR pref[i] as our current answer\\n            ans[i]=prev^pref[i];\\n            //Storing pref[i] as prev\\n            prev=pref[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678813,
                "title": "simple-adj-xor-c",
                "content": "```\\nvector<int> findArray(vector<int>& pref) {\\n        vector<int> ans = pref;\\n        for(int i = 1; i < pref.size();i++){\\n            ans[i]=pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> findArray(vector<int>& pref) {\\n        vector<int> ans = pref;\\n        for(int i = 1; i < pref.size();i++){\\n            ans[i]=pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923466,
                "title": "c-javascript-python-java-go-easy-solution",
                "content": "# Approach\\nTake a list of numbers and transforms it into a new list by performing an operation called XOR between each pair of consecutive numbers. The XOR operation combines the binary representations of the numbers and produces a result. The transformed list is then returned as the output\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++) ans.push_back(pref[i-1]^pref[i]);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\n    const ans=[];\\n    ans.push(pref[0]);\\n    for(let i=1;i<pref.length;i++) ans.push(pref[i-1]^pref[i]);\\n    return ans;\\n};\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans=[]\\n        ans.append(pref[0])\\n        for i in range(1, len(pref)):\\n            ans.append(pref[i-1]^pref[i])      \\n        return ans;\\n```\\n\\n\\n---\\n\\n# Java\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++) ans[i]=(pref[i-1]^pref[i]);\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n# Go\\n```\\nfunc findArray(pref []int) []int {\\n    ans := make([]int, len(pref))\\n\\tans[0] = pref[0]\\n\\tfor i := 1; i < len(pref); i++ {\\n        ans[i] = pref[i-1] ^ pref[i]\\n    }\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++) ans.push_back(pref[i-1]^pref[i]);\\n        return ans;\\n    }\\n};\\n\\n```\n```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\n    const ans=[];\\n    ans.push(pref[0]);\\n    for(let i=1;i<pref.length;i++) ans.push(pref[i-1]^pref[i]);\\n    return ans;\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans=[]\\n        ans.append(pref[0])\\n        for i in range(1, len(pref)):\\n            ans.append(pref[i-1]^pref[i])      \\n        return ans;\\n```\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++) ans[i]=(pref[i-1]^pref[i]);\\n        return ans;\\n    }\\n}\\n```\n```\\nfunc findArray(pref []int) []int {\\n    ans := make([]int, len(pref))\\n\\tans[0] = pref[0]\\n\\tfor i := 1; i < len(pref); i++ {\\n        ans[i] = pref[i-1] ^ pref[i]\\n    }\\n\\treturn ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859572,
                "title": "beats-100-beginner-friendly-java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] new_arr = new int[pref.length];\\n        new_arr[0] = pref[0];\\n        for(int i=pref.length-1; i>0; i--){\\n            new_arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return new_arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] new_arr = new int[pref.length];\\n        new_arr[0] = pref[0];\\n        for(int i=pref.length-1; i>0; i--){\\n            new_arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return new_arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762519,
                "title": "java-2-ms-easy-and-fast-solution-o-n-with-explanation",
                "content": "# Approach\\nThe approach used in the given solution is to iterate over the `pref` array and calculate the values of the `arr` array such that each element `arr[i]` is obtained by XORing the previous element `arr[i-1]` with the corresponding `pref[i]` value.\\n\\n1. Initialize an array `arr` of size `n` to store the resulting values.\\n\\n2. Set the first element of `arr` as `arr[0] = pref[0]`. This is because there are no previous elements to XOR with for the first element.\\n\\n3. Iterate over the `pref` array starting from index 1 (since the first element is already set in `arr`).\\n\\n4. For each iteration, calculate the current `arr` value by XORing the previous `arr` value with the corresponding `pref` value. Set `arr[i] = arr[i-1] ^ pref[i]`. This is because XORing `arr[i-1]` with `pref[i]` will give the value that satisfies the equation `pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]`.\\n\\n5. Repeat the process for all elements in the `pref` array, updating the corresponding values in `arr`.\\n\\n6. Finally, return the resulting `arr` array.\\n\\nThe logic behind the solution is that XOR operation is both commutative and associative. By iterating over the `pref` array and XORing the previous `arr` value with the current `pref` value, we can find the values of `arr` that satisfy the given equation. Each XOR operation cancels out the previous XOR operations, resulting in the original values of `arr`.\\n\\nBy following this approach, the solution effectively reconstructs the original array `arr` from the given `pref` array.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n        arr[0] = pref[0];\\n\\n        for(int i = 1; i < n; i++)\\n            arr[i] = pref[i - 1] ^ pref[i];\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n        arr[0] = pref[0];\\n\\n        for(int i = 1; i < n; i++)\\n            arr[i] = pref[i - 1] ^ pref[i];\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375374,
                "title": "simple-and-best-solution",
                "content": "# Intuition\\n1. x^x = 0:\\nThe XOR operation between two identical bits is always 0. So, when you XOR a bit with itself (i.e., x XOR x), the result will always be 0. Thus, if x is a binary number, then x XOR x will be equal to 0.\\n\\n2. 0^x = x:\\nThe XOR operation between a 0 bit and any other bit is always equal to the other bit. So, when you XOR a 0 bit with any other bit x, the result will be x. Thus, if x is a binary number, then 0 XOR x will be equal to x.\\n\\nSo we have to xor of curr value with the prev value i.e our answer.\\n# Approach\\nFirstly push  0th index value. the traverse the loop and then push pref[i]^pref[i-1] into the vector\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int xor_ = 0, n= pref.size();\\n        vector<int> v;\\n        v.push_back(pref[0]);\\n        for(int i = 1; i<n; i++){\\n          xor_ = pref[i-1]^pref[i];\\n          v.push_back(xor_);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int xor_ = 0, n= pref.size();\\n        vector<int> v;\\n        v.push_back(pref[0]);\\n        for(int i = 1; i<n; i++){\\n          xor_ = pref[i-1]^pref[i];\\n          v.push_back(xor_);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135004,
                "title": "easy-approach-using-prefix-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe have to simply calculate the xor with its previous value and after calculating the prefix xor for each element. Then, we have to store those prefix xor values in an array.\\nAfter storing all the values . simply return that prefix xor array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        prefix=[pref[0]]\\n        for i in range(1,len(pref)):\\n            prefix.append(pref[i-1]^pref[i])\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        prefix=[pref[0]]\\n        for i in range(1,len(pref)):\\n            prefix.append(pref[i-1]^pref[i])\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032459,
                "title": "easy-c-solution-using-xor-property",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> arr;\\n        // a^b= c : a^b^a= c^a : b= c^a\\n        int a= 0,ln= pref.size();\\n        for(int i=0;i<ln;i++){\\n            arr.push_back(pref[i]^a);\\n            a^= arr.back();\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> arr;\\n        // a^b= c : a^b^a= c^a : b= c^a\\n        int a= 0,ln= pref.size();\\n        for(int i=0;i<ln;i++){\\n            arr.push_back(pref[i]^a);\\n            a^= arr.back();\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981662,
                "title": "c-easy-solution-100-faster",
                "content": "# Intuition\\nPlzz UPVOTE \\u2B06\\uFE0F if u find my solution helpful.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        int n=pref.size();\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n           ans.push_back(pref[i-1]^pref[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        int n=pref.size();\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<n;i++)\\n        {\\n           ans.push_back(pref[i-1]^pref[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830434,
                "title": "use-xor-to-invert-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        int n  = p.size();\\n        vector<int> a(n);\\n        \\n        a[0] = p[0];\\n        for(int i =1;i<n;i++)\\n        {\\n            a[i] = p[i-1]^p[i];\\n        }\\n        \\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        int n  = p.size();\\n        vector<int> a(n);\\n        \\n        a[0] = p[0];\\n        for(int i =1;i<n;i++)\\n        {\\n            a[i] = p[i-1]^p[i];\\n        }\\n        \\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825005,
                "title": "cpp-easy-solution-with-explanation-o-n-complexity",
                "content": "# Approach\\n The Approach is very simple find XOR value of each adjacent terms and push it in the answer vector....Because this is the property of XOR\\n> X ^ Y = Z  then X ^ Z = Y\\n\\n```\\np = [5,2,0,3,1],\\n-> p[0] = 5 [push it in the vector]\\n\\n-> p[1] = 5 ^ 7 = 2.             \\n   or we can say 5 ^ 2 = 7 [push it in the vector]\\n\\n-> p[2] = (5 ^ 7) ^ 2 = 0.        \\n   or we can say 2 ^ 2 = 0 , or 2 ^ 0 = 2 [push it in the vector] \\n\\n-> p[3] = (5 ^ 7 ^ 2) ^ 3 = 3 \\n   or we can say, 0 ^ 3 = 3, or 0 ^ 3 = 3 [push it in the vector]\\n\\n-> p[4] = (5 ^ 7 ^ 2 ^ 3) ^ 2 = 1\\n   or we can say 3 ^ 2 = 1 , or 3 ^ 1 = 2 [push it in the vector]\\n\\n```\\nAnswer vector ={5,7,2,3,2} \\n\\n> Please Upvote if you like the Explanation \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0A\\uD83D\\uDE0A\\n \\n# Complexity\\n- Time complexity: O(n), 96.54% better than Cpp Online Submissions\\n\\n- Space complexity: 30.79% better than Cpp Online Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        vector<int> v;\\n        v.push_back(p[0]);\\n\\n        for(int i=0;i<p.size()-1;i++)\\n            v.push_back(p[i]^p[i+1]);\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\np = [5,2,0,3,1],\\n-> p[0] = 5 [push it in the vector]\\n\\n-> p[1] = 5 ^ 7 = 2.             \\n   or we can say 5 ^ 2 = 7 [push it in the vector]\\n\\n-> p[2] = (5 ^ 7) ^ 2 = 0.        \\n   or we can say 2 ^ 2 = 0 , or 2 ^ 0 = 2 [push it in the vector] \\n\\n-> p[3] = (5 ^ 7 ^ 2) ^ 3 = 3 \\n   or we can say, 0 ^ 3 = 3, or 0 ^ 3 = 3 [push it in the vector]\\n\\n-> p[4] = (5 ^ 7 ^ 2 ^ 3) ^ 2 = 1\\n   or we can say 3 ^ 2 = 1 , or 3 ^ 1 = 2 [push it in the vector]\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        vector<int> v;\\n        v.push_back(p[0]);\\n\\n        for(int i=0;i<p.size()-1;i++)\\n            v.push_back(p[i]^p[i+1]);\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818072,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n         arr[0]=pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            arr[i]=pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n         arr[0]=pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            arr[i]=pref[i-1]^pref[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2802161,
                "title": "easy-solution",
                "content": "class Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        if(len(pref)==1):\\n            return pref\\n        req=[pref[0]]\\n        for i in range(1,len(pref)):\\n            req.append(pref[i]^pref[i-1])\\n        return req\\n* 1.",
                "solutionTags": [],
                "code": "class Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        if(len(pref)==1):\\n            return pref\\n        req=[pref[0]]\\n        for i in range(1,len(pref)):\\n            req.append(pref[i]^pref[i-1])\\n        return req\\n* 1.",
                "codeTag": "Java"
            },
            {
                "id": 2753923,
                "title": "python-simple-solution-in-4-lines-faster-than-90-2",
                "content": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        arr,n=[pref[0]],len(pref)\\n        for i in range(1,n):\\n            arr.append(pref[i-1]^pref[i])\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        arr,n=[pref[0]],len(pref)\\n        for i in range(1,n):\\n            arr.append(pref[i-1]^pref[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753119,
                "title": "python-o-n-two-lines-list-comprehension",
                "content": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        output = [pref[i] ^ pref[i-1] for i in range(1, len(pref))]\\n        return [pref[0]] + output\\n```",
                "solutionTags": [],
                "code": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        output = [pref[i] ^ pref[i-1] for i in range(1, len(pref))]\\n        return [pref[0]] + output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2703066,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> {\\n        pref.iter()\\n            .scan(0, |prev, &x| {\\n                let res = *prev ^ x;\\n                *prev = x;\\n                Some(res)\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> {\\n        pref.iter()\\n            .scan(0, |prev, &x| {\\n                let res = *prev ^ x;\\n                *prev = x;\\n                Some(res)\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701512,
                "title": "c-solution-easy",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* findArray(int* pref, int prefSize, int* returnSize){\\n    int *solution = calloc(prefSize, sizeof(int));\\n    solution[0] = pref[0];\\n    for (int index = 1; index < prefSize; index++){\\n        solution[index] = pref[index-1] ^ pref[index];\\n    }\\n    *returnSize = prefSize;\\n    return solution;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* findArray(int* pref, int prefSize, int* returnSize){\\n    int *solution = calloc(prefSize, sizeof(int));\\n    solution[0] = pref[0];\\n    for (int index = 1; index < prefSize; index++){\\n        solution[index] = pref[index-1] ^ pref[index];\\n    }\\n    *returnSize = prefSize;\\n    return solution;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701457,
                "title": "javascript-solution-super-easy",
                "content": "```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\n    let solution = [pref[0]];\\n    for (let index = 1; index < pref.length; index++){\\n        solution.push(pref[index-1] ^ pref[index]);\\n    }\\n    return solution;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\n    let solution = [pref[0]];\\n    for (let index = 1; index < pref.length; index++){\\n        solution.push(pref[index-1] ^ pref[index]);\\n    }\\n    return solution;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2697921,
                "title": "using-xor-properties-for-a-very-easy-solution",
                "content": "Recall the property of XOR, that is ``a ^ a = 0`` and ``a ^ 0 = a``. Note that we have the recurrence for prefix XOR, which is ``pre[i] = pre[i - 1] ^ a[i]``. Thus, ``pre[i] ^ pre[i - 1] = 0 ^ a[i] = a[i]``. Thus, for finding ``a[1], a[2], ..., a[n - 1]``, we can just apply this method, and ``a[0] = pre[0]``, so we are done. \\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        \\n        ans.push_back(pref[0]);\\n        \\n        for(int i = 1; i < pref.size(); i++){\\n            ans.push_back(pref[i] ^ pref[i - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n            \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        \\n        ans.push_back(pref[0]);\\n        \\n        for(int i = 1; i < pref.size(); i++){\\n            ans.push_back(pref[i] ^ pref[i - 1]);\\n        }\\n        \\n        return ans;\\n    }\\n            \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691037,
                "title": "c-short-xor-property",
                "content": "```\\n  vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                ans[0]=pref[0];\\n            else\\n                ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                ans[0]=pref[0];\\n            else\\n                ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2685100,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[]} pref\\n# @return {Integer[]}\\ndef find_array(pref)\\n  [0, *pref].each_cons(2).map { _1 ^ _2 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} pref\\n# @return {Integer[]}\\ndef find_array(pref)\\n  [0, *pref].each_cons(2).map { _1 ^ _2 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2684765,
                "title": "c-xor-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        if(pref.size() == 0) return {};\\n        //if(pref.size() == 1)\\n        \\n        vector<int> result;\\n        result.push_back(pref[0]);\\n        for(int i=1 ; i<pref.size() ; i++)\\n        {\\n            result.push_back(pref[i] ^ pref[i-1]);            \\n        }\\n        return result;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        if(pref.size() == 0) return {};\\n        //if(pref.size() == 1)\\n        \\n        vector<int> result;\\n        result.push_back(pref[0]);\\n        for(int i=1 ; i<pref.size() ; i++)\\n        {\\n            result.push_back(pref[i] ^ pref[i-1]);            \\n        }\\n        return result;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684467,
                "title": "python-3-easy-o-n-time-greedy-solution-explained",
                "content": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [0 for i in range(len(pref))]\\n        ans[0] = pref[0]\\n        for i in range(1, len(pref)):\\n            ans[i] = pref[i-1]^pref[i]\\n        return ans\\n```\\n\\n**Explanation**\\n```\\nas a^a = 0\\npref[i] = a1 (Base Case)\\npref[i-1] = a1^a2^a3^.....^ai-1\\nand \\npref[i] = a1^a2^.......^ai\\n\\tpref [i-1]   =  a1 ^ a2 ^ .... ^ ai-1 \\n^   pref[i]      =  a1 ^ a2 ^ .... ^ ai -1 ^ ai\\n                 =   0 ^ 0  ^  0 ^ ..... 0 ^ ai\\n\\t\\t\\t\\t =  ai\\nwe can conclude that for any i>1, ai = pref(i-1) ^ pref(i)\\n\\n(^ is the Bitwise XOR Operator)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [0 for i in range(len(pref))]\\n        ans[0] = pref[0]\\n        for i in range(1, len(pref)):\\n            ans[i] = pref[i-1]^pref[i]\\n        return ans\\n```\n```\\nas a^a = 0\\npref[i] = a1 (Base Case)\\npref[i-1] = a1^a2^a3^.....^ai-1\\nand \\npref[i] = a1^a2^.......^ai\\n\\tpref [i-1]   =  a1 ^ a2 ^ .... ^ ai-1 \\n^   pref[i]      =  a1 ^ a2 ^ .... ^ ai -1 ^ ai\\n                 =   0 ^ 0  ^  0 ^ ..... 0 ^ ai\\n\\t\\t\\t\\t =  ai\\nwe can conclude that for any i>1, ai = pref(i-1) ^ pref(i)\\n\\n(^ is the Bitwise XOR Operator)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683470,
                "title": "golang-101-ms-8-7-mb",
                "content": "```\\nfunc findArray(pref []int) []int {\\n    for i := len(pref)-1; i > 0; i-- {\\n        pref[i] ^= pref[i-1]\\n    }\\n    return pref\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findArray(pref []int) []int {\\n    for i := len(pref)-1; i > 0; i-- {\\n        pref[i] ^= pref[i-1]\\n    }\\n    return pref\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683397,
                "title": "c-easy-simple-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    // we are given:\\n    // [a, a ^ b, a ^ b ^ c, a ^ b ^ c ^ d, ...]\\n    \\n    // we need to find\\n    // [a, b, c, d, ...]\\n    \\n    vector<int> findArray(vector<int>& pref) {\\n        int n, latest = pref[0];\\n        for(int i=1; i < pref.size(); i++){\\n            // n saves pref[i] temporarily\\n            n = pref[i];\\n            \\n            // xor current element with the last one i.e say (a ^ b ^ c ^ d) ^ (a ^ b ^ c) = d\\n            pref[i] ^= latest;\\n            \\n            // set latest as the original pref[i] (before changing) saved in n \\n            latest = n;\\n        }\\n    \\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    // we are given:\\n    // [a, a ^ b, a ^ b ^ c, a ^ b ^ c ^ d, ...]\\n    \\n    // we need to find\\n    // [a, b, c, d, ...]\\n    \\n    vector<int> findArray(vector<int>& pref) {\\n        int n, latest = pref[0];\\n        for(int i=1; i < pref.size(); i++){\\n            // n saves pref[i] temporarily\\n            n = pref[i];\\n            \\n            // xor current element with the last one i.e say (a ^ b ^ c ^ d) ^ (a ^ b ^ c) = d\\n            pref[i] ^= latest;\\n            \\n            // set latest as the original pref[i] (before changing) saved in n \\n            latest = n;\\n        }\\n    \\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683158,
                "title": "python-fastest-100-one-liner-using-list-comprehension-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/818871294/) employs a smart trick inside a list comprehension. It demonstrated **798 ms runtime (100.00%)** and used **32.6 MB memory (83.33%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Rust**](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/discuss/2683069/Rust-29-ms-fastest-(100)-one-liner-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n\\n        # here, we use a trick to perform two operations inside\\n        # a list comprehension and return the first result (xor)\\n        last = 0\\n        return [(n^last,last:=n)[0] for n in pref]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n\\n        # here, we use a trick to perform two operations inside\\n        # a list comprehension and return the first result (xor)\\n        last = 0\\n        return [(n^last,last:=n)[0] for n in pref]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683069,
                "title": "rust-29-ms-fastest-100-one-liner-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/818853117/) employs a functional-style approach.... It demonstrated **29 ms runtime (100.00%)** and used **3.8 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Python**](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/discuss/2683158/Python-fastest-(100)-one-liner-using-list-comprehension-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> \\n    {\\n        // map-collect with storing an intermediate state (last number)\\n        let mut last = 0;\\n        pref.into_iter().map(|n| { let xor = n^last; last = n; xor }).collect()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> \\n    {\\n        // map-collect with storing an intermediate state (last number)\\n        let mut last = 0;\\n        pref.into_iter().map(|n| { let xor = n^last; last = n; xor }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682898,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\nlet arr = [];\\narr[0] = pref[0];\\nfor(i=1;i<pref.length;i++){\\n    arr[i] = pref[i] ^ pref[i-1]\\n}\\nreturn arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} pref\\n * @return {number[]}\\n */\\nvar findArray = function(pref) {\\nlet arr = [];\\narr[0] = pref[0];\\nfor(i=1;i<pref.length;i++){\\n    arr[i] = pref[i] ^ pref[i-1]\\n}\\nreturn arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682607,
                "title": "c-easy-solution-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int curr=0;\\n        int prev=0;\\n        for(int i=0;i<pref.size();i++){\\n              curr=pref[i];\\n            pref[i]=prev^pref[i];\\n            \\n            prev=curr;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int curr=0;\\n        int prev=0;\\n        for(int i=0;i<pref.size();i++){\\n              curr=pref[i];\\n            pref[i]=prev^pref[i];\\n            \\n            prev=curr;\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681808,
                "title": "java-0-ms-5-line-code",
                "content": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n        arr[0]=pref[0];\\n        for(int i=1; i<arr.length; i++){\\n            arr[i]=pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n        arr[0]=pref[0];\\n        for(int i=1; i<arr.length; i++){\\n            arr[i]=pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681743,
                "title": "java-100-faster-100-memory-effective",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n![100 and 100.png](https://assets.leetcode.com/users/images/d5a1fced-e32f-4edd-9a00-352f8c7a01da_1665323806.45123.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int prev = pref[0], memo = prev;\\n        for (int i = 1; i < pref.length; i++) {\\n            memo = pref[i];\\n            pref[i] = prev ^ pref[i];\\n            prev = memo;\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int prev = pref[0], memo = prev;\\n        for (int i = 1; i < pref.length; i++) {\\n            memo = pref[i];\\n            pref[i] = prev ^ pref[i];\\n            prev = memo;\\n        }\\n        return pref;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681025,
                "title": "java-solution-faster-than-100-easy-solution-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] res = new int[pref.length];\\n        res[0]=pref[0];\\n        int xor = pref[0];\\n        for(int i=1;i<pref.length;i++)\\n        {\\n            res[i]=xor^pref[i];\\n            xor^=res[i];\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] res = new int[pref.length];\\n        res[0]=pref[0];\\n        int xor = pref[0];\\n        for(int i=1;i<pref.length;i++)\\n        {\\n            res[i]=xor^pref[i];\\n            xor^=res[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2680598,
                "title": "easy-approach-observation-6-lines-of-code-c",
                "content": "**Approach**\\n\\n    Number ^x=ans\\n         then  Number^ans=x        \\n**C++**\\n  \\n     vector<int> findArray(vector<int>& pref) {\\n         vector<int> ans(pref.size());\\n        ans[0]=pref[0];\\n       for(int i=1;i<pref.size();i++){\\n          ans[i]=pref[i]^pref[i-1];//Just get the Xor of current and previous element\\n       }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "**Approach**\\n\\n    Number ^x=ans\\n         then  Number^ans=x        \\n**C++**\\n  \\n     vector<int> findArray(vector<int>& pref) {\\n         vector<int> ans(pref.size());\\n        ans[0]=pref[0];\\n       for(int i=1;i<pref.size();i++){\\n          ans[i]=pref[i]^pref[i-1];//Just get the Xor of current and previous element\\n       }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2680462,
                "title": "very-very-easy-few-line-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans(pref.size(),0);\\n        ans[0]=pref[0];\\n        for(int i=0;i<pref.size()-1;i++){\\n            ans[i+1]=pref[i]^pref[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans(pref.size(),0);\\n        ans[0]=pref[0];\\n        for(int i=0;i<pref.size()-1;i++){\\n            ans[i+1]=pref[i]^pref[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680401,
                "title": "c-easy-and-concise-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++)\\n        {\\n            ans.push_back(pref[i-1]^pref[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++)\\n        {\\n            ans.push_back(pref[i-1]^pref[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680193,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bit Manipulation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        \\n        int n = pref.size();\\n        \\n        // we know that (x ^ x == 0)\\n        \\n        // let say pref[i] = (a ^ b ^ c ^ d) and pref[i - 1] = (a ^ b ^ c), when we will do (pref[i] ^ pref[i - 1]) i.e. (a ^ b ^ c ^ d ^ a ^ b ^ c) club the pairs like (a ^ a ^ b ^ b ^ c ^ c ^ d) it will become (d)\\n        \\n        // perform the same operation to find every element of array\\n        \\n        vector<int> arr(n);\\n        \\n        arr[0] = pref[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            arr[i] = (pref[i] ^ pref[i - 1]);\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        \\n        int n = pref.size();\\n        \\n        // we know that (x ^ x == 0)\\n        \\n        // let say pref[i] = (a ^ b ^ c ^ d) and pref[i - 1] = (a ^ b ^ c), when we will do (pref[i] ^ pref[i - 1]) i.e. (a ^ b ^ c ^ d ^ a ^ b ^ c) club the pairs like (a ^ a ^ b ^ b ^ c ^ c ^ d) it will become (d)\\n        \\n        // perform the same operation to find every element of array\\n        \\n        vector<int> arr(n);\\n        \\n        arr[0] = pref[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            arr[i] = (pref[i] ^ pref[i - 1]);\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679802,
                "title": "java-solution-pictorial-explanation-forward-and-reverse-iteration-easy",
                "content": "### **Please Upvote** :D\\n![image](https://assets.leetcode.com/users/images/d2da7eeb-f759-43b3-a5fe-2939598c18dd_1665296814.5760305.png)\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        ans[0] = pref[0];\\n        \\n        for (int i = 1; i < pref.length; i++) {\\n            ans[i] = pref[i] ^ pref[i - 1];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n) - neglecting output array\\n```\\n**Reverse iteration:**\\n![image](https://assets.leetcode.com/users/images/87f93329-9a8a-4d27-b695-bb9036108773_1665298988.6826682.png)\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        for (int i = pref.length - 1; i > 0; --i) {\\n            pref[i] ^= pref[i - 1];\\n        }\\n\\n        return pref;\\n    }\\n}\\n\\n// TC: O(n)\\n// No extra space used at all\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        ans[0] = pref[0];\\n        \\n        for (int i = 1; i < pref.length; i++) {\\n            ans[i] = pref[i] ^ pref[i - 1];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n) - neglecting output array\\n```\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        for (int i = pref.length - 1; i > 0; --i) {\\n            pref[i] ^= pref[i - 1];\\n        }\\n\\n        return pref;\\n    }\\n}\\n\\n// TC: O(n)\\n// No extra space used at all\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679739,
                "title": "c-python-100-fast-super-clear",
                "content": "**XOR Property**\\nTo solve this problem we should know a basic propery:-\\nIt says if a^b = c then\\n\\t\\t\\t  b^c = a\\n\\t\\t\\t  a^c = b\\n\\nFor Example:\\n5^2 = 7\\n2^7 = 5\\n5^7 = 2\\n\\n**Solution**\\n\\n```\\nWe know pref[0] will be always equal to ans[0]  only because that is only one element.\\n\\nSo now, we have\\n\\npref[1] = ans[0]^ans[1], So by using above property\\nans[1] = ans[0]^pref[1]\\nSo we get ans[1]\\nNow again\\npref[2] = ans[0]^ans[1]^ans[2], So\\n               ans[0]^ans[1] = a, consider this as a single value then\\n\\t\\t\\t   \\nans[2] = ans[0]^ans[1]^pref[2]\\n\\nSo we get ans[2] now\\n\\nNow again\\npref[3] = ans[0]^ans[1]^ans[2]^ans[3]\\nans[3] = ans[0]^ans[1]^ans[2]^pref[3]\\n\\nSo we get ans[3]\\nIn this way we can get entire array.\\n```\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans = {pref[0]};\\n        int curr_xor = pref[0];\\n        int n = pref.size();\\n        \\n        for(int i = 1;i < n;i++){\\n            int currElement = curr_xor^pref[i];\\n            curr_xor = curr_xor^currElement;\\n            ans.push_back(currElement);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\n**Python Code**\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [pref[0]]\\n        curr_xor = pref[0]\\n        n = len(pref)\\n        \\n        for i in range(1,n):\\n            currElement = curr_xor^pref[i]\\n            curr_xor = curr_xor^currElement\\n            ans.append(currElement)\\n        \\n        return ans\\n```\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\nJoin My Telegram Channel:\\nhttps://t.me/ramkishanteli\\nSubscribe to My Youtube Channel for video solutions:\\nhttps://www.youtube.com/channel/UCC1xvf7iphCnOP1VQZL9BCA\\nFollow me on Linkedin:\\nhttps://www.linkedin.com/in/ram-kishan-t-678455b2/\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nWe know pref[0] will be always equal to ans[0]  only because that is only one element.\\n\\nSo now, we have\\n\\npref[1] = ans[0]^ans[1], So by using above property\\nans[1] = ans[0]^pref[1]\\nSo we get ans[1]\\nNow again\\npref[2] = ans[0]^ans[1]^ans[2], So\\n               ans[0]^ans[1] = a, consider this as a single value then\\n\\t\\t\\t   \\nans[2] = ans[0]^ans[1]^pref[2]\\n\\nSo we get ans[2] now\\n\\nNow again\\npref[3] = ans[0]^ans[1]^ans[2]^ans[3]\\nans[3] = ans[0]^ans[1]^ans[2]^pref[3]\\n\\nSo we get ans[3]\\nIn this way we can get entire array.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans = {pref[0]};\\n        int curr_xor = pref[0];\\n        int n = pref.size();\\n        \\n        for(int i = 1;i < n;i++){\\n            int currElement = curr_xor^pref[i];\\n            curr_xor = curr_xor^currElement;\\n            ans.push_back(currElement);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [pref[0]]\\n        curr_xor = pref[0]\\n        n = len(pref)\\n        \\n        for i in range(1,n):\\n            currElement = curr_xor^pref[i]\\n            curr_xor = curr_xor^currElement\\n            ans.append(currElement)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679425,
                "title": "easy-java-solution",
                "content": "```\\n public int[] findArray(int[] nums) {\\n        int a1;\\n        int a2 = nums[0];\\n        int[] a = new int[nums.length];\\n        a[0]=nums[0];\\n        if(nums.length==1) return a;\\n        int index = 1;\\n        for (int i = 1 ; i < nums.length; i++ ){\\n            a1=a2^nums[i];\\n            a[index++]=a1;\\n            a2^=a1;\\n        }\\n        return a;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] findArray(int[] nums) {\\n        int a1;\\n        int a2 = nums[0];\\n        int[] a = new int[nums.length];\\n        a[0]=nums[0];\\n        if(nums.length==1) return a;\\n        int index = 1;\\n        for (int i = 1 ; i < nums.length; i++ ){\\n            a1=a2^nums[i];\\n            a[index++]=a1;\\n            a2^=a1;\\n        }\\n        return a;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679293,
                "title": "c-very-easy-just-obervation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> arr(n);\\n        \\n        for(int i=0; i<pref.size(); i++)\\n        {\\n            if(i==0)\\n                arr[i]=pref[0];\\n            else{\\n                arr[i]=pref[i-1]^pref[i];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int n = pref.size();\\n        vector<int> arr(n);\\n        \\n        for(int i=0; i<pref.size(); i++)\\n        {\\n            if(i==0)\\n                arr[i]=pref[0];\\n            else{\\n                arr[i]=pref[i-1]^pref[i];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679280,
                "title": "reverse-xor-java",
                "content": "using  if, `c = a ^ b` then `a = c ^ b` property.\\n\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        if(pref.length < 2) return pref;\\n        int xor = pref[0];\\n        for(int i = 1; i < pref.length; i++){\\n            // int tmp = pref[i];\\n            pref[i] = xor ^ pref[i];\\n            xor ^= pref[i];\\n        } \\n        return pref;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        if(pref.length < 2) return pref;\\n        int xor = pref[0];\\n        for(int i = 1; i < pref.length; i++){\\n            // int tmp = pref[i];\\n            pref[i] = xor ^ pref[i];\\n            xor ^= pref[i];\\n        } \\n        return pref;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679242,
                "title": "simple-c-working-bruteforce-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        vector<int> a(p.size());\\n        a[0] = p[0];\\n        for(int i=1;i<p.size();i++){\\n            a[i] = p[i]^p[i-1];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        vector<int> a(p.size());\\n        a[0] = p[0];\\n        for(int i=1;i<p.size();i++){\\n            a[i] = p[i]^p[i-1];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679133,
                "title": "xor-properties",
                "content": "**Explanation**\\n\\n**4 Properties of XOR**\\n\\nCommutative : A \\u2295 B = B \\u2295 A\\nAssociative : A \\u2295 ( B \\u2295 C ) = ( A \\u2295 B ) \\u2295 C\\nIdentity element : A \\u2295 0 = A\\nSelf-inverse : A \\u2295 A = 0\\n\\nIn our example:\\nInput: pref = [5,2,0,3,1]\\nOutput: [5,7,2,3,2]\\n\\nwe try to get the second element:\\n```\\n5 ^ x = 2\\n5 ^ x ^ 2 = 2 ^ 2\\n5 ^ 2 ^ x = 0\\nx = 5 ^ 2\\n```\\n**Python**\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        res = []\\n        res.append(pref[0])\\n        for i in range(1, len(pref)):\\n            res.append(pref[i - 1] ^ pref[i])\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n5 ^ x = 2\\n5 ^ x ^ 2 = 2 ^ 2\\n5 ^ 2 ^ x = 0\\nx = 5 ^ 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679122,
                "title": "3-lines-python-o-n-explained",
                "content": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        arr = [pref[0]]\\n        for i in range(1,len(pref)):\\n            arr.append(pref[i-1]^pref[i])\\n        return arr\\n```\\nWe know ```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]``` which means ```pref[i-1] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]``` so ```pref[i] = pref[i-1] ^ arr[i]```. Let\\'s XOR with ```pref[i-1]``` on either side, so ```pref[i-1] ^ pref[i] = pref[i-1] ^ pref[i-1] ^ arr[i]```. Anything XOR itself is 1, so this means that ```arr[i] = pref[i-1] ^ pref[i]```!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        arr = [pref[0]]\\n        for i in range(1,len(pref)):\\n            arr.append(pref[i-1]^pref[i])\\n        return arr\\n```\n```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\n```pref[i-1] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]```\n```pref[i] = pref[i-1] ^ arr[i]```\n```pref[i-1]```\n```pref[i-1] ^ pref[i] = pref[i-1] ^ pref[i-1] ^ arr[i]```\n```arr[i] = pref[i-1] ^ pref[i]```",
                "codeTag": "Python3"
            },
            {
                "id": 2679120,
                "title": "python-easy-single-line",
                "content": "```python\\n\\nclass Solution:\\n\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        res=[pref[0]]\\n        for i in range(1,len(pref)):\\n            res.append(pref[i]^pref[i-1])\\n        return res\\n        \\n\\t\\t#single line\\n\\t\\t\\n\\t\\t    return [pref[0]]+[pref[i]^pref[i-1] for i in range(1,len(pref))]\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\n\\t\\n\\t\\n***u have came this far please upvote my prend***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\n\\nclass Solution:\\n\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        res=[pref[0]]\\n        for i in range(1,len(pref)):\\n            res.append(pref[i]^pref[i-1])\\n        return res\\n        \\n\\t\\t#single line\\n\\t\\t\\n\\t\\t    return [pref[0]]+[pref[i]^pref[i-1] for i in range(1,len(pref))]\\n\\t\\t\\t\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679115,
                "title": "rust-prefix-xor-with-comments",
                "content": "This is my unrevised submission for the 2022-10-09 Weekly Contest 314. An element of `pref` is the corresponding element of the originial array (`arr`), XORed with all the previous elements of `arr`, i.e. the previous `pref` entry.\\n\\nComment: I could have done the simpler `pref[i] = pref[i-1]` in retrospect, but this works fine too.\\n\\n```\\nimpl Solution {\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> {\\n        let mut arr = vec![0; pref.len()];\\n        let mut bm = 0;\\n        for i in 0..pref.len() {\\n            arr[i] = pref[i] ^ bm;\\n            bm ^= arr[i];\\n        }\\n        arr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_array(pref: Vec<i32>) -> Vec<i32> {\\n        let mut arr = vec![0; pref.len()];\\n        let mut bm = 0;\\n        for i in 0..pref.len() {\\n            arr[i] = pref[i] ^ bm;\\n            bm ^= arr[i];\\n        }\\n        arr\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679043,
                "title": "c-bit-manupulation-easily-explained-theory-behind-it",
                "content": "```\\n\\u2705 C++ || bit- manupulation\\nApproach:- If a^b=c, then a^c=b, this is the concept behind the question :)\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        int n=p.size();\\n        vector<int> ans(n);\\n        ans[0]=p[0];\\n        int xorr=ans[0];\\n        for(int i=1;i<n;i++){\\n            ans[i]=(xorr^p[i]);\\n            xorr=(xorr^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\u2705 C++ || bit- manupulation\\nApproach:- If a^b=c, then a^c=b, this is the concept behind the question :)\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& p) {\\n        int n=p.size();\\n        vector<int> ans(n);\\n        ans[0]=p[0];\\n        int xorr=ans[0];\\n        for(int i=1;i<n;i++){\\n            ans[i]=(xorr^p[i]);\\n            xorr=(xorr^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678955,
                "title": "c-simple-and-easiest-approach-3-line-code",
                "content": "\\nvector<int> findArray(vector<int>& pref) {\\n        \\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i = 0 ; i < pref.size()-1 ;i++){\\n            int yes = pref[i] xor pref[i+1];\\n            ans.push_back(yes);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\nvector<int> findArray(vector<int>& pref) {\\n        \\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i = 0 ; i < pref.size()-1 ;i++){\\n            int yes = pref[i] xor pref[i+1];\\n            ans.push_back(yes);\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}",
                "codeTag": "Unknown"
            },
            {
                "id": 2678946,
                "title": "go-simple-solution",
                "content": "```\\nfunc findArray(pref []int) []int {\\n\\tans := make([]int, len(pref))\\n\\tans[0] = pref[0]\\n\\tfor i := 1; i < len(pref); i++ {\\n\\t\\tans[i] = pref[i-1] ^ pref[i]\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findArray(pref []int) []int {\\n\\tans := make([]int, len(pref))\\n\\tans[0] = pref[0]\\n\\tfor i := 1; i < len(pref); i++ {\\n\\t\\tans[i] = pref[i-1] ^ pref[i]\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678892,
                "title": "xor-i-pref-i-pref-i-1-easy",
                "content": "Space - O(n)\\n```\\npublic int[] findArray(int[] pref) {\\n        int[] xor = new int[pref.length];\\n        xor[0] = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            xor[i] = pref[i]^pref[i-1];\\n        }\\n        return xor;\\n    }\\n```\\n\\n\\n\\nSpace- O(1)\\n```\\npublic int[] findArray(int[] pref) {\\n        for(int i=pref.length-1;i>0;i--){\\n            pref[i] = pref[i]^pref[i-1];\\n        }\\n        return pref;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] findArray(int[] pref) {\\n        int[] xor = new int[pref.length];\\n        xor[0] = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            xor[i] = pref[i]^pref[i-1];\\n        }\\n        return xor;\\n    }\\n```\n```\\npublic int[] findArray(int[] pref) {\\n        for(int i=pref.length-1;i>0;i--){\\n            pref[i] = pref[i]^pref[i-1];\\n        }\\n        return pref;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678887,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        ll n=pref.size();\\n        vi(int)ans(n);\\n        ans[0]=pref[0];\\n        for(ll i=1;i<n;++i){\\n            ans[i]=pref[i-1]^pref[i];\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        ll n=pref.size();\\n        vi(int)ans(n);\\n        ans[0]=pref[0];\\n        for(ll i=1;i<n;++i){\\n            ans[i]=pref[i-1]^pref[i];\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678864,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans=new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<=pref.length-1;i++)\\n            ans[i]=pref[i-1]^pref[i];\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans=new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<=pref.length-1;i++)\\n            ans[i]=pref[i-1]^pref[i];\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678846,
                "title": "xor-inverse-is-xor-itself",
                "content": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        n = len(pref)\\n        return [pref[0]] + [pref[i] ^ pref[i - 1] for i in range(1, n)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        n = len(pref)\\n        return [pref[0]] + [pref[i] ^ pref[i - 1] for i in range(1, n)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678819,
                "title": "find-the-original-array-of-prefix-xor-c-solution-easy-solution-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size());\\n        ans[0] = pref[0];\\n        for(int i=1; i<pref.size(); i++)\\n            ans[i] = pref[i]^pref[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size());\\n        ans[0] = pref[0];\\n        for(int i=1; i<pref.size(); i++)\\n            ans[i] = pref[i]^pref[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678814,
                "title": "python-clean-and-easy-approach",
                "content": "```\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        res = []\\n        n = 0\\n        for pre in pref:\\n            res.append(n^pre)\\n            n = pre\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        res = []\\n        n = 0\\n        for pre in pref:\\n            res.append(n^pre)\\n            n = pre\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2678805,
                "title": "python-4-lines-prefix-xor",
                "content": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n\\tres = [pref[0]]\\n\\tfor i in range(1,len(pref)):\\n\\t\\tres.append(pref[i]^pref[i-1])\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n\\tres = [pref[0]]\\n\\tfor i in range(1,len(pref)):\\n\\t\\tres.append(pref[i]^pref[i-1])\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2678799,
                "title": "java-solution-with-explanation-o-n",
                "content": "Few things you should know about XOR,\\n0 ^ a = a\\na ^ a = 0\\n(a ^ b) ^ c = a ^ (b ^ c)\\na ^ b ^ c = a ^ c ^ b\\n\\nif you use these 4 rules, you can solve this problem by keeping track of XOR until prev position, say it\\'s Y\\nSince at position i, you want the final compute to be equal to prevf[i], the ans will the Y ^ pref[i] so that when you xor this with the prev result, i.e Y, you will get the same number\\n\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int len = pref.length;\\n        int[] ans = new int[len];\\n        ans[0] = pref[0];\\n        \\n        for(int i = 1, curr = ans[0]; i < len; i++) {\\n            ans[i] = (curr ^ pref[i]);\\n            curr = (curr ^ ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int len = pref.length;\\n        int[] ans = new int[len];\\n        ans[0] = pref[0];\\n        \\n        for(int i = 1, curr = ans[0]; i < len; i++) {\\n            ans[i] = (curr ^ pref[i]);\\n            curr = (curr ^ ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678793,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans=new int[pref.length];\\n        ans[0]=pref[0];\\n        int xor=ans[0];\\n        for(int i=1;i<pref.length;i++){            \\n            ans[i]=xor^pref[i];\\n            xor=xor^ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans=new int[pref.length];\\n        ans[0]=pref[0];\\n        int xor=ans[0];\\n        for(int i=1;i<pref.length;i++){            \\n            ans[i]=xor^pref[i];\\n            xor=xor^ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091258,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1; i<pref.size(); i++)  ans.push_back(pref[i-1]^pref[i]);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1; i<pref.size(); i++)  ans.push_back(pref[i-1]^pref[i]);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088975,
                "title": "2433",
                "content": "# Intuition\\nActually 2 XOR 5 = 7, meanwhile, 7 XOR 5 = 2. It is same\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int []ans = new int[pref.length];\\n        ans[0] = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[i] = pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int []ans = new int[pref.length];\\n        ans[0] = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[i] = pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088118,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na^b=c\\na^c=b\\nc^b=a\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        //a^b=c\\n        //a^c=b\\n        //c^b=a\\n        int ans[] = new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++)\\n        {\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        //a^b=c\\n        //a^c=b\\n        //c^b=a\\n        int ans[] = new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++)\\n        {\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086903,
                "title": "xor-attribute-xor-previous-first-and-process-next-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nXOR attribute XOR first to process next element.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ret = []\\n        a = 0\\n        for i in range(len(pref)):\\n            ret.append(pref[i] ^ a)\\n            a = pref[i] ^ a\\n            if i > 0:\\n                a ^= pref[i-1]\\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ret = []\\n        a = 0\\n        for i in range(len(pref)):\\n            ret.append(pref[i] ^ a)\\n            a = pref[i] ^ a\\n            if i > 0:\\n                a ^= pref[i-1]\\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086446,
                "title": "1-line-solution-with-python-std-lib",
                "content": "It\\'s curious that even so short it beats 99.5% in runtime.\\n\\nTo understand this functions read:\\nhttps://docs.python.org/3/library/itertools.html#itertools.pairwise\\nhttps://docs.python.org/3/library/itertools.html#itertools.starmap\\n\\n# Complexity\\nTime and space complexity in O(n)\\n\\n# Code\\n```\\nfrom itertools import pairwise, starmap\\nfrom operator import xor\\n\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        return [pref[0]] + list(starmap(xor, pairwise(pref)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import pairwise, starmap\\nfrom operator import xor\\n\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        return [pref[0]] + list(starmap(xor, pairwise(pref)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079968,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(pref)==1 or len(pref)==0:\\n            return pref\\n        else:\\n            new_pref = []\\n            new_pref.append(pref[0])\\n            for i in range(len(pref)-1):\\n                new_pref.append(pref[i] ^ pref[i+1])\\n            return new_pref\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(pref)==1 or len(pref)==0:\\n            return pref\\n        else:\\n            new_pref = []\\n            new_pref.append(pref[0])\\n            for i in range(len(pref)-1):\\n                new_pref.append(pref[i] ^ pref[i+1])\\n            return new_pref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079896,
                "title": "typescript-bit-manipulation",
                "content": "# Approach\\nif a^b =c\\nthen a^c=b\\n\\n# Code\\n```\\nfunction findArray(pref: number[]): number[] {\\n    let xor = pref[0];\\n    for (let i = 1; i < pref.length; i++) {\\n        pref[i] = xor ^ pref[i];\\n        xor = xor ^ pref[i];\\n    }\\n    return pref;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction findArray(pref: number[]): number[] {\\n    let xor = pref[0];\\n    for (let i = 1; i < pref.length; i++) {\\n        pref[i] = xor ^ pref[i];\\n        xor = xor ^ pref[i];\\n    }\\n    return pref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075590,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        arr=[pref[0]]\\n        index=0\\n        for i in range(1,len(pref)):\\n            index=index^arr[i-1]\\n            arr.append(index^pref[i])\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        arr=[pref[0]]\\n        index=0\\n        for i in range(1,len(pref)):\\n            index=index^arr[i-1]\\n            arr.append(index^pref[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075199,
                "title": "a-mathematical-proof-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe trick here is knowing that XOR is self inverting. From here, we can essentially prove why the given code works.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClaim: For any $n > 0$, we can obtain the $n$th element of the original sequence by XORing the $n$th and $(n-1)$th element of the new sequence. \\n\\nProof:Assume we had some sequence of nonnegative integers $a_n$ and some sequence $b_n$ such that the following holds for $n > 0$:\\n$b_n = a_0 \\\\bigoplus a_2 \\\\cdots \\\\bigoplus a_n$\\nWhere $\\\\bigoplus$ is binary XOR.\\nThen, the following holds by commutivaty and associativity of XOR, for $n > 0$:\\n$$\\n\\\\begin{align}\\nb_n \\\\bigoplus b_{n-1} &= (a_0 \\\\bigoplus a_2 \\\\cdots \\\\bigoplus a_n) \\\\bigoplus (a_0 \\\\bigoplus a_2 \\\\cdots \\\\bigoplus a_{n-1})\\\\\\\\\\n&= (a_0 \\\\bigoplus a_0) \\\\bigoplus \\\\cdots (a_{n-1} \\\\bigoplus a_{n-1}) \\\\bigoplus a_n \\\\\\\\\\n&= 0 \\\\bigoplus a_n\\n&= a_n\\n\\\\end{align} \\n$$\\nThus, we can obtain the original sequence $a_n$ by performing $b_n \\\\bigoplus b_{n-1}$. \\n$\\\\square$\\nThis proof isn\\'t as formal as it could be, but it shows fundamentally why this approach works. XOR of binary strings of the same length forms a commutative group, with identity $0$ and every element being self inverting. If you\\'re interested in how this stuff works mathematically, I reccommend reading Artin\\'s Algebra.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), a nice linear approach.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), uses practically nothing since this solution is in place :).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n\\n        for (int i = pref.size() - 1; i > 0; i--){\\n            pref[i] ^= pref[i-1];\\n        }\\n\\n        return pref;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n\\n        for (int i = pref.size() - 1; i > 0; i--){\\n            pref[i] ^= pref[i-1];\\n        }\\n\\n        return pref;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072587,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        int curr =  pref[0];\\n        ans[0] =  curr;\\n        for(int i=1; i<pref.length; i++){\\n            ans[i] =  pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        int curr =  pref[0];\\n        ans[0] =  curr;\\n        for(int i=1; i<pref.length; i++){\\n            ans[i] =  pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072382,
                "title": "c-in-place-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for (int i = pref.size() - 1; i > 0; i--)\\n        {\\n            pref[i] = pref[i] ^ pref[i - 1];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        for (int i = pref.size() - 1; i > 0; i--)\\n        {\\n            pref[i] = pref[i] ^ pref[i - 1];\\n        }\\n        return pref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071331,
                "title": "best-method-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n);\\n        ans[0]=pref[0];\\n         for(int i=1;i<n;i++){\\n             int c=pref[i-1]^pref[i];\\n           ans[i]=c;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n);\\n        ans[0]=pref[0];\\n         for(int i=1;i<n;i++){\\n             int c=pref[i-1]^pref[i];\\n           ans[i]=c;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068713,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        prev = pref[0]\\n        for i in range(1, len(pref)):\\n            curr = pref[i]\\n            pref[i] = prev ^ curr\\n            prev = curr\\n\\n        return pref\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        prev = pref[0]\\n        for i in range(1, len(pref)):\\n            curr = pref[i]\\n            pref[i] = prev ^ curr\\n            prev = curr\\n\\n        return pref\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066235,
                "title": "python-runtime-o-n-memory-o-1",
                "content": "Key: x^y = z, x^z = y\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [pref[0]]\\n        for i in range(1, len(pref)):\\n            ans.append(pref[i-1]^pref[i])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        ans = [pref[0]]\\n        for i in range(1, len(pref)):\\n            ans.append(pref[i-1]^pref[i])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057931,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n        arr[0]=pref[0];\\n        int val=arr[0];\\n        for(int i=1;i<arr.length;i++)\\n        {\\n           arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int arr[]=new int[pref.length];\\n        arr[0]=pref[0];\\n        int val=arr[0];\\n        for(int i=1;i<arr.length;i++)\\n        {\\n           arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055425,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\na^b=c\\nc^a=b\\ntherefore pref[n]=arr[0]^arr[1]......^arr[n]\\n          pref[n-1]=arr[0]......^arr[n-1]\\n          pref[n]=arr[n-1]^arr[n]\\n          arr[n]=arr[n-1]^pref[n]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        if(pref.length==0||pref.length==1){\\n            return pref;\\n        }\\n        int arr[] = new int[pref.length];\\n        int x=pref[pref.length-1];\\n        arr[0]=pref[0];\\n        for(int i=pref.length-1;i>0;i--){\\n            arr[i]=pref[i-1]^pref[i];\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        if(pref.length==0||pref.length==1){\\n            return pref;\\n        }\\n        int arr[] = new int[pref.length];\\n        int x=pref[pref.length-1];\\n        arr[0]=pref[0];\\n        for(int i=pref.length-1;i>0;i--){\\n            arr[i]=pref[i-1]^pref[i];\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051368,
                "title": "simple-xor-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] result = new int[pref.length];\\n\\n        result[0] = pref[0];\\n\\n        for(int i=1;i<pref.length;i++){\\n          result[i] = pref[i-1]^pref[i];\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] result = new int[pref.length];\\n\\n        result[0] = pref[0];\\n\\n        for(int i=1;i<pref.length;i++){\\n          result[i] = pref[i-1]^pref[i];\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049426,
                "title": "python3-one-pass-in-place",
                "content": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        for i in range(len(pref)-1, 0, -1):\\n            pref[i] = pref[i] ^ pref[i-1]\\n        return pref\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        for i in range(len(pref)-1, 0, -1):\\n            pref[i] = pref[i] ^ pref[i-1]\\n        return pref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048004,
                "title": "1-line-solution-with-explanation-c-bit-manipulation-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn interesting property of XOR operator is that for two number a and b, if a^b = c, then  b = c^a is true and a = c^b is true. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing this property, for each index of the prefix array, we think of the array elements before that particular index as A i.e pref[i-1] and the value of C as pref[i].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans = {pref[0]};\\n        for(int i= 1; i<pref.size();i++) ans.push_back(pref[i]^pref[i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans = {pref[0]};\\n        for(int i= 1; i<pref.size();i++) ans.push_back(pref[i]^pref[i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043075,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUsing a simple xor property\\na^b=c  a^c=b  b^c=a\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        if(pref.size()==1){\\n            return pref;\\n        }\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            ans.push_back(pref[i]^pref[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        if(pref.size()==1){\\n            return pref;\\n        }\\n        vector<int>ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            ans.push_back(pref[i]^pref[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035336,
                "title": "2-lines-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        c=pref[0]\\n        for i in range(1,len(pref)):pref[i],c=c^pref[i],pref[i]\\n        return pref\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        c=pref[0]\\n        for i in range(1,len(pref)):pref[i],c=c^pref[i],pref[i]\\n        return pref\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035074,
                "title": "brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        int sum=0;\\n        if(pref.size()==1){\\n            return pref;\\n        }\\n        for(int i=0;i<pref.size();i++){\\n            if(i==0){\\n                ans.push_back(pref[i]);\\n                sum=sum^ans[i];\\n            }\\n            else{\\n                int a=sum^pref[i];\\n                ans.push_back(a);\\n                sum=sum^ans[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        int sum=0;\\n        if(pref.size()==1){\\n            return pref;\\n        }\\n        for(int i=0;i<pref.size();i++){\\n            if(i==0){\\n                ans.push_back(pref[i]);\\n                sum=sum^ans[i];\\n            }\\n            else{\\n                int a=sum^pref[i];\\n                ans.push_back(a);\\n                sum=sum^ans[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034102,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int ans=0;\\n        vector<int> a;\\n        a.push_back(pref[0]);\\n        for(int i=0;i<pref.size()-1;i++){\\n            a.push_back(pref[i]^pref[i+1]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        int ans=0;\\n        vector<int> a;\\n        a.push_back(pref[0]);\\n        for(int i=0;i<pref.size()-1;i++){\\n            a.push_back(pref[i]^pref[i+1]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032087,
                "title": "python3-solution-with-o-n-time-and-o-1-space-beats-91-14-runtime-and-88-08-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        \\n        temp2 = pref[0]\\n        for i in range(1,len(pref),1):\\n            temp1 = pref[i]\\n            pref[i] = temp2 ^ pref[i]\\n            temp2 = temp1\\n        return pref\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        \\n        temp2 = pref[0]\\n        for i in range(1,len(pref),1):\\n            temp1 = pref[i]\\n            pref[i] = temp2 ^ pref[i]\\n            temp2 = temp1\\n        return pref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027538,
                "title": "easy-java-solution-runtime-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I first read this problem, I was very much unsure how to approach this. I tried different permutations and combinations, when I stumbled upon the most intuitive solution. It is actually very simple, which I have written below\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe have been given an array `pref` where \\n\\n```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\\n\\nAnd we need to find the original array `arr`.\\n\\nWhile trying different approaches, I came across a very simple math. For this approach, we actually need 2 properties:\\n\\n* `n ^ n = 0`\\n* `n ^ 0 = n`\\n\\nGiven, that for the array `pref`, \\n\\n```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\\n\\nConcluding from this,\\n\\n```pref[i-1] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]```\\n\\nSo if we calculate `pref[i] ^ pref[i-1]`, and substituting the values of the 2 equations, we are left with `arr[i]`. \\n\\nPlease do the calculations yourself (Hint: Use the 2 properties I discussed)\\n\\nUsing this approach, we can easily find out the original array `arr`.\\n\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n\\n        arr[0] = pref[0];\\n\\n        for(int i=1;i<n;i++) {\\n            arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\n```pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]```\n```pref[i-1] = arr[0] ^ arr[1] ^ ... ^ arr[i-1]```\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n\\n        arr[0] = pref[0];\\n\\n        for(int i=1;i<n;i++) {\\n            arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025363,
                "title": "easy-java-solution-bit-manipulation",
                "content": "# Intuition\\neasy understandable code \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr=new int[pref.length];\\n        arr[0]=pref[0];\\n        int xor=arr[0];\\n        for(int i=1;i<pref.length;i++){\\n            arr[i]=xor^pref[i];\\n            xor=xor^arr[i];\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr=new int[pref.length];\\n        arr[0]=pref[0];\\n        int xor=arr[0];\\n        for(int i=1;i<pref.length;i++){\\n            arr[i]=xor^pref[i];\\n            xor=xor^arr[i];\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019740,
                "title": "java-and-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Java\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int [pref.length];\\n        ans[0] = pref[0];\\n        for(int i = 1; i< pref.length; i++){\\n            ans[i] = pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# Python\\n```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        lst = list()\\n        lst.append(pref[0])\\n        for i in range(1, len(pref)):\\n            lst.append(pref[i-1] ^ pref[i])\\n        return lst\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int [pref.length];\\n        ans[0] = pref[0];\\n        for(int i = 1; i< pref.length; i++){\\n            ans[i] = pref[i] ^ pref[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\ndef findArray(self, pref: List[int]) -> List[int]:\\n        lst = list()\\n        lst.append(pref[0])\\n        for i in range(1, len(pref)):\\n            lst.append(pref[i-1] ^ pref[i])\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019628,
                "title": "easy-solution-using-xor-property",
                "content": "# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                ans[0]=pref[0];\\n            else\\n                ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      vector<int> findArray(vector<int>& pref) {\\n        int n=pref.size();\\n        vector<int>ans(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0)\\n                ans[0]=pref[0];\\n            else\\n                ans[i]=pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015783,
                "title": "fast-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size(),0);\\n        ans[0] = pref[0];\\n        for(int i=1; i<pref.size(); i++){\\n            ans[i] = pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size(),0);\\n        ans[0] = pref[0];\\n        for(int i=1; i<pref.size(); i++){\\n            ans[i] = pref[i]^pref[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015444,
                "title": "simple-python-solution-based-on-easy-intuition",
                "content": "# Intuition\\nWe have used some basic facts abot the XOR operation to solve this problem.\\n\\n# Approach\\nSome facts about xor:\\na ^ b = X\\nX ^ a = b\\nX ^ b = a\\n\\n# Complexity\\n- Time complexity:\\nWorst case: O(n^2)\\n\\n- Space complexity:\\nO(len(pref))\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0] * len(pref)\\n        for i in range(len(pref)):\\n            if i == 0:\\n                ans[i] = pref[i]\\n            else:\\n                ans[i] = (pref[i] ^ pref[i-1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findArray(self, pref):\\n        \"\"\"\\n        :type pref: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        ans = [0] * len(pref)\\n        for i in range(len(pref)):\\n            if i == 0:\\n                ans[i] = pref[i]\\n            else:\\n                ans[i] = (pref[i] ^ pref[i-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015053,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int arr[] = new int[n];\\n\\n        arr[0] = pref[0];\\n        \\n        for(int i=1;i<n;++i)\\n        {\\n           arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int arr[] = new int[n];\\n\\n        arr[0] = pref[0];\\n        \\n        for(int i=1;i<n;++i)\\n        {\\n           arr[i] = pref[i]^pref[i-1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014458,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n\\n        vector<int>ans(pref.size());\\n        ans[0]=pref[0];\\n\\n        for(int i=1;i<pref.size();i++)\\n        {\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n\\n        vector<int>ans(pref.size());\\n        ans[0]=pref[0];\\n\\n        for(int i=1;i<pref.size();i++)\\n        {\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008595,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n        int temp = 0;\\n        for(int i=0; i<pref.length-1; i++){\\n            temp = temp ^ arr[i];\\n            arr[i+1] = temp ^ pref[i+1];\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n        int temp = 0;\\n        for(int i=0; i<pref.length-1; i++){\\n            temp = temp ^ arr[i];\\n            arr[i+1] = temp ^ pref[i+1];\\n        }\\n        return arr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006684,
                "title": "you-cannot-get-more-simpler-code-than-this-very-very-very-easyyyy",
                "content": "**Plzzzzzzzzzzz Uppppvoteeeeeeeee \\uD83E\\uDD7A**\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr=new int[pref.length];\\n        arr[0]=pref[0];\\n        for (int i = 1; i < pref.length; i++) {\\n            arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr=new int[pref.length];\\n        arr[0]=pref[0];\\n        for (int i = 1; i < pref.length; i++) {\\n            arr[i]=pref[i]^pref[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004864,
                "title": "ind-the-original-array-of-prefix-xor-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        a=[pref[0]]\\n        for i in range(len(pref)-1):\\n            a.append(pref[i]^pref[i+1])\\n        return a\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        a=[pref[0]]\\n        for i in range(len(pref)-1):\\n            a.append(pref[i]^pref[i+1])\\n        return a\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998010,
                "title": "quick-solve-bitwise-operator-bit-manipulation-handling",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n\\n        for(int i=1; i<pref.length; i++){\\n            arr[i] = pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n\\n        for(int i=1; i<pref.length; i++){\\n            arr[i] = pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981215,
                "title": "c-super-easy-to-understand-solution",
                "content": "# Intuition\\nThe intuition behind this solution is to generate a new array where each element is the XOR of consecutive elements from the input array.\\n\\n# Approach\\nThe approach to solving this problem involves iterating through the input array and applying the XOR operation between consecutive elements. The result of each XOR operation is added to the resulting array. To initialize the resulting array, the first element from the input array is directly added to it. Then, in the loop, the XOR of the current element and the next element is calculated, and the result is pushed into the resulting array. The resulting array is then returned as the answer.\\n\\n# Complexity\\n- Time complexity: **O(n)**  \\n  The time complexity is determined by the loop that iterates through the input array, where each iteration involves constant-time XOR operations.\\n\\n- Space complexity: **O(n)**  \\n  The space complexity is determined by the space used to store the resulting array, which has the same size as the input array.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> res;\\n        res.push_back(pref[0]);\\n        int result = 0;\\n        for (int i = 0; i < pref.size() - 1; i++) {\\n            result = pref[i] ^ pref[i + 1];\\n            res.push_back(result);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> res;\\n        res.push_back(pref[0]);\\n        int result = 0;\\n        for (int i = 0; i < pref.size() - 1; i++) {\\n            result = pref[i] ^ pref[i + 1];\\n            res.push_back(result);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973673,
                "title": "simple-c-solultion",
                "content": "# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* findArray(int* pref, int prefSize, int* returnSize){\\n    int *ret = malloc(sizeof(int)*prefSize);\\n    *returnSize = prefSize;\\n    for (int i = prefSize-1; i > 0; i--)\\n    {\\n        ret[i] = pref[i] ^ pref[i-1];\\n    }\\n    ret[0] = pref[0];\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* findArray(int* pref, int prefSize, int* returnSize){\\n    int *ret = malloc(sizeof(int)*prefSize);\\n    *returnSize = prefSize;\\n    for (int i = prefSize-1; i > 0; i--)\\n    {\\n        ret[i] = pref[i] ^ pref[i-1];\\n    }\\n    ret[0] = pref[0];\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969764,
                "title": "very-easy-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int[] findArray(int[] pref)\\n    {\\n        int n=pref.length;\\n        int arr[]=new int[n];\\n        arr[0]=pref[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] findArray(int[] pref)\\n    {\\n        int n=pref.length;\\n        int arr[]=new int[n];\\n        arr[0]=pref[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            arr[i]=pref[i-1]^pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965798,
                "title": "general-xor-property",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int res[] = new int[pref.length];\\n        res[0] = pref[0];\\n        for(int i = 1 ; i < pref.length ; i++){\\n            int cur = pref[i];\\n            int temp = cur^pref[i-1];\\n            res[i]= temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int res[] = new int[pref.length];\\n        res[0] = pref[0];\\n        for(int i = 1 ; i < pref.length ; i++){\\n            int cur = pref[i];\\n            int temp = cur^pref[i-1];\\n            res[i]= temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958972,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        a = [pref[0]]\\n        for i in range(len(pref)-1):\\n            a.append(pref[i]^pref[i+1])\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        a = [pref[0]]\\n        for i in range(len(pref)-1):\\n            a.append(pref[i]^pref[i+1])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942866,
                "title": "easy-solution-for-beginners-o-n-time-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. pref[1] = arr[0] ^ arr[1] (arr is an array which we have to return ).\\n2. let pref[1] = b , arr[0] = a and arr[1] = x which we have to find so, b = a ^ x (we need to remove a from right side do we can find the value of x).\\n3. a ^ b = a ^ a ^ x (a ^ a = 0)\\n4. a ^ b = x (because xor of same no is equal to 0 and 0 xor a  = a)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/7e9ec807-5ff1-433e-aeb5-824ea92257d2_1692653564.3162503.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] findArray(int[] pref) \\n    {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n        for (int i = 1; i < pref.length; ++i)\\n        {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] findArray(int[] pref) \\n    {\\n        int[] arr = new int[pref.length];\\n        arr[0] = pref[0];\\n        for (int i = 1; i < pref.length; ++i)\\n        {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941670,
                "title": "find-the-original-array-of-prefix-xor-my-approach-java",
                "content": "Simple Maths...\\n\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int ans[]=new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nUpvote if you like it.\\nComment out your approach of solving this problem...",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int ans[]=new int[pref.length];\\n        ans[0]=pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[i]=pref[i]^pref[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941130,
                "title": "c-short-and-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        int size = pref.size();\\n        vector<int> arr(size);\\n        arr[0] = pref[0];\\n        for(int i = 1; i < size; ++i)\\n        {\\n            arr[i] = pref[i] ^ pref[i - 1];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) \\n    {\\n        int size = pref.size();\\n        vector<int> arr(size);\\n        arr[0] = pref[0];\\n        for(int i = 1; i < size; ++i)\\n        {\\n            arr[i] = pref[i] ^ pref[i - 1];\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940187,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- a ^ b = c and a ^ c = b\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] FindArray(int[] pref) {\\n        int[] arr = new int[pref.Length];\\n\\n        arr[0] = pref[0];\\n\\n        for(int i = 1; i < pref.Length; i++)\\n        {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindArray(int[] pref) {\\n        int[] arr = new int[pref.Length];\\n\\n        arr[0] = pref[0];\\n\\n        for(int i = 1; i < pref.Length; i++)\\n        {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938410,
                "title": "ruby-one-liner",
                "content": "```\\ndef find_array(pref)\\n  [pref[0]] + (1...pref.size).map{|i| (pref[i-1]^pref[i])}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef find_array(pref)\\n  [pref[0]] + (1...pref.size).map{|i| (pref[i-1]^pref[i])}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3930049,
                "title": "java-1ms-beats-100-00",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n\\n        int[] arr = new int[pref.length];  // what we\\'ll return\\n        arr[0] = pref[0];\\n\\n        for (int i = 1; i < pref.length; ++i) {\\n            arr[i] = pref[i] ^ pref[i - 1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n\\n        int[] arr = new int[pref.length];  // what we\\'ll return\\n        arr[0] = pref[0];\\n\\n        for (int i = 1; i < pref.length; ++i) {\\n            arr[i] = pref[i] ^ pref[i - 1];\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929847,
                "title": "easy-peasy-c-java-python-solution-o-n-space-and-time",
                "content": "# Idea\\npref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]. idea is to xor pref[i-1] both side and expand pref[i-1] on rhs and cancle out stuff on rhs.... \\n\\n# Intuition\\nThe problem can be solved using the properties of XOR operation. XORing two identical numbers results in 0 (x ^ x = 0), and XORing any number with 0 results in the number itself (x ^ 0 = x).\\n# Approach\\nThe idea is to iteratively construct the arr array based on the given pref array. Since pref[i] represents the XOR of all elements in arr up to index i, we can deduce the following relation: `arr[i] = pref[i] ^ pref[i-1] ^ ... ^ pref[0]`\\n \\nUsing this relation, we can construct the arr array by XORing adjacent elements of the pref array. Starting from index 0 of pref, we add the XOR of the current element and the previous element of pref to the arr array. This effectively recovers the individual elements of arr from the cumulative XOR values in pref.\\n# Complexity\\n- Time complexity:\\nThe loop iterates through the pref array once, performing constant time operations within each iteration. Thus, the time complexity is O(n), where n is the size of the pref array.\\n- Space complexity:\\nThe ans vector is the only additional data structure used, which has the same size as the input pref array. Hence, the space complexity is O(n).\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.emplace_back(pref[0]);\\n        for(int i = 1; i < pref.size(); i++)\\n        {\\n            ans.push_back(pref[i]^pref[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java\\n```class Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n        arr[0] = pref[0];\\n        for (int i = 1; i < n; i++) {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```\\n# Python\\n```class Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        n = len(pref)\\n        arr = [0] * n\\n        arr[0] = pref[0]\\n        for i in range(1, n):\\n            arr[i] = pref[i - 1] ^ pref[i]\\n        return arr\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int>ans;\\n        ans.emplace_back(pref[0]);\\n        for(int i = 1; i < pref.size(); i++)\\n        {\\n            ans.push_back(pref[i]^pref[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```class Solution {\\n    public int[] findArray(int[] pref) {\\n        int n = pref.length;\\n        int[] arr = new int[n];\\n        arr[0] = pref[0];\\n        for (int i = 1; i < n; i++) {\\n            arr[i] = pref[i - 1] ^ pref[i];\\n        }\\n        return arr;\\n    }\\n}\\n```\n```class Solution:\\n    def findArray(self, pref: List[int]) -> List[int]:\\n        n = len(pref)\\n        arr = [0] * n\\n        arr[0] = pref[0]\\n        for i in range(1, n):\\n            arr[i] = pref[i - 1] ^ pref[i]\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925975,
                "title": "c-solution-using-xor-property",
                "content": "# Intuition\\ngiven:\\n    a^b = c , Property(a^b = c means ,=> a^c = b)\\nProof:\\n    a^b^a = c^a (XOR both sides with a)\\n    (a^a)^b = c^a (We can group the XOR)\\n    0^b = c^a (Property a^a = 0)\\n\\n## Build the code using the above logic and if you are not clear, then look at the code.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N) - Output array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size());\\n        ans[0] = pref[0];\\n        int val = pref[0];\\n        for(int i=1;i<pref.size();i++) {\\n            ans[i]=(val^pref[i]);\\n            val = val^ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans(pref.size());\\n        ans[0] = pref[0];\\n        int val = pref[0];\\n        for(int i=1;i<pref.size();i++) {\\n            ans[i]=(val^pref[i]);\\n            val = val^ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913718,
                "title": "2433-find-the-original-array-of-prefix-xor",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            int temp;\\n            temp = pref[i]^pref[i-1];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& pref) {\\n        vector<int> ans;\\n        ans.push_back(pref[0]);\\n        for(int i=1;i<pref.size();i++){\\n            int temp;\\n            temp = pref[i]^pref[i-1];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912808,
                "title": "just-xor-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        int num = pref[0];\\n        ans[0] = pref[0];\\n        int idx=1;\\n        int prev = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[idx++]=prev^pref[i];\\n            prev = pref[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findArray(int[] pref) {\\n        int[] ans = new int[pref.length];\\n        int num = pref[0];\\n        ans[0] = pref[0];\\n        int idx=1;\\n        int prev = pref[0];\\n        for(int i=1;i<pref.length;i++){\\n            ans[idx++]=prev^pref[i];\\n            prev = pref[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1638669,
                "content": [
                    {
                        "username": "acerunner",
                        "content": "I think the key to solving this is recognizing this property of the XOR (^):\\n\\nif a ^ b = c then a ^ c = b\\n\\nWhy? \\n\\n```\\na ^ b             = c  then \\nc ^ (a ^ b)       = c ^ c then     \\nc ^ (a ^ b) ^ b   = 0 ^ b then\\n(c ^ a) ^ (b ^ b) = b then \\na ^ c = b\\n```\\nFor the above steps we must also know that XOR is \\nassociative: a ^ (b ^ c) = (a ^ b) ^ c\\nand commutative:  a ^ b = b ^ a\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Good template mate\\uD83D\\uDE4C"
                    },
                    {
                        "username": "pbyrnes_99",
                        "content": "To me this logic is simpler if you see that:\\n(1): XOR being associative and commutative means you can permute the elements of a XOR expression however you like\\n(2): a ^ a = 0\\n(3): a ^ 0 = a\\nThose three properties means you can look at a long chain in an XOR expression and drop pairs of the same element and rearrange the order of elements.\\n\\nSo, you can start with:\\na ^ b = c\\nand XOR both sides with b ^ c:\\n(a ^ b) ^ (b ^ c) = c ^ (b ^ c)\\na ^ c = b\\nHere the last step on the left is recognizing that the pair of b\\'s can be dropped.  And the last step on the right is recognizing the pair of c\\'s can be dropped."
                    },
                    {
                        "username": "eduard92",
                        "content": "I had \"Easy\" problems that were harder than this.."
                    },
                    {
                        "username": "wtain",
                        "content": "I think this problem should be marked as \"easy\" as long as it is pretty straightforward."
                    },
                    {
                        "username": "java_run",
                        "content": "Agreed \\uD83E\\uDD1D"
                    },
                    {
                        "username": "alokyes55",
                        "content": "solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int> v1;\\n        v1.push_back(nums[0]);\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            v1.push_back(nums[i]^nums[i+1]);\\n        }\\n        return v1;\\n        \\n    }\\n};```"
                    },
                    {
                        "username": "leetcancode",
                        "content": "With the given hint, I think this should be marked as easy."
                    }
                ]
            },
            {
                "id": 1803155,
                "content": [
                    {
                        "username": "acerunner",
                        "content": "I think the key to solving this is recognizing this property of the XOR (^):\\n\\nif a ^ b = c then a ^ c = b\\n\\nWhy? \\n\\n```\\na ^ b             = c  then \\nc ^ (a ^ b)       = c ^ c then     \\nc ^ (a ^ b) ^ b   = 0 ^ b then\\n(c ^ a) ^ (b ^ b) = b then \\na ^ c = b\\n```\\nFor the above steps we must also know that XOR is \\nassociative: a ^ (b ^ c) = (a ^ b) ^ c\\nand commutative:  a ^ b = b ^ a\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Good template mate\\uD83D\\uDE4C"
                    },
                    {
                        "username": "pbyrnes_99",
                        "content": "To me this logic is simpler if you see that:\\n(1): XOR being associative and commutative means you can permute the elements of a XOR expression however you like\\n(2): a ^ a = 0\\n(3): a ^ 0 = a\\nThose three properties means you can look at a long chain in an XOR expression and drop pairs of the same element and rearrange the order of elements.\\n\\nSo, you can start with:\\na ^ b = c\\nand XOR both sides with b ^ c:\\n(a ^ b) ^ (b ^ c) = c ^ (b ^ c)\\na ^ c = b\\nHere the last step on the left is recognizing that the pair of b\\'s can be dropped.  And the last step on the right is recognizing the pair of c\\'s can be dropped."
                    },
                    {
                        "username": "eduard92",
                        "content": "I had \"Easy\" problems that were harder than this.."
                    },
                    {
                        "username": "wtain",
                        "content": "I think this problem should be marked as \"easy\" as long as it is pretty straightforward."
                    },
                    {
                        "username": "java_run",
                        "content": "Agreed \\uD83E\\uDD1D"
                    },
                    {
                        "username": "alokyes55",
                        "content": "solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int> v1;\\n        v1.push_back(nums[0]);\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            v1.push_back(nums[i]^nums[i+1]);\\n        }\\n        return v1;\\n        \\n    }\\n};```"
                    },
                    {
                        "username": "leetcancode",
                        "content": "With the given hint, I think this should be marked as easy."
                    }
                ]
            },
            {
                "id": 1750280,
                "content": [
                    {
                        "username": "acerunner",
                        "content": "I think the key to solving this is recognizing this property of the XOR (^):\\n\\nif a ^ b = c then a ^ c = b\\n\\nWhy? \\n\\n```\\na ^ b             = c  then \\nc ^ (a ^ b)       = c ^ c then     \\nc ^ (a ^ b) ^ b   = 0 ^ b then\\n(c ^ a) ^ (b ^ b) = b then \\na ^ c = b\\n```\\nFor the above steps we must also know that XOR is \\nassociative: a ^ (b ^ c) = (a ^ b) ^ c\\nand commutative:  a ^ b = b ^ a\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Good template mate\\uD83D\\uDE4C"
                    },
                    {
                        "username": "pbyrnes_99",
                        "content": "To me this logic is simpler if you see that:\\n(1): XOR being associative and commutative means you can permute the elements of a XOR expression however you like\\n(2): a ^ a = 0\\n(3): a ^ 0 = a\\nThose three properties means you can look at a long chain in an XOR expression and drop pairs of the same element and rearrange the order of elements.\\n\\nSo, you can start with:\\na ^ b = c\\nand XOR both sides with b ^ c:\\n(a ^ b) ^ (b ^ c) = c ^ (b ^ c)\\na ^ c = b\\nHere the last step on the left is recognizing that the pair of b\\'s can be dropped.  And the last step on the right is recognizing the pair of c\\'s can be dropped."
                    },
                    {
                        "username": "eduard92",
                        "content": "I had \"Easy\" problems that were harder than this.."
                    },
                    {
                        "username": "wtain",
                        "content": "I think this problem should be marked as \"easy\" as long as it is pretty straightforward."
                    },
                    {
                        "username": "java_run",
                        "content": "Agreed \\uD83E\\uDD1D"
                    },
                    {
                        "username": "alokyes55",
                        "content": "solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int> v1;\\n        v1.push_back(nums[0]);\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            v1.push_back(nums[i]^nums[i+1]);\\n        }\\n        return v1;\\n        \\n    }\\n};```"
                    },
                    {
                        "username": "leetcancode",
                        "content": "With the given hint, I think this should be marked as easy."
                    }
                ]
            },
            {
                "id": 1725210,
                "content": [
                    {
                        "username": "acerunner",
                        "content": "I think the key to solving this is recognizing this property of the XOR (^):\\n\\nif a ^ b = c then a ^ c = b\\n\\nWhy? \\n\\n```\\na ^ b             = c  then \\nc ^ (a ^ b)       = c ^ c then     \\nc ^ (a ^ b) ^ b   = 0 ^ b then\\n(c ^ a) ^ (b ^ b) = b then \\na ^ c = b\\n```\\nFor the above steps we must also know that XOR is \\nassociative: a ^ (b ^ c) = (a ^ b) ^ c\\nand commutative:  a ^ b = b ^ a\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Good template mate\\uD83D\\uDE4C"
                    },
                    {
                        "username": "pbyrnes_99",
                        "content": "To me this logic is simpler if you see that:\\n(1): XOR being associative and commutative means you can permute the elements of a XOR expression however you like\\n(2): a ^ a = 0\\n(3): a ^ 0 = a\\nThose three properties means you can look at a long chain in an XOR expression and drop pairs of the same element and rearrange the order of elements.\\n\\nSo, you can start with:\\na ^ b = c\\nand XOR both sides with b ^ c:\\n(a ^ b) ^ (b ^ c) = c ^ (b ^ c)\\na ^ c = b\\nHere the last step on the left is recognizing that the pair of b\\'s can be dropped.  And the last step on the right is recognizing the pair of c\\'s can be dropped."
                    },
                    {
                        "username": "eduard92",
                        "content": "I had \"Easy\" problems that were harder than this.."
                    },
                    {
                        "username": "wtain",
                        "content": "I think this problem should be marked as \"easy\" as long as it is pretty straightforward."
                    },
                    {
                        "username": "java_run",
                        "content": "Agreed \\uD83E\\uDD1D"
                    },
                    {
                        "username": "alokyes55",
                        "content": "solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int> v1;\\n        v1.push_back(nums[0]);\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            v1.push_back(nums[i]^nums[i+1]);\\n        }\\n        return v1;\\n        \\n    }\\n};```"
                    },
                    {
                        "username": "leetcancode",
                        "content": "With the given hint, I think this should be marked as easy."
                    }
                ]
            },
            {
                "id": 2043904,
                "content": [
                    {
                        "username": "acerunner",
                        "content": "I think the key to solving this is recognizing this property of the XOR (^):\\n\\nif a ^ b = c then a ^ c = b\\n\\nWhy? \\n\\n```\\na ^ b             = c  then \\nc ^ (a ^ b)       = c ^ c then     \\nc ^ (a ^ b) ^ b   = 0 ^ b then\\n(c ^ a) ^ (b ^ b) = b then \\na ^ c = b\\n```\\nFor the above steps we must also know that XOR is \\nassociative: a ^ (b ^ c) = (a ^ b) ^ c\\nand commutative:  a ^ b = b ^ a\\n"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Good template mate\\uD83D\\uDE4C"
                    },
                    {
                        "username": "pbyrnes_99",
                        "content": "To me this logic is simpler if you see that:\\n(1): XOR being associative and commutative means you can permute the elements of a XOR expression however you like\\n(2): a ^ a = 0\\n(3): a ^ 0 = a\\nThose three properties means you can look at a long chain in an XOR expression and drop pairs of the same element and rearrange the order of elements.\\n\\nSo, you can start with:\\na ^ b = c\\nand XOR both sides with b ^ c:\\n(a ^ b) ^ (b ^ c) = c ^ (b ^ c)\\na ^ c = b\\nHere the last step on the left is recognizing that the pair of b\\'s can be dropped.  And the last step on the right is recognizing the pair of c\\'s can be dropped."
                    },
                    {
                        "username": "eduard92",
                        "content": "I had \"Easy\" problems that were harder than this.."
                    },
                    {
                        "username": "wtain",
                        "content": "I think this problem should be marked as \"easy\" as long as it is pretty straightforward."
                    },
                    {
                        "username": "java_run",
                        "content": "Agreed \\uD83E\\uDD1D"
                    },
                    {
                        "username": "alokyes55",
                        "content": "solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findArray(vector<int>& nums) {\\n        vector<int> v1;\\n        v1.push_back(nums[0]);\\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            v1.push_back(nums[i]^nums[i+1]);\\n        }\\n        return v1;\\n        \\n    }\\n};```"
                    },
                    {
                        "username": "leetcancode",
                        "content": "With the given hint, I think this should be marked as easy."
                    }
                ]
            }
        ]
    }
]