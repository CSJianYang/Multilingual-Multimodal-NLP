[
    {
        "title": "Remove Duplicates from Sorted List II",
        "question_content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,3,4,4,5]\nOutput: [1,2,5]\n\nExample 2:\n\nInput: head = [1,1,1,2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 300].\n\t-100 <= Node.val <= 100\n\tThe list is guaranteed to be sorted in ascending order.",
        "solutions": [
            {
                "id": 28335,
                "title": "my-accepted-java-code",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n            if(head==null) return null;\\n            ListNode FakeHead=new ListNode(0);\\n            FakeHead.next=head;\\n            ListNode pre=FakeHead;\\n            ListNode cur=head;\\n            while(cur!=null){\\n                while(cur.next!=null&&cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                if(pre.next==cur){\\n                    pre=pre.next;\\n                }\\n                else{\\n                    pre.next=cur.next;\\n                }\\n                cur=cur.next;\\n            }\\n            return FakeHead.next;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1395724,
                "title": "8-lines-c-solution-faster-than-100-submissions-for-beginners-explanation-of-approach",
                "content": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "first make a dummy node and assign its value equals to 0 and its next points to the head of the given linked list.\\nalso make a prev node and point it to the dummy node.\\n***Always remember that a prev node is always required wherever we have to delete a node or we have to break links and create new links . this thing is very important for beginner coders for developing their intusions in future. That\\'s not a rule i have said it on the basis of my coding expirience***.\\nThen you have to traverse the linked list so run a while loop.\\ncheck that if the two adjacent nodes are equal or not if the two adjacent nodes are equal then traverse trhe linked list upto ehen the adjacent nodes are not identical.\\nThen directly connect the link from prev->next to the head->next.\\nWhile in other case is the adjacent nodes are not equal then simply traverse the linked list by prev=prev->next.\\n\\n\\n\\n\\n ListNode* deleteDuplicates(ListNode* head) {\\n       \\n        ListNode *dummy=new ListNode(0,head);\\n           ListNode *prev=dummy;\\n            \\n            while(head!=NULL){\\n           \\n            if(head->next!=NULL && head->val==head->next->val){\\n                    \\n    while(head->next!=NULL && head->val==head->next->val)head=head->next;\\n                         \\n                       \\n                            prev->next=head->next;\\n                    }\\n                    \\n                    else prev=prev->next;\\n                           \\n                   \\n                    head=head->next;\\n            }\\n            \\n            return dummy->next;\\n                \\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t//if(you_like_and_understand_my_solution)\\n\\t\\t//{\\n\\t\\t//  please_upvote++;\\n\\t\\t// }\\n\\t\\t\\n\\t\\t/*Guys plz plz plz upvote my solution if you really like and understand it.and if you stuck at any point then feel free to comment*/.",
                "codeTag": "Unknown"
            },
            {
                "id": 28336,
                "title": "python-in-place-solution-with-dummy-head-node",
                "content": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def deleteDuplicates(self, head):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                pre.next = head\\n            else:\\n                pre = pre.next\\n                head = head.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 28364,
                "title": "java-simple-and-clean-code-with-comment",
                "content": "    public class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}\\n        \\tif (slow.next != fast) { //duplicates detected.\\n        \\t\\tslow.next = fast.next; //remove the dups.\\n        \\t\\tfast = slow.next;     //reposition the fast pointer.\\n        \\t} else { //no dup, move down both pointer.\\n        \\t\\tslow = slow.next;\\n        \\t\\tfast = fast.next;\\n        \\t}\\n        \\t\\n        }\\n        return dummy.next;\\n    } }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n    \\t//use two pointers, slow - track the node before the dup nodes, \\n    \\t// fast - to find the last node of dups.\\n        ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n        slow.next = fast;\\n        while(fast != null) {\\n        \\twhile (fast.next != null && fast.val == fast.next.val) {\\n         \\t\\tfast = fast.next;    //while loop to find the last node of the dups.\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 28339,
                "title": "my-recursive-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n        \\n        if (head.next != null && head.val == head.next.val) {\\n            while (head.next != null && head.val == head.next.val) {\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        } else {\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n    \\n\\n\\nif current node is not unique, return deleteDuplicates with head.next. \\nIf current node is unique, link it to the result of next list made by recursive call. Any improvement?",
                "codeTag": "Unknown"
            },
            {
                "id": 28355,
                "title": "simple-and-clear-c-recursive-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            } else {\\n                while (p && p->val == val) p = p->next;\\n                return deleteDuplicates(p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if (!head) return 0;\\n            if (!head->next) return head;\\n            \\n            int val = head->val;\\n            ListNode* p = head->next;\\n            \\n            if (p->val != val) {\\n                head->next = deleteDuplicates(p);\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2419088,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 93.57% of Java online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 88.10% of C++ online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 28 ms, faster than 79.86% of Python online submissions for Remove Duplicates from Sorted List II.\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n        \\n# **JavaScript Solution:**\\nRuntime: 91 ms, faster than 67.42% of JavaScript online submissions for Remove Duplicates from Sorted List II.\\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Special case...\\n        if (head == null || head.next == null)\\n            return head;\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next and curr.next.next not null\\n        while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n            // if the value of curr.next and curr.next.next is same...\\n            // There is a duplicate value present in the list...\\n            if(curr.next.val == curr.next.next.val) {\\n                int duplicate = curr.next.val;\\n                // If the next node of curr is not null and its value is eual to the duplicate value...\\n                while(curr.next !=null && curr.next.val == duplicate) {\\n                    // Skip those element and keep updating curr...\\n                    curr.next = curr.next.next;\\n                }\\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // create a fake node that acts like a fake head of list pointing to the original head...\\n        ListNode* fake = new ListNode(0);\\n        // fake node points to the original head...\\n        fake->next = head;\\n        ListNode* pre = fake;     //pointing to last node which has no duplicate...\\n        ListNode* curr = head;      // To traverse the linked list...\\n        // Now we traverse nodes and do the process...\\n        while (curr != NULL) {\\n            // Create a loop until the current and previous values are same, keep updating curr...\\n            while (curr->next != NULL && pre->next->val == curr->next->val)\\n                curr = curr->next;\\n            // if curr has non-duplicate value, move the pre pointer to next node...\\n            if (pre->next == curr)\\n                pre = pre->next;\\n            // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n            else\\n                pre->next = curr->next;\\n                // Move curr forward...\\n                // In next iteration, we still need to check whether curr points to duplicate value...\\n                curr = curr->next;\\n        }\\n        // Return the linked list...\\n        return fake->next;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```\n```\\nvar deleteDuplicates = function(head) {\\n    // Special case...\\n    if (head == null || head.next == null)\\n        return head;\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head......\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next and curr.next.next not null\\n    while(curr.next != null && curr.next.next != null){         // curr.next means the next node of curr pointer and curr.next.next means the next of next of curr pointer...\\n        // if the value of curr.next and curr.next.next is same...\\n        // There is a duplicate value present in the list...\\n        if(curr.next.val == curr.next.next.val) {\\n            let duplicate = curr.next.val;\\n            // If the next node of curr is not null and its value is eual to the duplicate value...\\n            while(curr.next !=null && curr.next.val == duplicate) {\\n                // Skip those element and keep updating curr...\\n                curr.next = curr.next.next;\\n            }\\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\n```\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n    // create a fake node that acts like a fake head of list pointing to the original head...\\n    struct ListNode* fake = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    // fake node points to the original head...\\n    fake->next = head;\\n    struct ListNode* pre = fake;        //pointing to last node which has no duplicate...\\n    struct ListNode* curr = head;       // To traverse the linked list...\\n    // Now we traverse nodes and do the process...\\n    while (curr != NULL) {\\n        // Create a loop until the current and previous values are same, keep updating curr...\\n        while (curr->next != NULL && pre->next->val == curr->next->val)\\n            curr = curr->next;\\n        // if curr has non-duplicate value, move the pre pointer to next node...\\n        if (pre->next == curr)\\n            pre = pre->next;\\n        // If curr is updated to the last duplicate value, discard it & connect pre and curr->next...\\n        else\\n            pre->next = curr->next;\\n            // Move curr forward...\\n            // In next iteration, we still need to check whether curr points to duplicate value...\\n            curr = curr->next;\\n    }\\n    // Return the linked list...\\n    return fake->next;\\n}\\n```\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(-1)\\n        fake.next = head\\n        # We use prev (for node just before duplications begins), curr (for the last node of the duplication group)...\\n        curr, prev = head, fake\\n        while curr:\\n            # while we have curr.next and its value is equal to curr...\\n            # It means, that we have one more duplicate...\\n            while curr.next and curr.val == curr.next.val:\\n                # So move curr pointer to the right...\\n                curr = curr.next\\n            # If it happens, that prev.next equal to curr...\\n            # It means, that we have only 1 element in the group of duplicated elements...\\n            if prev.next == curr:\\n                # Don\\'t need to delete it, we move both pointers to right...\\n                prev = prev.next\\n                curr = curr.next\\n            # Otherwise, we need to skip a group of duplicated elements...\\n            # set prev.next = curr.next, and curr = prev.next...\\n            else:\\n                prev.next = curr.next\\n                curr = prev.next\\n        # Return the linked list...\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28334,
                "title": "is-this-the-best-c-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }\\n                else\\n                    runner = &((*runner)->next);\\n            }\\n            \\n            return head;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode *deleteDuplicates(ListNode *head) {\\n            ListNode **runner = &head;\\n            \\n            if(!head || !head->next)return head;\\n            \\n            while(*runner)\\n            {\\n                if((*runner)->next && (*runner)->next->val == (*runner)->val)\\n                {\\n                    ListNode *temp = *runner;\\n                    while(temp && (*runner)->val == temp->val)\\n                        temp = temp->next;\\n                    \\n                    *runner = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28351,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "Simply check if the element is duplicate. If yes, record it and use a while loop to go to the next unique element.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }\\n                }\\n                else {\\n                    cur = cur->next;\\n                }\\n            }\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode* cur = dummy;\\n            int duplicate;\\n            while (cur->next && cur->next->next) {\\n                if (cur->next->val == cur->next->next->val) {\\n                    duplicate = cur->next->val;\\n                    while (cur->next && cur->next->val == duplicate) {\\n                        cur->next = cur->next->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1002902,
                "title": "python-2-pointers-solution-explained",
                "content": "Idea here is to traverse our linked list and use two pointers:\\n\\n1. `slow` is for node just before duplications begins\\n2. `fast` is for the last node of duplication group.\\n\\nNow, we traverse nodes and do the following steps:\\n1. while we have `fast.next` and its value is equal to `fast`, it means, than we have one more duplicate, so we move `fast` pointer to the right.\\n2. If it happen, that `slow.next` equal to `fast`, it means, that we have only `1` element in group of duplicated elements, that is we do not need to delete it and we move both pointers to right.\\n3. If it happen, that `slow.next` is not equal to `fast`, it means, that we need to skip group of duplicated elements: we create new connection: `slow.next = fast.next`, and also we allocate `fast = slow.next`. Note, that now we still have the original property: `slow` points to node before group of duplicated elements and `fast` will be the last element of this group (after `while fast.next and fast.val == fast.next.val:` line)\\n\\n**Complexity**: time complexity is `O(n)`: we traverse our list at most twice for each of the pointers. Space complexity is `O(1)`: we did not use any additional memory here.\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        fast, slow = head, dummy\\n        while fast:\\n            while fast.next and fast.val == fast.next.val:\\n                fast = fast.next\\n            if slow.next == fast:\\n                slow, fast = slow.next, fast.next\\n            else:\\n                slow.next = fast.next\\n                fast = slow.next\\n                \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165015,
                "title": "python3-simple-recursive-and-iterative-solution-with-figure-explanation",
                "content": "**Recursive**\\n- Idea\\n\\t- Base case: list is empty or contains only one element --> No duplicates\\n\\t- Recursive case: Assuming that the rest of the list is already done removing duplicates, we only need to consider the first part\\n\\t\\t- There\\'s no duplicate in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/490adbec-efbb-4f4e-87aa-feff28e37f78_1618746910.08464.png)\\n\\t\\t- There\\'re duplicates in the first part\\n\\t\\t\\t![image](https://assets.leetcode.com/users/images/7e0078bb-8da8-4ffe-a3ef-4f1c6748603f_1618747062.235478.png)\\n- Implementation\\n   ```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\\n   \\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(n)\\n\\n\\n\\n**Iterative**\\n- Idea\\n\\t- Add `dummy_head` before `head`. `dummy.next` is the first node of the list.\\n\\t\\t- Using `dummy_head` can help us to handle edge cases easily. For example, removing duplicate nodes at the beginning of list.\\n\\t- Use two pointers `prev` and `cur` for removing nodes\\n\\t- Iterate the list\\n\\t\\t- If there\\'s no duplicate, move `prev` and `cur` one step forward\\n\\t\\t- If there\\'re duplicate\\n\\t\\t\\t- Iterate `cur` to the last duplicate node\\n\\t\\t\\t- \"Jump over\" the duplicates \\n\\t\\t\\t\\t- `prev.next = cur.next` \\n\\t\\t\\t\\t- `cur = cur.next`\\n\\t\\t![image](https://assets.leetcode.com/users/images/b1eff2b9-24b8-47ac-9b09-88341cc0db64_1618752302.197709.png)\\n- Implementation\\n\\t```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```\\n\\t\\n- Complexity\\n\\t- Time: O(n)\\n\\t- Space: O(1)\\n\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n   def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        # Base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # Recursive case\\n        \\n        # No duplicate in the first part\\n        if head.next.val != head.val: \\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n        \\n        # Duplicates exist in the first part\\n        cur = head\\n        while cur.next and cur.next.val == cur.val:\\n            cur = cur.next\\n        return self.deleteDuplicates(cur.next)\\n   ```\n```python\\n\\tdef deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy_head = ListNode(next=head)\\n        prev, cur = dummy_head, head\\n        \\n        while cur and cur.next:\\n            if cur.val != cur.next.val:\\n                # If there\\'s no duplicate,\\n                # move prev and cur one step forward\\n                prev, cur = cur, cur.next\\n            else:\\n                # If there\\'re duplicates,\\n                # iterate cur to the last duplicate nodes,\\n                while cur.next and cur.val == cur.next.val:\\n                    cur = cur.next\\n                    \\n                # and jump over the duplicates\\n                prev.next = cur.next\\n                cur = cur.next\\n        \\n        return dummy_head.next\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 28338,
                "title": "o-n-time-o-1-space-easiest-understanding",
                "content": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "The idea is simple, we maintain two pointers, pre, cur in the given List. Pre pointer is always referring to one position before the cur pointer. When we found pre.val != cur.val && cur.val != cur.next.val, the node referred by cur pointer is a unique node. \\n\\n\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode dummy = new ListNode(0 == head.val ? 1 : 0); // to guarantee the dummy node is not same as the original head. \\n\\n        dummy.next = head;\\n        \\n        ListNode pre = dummy;\\n        ListNode cur = head;\\n\\n        ListNode first = dummy;  // the first node in the new unduplicated(result) list.\\n        \\n        while (cur != null && cur.next != null) {\\n            if (cur.val != pre.val && cur.val != cur.next.val) { // we found a unique node, we connect it at the tail of the unduplicated list, and update the first node.\\n                first.next = cur;\\n                first = first.next;\\n            }\\n            pre = cur;\\n            cur = cur.next;\\n        }\\n        \\n        if (pre.val != cur.val) { // the last node needs to be dealt with independently\\n            first.next = cur;\\n            first = first.next;\\n        }\\n        \\n        first.next = null; // the subsequent list is duplicate.\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 816387,
                "title": "simple-3-pointer-solution-8ms-c",
                "content": "* Faster than 93.08% (8ms)\\n* Memory usage less than 96.39% (10.8 MB)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n#### If you like the solution, do give it an upvote. In case of queries, feel free to leave them in the comment.\\n#### LeetCode and Chill !!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        if(!head)\\n            return head;\\n        \\n        ListNode *prev=NULL, *curr=head, *next=curr->next;\\n        while(next)\\n        {\\n            if(curr->val == next->val)\\n            {\\n                while(next && next->val == curr->val)\\n                    next=next->next;\\n                if(!prev) // This condition means element at the head is repeating. So, head pointer needs to be shifted.\\n                    head=next;\\n                else\\n                    prev->next = next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n            }\\n            \\n            curr=next;\\n            if(next)\\n                next=curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28572,
                "title": "a-short-and-simple-java-solution",
                "content": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "solutionTags": [],
                "code": "    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode d = dummy;\\n        while (head != null) {\\n            if (head.next != null && head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val)\\n                    head = head.next;\\n            } else {\\n                d.next = head;\\n                d = d.next;\\n            }\\n            head = head.next;\\n        }\\n        d.next = null;\\n        return dummy.next;\\n    }\\n\\n1->1->1->2->2->3\\n\\nwe skip all the 1's and start the loop from 2\\n\\nand also skip all the 2's, and now head.val == 3;\\n\\nponit d.next to the tail, end the loop",
                "codeTag": "Unknown"
            },
            {
                "id": 1832481,
                "title": "c-detailed-explanation-w-actually-memory-delete-commented-code-easy-to-understand",
                "content": "***Brief note about Question-***\\n```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\\n_____________\\n***Solution - I (Accepted)-***\\n* First we create a dummy node name as `prehead` whose next contains the` head` node.\\n* After that, we have to make a current pointer and moves that pointer in the our linked list.\\n* Suppose at  a point we find `curr ->next -> val == curr -> next -> next -> val`then we have to delete all nodes upto which they are having the same value.\\n* We actually delete that nodes from our linked list and free up memory.\\n* And lastly, as use of dummy node i.e our` prehead`, it\\'s next store our head node, so we return `prehead -> next.`\\n* Since, It is pretty straightforward to visuliaze the links how they works here, that\\'s why in this post i don\\'t include images.\\n* See code for more clarification.\\n________\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given-\\nSuppose our head given to us as head = -1 -> 0 -> 3 -> 4 -> 4 -> 4 -> 5 -> 5-> 6\\n\\nSince, 4 and 5 are repeating, so we delete that nodes, and our final answer looks like\\nhead = -1 -> 0 -> 3 -> 6\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //if head is NULL or just having a single node, simply return from here head \\n        if(head == NULL || head->next == NULL) \\n            return head;\\n        \\n        // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n        ListNode* prehead = new ListNode(-101);\\n        \\n        prehead -> next = head; // prehead\\'s next contain head\\n        \\n        ListNode* curr = prehead; // make a current pointer to move\\n        \\n        // while it not reaches to the end\\n        while(curr -> next != NULL && curr -> next -> next != NULL)\\n        {\\n            // if values are equal, now we have to delete values, till when they are equal\\n           if(curr -> next -> val == curr -> next -> next -> val)\\n           {\\n               // temp pointer to find upto when the va;ues are equal and delete that nodes which ar not be include in our answer\\n               ListNode* temp = curr -> next -> next;\\n               while(temp != NULL && curr -> next -> val == temp -> val)\\n               {\\n                   ListNode *anthortemp = temp;\\n                   temp = temp -> next;\\n                   delete anthortemp; // actually freeing up the memory\\n               }\\n               curr -> next = temp;\\n           }\\n           else // if values are not equal\\'s then simply move curr to next\\n           {\\n               curr = curr -> next;\\n           }\\n        }\\n        \\n        // and at last, prehead\\'s next contain head node, so return that\\n        return prehead -> next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28398,
                "title": "clean-python-solution-involving-dummy-node",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        \\n        while curr:\\n            if curr.next and curr.val == curr.next.val:\\n                val_to_rem = curr.val\\n                \\n                while curr and curr.val == val_to_rem:\\n                    curr = curr.next\\n                    \\n                prev.next = curr\\n                \\n            else:\\n                prev, curr = curr, curr.next\\n                \\n        return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 3224134,
                "title": "detailed-explanation-how-to-think-about-the-ques-100",
                "content": "# Intuition\\nTo solve this problem, we can use a dummy node and two pointers, current and previous. The dummy node serves as the head of the result linked list and helps us handle the case where the original head node needs to be removed. The current pointer moves through the linked list, checking for duplicates, and the previous pointer follows behind it, keeping track of the last distinct node.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We first create a dummy node with a value of 0 and set its next pointer to the original head node. We also initialize the prev and curr pointers to the dummy node and the head node, respectively.\\n- We then iterate through the linked list using the curr pointer, checking for duplicates with the curr.next node. If we find duplicates, we keep moving the curr pointer until we find the last duplicate node. We then update the prev.next pointer to point to the node after the last duplicate node.\\n- If we don\\'t find duplicates, we simply update the prev pointer to the curr node and move the curr pointer to its next node\\n- After iterating through the entire linked list, we return the next pointer of the dummy node, which points to the head of the resulting linked list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/53a2ee22-0977-4b5c-9768-f81d45e59bc2_1677219527.1926677.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL || head->next == NULL) return head;\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = head;\\n        ListNode* prev = dummy;\\n\\n        while(curr != NULL){\\n            if(curr->next != NULL && curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr= curr->next;\\n                }\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565744,
                "title": "simple-c-iterative-solution-comments-97-faster",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // handle edge cases, if list is empty\\n        // or if it has one element, return it\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        // create an auxiliary head pointer\\n        // and a new iterator\\n        auto auxiliary_head = new ListNode(-1);\\n        auto iter = auxiliary_head;\\n        \\n        while (head != nullptr) {\\n            if (head->next && head->val == head->next->val) {\\n                // if current node value is equal to its next value\\n                // skip all nodes of that value\\n                int curr = head->val;\\n                while (head && head->val == curr) {\\n                    head = head->next;\\n                }\\n            } else {\\n                // otherwise, assign node to next iterator\\n                // increment new iterator and increment node\\n                iter->next = head;\\n                iter = iter->next;\\n                head = head->next;\\n            }\\n        }\\n        \\n        // we need to cut the cord\\n        iter->next = nullptr;\\n        \\n        // return new head\\n        return auxiliary_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28371,
                "title": "javascript-iterative-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    const dummy = new ListNode();\\n    dummy.next = head;\\n    let node = dummy;                                                  // the last known distinct node\\n    while (node.next) {\\n        if (node.next.next && node.next.val === node.next.next.val) {  // if the next two nodes are equal...\\n            let nonValNode = node.next.next.next;\\n            while (nonValNode && nonValNode.val === node.next.val) {   // ...find the first one that isn't...\\n                nonValNode = nonValNode.next;\\n            }\\n            node.next = nonValNode;                                    // ...and glue it to the last known distinct node;...\\n        } else {\\n            node = node.next;                                          // ...otherwise the next node is distinct\\n        }\\n    }\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560641,
                "title": "java-solution-short-simple",
                "content": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n    \\n        if(head.val != head.next.val){\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        \\n        while(head.next != null && head.val == head.next.val){\\n            head = head.next;\\n        }\\n        \\n        return deleteDuplicates(head.next);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28483,
                "title": "c-8ms-iterative-naive-but-easy-to-implement",
                "content": "It is my first post ever... Did not saw similar ones so I would like to share a naive way to implement this.\\nIdea is to set a flag, which indicates the current head should be added or not.\\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }\\n                if(flag) // if should be added\\n                {\\n                    tail->next = head;\\n                    tail = tail->next;\\n                }\\n                head = head->next;\\n                flag = true; // time for a new head value, set flag back to true\\n            }\\n            tail->next = nullptr; // Don't forget this... I did..\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head||!head->next) return head;\\n            ListNode* dummy = new ListNode(0);\\n            ListNode* tail = dummy;\\n            int flag = true; // should the current head be added ?\\n            while(head){\\n                while(head&&head->next&&head->val==head->next->val)\\n                {\\n                    flag = false; // finds duplicate, set it to false\\n                    head = head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1833176,
                "title": "4ms-simple-c-easy",
                "content": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "\\n```\\n  ListNode* deleteDuplicates(ListNode* head) \\n    {\\n        if(!head || !head->next)\\n        {\\n            return head;\\n        }\\n        \\n        int x=head->val;\\n        int y=head->next->val;\\n        \\n        if(x!=y)\\n        {\\n            head->next=deleteDuplicates(head->next);\\n        }\\n        else\\n        {\\n            while(head && x==head->val)\\n            {\\n                head=head->next;\\n            }\\n           return deleteDuplicates(head);\\n        }\\n     \\n        return head;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1832645,
                "title": "c-efficient-short-easy-clean-solution-beginner-friendly",
                "content": "#### *please Upvote, if you Find its Helpful :)*\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=new ListNode(0,head);//dummy node\\n        ListNode* prev=temp;\\n        \\n        while(head!=NULL){\\n            if(head->next!=NULL && head->val==head->next->val){\\n               while(head->next!=NULL && head->val==head->next->val){\\n                   head=head->next;\\n               }\\n                prev->next=head->next;\\n            }else{\\n                prev=prev->next;\\n            }\\n            head=head->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832457,
                "title": "java-100-faster-solution-using-two-pointer",
                "content": "```class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }\\n               prev.next=curr.next;\\n            }\\n            else{\\n                prev=curr; \\n            }\\n            curr=curr.next;\\n        }\\n      return dummy.next;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            if(curr.next!=null && curr.val==curr.next.val) {\\n                while(curr.next!=null && curr.val==curr.next.val){\\n                    curr=curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 28479,
                "title": "8ms-clean-c-code",
                "content": "This is not a hard problem, but it is also not very easy to make the code clean and neat.\\n\\n    class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }\\n                    pre = head;\\n                    head = head->next;\\n                }\\n                ptr->next = NULL;\\n                return p->next;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if( !head ) return NULL;\\n                ListNode* p = new ListNode(head->val-1), *ptr = p, *pre = p;\\n                while( head ) {\\n                    if( pre->val != head->val && (!head->next || head->next->val != head->val )) {\\n                        ptr->next = head;\\n                        ptr = ptr->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2583544,
                "title": "easy-recursive-c-approach",
                "content": "In the recursive approach we\\'ll first set our base cases that if our *head* or *head -> next* is *NULL* then we simply return the head node as we have either a *NULL* or a Single Node in the Linked List.\\n\\nNow,\\nIf the value in head Node and the next Node is equal then using a while loop we\\'ll shift the head Node forward till the time two adjacent nodes have the same value \\n(i.e. till *head -> val == head -> next -> val*).\\n```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\\nAt the end of the while loop it\\'s important to notice that we\\'ll currently be on the Node whose value was duplicated so we\\'ll call recursion on the next value of head and update our pre-existing head. \\n**head = deleteDuplicates(head -> next)**\\n\\nOtherwise if the value of head and the next node are different we\\'ll just simply update our  *head -> next* by calling recursion on it leaving our head Node preserved as it wasn\\'t duplicated. \\n **head -> next = deleteDuplicates(head -> next)**\\n\\nFinally we\\'ll return the head Node. \\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/*\\nFor example : 1 -> 1 -> 1 -> 2 -> 3 \\nInitially our head will point at the first Node containing the value 1.\\nAfter going through the loop the head will be pointing at the third Node that again contains 1 but the value of the next Node isn\\'t 1 so the loop will terminate .\\n*/\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\t// Base Case\\n    if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int flag = head -> val;\\n        //If head is found duplicated\\n        if(head -> next -> val == flag){\\n            while(head -> next && head -> next -> val == flag){\\n               head = head -> next; \\n            }\\n            // Since head node is still the one which was duplicated calling recursion on next Node and updating current head\\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n        // If head isn\\'t duplicated\\n        else{\\n            //Leaving current head preserved and calling recursion from the next Node of list\\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n\\t\\n\\t/*\\n\\tif(solution -> understandable){\\n\\t\\tupvote++;\\n\\t}\\n\\tPS : This is my first ever answer on leetcode hope you liked it. Please comment for suggestions and feedback :)\\n\\t*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832725,
                "title": "c-easy-to-understand-iteration-simple",
                "content": "**82. Remove Duplicates from Sorted List II**\\n\\n#### **APPROACH -**\\n*Create a **dummyHead** with `dummyHead->next = head`\\nTraverse through the linked list with intially `isDuplicate = false`\\nMove through the nodes till same valued nodes present and update **isDuplicate**\\nSet the new links based on whether the current node is a duplicate\\nReturn **dummyHead->next***\\n</br>\\n#### **COMPLEXITY -**\\n* Time Complexity : O(N)\\n* Space Complexity : O(1)\\n</br>\\n#### **CODE -**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps** \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *dummyHead = new ListNode(0, head);\\n        ListNode *prev = dummyHead, *curr = head;\\n        \\n        while(curr) {\\n            bool isDuplicate = false;\\n            while(curr->next && curr->val == curr->next->val) {\\n                isDuplicate = true;\\n                curr = curr->next;\\n            }\\n            if(isDuplicate)\\n                prev->next = curr->next;\\n            else\\n                prev = curr;\\n            curr = curr->next;\\n        }\\n\\t\\t\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832310,
                "title": "c-easy-to-understand-recursion-simple",
                "content": "# 82. Remove Duplicates from Sorted List II\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)       **LINK TO LEETCODE REPOSITORY**\\n``` ```\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node.**\\n* If the **data of the next node is the same as the current node** then **delete the next node.** \\n* **Before we delete a node**, we need to store the next pointer of the node.\\n\\n``` ```\\n\\n**TIME COMPLEXITY**  : O(N)  , *N is number of Nodes*\\n**SPACE COMPLEXITY** : O(1) \\n``` ```\\n\\n**CODE WITH EXPLANATION**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\t\\t// if list contains no node\\n        if(!head)\\n            return 0;\\n\\t\\t//if list containg a single node return head\\n        if(!head -> next)\\n            return head;\\n        \\n\\t\\t// keepitn val of head in a temp variable var.\\n        int val = head ->val;\\n\\t\\t// temp contain the reference of next  node\\n        ListNode *temp = head -> next;\\n        \\n\\t\\t// if the next node have different value then,\\n\\t\\t// update head->next by temp(temp contains reference to next node)\\n        if(temp -> val != val)\\n        {\\n            head -> next = deleteDuplicates(temp);\\n            return head;\\n        }\\n        else\\n        {\\n\\t\\t\\t// if the values are same just update temp to temp->next;\\n           while(temp && temp -> val == val)\\n            {\\n\\t\\t\\t\\t// assigning temp to p \\n                ListNode *p = temp;\\n\\t\\t\\t\\t// updating temp with next node\\n                temp = temp->next;\\n\\t\\t\\t\\t// freeing the memory\\n                delete p;\\n            }\\n            return deleteDuplicates(temp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918883,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        let dummy: ListNode? = ListNode(-1)\\n        dummy?.next = head\\n\\n        var curr = dummy\\n        while let nextVal = curr?.next?.val, let nextNextVal = curr?.next?.next?.val {\\n            if nextVal == nextNextVal {\\n                let duplicate = nextVal\\n                while curr?.next != nil, curr?.next?.val == duplicate {\\n                    curr?.next = curr?.next?.next\\n                }\\n            } else {\\n                curr = curr?.next\\n            }\\n        }\\n\\n        return dummy?.next\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28438,
                "title": "my-python-solution-beats-91",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if head==None:\\n            return None\\n        \\n        dummy=ListNode(0)\\n        dummy.next=head\\n        \\n        cur=head\\n        prev=dummy\\n        \\n        dup=0\\n        \\n        while cur!=None and cur.next!=None:\\n            if cur.val==cur.next.val:\\n                cur=cur.next\\n                dup=1\\n            else:\\n                if dup==1:\\n                    prev.next=cur.next\\n                    cur=cur.next\\n                    dup=0\\n                else:\\n                    prev=cur\\n                    cur=cur.next\\n        if dup==1:\\n            prev.next=cur.next\\n            cur=cur.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28487,
                "title": "recommend-for-beginners-c-implementation-with-detailed-explaination",
                "content": "At the first glance, we can use the similar code of the simpler problem : which only delete the duplicate ones, So if we want to delete all the duplicate ones including the copy. We can use  the dummy node and the pre pointer to jump over all the duplicate nodes.\\nThe Trap is that you may ignore that when we meet the no-duplicate numbers, we should do different op based the previous states. Just like state-machine.\\nAt last but not least important, we should delete the duplicate number occurs at the end . \\n\\n    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }\\n                else{\\n                    if(flag) {\\n                        pre->next=next;\\n                        cur=next;\\n                        next=next->next;\\n                    }\\n                    else{\\n                        pre=pre->next;\\n                        cur=cur->next;\\n                        next=next->next;\\n                    }\\n                    flag=false;\\n                }\\n            }\\n            //the corner cases : if the duplicate number locates at the end \\n            if(flag) pre->next=next;\\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            if(!head)   return NULL;\\n            ListNode* dummy=new ListNode(INT_MAX);\\n            dummy->next=head;\\n            ListNode* pre=dummy, *cur=head, *next=head->next;\\n            bool flag=false;\\n            while(next){\\n                if(next->val==cur->val){\\n                    flag=true;\\n                    next=next->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1003243,
                "title": "c-iterative-2-pointer-solution-explained-100-time-40-space",
                "content": "This problem is rather easy to solve with extra memory and possibly an extra pass; a better challenge comes from trying to trying to work under more constrained requirements.\\n\\nFirst of all we will declare a few support variables:\\n* `res` will be the base from which we will build our solution and will save us a bit of painful edge cases to otherwise consider, for the affordable cost of one extra node;\\n* `prev` and `iter` will be the 2 pointers we will use to parse and purge the list from duplicates;\\n* `currVal` is a convenience variable to store the currently parsed value.\\n\\nWe will attach `head` right after `res` and then move on with a main loop that will run as long as we have `prev && prev->next`, in which:\\n* we will prepare the ground for the next inner loop, setting `iter` right after `prev` and assigning `iter->val` to `currVal`;\\n* advance `iter` with our inner loop, as long as we still have `iter->next` and its value matches the one stored in `currVal`;\\n* we will then have 2 cases:\\n\\t* the loop never run, since we only have one node with `currVal` right after `prev`, so this very node will become our `prev` for the next iteration;\\n\\t* otherwise, it means we found multiple occurrences of the same value and then we will just have to slice them away frome the list: in the next iteration `prev` will stay the same (so, potentially it might always be just `res`) and its successor will be the next node with a different value than `currVal`.\\n\\nOnce we are done, we can return `res->next` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n\\nAnd since it just occurred to me that with my last version of the code `currVal` has little use, refactor without it - performance is clearly basically the same, despite saving a few bytes and assignments:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        int currVal;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            currVal = iter->val;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == currVal) iter = iter->next;\\n            // case 1: only one node with currVal\\n            if (iter == prev->next || !iter) prev = iter;\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // support variables\\n        ListNode *res = new ListNode(-101), *prev = res, *iter = head;\\n        // attaching res before head\\n        res->next = head;\\n        while (prev && prev->next) {\\n            // preparing for the inner loop\\n            iter = prev->next;\\n            // advancing with all the similar values\\n            while (iter->next && iter->next->val == iter->val) iter = iter->next;\\n            // case 1: only one node with the same value\\n            if (iter == prev->next || !iter) prev = iter;\\n            // case 2: multiple nodes with the same value found\\n            else prev->next = iter->next;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382651,
                "title": "standard-c-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe standard way to handle this use case is to use the so-called Sentinel Node. Sentinel nodes are widely used for trees and linked lists as pseudo-heads, pseudo-tails, etc. They are purely functional and usually don\\'t hold any data. Their primary purpose is to standardize the situation to avoid edge case handling.\\n\\nFor example, let\\'s use here pseudo-head with zero value to ensure that the situation \"delete the list head\" could never happen, and all nodes to delete are \"inside\" the list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n    one linear traversing of the linked list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n    Because not using any additonal space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel = new ListNode(0, head);\\n        ListNode* prev = sentinel;\\n        while(head){\\n            if(head->next and head->val == head->next->val){\\n                while(head->next and head->val == head->next->val){\\n                    head = head->next;\\n                }\\n                prev->next = head->next;\\n            }\\n            else{\\n                prev = prev->next;\\n            }\\n            head = head->next; \\n        }\\n        return sentinel->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185194,
                "title": "82-remove-duplicates-from-sorted-list-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a dummy node dummy and set its next node as the head of the linked list.\\n2. Create a prev variable and initialize it with dummy.\\n3. Use a while loop to traverse the linked list while head and head.next are not None.\\n4. Check if the value of the current node head is equal to the value of the next node head.next.\\n5. If yes, then use another while loop to traverse the linked list and find all the duplicates.\\n6. Once all the duplicates are found, set head to head.next and update the next node of prev to head.\\n7. If the values are not equal, update the prev to prev.next and head to head.next.\\n8. Return dummy.next as the new head of the linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\nclass ListNode:\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n        while head and head.next:\\n            if head.val == head.next.val:\\n                while head and head.next and head.val == head.next.val:\\n                    head = head.next\\n                head = head.next\\n                prev.next = head\\n            else:\\n                prev = prev.next\\n                head = head.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893347,
                "title": "100-fastest-typescript-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode {\\n *     val: number\\n *     next: ListNode | null\\n *     constructor(val?: number, next?: ListNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.next = (next===undefined ? null : next)\\n *     }\\n * }\\n */\\n\\nfunction deleteDuplicates(head: ListNode | null): ListNode | null {\\n  if (!head) { return null }\\n  if (!head.next) { return head }\\n  let fakeHead = new ListNode(undefined, head) // beginning of a returned linked list\\n  let prev = fakeHead // start of the group with same values\\n  let current = head // pointer\\n\\n  while (current) { // move through the current group until new value is seen\\n    while (current.next && prev.next && prev.next.val === current.next.val) { current = current.next }\\n\\n    if (prev.next === current) {\\n      prev = prev.next // if group has only one member, move prev to current\\n    } else {\\n      prev.next = current.next // otherwise, exclude the group\\n    }\\n\\n    current = current.next as ListNode // Move to the next node\\n  }\\n\\n  return fakeHead.next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832665,
                "title": "python3-runtime-28-ms-faster-than-99-71-memory-13-8-mb-less-than-96-26",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        fake = ListNode(0, head)\\n        pred = fake\\n        while head:\\n            if head.next and head.val==head.next.val:\\n                while head.next and head.val==head.next.val:\\n                    head = head.next\\n                pred.next = head.next\\n            else: \\n\\t\\t\\t\\tpred = pred.next\\n            head = head.next\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003116,
                "title": "c-recursion-simple-straight-and-easy-to-understand-solution",
                "content": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```\\n\\nTime Complexity:  O(n) where n is number of nodes in linked list.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(head->val!=head->next->val){\\n            head->next=deleteDuplicates(head->next);\\n            return head;\\n        }\\n        int val=head->val;\\n        while(head && head->val==val)\\n            head=head->next;\\n        return deleteDuplicates(head);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588495,
                "title": "java-clear-explanation-of-question-and-logic-behind-the-answer",
                "content": "ok lets do this!!\\ni see a lot of people unabe to explain the question and the solution!\\nlet me first explain the question!!\\nquestion says to remove the duplicates from an sorted linked list!\\n(piece of advice-whenever you are given a sorted ds ,this is a hint that the question is easy....so dont think too much)\\nanyways lets see some ex:\\n1->2->2->3->3->4;\\nwe are required to remove ALL THE DUPLICATES ;\\nthus final list would be\\n1->4\\nand not\\n1->2->3->4;\\n\\nso lets go into the solution!\\nlike any other linked list problem lets take two pointer,\\none fast and one slow!\\nthe fast and slow both move one step at a time but fast is always ahead of slow as fast starts one node further than slow in the beginning!\\nLOGIC AND INTUITION:\\n\"thus the function of our fast node is to search for duplicates and wait for slow to catch up before moving any further!\\nin other words whenever fast detects a duplicate it would keep traversing till the last duplicate and then wait..\\nthe slow pointer will remove(delete) all the duplicate in the way and finally come to  fast node!\\nthis process continues till the fast encounters a null value indicating end of linkedl list\"\\n\\nINITIALLY WE ALSO NEED A DUMMY NODE SO THAT FAST IS ONE STEP AHEAD OF SLOW!\\n\\n```\\npublic class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}\\n    \\tif (slow.next != fast) { \\n    \\t\\tslow.next = fast.next; //remove the duplicates.\\n    \\t\\tfast = slow.next;     //fast moves to next unique value .\\n    \\t} else { //no duplicates...lets move towards right!!.\\n    \\t\\tslow = slow.next;\\n    \\t\\tfast = fast.next;\\n    \\t}\\n    \\t\\n    }\\n    return dummy.next;\\n} }\\n\\n\\nhope it helps!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\npublic ListNode deleteDuplicates(ListNode head) {\\n    ListNode dummy = new ListNode(0), fast = head, slow = dummy;\\n    slow.next = fast;\\n    while(fast != null) {\\n    \\twhile (fast.next != null && fast.val == fast.next.val) { // this loop basically takes fast to end of the current duplicates that we are tracking\\n     \\t\\tfast = fast.next;   \\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 508337,
                "title": "java-easy-10-line-solution-with-explanation",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif(head == null) return head;\\n\\tListNode dummy = new ListNode(0), pre = dummy, curr = head;\\n\\tpre.next = curr;\\n\\twhile(curr != null) {\\n\\t\\twhile(curr.next != null && curr.val == curr.next.val) \\n\\t\\t\\tcurr = curr.next;                   // curr goes to next node until it finds new val which is not same as prev one\\n\\t\\tif(pre.next == curr) pre = pre.next;    // no duplicate, so move pre to next node\\n\\t\\telse pre.next = curr.next;              // skip duplicate but don\\'t move pre\\n\\t\\tcurr = curr.next;                       // update curr\\n\\t}\\n\\treturn dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905732,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```\\n\\n![i.jpg](https://assets.leetcode.com/users/images/5ee16cc9-1523-46bf-bcae-e384caf0092f_1691954059.9454777.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr){\\n            return head;\\n        }\\n        ListNode* dummyNode = new ListNode(-1);\\n        dummyNode -> next = head;\\n        ListNode* curr = dummyNode;\\n\\n        while(curr->next!=nullptr&&curr->next->next!=nullptr){\\n            if(curr->next->val==curr->next->next->val){\\n                int duplicate = curr->next->val;\\n                while(curr->next!=nullptr&&curr->next->val==duplicate){\\n                    ListNode* temp = curr -> next;\\n                    curr -> next = curr->next->next;\\n                    delete temp;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617877,
                "title": "both-the-solutions-fully-and-clearly-explained-1-iterative-solution-2-using-stl-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. For iterative solution, simply iterate the Linked List and check for duplicate nodes and delete them.\\n2. For STL solution, store the elements of the Linked List in the map and delete them if their frequency is greater than 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***Solution 1:***\\n\\n1. Iterate the Linked List from one step back than the head, as it is possible that we need to delete the first element as well, and we know that **for deleting any node we require the previous node**.\\n2. Now just iterate the Linked List and store the current value of node in a variable named \\'variable\\' and till the subsequent elements == varible delete them.\\n3. If the above condition is not true, just move forward i.e., itr = itr -> next.\\n4. Finally return prev -> next (since our head of the list is stored in prev -> next pointer).\\n\\n\\n***Solution 2:***\\n\\n1. Iterate the Linked List and store the elements in a map named mp.\\n2. Create a new node \\'newHead\\' as the dummy head of the resulting Linked List.\\n3. Create a temporary pointer \\'temp\\' to keep treack of the last node in the resulting Linked List. Initalize it to \\'newHead\\'.\\n4. Iterate over the map, when (it.second == 1) create a new node \\'ans\\' with the value (it.first).\\n5. Connect the new node \\'ans\\' to the last node in the resulting Linked List by assigning \\'temp -> next = ans\\', and update \\'temp\\' to \\'ans\\' for the next iteration.\\n6. After processing all the unique values, the resulting Linked List is ready. Return \\'newHead -> next\\', which points to the first node in the resulting Linked List. \\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is O(n) for both the approaches.\\n\\n- Space complexity: \\n**Solution 1: O(1)\\n Solution 2: O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIn Solution 2 we are using map to store the unique values of the Linked List.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        if(head == NULL) return head;\\n\\n        ListNode* prev = new ListNode(); //this is pointing before head\\n        //Let\\'s say the list is 2 -> 2 -> 3 -> 5 -> 5 -> 5, in this case we have to delete the 1st element as well, therefore we have used prev pointer\\n        prev -> next = head;\\n\\n        ListNode* itr = prev;\\n\\n        while(itr -> next != NULL && itr -> next -> next != NULL)\\n        {\\n            if(itr -> next -> val == itr -> next -> next -> val)\\n            {\\n                int variable = itr -> next -> val;\\n                //We have to delete all the duplicate elements along with the original element\\n                while(itr -> next != NULL && itr -> next -> val == variable)\\n                {\\n                    itr -> next = itr -> next -> next;\\n                }\\n            }\\n            else //if we\\'ll not write else condition, we\\'ll get TLE\\n            {\\n                itr = itr -> next;\\n            }\\n        }\\n        return prev -> next; //head pointer is in prev -> next\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map <int, int> mp;\\n\\n        while(head != NULL)\\n        {\\n            mp[head -> val]++;\\n            head = head -> next;\\n        }\\n\\n        ListNode* newHead = new ListNode(); //Creating new list for answer\\n        ListNode* temp = newHead; //temp variable to keep track of the last node\\n        for(auto & it: mp)\\n        {\\n            if(it.second == 1)\\n            {\\n                ListNode* ans = new ListNode(it.first); //to avoid integer to pointer conversion\\n                temp -> next = ans;\\n                temp = ans;\\n            }\\n        }\\n        return newHead -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989127,
                "title": "100-faster-java-code-with-comments-for-better-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy =new ListNode(0,head);\\n        ListNode prev=dummy;\\n        while(head!=null){\\n            if(head.next!=null && head.val==head.next.val){\\n                //skip that nodes\\n                while(head.next!=null && head.val==head.next.val){\\n                    head=head.next;\\n                }\\n                prev.next=head.next;  //prev\\'s next point to the head next\\n            }else{\\n                prev=prev.next;\\n            }\\n            head=head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433787,
                "title": "js-o-n-time-o-1-space-with-explanation",
                "content": "Approach:\\nIn this problem, there are 3 cases to consider mainly\\n1. duplicates in the beginning - need to set a new `head`.\\n2. duplicates in between and at the end of the list.\\n3. unique value\\n\\nBasically, we start by checking values of the two adjacent nodes. If the values are equal (duplicates) -\\n1. for case 1, we did not have a prior node with unique value, the current node will basically be the first possible node encountered with a unique value (`possible` since after traversing further nodes, this node could also be having duplicate value). So we set this as the new node as head.\\n2. for case 2, we will have encountered a prior node with a unique value already, so we set the next pointer of that node as the current node.\\n3. for case 3, we set the prev node as the current node and move to the next node.\\n\\n```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(1)\\n\\nTest Cases for dry run:\\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let curr = head,\\n        prev = null;\\n    while(curr && curr.next) {\\n\\t\\t// if current node and next node value are same,\\n\\t\\t// iterate until we get to the node which does not have the same value as these 2 nodes\\n        if(curr.val === curr.next.val) {\\n            while(curr && curr.next && curr.val === curr.next.val) {\\n                curr = curr.next;\\n            }\\n\\t\\t\\t// the above loop will stop at the last duplicate node, for instance for 1,1,1,2,...\\n\\t\\t\\t// the loop will stop at 3rd node from start with value 1\\n\\t\\t\\t// so we move to next node which is not part of the previous set of duplicates\\n            curr = curr.next;\\n\\t\\t\\t\\n\\t\\t\\t// if no prev unique value node is encountered, set the `head` to this node\\n            if(!prev) {\\n                head = curr;\\n            } else {    // if there is a prev unique value node, reset it\\'s next pointer\\n\\t\\t\\t\\t// we do not change the prev node, since the current node itself can be having duplicate value\\n\\t\\t\\t\\t// so we will process the current node, until we identify it as having a unique value\\n                prev.next = curr;    \\n            }\\n        } else {    // node is having unique value\\n\\t\\t\\t// set prev as the current node and move to the next node\\n            prev = curr;\\n            curr = curr.next;    \\n        }\\n    }\\n    return head;    // finally return the head\\n};\\n```\n```\\n[1,2,3,3,4,4,5]      // duplicates in between\\n[1,1,1,2,2,2,3,4]    // duplicates at the beginning\\n[1,2,3,4,4,4]        // duplicates at the end\\n[1,1,2,2,3,3]        // all duplicates\\n[]                   // empty list\\n[1]                  // only one node\\n[1,1]                // only two nodes (duplicates)\\n[1,2]                // only two nodes (no duplicates)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338369,
                "title": "short-rust-solution",
                "content": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```\\nIt\\'s important to use pattern matching with conditions inside its branches, otherwise the ownership issues will drive you crazy.",
                "solutionTags": [],
                "code": "```rust\\npub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n    if head.is_none() { return head; }\\n\\n    let mut to_remove = head.as_ref().unwrap().val - 1;\\n    let mut dummy = Some(Box::new(ListNode { next: head, val: to_remove, }));\\n    let mut node = &mut dummy.as_mut().unwrap().next;\\n\\n    loop {\\n        match node {\\n            None => return dummy.unwrap().next,\\n            Some(n) if n.val == to_remove => *node = n.next.take(),\\n            Some(n) if n.next.is_some() && n.val == n.next.as_ref().unwrap().val => to_remove = n.val,\\n            Some(n) => {\\n                node = &mut n.next;\\n                if let Some(n) = node { to_remove = n.val - 1; }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048375,
                "title": "beginner-friendly-solution-hash-map-c-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/98ecf9d3-1257-4ca7-9638-6b2afb6c4ce6_1694792835.9833024.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* newlist=new ListNode();\\n        ListNode* temp2=newlist;\\n        map<int,int>m;\\n        while(temp)\\n        {\\n            m[temp->val]++;\\n            temp=temp->next;\\n        }\\n        for(auto i=m.begin();i!=m.end();i++)\\n        {\\n            if(i->second==1)\\n            {\\n                cout<<i->first<<endl;\\n                ListNode* node=new ListNode(i->first);\\n                temp2->next=node;\\n                temp2=temp2->next;\\n            }\\n        }\\n        return newlist->next;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3212752,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) return null;\\n\\n        ListNode ans = new ListNode();\\n        ans.next = head;\\n\\n        ListNode ptr = ans;\\n\\n        while (ptr.next != null && ptr.next.next != null) {\\n\\n            if (ptr.next.val == ptr.next.next.val) {\\n                int value = ptr.next.val;\\n                while (ptr.next != null && ptr.next.val == value) {\\n                    ptr.next = ptr.next.next;\\n                }\\n            } else {\\n                ptr = ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124662,
                "title": "c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/34398cd7-c2e8-4957-8661-69f127428365_1654659184.92216.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        bool j = false;\\n        while (head->next!=NULL && head->val == head->next->val){\\n            j = true;\\n            head->next = head->next->next;\\n        }\\n        if (j){\\n            head = deleteDuplicates(head->next);\\n            return head;\\n        }\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834089,
                "title": "1-ms-java-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "***STEPS :***\\n* Make two arrays of 100 length to keep the track of the count of ListNodes Value.\\n* Iterate the Linked List for counting .\\n* Create a dummy node and marks its next to head node.\\n* Create a temp node to iterate the linked list .\\n* Now while iterating check if nexts nodes count in the array is 1 or not if it is one then move to next node else move to next of next node .\\n* Return dummy\\'s next node\\n\\n\\n\\n**TIME COMPLEXITY ANALYSIS:**\\n* *TIME COMPLEXITY :* O(N) {For counting} + O(N) {For iterating the array} =O(2N)\\n* *SPACE COMPLEXITY :* O(1) {For keep track of count of Nodes value = O(1)\\n\\n\\n*Code for more understanding*\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        int pos [] = new int [101];\\n        int neg [] = new int [100];\\n        ListNode temp = head;\\n        while(temp!=null){\\n            if(temp.val>=0){\\n                pos[temp.val]++;\\n            }\\n            else{\\n                neg[Math.abs(temp.val)]++;\\n            }\\n            temp = temp.next;\\n        }\\n        ListNode dummy = new ListNode(-1);\\n        dummy .next = head;\\n        temp = dummy;\\n        while(temp.next!=null){\\n            \\n            if(temp.next.val>=0){\\n                if(pos[temp.next.val]!=1){\\n                    temp.next = temp.next.next;\\n                }\\n                else temp = temp.next;\\n            }\\n            else{\\n               if(neg[Math.abs(temp.next.val)]!=1){\\n                   temp.next = temp.next.next;\\n               } \\n                else temp = temp.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833446,
                "title": "c-code-easy-explanation-w-commented-code-faster-than-100-00-easy-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n     //if head is NULL or just having a single node, simply return from here head \\n    if(head == NULL || head -> next == NULL)\\n        return head;\\n    \\n    // creating our dummy node i.e prehead\\n        // we are giving it\\'s value is -101, because see constraints\\n        // -100 <= Node.val <= 100\\n    struct ListNode* prehead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    \\n    prehead -> val = -101;\\n    prehead -> next = head; // prehead\\'s next contain head\\n    \\n    struct ListNode* curr = prehead; // make a current pointer to move\\n    \\n    // while it not reaches to the end\\n    while(curr -> next != NULL && curr -> next -> next != NULL)\\n    {\\n        // if values are equal, now we have to delete values, till when they are equal\\n        if(curr -> next -> val == curr -> next -> next -> val)\\n        {\\n            struct ListNode* temp = curr -> next -> next;\\n            \\n            while(temp != NULL && curr -> next -> val == temp -> val)\\n            {\\n                struct ListNode* anthortemp = temp;\\n                temp = temp -> next;\\n                \\n                free(anthortemp); // actually freeing up the memory\\n            }\\n            \\n            curr -> next = temp;\\n            \\n        }\\n        else // if values are not equal\\'s then simply move curr to next\\n        {\\n            curr = curr -> next;\\n        }\\n    }\\n    \\n     // and at last, prehead\\'s next contain head node, so return that\\n    return prehead -> next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833010,
                "title": "javascript-easy-to-understand-2-solutions-detailed-explanation",
                "content": "## Core Strategy\\n\\nThe important points for this problem are:\\n- the original linked list is sorted\\n- we need to remove all the duplicate number, rather than left one there\\n\\nSo, what we need to do is:\\n- find a way to check one value is duplicated or not\\n- traverse the linked list and remove the duplicate nodes\\n- make sure we can still get the head of the final linked list\\n\\nFor step 2, we just use loop to traverse the linked list.\\nFor step 3, we could use a dummy node as the new head, to let us easier remove the old head node if we need.\\nFor step 1, here are 2 solutions with extra space or not.\\n\\n## With extra space\\n\\nFor this solution, we use a hashtable to do the counting for values in linked list. Then traverse again and remove the nodes we don\\'t need.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\\n\\n## Without extra space\\n\\nFor this solution, since we don\\'t want to use extra space, so we need to maintain 3 pointers - `prev`, `cur` and `next`. By this, we could compare the value and remove the nodes easily.\\n\\nI use the optional chaining operator (`?.`) in JS to avoid more checking logic.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst deleteDuplicates = head => {\\n  const count = {};\\n  const dummy = { next: head };\\n  for (let cur = head; cur; cur = cur.next) {\\n    count[cur.val] = (count[cur.val] || 0) + 1;\\n  }\\n  for (let cur = dummy; cur.next;) {\\n    count[cur.next.val] > 1 ? (cur.next = cur.next.next) : (cur = cur.next);\\n  }\\n  return dummy.next;\\n};\\n```\n```js\\nconst deleteDuplicates = head => {\\n  const dummy = { next: head };\\n  let prev = dummy;\\n  let cur = head;\\n  let next = head?.next;\\n  while (next) {\\n    if (cur.val !== next.val) {\\n      prev = cur;\\n      cur = next;\\n      next = next.next;\\n    } else {\\n      const val = cur.val;\\n      while (next && next.val === val) {\\n        next = next.next;\\n      }\\n      cur = next;\\n      next = next?.next;\\n      prev.next = cur;\\n    }\\n  }\\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706302,
                "title": "python3-easy-to-understand-recurrsion-faster-then-98",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```\\n\\n![image](https://assets.leetcode.com/users/images/18cd6f3e-253d-4785-8a74-937a33da5d5b_1642746179.505114.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tif not head.next:\\n\\t\\treturn head\\n\\n\\tif head.val != head.next.val:\\n\\t\\thead.next = self.deleteDuplicates(head.next)\\n\\t\\treturn head\\n\\n\\tif not head.next.next or head.next.val != head.next.next.val:\\n\\t\\treturn self.deleteDuplicates(head.next.next)\\n\\n\\n\\treturn self.deleteDuplicates(head.next) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003478,
                "title": "c-super-simple-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *last = new ListNode(0), *new_head = last;\\n        \\n        while (head) {\\n            \\n            if (head->next && head->val == head->next->val) {\\n                while (head->next && head->val == head->next->val)\\n                    head = head->next;\\n            }\\n            \\n            else {\\n                last->next = head;\\n                last = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        last->next = NULL;\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561149,
                "title": "c-mimimalizm",
                "content": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* deleteDuplicates(ListNode* head, bool dup = false) {\\n    if (head == nullptr)\\n        return nullptr;\\n    while (head->next != 0 && head->val == head->next->val) {\\n        dup = true;\\n        head->next = head->next->next;\\n    }\\n    head->next = deleteDuplicates(head->next);\\n    return dup ? head->next : head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28469,
                "title": "java-concise-iterative-solution",
                "content": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "        \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode p, dummy = new ListNode(0);\\n        p = dummy;\\n        dummy.next = head;\\n        while (head != null && head.next != null) {\\n            if (head.val == head.next.val) {\\n                while (head.next != null && head.val == head.next.val) {\\n                    head = head.next;\\n                }\\n                head = head.next;\\n                p.next = head;\\n            } else {\\n                head = head.next;\\n                p = p.next;\\n            }\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28390,
                "title": "a-easy-to-understand-python-solution",
                "content": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "solutionTags": [],
                "code": "\\n\\n    def deleteDuplicates(self, head):\\n        # Add a dummy node point to the current list\\n        newhead = ListNode(0)\\n        newhead.next = head\\n        val_need_to_be_deleted = None\\n        tail = newhead\\n        \\n        while head:\\n            \\n            # Triger delete mode if current has the same val as the next\\n            if head and head.next and head.val == head.next.val:\\n                val_need_to_be_deleted = head.val\\n            \\n            # Not a dup if delete mode is off or the current value doesn't match the value need to be deleted\\n            if val_need_to_be_deleted == None or head.val != val_need_to_be_deleted:\\n                # add it to the newlist\\n                tail.next = head\\n                tail = head\\n                \\n            head = head.next\\n            \\n        tail.next = None\\n        return newhead.next",
                "codeTag": "Python3"
            },
            {
                "id": 3142482,
                "title": "easy-c-solution-linked-list-two-pointer-best-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Linklist + Two Pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approache by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\n/*\\n\\n    Time Complexity :O(N), because we are traversing over the elements exactly one. Thus the time complexity is\\n    linear.\\n\\n    Space Complexity : O(1), because we have used constant elements. Thus the space complexity is constant.\\n\\n    Using Linklist + Two Pointer.\\n\\n*/\\n\\n\\n/********************************************* First Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                if(prev == NULL){\\n                    head = curr->next;\\n                }\\n                else{\\n                    prev->next = curr->next;\\n                }\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Second Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail->next = curr;\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/********************************************* Third Code *********************************************/\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL){\\n            return head;\\n        }\\n        ListNode* curr = head;\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n        dummyTail->next = curr;\\n        while(curr != NULL && curr->next != NULL){\\n            if(curr->val == curr->next->val){\\n                while(curr->next != NULL && curr->val == curr->next->val){\\n                    curr = curr->next;\\n                }\\n                dummyTail->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                dummyTail = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120308,
                "title": "sabse-easy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head -> next){\\n\\t\\treturn head;\\n     }\\n        \\n        int target = head -> val;\\n\\n        if(head -> next -> val == target){\\n            while(head -> next && head -> next -> val == target){\\n               head = head -> next; \\n            }\\n           \\n            head = deleteDuplicates(head -> next); \\n        }\\n        \\n      \\n        else{\\n            \\n            head -> next = deleteDuplicates(head -> next);\\n        }\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066893,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* t=head;\\n        int c=1;\\n        ListNode* dummy=new ListNode(1);\\n        ListNode* ans=dummy;\\n        int f=1;\\n        while(f && t)\\n        {\\n            ListNode* p=t;\\n            int c=0;\\n            while(t->next && t->val==t->next->val)\\n            {\\n                c++;\\n                t=t->next;\\n            }\\n            if(c==0)\\n            {\\n                ans->next=p;\\n                ans=ans->next;\\n            }\\n            t=t->next;\\n        }\\n        ans->next=NULL;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035441,
                "title": "my-accepted-python-code",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        if head is not None:\\n            if head.next is not None:\\n                if head.val == head.next.val:\\n                    headTemp = self.deleteDuplicates(head.next)\\n                    if headTemp is not None:\\n                        if head.val == headTemp.val:\\n                            if headTemp is not None:\\n                                return headTemp.next\\n                            return None\\n                    return headTemp\\n                else:\\n                    head.next = self.deleteDuplicates(head.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027773,
                "title": "javascript-solution-with-explanation-o-n-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is defining a function deleteDuplicates that takes in a singly linked list head and removes any duplicate nodes from the list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere is an explanation of the code:\\n\\nFirst, a dummy node is created with a value of 0 and it is set as the next node of the dummy node. This dummy node will be used to track the head of the list as it is modified. prev is set to dummy and curr is set to head.\\n\\nA while loop is then entered that will continue until curr is null. Inside the loop, there is another while loop that will continue until curr.next is null or curr.val is not equal to curr.next.val. This inner loop is used to move curr to the last occurrence of a value that is duplicated in the list.\\n\\nAfter the inner loop, there is an if statement that checks if prev.next is equal to curr. If it is, this means that curr was not a duplicate and prev should be advanced to curr. If prev.next is not equal to curr, this means that curr was a duplicate and prev.next should be set to curr.next to skip over the duplicates.\\n\\nFinally, curr is advanced to curr.next and the process repeats until curr is null. The modified list, with duplicates removed, is then returned as dummy.next.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), because the function iterates through the linked list once, and performs a constant amount of work on each iteration.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is also O(1), because the function only stores a constant amount of data (the dummy node, the prev and curr pointers) regardless of the size of the input.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteDuplicates = function(head) {\\n   let dummy = new ListNode(0)\\n    dummy.next = head;\\n    let prev = dummy, curr = head;\\n    while (curr) {\\n        while (curr.next && curr.val == curr.next.val)\\n            curr = curr.next\\n        if (prev.next == curr)\\n            prev = curr\\n        else\\n            prev.next = curr.next\\n        curr = curr.next\\n    }\\n    return dummy.next\\n\\n};\\n<!--I hope this helps!-->\\n<!--Please upvote if you like this solution-->\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2743244,
                "title": "beginner-level-to-optimised-solution",
                "content": "**1. Beginner Level -**\\n\\nIn this approach, we are using an auxliary space (HashMap and HashSet) to point out duplicates and in the HashSet we are not considering those duplicates.\\n\\nI can certainly tell that it is a very lengthy approach, but in an Interview, it is bit easy to come up with, if you have a good knowledge of HashMap & HashSet.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\\n\\n**Time Complexity = O(n)\\nSpace Complexity = O(n)**\\n\\n**2. Optimised Level :-**\\n\\nBelow is the algorithm for the problem - \\n\\n* Make three nodes `pre`, \\'ans\\' & `curr`.\\n* `pre` will be the previous node to the current node and `curr` will be the current node. \\'ans\\' will point to `pre` at first, and will stay there.\\n* While duplicates found in current node(`curr`), then move on to the next node.\\n* If we move on, then the `curr` will **NOT** certainly be the next node to the `pre` node.\\n* At this point of time `pre`\\'s next pointer will point to `curr`\\'s next pointer. This way we are linking the non-duplicate nodes togher.\\n* Else the `pre`\\'s  next pointer will point to `curr`. Also `pre` will move on by 1 node like `curr`.\\n* Move forward the curr.\\n* After traversing the entire list as `curr`, just return the next pointed node of `ans`, which is our answer.\\n\\nPlease practise it to get a better point of view.\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(n)\\nSpace Complexity: O(1)**\\n\\nHappy Coding :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) { return null; }\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ListNode node = head;\\n        \\n        // Traversing the LL and making the Map such that we can point duplicates\\n        while(node != null){\\n            if(map.containsKey(node.val)) { map.put(node.val, 1); }\\n            else { map.put(node.val, 0); }\\n            node = node.next;\\n        }\\n        \\n        HashSet<Integer> finalNodeVals = new HashSet<>();\\n        for(int i : map.keySet()){\\n            if(map.get(i) == 0) { finalNodeVals.add(i); }\\n        }\\n        \\n        if(finalNodeVals.size() == 0) { return null; }\\n        \\n        ListNode node1 = head, finalHead = head;\\n        boolean first = true;\\n        \\n        while(node1 != null){\\n            if(finalNodeVals.contains(node1.val) && first == true) { \\n                head = node1; finalHead = head; first = false; \\n            }\\n            else if(finalNodeVals.contains(node1.val) && first == false) { \\n                head.next = node1; head = head.next;\\n            }\\n            node1 = node1.next;\\n        }\\n        \\n        head.next = null;\\n        \\n        return finalHead;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode pre = new ListNode(0);\\n        pre.next = head;\\n        ListNode curr = head, ans = pre;\\n        \\n        while(curr != null){\\n            while(curr.next != null && curr.val == curr.next.val){\\n                curr = curr.next;\\n            }\\n            if(pre.next != curr){\\n                pre.next = curr.next;\\n            }\\n            else{\\n                pre.next = curr; pre = pre.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118235,
                "title": "cpp-easy-solution",
                "content": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```\\nPlease upvote if you like this solution .",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* dummyNode=new ListNode(-1); \\n    dummyNode->next=head;//add a extra node so that we can check that whether the repeated num starts from first node or not.\\n    ListNode* curr=dummyNode;\\n    \\n    while(curr->next != NULL and curr->next->next != NULL){\\n        if(curr->next->val != curr->next->next->val){\\n          curr=curr->next;\\n        }\\n        else{\\n            int value=curr->next->val;\\n            \\n            while(curr->next and curr->next->val == value){ //Checking repetitions of the duplicate node\\n                curr->next=curr->next->next;\\n            }\\n        }\\n    }\\n    return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832692,
                "title": "c-easy-to-understand-iterative-simple",
                "content": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\\n\\n**EXPLANATION**\\n\\n\\n* **Traverse the list** from the **head** (or start) node.\\n* While traversing, **compare each node with its next node**.\\n* If the data of the next node is the **same** as the current node then **skip** the next node.(don\\'t add to answer)\\n* If node has **unique value add to answer**  \\n* Then we need **update** our pointers.\\n\\nTIME COMPLEXITY : O(N) , N is number of Nodes\\nSPACE COMPLEXITY : O(1)\\n\\n\\n\\n\\n\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Linked list problem, Recursion.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n```\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n\\tif(!head || !head->next) return head; //base case\\n\\t\\n\\tListNode* prev,*start=head,*end=head;  // 3 pointers\\n\\tListNode* dummy=new ListNode();   // to handle corner case-> first element has duplicate\\n\\tprev=dummy;\\n\\t\\n\\twhile(end){\\n\\n\\t\\tif(end->next && end->val==end->next->val) {end=end->next; continue;} //skip duplicate\\n\\t\\t\\n\\t\\tif(!end->next && start!=end) {prev->next=NULL;break;} // to handle corner case-> last element has duplicate\\n\\t\\t\\n\\t\\tif(start==end) {prev->next=end, prev=prev->next;} //unique element add to answer\\n\\t\\t\\n\\t\\tstart=end->next, end=end->next; //update pointers\\n\\t}\\n\\t\\n\\treturn dummy->next; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832500,
                "title": "c-95-faster",
                "content": "![image](https://assets.leetcode.com/users/images/002a7e8a-8850-455a-bfad-c32c2e7efd6f_1646794760.4226303.png)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640463,
                "title": "c-easy-to-undersand-efficient-code-3-approaches",
                "content": "**Approach 1**\\n**Iterative method**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\\n**Approach 2**\\n**Recurcive solution**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\\n**Approach 3**\\n**Creating new nodes**\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* sentinel=new ListNode(0);\\n        sentinel->next=head;\\n        ListNode* pred=sentinel;\\n        if(!head)\\n        return NULL;\\n        while(head)\\n        {\\n            if(head->next!=NULL&&head->val==head->next->val)\\n            {\\n            while(head->next!=NULL&&head->val==head->next->val)\\n            {\\n                head=head->next;\\n            }\\n                pred->next=head->next;\\n            }\\n            else\\n            {\\n                pred=pred->next;\\n            }\\n            head=head->next;\\n        }\\n        return sentinel->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       if(!head)\\n       return NULL;\\n       if(!head->next)\\n       return head;\\n       int value=head->val;\\n        ListNode* curr=head->next;\\n        if(curr->val==value)\\n        {\\n            while(curr&&curr->val==value)\\n            {\\n                curr=curr->next;\\n            }\\n            return deleteDuplicates(curr);\\n        }\\n        else\\n        {\\n            head->next=deleteDuplicates(curr);\\n            return head;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head)\\n        return NULL;\\n        unordered_map<int,int> freq;\\n        while(head)\\n        {\\n            freq[head->val]++;\\n            head=head->next;\\n        }\\n        vector<int> v;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second==1)\\n            v.push_back(pr.first);\\n        }\\n        if(v.size()==0)\\n        return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* temp=new ListNode(v[0]);\\n        ListNode* p=temp;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215315,
                "title": "simple-and-clear-explanation-of-recursive-solution",
                "content": "Problem Statement:[https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/](http://)\\n\\n### How to  write a Recursive function?\\n*We have to follow three steps to write a*  **recursive code** \\n1.  **Assumption:**\\n* \\t  Assumption is nothing but what do you want your function to do.\\n2. **Main Logic:**\\n*     Solving problem using sub problems\\n3. **Base Condition:**\\n*     When recursion should terminate \\n\\n**Before diving into the solution lets understand the question**:\\n\\tThey have given a Linked list, we have to remove all the occurences of an element whose frequency is more than one and return the new linkedlist.\\n\\t![image](https://assets.leetcode.com/users/images/3fae7b24-93ab-4cfd-b452-de689684fa2f_1621272982.2501419.png)\\n\\t\\nIn the given linkedlist frequencies of 3 and 4 is 2, which is greater than 1, so we have to delete all the occurence of 3 and 4 then we have to return head node of new linked list.\\n\\n### Defining our three steps in recursion\\n**Assumption:** Remove all the occurences of an element whose frequency is more than one and return the linkedlist.\\n\\n**Main Logic:** Here we have two cases for a node either to consider it or not in final linkedlist.\\n*    **Case-1:** If we land on a node whose frequency is 1, then we should \\n      consider it and this node should point to the **nextnode** in the linkedlist\\n      whose frequency is 1, if we don\\'t find any node then it should point to NULL.\\n*   **Case-2:** If we land on a node whose frequency is more than 1, then \\n\\t  we have to ignore all the nodes of same value till we get **nextnode** whose \\n\\t  frequency is 1, if we don\\'t find any node then it should point to NULL.\\n\\t  \\n**BaseCondition**: \\n*    If we are at **Last node** then there is no need to check its frequency (because we are at lastnode there will be no nodes after it, so it\\'s frequency is one.) so we can simply return that node.\\n*    If the head node is NULL then we have to return.\\n\\n### Recursive Solution:\\n```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```\\n\\nIf you have any doubts feel free to ask in comment section\\n\\nThis is my first article tell me your review on this and where can I improve.\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* recursiveDeletion(ListNode*head){\\n\\t\\t//Base Conditions:\\n\\t\\tif(head==NULL || head->next==NULL)\\n\\t\\t\\treturn head;\\n\\t\\t\\t\\n\\t\\tbool flag=false //To check the given node is repeating or not.\\n\\t\\tint headValue=head->val;\\n\\t\\t\\n\\t\\tListNode*temp=head->next; //temporary pointer for itearating till we get\\n\\t\\t\\t\\t\\t\\t\\t\\t //a node whose data is not equal to headValue.\\n\\t\\twhile(temp!=NULL && temp->next==headValue){\\n\\t\\t\\tflag=true;\\n\\t\\t\\ttemp=temp->next; //shift to next node \\n\\t\\t}\\n\\t\\t//Now temp pointer points to a node whose value is different from headValue.\\n\\t\\t\\n\\t\\t// MAIN LOGIC: Case-2 (frequency more than 1)\\n\\t\\tif(flag==true){\\n\\t\\t\\treturn recursiveDeletion(temp);\\n\\t\\t\\t// we are not appending temp node to the previous node of head \\n            //because we don\\'t know whether temp node is repeating or not \\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\t//Case-1 ( frequency is 1)\\n\\t\\t\\thead->next= recursiveDeletion(head->next);\\n\\t\\t\\t// we are considering head in our linkedlist\\n\\t\\t\\t\\n\\t\\t\\treturn head;\\n\\t\\t\\t//******why should we return head?***********\\n\\t\\t\\t// beacuse we have to link head node to the prev node as we called\\n\\t\\t\\t//prev->next=recursiveDeletion(prev->next)  prev->next == head \\n            //as head is not repeating we have to return pointer of head.\\n\\t\\t\\t\\n\\t\\t\\t//head points to the nextnode return by the function it can either be\\n\\t\\t\\t // NULL or a node\\n\\t\\t\\t\\n\\t\\t}\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1175415,
                "title": "c-8ms-o-n-solution",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n            temp=temp->next;\\n            prev=prev->next;\\n        }\\n           if(temp->val!=prev->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }\\n                \\n                else{\\n                     ListNode*node=new ListNode(temp->val);\\n                   temp2->next=node;\\n                temp2=node;   \\n                }\\n              \\n            }\\n        temp2->next=NULL;\\n        if(h->val==-102)\\n            return NULL;\\n        return h;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        ListNode*prev=new ListNode(-101);\\n        prev->next=head;\\n        ListNode*temp=head;\\n        ListNode*temp2=new ListNode(-102);\\n        ListNode*h=temp2;\\n        while(temp->next!=NULL){\\n            if(temp->val!=prev->val && temp->val!=temp->next->val){\\n                if(temp2->val==-102){\\n                      temp2->val=temp->val;\\n                    h=temp2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 805304,
                "title": "both-recursive-and-iterative-c",
                "content": "\\n         //iterative\\n\\t\\t \\n        class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }else{\\n                        tail->next=head;\\n                        tail=tail->next;\\n                        head=head->next;\\n                    }\\n                }\\n                tail->next=NULL;\\n                return newhead->next;\\n            }\\n        };\\n\\t\\t\\n\\t\\t//recursive\\n\\t\\t\\n\\t\\tclass Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==nullptr) return head;\\n                ListNode* p1=head->next;\\n                if(p1 && p1->val==head->val){\\n                 while(p1 && p1->val==head->val) {\\n                     p1=p1->next;\\n                 }\\n                    return deleteDuplicates(p1);\\n                }\\n                else \\n                head->next = deleteDuplicates(head->next);\\n                return head;\\n            } \\n        };\\n\\t\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public:\\n            ListNode* deleteDuplicates(ListNode* head) {\\n                if(head==NULL ||head->next==NULL)\\n                    return head;\\n                ListNode *tail= new ListNode(-1);\\n                ListNode* newhead=tail;\\n                while(head!=NULL){\\n                    if(head->next!=NULL && head->val==head->next->val){\\n                        int curr=head->val;\\n                        head=head->next;\\n                        while(head && head->val==curr)\\n                            head=head->next;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 509070,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return \\n        ret = pre = ListNode(0)\\n        ret.next = cur = head\\n        while(cur.next):\\n            nxt = cur.next\\n            if cur.val == nxt.val:\\n                while(nxt.next and nxt.val == nxt.next.val):\\n                    nxt = nxt.next\\n                pre.next = cur = nxt.next\\n                if not cur: return ret.next\\n            else:\\n                pre,cur,nxt = cur,nxt,nxt.next\\n            \\n            \\n        return ret.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234766,
                "title": "python-recursive-iterative-easy-to-understand-both-beat-100",
                "content": "recursive:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\\niterative:\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        if not head or not head.next: return head\\n        nxt = head.next\\n        if nxt.val != head.val:\\n            head.next = self.deleteDuplicates(nxt)\\n            return head\\n        else:\\n            while nxt and nxt.val == head.val:\\n                nxt = nxt.next\\n            return self.deleteDuplicates(nxt)\\n```\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: \\'ListNode\\') -> \\'ListNode\\':\\n        dum = ListNode(0)\\n        dum.next, pre, cur = head, dum, head\\n        while cur:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur: \\n                pre = cur\\n            else: \\n                pre.next = cur.next\\n            cur = cur.next\\n        return dum.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28333,
                "title": "accpted-javascript-solution",
                "content": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nconst deleteDuplicates = function(head) {\\n    if(head === null || head.next === null) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    head = dummy;\\n    \\n    while(head.next !== null && head.next.next !== null) {\\n        if(head.next.val === head.next.next.val) {\\n            let val = head.next.val;\\n            while( head.next !== null && head.next.val === val ){\\n                head.next = head.next.next;\\n            }\\n        } else {\\n            head = head.next;\\n        }\\n\\t}\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28594,
                "title": "11-lines-c-solution-with-comments",
                "content": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "solutionTags": [],
                "code": "    \\tListNode *deleteDuplicates(ListNode *head) {\\n        if(!head||!head->next)return head;\\n        ListNode *newhead=0,**phead=&newhead;//phead pointer to new head pointer\\n        while(head)\\n        {\\n            if(head->next&&head->val==head->next->val)\\n\\t\\t\\t{//skip all nodes has duplicate value\\n\\t\\t\\t\\tint dupval=head->val;\\n\\t\\t\\t\\twhile(head&&head->val==dupval)head=head->next;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}//assign and advance phead\\n\\t\\t\\telse {*phead=head; phead=&((*phead)->next);}\\n\\t\\t\\thead=head->next;\\n        }\\n        *phead=0;// point the next of last node to NULL\\n        return newhead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3835448,
                "title": "easy-c-solution",
                "content": "\\n# Approach\\nCreate a dummy node:\\n\\nWe start by creating a dummy node that acts as the \"head\" of the updated linked list. The dummy node will have a value of 0 and point to the original head of the linked list.\\nInitialize pointers:\\n\\nWe initialize two pointers, head and prev, both pointing to the dummy node initially.\\nThe head pointer is used to traverse the original linked list, and the prev pointer is used to keep track of the last non-duplicate node in the updated linked list.\\nTraverse the linked list:\\n\\nWe use a while loop to iterate through the linked list until the head pointer reaches the end (NULL).\\nInside the loop, we check if the current node\\'s value is equal to the value of its next node (indicating a duplicate).\\nRemove duplicates:\\n\\nIf a duplicate is found (i.e., head->val == head->next->val), we enter another nested while loop to skip all the consecutive nodes with the same value. This ensures that we find the last node with the same value.\\nUpdate pointers:\\n\\nAfter the nested loop, head will be pointing to the last duplicate node.\\nWe then update the prev->next pointer to skip all the duplicate nodes and point to the node after the last duplicate node.\\nIf no duplicates were found, we simply move the prev pointer to the next node.\\nMove head pointer:\\n\\nIn either case (duplicate found or not), we move the head pointer to the next node.\\nReturn the updated linked list:\\n\\nAfter the loop ends, the original linked list is modified such that all duplicates are removed, and the prev pointer points to the last non-duplicate node.\\nWe return dummy->next, which is the head of the updated linked list.\\nThis approach effectively removes all duplicate elements from the linked list while maintaining the order of the non-duplicate elements.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head)\\n    {\\n        ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {\\n            if(head->next!=NULL && head->val==head->next->val)\\n            {\\n                while(head->next!=NULL && head->val==head->next->val)\\n                {\\n                    head=head->next;\\n                }\\n            prev->next=head->next;\\n            }\\n            else\\n            {\\n                prev=prev->next;\\n            }\\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404383,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate through the list while counting the frequency of every element. If the frequency of the element is one then we add the element to the list.\\n\\nTo do this take a previous pointer and point it to NULL. Take a temporary pointer to iterate though the list. Count the frequency of every element. If the frequency is one, point the prevoius Node to the current Node and initialize the privious node to the current Node. But if the previous node is NULL, then initialize head pointer to the current Node and previous Node to also the current node. When temp reaches to NULL and previous node is not NULL then point the Previous Node to NULL.\\n\\nBut if the prevoius node is still is NULL it means the list has no value of single frequency. In this case return NULL.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Cause the list is iterated only once. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity $$O(1)$$ We only use constant size variables\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        ListNode* temp = head;//Temporary pointer\\n        ListNode* pre = NULL;//Initializing previous pointer to NULL\\n        \\n        /* Looping through the list untill the tempurary pointer\\n        reaches NULL */  \\n        while(temp != NULL){\\n\\n            int k = 1;\\n            ListNode* curr = temp; //Initialize current pointer to temp\\n            \\n            //Counting the frequency of the current element\\n            while((temp != NULL) && (temp->val == curr->val)){\\n                temp = temp->next;\\n                k++;\\n            }\\n            k--;\\n\\n            //If frequency of the element is 1 put it in the the list\\n            if(k == 1){\\n\\n                // If the previous pointer is null then initialize\\n                // the head pointer  and the previous pointer \\n                // to the current pointer\\n  \\n                if(pre == NULL){\\n                    head = curr;\\n                    pre = curr;\\n                }\\n\\n                //if not then previous to current and next value of\\n                // privious pointer to current pointer\\n                else{\\n                    pre->next = curr;\\n                    pre = curr;\\n                }\\n            }\\n            // when temporary pointer reaches to NULL\\n            // and prevoius pointer is not null then initialie\\n            // next value of prevoius pointer to NULL or temp\\n\\n            if(temp == NULL && pre != NULL){\\n                pre->next = temp;\\n            }\\n        } \\n\\n        // If prevoius pointer is still is NULL, it means that \\n        // no value is eligible for the ans list\\n        // so initialize head to NULL and return head\\n\\n        if(pre == NULL){\\n            head = NULL;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383200,
                "title": "java-simple-straightforward-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        // Create a new LikedList that will contain our final answer in .next\\n        ListNode newList = new ListNode();\\n        // Create a copy of the head of the new LinkedList\\n        ListNode newListHead = newList;\\n\\n        // Iterate over the list\\n        while(head != null){\\n            // Keep track of whether or not we moved over a chunk of duplicated\\n            boolean wentOverAChunk = false;\\n            // This while loop jumps over the chunk of duplicated\\n            while(head.next != null && head.next.val == head.val){\\n                head = head.next;\\n                wentOverAChunk = true; // Set to true if we encountered duplicates\\n            }\\n            // If we haven\\'t encountered duplicates, add a copy of the node to the newList\\n            if(!wentOverAChunk){\\n                newList.next = new ListNode(head.val);\\n                newList = newList.next;\\n            }\\n            head = head.next;\\n        }\\n        return newListHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235911,
                "title": "python-93-83-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        d={}\\n        temp=head\\n        while temp!=None:\\n            if temp.val in d:\\n                d[temp.val]+=1\\n            else:\\n                d[temp.val]=1\\n            temp=temp.next\\n        temp=head\\n        L=ListNode()\\n        temp2=L\\n        while temp!=None:\\n            if temp.next==None and d[temp.val]>1:\\n                temp2.next=None\\n            if d[temp.val]>1:\\n                temp=temp.next\\n            else:\\n                temp2.next=temp\\n                temp2=temp2.next\\n                temp=temp.next\\n        return L.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368612,
                "title": "c-recusrive-solution-easy-understanding",
                "content": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n if(!head || !head->next)\\n        return head;\\n        \\n        Node*next=head->next;\\n        if(head->data==next->data)\\n        {\\n            while(next && next->data==head->data)\\n                next=next->next;\\n            return removeAllDuplicates(next);\\n        }\\n        else\\n        {\\n            head->next=removeAllDuplicates(next);\\n            return head;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2242508,
                "title": "golang-solution-sentinel-node",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // sentinel\\n    sentinel := &ListNode{Next: head}\\n    \\n    // predecessor = the last node\\n    // before the sublist of duplicates\\n    pred := sentinel\\n    \\n    for head != nil {\\n        if head.Next != nil && head.Val == head.Next.Val {\\n            for head.Next != nil && head.Val == head.Next.Val {\\n                head = head.Next\\n            }\\n            \\n            pred.Next = head.Next\\n        } else {\\n            pred = pred.Next\\n        }\\n        \\n        // move forward\\n        head = head.Next\\n    }\\n    \\n    return sentinel.Next\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1833627,
                "title": "python-go-dummy-node-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F Dummy Node Solution and Explanation \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\nIt is very important to set a dummy node **points to head**, in this question the head of linked lists will be change if original head is duplicate\\n\\nFor Example 2\\n\\n\\thead = [1,1,1,2,3], Output: [2,3]\\n\\nYou can see that we change head to 2, so it\\'s important to set a dummy node before head and then we return dummy.next\\n\\nAnother requirement for this question is that we have to remove duplicate nodes.\\n\\n**Algorithm**\\n\\n0. We set a prev node, before we traverse into list\\n1. We set subHead = prev.next, and sent it to traverse the list.\\nOnce we find that **subHead.val != subHead.next.val** means subHead is not duplicate, we can move prev.next = subHead, and move prev forwar\\n2. If we find that subHead is **duplicate**, and then move subHead = subHead.next until **subHead.val != subHead.next.val** (Could be None or new value)\\nAnd then we make **prev.next = subHead.next**\\nNote that we not move prev forward at this stage, only remove duplicate. We only move prev forward to non duplicate nodes which will be excute at step2\\n## Complexity Analysis\\n* Time: O(N): Let N be the length of linked list\\n* Space: O(1)\\n## Floyd\\'s Cycle Detection Code\\n**Python**\\n```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\\n**Go**\\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        # Create a dummy node\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        \\n        while prev.next and prev.next.next:\\n            # Init subHead\\n            subHead = prev.next\\n            # If not duplicate move prev forward\\n            if subHead.val != subHead.next.val:\\n                prev.next = subHead\\n                prev = prev.next\\n                continue\\n            # If duplicate remove them and point prev.next to next integer\\n            # Note that we not move prev forward at this stage, only remove duplicate\\n            while subHead.next and subHead.val == subHead.next.val:\\n                subHead = subHead.next\\n            prev.next = subHead.next\\n        # return head\\n        return dummy.next\\n```\n```go\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    // Create a dummy node\\n    dummy := ListNode{0, head}\\n    prev := &dummy\\n    \\n    for prev.Next != nil && prev.Next.Next != nil{\\n        // Init subHead\\n        subHead := prev.Next\\n        // If not duplicate move prev forward\\n        if subHead.Val != subHead.Next.Val{\\n            prev.Next = subHead\\n            prev = prev.Next\\n            continue\\n        }\\n        // If duplicate remove them and point prev.next to next integer\\n        // Note that we not move prev forward at this stage, only remove duplicate\\n        for subHead.Next != nil && subHead.Val == subHead.Next.Val{\\n            subHead = subHead.Next\\n        }\\n        prev.Next = subHead.Next\\n        \\n    }\\n\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833360,
                "title": "c-2-methods-100-faster-easy-to-understand",
                "content": "**Method 1 :**  Brute Force [ TC : O(N)  & SC : O(N) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\\n\\n\\n**Method 2:** Optimize Solution [ TC : O(N)  & SC : O(1) ]\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        unordered_map<int,int>m;\\n        ListNode* h = new ListNode(0);\\n        \\n        ListNode* curr = head;\\n        while(curr)\\n        {\\n            m[curr->val]++;\\n            curr = curr->next;\\n        }\\n        \\n        curr = h;\\n        ListNode* temp = head;\\n        while(temp)\\n        {\\n            if(m[temp->val] == 1)\\n            {\\n                curr->next = temp;\\n                curr = curr->next;\\n            }\\n            \\n        temp = temp->next;\\n        }\\n        curr->next = NULL;\\n\\n        return h->next;\\n        \\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* h = new ListNode(0);\\n        ListNode* prev = h;\\n        ListNode* curr = head;\\n     \\n        \\n        while(curr)\\n        {\\n            if(curr->next && curr->val == curr->next->val)\\n            {\\n                while(curr->next && curr->val == curr->next->val)\\n                    curr = curr->next;\\n            }\\n            else\\n            {\\n                   prev->next = curr;\\n                    prev = curr;   \\n            }\\n            \\n            curr = curr->next;\\n        }\\n        prev->next = NULL;\\n        return h->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832967,
                "title": "tc-o-n-sc-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        \\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode* temp=head;\\n        ListNode* prev=dummy;\\n        \\n        while(temp!=NULL){\\n            if(temp->next!=NULL && temp->val == temp->next->val){\\n                while(temp->next!=NULL && temp->val == temp->next->val)\\n                    temp=temp->next;\\n                prev->next=temp->next;\\n            }\\n            else if(prev->next!=NULL)\\n                prev=prev->next;\\n            temp=temp->next;      \\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783662,
                "title": "java-solution-with-dry-run",
                "content": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prev = dummy;\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && head.val == head.next.val)\\n            {\\n                while(head.next != null && head.val == head.next.val)\\n                {\\n                    head = head.next;\\n                }\\n                \\n                prev.next = head.next;\\n                head = head.next;\\n            }\\n            else\\n            {\\n                prev= prev.next;\\n                head = head.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nprev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nhead will keep track of removing the duplicates elements of Sorted LL\\nso when head.next != null and head.next.val == head.val \\nmove the head pointer to it\\'s next until head.next.val != head.val\\n \\nWhen head.next.val not equal to head.val then just mov prev and head pointer by one step\\n\\n\\n         prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\n              prev  head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\nNow head.next.val == head.val so move head pointer till head.next.val != head.val\\n\\n\\n              prev      head\\n  0    --> 1 -> 2 -> 3 -> 3 -> 4 -> 4 ->5\\ndummy\\n\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n              prev      head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\n2. head = head.next\\n              prev          head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\n\\nnow head.val == head.next.val so move head pointer till head.next.val != head.val\\n\\n              prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |_____________|\\n\\nNow head is pointing to last occurence of duplicate element so connect pre next to head next  and move head to it\\'s next\\n\\n1. prev.next = head.next\\n\\n             prev               head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\n2. head = head.next\\n\\n             prev                    head\\n  0    --> 1 -> 2   3 -> 3 -> 4 -> 4 ->5\\ndummy           |______________________|\\n\\n\\nResultant LL  : \\n\\n     0 -> 1->2->5\\n    dummy    \\n    \\n    RETURN dummy.next\\n\\n\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1703186,
                "title": "c-easy-to-understand-faster-than-95-percent",
                "content": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL or head->next == NULL){\\n            return head;\\n        }\\n        ListNode * temp = head;\\n        ListNode * prev = new ListNode(-2);\\n        ListNode * head1 = prev;\\n        prev->next = head;\\n        int find = head->val;\\n        while(temp != NULL){\\n            if(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                while(temp != NULL and temp->next != NULL and temp->val == temp->next->val){\\n                    temp = temp->next;\\n                }\\n                prev->next = temp->next;\\n                temp = prev->next;\\n            }\\n            else{\\n                prev = prev->next;\\n                temp = temp->next;\\n                \\n            }\\n        }\\n        return head1->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1407383,
                "title": "ultra-simple-cpp-solution-suggestions-for-optimization-are-welcomed",
                "content": "Runtime: 8 ms, faster than 60.39% of C++ online submissions for Remove Duplicates from Sorted List II.\\nMemory Usage: 11.1 MB, less than 90.02% of C++ online submissions for Remove Duplicates from Sorted List II.\\n\\nT(n) = O(n)\\nS(n) = O(1)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n        ListNode* curr   = head;\\n        ListNode* prev   = nullptr;\\n        ListNode* ahead  = head;\\n        \\n        \\n        while(curr){\\n            \\n            if(curr->next && curr->val==curr->next->val){\\n                \\n                while(curr->next && curr->val==curr->next->val)\\n                    curr = curr->next;    \\n                \\n                if(prev==nullptr){\\n                    head = curr->next;\\n                    prev==nullptr;\\n                }\\n                else\\n                    prev->next = curr->next;    \\n                \\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235937,
                "title": "c-recursion-easy",
                "content": "As the solution is recursive, let\\'s see the base cases.\\n1. If the ```head``` is ```NULL``` return ```head```, coz nothing to do further.\\n2. Else check for the duplicates of ```head``` with the help of temp pointer and update the ```head```\\n3. If the present ```temp``` or ```head``` is not ```NULL``` then call the deleteDuplicates on ```temp->next```.\\n4. Return ```head```.\\n\\nHope this helps!\\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```head```\n```NULL```\n```head```\n```head```\n```head```\n```temp```\n```head```\n```NULL```\n```temp->next```\n```head```\n```\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head) return head;\\n        ListNode* temp = head;\\n        while(head and head->next and head->val == head->next->val){\\n            while(temp and head->val == temp->val)\\n                temp = temp->next;\\n            head = temp;\\n        }\\n        if(temp)\\n        temp->next = deleteDuplicates(temp->next);\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232028,
                "title": "different-way-to-write-the-solution-python-code-not-using-two-while-loops",
                "content": "I tried alternate approach compared to solution.\\n\\n\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\\n        s = ListNode(0, head)\\n        p = s\\n        d = None\\n        while s and s.next and s.next.next:\\n            if s.next.val == s.next.next.val:\\n                d = s.next.val\\n                s.next = s.next.next.next\\n            elif d is not None and d == s.next.val:\\n                s.next = s.next.next\\n            else:\\n                s = s.next\\n        if s.next and s.next.val == d:\\n            s.next = s.next.next\\n        return p.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003306,
                "title": "remove-duplicates-from-sorted-list-ii-c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        //recursion exit condition\\n        if (!head||!head->next) return head;\\n        \\n        ListNode* node = head->next;\\n        \\n        //case: node val is not a duplicate of head val\\n        if (node->val != head->val) {\\n            //repeat process with next two nodes\\n            head->next = deleteDuplicates(node);\\n            return head;\\n        } \\n        //case: node val is a duplicate of head val\\n        else {\\n            //remove all nodes until no duplicate value as head, or end of list\\n            while (node && node->val == head->val) node = node->next;\\n            //return node here because head is part of the duplicate\\n            return deleteDuplicates(node);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715415,
                "title": "java-recursion-o-n",
                "content": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode deleteDuplicates(ListNode head) {\\n\\tif( head != null && head.next != null) {            \\n\\t\\tif(head.next.val != head.val) {\\n\\t\\t\\thead.next = deleteDuplicates(head.next);\\n\\t\\t} else {\\n\\t\\t\\twhile(head.next != null && head.val == head.next.val)\\n\\t\\t\\t\\thead = head.next;\\n\\t\\t\\treturn deleteDuplicates(head.next);\\n\\t\\t}\\n\\t}\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362394,
                "title": "java-recursive-and-iterative-approaches",
                "content": "Recursive approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\n\\nIterative approach:\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        // When the current heads are followed with a bunch of duplicates;\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode dummyHead = new ListNode(0);\\n        dummyHead.next = head;\\n        ListNode cur = dummyHead;\\n        while (cur.next != null && cur.next.next != null) {\\n            // pass when no duplicate\\n            if (cur.next.val != cur.next.next.val) {\\n                cur = cur.next;\\n                continue;\\n            }\\n            ListNode prev = cur;\\n            cur = cur.next;\\n            while (cur.next != null && cur.val == cur.next.val) {\\n                cur = cur.next;\\n            }\\n            prev.next = cur.next;\\n            cur = prev;\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249643,
                "title": "swift-solution",
                "content": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        var temp = ListNode(0)\\n        var slow: ListNode? = temp, fast = head\\n        while slow != nil {\\n            if fast != nil && fast!.val == fast!.next?.val {\\n                while fast!.val == fast!.next?.val {\\n                    fast = fast!.next\\n                }\\n                fast = fast?.next\\n            \\n            } else {\\n                slow!.next = fast\\n                slow = slow?.next\\n                fast = fast?.next\\n            }\\n        }\\n        return temp.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225398,
                "title": "python-simple-recursive-100-with-explanation",
                "content": "Look at the first node, it is either duplicate or unique.\\n**(1)** duplicate: it is like A-A-......-B, then B is the head we return\\n**(2)** unique: it is like A-B-......, then A is the head we return\\n```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Edge/Base case\\n        if not head or not head.next:\\n            return head\\n        # case (1)\\n        if head.val == head.next.val:\\n            while head.next and head.val == head.next.val:\\n                head = head.next\\n            return self.deleteDuplicates(head.next)    \\n        # case (2)\\n        else:\\n            head.next = self.deleteDuplicates(head.next)\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164789,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        curr = head\\n        prev = ListNode(0)\\n        prev.next = curr\\n        rec = prev\\n        while curr:\\n            dupl = False \\n            while curr.next and curr.val == curr.next.val:\\n                dupl = True\\n                curr = curr.next\\n            if dupl:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        return rec.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28522,
                "title": "super-simple-and-easy-to-understand-cpp-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }\\n\\n                if (p1==p2) {\\n                    p = p1;\\n                } else {\\n                    p->next = p2->next;\\n                }\\n\\n                p1 = p2 = p->next;\\n            }\\n\\n            return dummy.next;\\n\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* deleteDuplicates(ListNode* head) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *p = &dummy;\\n            ListNode *p1 = head;\\n            ListNode *p2 = head;\\n            while (p1) {\\n                while (p2->next && p1->val==p2->next->val) {\\n                    p2 = p2->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4019039,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null||head.next==null)return head;\\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode prev=dummy;\\n        ListNode cur=head;\\n        while(cur!=null){\\n            if(cur.next!=null && cur.val==cur.next.val){\\n                while(cur.next!=null && cur.val==cur.next.val){\\n                    cur=cur.next;\\n                }\\n                prev.next=cur.next;\\n            }\\n            else{\\n                prev=cur;\\n            }\\n            cur=cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840394,
                "title": "javascript-with-explanation",
                "content": "# Intuition\\nI had to review other answers to get a better understanding, but none of the explanation really were thorough enough to fully understand.\\n\\n# Approach\\nAs other have mentioned, we need to create a dummy node or preNode.\\nSince the intent is that we need a pre node in order for us to keep track and remove the duplicates. \\nIf we don\\'t have the pre node, we going to have a hard time updating the current node. The pre node is key to solving this problem.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nconst deleteDuplicates = function(head) {\\n    // Example head: [1,2,3,3,4,4,5]\\n    let dummyNode = new ListNode(0)\\n    dummyNode.next = head \\n    // dummyNode -> [0,1,2,3,3,4,4,5] \\n    // which now gives us a starting node to update once\\n    // we\\'ve found and removed duplicate\\n    // we assign dummyNode to list \\n    let list = dummyNode\\n\\n    // Start list = [0,1,2,3,3,4,4,5]\\n    // We want to continously check the next and the next.next node\\n    // AKA nodes 1 -> 2 above in list\\n    // The while loop below will reach the else statement until \\n    // we reach the  3 -> 3 nodes\\n    while (list.next && list.next.next) {\\n        if (list.next.val === list.next.next.val) {\\n            // [1,2,3,3,4,4,5]\\n            //      ^ ^ \\n            // Now that we\\'ve found our first duplicate,\\n            // it turns into a sub loop to remove not just one, \\n            // but all dupes, referring to 2nd Ex: [1,1,1,2,3]\\n            while (list.next && list.next.next && list.next.val === list.next.next.val) {\\n                 // [1,2,3,3,4,4,5]\\n                 //        ^ ^ \\n                list.next = list.next.next\\n                // Next, which is the 2nd node 3 gets updated to 4. \\n                // We then wold loop again in the while loop\\n                // which will be false, moving on to the next line below\\n            }\\n            // Now we remove the first 3 since it\\'s part of the dupes\\n            // list is 1 below, so list.next is 2\\n            // [1,2,3,4,4,5] -> [1,2,4,4,5]\\n            //  | ^   ^ \\n            list.next = list.next.next\\n        } else {\\n            // If not a dupe we update current with next.\\n            list = list.next\\n        }\\n    }\\n    return dummyNode.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3531498,
                "title": "simple-solution-two-pointer-c-java",
                "content": "\\n# Approach 1 - Using HashMap\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a hashmap and store the frequency of elements and recreate the linked list by taking the elements occurring once.\\n\\nBut for that we have to traverse the linked list twice and we will not use the fact that the given linked list is sorted.\\n\\n# Approach 2 - Two pointer\\n$$ Optimized \\\\hspace{0.2cm} solution $$\\n<!-- This is the actual solution in the code. -->\\nWe can use the given condition that the linked list is sorted and use two pointers to keep track of repeated nodes.\\n\\nKeep a `count` variable and keep track of number of occurances of nodes.\\n\\nTraverse through the linked list and add the elements which occur only once to the new linked list.\\n> **Optimization:** Can modify the given linked list without using extra space.\\n\\nNote: Don\\'t forget to check for the last element of the linked list.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```\\n\\n**Will you upvote if the solution was helpful?**",
                "solutionTags": [
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == NULL || head->next == NULL) return head;\\n\\n        ListNode *curr = head, *prev = NULL;\\n        ListNode *r_head = NULL, *r_tail = NULL;\\n\\n        int cnt = 0;\\n        while (curr != NULL) {\\n            if (prev == NULL || prev->val == curr->val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == NULL) {\\n                        r_head = new ListNode(prev->val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail->next = new ListNode(prev->val);\\n                        r_tail = r_tail->next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != NULL) {\\n            if (r_head == NULL) {\\n                r_head = new ListNode(prev->val);\\n            } else {\\n                r_tail->next = new ListNode(prev->val);\\n            }\\n        }\\n        return r_head;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    \\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode curr = head, prev = null;\\n        ListNode r_head = null, r_tail = null;\\n\\n        int cnt = 0;\\n        while (curr != null) {\\n            if (prev == null || prev.val == curr.val) {\\n                ++cnt;\\n            } else {\\n                if (cnt < 2) {\\n                    if (r_head == null) {\\n                        r_head = new ListNode(prev.val);\\n                        r_tail = r_head;\\n                    } else {\\n                        r_tail.next = new ListNode(prev.val);\\n                        r_tail = r_tail.next;\\n                    }\\n                }\\n                cnt = 1;\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        // To check for the last element of linked list\\n        if (cnt < 2 && prev != null) {\\n            if (r_head == null) {\\n                r_head = new ListNode(prev.val);\\n            } else {\\n                r_tail.next = new ListNode(prev.val);\\n            }\\n        }\\n        return r_head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453909,
                "title": "easy-and-simple-java-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n         ListNode curr=dummy;\\n        if(head==null || head.next==null){\\n             return head;\\n        }\\n        while(curr.next!=null && curr.next.next!=null){\\n          if(curr.next.val==curr.next.next.val){\\n              int value=curr.next.val;\\n              while(curr.next!=null && curr.next.val==value){\\n                  curr.next=curr.next.next;\\n              }\\n          }\\n          else{\\n              curr=curr.next;\\n          }  \\n        }\\n        return dummy.next;\\n        // ListNode ptr=head;\\n        // ListNode ptr2=head.next;\\n        // if(head==null || head.next==null){\\n        //     return head;\\n        // }\\n        // if(head.val==head.next.val){\\n        //     head=head.next.next.next;\\n        // }\\n        // while(ptr2.next!=null){\\n        //     if(ptr2.val==ptr2.next.val){\\n        //        ptr.next=ptr2.next.next;\\n        //        ptr2=ptr2.next.next;\\n        //     }\\n        //     else{\\n        //         ptr=ptr.next;\\n        //         ptr2=ptr2.next;\\n        //     }\\n        // }\\n        // return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239255,
                "title": "python-97-02-faster-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head==None or head.next==None:\\n            return head\\n        temp=head\\n        dummy=pre=ListNode()\\n        while temp and temp.next:\\n            if temp.val==temp.next.val:\\n                while temp and temp.next and temp.val==temp.next.val:\\n                    temp=temp.next\\n                temp=temp.next\\n                pre.next=temp\\n            else:\\n                pre.next=temp\\n                pre=pre.next\\n                temp=temp.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150415,
                "title": "1-baar-code-dekhe-fir-vishwas-kare-sabse-easy-approach-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        unordered_map<int,int> ump;\\n        ListNode* head1=new ListNode(0);\\n        ListNode *tomp=head1;\\n\\n        ListNode *temp=head;\\n        while(temp!=NULL)\\n        {\\n            ump[temp->val]++;\\n            temp=temp->next;\\n        }\\n         \\n        temp=head;\\n        while(temp!=NULL)\\n        {\\n            if(ump[temp->val]==1)\\n            {\\n             ListNode * temp1 =new ListNode(temp->val);\\n             tomp->next=temp1;\\n             tomp=temp1;\\n\\n            \\n               \\n\\n            }\\n            temp=temp->next;\\n        }\\n\\nreturn head1->next;\\n\\n    \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081759,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==NULL)\\n            return  NULL;\\n        ListNode* dummy = new ListNode(0,head);\\n        ListNode* p=dummy, *q=head;\\n        int flag=1;\\n        while(q && q->next){\\n            if(q->val == q->next->val){\\n                q=q->next;\\n                flag=0;\\n            }\\n            else{\\n                if(flag){\\n                    p=p->next;\\n                    q=q->next;\\n                }\\n                else{\\n                    p->next = q->next;\\n                    q=q->next;\\n                }\\n                flag=1;\\n            }\\n        }\\n        if(flag){\\n            p=p->next;\\n            q=q->next;\\n        }\\n        else{\\n            p->next = q->next;\\n            q=q->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059535,
                "title": "0ms-beats100-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n        ListNode dummy=new ListNode();\\n        dummy.next=head;\\n        ListNode ptr=dummy;\\n        while(ptr.next!=null && ptr.next.next!=null){\\n            if(ptr.next.val==ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057378,
                "title": "0ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null) return null;\\n\\n        ListNode ans=new ListNode();\\n        ans.next=head;\\n\\n        ListNode ptr=ans;\\n\\n        while(ptr.next!=null && ptr.next.next!=null){\\n\\n            if(ptr.next.val == ptr.next.next.val){\\n                int value=ptr.next.val;\\n                while(ptr.next!=null && ptr.next.val==value){\\n                    ptr.next=ptr.next.next;\\n                }\\n            }\\n            else{\\n                ptr=ptr.next;\\n            }\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831244,
                "title": "java-solution-faster-than-100-of-java-submissions-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {    \\n        ListNode result = new ListNode(0, null);\\n        ListNode curr = result;\\n        boolean isRepeated = false;\\n        while (head != null){\\n            while (head.next != null && head.val == head.next.val){\\n                isRepeated = true;\\n                head = head.next;\\n            }\\n            \\n            if (!isRepeated){\\n                curr.next = new ListNode(head.val, null);\\n                curr = curr.next;\\n            }\\n            \\n            isRepeated = false;\\n            head = head.next;\\n        }\\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834326,
                "title": "python-easy-solution",
                "content": "```\\n\\n```class Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        l = {}\\n        h = ret = ListNode(0)\\n        while head:\\n            if head.val not in l.keys():\\n                l[head.val] = 1\\n            else:\\n                l[head.val] += 1\\n            head = head.next\\n        for i in l.keys():\\n            if l[i] == 1:\\n                # print(i)\\n                ret.next = ListNode(i)\\n                ret = ret.next\\n        return h.next",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833325,
                "title": "remove-duplicate-from-sorted-list-ii-t-c-o-n-s-c-o-1",
                "content": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) \\n    {\\n\\t\\t// Return head, if no nodes are present or only one node is present.\\n        if (!head || !head->next)\\n            return head;\\n\\t\\t// Create a prev variable of ListNode type and initialize it with 0.\\n        ListNode* prev = new ListNode(0);\\n        ListNode* ans = prev; // To keep track of first element of the prev.\\n        ListNode* curr = head; \\n\\t\\t// Run the loop unless you find end of the loop or last node.\\n        while (curr && curr->next)\\n        {\\n\\t\\t\\t// Run another loop to skip the duplicate number.\\n            while (curr && curr->next && curr->val == curr->next->val)\\n            {\\n                int x = curr->val;\\n                while (curr && curr->val == x)\\n                    curr = curr->next;\\n            }\\n\\t\\t\\t// After skipping the nodes, join the prev node to the next of the last repeating or duplicate node.\\n            prev->next = curr;\\n            prev = prev->next;\\n            curr = (curr != NULL)? curr->next: NULL; // increment curr until it become NULL.\\n        }\\n\\t\\t// Return next of ans, since prev is having a dummy value a the first node.\\n        return ans->next;\\n    }\\n\\t// Even after running two nested loops, each node is visited only ones, hence the solution is O(n) and space requirement is O(1).\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597764,
                "title": "two-pointers-with-python",
                "content": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        dummy = ListNode(0,head)\\n        cur = head\\n        pre = dummy\\n        while cur and cur.next:\\n            while cur.next and cur.val == cur.next.val:\\n                cur = cur.next\\n            if pre.next == cur:\\n                pre = pre.next\\n                \\n            else:\\n                pre.next = cur.next\\n                \\n            cur = cur.next\\n\\n        return dummy.next\\n\\t\\t\\n\\n**Note**\\n\\n1. Linked list in python is a blind point to me. It was hard for me to realize that the `head` is actually a node, that points to the following list, say, `[1,2,3,3,4,4,5]`. \\n\\n2. In python, linked list has shallow copy too.\\n3. Whenever deal with the linked list type of problem, consider the feasibility of `dummy` node first. Two pointers must have a dummy node.",
                "codeTag": "Java"
            },
            {
                "id": 1545206,
                "title": "o-n-and-o-1",
                "content": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n\\t\\tListNode* tmp = new ListNode(-1);\\n        tmp->next = head;\\n        ListNode* prev = tmp;\\n        while(head != NULL && head->next != NULL)\\n        {\\n            if(head->val == head->next->val)\\n            {\\n                while(head->next != NULL && head->val == head->next->val)\\n                    head = head->next;\\n                head = head->next;\\n                prev->next = head;\\n            }\\n            else\\n            {\\n                prev = head;\\n                head = head->next;\\n            }\\n        }\\n        \\n        return tmp->next;",
                "codeTag": "Unknown"
            },
            {
                "id": 1520823,
                "title": "javascript-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n    let tmpHead = new ListNode();\\n    tmpHead.next = head;\\n    let cur = tmpHead;\\n    let visted = new Set();\\n    while(cur.next){\\n       let counter = 0;\\n       let val = cur.next.val;\\n       let tmp = cur.next;\\n       while(tmp && tmp.val == val){\\n           counter++;\\n           tmp =  tmp.next\\n       }\\n       if(counter > 1) cur.next = tmp;\\n       else cur = cur.next; \\n    }\\n    return tmpHead.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403605,
                "title": "recursive-rust-short-and-easy-to-understand-0ms-beats-100",
                "content": "I find recursion to be more intuitive for this problem. Essentially, if the current node\\'s value is the same as the previous node\\'s value (`prev`) or if the next node is not `None` and both the current node and the next node have the same value, then I\\'ll skip the current node. Or else, the `next` of the current node is the result of recursively calling the function using the next node as head, and the current node\\'s value as `prev`.\\n\\n```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        fn go(node: Option<Box<ListNode>>, prev: Option<i32>) -> Option<Box<ListNode>> {\\n            if let Some(mut n) = node {\\n                let x = Some(n.val);\\n                if x == prev {\\n                    go(n.next, prev)\\n                } else {\\n                    match n.next {\\n                        Some(n2) if n2.val == n.val => go(Some(n2), x),\\n                        _ => {\\n                            n.next = go(n.next, x);\\n                            Some(Box::new(*n))\\n                        }\\n                    }\\n                }\\n            } else {\\n                None\\n            }\\n        }\\n\\n        go(head, None)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368599,
                "title": "golang-clean-solution",
                "content": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteDuplicates(head *ListNode) *ListNode {\\n    prev := &ListNode{-101, head}\\n    res := prev\\n    \\n    for prev.Next != nil {\\n        val := prev.Next.Val\\n        removed := false\\n        \\n        for prev.Next.Next != nil && prev.Next.Next.Val == val {\\n            prev.Next = prev.Next.Next\\n            removed = true\\n        }\\n        \\n        if removed {\\n            prev.Next = prev.Next.Next\\n            continue\\n        } \\n        prev = prev.Next\\n    }\\n    return res.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265247,
                "title": "simplest-approach-and-explained-with-comments",
                "content": "**Idea is to count the number of nodes and if its freq is 1 connect them.**\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```\\n**If you found this approach helpful Please upvote this post :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL){\\n            return head;\\n        }\\n        \\n        ListNode *dummy = new ListNode(0);\\n        ListNode *iter = dummy;\\n        ListNode *cur = head;\\n        //itearte until cur is not NULL\\n        while(cur != NULL){\\n            //store the current node\\n           ListNode *temp = cur;\\n            //counter to store the value repeat\\n           int cnt = 0;\\n            //count number of times it is repeat\\n           while(cur != NULL and (temp -> val == cur -> val)){\\n               cur = cur -> next;\\n               cnt++;\\n           }\\n            //disconnect link with cur\\n           temp -> next = NULL;\\n            //if count is 1 \\n            //that means it is not repeated\\n           if(cnt == 1){    \\n             iter -> next = temp;\\n             iter = iter -> next;\\n           }\\n        }\\n        return dummy -> next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261074,
                "title": "simple-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n       ListNode *dummy=new ListNode(0,head);\\n        ListNode *prev=dummy;\\n        while(head!=NULL)\\n        {if(head->next!=NULL && head->val==head->next->val)\\n            {while(head->next!=NULL && head->val==head->next->val)\\n                    head=head->next;   \\n             prev->next=head->next;\\n            }\\n            else\\n            prev=head;  \\n        head=head->next;\\n        }\\n        return dummy->next;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1198277,
                "title": "c-one-pass-solution-o-n-time-o-1-space",
                "content": "Basically at each value, have a slow pointer wait there, and have another pointer go forward and see if any others have the same value.\\nSince we know that this list is sorted, if there is another node with the same value, we know that there are duplicates.\\nSimply overwrite the duplicates and set slow to fast (as fast will be set to a new value) and continue.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // zero or one nodes in list\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* res_curr = res;\\n        \\n        while (slow) {\\n            int c = 0;\\n            \\n            while (fast && slow->val == fast->val) {\\n                fast = fast->next;\\n                c++;\\n            }\\n            \\n            if (c < 2) {\\n                res_curr->next = slow;\\n                res_curr = res_curr->next;\\n            }\\n            \\n            if (!fast) {\\n                res_curr->next = nullptr;\\n                break;\\n            }\\n            slow = fast;\\n        }\\n        \\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179340,
                "title": "c-easy-using-maps",
                "content": "***Do upvote if it helped you to keep me motivated***  \\uD83D\\uDE0A\\u270C\\n***Explanation in the comments section***\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n      map<int,int> m;\\n      ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            m[temp->val]++;\\n            temp = temp->next;\\n        }\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        for(auto x: m)\\n        {\\n            if(x.second==1)\\n            {\\n               curr->next = new ListNode(x.first);\\n                curr = curr->next;\\n            }\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056505,
                "title": "c-0ms-two-pointers-iterative-beat-100-speed-and-96-87-memory",
                "content": "**Simple Understandable Two pointers approach. (Iterative)**\\n\\nIntializing two pointers temp and prev (previous), temp points to head and intially previous is dummy node (pointing to NULL). \\n1. Starting from head, compare every node value with its next node value.\\n2. If value is same, move temp pointer to the node until value is different. Now, temp is at present just before the node where value is different. **Point to next of this node with prev pointer ( because we want different value)** No need of extra pointer :).\\n3. Relocating the pointers to new postion and move ahead until last node.\\n\\nHere is the code for the same approach. \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp = head;\\n        ListNode* prev = new ListNode(0);\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->val== temp->next->val){\\n                while(temp->next != NULL && temp->val == temp->next->val ) {\\n                    temp->next = temp->next->next;\\n                }\\n                if(temp == head) head = temp->next;\\n                else {\\n                     prev->next = temp->next;\\n                     temp = temp->next;\\n                }\\n            }\\n            else {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003849,
                "title": "swift-solution-using-two-pointers-and-a-dummy-with-comments",
                "content": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteDuplicates(_ head: ListNode?) -> ListNode? {\\n        guard let head = head else { return nil }\\n        // Declare a dummy node to start from it and later use it to return the result.\\n        let dummy: ListNode? = ListNode(Int.min)\\n        // Connect dummy with the head\\n        dummy?.next = head\\n        // Use two pointer approach to be able to delete nodes in between them.\\n        var previous: ListNode? = dummy\\n        var current: ListNode? = dummy?.next\\n\\n        // Iterate through all nodes in the list\\n        while current != nil {\\n            // If we have a duplicate\\n            if current?.next?.val == current?.val {\\n                // Iterate until current points to the last duplicated node, needed if there\\'s more than 2 duplicates in a row\\n                while current?.next?.val == current?.val {\\n                    current = current?.next\\n                }\\n                // Remove duplicates by connecting previous with the node after last duplicate\\n                previous?.next = current?.next\\n                // Move current pointer to the next node to continue looping\\n                current = current?.next\\n            } else {\\n                // if the duplicate condition didn\\'t trigger, continue looping\\n                previous = current\\n                current = current?.next\\n            }\\n        }\\n        // The result is dummy\\'s next node\\n        return dummy?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003385,
                "title": "java-o-n-0ms-recursive-solution",
                "content": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n  Definition for singly-linked list.\\n  public class ListNode {\\n      int val;\\n      ListNode next;\\n      ListNode() {}\\n      ListNode(int val) { this.val = val; }\\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n  }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null)\\n            return head;\\n        if(head.next==null)\\n            return head;\\n        if(head.val !=head.next.val)\\n        {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }else{\\n            int temp = head.val;\\n            while(head!=null && head.val==temp)\\n                head=head.next;\\n            return deleteDuplicates(head);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003278,
                "title": "c-iteration-recursion-with-sentinel-head-predecessor",
                "content": "**Idea:**\\nSimulation.\\nJust begin with the conceret examples and try to solve them one by one: \\ni) with/without repetition,\\nii) repetition shows up in the middle, begining, ending.\\nDone.\\n\\n**Comments:**\\nWith iteration  apporach, you need address each corner cases.\\nWith recursion approach, you only need focus on the recursion pattern. Your code is only as crystal clear as your thinking. \\n\\nApproach 1: 2-pointer: Sentinel Head + Predecessor\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\\n\\nApproach 2: Recursion\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {        \\n        ListNode dummy(-101), *p = head, *p2=&dummy;        \\n        while(p){\\n            ListNode *l = p, *r = p->next;            \\n            while(r && l->val == r->val) r = r->next;                            \\n            if(l->next == r){ // no repetition\\n                p2->next = l;\\n                p2 = p2->next;\\n                p2->next = NULL; // break chain/list, example: [1, 2, 2]\\n            }\\n            p = r;            \\n        }\\n        return dummy.next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode * p = head->next;\\n        if(p->val != head->val){\\n            head->next = deleteDuplicates(head->next);\\n            return head;\\n        }else{\\n            while(p && p-> val == head->val) p = p->next;\\n            return deleteDuplicates(p);            \\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003000,
                "title": "simple-java-solution-with-explaination-0ms-100-faster",
                "content": "1.To avoid head null checks create dummy node and point dummy.next=head.\\n2.Take two pointers. prev and temp. prev point to dummy initially and temp point to head.\\n3. loop till temp and temp next is available. (as for single node nothing to be deleted)\\n4. if matching element found keep on incrementing temp without changing previous inside loop.\\n5. after loop finishes at point 4 we use boolean to check if some duplicates has found. if yes just point prev.next=temp.next. else just increment prev.\\n6. in any case if duplicate exists or not increment temp to point to next element. \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode dummy= new ListNode(101,head);\\n        ListNode prev = dummy;\\n        ListNode temp = head;\\n        boolean match=false;\\n        while(temp!=null && temp.next!=null) {\\n            match=false;\\n            while(temp.next!=null && temp.next.val==temp.val) {\\n                temp=temp.next;\\n                match=true;\\n            }   \\n            if(match) {\\n                prev.next=temp.next;\\n            } else {\\n                prev=prev.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758858,
                "title": "java-100-recursion-short-code",
                "content": "If you found the solution helpfu, kindly like or upvote. :)\\n\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head==null || head.next==null)\\n    \\t\\treturn head;\\n    \\tif(head.val!= head.next.val)\\n    \\t{\\n    \\t\\thead.next=deleteDuplicates(head.next);\\n    \\t\\treturn head;\\n    \\t}\\n    \\t//If there are duplicacy in head\\n    \\tListNode curr= head;\\n    \\twhile(curr !=null &&curr.val==head.val)\\n    \\t{\\n    \\t\\tcurr=curr.next;\\n    \\t}\\n    \\t\\n    \\treturn deleteDuplicates(curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738462,
                "title": "c-very-important-memory-leak-handled-beats-95-speed-and-100-memory",
                "content": "The major issue when handling pointers are to check for a memory leak. \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }\\n            return deleteDuplicates(p1);\\n        }\\n        else \\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    } \\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head==nullptr) return head;\\n        ListNode* p1=head->next;\\n        if(p1 && p1->val==head->val){\\n         while(p1 && p1->val==head->val) {\\n             ListNode* p2= p1;\\n             p1=p1->next;\\n             p2->next = nullptr;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 694199,
                "title": "java-solution-create-dummy-node",
                "content": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "````\\npublic ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if(head.next==null) return head;\\n        \\n        ListNode dummy=new ListNode(-1,head);\\n        ListNode p=dummy;\\n        \\n        while(p.next!=null){\\n                     \\n            ListNode n=p.next;\\n            while(n.next!=null && n.val==n.next.val){\\n                n=n.next;\\n            }\\n            \\n            if(p.next==n){\\n                p=n;\\n            }else{\\n                p.next=n.next;\\n            }\\n            \\n        }\\n        \\n        return dummy.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 396679,
                "title": "easy-to-understand-recursive-approach-and-iterative-approach-in-java-with-detailed-comment",
                "content": "Solution A: Recursive way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\\n\\nSolution B: Iterative way\\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        if(head.next != null && head.val == head.next.val){\\n            while(head.next != null && head.val == head.next.val){ // if current node is not unique, skip it and its duplicates, then check following\\n                head = head.next;\\n            }\\n            return deleteDuplicates(head.next);\\n        }else{\\n            head.next = deleteDuplicates(head.next); // if current node is unique, keep it, and check following\\n        }\\n        return head;\\n    }\\n```\n```\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode newDummy = new ListNode(-1); // the dummy head of the non-duplicate linked list\\n        ListNode nonDup = newDummy; // the pointer used to traverse non-duplicate linked list\\n        \\n        ListNode node = head; // the pointer used to traverse the original linked list\\n        \\n        while(node != null){\\n            if(node.next != null && node.val == node.next.val){\\n                int dupVal = node.val; // record the value of duplicates\\n                while(node != null && node.val == dupVal){\\n                    node = node.next; // skip all the duplicates\\n                }\\n            }else{\\n                nonDup.next = node;\\n                nonDup = nonDup.next;\\n                node = node.next;\\n            }\\n        }\\n        \\n        nonDup.next = null; // cut the following nodes referenced by node.next ...\\n        \\n        return newDummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386437,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* deleteDuplicates(struct ListNode* head) {\\n    if(head == NULL)\\n        return NULL;\\n    if(head->next && head->val == head->next->val) {\\n        /* Remove all duplicate numbers */\\n        while(head->next && head->val == head->next->val)\\n            head = head -> next;\\n        return deleteDuplicates(head->next);\\n    } else {\\n        head->next = deleteDuplicates(head->next);\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381446,
                "title": "c-best-solution-easy-simplest-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        \\n\\n        unordered_set<int> s;\\n        \\n        ListNode *t=head;\\n        \\n        if(!head)\\n            return head;\\n        \\n        while(t->next)\\n        {\\n            if(t->next->val == t->val)\\n                s.insert(t->val);\\n            \\n            t=t->next;\\n        }\\n        \\n        t=head;\\n        \\n        \\n        {\\n            while(t->next){\\n                if(s.find(t->next->val)!=s.end())\\n                    t->next=t->next->next;\\n                else\\n                    t=t->next;\\n                \\n            }\\n        }\\n        \\n        if(s.find(head->val)!=s.end())\\n            return head->next;\\n        else\\n            return head;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322205,
                "title": "javascript-straightforward-solution",
                "content": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar deleteDuplicates = function(head) {\\n\\n    let curr = head;\\n    let prev = null; // previous node\\n    \\n    while(curr != null && curr.next != null){\\n        let val; \\n        if(curr.val == curr.next.val){\\n            val = curr.val; // find next node not equal to val:\\n            while(curr != null && curr.val == val)\\n                curr = curr.next;\\n            // erase all \\'val\\' nodes:\\n            if(prev != null){  \\n                prev.next = curr;\\n            }\\n            else{\\n                head = curr;  // change head if it\\'s first node              \\n            }\\n        }\\n        else{\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n    }\\n   \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315543,
                "title": "java-recursive-solution-100-time-100-space",
                "content": "Time O(n)  Space O(n)\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```\\nIterative solution space is O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        if (head.val != head.next.val) {\\n            head.next = deleteDuplicates(head.next);\\n            return head;\\n        }\\n        while (head.next != null && head.val == head.next.val) {\\n            head = head.next;\\n        }\\n        return deleteDuplicates(head.next);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258435,
                "title": "c-solution-with-explanation",
                "content": "In terms of memory leak, it is dangerous to delete or free memories which are not allocated by your program.\\n\\nIn addition, modern C++ encourages programmers to use smart pointer classes, like shared_ptr, instead of pure pointers. Interviewers may be more than happy to disscuss these topics.\\n\\n```\\nclass Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }\\n            // check that element\\n            return deleteDuplicates(head->next);\\n        }\\n        // this head can be use, check the subsequent elements \\n        // and connect them together\\n        head->next = deleteDuplicates(head->next);\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // return the ptr of first non-repeating elements starting from head\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (!head || !head->next) return head; // base cases\\n        if (head->next->val == head->val) {\\n            // this head is duplicate and can not be used\\n            \\n            while (head->next && head->next->val == head->val) {\\n                // skip until a non-repeating element (or NULL) appears\\n                head = head->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 216313,
                "title": "clean-easy-to-understand-c-solution-without-memory-leaks",
                "content": "Most C/C++ solutions leak the nodes that are supposedly deleted or the \\'dummy\\' node. Here\\'s a clean, compact solution that actually doesn\\'t leak memory:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)  return head;\\n        \\n        ListNode dummyHead(0);  dummyHead.next = head;\\n        ListNode* crt = head;   ListNode* prev = &dummyHead;\\n        while (crt != nullptr && crt->next != nullptr)\\n        {\\n             if (crt->next->val == crt->val)\\n             {\\n                int duplicateVal = crt->val;\\n                while (crt != nullptr && crt->val == duplicateVal)\\n                {\\n                    prev->next = crt->next;\\n                    delete crt;\\n                    crt = prev->next;\\n                }\\n             }\\n             else\\n             {\\n                 prev = crt;\\n                 crt = crt->next;\\n             }\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28344,
                "title": "python-simple-solution",
                "content": "`curr` will always be the node behind, in case the next node is a duplicate that needs to be removed. Even the head can be removed. Hence having a dummy node solves this problem. \\n\\n*- Yangshun*\\n\\n```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        # Time: O(n)\\n        # Space: O(1)\\n        dummy = ListNode(None)\\n        dummy.next = head\\n        curr = dummy\\n        while curr:\\n            has_dup = False\\n            # Remove duplicates and leave the last of the duplicates.\\n            while curr.next and curr.next.next and curr.next.val == curr.next.next.val:\\n                curr.next = curr.next.next\\n                has_dup = True\\n            if has_dup:\\n                # Remove the last duplicate\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28388,
                "title": "simple-iterative-solution-with-memory-management",
                "content": "I am not sure why none of the top C++ answers has memory deletion. Here is my simple solution with correct memory release. Would appreciate suggestions.\\n```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* deleteDuplicates(ListNode* head) {\\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode *prev = &dummy;\\n        \\n        while (prev->next) {\\n            ListNode *cur = prev->next;\\n            if (cur->next && cur->next->val == cur->val) {\\n                do {\\n                    ListNode* tmp = cur->next->next;\\n                    delete cur->next;\\n                    cur->next = tmp;\\n                } while (cur->next && cur->next->val == cur->val);\\n                prev->next = cur->next;\\n                delete cur;\\n            } else {\\n                prev = prev->next;\\n            }\\n        }\\n      \\n        return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28501,
                "title": "share-beat-100-python-code",
                "content": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def deleteDuplicates(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy = ListNode(0)\\n        pt = dummy\\n        repeated = 0\\n        while head and head.next:\\n            if head.val != head.next.val:\\n                if not repeated:\\n                    pt.next = head\\n                    pt = pt.next\\n                repeated = 0\\n            else:\\n                repeated = 1\\n            head = head.next\\n            \\n        pt.next = None if repeated else head\\n        \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 4023606,
                "title": "java-beats-100-o-n-time-complexity-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        head = new ListNode(0, head);\\n        ListNode curr = head, prev = head;\\n\\n        while (curr != null && curr.next != null) {\\n            if (curr == head) {\\n                curr = curr.next;\\n                continue;\\n            }\\n            if (curr.val != curr.next.val) {\\n                prev = curr;\\n            }\\n            else {\\n                while (curr.next != null && curr.val == curr.next.val) {\\n                    curr = curr.next;\\n                }\\n                prev.next = curr.next;\\n            }\\n\\n            curr = curr.next;\\n        }\\n\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005092,
                "title": "best-recursive-solution-for-java",
                "content": "# Intuition\\nDo recursion with the given function, only need to declare a global variable. \\n\\n# Approach\\nA duplicate node is when the adjacents are holding sama value. When head is a duplicate node then store head as duplicate and check the next node for if it\\'s duplicate or not. Otherwise set head next by deleting duplicates from the head next node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode duplicate;\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if (head == null) {\\n            return head;\\n        } \\n        if (duplicate != null) {\\n            if (head.val == duplicate.val) {\\n                return deleteDuplicates(head.next);\\n            } else {\\n                duplicate = null;\\n                head = deleteDuplicates(head);\\n            }\\n        } else if (head.next != null && head.val == head.next.val) {\\n            duplicate = head;\\n            return deleteDuplicates(head.next.next);\\n        } else {\\n            duplicate = null;\\n            head.next = deleteDuplicates(head.next);\\n        }\\n        return head;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998727,
                "title": "easy-solution-without-extra-space-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing through the linked list maintaining previous pointer and connecting latest found (appearently) non duplicate node as it\\'s next.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. It first checks if the list is empty (has no elements). If it\\'s empty, there\\'s nothing to do, so it returns an empty list.\\n\\n2. It creates a special node called \\'x\\' and connects it to the beginning of the list. This helps in handling cases where the first element of the list is a duplicate.\\n\\n3. It sets up two pointers, \\'head\\' and \\'prev,\\' to traverse the list. \\'Head\\' is used to move through the list, and \\'prev\\' keeps track of the previous node.\\n\\n4. The code then goes through the list one element at a time using a loop.\\n\\n5. Inside the loop, it checks if the current element has duplicates by comparing its value with the next element\\'s value. If duplicates are found, it marks them and moves the \\'head\\' pointer past all duplicates.\\n\\n6. If duplicates were marked, it makes the \\'prev\\' node skip these duplicates by updating its \\'next\\' pointer to point to the first non-duplicate element.\\n\\n7. If no duplicates were found, it updates \\'prev\\' to the current element.\\n\\n8. It then moves the \\'head\\' pointer to the next element and repeats the process until it reaches the end of the list.\\n\\n9. Finally, it returns the modified list, which starts from \\'x->next,\\' excluding the initial \\'x\\' node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nTraversing through entire linked list for once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nNot using any extra space.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n    // Check if the linked list is empty, if so, return NULL\\n    if (!head) return NULL;\\n\\n    // Create a new node \\'x\\' and set its next pointer to the head of the linked list\\n    ListNode* x = new ListNode(0);\\n    x->next = head;\\n\\n    // Create a \\'prev\\' pointer to keep track of the previous node while traversing\\n    ListNode* prev = x;\\n\\n    // Loop through the linked list\\n    while (head) {\\n        // Initialize a boolean \\'dup\\' to false to track duplicate nodes\\n        bool dup = false;\\n\\n        // Check for duplicates by comparing the current node\\'s value with the next node\\'s value\\n        while (head->next && head->next->val == head->val) {\\n            head = head->next;\\n            dup = true;\\n        }\\n\\n        // If duplicates were found, update the \\'prev\\' node\\'s next pointer to skip the duplicates\\n        if (dup) {\\n            prev->next = head->next;\\n        } else {\\n            // If no duplicates were found, simply update \\'prev\\' to the current node\\n            prev = head;\\n        }\\n\\n        // Move to the next node in the linked list\\n        head = head->next;\\n    }\\n\\n    // Return the modified linked list starting from \\'x->next\\'\\n    return x->next;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974848,
                "title": "python-3-o-1-space-solution",
                "content": "##### UPVOTE IF YOU LIKE ;)\\n![SpidermanTobeyMaguireGIF.gif](https://assets.leetcode.com/users/images/b55a37a9-a9f5-4be8-a13e-455c0a0a2714_1693289534.1989064.gif)\\n\\n# Code\\n```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```\\n\\n# Explanation\\nCheck my blog for detailed explanations: https://gaebalogaebal.tistory.com/category/%5BLeetCode%5D\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```py\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # Base Case\\n        if not head: return None\\n        \\n        # Dummy Node\\n        dummy = ListNode(0, head)\\n\\n        # dup\\'s initial value is a value that \\n        # a node cannot have in this problem\\n        prev, cur = dummy, head\\n        dup = -101\\n        while cur.next:\\n            # If a duplicate is found, save that value\\n            if cur.val == cur.next.val:\\n                dup = cur.val\\n            \\n            # If the current node\\'s value is dup\\n            # Remove the current node\\n            if cur.val == dup:\\n                prev.next = cur.next\\n\\n            # If not just update prev to its next node                \\n            else:\\n                prev = prev.next\\n\\n            cur = cur.next\\n\\n        # Check the last node\\n        if cur.val == dup:\\n            prev.next = None\\n        \\n        return dummy.next\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961110,
                "title": "simple-c-solution",
                "content": "# Using Extra Space - Map\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int> mp;\\n        ListNode *temp=head;\\n        while(temp!=nullptr){\\n            mp[temp->val]++;\\n            temp=temp->next;\\n        }\\n        ListNode *res=new ListNode(0);\\n        temp=res;\\n        for(auto m:mp){\\n            if(m.second==1){\\n                temp->next=new ListNode(m.first);\\n                temp=temp->next;\\n            }\\n        }\\n        return res->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode *deleteDuplicates(ListNode *head){\\n        if(head==NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode *res=new ListNode(0);\\n        ListNode *current=head,*prevNode=res;\\n        while(current){\\n            bool isDuplicate=false;\\n            while(current->next && current->val==current->next->val){\\n                current=current->next;\\n                isDuplicate=true;\\n            }\\n            if(!isDuplicate){\\n                prevNode->next=current;\\n                prevNode=current;\\n            }\\n            current=current->next;\\n        }\\n        prevNode->next=nullptr;\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941117,
                "title": "putta-easy-solution-c-beats-95",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        if(head == NULL || head->next == NULL) return head;\\n        ListNode* newhead = new ListNode(0);\\n        ListNode* head2 =newhead ;\\n       ListNode* temp = head;\\n       while(temp) {\\n           int val = temp->val;\\n           ListNode* dummy = temp;\\n           temp = temp->next;\\n            int flag = 0;\\n           while(temp && val == temp->val){\\n               flag = 1;\\n               temp = temp->next;\\n            }\\n           if( flag == 0) {newhead->next = dummy;\\n           newhead = newhead->next;\\n           newhead->next = NULL;}\\n       }\\n       return head2->next;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890977,
                "title": "use-simple-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        dummy = ListNode(0)  \\n        dummy.next = head\\n        prev = dummy\\n        current = head\\n\\n        while current:\\n            next_node = current.next\\n\\n            while next_node and next_node.val == current.val:\\n                next_node = next_node.next\\n\\n            if current.next != next_node:\\n                prev.next = next_node\\n            else:\\n                prev = current\\n            \\n            current = next_node\\n\\n        return dummy.next\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890476,
                "title": "simple-iterative-c-solution",
                "content": "# Intuition\\nCompare adjacent values in the linked list and move the pointer to the next until repeated values are present. \\n\\n# Approach\\nCreate a new header for creating the new list. Iterate through the given list and if current value and value of the next pointer is same, iterate till the value repeats. If the values are not same, create a new node with the same value as the node. If header is null i.e. has not been assigned yet, then set the header equal to the new node, else, set header -> next = new node and header = header -> next.\\n\\nAt the end, if last element is not repeated create a new node with same value as that of last node and set header -> next to the last node.\\nReturn the new header which will be the new list with duplicated values removed.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n        if(head == NULL) return head;\\n\\n        if(head -> next == NULL) return head;\\n        \\n        ListNode *h = NULL;\\n        ListNode *start = head;\\n\\n        ListNode *ans = NULL;\\n\\n        bool f = false;\\n        \\n        while(start -> next != NULL) {\\n            if(start -> val == start -> next -> val) {\\n                int v = start -> val;\\n                while(start -> next -> val == v) {\\n                    start = start -> next;\\n                    if(start -> next == NULL) break;\\n                }\\n\\n                if(start -> next == NULL) {\\n                    f = true;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(h == NULL) {\\n                    ListNode *new_node = new ListNode(start -> val);\\n                    new_node -> next = NULL;\\n                    h = new_node;\\n                    ans = h;\\n                }\\n                else{\\n                    ListNode *node = new ListNode(start -> val);\\n                    node -> next = NULL;\\n                    h -> next = node;\\n                    h = h -> next;\\n                }\\n            }\\n            start = start -> next;\\n        }\\n\\n        if(!f) {\\n            if(h == NULL) {\\n                ans = start;\\n            }\\n            else{\\n                h -> next = start;\\n            }\\n        }\\n\\n        h = ans;\\n\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884851,
                "title": "c-o-n-3ms-100-beats-easy-solution-with-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteDuplicates(struct ListNode* head){\\n        struct ListNode *dummy = malloc(sizeof(struct ListNode));\\n        dummy->next = head;\\n        dummy->val = 0;\\n        struct ListNode *prev = dummy , *curr = head;\\n\\n        while(curr)\\n        {\\n            struct ListNode *next_node = curr->next;\\n            while(next_node && curr->val == next_node->val)\\n            {\\n                struct ListNode *temp = next_node->next;\\n                // delete next_node;\\n                next_node = temp;\\n            }\\n\\n            if(curr->next != next_node)\\n            {\\n                prev->next = next_node;\\n                // delete curr;\\n            }\\n            else\\n            {\\n                prev = curr;\\n\\n            }\\n            curr = next_node;\\n        }\\n        return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775202,
                "title": "easy-java-solution-beats-100-in-place-solution-clean-code-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/a3de047b-a131-4982-a2f2-0013d429d217_1689535320.8316107.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n\\n        ListNode traverse = head;\\n        ListNode temp = new ListNode();\\n        ListNode ans = temp;\\n        int flag = 0;\\n\\n        while(traverse.next != null) {\\n            if(traverse.next.val != traverse.val) {\\n                if(flag == 1) {\\n                    traverse = traverse.next;\\n                }\\n                else {\\n                temp.next = traverse;\\n                temp = temp.next;\\n                traverse = traverse.next;\\n                }\\n                flag = 0;\\n            }\\n            else if(traverse.next.val == traverse.val) {\\n                flag = 1;\\n                traverse = traverse.next;\\n            }\\n        } \\n        if(flag == 1) {\\n            temp.next = null;\\n        }\\n        else {\\n        temp.next = traverse;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732971,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere i have used concept of hash map and basic concept of linkedlist\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n   if(head==null||head.next==null){ return head;}\\n   HashMap<Integer,Integer> map=new HashMap<>();\\n   ListNode node=new ListNode(-1);\\n   ListNode prev=node;\\n   ListNode curr=head;\\n   while(curr!=null){\\n       if(map.containsKey(curr.val)){\\n           map.put(curr.val,map.get(curr.val)+1);\\n       }else{\\n           map.put(curr.val,0);\\n       }\\n       curr=curr.next;\\n   }\\ncurr=head;\\nwhile(curr!=null){\\n    if(map.get(curr.val)==0){\\n        prev.next=curr;\\n        prev=curr;\\n    }\\ncurr=curr.next;}\\nif(prev.next!=null){\\n    prev.next=null;\\n\\n    }\\n    return node.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714833,
                "title": "easy-constant-space-solution-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn Linked List write the basic Solution and then try to go for the edge cases , this was one of them , you have to handle the edge cases here.\\n1) what if duplicates were in head ,you gotta handle that\\n2) what if duplicates were the last values you gotta handle that\\n\\n\\nALWAYS TRY DRAWING DIAGRAM FIRST AND SIMLUATE IT \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode temp = head,prev = null;\\n\\n        while(temp != null){\\n            ListNode k = temp.next;\\n            \\n            if(temp.next != null && temp.val == temp.next.val){\\n                while(k != null && temp.val == k.val) {\\n                    k = k.next;\\n                }\\n                if( prev == null && k == null) {\\n                    head = null;\\n                    break;\\n                }\\n                else if(prev == null){\\n                    head = k;\\n                    temp = head;\\n                    prev = null;\\n                }\\n                else if( k == null){\\n                    prev.next = null;\\n                    break;\\n                } else {\\n                    prev.next = k;\\n                    temp = prev;\\n                }\\n                continue;\\n            }\\n\\n            prev = temp;\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633297,
                "title": "easy-solution-in-java",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```\\n---\\n##### *Please upvote if you\\'ve liked my solution : ))*",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        if(head == null || head.next == null)    return head;\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        while(curr!=null && curr.next!=null)\\n        {\\n            boolean flag = false;\\n            if(curr.val != curr.next.val)\\n            {\\n                prev.next = curr;\\n                prev = prev.next;\\n                curr = curr.next;\\n            }\\n            else\\n            {\\n                int data = curr.val;\\n                while(curr.next!=null && curr.val == curr.next.val)\\n                {\\n                    curr.next = curr.next.next;\\n                }\\n                prev.next = curr.next;\\n                curr = curr.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533733,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic ListNode DeleteDuplicates(ListNode head) {\\n        var dummyHead = new ListNode(0, head);\\n        var prev = dummyHead;\\n        \\n        while (prev != null)\\n        {\\n            // Found value that has duplicates\\n            if (prev.next != null && prev.next.next != null && prev.next.val == prev.next.next.val)\\n            {\\n                var duplicateValue = prev.next.val;\\n                while (prev.next != null && prev.next.val == duplicateValue) prev.next = prev.next.next;\\n            }\\n            else prev = prev.next;\\n        }\\n\\n        return dummyHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509136,
                "title": "great-explanation-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n\\n   /*\\n   # concept: \\n     @ to delete all duplicate number, we must need to know dup node\\'s previous node to connect with \\n         the next unique node\\n\\n         1)if head node contains dup, then need to make the next unique node to prev.\\n           1->1->2\\n          here, cur node will be 2nd 1, so we will make cur = cur->next and  head = cur;\\n\\n          1)if other node contains dup, then need to make the next unique node to prev.\\n           0->2->2->3\\n          here, cur node will be 2nd 2, so we will make  prev->next = cur->next  and  cur = cur->next;\\n\\n    @ if node don\\'t contains dup, then need to make the node to prev..\\n      prev = curr;\\n     curr = curr->next\\n\\n   */\\n    \\n    ListNode* curr = head;\\n    ListNode* prev = NULL;\\n    //this condition satisfy the condition if(head==NUll or head->next==NULL) return head\\n    //so we don\\'t mention this condition first\\n    while(curr != NULL && curr->next != NULL) {\\n        if(curr->val == curr->next->val) {\\n            //tricky part, as we are comparing two nodes, it must need to check that 2 nodes are avaible \\n            //to check that curr->next != NULL \\n            while(curr->next != NULL && curr->val == curr->next->val) {\\n                curr = curr->next;\\n            }\\n            if(prev != NULL) { //if head not don\\'t contain duplicate\\n                prev->next = curr->next;\\n                curr = curr->next;    \\n            }else { // if head node contain deplicate & no need to change prev\\n                curr = curr->next;  \\n                head = curr;\\n                 \\n            }\\n        }else { //if  all node are unique\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n    }\\n    return head;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462736,
                "title": "simple-c-solution-using-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode *t1=head,*t2;\\n        if(t1==NULL || t1->next==NULL)\\n        {\\n            return head;\\n        }\\n        while(t1!=NULL)\\n        {\\n            if(t1!=NULL && t1->next!=NULL && t1->val==t1->next->val)\\n           {\\n            int x1=t1->val;\\n            while(head!=NULL && head->val==x1)\\n            {\\n                head=head->next;\\n            }\\n            t1=head;\\n          }\\n            else if(t1->next!=NULL && t1->next->next!=NULL &&      t1->next->next->val==t1->next->val)\\n            {\\n                t2=t1->next;\\n                int x=t1->next->val;\\n                while(t2!=NULL && t2->val==x)\\n                {\\n                    t2=t2->next;\\n                }\\n                t1->next=t2;\\n            }\\n            else\\n            {\\n                t1=t1->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457663,
                "title": "82-remove-duplicates-from-sorted-list-ii-java",
                "content": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteDuplicates(ListNode head) {\\n        ListNode help=new ListNode(); \\n        ListNode prev=help;\\n        help.next=head;\\n        while(head!=null)\\n        {\\n            if(head.next!=null&&head.val==head.next.val)\\n            {\\n                while(head.next!=null&&head.val==head.next.val)\\n                head=head.next;\\n                prev.next=head.next;\\n            }\\n            else\\n            prev=prev.next;\\n            head=head.next;\\n        }\\n        return help.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444232,
                "title": "easy-c-code-using-maps",
                "content": "\\n# Approach\\nFirstly use a map to calculate frequencies of each element.\\nCreate a new linked list and insert elements into linked list if the element frequency is equal to 1.\\nWe will obtain a new linked list with no duplicate elements in it. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        map<int,int>mp;\\n        ListNode *p=head;\\n        while(p){\\n            mp[p->val]++;\\n            p=p->next;\\n        }\\n        ListNode *ans=new ListNode();\\n        ListNode *ans1=ans;\\n        for(auto it:mp){\\n            if(it.second==1){\\n                ans1->next=new ListNode(it.first);\\n                ans1=ans1->next;\\n            }\\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1800490,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1566621,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1865337,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1997794,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1567737,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1946391,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1935798,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1848436,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1811576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            },
            {
                "id": 1793403,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Am I the only one who stared at this for 5 minutes not understanding the difference between delete dupes 2 and delete dupes 1?"
                    },
                    {
                        "username": "satyasanjay1999",
                        "content": "yes I also thought it is the same question.."
                    },
                    {
                        "username": "rakshit492",
                        "content": "I know the difference. In this question, you also have to delete the original node along with the duplicate. For example (1,2,2,3) -> (1,3)."
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "[@CrypticParadigm](/CrypticParadigm) nvm\\n"
                    },
                    {
                        "username": "CrypticParadigm",
                        "content": "Did you ever figure out the difference? Not sure I know either."
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "https://youtu.be/j7W70djR5ow (clickable)"
                    },
                    {
                        "username": "navinbisht1992",
                        "content": "In javascript  list is\\n `list = {\\n        val: 0,\\n        next: null,\\n    };`\\n\\nand when this is returned it\\'s `[0]` and not `[]`. \\n\\nSo many issues in leetcode"
                    },
                    {
                        "username": "sdavide1010",
                        "content": "I\\'m stressed with the stupid interpretation of leetcode, how is it supposed to be for this empty? always throws [0]"
                    },
                    {
                        "username": "tanula",
                        "content": "description is poorly written. It should have said \"find the duplicates and remove them all from the original list\". "
                    },
                    {
                        "username": "mochiball",
                        "content": "Question states \"leaving only distinct elements\" so its pretty clear. The picture also tells you its only elements with non-duplicates will remain "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Head + Predecessor\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "gourav0_0",
                        "content": "What should be time and space complexity for this problem\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi [@GOURAV](/gourav0_0), Time and space complexities for this problem, or any problem will vary according to the coder. For this problem it could be two ways 1. Time : O(N), Space : O(N) Because of map used or  2. Time : O(N), Space : O(1) if used pointers to solve it. You can check code for both these cases here : https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solutions/3665494/best-c-2-approaches-space-o-1-o-n/"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head.next==null || head==null){\n            return head;\n        }\n        HashMap<Integer,Integer>map=new HashMap<>();\n        ListNode dummy=new ListNode(0);\n        \n        ListNode prev=dummy;\n        ListNode curr=head;\n        while(curr!=null){\n            if(map.containsKey(curr.val)){map.put(curr.val,map.get(curr.val)+1);}\n            else{map.put(curr.val,1);}\n            curr=curr.next;\n        }\n        \n        curr=head;\n        while(curr!=null){\n            if(map.get(curr.val)==1){\n               prev.next=curr;\n               prev=curr;}\n            curr=curr.next;}\n        return dummy.next;\n    }\n}\nThis code is giving wrong answer for testcase [1,2,2]  it is giving [1,2,2]  instead of [1] can anyone pls tell\nwhat's the error??"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "[@bhavya21245](/bhavya21245) Oh, That\\'s really great \\uD83D\\uDD25"
                    },
                    {
                        "username": "bhavya21245",
                        "content": "Thanks for your help\\uD83D\\uDE4FI did dry run and even posted the solution \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "Hi Bhavya,  you are getting the same list back as answer, becoz u just moved curr pointer when curr.val was not 1, but the links were not broken from each other (i.e prev from curr\\'s node) , so prev pointer remains connected to the 2 node, that\\'s why it remains the same.  Hope this helps, Also try doing a dry run yourself !"
                    },
                    {
                        "username": "neerajydv23",
                        "content": "In the code, we are returning new head of linked list as \"dummy.next\" but in starting dummy is pointing towards head so as we move forward the head is changing or it might be getting removed if it is a duplicate then how is dummy.next returning the head of output linked list ?"
                    },
                    {
                        "username": "kshitij_2025",
                        "content": "`plzz help -  for input [1,1] it\\'s showing runtime error`\\n\\n `class Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* dummyhead= new ListNode(0,head);\\n        ListNode* prev =dummyhead;\\n            if(head == NULL){\\n                return head; \\n            }\\n        while(curr != NULL && curr->next !=NULL){\\n            if(curr->val == curr->next->val ){\\n                while(curr->val == curr->next->val){\\n                    curr=curr->next;\\n                }prev->next=curr->next;\\n                if(curr->next != NULL){\\n                    curr=curr->next;}\\n            }else{\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n\\n        }return dummyhead->next;\\n}\\n};`"
                    },
                    {
                        "username": "alexrlh2",
                        "content": "I have an O(n) solution but it does not use the fact that the list is sorted. Can this fact be used to optimise in any way? If not, why is the list sorted in the challenge?"
                    },
                    {
                        "username": "ShamrockLee",
                        "content": "Sorting guarantees that all the duplicates are adjacent, which makes it possible to achieve both O(n) time complexity and O(1) (extra) space complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Duplicate Emails",
        "question_content": "<p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
        "solutions": [
            {
                "id": 53528,
                "title": "i-have-this-simple-approach-anybody-has-some-other-way",
                "content": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "solutionTags": [],
                "code": "select Email \\nfrom Person \\ngroup by Email \\nhaving count(*) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2385937,
                "title": "3-different-solutions-easy-to-understand",
                "content": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Please upvote, if you like my solution\\n# 1\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n\\n# 2.\\nSELECT DISTINCT(p1.email) from Person p1, Person p2\\nwhere p1.id <> p2.id AND p1.email = p2.email;\\n\\n#3. \\nSELECT DISTINCT(p1.email) from \\nPerson p1 JOIN Person p2 ON\\np1.email = p2.email AND p1.id <> p2.id;\\n# feel free to ask anything, if have any doubts\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3827277,
                "title": "100-easy-fast-clean-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/50510b0c-779b-4cac-99da-f40f9ee9f70e_1690526377.4372673.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT P1.Email FROM Person P1,Person P2 \\n\\nWHERE P1.id <> P2.id AND P1.Email=P2.Email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53553,
                "title": "my-simple-accepted-solution",
                "content": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "solutionTags": [],
                "code": "    select Email\\n    from Person\\n    group by Email\\n    having count(*)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 53531,
                "title": "a-solution-using-a-group-by-and-another-one-using-a-self-join",
                "content": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "914 ms\\n\\n    SELECT Email from Person\\n    Group By Email\\n    Having Count(*) > 1;\\n\\n933 ms\\n\\n    SELECT distinct p1.Email from Person p1\\n    INNER JOIN Person p2\\n    ON p1.Email = p2.Email\\n    WHERE p1.Id <> p2.Id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1538675,
                "title": "simple-accepted-solution",
                "content": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\n\\n**Like it ? lease upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email as Email\\nFROM Person \\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53557,
                "title": "share-my-solution",
                "content": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "solutionTags": [],
                "code": "    Select Email\\n    From Person\\n    GROUP BY Email\\n    Having count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53548,
                "title": "simple-solution-use-group-by",
                "content": "    select Email from Person group by Email having count(Email) > 1;",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 3214788,
                "title": "182-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTo solve this problem, we need to group the records by email and select only those that have more than one occurrence. We can use the GROUP BY clause and HAVING clause to do this. Here\\'s the SQL query:\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```\\nThis will select all the duplicate emails from the Person table. The GROUP BY clause groups the records by email, and the HAVING clause selects only those groups that have more than one record, which means that the email is duplicated.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027577,
                "title": "mysql-one-line-soln",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849247,
                "title": "easiest-solution-mysql-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct x.email from Person x,Person y where x.email=y.email and x.id>y.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478870,
                "title": "mysql-3-solutions-faster-than-99-71-having-join",
                "content": "\\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\nPlease upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\nAny suggestions and improvements are always welcome.\\nSolution 1: Join, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 396 ms, faster than 61.66% of MySQL.\\n```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\\nSolution 2: Where clause, long, not good \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n\\u2705 Runtime: 588 ms, faster than 32.98% of MySQL.\\n\\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\\nSolution 3: Group by and having clause \\uD83C\\uDFAF\\n\\u2705 Runtime: 274 ms, faster than 99.71% of MySQL.\\n\\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```\\nIf you like the solutions, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.email Email\\nfrom Person as a \\njoin Person as b \\non a.email = b.email and a.id != b.id\\n```\n```\\nselect distinct a.email Email \\nfrom Person a, Person b\\nwhere a.email = b.email \\nand a.id <> b.id\\n```\n```\\nselect email Email\\nfrom Person \\ngroup by email \\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942961,
                "title": "easy-beginner-solution-using-loc-and-duplicated",
                "content": "# Intuition\\nWe want select all values that are duplicated in our email column and return those as a dataframe, ensuring that we only report each email value once. \\n\\n# Approach\\nThis is a straightforward problem using .loc(), .duplicated(), and .drop_cuplicates().\\n\\n1. We create a new dataFrame called results\\n2. We use .loc to find all elements of the person dataframe whos emails are duplicated using the .duplicated() method. This will populate our results dataframe with each duplicated email. \\n3. We then use drop_duplicates to remove any duplicated values from our results dataFrame since some entries may be duplicated more than once. \\n\\nPlease upvote and happy coding :) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n    results = pd.DataFrame()\\n\\n    results = person.loc[person.duplicated(subset=[\\'email\\']), [\\'email\\']]\\n    \\n    return results.drop_duplicates()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 53546,
                "title": "simple-solution-not-bad",
                "content": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct(p.Email) \\n    from Person p, Person p1\\n    where (p.Id <> p1.Id and p.Email = p1.Email);",
                "codeTag": "Unknown"
            },
            {
                "id": 2996406,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967813,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```\\nThe **HAVING** clause was added to SQL because the **WHERE** keyword cannot be used with aggregate functions.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2582141,
                "title": "very-easy-mysql-solution-20",
                "content": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email from person group by email having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885738,
                "title": "simple-and-elegant-multiple-solutions",
                "content": "**JOIN (Slow)**:\\n```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\\n\\n**Sub-query**:\\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\\n\\n**HAVING**:\\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT P1.Email\\nFROM Person P1\\nJOIN Person P2 ON P1.Email = P2.Email\\nWHERE P1.Id <> P2.Id\\n```\n```\\nSELECT EMAIL FROM\\n    (SELECT Email, COUNT(Email) AS EmailCount\\n     FROM Person GROUP BY Email) Q\\nWHERE EmailCount >= 2\\n```\n```\\nSELECT Email FROM Person\\nGROUP BY Email\\nHAVING COUNT(Email) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802338,
                "title": "sql-easy-peasy",
                "content": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING count(*)>=2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274978,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271110,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2533631,
                "title": "oracle-plsql-3-different-solution",
                "content": "**Using Subquery**\\n```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\\n**Using Having Keyword**\\n*Note - Just as the **WHERE** clause can be used to select and reject the individual rows that participate in a query, the **HAVING** clause can be used to select and reject row groups.*\\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\\n**Using Self Join**\\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT EMAIL FROM \\n(SELECT EMAIL,COUNT(EMAIL) AS C FROM PERSON GROUP BY EMAIL ) TEMP \\nWHERE TEMP.C>1;\\n```\n```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```\n```\\nSELECT DISTINCT P1.EMAIL FROM PERSON P1 JOIN PERSON P2 ON P1.EMAIL = P2.EMAIL AND P1.ID <> P2.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451415,
                "title": "having-and-count-simple",
                "content": "`select email from Person group By email having count(email)>1 `",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "`select email from Person group By email having count(email)>1 `",
                "codeTag": "Unknown"
            },
            {
                "id": 2421000,
                "title": "mysql-2-different-approach-one-line-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```\n```\\nSELECT Email FROM Person GROUP BY Email HAVING  COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803853,
                "title": "best-easiest-mysql-2-approaches-182-duplicate-emails",
                "content": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#below are 2 mysql solutions for this question\\n\\n#First solution\\nselect email from Person \\ngroup by email\\nhaving count(email)>1;\\n\\n\\n#second solution\\nselect email from\\n(select email, count(email) as c from Person group by email) as temp\\nwhere c>1\\n\\n\\n#pls upvote if you find solution easy ...Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765981,
                "title": "mysql-forever-group-by",
                "content": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Email FROM Person group by Email having count(Email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1757753,
                "title": "simple-2-lines-with-explanation-you-ll-love-it-guaranteed",
                "content": "If you\\'ve Learned something new please give it upvote;\\notherwise thank you for having a look \\uD83D\\uDE4F\\uD83C\\uDFFB\\n\\nHere my appraoch is using SELF JOINS. if you don\\'t have an idea what it is you can check out my answer https://leetcode.com/problems/employees-earning-more-than-their-managers/discuss/1757621/Simple-3-Lines-with-explanation.-(-You\\'ll-love-it-guaranteed.)\\nYou\\'ll get the basic idea what is SELF JOIN.\\n\\nchecking whether the same table has same emails with different ids.\\nif there are, then using DISTINCT keyword to only show unique emails to show on screen. \\n(we don\\'t want to show all them if there are thousand duplicate emails. we want only one)\\n\\n```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.email AS Email FROM Person p1\\nJOIN Person p2 ON p1.id != p2.id AND p1.email = p2.email\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527877,
                "title": "easy-self-join-only",
                "content": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "solutionTags": [],
                "code": "```\\nselect distinct a.Email from Person as a, Person as b where a.Email=b.Email and a.Id<>b.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53550,
                "title": "standard-solution-with-distinct",
                "content": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "solutionTags": [],
                "code": "    SELECT DISTINCT Person.Email \\n    FROM Person \\n    GROUP BY Person.Email\\n    HAVING COUNT(Person.Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53551,
                "title": "a-simple-straightforward-solution",
                "content": "    select Email from Person group by Email having count(Id) > 1",
                "solutionTags": [],
                "code": "    select Email from Person group by Email having count(Id) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 53560,
                "title": "my-first-accepted-sql-solution-using-group-by-in-845-ms-thank-god",
                "content": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    # Write your MySQL query statement below\\n    select email \\n    from( \\n         select \\n               email, \\n               count(*) as c\\n         from Person\\n         group by email\\n    ) a\\n    where a.c > 1;\\nWe should review and think over other guys' solution frequently, especially for beginners. I think it's significantly helpful~~",
                "codeTag": "Unknown"
            },
            {
                "id": 3939489,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3525493,
                "title": "mysql-solution-for-duplicate-emails-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to identify email addresses that are duplicated in the Person table and retrieve those addresses along with their counts.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query uses the group by clause to group the records in the Person table based on the Email column.\\n2. The having clause is used to filter the groups and include only those groups where the count of email addresses (count(Email)) is greater than 1.\\n3. The select statement select Email retrieves the email addresses from the qualifying groups.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the SQL query depends on the size of the Person table and the efficiency of the database engine\\'s query optimization and execution. Assuming proper indexing and optimization, the time complexity can vary but is typically in the order of O(n log n) or O(n), where n is the number of rows in the Person table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SQL query is determined by the memory required to store the result set, which in this case is the email addresses that appear more than once. The space complexity is proportional to the number of rows returned by the query.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect Email from Person group by Email having count(Email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3458408,
                "title": "3-line-code-beats-80",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3329405,
                "title": "very-simple-solution-using-having-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  email from person\\ngroup by email \\nhaving count(*) >1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218260,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2877331,
                "title": "mysql-simple-having-clause",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```\\n\\n### HAVING count(email) > 1 \\nMainly use the last line to filter out those records which appear more than one in the database.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING count(email) > 1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652011,
                "title": "mysql-solution-memory-usage-0b",
                "content": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM Person GROUP BY EMAIL HAVING COUNT(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406578,
                "title": "mysql-using-count",
                "content": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT Email FROM Person \\nGROUP by Email HAVING count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2291486,
                "title": "mysql-simple-mysql-solution-using-count-having-clause",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 322 ms, faster than 84.35% of MySQL online submissions for Duplicate Emails.\\n# Memory Usage: 0B, less than 100.00% of MySQL online submissions for Duplicate Emails.\\n\\n\\tSELECT EMAIL FROM PERSON\\n\\tGROUP BY EMAIL\\n\\tHAVING COUNT(EMAIL) > 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2226726,
                "title": "a-trick-to-solve-duplicate-values-in-sql-using-aggregate-function-and-group-by-mysql-solution",
                "content": "We have to display the duplicate values of email which means display all the mail whose occurence is greater than 1.\\n\\nNow for occurence  we use an aggregate function called as : **count()**\\n\\nA trick to solve Duplicate values in SQL:\\n\\n1.) Using the GROUP BY clause to group all rows by the target column(s) \\u2013 i.e. the column(s) you want to check for duplicate values on.<br>\\n2.) Using the COUNT function in the HAVING clause to check if any of the groups have more than 1 entry; those would be the duplicate values.<br>\\n\\n**MySQL Solution :**\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030358,
                "title": "simple-solution",
                "content": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "solutionTags": [],
                "code": "SELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT (email) >= 2;\\n#please upvote :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1728735,
                "title": "sql-easy-4-line-group-by-duplicate-emails",
                "content": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```\\nPlease **UpVote**, if you understood the problem.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email \\nFROM person\\nGROUP BY email \\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581930,
                "title": "simple-mysql",
                "content": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "solutionTags": [],
                "code": "select email from person\\ngroup by email\\nhaving count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1562445,
                "title": "simple-mysql-solution-faster-than-85",
                "content": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\nGuess it\\'s pretty straight forward w/o needing explanation. Keep your good work up.",
                "solutionTags": [],
                "code": "```sql\\nSELECT \\n    email\\nFROM\\n    Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178366,
                "title": "simple-solution-easy-understand",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email\\nHAVING COUNT(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 1134229,
                "title": "mysql-2-solutions-easy-to-understand",
                "content": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "solutionTags": [],
                "code": "```\\n#Using Sub Query\\nselect email from Person group by Email having count(Email)>=2;\\n\\n#Using Self Join\\nselect distinct P1.Email from Person as P1, Person as P2 where P1.Email=P2.Email and P1.Id<>P2.Id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876543,
                "title": "by-group-by-and-having-clause",
                "content": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM Person\\nGROUP BY Email \\nHAVING count(Email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 170685,
                "title": "group-by-having-most-efficient-solution",
                "content": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email \\nFROM   person \\nGROUP  BY email \\nHAVING Count(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53555,
                "title": "my-solution",
                "content": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "solutionTags": [],
                "code": "    SELECT Email FROM Person\\n    GROUP BY Email\\n    HAVING COUNT(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 4055225,
                "title": "pandas-easy-duplicate-emails",
                "content": "First Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051666715/)\\n\\n```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\\n\\t\\nSecond Approach:\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051679673/)\\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\\n\\nThird Appraoch\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1051685938/)\\n\\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\\n\\n**SQL**\\n[See the Accepted and Successful Submission Detail](https://leetcode.com/submissions/detail/1061389573/)\\n\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\\n\\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/de333cff-f88a-4d35-a3a5-e0b8d0cc2c19_1695221934.7114468.jpeg)\\n",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # Let\\'s first, self-join to find distinct duplicated emails\\n    merged_emails_inner = person.merge(person, on=\\'email\\', how=\\'inner\\')\\n\\n    # In the next step, rows where the IDs are not equal are filtered out\\n    filtered_equal_id = merged_emails_inner[merged_emails_inner[\\'id_x\\'] != merged_emails_inner[\\'id_y\\']]\\n\\n    # Then select distinct email addresses\\n    unique_id = filtered_equal_id[\\'email\\'].unique()\\n\\n    # Finally, we can create a new DataFrame with the distinct email addresses\\n    result_df = pd.DataFrame({\\'email\\': unique_id})\\n\\n    return result_df\\n```\n```\\n\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# 1) First, we group by \\'email\\' and filtering using the `HAVING` clause\\n\\t\\tgrouped_emails = person.groupby(\\'email\\')\\n\\n\\t\\t# 2) Then, we can filter the groups based on the condition that the count of each group (i.e., the number of occurrences of each unique email) should be greater than 1.\\n\\t\\tfiltered_emails = grouped_emails.filter(lambda group: len(group) > 1)\\n\\n\\t\\t# 3) in the next step, the unique email addresses from the filtered Series are extracted\\n\\t\\tunique_emails = filtered_emails[\\'email\\'].unique()\\n\\n\\t\\t# 4) Then, we create a DataFrame with the unique email addresses\\n\\t\\tresult_df = pd.DataFrame({\\'email\\': unique_emails})\\n\\n\\t\\treturn result_df\\n```\n```\\n\\tdef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n\\n\\t\\t# First, we group by \\'email\\' and counting occurrences\\n\\t\\temail_counts = person.groupby(\\'email\\').size()\\n\\n\\t\\t# Next, only emails with counts greater than 1 are filtered\\n\\t\\tresult_df = pd.DataFrame({\\'Email\\': email_counts[email_counts > 1].index})\\n\\n\\t\\treturn result_df\\n```\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```\n```\\n-- Select the \\'email\\' column from the \\'Person\\' table\\n-- This query is focused on retrieving email addresses.\\n\\nSELECT email\\n\\n-- Specify the source table for the query as \\'Person\\'\\n-- The data is being retrieved from the \\'Person\\' table.\\n\\nFROM Person\\n\\n-- Use the GROUP BY clause to group the data based on the \\'email\\' column\\n-- This groups rows with the same email address together.\\n\\nGROUP BY email\\n\\n-- The HAVING clause filters the grouped results.\\n-- It selects groups (email addresses) where the count of occurrences is greater than 1.\\n-- This identifies email addresses that appear more than once in the \\'Person\\' table.\\n\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3934435,
                "title": "very-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM PERSON GROUP BY EMAIL HAVING COUNT(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813525,
                "title": "an-easy-to-understand-solution-in-oracle",
                "content": "# Code\\n```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT p2.email FROM Person p2 GROUP BY p2.email having count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539763,
                "title": "fully-simple-for-beginners",
                "content": "\\n\\n# Code\\n```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\nemail as Email \\nFROM PERSON \\nGROUP BY email HAVING count(email) > 1;  \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506209,
                "title": "using-group-by-having-and-count-to-identify-duplicate-values",
                "content": "# Intuition\\nMy first thought was to find all values that are not unique, but I wasn\\'t able to have that work. So then I looked into the GROUP BY and HAVING clause. \\n\\n# Approach\\nUsing the GROUP BY clause, I grouped all the email values and used the HAVING clause to identify emails that had a count greater than 1. This would mean there were duplicate values. \\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING(COUNT(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501208,
                "title": "simplest-solution",
                "content": "# Intuition\\nThere is a fairly straightforward solution to this problem. To group the results by Email, we simply select the Email column from the Person table. Using the HAVING clause, we filter the groups to include only those with a count greater than one (i.e., those that appear more than once). Consequently, the Person table contains a list of emails that appear more than once.\\n\\nBecause this solution relies on SQL\\'s built-in GROUP BY and HAVING functions, which are optimized for this type of operation, it is efficient. It is not necessary to write any custom functions or loops to iterate over the table data.\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT email as Email\\nFROM Person\\nGROUP BY email\\nHAVING count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478941,
                "title": "nested-queries",
                "content": "\\n# Code\\n```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM (SELECT COUNT(email) AS EmailCount, email FROM Person \\nGROUP BY email) AS Temp WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466076,
                "title": "3-best-approach-to-solve-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n1. select email from person group by email having count(email)>1 ;\\n\\n2. select distinct p1.email from person p1 ,person p2 where p1.id != p2.id and p1.email=p2.email;\\n\\n3. select distinct p1.email from person as p1 join person as p2 on p1.id != p2.id and p1.email=p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409375,
                "title": "super-easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306922,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294457,
                "title": "mysql-easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264077,
                "title": "group-by-and-having",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3121252,
                "title": "simple-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email as Email from Person group by email having count(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100725,
                "title": "simple-query-duplicate-emails",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100505,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2917417,
                "title": "duplicate-emails-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING Count(Email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699614,
                "title": "mysql-group-by-count",
                "content": "# Write your MySQL query statement below\\n```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT email AS Email  FROM Person\\nWHERE email IN\\n(SELECT CASE WHEN COUNT(id)>1 THEN email\\nEND\\nFROM Person\\nGROUP BY email);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2646313,
                "title": "simple-and-easy-explained",
                "content": "Use**GROUP BY**clause to group all the rows by selecting the particular column (*email*);\\nnext use **COUNT()** in the **HAVING** clause to check if any *email* is repeated more than once.\\n\\n```\\nselect email as Email from Person group by email having count(email) > 1;\\n```\\n\\neasy, no? cheers",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580520,
                "title": "using-distinct",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT DISTINCT p1.email\\nFROM Person p1 INNER JOIN person p2 ON p1.email = p2.email AND p1.id <> p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539583,
                "title": "mysql-easy-solution",
                "content": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from \\n    person \\n    group by email\\n    having count(id)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2412013,
                "title": "mysql-easy",
                "content": "\\tselect email from Person group by email having count(*)>1",
                "solutionTags": [],
                "code": "\\tselect email from Person group by email having count(*)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2115544,
                "title": "one-line-solution-easy",
                "content": "**Duplicate Emails Solution :**\\n--------------------------------\\n**In MySQL**\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\\n\\n**In Oracle**\\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```\\n\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY 1 \\n            HAVING COUNT(1) > 1\\n```\n```\\n# Write your MySQL query statement below\\nSELECT email AS Email \\n    FROM Person \\n        GROUP BY email \\n            HAVING COUNT(email) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2021517,
                "title": "easy-to-understand-solution",
                "content": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```\\n\\n**Please Upvote to keep me motivated  :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(u1.email) as Email\\nfrom Person u1,Person u2\\nwhere u1.email=u2.email and u1.id!=u2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786364,
                "title": "faster-than-94-47-of-the-submissions",
                "content": "\\n```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744478,
                "title": "simple-solution-for-182-duplicate-emails-using-having-and-group-by",
                "content": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as Email \\nfrom person\\ngroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1597376,
                "title": "mysql-with-explaination",
                "content": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```\\n\\nHere we have use group by clause which will group all the repeating and non-repeating emails disticnctly and then applying having clause in combination with aggregate function count.",
                "solutionTags": [],
                "code": "```\\nselect email from person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513698,
                "title": "ms-sql",
                "content": "#### Question\\n```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```\\n\\n#### Answer\\n```SQL\\n/* Write your T-SQL query statement below */\\nselect email from person\\ngroup by email\\nhaving count(*) > 1",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n182. Duplicate Emails\\n\\nSQL Schema\\nTable: Person\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Email       | varchar |\\n+-------------+---------+\\nId is the primary key column for this table.\\nEach row of this table contains an email. The emails will not contain uppercase letters.\\n \\n\\nWrite an SQL query to report all the duplicate emails.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nPerson table:\\n+----+---------+\\n| Id | Email   |\\n+----+---------+\\n| 1  | a@b.com |\\n| 2  | c@d.com |\\n| 3  | a@b.com |\\n+----+---------+\\nOutput: \\n+---------+\\n| Email   |\\n+---------+\\n| a@b.com |\\n+---------+\\nExplanation: a@b.com is repeated two times.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1510657,
                "title": "duplicate-emails-mssql-server",
                "content": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "solutionTags": [],
                "code": "select \\nEmail\\nfrom Person\\ngroup by Email\\nhaving count(Email) > 1\\norder by Email asc",
                "codeTag": "Unknown"
            },
            {
                "id": 1437686,
                "title": "very-simple-mysql",
                "content": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT EMAIL FROM PERSON GROUP BY EMAIL HAVING COUNT(EMAIL) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342332,
                "title": "simple-solution-with-group-by-and-having",
                "content": "select email from person \\ngroup by email having count(email) > 1;",
                "solutionTags": [],
                "code": "select email from person \\ngroup by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1175726,
                "title": "simple-sql-query",
                "content": "Here,\\nCheck if Ids are not equal and if email ids are equal, so the are duplicates !\\n\\n```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT p1.Email\\nfrom Person p1,Person p2\\nwhere p1.Id <> p2.Id \\nand p1.Email = p2.Email\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083314,
                "title": "using-having-clause",
                "content": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Email from Person\\nGroup by Email\\nHaving count(*) > 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069005,
                "title": "i-believe-simple-and-human-readable-answer-is-the-best",
                "content": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "solutionTags": [],
                "code": "SELECT Email\\nFROM PERSON\\nGROUP BY EMAIL\\nHAVING COUNT(EMAIL) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 912151,
                "title": "mysql-use-group-by-and-count",
                "content": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email from Person GROUP by email HAVING COUNT(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745392,
                "title": "mysql-using-group-by",
                "content": "If you found the solution helpful, kindly upvote :)\\n\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM person group by email having count(email)>1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621389,
                "title": "simplest-question-on-leetcode",
                "content": "select email from person group by email having(count(id)>1)",
                "solutionTags": [],
                "code": "select email from person group by email having(count(id)>1)",
                "codeTag": "Unknown"
            },
            {
                "id": 488546,
                "title": "faster-than-99-36-of-ms-sql-server",
                "content": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "solutionTags": [],
                "code": "SELECT Email FROM Person\\nGROUP BY Email\\nHaving count(Email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 53538,
                "title": "i-am-a-newbie-on-sql-share-my-solution-no-having-no-join",
                "content": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT CountTable.Email FROM (\\nSELECT Person.Email,COUNT(Person.Email) AS CountNum\\n\\tFROM Person\\n\\tGROUP BY Person.Email\\n) AS CountTable WHERE CountTable.CountNum>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53556,
                "title": "min-and-max-a-different-way-to-find-duplicate",
                "content": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "solutionTags": [],
                "code": "Just for sharing. It can also find the `duplicate` emails.\\n\\n    SELECT email \\n    FROM (  SELECT email, MIN(id) minid, MAX(id) maxid\\n            FROM Person \\n            GROUP by email ) minmax\\n    WHERE minid <> maxid\\nIf change the where condition, we can get the `unique` ones.\\n\\n    WHERE minid = maxid",
                "codeTag": "Unknown"
            },
            {
                "id": 4043257,
                "title": "extracting-duplicate-rows-from-a-dataframe-object-and-returning-these-rows-in-a-new-dataframe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires extracting rows from the person DataFrame that have duplicate email addresses and returning these rows in a new DataFrame. The intuition is to use the .duplicated() method to identify rows with duplicate email addresses and then create a new DataFrame containing these rows.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use the .duplicated() method with keep=\\'first\\' to identify rows with duplicate email addresses while keeping the first occurrence.\\n- Create a new DataFrame, duplicate_df, by filtering the rows from the person DataFrame using the boolean result from the .duplicated() operation.\\nRename the \\'email\\' column in the duplicate_df DataFrame to \\'Email\\'.\\n- Use .drop_duplicates(subset=[\\'Email\\']) to remove duplicate rows based on the \\'Email\\' column and keep only one instance of each duplicate email address.\\n- Return the resulting output_df DataFrame containing one instance of each duplicate email address.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of rows in the person DataFrame. The time complexity is dominated by the operations to identify duplicates and filter the DataFrame, which is proportional to the number of rows in the person DataFrame.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n\\n- Space complexity: O(k), where k is the number of unique duplicate email addresses in the person DataFrame. The space complexity is determined by the space required to store the duplicate_df and output_df DataFrames. Both DataFrames will have the same number of rows as the number of duplicate email addresses. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef duplicate_emails(person: pd.DataFrame) -> pd.DataFrame:\\n    \\'\\'\\'\\n    @param: DataFrame object named person \\n    @return: DataFrame object with 1 column label Email and each row is a repeated email \\n    \\'\\'\\'\\n\\n    # The .duplicated() method in pandas returns a Boolean Series that indicates whether each row in a DataFrame is a duplicate of a previous row. The resulting Series has the same number of rows as the original DataFrame, where each element is True if the corresponding row is a duplicate and False otherwise.\\n\\n\\n    # output_df = pd.DataFrame(columns=[\\'Email\\']) # Initialise an empty dataframe object \\n    duplicate_df = person[person.duplicated(subset=[\\'email\\'], keep= \\'first\\')] # Create a new dataframe with rows from the person DF\\n    # print(type(duplicate_df))\\n\\n    # extract the required columns \\n    output_df = duplicate_df.rename(columns={\\'email\\':\\'Email\\'})[[\\'Email\\']].drop_duplicates(subset=[\\'Email\\'])\\n    return output_df\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820302,
                "title": "duplicate-emails-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person\\ngroup by email\\nhaving count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550320,
                "title": "easy-sql-code-group-by-having-clause-used",
                "content": "# Intuition\\nSimply **GROUP BY-HAVING** Clause is used.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506152,
                "title": "mysql-mega-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDon\\'t forget to write the commands in order\\n\\n# Code\\n```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336670,
                "title": "duplicate-emails",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from Person group by email having count(*)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3281912,
                "title": "sql-simple-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct p1.email as Email from person as p1 join person as p2 \\nwhere p1.email=p2.email and p1.id!=p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3167019,
                "title": "easiest-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect email as Email from Person group by email having count(email)>=2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3104694,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2951670,
                "title": "easiest-way-using-self-join-and-groupby",
                "content": "**UPVOTE IF U FOUND IT HELPFUL :-)**\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\\n\\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(p1.email) as Email\\nfrom Person p1,Person p2\\nwhere p1.email=p2.email and p1.id<>p2.id\\n```\n```\\nselect email as Email from Person\\nGroup by email\\nhaving count(email)>1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2813349,
                "title": "93-faster",
                "content": "![image](https://assets.leetcode.com/users/images/e946c37a-0515-4063-bd50-d6a0605dd695_1668416616.1929512.png)\\n\\n\\n```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2660507,
                "title": "simple-self-join",
                "content": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "solutionTags": [],
                "code": "```\\nselect Distinct a.email as Email\\nfrom \\nPerson as a,\\nPerson as  b\\nwhere \\na.id <> b.id\\nand\\na.email = b.email\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2616318,
                "title": "easy-count-solution-with-explanation-2-approaches",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```\\n\\nFor more detail please ref:\\n*(Note: You can bookmark it for your future ref)*\\nhttps://leet-codes.blogspot.com/2022/09/182-duplicate-emails.html",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT Email FROM Person GROUP BY Email HAVING  count(*) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588859,
                "title": "using-group-by-clause-easy-one",
                "content": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "Select email from Person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2563211,
                "title": "mysql-better-than-100-memory-and-58-time",
                "content": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "solutionTags": [],
                "code": "SELECT email FROM Person GROUP BY email having count(email)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2562037,
                "title": "simple-soln-using-inner-join",
                "content": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "solutionTags": [],
                "code": "select distinct p1.email as Email from person p1 inner join person p2\\nwhere p1.email= p2.email and p1.id<>p2.id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2558738,
                "title": "mysql-fundamental-approach",
                "content": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT Email FROM\\n    (SELECT Email, COUNT(Email) AS c\\n    FROM Person\\n    GROUP BY Email) AS Tem\\n    WHERE c > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2556848,
                "title": "simplest-solution-mysql-having-clause",
                "content": "select email from Person group by email\\nhaving count(*) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from Person group by email\\nhaving count(*) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2545091,
                "title": "sql-solution-using-window-function",
                "content": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```\\n\\nPlease upvote!!!",
                "solutionTags": [],
                "code": "```\\nselect email as \"Email\" from(select distinct email, count(p.email) over(partition by p.email) as \"count\" from person p) x where x.count>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541900,
                "title": "ms-sql-solution",
                "content": "select email from Person group by email having count(*) > 1;\\n",
                "solutionTags": [],
                "code": "select email from Person group by email having count(*) > 1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2537096,
                "title": "mysql-solution-simple",
                "content": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n    #Using group by and having\\n    SELECT email AS \\'Email\\'\\n    FROM Person\\n    GROUP BY email\\n    HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2528677,
                "title": "mysql-easy-solution-group-by",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2514308,
                "title": "mysql-duplicate-emails-sol-324-ms",
                "content": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email Email from Person group by email having count(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505270,
                "title": "easy-mysql-short-and-concise-check-it",
                "content": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email\\nfrom person \\ngroup by email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2476510,
                "title": "with-explanation-comments-time-323-ms-85-63-space-0b-100-00",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\n#select all elements from the coulmn \"Email\"\\nSELECT Email\\n#from the Person table\\nFROM Person\\n#groupped by the Email field\\nGROUP BY Email\\n#having a value more than 1\\nHAVING COUNT(*) > 1;\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2468168,
                "title": "mysql-solution-easy-understanding-group-by-having",
                "content": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect email as \\'Email\\'\\nfrom Person \\nGROUP BY email\\nHAVING COUNT(email) > 1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456284,
                "title": "faster-than-70-89-using-having-and-count-easy-to-understand",
                "content": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2386383,
                "title": "mysql-3-ways-super-easy",
                "content": "* **SELF JOIN**\\n```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\\n\\n* **Having and Group By Clause**\\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\\n\\n* **Having, Group By, Temperoary Table**\\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT DISTINCT A.email FROM Person A,Person B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```\n```sql\\nSELECT email FROM Person GROUP BY email HAVING count(email) > 1;\\n```\n```sql\\nSELECT email FROM (\\n    SElECT email,count(email) as EmailCount FROM Person GROUP BY email\\n) as emailData WHERE EmailCount > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356926,
                "title": "can-anyone-explain-why-group-by-is-needed",
                "content": "My initial code was \\n\\n```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\\nbut this only passed the test case and did not pass the submission. The submission test case wanted me to return an empty value since there are no duplicates. After looking at the discussion board, the top solution is:\\n\\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```\\nThis does pass the submission test case but I dont understand why. \\n\\nI am trying to fully understand so maybe I am thinking to hard about it but;\\nCan anyone explain why the \\'Group By\\' allows the query to return an empty value?\\n\\n",
                "solutionTags": [],
                "code": "```\\nselect Email\\nfrom Person\\nhaving count(email) > 1\\n```\n```\\nselect Email\\nfrom Person\\ngroup by Email\\nhaving count(*) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356055,
                "title": "solution-you-thought-first",
                "content": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EMAIL FROM PERSON\\nGROUP BY EMAIL \\nHAVING COUNT(EMAIL) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2337509,
                "title": "using-having-and-group-by",
                "content": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT email FROM Person \\nGROUP BY email \\nHAVING COUNT(email)>1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329912,
                "title": "simple-group-by-with-having",
                "content": "select email from person group by email having count(*)>=2",
                "solutionTags": [],
                "code": "select email from person group by email having count(*)>=2",
                "codeTag": "Unknown"
            },
            {
                "id": 2319719,
                "title": "simple-mysql-solution-easy-to-understand-group-by",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270479,
                "title": "faster-than-95-simple-mysql-solution",
                "content": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    email AS Email\\nFROM\\n    Person\\nGROUP BY\\n    email\\nHAVING\\n    COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2251545,
                "title": "without-group-by",
                "content": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nselect distinct p1.email from person as p1,person as p2 where p1.email=p2.email and p1.id!=p2.id;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2247548,
                "title": "one-line-oracle-solution-80-efficient",
                "content": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select distinct a.email from Person a inner join Person b on a.email=b.email where a.id<>b.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2179813,
                "title": "easy-solution-using-count-and-group-by",
                "content": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "solutionTags": [],
                "code": "select email as Email\\nfrom Person \\ngroup by 1\\nhaving count(1)>1",
                "codeTag": "Unknown"
            },
            {
                "id": 2146501,
                "title": "simple-to-understand-solution",
                "content": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select email from person\\ngroup by email\\nhaving count(email)>1;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2135537,
                "title": "mssql-grop-by-having",
                "content": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect email\\nfrom Person\\ngroup by email\\nhaving count(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2105397,
                "title": "mysql-easiest-solution",
                "content": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**Pls Upvote if you lke the Solution!**\\n```\\nSELECT DISTINCT(p1.email) \\nFROM Person p1 JOIN Person p2 \\nON p1.email=p2.email AND p1.id<>p2.id",
                "codeTag": "Unknown"
            },
            {
                "id": 2095226,
                "title": "sql-easy-simple-solution",
                "content": "**All suggestions are welcome.\\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)**\\n\\n\\n```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct p1.email from Person p1, Person  p2 where p1.email=p2.email and p1.id > p2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2092836,
                "title": "easy-solution",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email)>1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089925,
                "title": "simple-mysql-query-based-on-delete-duplicate-emails-192",
                "content": "[Solution](https://leetcode.com/problems/delete-duplicate-emails/discuss/55553/Simple-Solution) using which this one was developed\\n```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email\\nFROM Person p1, Person p2\\nWHERE p1.Email = p2.Email AND\\np1.Id > p2.Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058479,
                "title": "simplest-answer-dont-search-for-complex-one",
                "content": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email FROM Person GROUP BY email HAVING COUNT(email) > 1 ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005850,
                "title": "mysql-100-less-memory",
                "content": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "solutionTags": [],
                "code": "Select Email\\nFrom Person\\nGroup By Email\\nHaving Count(Email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1994343,
                "title": "extremely-simple-and-fast-solution",
                "content": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email FROM Person\\nGROUP BY email\\nHAVING  COUNT(email) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986789,
                "title": "easy-sql-solution",
                "content": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/be4a4d08-73c1-4d66-840a-f0302643c79e_1651073127.4433901.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect DISTINCT email AS \\'Email\\'\\nFROM Person p\\nWHERE email IN (SELECT email FROM Person p1 WHERE p.id <> p1.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973590,
                "title": "used-distinct-and-select-2-tables-71-72-time-100-00-space",
                "content": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect DISTINCT p.email as email from Person P \\nwhere P.email in (select email from Person P2 where p2.id <> p.id);  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969130,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT email\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(id) > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960555,
                "title": "mysql-93-faster-one-line-group-by",
                "content": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\nselect email from Person group by 1 having count(id) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959553,
                "title": "mysql-simple-solution-faster-than-93",
                "content": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect email from person group by email having count(email) > 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1911436,
                "title": "ms-sql",
                "content": "Runtime: 756 ms, faster than 96.81% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte as\\n(SELECT email, count(id) cnt\\nfrom Person\\ngroup by email)\\nselect email from cte\\nwhere cnt > 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891919,
                "title": "ms-sql-server-solution",
                "content": "Runtime: 1059 ms, faster than 59.13% of MS SQL Server online submissions for Duplicate Emails.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Duplicate Emails.\\n\\n```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect email as Email from Person group by email having count(email) > 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884959,
                "title": "simple-sql-solution-using-2-approaches-self-join-and-group-by",
                "content": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Using Group by and having clause\\nselect Email from person group by email having count(*) > 1\\n\\n# Using self join\\nselect distinct p1.Email from person p1 join person p2\\non p1.email = p2.email and p1.id != p2.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882698,
                "title": "faster-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(email) from Person where email in (select email from Person  group by email having count(email)>1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849980,
                "title": "beats-88-2-runtime-and-beats-100-memory-utilization",
                "content": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "solutionTags": [],
                "code": "select distinct(p.email) from person p where p.email in (select s.email from person s where s.id != p.id)",
                "codeTag": "Unknown"
            },
            {
                "id": 1790478,
                "title": "easy-solution",
                "content": "select email from person group by email having count(email) > 1;",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "select email from person group by email having count(email) > 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1720147,
                "title": "mysql-solution-using-having",
                "content": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "solutionTags": [],
                "code": "```\\nSELECT email\\nFROM   person\\nGROUP  BY email\\nHAVING Count(*) > 1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710053,
                "title": "sql-count",
                "content": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "solutionTags": [],
                "code": "select email\\nfrom person\\ngroup by email\\nhaving count(email)>1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1681421,
                "title": "mysql-simple-solution",
                "content": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct p1.email as \\'Email\\' from Person p1, Person p2\\nwhere p1.id != p2.id and p1.email = p2.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1645168,
                "title": "easy-solution-without-using-group-by",
                "content": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT A.email\\nFROM Person AS A, Person AS B\\nWHERE A.id <> B.id\\nAND A.email = B.email;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631615,
                "title": "mysql-easy",
                "content": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect email As Email\\nFrom Person\\nGroup By email\\nHaving Count(*) > 1\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575016,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576972,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1571389,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1568481,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1570505,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574508,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1573320,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576741,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1576150,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1575521,
                "content": [
                    {
                        "username": "davina1612",
                        "content": "Group By Clause is used to group similar entities together, and serves as perfect query to group the similar emails together. Syntax is as follows :\\n\\n**SELECT _parameters_ From _Table Name_\\nGROUP BY _the entity you want to group together, in this case emails_;**\\n\\nQuery : \\nselect Email from Person\\nGroup by Email  \\nHaving Count(*) > 1 ;\\n\\n\\n"
                    },
                    {
                        "username": "krupalipatel010",
                        "content": "**Approach 1 - Faster runtime**\\n\\nwith temp as (\\nselect email,\\nrow_number() over(partition by email) as rnk\\nfrom  person\\n)\\n\\nselect distinct email from temp where rnk > 1\\n\\n\\n**Approach 2-slow but simple to understand**\\nselect distinct email\\nfrom person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "no need of distinct"
                    },
                    {
                        "username": "SRINIVASHINI_SUNDARALINGAM",
                        "content": "[@Arshad_Nehal](/Arshad_Nehal) HAVING clause takes some time..bcz  we will get result after aggregation aggregating \\n"
                    },
                    {
                        "username": "Arshad_Nehal",
                        "content": "why first one has faster runtime\\n"
                    },
                    {
                        "username": "Dreamers",
                        "content": "# Write your MySQL query statement below\\nSELECT Email FROM Person\\nHAVING (COUNT(Email)>1);\\n\\n\\n\\nWithout GROUP BY Email, I alway got wrong answer. What is GROUP BY, why it matters here?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": "here, group by group by will group the similar mails together"
                    },
                    {
                        "username": "chennnnnnn",
                        "content": "GROUP BY is used when we want one or more fields to organize similar records together. The list of fields in the GROUP BY clause must be identical to the list of fields SELECTed"
                    },
                    {
                        "username": "highllander",
                        "content": "`SELECT Email FROM Person GROUP BY Email Having COUNT(*) > 1; `"
                    },
                    {
                        "username": "prashanth223",
                        "content": "# Write your MySQL query statement below\\n\\nselect Email from Person group by Email having count(Email)>1;"
                    },
                    {
                        "username": "John_2310",
                        "content": "**Approach**\\nWe can check for the matching Email fields in the records having different Id as compared to the current record. Then we accumulate all the duplicated values and use `select distinct` in the outer query to print the duplicated records. \\n\\n**MySQL/Ms SQL SERVER Query**\\n`select distinct p.Email from Person as p where Email in(Select Email from Person where Email = p.email and Id != p.Id);`\\n\\n"
                    },
                    {
                        "username": "vanagarw",
                        "content": "\\'\\'\\'\\nselect  Email as Email from Person\\nMINUS\\nselect distinct Email as Email from Person\\n\\'\\'\\'\\n\\nWhy doesnt this work?"
                    },
                    {
                        "username": "Logic0807",
                        "content": "MINUS operator compares the result sets of two queries and returns distinct rows from the left query that are not output by the right query. DISTINCT is inherent in MINUS"
                    },
                    {
                        "username": "devn",
                        "content": "with dup_data as (\\nSELECT id, email, ROW_NUMBER() OVER (partition by email ORDER by email) as num1 FROM Person\\n)\\n\\nSELECT DISTINCT email from dup_data WHERE num1 > 1"
                    },
                    {
                        "username": "kdhakal",
                        "content": "\\tselect email from Person group by email having count(*) > 1;"
                    },
                    {
                        "username": "user7419w",
                        "content": "![image](https://assets.leetcode.com/users/images/80cb07c2-9023-40d5-a6a0-c334662b8feb_1625993568.0604331.png)\\n\\n\\n-- SUBMISSION:\\n\\nselect distinct a.Email from \\n(select Email,row_number() over (partition by Email) as rn\\nfrom Person) a \\nwhere a.rn > 1"
                    }
                ]
            },
            {
                "id": 1574345,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1576215,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1575485,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1574455,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2076978,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2064868,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 2022928,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1964590,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1896547,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1893963,
                "content": [
                    {
                        "username": "kitokirti94",
                        "content": "# Write your MySQL query statement below\\nSELECT DISTINCT p1.Email\\nFrom Person p1\\nJoin Person p2\\nWHERE p1.Email =p2.EmaiL AND p1.Id <> p2.Id"
                    },
                    {
                        "username": "SahilAnower",
                        "content": "`Select email as Email From Person Group By email Having Count(email)>1;`"
                    },
                    {
                        "username": "mehulsatardekar",
                        "content": "# Mysql Solution\\n\\n**`select email from person group by email having count(email) > 1;`**"
                    },
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/qK_PcMHUyY4](https://youtu.be/qK_PcMHUyY4)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "maithiliK3",
                        "content": "Did you solve premium queries too?"
                    },
                    {
                        "username": "user8789w",
                        "content": "select distinct a.email as Email from (\\nselect id,email,lead(email,1) over(order by email) as next_email from person\\n) a where a.email = a.next_email\\n\\nselect distinct email from (select email,count(*) as cnt from person group by email order by email) \\na where a.cnt > 1"
                    },
                    {
                        "username": "aryaraj_16",
                        "content": "is there any another way to solve this question rather than using \" group by \" ?"
                    },
                    {
                        "username": "mmsarkar621",
                        "content": "SELECT email as Email\\nFROM Person\\nGROUP BY email HAVING count(email) > 1"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "select email \\nfrom (\\n  select email, row_number() over (partition by email)  as email_total\\n  from Person\\n) subquery\\nwhere email_total > 1"
                    },
                    {
                        "username": "arturonp",
                        "content": "SELECT Distinct email AS Email FROM Person \\n\\nHAVING COUNT(*) > 1 "
                    },
                    {
                        "username": "user4479u",
                        "content": "This code is from my girlfriend, her logic is so bad, but this code works well\n\nselect\ncase when count(email) > 1 then email end as 'Email'\nfrom Person"
                    }
                ]
            },
            {
                "id": 1881442,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1845451,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1839695,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1812094,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1808987,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1803586,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1802766,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797654,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1797262,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1792261,
                "content": [
                    {
                        "username": "sarthakdhama007",
                        "content": "select Email from Person group by email having count(email)>1;"
                    },
                    {
                        "username": "flagUAS_28",
                        "content": "I tried using subquery, grouping by count, and I can\\'t seem to figure out why sql server is not accepting it.\\n\\nselect Email from (select Email, count(Email) from Person group by Email having count(Email) > 1);"
                    },
                    {
                        "username": "akashbm",
                        "content": "select P1.email as Email\\nfrom Person P1, Person P2\\nwhere P1.id != P2.id\\nand P1.email = P2.email\\ngroup by P1.email"
                    },
                    {
                        "username": "code_zen_0",
                        "content": "This is my answer :\\n\\nSELECT email\\nFROM person\\nGROUP BY email\\nHAVING COUNT(email) = 2;"
                    },
                    {
                        "username": "csalomon_ya",
                        "content": " select distinct email\\n  from\\n  (select email, dense_rank() over (partition by email order by id) as [rank]\\n  from person)t1\\n  where rank =2"
                    },
                    {
                        "username": "AKASHrt2021",
                        "content": "select email from (select count(id) as freq,email from Person group by email) x where x.freq>1;"
                    },
                    {
                        "username": "jwebb2W",
                        "content": "Test case with two e-mails that are not repeats erroneously expects one of the non-repeated e-mails, when it should be an empty return.\\n\\nInput\\nPerson =\\n| id | email             |\\n| -- | ----------------- |\\n| 1  | paris@hilton.com  |\\n| 2  | mickey@disney.com |\\n7 / 15 testcases passed\\nOutput\\n| email            |\\n| ---------------- |\\n| paris@hilton.com |\\nExpected\\n| Email |\\n| ----- |"
                    },
                    {
                        "username": "shivaputra123",
                        "content": "When i start to solve i got some error in this problem i tried first to take duplicate and then i realize this solution is not required duplicate number but it required values of duplicate number  its good to resolve thanks"
                    },
                    {
                        "username": "KhaledAOsman",
                        "content": "Why give me error ?\\n\"Column \\'email\\' in field list is ambiguous\"\\nSelect email \\nfrom Person as p1\\ninner join Person as p2 \\non p1.id =p2.id\\n\\n"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select email from person\\ngroup by email having count(email)>1;"
                    }
                ]
            },
            {
                "id": 1783597,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1777337,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1776030,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1774127,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1751993,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1731142,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1724819,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716892,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716838,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            },
            {
                "id": 1716295,
                "content": [
                    {
                        "username": "ajinkya_kadhe",
                        "content": "This is a SQL query that selects the \"email\" column from the \"Person\" table and groups the results by the \"email\" column. The \"HAVING\" clause specifies that only groups with a count greater than 1 should be returned. In other words, it returns the email addresses that are repeated more than once in the \"Person\" table.\\n `select email as Email from Person GROUP BY email HAVING count(email) > 1`"
                    },
                    {
                        "username": "NaveenShukla",
                        "content": "2 APPROACHES - Using JOIN, Using GROUP BY count.\\n\\n- 1st App - Using JOIN:\\n\\nSELECT distinct (p1.email) AS Email FROM Person p1 JOIN Person p2\\nON p1.email = p2.email and p1.id != p2.id;\\n\\n\\n- 2nd App - Using GROUP BY count:\\n\\nselect distinct email from person \\ngroup by email\\nhaving count(*) > 1;\\n\\n\\n:-D"
                    },
                    {
                        "username": "azaraatif",
                        "content": "select email as \\'Email\\' from Person \\ngroup by email \\nhaving count(email) > 1;"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT email AS Email FROM Person\\nGROUP BY email\\nHAVING COUNT(*) >= 2;"
                    },
                    {
                        "username": "tuneer_bhattacharya",
                        "content": "# Write your MySQL query statement below\\nSelect email From Person \\nGROUP BY email\\nHAVING count(*)>1"
                    },
                    {
                        "username": "syntaxoo",
                        "content": " `SELECT T1.email\\nFROM (\\n    SELECT email ,count(email) as cnt\\n    FROM Person\\n    GROUP BY email \\n    )T1\\nWHERE T1.cnt > 1`"
                    },
                    {
                        "username": "sameerpatil_",
                        "content": "UNIQUE Approach using self join\\n\\nSELECT DISTINCT p.email AS Email \\nFROM person p, person pe \\nWHERE p.id!=pe.id AND p.email=pe.email;"
                    },
                    {
                        "username": "Drackus001",
                        "content": "SELECT DISTINCT email \\'Email\\'\\nFROM Person\\nGROUP BY email\\nHAVING COUNT(email) > 1;"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select email from Person\\ngroup by email\\nhaving count(*) > 1"
                    },
                    {
                        "username": "himsindhu1499",
                        "content": "with cte as (select email,count(*) as \\'cnt\\'\\nfrom Person\\ngroup by email)\\nselect email as \\'Email\\' from cte\\nwhere cnt >1"
                    }
                ]
            }
        ]
    }
]