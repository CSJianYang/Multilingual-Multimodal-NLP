[
    {
        "title": "Maximum Employees to Be Invited to a Meeting",
        "question_content": "A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.\nThe employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.\nGiven a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting.\n&nbsp;\nExample 1:\n\nInput: favorite = [2,2,1,2]\nOutput: 3\nExplanation:\nThe above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.\nAll employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.\nNote that the company can also invite employees 1, 2, and 3, and give them their desired seats.\nThe maximum number of employees that can be invited to the meeting is 3. \n\nExample 2:\n\nInput: favorite = [1,2,0]\nOutput: 3\nExplanation: \nEach employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.\nThe seating arrangement will be the same as that in the figure given in example 1:\n- Employee 0 will sit between employees 2 and 1.\n- Employee 1 will sit between employees 0 and 2.\n- Employee 2 will sit between employees 1 and 0.\nThe maximum number of employees that can be invited to the meeting is 3.\n\nExample 3:\n\nInput: favorite = [3,0,1,4,1]\nOutput: 4\nExplanation:\nThe above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.\nEmployee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\nSo the company leaves them out of the meeting.\nThe maximum number of employees that can be invited to the meeting is 4.\n\n&nbsp;\nConstraints:\n\n\tn == favorite.length\n\t2 <= n <= 105\n\t0 <= favorite[i] <=&nbsp;n - 1\n\tfavorite[i] != i",
        "solutions": [
            {
                "id": 1660944,
                "title": "c-dfs-with-illustration",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. DFS\\n![image](https://assets.leetcode.com/users/images/4b897539-d0e0-4106-b726-2d844e25505b_1641096121.633408.png)\\n![image](https://assets.leetcode.com/users/images/a24c2da3-31c2-4794-95ac-bd99be8ef4fd_1641096978.4959388.png)\\n\\n![image](https://assets.leetcode.com/users/images/97b2c449-baaa-424a-9f32-98f44769a471_1641096127.869161.png)\\n\\nThe answer is the maximum of:\\n* the **sum** of all case 1 components\\n* the **maximum** of case 2 components\\n\\nUpdate 1/2/2022:\\n![image](https://assets.leetcode.com/users/images/659f9365-ca80-4090-b099-58dff10508a9_1641192564.935251.png)\\n\\n![image](https://assets.leetcode.com/users/images/b67b9e0e-ca31-410b-8a61-fa7f6e0495bc_1641192569.2305136.png)\\n\\n![image](https://assets.leetcode.com/users/images/1d61f495-ed33-4000-b020-abd457e04889_1641192572.5737343.png)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& A) {\\n        int N = A.size();\\n        vector<int> m(N, -1); // m[i] is the depth of node i. -1 means unvisited\\n        vector<vector<int>> r(N); // The reverse graph\\n        for (int i = 0; i < N; ++i) r[A[i]].push_back(i);\\n        // handle case 1\\n        function<int(int)> dfs = [&](int u) {\\n            if (m[u] != -1) return m[u];\\n            int ans = 0;\\n            for (int v : r[u]) ans = max(ans, dfs(v));\\n            return m[u] = 1 + ans;\\n        };\\n        int ans = 0, free = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (m[i] != -1) continue; // skip visited nodes\\n            if (A[A[i]] == i) {\\n                m[i] = m[A[i]] = 0;\\n                int a = 0, b = 0; // find the length of the longest arms starting from `i` and `A[i]`\\n                for (int v : r[i]) {\\n                    if (v == A[i]) continue;\\n                    a = max(a, dfs(v));\\n                }\\n                for (int v : r[A[i]]) {\\n                    if (v == i) continue;\\n                    b = max(b, dfs(v));\\n                }\\n                free += a + b + 2; // this free component is of length `a+b+2`\\n            }\\n        }\\n        // handle case 2\\n        function<tuple<int, int, bool>(int)> dfs2 = [&](int u)->tuple<int, int, bool> {\\n            if (m[u] != -1) return {u, m[u], false}; // We visited this node the second time, so this node must be the entry point to the cycle\\n            m[u] = 0;\\n            auto [entryPoint, depth, cycleVisited] = dfs2(A[u]);\\n            if (cycleVisited) { // After the cycle being traversed, any other node in the backtracking process are outside of the cycle and should be ignored (by keeping m[u] as 0).\\n                return {entryPoint, depth, true};\\n            }\\n            m[u] = 1 + depth; // If we haven\\'t met the entry point again, this is a node within the cycle, so we increment the depth.\\n            return {entryPoint, m[u], u == entryPoint}; // When we visit the entry point again, we know what we\\'ve done traversing the cycle.\\n        };\\n        for (int i = 0; i < N; ++i) {\\n            if(m[i] != -1) continue;\\n            auto [entryPoint, depth, cycleVisited] = dfs2(i);\\n            if (cycleVisited) ans = max(ans, depth);\\n        }\\n        return max(ans, free);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& A) {\\n        int N = A.size();\\n        vector<int> m(N, -1); // m[i] is the depth of node i. -1 means unvisited\\n        vector<vector<int>> r(N); // The reverse graph\\n        for (int i = 0; i < N; ++i) r[A[i]].push_back(i);\\n        // handle case 1\\n        function<int(int)> dfs = [&](int u) {\\n            if (m[u] != -1) return m[u];\\n            int ans = 0;\\n            for (int v : r[u]) ans = max(ans, dfs(v));\\n            return m[u] = 1 + ans;\\n        };\\n        int ans = 0, free = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (m[i] != -1) continue; // skip visited nodes\\n            if (A[A[i]] == i) {\\n                m[i] = m[A[i]] = 0;\\n                int a = 0, b = 0; // find the length of the longest arms starting from `i` and `A[i]`\\n                for (int v : r[i]) {\\n                    if (v == A[i]) continue;\\n                    a = max(a, dfs(v));\\n                }\\n                for (int v : r[A[i]]) {\\n                    if (v == i) continue;\\n                    b = max(b, dfs(v));\\n                }\\n                free += a + b + 2; // this free component is of length `a+b+2`\\n            }\\n        }\\n        // handle case 2\\n        function<tuple<int, int, bool>(int)> dfs2 = [&](int u)->tuple<int, int, bool> {\\n            if (m[u] != -1) return {u, m[u], false}; // We visited this node the second time, so this node must be the entry point to the cycle\\n            m[u] = 0;\\n            auto [entryPoint, depth, cycleVisited] = dfs2(A[u]);\\n            if (cycleVisited) { // After the cycle being traversed, any other node in the backtracking process are outside of the cycle and should be ignored (by keeping m[u] as 0).\\n                return {entryPoint, depth, true};\\n            }\\n            m[u] = 1 + depth; // If we haven\\'t met the entry point again, this is a node within the cycle, so we increment the depth.\\n            return {entryPoint, m[u], u == entryPoint}; // When we visit the entry point again, we know what we\\'ve done traversing the cycle.\\n        };\\n        for (int i = 0; i < N; ++i) {\\n            if(m[i] != -1) continue;\\n            auto [entryPoint, depth, cycleVisited] = dfs2(i);\\n            if (cycleVisited) ans = max(ans, depth);\\n        }\\n        return max(ans, free);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661178,
                "title": "python-explanation-with-pictures",
                "content": "I created my solution right after the contest ended, but it was blocked somehow. Currently all my posts for this problem are only visible to me.\\n\\nURL of my original post: \\nhttps://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661263/python-3-explanation-with-pictures\\n\\n> I have tried quite a few times but still cant post anything, its really frustrating to be blocked for no reason. I have no idea what\\'s going on since I was just using the same method as before: no other URLs, just 6 figures and the code. \\n> But this post for complaining is alive, so I will copy my original post here.\\n\\n---\\n\\n\\nThere are two ways to fill the table:\\n\\n-  some people form a one-way connected cirlce (a -> b -> c -> d -> a, a->b means b is a\\'s favorite people)\\n-  some groups of people featured by two mutal-favoriting people (a <-> b, which means both a and b are the other\\'s favorite people)\\n\\n![image](https://assets.leetcode.com/users/images/727de57e-a6b4-4ee3-b714-9bcee1234704_1641163766.1036708.png)\\n\\nHere our task is to find out the maximum number of people in these two cases and return the larger one. That is:\\n- The maximum circle in this graph.\\n- The sum of all the longest chain containing all the pairs.\\n\\n---\\n\\n\\n## 1. The largest circle.\\n\\n\\nIn this problem, each people only has 1 favorite people, which makes this problem easy to handle. We just need to find an **unvisited** people, mark him/her as **visited**, find his/her favorite people and go ahead to that person, until we find the first **visited** people. As shown below, the first **visited** people in this iteration is colored in dark green. (We will talk about how to get the size of this circle later)\\n\\n![image](https://assets.leetcode.com/users/images/e1309fec-c662-413e-8c9b-2b455ba712b8_1641164173.3616712.png)\\n\\n\\nWe have known that every iteration always ends up with an **visited** people. The only difference is: \\n\\n> Is this people being firstly visited in this iteration, or in an earlier iteration?\\n\\nTake the figures below as an example, in the red iteration, we run into a **visited** people who has been visited in a previous iteration, then there wouldn\\'t be any new circle. However in the blue interation, the **visited** people (colored in dark blue) is firstly visited in this iteration, meaning there exists a new circle.\\n\\n![image](https://assets.leetcode.com/users/images/898f3f9e-c593-4543-afb8-157209fc8e15_1641164956.4485626.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/2d8db2c4-fee7-4c0e-b4db-361684b57c05_1641165030.848955.png)\\n\\n---\\n\\n> How to get the size of a circle?\\n\\nOnce we record the starting people when starting a new iteration, if we find a new legal circle, we just need to calculate how many people we have newly visited in this ieration, and the distance from the starting people to the first **visited** people. \\n\\n![image](https://assets.leetcode.com/users/images/472a7d95-fd0c-452d-951f-bb9f30ea2671_1641165332.9819517.png)\\n\\nCalculate the size of each circle and record the largest one.\\n\\n---\\n\\n## 2. Sum of all the longest chains.\\n\\nRecall that we need to find out all the pairs containing two mutal-favoriting people.\\n\\n![image](https://assets.leetcode.com/users/images/9e59c343-7faa-4c33-a5ae-28aefd1b801c_1641165397.8526597.png)\\n\\nThen we would like to get the longest chain for each pair. Consider the status below, where a and b are mutal-favoriting. \\n\\n![image](https://assets.leetcode.com/users/images/9d073878-2b25-4aa6-b3ca-6c74f88efdc2_1641165402.3325021.png)\\n\\nWe could use either BFS or DFS on the graph to find out the longest arm start from a or b. Here the number stands for the distance from each people to a or b, which is exactly the arm length ending at this people.\\n\\nThen the maximum length equals the length of two longest \\'arms\\' plus 2 (a and b themselves).\\n\\n\\n![image](https://assets.leetcode.com/users/images/8f8a4ad8-569c-4525-96bf-e9cba73b1f37_1641165406.5479186.png)\\n\\n> Finally, we compare the size of the largest circle and the sum of the longest lengths and return the larger one as the answer.\\n\\n\\n\\n```\\ndef maximumInvitations(self, A: List[int]) -> int:\\n\\t\\t# First, we find the largest circle.\\n        n, maxc = len(A), 0\\n        seen = [0] * n\\n        for idx in range(n):\\n\\t\\t\\n\\t\\t\\t# If a people hasn\\'t been visited:\\n            if seen[idx] == 0:\\n                \\n\\t\\t\\t\\t# start is for locating the first visited people, cur_people stands \\n\\t\\t\\t\\t#for the current people we are visiting, we use curset to store all \\n\\t\\t\\t\\t# the visited people in this iteration.\\n\\t\\t\\t\\tstart = idx\\n                cur_people = idx\\n                curset = set()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# As long as we are visiting new people, we keep finding his/her favorite.\\n                while seen[cur_people] == 0:\\n                    seen[cur_people] = 1\\n                    curset.add(cur_people)\\n                    cur_people = A[cur_people]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Until we find the first visited people. Depends on if this \\n\\t\\t\\t\\t# visited people has been visited in eariler iteration or just this iteration.\\n\\t\\t\\t\\tif cur_people in curset:       # if current people is in current set, meaning we have found a new circle\\n                    cursum = len(curset)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# use \\'start\\' to find the distance from the first visited people in this iteration \\n\\t\\t\\t\\t\\t# to this current people.\\n                    while start != cur_people:\\n                        cursum -= 1\\n                        start = A[start]\\n                    maxc = max(maxc, cursum)\\n                                       \\n\\t\\t# Then we try to find the sum of largest arms. Firstly, find all mutal-favorite peoples.\\n        pair = []\\n        visited = [0] * n\\n        for i in range(n):\\n\\t\\t\\n\\t\\t\\t# If a is b\\'s favorite and vise versa, we put them in \\'pair\\'.\\n            if A[A[i]] == i and visited[i] == 0:\\n                pair.append([i, A[i]])\\n                visited[i] = 1\\n                visited[A[i]] = 1\\n\\t\\t\\n\\t\\t# for every people I, find out all the people whos favorite is I.\\n        res = 0\\n        child = collections.defaultdict(list)\\n        for i in range(n):\\n            child[A[i]].append(i)\\n        \\n        for a, b in pair:\\n            # max arm length start from first people a\\n            maxa = 0\\n            dq = collections.deque()\\n            for cand in child[a]:\\n                if cand != b:\\n                    dq.append([cand, 1])\\n            while dq:\\n                cur, n = dq.popleft()\\n                maxa = max(maxa, n)\\n                for nxt in child[cur]:\\n                    dq.append([nxt, n + 1])\\n                    \\n            # max arm length start from first people b\\n            maxb = 0\\n            dq = collections.deque()\\n            for cand in child[b]:\\n                if cand != a:\\n                    dq.append([cand, 1])\\n            while dq:\\n                cur, n = dq.popleft()\\n                maxb = max(maxb, n)\\n                for nxt in child[cur]:\\n                    dq.append([nxt, n + 1])\\n            \\n\\t\\t\\t# Thus the total length is the two longest arm plus 2 (a and b themselves)\\n            res += 2 + maxa + maxb\\n\\t\\t\\t\\n\\t\\t# select the larger one as the answer.\\n        return max(maxc, res)  \\n```\\n\\n\\n\\nPlease let me know if you have any questions about the solution, or suggestions for this issue, thanks!",
                "solutionTags": [],
                "code": "```\\ndef maximumInvitations(self, A: List[int]) -> int:\\n\\t\\t# First, we find the largest circle.\\n        n, maxc = len(A), 0\\n        seen = [0] * n\\n        for idx in range(n):\\n\\t\\t\\n\\t\\t\\t# If a people hasn\\'t been visited:\\n            if seen[idx] == 0:\\n                \\n\\t\\t\\t\\t# start is for locating the first visited people, cur_people stands \\n\\t\\t\\t\\t#for the current people we are visiting, we use curset to store all \\n\\t\\t\\t\\t# the visited people in this iteration.\\n\\t\\t\\t\\tstart = idx\\n                cur_people = idx\\n                curset = set()\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# As long as we are visiting new people, we keep finding his/her favorite.\\n                while seen[cur_people] == 0:\\n                    seen[cur_people] = 1\\n                    curset.add(cur_people)\\n                    cur_people = A[cur_people]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t# Until we find the first visited people. Depends on if this \\n\\t\\t\\t\\t# visited people has been visited in eariler iteration or just this iteration.\\n\\t\\t\\t\\tif cur_people in curset:       # if current people is in current set, meaning we have found a new circle\\n                    cursum = len(curset)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# use \\'start\\' to find the distance from the first visited people in this iteration \\n\\t\\t\\t\\t\\t# to this current people.\\n                    while start != cur_people:\\n                        cursum -= 1\\n                        start = A[start]\\n                    maxc = max(maxc, cursum)\\n                                       \\n\\t\\t# Then we try to find the sum of largest arms. Firstly, find all mutal-favorite peoples.\\n        pair = []\\n        visited = [0] * n\\n        for i in range(n):\\n\\t\\t\\n\\t\\t\\t# If a is b\\'s favorite and vise versa, we put them in \\'pair\\'.\\n            if A[A[i]] == i and visited[i] == 0:\\n                pair.append([i, A[i]])\\n                visited[i] = 1\\n                visited[A[i]] = 1\\n\\t\\t\\n\\t\\t# for every people I, find out all the people whos favorite is I.\\n        res = 0\\n        child = collections.defaultdict(list)\\n        for i in range(n):\\n            child[A[i]].append(i)\\n        \\n        for a, b in pair:\\n            # max arm length start from first people a\\n            maxa = 0\\n            dq = collections.deque()\\n            for cand in child[a]:\\n                if cand != b:\\n                    dq.append([cand, 1])\\n            while dq:\\n                cur, n = dq.popleft()\\n                maxa = max(maxa, n)\\n                for nxt in child[cur]:\\n                    dq.append([nxt, n + 1])\\n                    \\n            # max arm length start from first people b\\n            maxb = 0\\n            dq = collections.deque()\\n            for cand in child[b]:\\n                if cand != a:\\n                    dq.append([cand, 1])\\n            while dq:\\n                cur, n = dq.popleft()\\n                maxb = max(maxb, n)\\n                for nxt in child[cur]:\\n                    dq.append([nxt, n + 1])\\n            \\n\\t\\t\\t# Thus the total length is the two longest arm plus 2 (a and b themselves)\\n            res += 2 + maxa + maxb\\n\\t\\t\\t\\n\\t\\t# select the larger one as the answer.\\n        return max(maxc, res)  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661394,
                "title": "java-short-solution-based-on-topological-sort-which-leaves-just-loops",
                "content": "The goal is to find loops of size >2 and loops of size == 2 with longest path leading to either end. Topological sort seems to be a good fit.\\nNo need to create graph since there is exactly one neighbor.\\n\\n```\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        boolean[] visited = new boolean[n];\\n        // topological sort which picks out acyclic part.\\n        int[] indegrees = new int[n];\\n        for(int i = 0; i < n; ++i) {\\n            int j = favorite[i]; // i -> favorite[i].\\n            ++indegrees[j];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; ++i) {\\n            if (indegrees[i] == 0) {\\n                visited[i] = true;\\n                q.offer(i);\\n            }\\n        }\\n        int[] dp = new int[n]; // dp[i] is the longest path leading to i exclusively.\\n        while(!q.isEmpty()) {\\n            int i = q.poll();\\n            int j = favorite[i];\\n            dp[j] = Math.max(dp[j], dp[i] + 1);\\n            if (--indegrees[j] == 0) {\\n                visited[j] = true;\\n                q.offer(j);\\n            }\\n        }\\n        // now not visited nodes are all loops. check each loop\\'s length.\\n        int result = 0; // loops of length > 2.\\n        int result2 = 0; // loops of length 2 and paths leading to both nodes.\\n        for(int i = 0; i < n; ++i) {\\n            if (visited[i] == false) {\\n                int length = 0;\\n                for(int j = i; visited[j] == false; j = favorite[j]) {\\n                    visited[j] = true;\\n                    ++length;\\n                }\\n                if (length == 2) {\\n                    result2 += 2 + dp[i] + dp[favorite[i]];\\n                } else {\\n                    result = Math.max(result, length);\\n                }\\n            }\\n        }\\n        return Math.max(result, result2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        boolean[] visited = new boolean[n];\\n        // topological sort which picks out acyclic part.\\n        int[] indegrees = new int[n];\\n        for(int i = 0; i < n; ++i) {\\n            int j = favorite[i]; // i -> favorite[i].\\n            ++indegrees[j];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i = 0; i < n; ++i) {\\n            if (indegrees[i] == 0) {\\n                visited[i] = true;\\n                q.offer(i);\\n            }\\n        }\\n        int[] dp = new int[n]; // dp[i] is the longest path leading to i exclusively.\\n        while(!q.isEmpty()) {\\n            int i = q.poll();\\n            int j = favorite[i];\\n            dp[j] = Math.max(dp[j], dp[i] + 1);\\n            if (--indegrees[j] == 0) {\\n                visited[j] = true;\\n                q.offer(j);\\n            }\\n        }\\n        // now not visited nodes are all loops. check each loop\\'s length.\\n        int result = 0; // loops of length > 2.\\n        int result2 = 0; // loops of length 2 and paths leading to both nodes.\\n        for(int i = 0; i < n; ++i) {\\n            if (visited[i] == false) {\\n                int length = 0;\\n                for(int j = i; visited[j] == false; j = favorite[j]) {\\n                    visited[j] = true;\\n                    ++length;\\n                }\\n                if (length == 2) {\\n                    result2 += 2 + dp[i] + dp[favorite[i]];\\n                } else {\\n                    result = Math.max(result, length);\\n                }\\n            }\\n        }\\n        return Math.max(result, result2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1674049,
                "title": "mutual-favorites",
                "content": "Your initial impulse could be to use some graph algorithm to find the longest cycle. That would be an overcomplication - there is an easier way to find cycles since each person has only one favorite. And, it won\\'t solve the problem because a cycle is not the only possible arrangement.\\n\\nIf two employees favorite each other, we can sit them together and they would not care who is on the other side. \\n\\nIf another employee likes one of those mutual favorites, we can sit them next. So, you can \"chain\" favorites starting from the mutual ones.\\n\\n![image](https://assets.leetcode.com/users/images/4406bdbc-9a76-4eef-a78c-5107fa45fed1_1641610345.4367068.png)\\n\\nWe can identify mutual favorites as `fav[fav[i]] == i`. We can also use a reverse favorite tree (`al`) to trace the favorites chain from those mutual favorites, and find the longest chain using DFS.\\n\\nAll mutual favorites with their longest \"chains\" can be seated at the same table. \\n\\nAfter that, we also need to check for loops. We start from an employee `i` and go up the favorites chain - marking employees as `visited` - until we encounter a visited employee `j` again (loop). The size of the loop is the total number of steps, minus the number of steps from employee `i` to `j`.\\n\\n**C++**\\n```cpp\\nbool visited[100000] = {};\\nint dfs(int i, vector<vector<int>> &al) {\\n    visited[i] = true;\\n    return 1 + accumulate(begin(al[i]), end(al[i]), 0, [&](int res, int j){\\n        return max(res, dfs(j, al));\\n    });\\n}\\nint maximumInvitations(vector<int>& fav) {\\n    int res = 0;\\n    vector<vector<int>> al(fav.size());\\n    for(int i = 0; i < fav.size(); ++i)\\n        if (fav[fav[i]] != i)\\n            al[fav[i]].push_back(i);\\n    for(int i = 0; i < fav.size(); ++i)\\n        if (fav[fav[i]] == i)\\n            res += dfs(i, al);\\n    for(int i = 0; i < fav.size(); ++i) {\\n        int cnt = 0, j = i;\\n        for (; visited[j] == false; j = fav[j]) {\\n            visited[j] = true;\\n            ++cnt;\\n        }\\n        for (int k = i; k != j; k = fav[k])\\n            --cnt;\\n        res = max(res, cnt); \\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool visited[100000] = {};\\nint dfs(int i, vector<vector<int>> &al) {\\n    visited[i] = true;\\n    return 1 + accumulate(begin(al[i]), end(al[i]), 0, [&](int res, int j){\\n        return max(res, dfs(j, al));\\n    });\\n}\\nint maximumInvitations(vector<int>& fav) {\\n    int res = 0;\\n    vector<vector<int>> al(fav.size());\\n    for(int i = 0; i < fav.size(); ++i)\\n        if (fav[fav[i]] != i)\\n            al[fav[i]].push_back(i);\\n    for(int i = 0; i < fav.size(); ++i)\\n        if (fav[fav[i]] == i)\\n            res += dfs(i, al);\\n    for(int i = 0; i < fav.size(); ++i) {\\n        int cnt = 0, j = i;\\n        for (; visited[j] == false; j = fav[j]) {\\n            visited[j] = true;\\n            ++cnt;\\n        }\\n        for (int k = i; k != j; k = fav[k])\\n            --cnt;\\n        res = max(res, cnt); \\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661037,
                "title": "java-detailed-explanation-with-picture-o-n-time-complexity",
                "content": "There are two conditions:\\n  1. There is a pair of ***Gganbu***, who are each others\\' favorite. So anyone who like them are lucky. So we only need to select the longest path.\\n  2. There is a circle. Anyone outside the circle will be eliminated. As shown in picture, E, F are not lucky to be selected.\\n  ![image](https://assets.leetcode.com/users/images/7f7b9a59-d46b-454e-ad49-a6ab05657b99_1641096163.6561313.png)\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n\\n        int answer = 0;\\n\\n        List<List<Integer>> pairs = new ArrayList<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (i == favorite[favorite[i]]) {\\n                if (i < favorite[i]) {\\n                    List<Integer> pair = new ArrayList<>();\\n                    pair.add(i);\\n                    pair.add(favorite[i]);\\n                    pairs.add(pair);\\n                }\\n            } else {\\n                graph.get(favorite[i]).add(i);\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[favorite.length];\\n        for (List<Integer> pair: pairs) {\\n            answer += dfs(graph, pair.get(0), visited) + dfs(graph, pair.get(1), visited);\\n        }\\n        \\n        int[] counter = new int[favorite.length];\\n        int[] round = new int[favorite.length];\\n\\n        int rnd = 1;\\n\\n        int circleMax = 0;\\n\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            if (round[i] != 0) {\\n                continue;\\n            }\\n\\n            int cnt = 1;\\n            int j = i;\\n            while (counter[j] == 0) {\\n                counter[j] = cnt;\\n                round[j] = rnd;\\n                j = favorite[j];\\n                cnt++;\\n            }\\n            if (round[j] == rnd) {\\n                circleMax = Math.max(circleMax, cnt - counter[j]);\\n            }\\n            rnd++;\\n        }\\n        return Math.max(circleMax, answer);\\n    }\\n\\n    private int dfs(List<List<Integer>> graph, int node, boolean[] visited) {\\n        visited[node] = true;\\n        int max = 0;\\n        for (int neighbor: graph.get(node)) {\\n            max = Math.max(max, dfs(graph, neighbor, visited));\\n        }\\n        return max + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n\\n        int answer = 0;\\n\\n        List<List<Integer>> pairs = new ArrayList<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (i == favorite[favorite[i]]) {\\n                if (i < favorite[i]) {\\n                    List<Integer> pair = new ArrayList<>();\\n                    pair.add(i);\\n                    pair.add(favorite[i]);\\n                    pairs.add(pair);\\n                }\\n            } else {\\n                graph.get(favorite[i]).add(i);\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[favorite.length];\\n        for (List<Integer> pair: pairs) {\\n            answer += dfs(graph, pair.get(0), visited) + dfs(graph, pair.get(1), visited);\\n        }\\n        \\n        int[] counter = new int[favorite.length];\\n        int[] round = new int[favorite.length];\\n\\n        int rnd = 1;\\n\\n        int circleMax = 0;\\n\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            if (round[i] != 0) {\\n                continue;\\n            }\\n\\n            int cnt = 1;\\n            int j = i;\\n            while (counter[j] == 0) {\\n                counter[j] = cnt;\\n                round[j] = rnd;\\n                j = favorite[j];\\n                cnt++;\\n            }\\n            if (round[j] == rnd) {\\n                circleMax = Math.max(circleMax, cnt - counter[j]);\\n            }\\n            rnd++;\\n        }\\n        return Math.max(circleMax, answer);\\n    }\\n\\n    private int dfs(List<List<Integer>> graph, int node, boolean[] visited) {\\n        visited[node] = true;\\n        int max = 0;\\n        for (int neighbor: graph.get(node)) {\\n            max = Math.max(max, dfs(graph, neighbor, visited));\\n        }\\n        return max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661433,
                "title": "c-topo-sort-disjoint-union",
                "content": "The disjoint union structure here is used for keeping track of the lengths of the cycles. Topo sort is being used to reduce the graph down to only its cyclic components.\\n\\nThe idea is to first process the nodes that aren\\'t part of a cycle (i.e. start with the nodes with an in-degree of 0). Then after those nodes have been processed, you\\'re left with just different cyclic components. The cyclic components with length 2 can be combined with other cyclic components of length 2, we can call this sum `joinable`.\\n\\nNow, If a cyclic component\\'s length is greater than 2, then the answer is the maximum of these lengths, we can call this maximum `res`.\\n\\nThe final answer is `max(res, joinable)`.\\nThe code below also has comments to follow along.\\n\\n```C++\\nconst int mxN = 1e5;\\nclass Solution {\\npublic:\\n    int inDeg[mxN];\\n    int ans[mxN];\\n    int sz[mxN];\\n    int un[mxN];\\n    \\n    int find(int a) {\\n        if (un[a] == a) return a;\\n        else return un[a] = find(un[a]);\\n    }\\n    void uni(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        if (sz[x] < sz[y]) swap(x, y);\\n        //x has more, y has less\\n        sz[x] += sz[y];\\n        un[y] = un[x];\\n    }\\n    \\n    int maximumInvitations(vector<int>& adj) {\\n        int N = adj.size();\\n        \\n        for (int i = 0; i < N; ++i) {\\n            sz[i] = 1;\\n            un[i] = i;\\n            ans[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < N; ++i) {\\n            inDeg[adj[i]]++;\\n        }\\n\\t\\t//start of topo sort\\n        queue<int> st;\\n        for (int i = 0; i < N; ++i) {\\n            if (inDeg[i] == 0) {\\n                st.push(i);\\n            }\\n        }\\n        while (!st.empty()) {\\n            int v = st.front(); st.pop();\\n            int c = adj[v];\\n            ans[c] = max(ans[c], ans[v] + 1); //largest possible non-cyclic path up to node \\'c\\'\\n            inDeg[c]--;\\n            if (inDeg[c] == 0) {\\n                st.push(c);\\n            }\\n        }\\n\\t\\t//end of topo sort\\n\\t\\t\\n\\t\\t//figuring out the lengths of the cycles with disjoint structure\\n        for (int i = 0; i < N; ++i) {\\n            if (inDeg[i])\\n                uni(i, adj[i]);\\n        }\\n\\n        int res = 0;\\n        int joinable = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (!inDeg[i]) continue; //we only care about the cyclic components\\n            int len = sz[find(i)]; //length of cycle for current node\\n            if (len == 2) {\\n\\t\\t\\t\\tint neigh = adj[i];\\n                inDeg[neigh]--; //making sure we dont overcount in our \"joinable\" sum by revisiting neighbor\\n                len = ans[i] + ans[neigh]; //answer for cycle of length 2 is the sum of the largest paths up to the 2 nodes\\n                joinable += len;\\n            } else {\\n                //the only answer for a node with cycle of length >= 3 is just the length\\n\\t\\t\\t\\t res = max(res, len);\\n            }\\n        }\\n        \\n        return max(res, joinable);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```C++\\nconst int mxN = 1e5;\\nclass Solution {\\npublic:\\n    int inDeg[mxN];\\n    int ans[mxN];\\n    int sz[mxN];\\n    int un[mxN];\\n    \\n    int find(int a) {\\n        if (un[a] == a) return a;\\n        else return un[a] = find(un[a]);\\n    }\\n    void uni(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        if (sz[x] < sz[y]) swap(x, y);\\n        //x has more, y has less\\n        sz[x] += sz[y];\\n        un[y] = un[x];\\n    }\\n    \\n    int maximumInvitations(vector<int>& adj) {\\n        int N = adj.size();\\n        \\n        for (int i = 0; i < N; ++i) {\\n            sz[i] = 1;\\n            un[i] = i;\\n            ans[i] = 1;\\n        }\\n        \\n        for (int i = 0; i < N; ++i) {\\n            inDeg[adj[i]]++;\\n        }\\n\\t\\t//start of topo sort\\n        queue<int> st;\\n        for (int i = 0; i < N; ++i) {\\n            if (inDeg[i] == 0) {\\n                st.push(i);\\n            }\\n        }\\n        while (!st.empty()) {\\n            int v = st.front(); st.pop();\\n            int c = adj[v];\\n            ans[c] = max(ans[c], ans[v] + 1); //largest possible non-cyclic path up to node \\'c\\'\\n            inDeg[c]--;\\n            if (inDeg[c] == 0) {\\n                st.push(c);\\n            }\\n        }\\n\\t\\t//end of topo sort\\n\\t\\t\\n\\t\\t//figuring out the lengths of the cycles with disjoint structure\\n        for (int i = 0; i < N; ++i) {\\n            if (inDeg[i])\\n                uni(i, adj[i]);\\n        }\\n\\n        int res = 0;\\n        int joinable = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (!inDeg[i]) continue; //we only care about the cyclic components\\n            int len = sz[find(i)]; //length of cycle for current node\\n            if (len == 2) {\\n\\t\\t\\t\\tint neigh = adj[i];\\n                inDeg[neigh]--; //making sure we dont overcount in our \"joinable\" sum by revisiting neighbor\\n                len = ans[i] + ans[neigh]; //answer for cycle of length 2 is the sum of the largest paths up to the 2 nodes\\n                joinable += len;\\n            } else {\\n                //the only answer for a node with cycle of length >= 3 is just the length\\n\\t\\t\\t\\t res = max(res, len);\\n            }\\n        }\\n        \\n        return max(res, joinable);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661147,
                "title": "python-discuss-cycle-size-3-or-size-2-with-visualized-explanation",
                "content": "**Observation:**\\nLet\\'s discuss one of the testcase:\\n`[1,0,3,2,5,6,7,4,9,8,11,10,11,12,10]`\\n\\nIf person `A` likes `B`, we construct an edge of `A -> B`. Then we can construct a graph like below:\\n\\n![](https://i.imgur.com/0V5z2rx.png)\\nWe can find that there are two kinds of cycle:\\n* Cycle with size >= 3 (green cycles)\\n    * If we try to arrange this kind of cycle, we can only arrange a cycle and we are unable to put other employees on the table.\\n    * For example, we can allocate the employees like `[(4, 5, 6, 7)]`\\n* Cycle with size == 2 (red cycles)\\n    * If we try to arrange this kind of cycle, we can put all this kind of cycles on the table.\\n    * For example, we can allocate the employees like `[(0, 1), (2, 3), (8, 9), [13, 12, (11, 10), 14]]`\\n    * Notice that we can also put extended path (look at the blue circle) next to the two endpoints of the 2-cycle\\n\\nLet\\'s discuss another testcase:\\n`[9,14,15,8,22,15,12,11,10,7,1,12,15,6,5,12,10,21,4,1,16,3,7]`\\n\\n![](https://i.imgur.com/hAIqlHR.png)\\n* We can find that there might be several extended path of a 2-cycle, so we should choose the longest one of each endpoint of 2-cycle.\\n* For example, the endpoints of the 2-cycle is `[12, 15]` and we should find the longest extended path of them respectively.\\n    * For employee 12, we can find a longest path which is `[18, 4, 22, 7, 11, 12]`\\n    * For employee 15, we can find a longest path which is `[17, 21, 3, 8, 10, 1, 14, 5, 15]`\\n\\n\\n---\\n**Solution:**\\nSo the solution consists of two parts:\\n* First, find all the cycles in this directed graph.\\n    * Since the out degrees of every vertex is at most `1`, we can use a simpler method to find the cycles: Just walk through the graph from unexplored vertex and stop when we meet the explored point.\\n* Second, the answer may be derived from different cases:\\n    * A single cycle with size >= 3.\\n    * All cycle with sizes == 2, and contains the extended path. We can use BFS to find the longest path of every endpoint of a 2-cycle.\\n\\nMy script:\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        # if a likes b, construct an edge reversely (b -> a) to make following BFS easier\\n        invG = defaultdict(list)\\n        for idx, fav in enumerate(favorite):\\n            invG[fav].append(idx)\\n        \\n        # function for finding the extended path of 2-cycle\\n        def bfs(start, seen):\\n            q = deque([(start, 0)])\\n            ans = 0 \\n            while q:\\n                pos, dist = q.popleft()\\n                for neib in invG[pos]:\\n                    if neib in seen:\\n                        continue\\n                    seen.add(neib)\\n                    q.append((neib, dist+1))\\n                    ans = max(ans, dist + 1)\\n            return ans\\n        \\n        \\n        N = len(favorite)\\n        \\n        # solution derived from a single large cycle & all 2-cycles\\n        ans_large_cycle, ans_2_cycles = 0, 0 \\n        \\n        # finding all cycles\\n        for i in range(N): \\n            if favorite[i] != -1:  # not explored before, do a DFS here\\n                dist = {i: 0}  # record the order of exploration\\n                while favorite[i] != -1:\\n                    nxt = favorite[i]\\n                    favorite[i] = -1\\n                    if nxt in dist:  # detect cycle\\n                        cycle_len = len(dist) - dist[nxt]  # the real cycle length\\n                        \\n                        # update the solution derived from a single large cycle\\n                        ans_large_cycle = max(ans_large_cycle, cycle_len) \\n                        \\n                        # update the solution derived from 2-cycle and its extended path\\n                        if cycle_len == 2: \\n                            # i is the currrent vertex and nxt is the next vertex\\n                            ans_2_cycles += 2 + bfs(nxt, {i, nxt}) + bfs(i, {i, nxt}) \\n                    else:\\n                        i = nxt\\n                        dist[nxt] = len(dist)\\n\\n        return max(ans_large_cycle, ans_2_cycles)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        # if a likes b, construct an edge reversely (b -> a) to make following BFS easier\\n        invG = defaultdict(list)\\n        for idx, fav in enumerate(favorite):\\n            invG[fav].append(idx)\\n        \\n        # function for finding the extended path of 2-cycle\\n        def bfs(start, seen):\\n            q = deque([(start, 0)])\\n            ans = 0 \\n            while q:\\n                pos, dist = q.popleft()\\n                for neib in invG[pos]:\\n                    if neib in seen:\\n                        continue\\n                    seen.add(neib)\\n                    q.append((neib, dist+1))\\n                    ans = max(ans, dist + 1)\\n            return ans\\n        \\n        \\n        N = len(favorite)\\n        \\n        # solution derived from a single large cycle & all 2-cycles\\n        ans_large_cycle, ans_2_cycles = 0, 0 \\n        \\n        # finding all cycles\\n        for i in range(N): \\n            if favorite[i] != -1:  # not explored before, do a DFS here\\n                dist = {i: 0}  # record the order of exploration\\n                while favorite[i] != -1:\\n                    nxt = favorite[i]\\n                    favorite[i] = -1\\n                    if nxt in dist:  # detect cycle\\n                        cycle_len = len(dist) - dist[nxt]  # the real cycle length\\n                        \\n                        # update the solution derived from a single large cycle\\n                        ans_large_cycle = max(ans_large_cycle, cycle_len) \\n                        \\n                        # update the solution derived from 2-cycle and its extended path\\n                        if cycle_len == 2: \\n                            # i is the currrent vertex and nxt is the next vertex\\n                            ans_2_cycles += 2 + bfs(nxt, {i, nxt}) + bfs(i, {i, nxt}) \\n                    else:\\n                        i = nxt\\n                        dist[nxt] = len(dist)\\n\\n        return max(ans_large_cycle, ans_2_cycles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661824,
                "title": "python-simple-step-by-step-explained-o-n-with-only-topological-sort-1100-ms",
                "content": "Based on [@heshan1234](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661394/Java-Short-solution-based-on-topological-sort-which-leaves-just-loops)\\'s solution in Java.\\n# Data structures to preprocess before actual work\\n```\\n# indegree counter, i.e. indegree[i] is the number of people the person \\'i\\' is the favorite of\\nindegree= [0]*n\\n# visited bool array, for topological sort\\nvis = [False]*n \\n# topological sort queue, which contains only elements with effective zero-indegree\\nqueue =  deque([])\\n#  dp[i] is the longest chain(path of person to their favorite) leading to person \\'i\\'\\ndp = [0]*n\\n```\\n\\n# Calculating the indegree of each person\\n```\\n# counting indegree for each person\\nfor person in range(n): \\n\\tfav =favorite[person] \\n\\tindegree[fav]+=1 \\n```\\n# Building up the \\'dp\\' array using topological sort\\ninitializing queue with indegree==0\\n```\\n# visit each person with indegree 0 and add it to the queue to be explored.\\nfor person in range(n):\\n\\tif not indegree[person]:\\n\\t\\tvis[person]=True\\n\\t\\tqueue.append(person)\\n```\\nActual topo-sort\\n```\\n# bfs/dfs based on element elements with 0 indegree \\n# this process is to buildup dp\\nwhile queue:\\n\\tperson = queue.popleft()\\n\\tfav = favorite[person]\\n\\t# update longest chain ending at fav \\n\\tdp[fav]  = max(dp[fav],dp[person]+1)\\n\\t# decrement indegree since we are removing \\'person\\' from incoming edges of \\'fav\\' \\n\\tindegree[fav]-=1\\n\\tif not indegree[fav]:\\n\\t\\tvis[fav]=True\\n\\t\\tqueue.append(fav)\\n```\\n# Core Logic\\nThere are 2 types of cases to handle:-\\n1.  **Type1**, where the loop is of size=2. To handle this:-\\n\\t* Get longest chains ending at each of the 2 elements in the loop . \\n\\t* The current chain acts a bridge between the two chains, \\n\\t* Hence chain size is sum of size of chains ending at both the elements + 2(for the current chain) .\\n\\t* They can combined with other such chains because they are unbounded on 2 sides.\\n2.  **Type2**, where the loop is of size>2. Now this is a normal chain that form a loop, so you can only take the max of loops sizes of type2    \\n**The final answer is max of both the types**.\\n```\\ntype1,type2 = 0,0\\nfor person in range(n):\\n\\tif not vis[person]:\\n\\t\\tcur,length = person,0\\n\\t\\t# keep visiting fav of cur unless a visited element is seen, a sort of dfs with only one neighbor\\n\\t\\twhile not vis[cur]: \\n\\t\\t\\tvis[cur] = True \\n\\t\\t\\tcur = favorite[cur]\\n\\t\\t\\tlength+=1\\n\\t\\tif length==2: \\n\\t\\t\\ttype1+= (dp[person]+dp[favorite[person]]+2) \\n\\t\\telse: \\n\\t\\t\\ttype2= max(type2,length)\\n```        \\n\\n# clean consise combined code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree,vis, queue, dp = [0]*n, [False]*n, deque([]), [0]*n\\n        for person in range(n): indegree[favorite[person]]+=1\\n        for person in range(n):\\n            if not indegree[person]:\\n                vis[person]=True\\n                queue.append(person)\\n        while queue:\\n            person = queue.popleft()\\n            fav = favorite[person]\\n            dp[fav], indegree[fav] = max(dp[fav],dp[person]+1), indegree[fav]-1\\n            if not indegree[fav]:\\n                vis[fav]=True\\n                queue.append(fav)\\n        type1,type2 = 0,0\\n        for person in range(n):\\n            if not vis[person]:\\n                cur,length = person,0\\n                while not vis[cur]: vis[cur], cur, length = True, favorite[cur], length+1\\n                if length==2: type1+= (dp[person]+dp[favorite[person]]+2) \\n                else: type2= max(type2,length)\\n        return max(type1,type2)\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Topological Sort"
                ],
                "code": "```\\n# indegree counter, i.e. indegree[i] is the number of people the person \\'i\\' is the favorite of\\nindegree= [0]*n\\n# visited bool array, for topological sort\\nvis = [False]*n \\n# topological sort queue, which contains only elements with effective zero-indegree\\nqueue =  deque([])\\n#  dp[i] is the longest chain(path of person to their favorite) leading to person \\'i\\'\\ndp = [0]*n\\n```\n```\\n# counting indegree for each person\\nfor person in range(n): \\n\\tfav =favorite[person] \\n\\tindegree[fav]+=1 \\n```\n```\\n# visit each person with indegree 0 and add it to the queue to be explored.\\nfor person in range(n):\\n\\tif not indegree[person]:\\n\\t\\tvis[person]=True\\n\\t\\tqueue.append(person)\\n```\n```\\n# bfs/dfs based on element elements with 0 indegree \\n# this process is to buildup dp\\nwhile queue:\\n\\tperson = queue.popleft()\\n\\tfav = favorite[person]\\n\\t# update longest chain ending at fav \\n\\tdp[fav]  = max(dp[fav],dp[person]+1)\\n\\t# decrement indegree since we are removing \\'person\\' from incoming edges of \\'fav\\' \\n\\tindegree[fav]-=1\\n\\tif not indegree[fav]:\\n\\t\\tvis[fav]=True\\n\\t\\tqueue.append(fav)\\n```\n```\\ntype1,type2 = 0,0\\nfor person in range(n):\\n\\tif not vis[person]:\\n\\t\\tcur,length = person,0\\n\\t\\t# keep visiting fav of cur unless a visited element is seen, a sort of dfs with only one neighbor\\n\\t\\twhile not vis[cur]: \\n\\t\\t\\tvis[cur] = True \\n\\t\\t\\tcur = favorite[cur]\\n\\t\\t\\tlength+=1\\n\\t\\tif length==2: \\n\\t\\t\\ttype1+= (dp[person]+dp[favorite[person]]+2) \\n\\t\\telse: \\n\\t\\t\\ttype2= max(type2,length)\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree,vis, queue, dp = [0]*n, [False]*n, deque([]), [0]*n\\n        for person in range(n): indegree[favorite[person]]+=1\\n        for person in range(n):\\n            if not indegree[person]:\\n                vis[person]=True\\n                queue.append(person)\\n        while queue:\\n            person = queue.popleft()\\n            fav = favorite[person]\\n            dp[fav], indegree[fav] = max(dp[fav],dp[person]+1), indegree[fav]-1\\n            if not indegree[fav]:\\n                vis[fav]=True\\n                queue.append(fav)\\n        type1,type2 = 0,0\\n        for person in range(n):\\n            if not vis[person]:\\n                cur,length = person,0\\n                while not vis[cur]: vis[cur], cur, length = True, favorite[cur], length+1\\n                if length==2: type1+= (dp[person]+dp[favorite[person]]+2) \\n                else: type2= max(type2,length)\\n        return max(type1,type2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360864,
                "title": "c-easy-understanding-topo-strongly-connected-components-tarjan-s-and-kahn-s-algorithm",
                "content": "Let\\'s analyse few cases and then conclude the solution\\n\\n\\n![image](https://assets.leetcode.com/users/images/8d095e13-ed4c-4266-9399-c2ab4e89fc50_1659284255.3232708.png)\\n\\n\\n For the above graph answer will be 4 (the cycle having largest length)\\n\\nBut lets analyse few more cases where cycle is 2\\n\\n![image](https://assets.leetcode.com/users/images/99682677-327d-4756-83fa-4022d0e21ebb_1659284536.8107343.png)\\n\\n\\n\\nIn above diagram we have largest cycle of 4 but that is not the answer\\nanswer is 6(see below)\\n\\n**answer is maximum of**\\nlet u,v form 2 length cycle then \\n1.maximum length cycle\\n2. distance(u to leaf without covering any cycle) + distance(v to leaf without covering any cycle)\\n![image](https://assets.leetcode.com/users/images/aec43965-c774-40f2-9964-cefa8882cfde_1659284635.1982217.png)\\n\\n\\n**So, this is the case we need to look, whenever there is cycle of length 2 we have to recalculate the answer**\\n\\nSo what should be the answer whenever there is a graph having cycle of length 2 \\n1. Lets suppose u->v and v->u is the 2 length cycle\\n2. umax = maximum distance between u and leaf without covering any cycle\\n3. vmax = maximum distance between v and leaf without covering any cycle\\n4. For all 2 cycle nodes\\n\\t1. sum+=umax+vmax\\n\\nFinal answer should be the maximum of sum and  maximumLength Cycle in the graph\\n\\n\\n\\nAlgorithm - \\n1. Use Tarjans algorithm to find strongly connected components\\n2. Store the maximum length cycle\\n3. if there is any cycle of length 2 we store both nodes in an array\\n4. we see if there is no 2 length cycle we return maximum length cycle\\n5. if there is 2 length cycle then\\n\\t1. Lets suppose u->v and v->u is the 2 length cycle\\n\\t2. umax = maximum distance between u and leaf without covering any cycle\\n\\t3. vmax = maximum distance between v and leaf without covering any cycle\\n\\t4. For all 2 cycle nodes\\n\\t\\t1. sum+=umax+vmax\\n6. return maximum of sum and  maximumLength Cycle in the grap\\n\\n```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    stack<int> st;\\n    vector<bool> isMemberOfStack;\\n    vector<int> time;\\n    vector<int> low;\\n    int curr_time = 1;\\n    int ans;\\n    bool isThereACycleOfLength2;\\n    vector<vector<int>> cyclesOfLength2;\\npublic:\\n    \\n    void dfs(int u, int parent){\\n        time[u] = curr_time;\\n        low[u] = curr_time;\\n        curr_time += 1;\\n        st.push(u);\\n        isMemberOfStack[u] = 1;\\n        \\n        for(int adj : graph[u]){\\n            if(time[adj] == 0){  // node is not visited\\n                dfs(adj, u);\\n                low[u] = min(low[u], low[adj]);\\n            }\\n            if(isMemberOfStack[adj] == 1){\\n                low[u] = min(low[u], time[adj]);\\n            }\\n        }\\n         \\n        if(time[u] == low[u]){\\n            int count = 0;\\n            while(st.top() != u){\\n                int v = st.top();\\n                st.pop();\\n                isMemberOfStack[v] = 0;\\n                count += 1;\\n                // cout<<v<<\" \";\\n            }\\n            st.pop();\\n            isMemberOfStack[u] = 0;\\n            count += 1;\\n            // cout<<u<<endl;\\n            \\n            ans = max(ans , count);\\n            \\n            if(count == 2){\\n                isThereACycleOfLength2 = true;\\n                vector<int> temp(2,0);\\n                temp[0] = u;\\n                temp[1] = graph[u][0];\\n              \\n                cyclesOfLength2.push_back(temp);\\n            }\\n        }\\n    }\\n    \\n    \\n    void prepareMaximumLengthsWithoutCycles(vector<int> &maxLen, vector<int> indegree){\\n        queue<int> q;\\n        int n = maxLen.size();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(int v : graph[u]){\\n                maxLen[v] = max(maxLen[v], 1+ maxLen[u]);\\n                indegree[v] -= 1;\\n                if(indegree[v] == 0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n    \\n    }\\n    \\n\\n    int maximumInvitations(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        graph.resize(n);\\n        time.resize(n);\\n        low.resize(n);\\n        isMemberOfStack.resize(n);\\n        isThereACycleOfLength2 = false;\\n        vector<int> indegree(n , 0);\\n        for(int i = 0 ; i < n ; i++){\\n            \\n            graph[i].push_back(edges[i]);\\n            isMemberOfStack[i] = 0;\\n            time[i] = 0;\\n            low[i] = 0;\\n            indegree[edges[i]] += 1;\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(time[i] == 0){\\n                dfs(i, -1);\\n            }\\n        }\\n        \\n        if(ans == 1){\\n            return -1;\\n        }\\n        \\n        // if we don\\'t have a cycle of length 2\\n        if(isThereACycleOfLength2 == false){\\n            return ans;\\n        }\\n        \\n        \\n        // if we have cycles of length 2\\n        \\n        vector<int> maxLen(n, 1);\\n        prepareMaximumLengthsWithoutCycles(maxLen, indegree);\\n        \\n        \\n        \\n        int twonodecyclegraphsanswers = 0;\\n        for(vector<int> p : cyclesOfLength2 ){\\n            twonodecyclegraphsanswers += maxLen[p[0]] + maxLen[p[1]] ; \\n            ans = max(ans,twonodecyclegraphsanswers );\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```\\n\\nTime Complexity - O(N+E)\\nSpace Complexity - O(N)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    stack<int> st;\\n    vector<bool> isMemberOfStack;\\n    vector<int> time;\\n    vector<int> low;\\n    int curr_time = 1;\\n    int ans;\\n    bool isThereACycleOfLength2;\\n    vector<vector<int>> cyclesOfLength2;\\npublic:\\n    \\n    void dfs(int u, int parent){\\n        time[u] = curr_time;\\n        low[u] = curr_time;\\n        curr_time += 1;\\n        st.push(u);\\n        isMemberOfStack[u] = 1;\\n        \\n        for(int adj : graph[u]){\\n            if(time[adj] == 0){  // node is not visited\\n                dfs(adj, u);\\n                low[u] = min(low[u], low[adj]);\\n            }\\n            if(isMemberOfStack[adj] == 1){\\n                low[u] = min(low[u], time[adj]);\\n            }\\n        }\\n         \\n        if(time[u] == low[u]){\\n            int count = 0;\\n            while(st.top() != u){\\n                int v = st.top();\\n                st.pop();\\n                isMemberOfStack[v] = 0;\\n                count += 1;\\n                // cout<<v<<\" \";\\n            }\\n            st.pop();\\n            isMemberOfStack[u] = 0;\\n            count += 1;\\n            // cout<<u<<endl;\\n            \\n            ans = max(ans , count);\\n            \\n            if(count == 2){\\n                isThereACycleOfLength2 = true;\\n                vector<int> temp(2,0);\\n                temp[0] = u;\\n                temp[1] = graph[u][0];\\n              \\n                cyclesOfLength2.push_back(temp);\\n            }\\n        }\\n    }\\n    \\n    \\n    void prepareMaximumLengthsWithoutCycles(vector<int> &maxLen, vector<int> indegree){\\n        queue<int> q;\\n        int n = maxLen.size();\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(q.empty() == false){\\n            int u = q.front();\\n            q.pop();\\n            \\n            for(int v : graph[u]){\\n                maxLen[v] = max(maxLen[v], 1+ maxLen[u]);\\n                indegree[v] -= 1;\\n                if(indegree[v] == 0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n    \\n    }\\n    \\n\\n    int maximumInvitations(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        graph.resize(n);\\n        time.resize(n);\\n        low.resize(n);\\n        isMemberOfStack.resize(n);\\n        isThereACycleOfLength2 = false;\\n        vector<int> indegree(n , 0);\\n        for(int i = 0 ; i < n ; i++){\\n            \\n            graph[i].push_back(edges[i]);\\n            isMemberOfStack[i] = 0;\\n            time[i] = 0;\\n            low[i] = 0;\\n            indegree[edges[i]] += 1;\\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            if(time[i] == 0){\\n                dfs(i, -1);\\n            }\\n        }\\n        \\n        if(ans == 1){\\n            return -1;\\n        }\\n        \\n        // if we don\\'t have a cycle of length 2\\n        if(isThereACycleOfLength2 == false){\\n            return ans;\\n        }\\n        \\n        \\n        // if we have cycles of length 2\\n        \\n        vector<int> maxLen(n, 1);\\n        prepareMaximumLengthsWithoutCycles(maxLen, indegree);\\n        \\n        \\n        \\n        int twonodecyclegraphsanswers = 0;\\n        for(vector<int> p : cyclesOfLength2 ){\\n            twonodecyclegraphsanswers += maxLen[p[0]] + maxLen[p[1]] ; \\n            ans = max(ans,twonodecyclegraphsanswers );\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1663628,
                "title": "python-o-n-cycle-detection-and-dfs-bfs-image-explanation-step-by-step",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* We first construct a directed graph, the vertices are employees, if a favorite b then a directed edge points from a to b\\n* Through union find set, we divide the graph into several disconnected islands. It can be proved that each island has one and only one cycle. Moreover since there is one and only one cycle on every island, we can also find out the cycle directly without UnionFind, and the nodes connected to eacy cycle forms an island.\\n\\t* If the circle is greater than 2, employees in this circle can only sit at a table alone.\\n\\t* If the circle is equal to 2, the two employees in the circle favor each other, and a favorite chain can be gathered on their left and right sides to form a free sequence.\\n\\t\\t* Note that all free sequences can be concated and sit at a table together.\\n\\t\\n![image](https://assets.leetcode.com/users/images/935bf057-38ab-442e-b2b0-5f631bd56216_1641187850.9439714.png)\\n* Now I explain the detail step by step with the help of the examples in the figure.\\n\\t* we can easily find out that there are 3 islands in the graph via union find set and denoted by A B C respectively.\\n\\t* for each island we find out the only cycle on it, for example A has the cycle (A1, A2, A3, A4) and B has the cycle (B1, B2). since there is one and only one cycle on every island, we can also find out the cycle directly without UnionFind. \\n\\t* If we invite anyone in (A1, A2, A3, A4), we must invite them all and we cannot invite any other one on or not on island A. Actually employees on island A but not belong to the cycle cannot be invited forever.\\n\\t* However on island B, it is much more different. (B1, B2) is the cycle and they faver eacy other, and  B3 who favors B1 can sit on the other side of B2 without conflict. (B3, B1, B2) form a free sequence.\\n\\t* The situation on Island C is similar to Island B. After selecting C1 and C2 on the circle, we can further invite the longest favorite chain on both sides of them to form the longest free sequence on the island together with C1 and C2, that is (C3, C4, C6, C7, C1, C2, C11, C12)\\n\\t* Finally we concat all the free sequences because they can sit together without confilit. that is (B3, B1, B2, C3, C4, C6, C7, C1, C2, C11, C12)\\n\\t* The answer is the maximum of the longest single cycle and the concated free sequences.\\n\\t\\t* the longest single cycle\\n\\t\\t\\t* (A1, A2, A3, A4)\\n\\t\\t* the concated free sequences\\n\\t\\t\\t* (B3, B1, B2, C3, C4, C6, C7, C1, C2, C11, C12)\\n\\n```\\nTime  Complexity: O(N) for each node would be visited only once, we use a set named seen to avoid repeat.\\nSpace Complexity: O(N)\\n```\\n\\n**Python Without Union Find**\\n```\\nclass Solution(object):\\n    def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        for i, j in enumerate(favorite):\\n            pre[j].append(i)\\n\\n        seen, max_cycle_length, sequence_length = set(), 0, 0\\n\\n        for node in range(len(favorite)):  # for each island, there is one and only one cycle\\n            # find the cycle and its length\\n            if node in seen: continue\\n            path = [node]\\n            while favorite[path[-1]] not in seen:\\n                seen.add(favorite[path[-1]])\\n                path.append(favorite[path[-1]])\\n            if favorite[path[-1]] not in path: continue\\n            cycle_length = len(path) - path.index(favorite[path[-1]])\\n\\n            if cycle_length == 2:  # cycle can concat with other sequential nodes on the island at both left and right\\n                # via dfs or bfs through pre, we can find out the longest sequence left and right of the cycle\\n                # finally we concat the left longest sequence and the cycle itself and the right longest sequence as\\n                # the longest valid sequence of the island.\\n                max_sub_len = [0, 0]\\n                cycle = path[-2:]\\n                pre[cycle[0]].remove(cycle[1])\\n                pre[cycle[1]].remove(cycle[0])\\n                for k in [0, 1]:  # the left and right of the cycle as the start point of dfs respectively\\n                    dq = collections.deque([(cycle[k], 0)])\\n                    while dq:\\n                        i, depth = dq.pop()  # DFS\\n                        # i, depth = dq.popleft()  # BFS\\n                        if i in pre:\\n                            for j in pre[i]:\\n                                dq.append((j, depth + 1))\\n                                seen.add(j)\\n                        else:\\n                            max_sub_len[k] = max(max_sub_len[k], depth)  # get the length of longest sequence\\n                # 2 is the length of cycle, max_sub_len are lengths of longest sequence of both left and right ends\\n                sequence_length += 2 + sum(max_sub_len)\\n            else:  # greater than 2, the cycle can\\'t concat with any other node\\n                max_cycle_length = max(max_cycle_length, cycle_length)\\n\\n        # either a big cycle or some free sequences will be the final answer\\n        return max(max_cycle_length, sequence_length)\\n```\\n\\n**Python With Union Find**\\n```\\nclass UnionFind(object):  # standard union find set class\\n    def __init__(self, n):\\n        self.parent = range(n)\\n        self.level = [0] * n\\n\\n    def find(self, i):\\n        while self.parent[i] != i:\\n            i = self.parent[i]\\n        return i\\n\\n    def union(self, i, j):\\n        i = self.find(i)\\n        j = self.find(j)\\n        if self.level[i] < self.level[j]:\\n            self.parent[i] = j\\n        elif self.level[j] < self.level[i]:\\n            self.parent[j] = i\\n        else:\\n            self.parent[j] = i\\n            self.level[i] += 1\\n\\n\\nclass Solution(object):\\n    def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        uf = UnionFind(len(favorite))\\n        for i, j in enumerate(favorite):\\n            uf.union(i, j)\\n            pre[j].append(i)\\n        islands = collections.defaultdict(list)\\n        for i in range(len(favorite)):\\n            islands[uf.find(i)].append(i)\\n\\n        max_cycle_length = 0\\n        sequence_length = 0\\n\\n        for nodes in islands.values():  # for each island, there is one and only one cycle\\n            # find the cycle and its length\\n            path = [nodes[0]]\\n            path_set = set([nodes[0]])\\n            while favorite[path[-1]] not in path_set:\\n                path_set.add(favorite[path[-1]])\\n                path.append(favorite[path[-1]])\\n            cycle_length = len(path) - path.index(favorite[path[-1]])\\n\\n            if cycle_length == 2:  # cycle can concat with other sequential nodes on the island at both left and right\\n                # via dfs or bfs through pre, we can find out the longest sequence left and right of the cycle\\n                # finally we concat the left longest sequence and the cycle itself and the right longest sequence as\\n                # the longest valid sequence of the island.\\n                max_sub_len = [0, 0]\\n                cycle = path[-2:]\\n                pre[cycle[0]].remove(cycle[1])\\n                pre[cycle[1]].remove(cycle[0])\\n                for k in [0, 1]:  # the left and right of the cycle as the start point of dfs respectively\\n                    dq = collections.deque([(cycle[k], 0)])\\n                    while dq:\\n                        i, depth = dq.pop()  # DFS\\n                        # i, depth = dq.popleft()  # BFS\\n                        if i in pre:\\n                            for j in pre[i]:\\n                                dq.append((j, depth + 1))\\n                        else:\\n                            max_sub_len[k] = max(max_sub_len[k], depth)  # get the length of longest sequence\\n                # 2 is the length of cycle, max_sub_len are lengths of longest sequence of both left and right ends\\n                sequence_length += 2 + sum(max_sub_len)\\n            else:  # greater than 2, the cycle can\\'t concat with any other node\\n                max_cycle_length = max(max_cycle_length, cycle_length)\\n\\n        # either a big cycle or some free sequences will be the final answer\\n        return max(max_cycle_length, sequence_length)\\n```\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nTime  Complexity: O(N) for each node would be visited only once, we use a set named seen to avoid repeat.\\nSpace Complexity: O(N)\\n```\n```\\nclass Solution(object):\\n    def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        for i, j in enumerate(favorite):\\n            pre[j].append(i)\\n\\n        seen, max_cycle_length, sequence_length = set(), 0, 0\\n\\n        for node in range(len(favorite)):  # for each island, there is one and only one cycle\\n            # find the cycle and its length\\n            if node in seen: continue\\n            path = [node]\\n            while favorite[path[-1]] not in seen:\\n                seen.add(favorite[path[-1]])\\n                path.append(favorite[path[-1]])\\n            if favorite[path[-1]] not in path: continue\\n            cycle_length = len(path) - path.index(favorite[path[-1]])\\n\\n            if cycle_length == 2:  # cycle can concat with other sequential nodes on the island at both left and right\\n                # via dfs or bfs through pre, we can find out the longest sequence left and right of the cycle\\n                # finally we concat the left longest sequence and the cycle itself and the right longest sequence as\\n                # the longest valid sequence of the island.\\n                max_sub_len = [0, 0]\\n                cycle = path[-2:]\\n                pre[cycle[0]].remove(cycle[1])\\n                pre[cycle[1]].remove(cycle[0])\\n                for k in [0, 1]:  # the left and right of the cycle as the start point of dfs respectively\\n                    dq = collections.deque([(cycle[k], 0)])\\n                    while dq:\\n                        i, depth = dq.pop()  # DFS\\n                        # i, depth = dq.popleft()  # BFS\\n                        if i in pre:\\n                            for j in pre[i]:\\n                                dq.append((j, depth + 1))\\n                                seen.add(j)\\n                        else:\\n                            max_sub_len[k] = max(max_sub_len[k], depth)  # get the length of longest sequence\\n                # 2 is the length of cycle, max_sub_len are lengths of longest sequence of both left and right ends\\n                sequence_length += 2 + sum(max_sub_len)\\n            else:  # greater than 2, the cycle can\\'t concat with any other node\\n                max_cycle_length = max(max_cycle_length, cycle_length)\\n\\n        # either a big cycle or some free sequences will be the final answer\\n        return max(max_cycle_length, sequence_length)\\n```\n```\\nclass UnionFind(object):  # standard union find set class\\n    def __init__(self, n):\\n        self.parent = range(n)\\n        self.level = [0] * n\\n\\n    def find(self, i):\\n        while self.parent[i] != i:\\n            i = self.parent[i]\\n        return i\\n\\n    def union(self, i, j):\\n        i = self.find(i)\\n        j = self.find(j)\\n        if self.level[i] < self.level[j]:\\n            self.parent[i] = j\\n        elif self.level[j] < self.level[i]:\\n            self.parent[j] = i\\n        else:\\n            self.parent[j] = i\\n            self.level[i] += 1\\n\\n\\nclass Solution(object):\\n    def maximumInvitations(self, favorite):\\n        pre = collections.defaultdict(list)\\n        uf = UnionFind(len(favorite))\\n        for i, j in enumerate(favorite):\\n            uf.union(i, j)\\n            pre[j].append(i)\\n        islands = collections.defaultdict(list)\\n        for i in range(len(favorite)):\\n            islands[uf.find(i)].append(i)\\n\\n        max_cycle_length = 0\\n        sequence_length = 0\\n\\n        for nodes in islands.values():  # for each island, there is one and only one cycle\\n            # find the cycle and its length\\n            path = [nodes[0]]\\n            path_set = set([nodes[0]])\\n            while favorite[path[-1]] not in path_set:\\n                path_set.add(favorite[path[-1]])\\n                path.append(favorite[path[-1]])\\n            cycle_length = len(path) - path.index(favorite[path[-1]])\\n\\n            if cycle_length == 2:  # cycle can concat with other sequential nodes on the island at both left and right\\n                # via dfs or bfs through pre, we can find out the longest sequence left and right of the cycle\\n                # finally we concat the left longest sequence and the cycle itself and the right longest sequence as\\n                # the longest valid sequence of the island.\\n                max_sub_len = [0, 0]\\n                cycle = path[-2:]\\n                pre[cycle[0]].remove(cycle[1])\\n                pre[cycle[1]].remove(cycle[0])\\n                for k in [0, 1]:  # the left and right of the cycle as the start point of dfs respectively\\n                    dq = collections.deque([(cycle[k], 0)])\\n                    while dq:\\n                        i, depth = dq.pop()  # DFS\\n                        # i, depth = dq.popleft()  # BFS\\n                        if i in pre:\\n                            for j in pre[i]:\\n                                dq.append((j, depth + 1))\\n                        else:\\n                            max_sub_len[k] = max(max_sub_len[k], depth)  # get the length of longest sequence\\n                # 2 is the length of cycle, max_sub_len are lengths of longest sequence of both left and right ends\\n                sequence_length += 2 + sum(max_sub_len)\\n            else:  # greater than 2, the cycle can\\'t concat with any other node\\n                max_cycle_length = max(max_cycle_length, cycle_length)\\n\\n        # either a big cycle or some free sequences will be the final answer\\n        return max(max_cycle_length, sequence_length)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661234,
                "title": "java-clean-not-really",
                "content": "1. we need to contruct graph from the giving relationship\\n2. we need to measure cycle size, max single cycle size and size2 cycle candidates.\\n3. max single size cycle can be a answer itself, eliminate all the rest path to this cycle.\\n4. size = 2 cycle can all sit together, so we can brute forcely extend from size=2 cycle, remember to add them all\\n5. retun res = Math.max(single size cycle, sum(size=2 cycle with extention)\\n\\n\\n```\\n class Solution {\\n    int N;\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    int singleMaxCycleSize = 0;\\n    List<List<Integer>> pairs = new ArrayList<>();\\n    int[] favorite;\\n    public int maximumInvitations(int[] favorite) {\\n        this.favorite = favorite;\\n        N = favorite.length;\\n        //1. construct the graph by relationship\\n        for (int i = 0; i < favorite.length; i++) {\\n            int pre = favorite[i];\\n            int cur = i;\\n            graph.putIfAbsent(pre, new ArrayList<>());\\n            graph.get(pre).add(cur);\\n        }\\n        //2. count the cycle size\\n        countCycle();\\n        return Math.max(singleMaxCycleSize, countSizeTwoExtra());\\n    }\\n    \\n    //this method is for extend from size2 cycle, we can only extend one path from\\n    //one of the two node, if they can both extend, we add all, or we can only extend one side\\n    Map<Integer, Integer> max = new HashMap<>();\\n    private int countSizeTwoExtra() {\\n        boolean[] visited = new boolean[N];\\n        int res = 0;\\n        for (List<Integer> pair : pairs) {\\n            int a = pair.get(0);\\n            int b = pair.get(1);\\n            max.put(a, 0);\\n            max.put(b, 0);\\n            \\n            visited[a] = true;\\n            dfs(b, visited, 0, b);\\n            visited[a] = false;\\n            \\n            visited[b] = true;\\n            dfs(a, visited, 0, a);\\n            visited[b] = false;\\n            \\n            if (max.get(a) > 0 && max.get(b) > 0) res += (max.get(a) + max.get(b));\\n            else if (max.get(a) > max.get(b)) res += max.get(a);\\n            else res += max.get(b);\\n            res += 2;\\n        }\\n        return res;\\n    }\\n    \\n    //this method is for checking if we can extend from one node (not go back to its pair)\\n    private void dfs(int cur, boolean[] visited, int len, int start) {\\n        if (visited[cur]) return;\\n        max.put(start, Math.max(max.get(start), len));\\n        visited[cur] = true;\\n        for (int nei : graph.getOrDefault(cur, new ArrayList<>()))\\n            if (!visited[nei])\\n               dfs(nei, visited, len + 1, start);\\n        visited[cur] = false;\\n    }\\n    \\n    //this method if for count maxSize cycle, and also store all possible size=2 cycle\\n    private void countCycle() {\\n        boolean[] visited = new boolean[N];\\n        boolean[] recStack = new boolean[N];\\n        for (int i = 0; i < N; i++)\\n            isCyclicUtil(i, visited, recStack, 0);\\n    }\\n    private void isCyclicUtil(int i, boolean[] visited, boolean[] recStack, int count) {\\n        if (recStack[i]) {\\n            singleMaxCycleSize = Math.max(singleMaxCycleSize, count);\\n            if (count == 2) pairs.add(List.of(i, favorite[i]));\\n            return;\\n        }\\n        if (visited[i]) return;\\n        visited[i] = true;\\n        recStack[i] = true;\\n        List<Integer> children = graph.getOrDefault(i, new ArrayList<>());\\n        for (Integer c: children)\\n            isCyclicUtil(c, visited, recStack, count + 1);\\n        recStack[i] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    int N;\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    int singleMaxCycleSize = 0;\\n    List<List<Integer>> pairs = new ArrayList<>();\\n    int[] favorite;\\n    public int maximumInvitations(int[] favorite) {\\n        this.favorite = favorite;\\n        N = favorite.length;\\n        //1. construct the graph by relationship\\n        for (int i = 0; i < favorite.length; i++) {\\n            int pre = favorite[i];\\n            int cur = i;\\n            graph.putIfAbsent(pre, new ArrayList<>());\\n            graph.get(pre).add(cur);\\n        }\\n        //2. count the cycle size\\n        countCycle();\\n        return Math.max(singleMaxCycleSize, countSizeTwoExtra());\\n    }\\n    \\n    //this method is for extend from size2 cycle, we can only extend one path from\\n    //one of the two node, if they can both extend, we add all, or we can only extend one side\\n    Map<Integer, Integer> max = new HashMap<>();\\n    private int countSizeTwoExtra() {\\n        boolean[] visited = new boolean[N];\\n        int res = 0;\\n        for (List<Integer> pair : pairs) {\\n            int a = pair.get(0);\\n            int b = pair.get(1);\\n            max.put(a, 0);\\n            max.put(b, 0);\\n            \\n            visited[a] = true;\\n            dfs(b, visited, 0, b);\\n            visited[a] = false;\\n            \\n            visited[b] = true;\\n            dfs(a, visited, 0, a);\\n            visited[b] = false;\\n            \\n            if (max.get(a) > 0 && max.get(b) > 0) res += (max.get(a) + max.get(b));\\n            else if (max.get(a) > max.get(b)) res += max.get(a);\\n            else res += max.get(b);\\n            res += 2;\\n        }\\n        return res;\\n    }\\n    \\n    //this method is for checking if we can extend from one node (not go back to its pair)\\n    private void dfs(int cur, boolean[] visited, int len, int start) {\\n        if (visited[cur]) return;\\n        max.put(start, Math.max(max.get(start), len));\\n        visited[cur] = true;\\n        for (int nei : graph.getOrDefault(cur, new ArrayList<>()))\\n            if (!visited[nei])\\n               dfs(nei, visited, len + 1, start);\\n        visited[cur] = false;\\n    }\\n    \\n    //this method if for count maxSize cycle, and also store all possible size=2 cycle\\n    private void countCycle() {\\n        boolean[] visited = new boolean[N];\\n        boolean[] recStack = new boolean[N];\\n        for (int i = 0; i < N; i++)\\n            isCyclicUtil(i, visited, recStack, 0);\\n    }\\n    private void isCyclicUtil(int i, boolean[] visited, boolean[] recStack, int count) {\\n        if (recStack[i]) {\\n            singleMaxCycleSize = Math.max(singleMaxCycleSize, count);\\n            if (count == 2) pairs.add(List.of(i, favorite[i]));\\n            return;\\n        }\\n        if (visited[i]) return;\\n        visited[i] = true;\\n        recStack[i] = true;\\n        List<Integer> children = graph.getOrDefault(i, new ArrayList<>());\\n        for (Integer c: children)\\n            isCyclicUtil(c, visited, recStack, count + 1);\\n        recStack[i] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661184,
                "title": "c-python-solution-max-length-of-cycle-and-max-depth-of-back-edge-graph",
                "content": "This problem can be separated to two problems.\\nProblem 1 : Get maximum length of cycle of the graph.\\nProblem 2 : Make back edge graph. Get sum of max depth of the trees which the root node is the node that i == favorite[favorite[i]]. \\nFinal answer is max value of problem1\\'s answer and problem2\\'s answer.\\n\\nc++ code :\\n```c++\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& A) {\\n        int ret = 0, n = A.size();\\n        vector<vector<int>> bg(n);\\n        for(auto i = 0; i < n; ++i) bg[A[i]].push_back(i);\\n        vector<bool> visited(n), inpath(n);\\n        vector<int> time(n);\\n        auto ct = 1;\\n        function<void(int)> dfs = [&](auto cur) {\\n            visited[cur] = inpath[cur] = true, time[cur] = ct++;\\n            auto nxt = A[cur];\\n            if(!visited[nxt]) dfs(nxt);\\n            if(inpath[nxt]) ret = max(ret, time[cur] - time[nxt] + 1);\\n            inpath[cur] = false;\\n        };\\n        for(auto i = 0; i < n; ++i) if(!visited[i]) dfs(i);\\n        function<int(int)> dfs2 = [&](auto cur) {\\n            int ret = 1;\\n            for(auto nxt : bg[cur]) if(nxt != A[cur]) ret = max(ret, dfs2(nxt) + 1);\\n            return ret;\\n        };\\n        int ret2 = 0;\\n        for(auto i = 0; i < n; ++i) if(i == A[A[i]] && i < A[i]) ret2 += dfs2(i) + dfs2(A[i]);\\n        return max(ret, ret2);\\n    }\\n};\\n```\\n\\npython code :\\n```python\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        visited_time = [0] * n\\n        inpath = [False] * n\\n        cur_time = 1\\n        def get_max_len_cycle(cur) :\\n            nonlocal cur_time\\n            inpath[cur], visited_time[cur], nxt = True, cur_time, favorite[cur]\\n            cur_time += 1\\n            ret = 0 if not inpath[nxt] else visited_time[cur] - visited_time[nxt] + 1\\n            if visited_time[nxt] == 0 : ret = max(ret, get_max_len_cycle(nxt))\\n            inpath[cur] = False\\n            return ret\\n        \\n        ret_cycle = 0\\n        for i in range(n) :\\n            if visited_time[i] == 0 :\\n                ret_cycle = max(ret_cycle, get_max_len_cycle(i))\\n        \\n        ret_not_cycle = 0\\n        back_edge_graph = [[] for _ in range(n)]\\n        for i in range(n) : back_edge_graph[favorite[i]].append(i)\\n        def get_max_depth(cur) :\\n            ret = 0\\n            for nxt in back_edge_graph[cur] :\\n                if favorite[cur] != nxt :\\n                    ret = max(ret, get_max_depth(nxt) + 1)\\n            return ret\\n        \\n        for i in range(n) :\\n            if favorite[favorite[i]] == i : ret_not_cycle += get_max_depth(i) + 1\\n        \\n        ret = max(ret_cycle, ret_not_cycle)\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Graph"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& A) {\\n        int ret = 0, n = A.size();\\n        vector<vector<int>> bg(n);\\n        for(auto i = 0; i < n; ++i) bg[A[i]].push_back(i);\\n        vector<bool> visited(n), inpath(n);\\n        vector<int> time(n);\\n        auto ct = 1;\\n        function<void(int)> dfs = [&](auto cur) {\\n            visited[cur] = inpath[cur] = true, time[cur] = ct++;\\n            auto nxt = A[cur];\\n            if(!visited[nxt]) dfs(nxt);\\n            if(inpath[nxt]) ret = max(ret, time[cur] - time[nxt] + 1);\\n            inpath[cur] = false;\\n        };\\n        for(auto i = 0; i < n; ++i) if(!visited[i]) dfs(i);\\n        function<int(int)> dfs2 = [&](auto cur) {\\n            int ret = 1;\\n            for(auto nxt : bg[cur]) if(nxt != A[cur]) ret = max(ret, dfs2(nxt) + 1);\\n            return ret;\\n        };\\n        int ret2 = 0;\\n        for(auto i = 0; i < n; ++i) if(i == A[A[i]] && i < A[i]) ret2 += dfs2(i) + dfs2(A[i]);\\n        return max(ret, ret2);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        visited_time = [0] * n\\n        inpath = [False] * n\\n        cur_time = 1\\n        def get_max_len_cycle(cur) :\\n            nonlocal cur_time\\n            inpath[cur], visited_time[cur], nxt = True, cur_time, favorite[cur]\\n            cur_time += 1\\n            ret = 0 if not inpath[nxt] else visited_time[cur] - visited_time[nxt] + 1\\n            if visited_time[nxt] == 0 : ret = max(ret, get_max_len_cycle(nxt))\\n            inpath[cur] = False\\n            return ret\\n        \\n        ret_cycle = 0\\n        for i in range(n) :\\n            if visited_time[i] == 0 :\\n                ret_cycle = max(ret_cycle, get_max_len_cycle(i))\\n        \\n        ret_not_cycle = 0\\n        back_edge_graph = [[] for _ in range(n)]\\n        for i in range(n) : back_edge_graph[favorite[i]].append(i)\\n        def get_max_depth(cur) :\\n            ret = 0\\n            for nxt in back_edge_graph[cur] :\\n                if favorite[cur] != nxt :\\n                    ret = max(ret, get_max_depth(nxt) + 1)\\n            return ret\\n        \\n        for i in range(n) :\\n            if favorite[favorite[i]] == i : ret_not_cycle += get_max_depth(i) + 1\\n        \\n        ret = max(ret_cycle, ret_not_cycle)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661085,
                "title": "find-cycles-dfs-when-size-2-java",
                "content": "we need to do another dfs when we have a component of size 2 to find the max length to extend it in either direction.\\nanswer is sum of all those size 2 with extensions or largest cycle\\n```\\nclass Solution {\\n    Stack<Integer> st;\\n    List<Integer>[] graph;\\n    List<Integer>[] revGraph;\\n    public int maximumInvitations(int[] favorite) {\\n        //find cycles\\n        int n = favorite.length;\\n        graph = new List[n];\\n        for (int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int i=0; i<n; i++) {\\n            graph[i].add(favorite[i]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        st = new Stack<>();\\n        for (int i=0; i<n; i++) {\\n            if (!visited[i]) {\\n                dfs1(visited, i);\\n            }\\n        }\\n        revGraph = new List[n];\\n        for (int i=0; i<n; i++) {\\n            revGraph[i] = new ArrayList<>();\\n        }\\n        for (int i=0; i<n; i++) {\\n            revGraph[favorite[i]].add(i);\\n        }\\n        visited = new boolean[n];\\n        int twoGroups = 0;\\n        int biggest = 0;\\n        while (!st.isEmpty()) {\\n            int p = st.pop();\\n            if (!visited[p]) {\\n                List<Integer> vis = new ArrayList<>();\\n                dfs2(visited, p, vis);\\n                if (vis.size()==2) {\\n                    twoGroups += dfs3(vis.get(0), vis.get(1));\\n                    twoGroups += dfs3(vis.get(1), vis.get(0));\\n                }\\n                biggest = Math.max(biggest, vis.size());\\n            }\\n        }\\n        return Math.max(twoGroups, biggest);\\n    }\\n    public int dfs3(int cur, int noGo) {\\n        int len = 0;\\n        for (int next:revGraph[cur]) {\\n            if (next != noGo) {\\n                len = Math.max(len, dfs3(next, cur));\\n            }\\n        }\\n        return len+1;\\n    }\\n    public void dfs2(boolean[] visited, int cur, List<Integer> vis) {\\n        visited[cur] = true;\\n        vis.add(cur);\\n        for (int next:revGraph[cur]) {\\n            if (!visited[next]) {\\n                dfs2(visited, next, vis);\\n            }\\n        }\\n    }\\n    public void dfs1(boolean[] visited, int cur) {\\n        visited[cur] = true;\\n        for (int next:graph[cur]) {\\n            if (!visited[next])\\n                dfs1(visited, next);\\n        }\\n        st.push(cur);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Stack<Integer> st;\\n    List<Integer>[] graph;\\n    List<Integer>[] revGraph;\\n    public int maximumInvitations(int[] favorite) {\\n        //find cycles\\n        int n = favorite.length;\\n        graph = new List[n];\\n        for (int i=0; i<n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int i=0; i<n; i++) {\\n            graph[i].add(favorite[i]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        st = new Stack<>();\\n        for (int i=0; i<n; i++) {\\n            if (!visited[i]) {\\n                dfs1(visited, i);\\n            }\\n        }\\n        revGraph = new List[n];\\n        for (int i=0; i<n; i++) {\\n            revGraph[i] = new ArrayList<>();\\n        }\\n        for (int i=0; i<n; i++) {\\n            revGraph[favorite[i]].add(i);\\n        }\\n        visited = new boolean[n];\\n        int twoGroups = 0;\\n        int biggest = 0;\\n        while (!st.isEmpty()) {\\n            int p = st.pop();\\n            if (!visited[p]) {\\n                List<Integer> vis = new ArrayList<>();\\n                dfs2(visited, p, vis);\\n                if (vis.size()==2) {\\n                    twoGroups += dfs3(vis.get(0), vis.get(1));\\n                    twoGroups += dfs3(vis.get(1), vis.get(0));\\n                }\\n                biggest = Math.max(biggest, vis.size());\\n            }\\n        }\\n        return Math.max(twoGroups, biggest);\\n    }\\n    public int dfs3(int cur, int noGo) {\\n        int len = 0;\\n        for (int next:revGraph[cur]) {\\n            if (next != noGo) {\\n                len = Math.max(len, dfs3(next, cur));\\n            }\\n        }\\n        return len+1;\\n    }\\n    public void dfs2(boolean[] visited, int cur, List<Integer> vis) {\\n        visited[cur] = true;\\n        vis.add(cur);\\n        for (int next:revGraph[cur]) {\\n            if (!visited[next]) {\\n                dfs2(visited, next, vis);\\n            }\\n        }\\n    }\\n    public void dfs1(boolean[] visited, int cur) {\\n        visited[cur] = true;\\n        for (int next:graph[cur]) {\\n            if (!visited[next])\\n                dfs1(visited, next);\\n        }\\n        st.push(cur);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662904,
                "title": "c-handle-two-cases-with-dfs-in-o-n-time-and-o-n-space",
                "content": "The solution will be the max of \\n* Biggest circle\\n* Sum of circles, which has size of two, after expansion\\n\\nIn the following code, I use `rev` to store the revert edges, which will be used for expansion to the size of two circles. \\n\\nThen, I use `dfs` to find all circle first, and also store the size of biggest circle in the `ans1`. Next, I use `dfs2` to expand all size of two circles and store the answer in `ans2`.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rev;\\n    vector<int> es, sizeOfTwo;\\n    int N, ans1, ans2;\\n    void dfs(vector<int>& depth, int cur, int d) {\\n        if (depth[cur] > 0) {\\n            if (d - depth[cur] == 2) sizeOfTwo.push_back(cur);\\n            ans1 = max(ans1, d - depth[cur]);\\n            return;\\n        }\\n        if (depth[cur] != -1) return;\\n        depth[cur] = d;\\n        dfs(depth, es[cur], d+1);\\n        depth[cur] = 0; // 0 means visited\\n    }\\n    void findAllCircules() {\\n        vector<int> depth(N, -1);\\n        for (int i=0; i<N; i++) {\\n            if (depth[i] == -1) {\\n                dfs(depth, i, 1);\\n            }\\n        }\\n    }\\n    int dfs2(int cur, int except) {\\n        int ret = 1;\\n        int d = 0;\\n        for (auto nxt : rev[cur]) {\\n            if (nxt != except) {\\n                d = max(d, dfs2(nxt, except));\\n            }\\n        }\\n        return ret + d;\\n    }\\n    void expandSizeOfTwo() {\\n        for (auto i : sizeOfTwo) {\\n            int j = es[i];\\n            ans2 += dfs2(i, j);\\n            ans2 += dfs2(j, i);\\n        }\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        es = favorite;\\n        N = es.size(), ans1 = 0, ans2 = 0;\\n        rev.resize(N);\\n        for (int i=0; i<N; i++) {\\n            rev[es[i]].push_back(i);\\n        }\\n        findAllCircules();\\n        expandSizeOfTwo();\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> rev;\\n    vector<int> es, sizeOfTwo;\\n    int N, ans1, ans2;\\n    void dfs(vector<int>& depth, int cur, int d) {\\n        if (depth[cur] > 0) {\\n            if (d - depth[cur] == 2) sizeOfTwo.push_back(cur);\\n            ans1 = max(ans1, d - depth[cur]);\\n            return;\\n        }\\n        if (depth[cur] != -1) return;\\n        depth[cur] = d;\\n        dfs(depth, es[cur], d+1);\\n        depth[cur] = 0; // 0 means visited\\n    }\\n    void findAllCircules() {\\n        vector<int> depth(N, -1);\\n        for (int i=0; i<N; i++) {\\n            if (depth[i] == -1) {\\n                dfs(depth, i, 1);\\n            }\\n        }\\n    }\\n    int dfs2(int cur, int except) {\\n        int ret = 1;\\n        int d = 0;\\n        for (auto nxt : rev[cur]) {\\n            if (nxt != except) {\\n                d = max(d, dfs2(nxt, except));\\n            }\\n        }\\n        return ret + d;\\n    }\\n    void expandSizeOfTwo() {\\n        for (auto i : sizeOfTwo) {\\n            int j = es[i];\\n            ans2 += dfs2(i, j);\\n            ans2 += dfs2(j, i);\\n        }\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        es = favorite;\\n        N = es.size(), ans1 = 0, ans2 = 0;\\n        rev.resize(N);\\n        for (int i=0; i<N; i++) {\\n            rev[es[i]].push_back(i);\\n        }\\n        findAllCircules();\\n        expandSizeOfTwo();\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661041,
                "title": "python3-quite-a-tedious-solution",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/18f88320ffb2c2a06e86fad46d82ebd17dadad64) for solutions of weekly 274. \\n\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821684,
                "title": "c-kosaraju-s-algo-pictorial-explanation",
                "content": "# Intuition\\n\\n![WhatsApp Image 2023-07-27 at 08.51.25.jpg](https://assets.leetcode.com/users/images/ac7083e2-53e3-4a3c-b1e0-65e44610f2aa_1690428225.8514593.jpeg)\\n\\n![WhatsApp Image 2023-07-27 at 08.51.26.jpg](https://assets.leetcode.com/users/images/c4169503-8f49-4132-97d7-188b8a681d1b_1690428196.6286278.jpeg)\\n\\n![WhatsApp Image 2023-07-27 at 08.51.27.jpg](https://assets.leetcode.com/users/images/38d470ab-a0a2-46ad-b5b6-09a0240a7586_1690428177.597485.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>graph;\\n    stack<int>st;\\n    vector<vector<int>>reversed;\\n    vector<vector<int>>length;\\n    vector<int>visitedDfs3;\\n\\n    void dfs(int node, vector<int>&visited){\\n        visited[node]=1;\\n        for(auto val: graph[node]){\\n            if(!visited[val])dfs(val,visited);\\n        }\\n        st.push(node);\\n    }\\n\\n    void dfs2(int node, vector<int>&visited, vector<int>&elements){\\n      // cout<<\"hi\"<<endl;\\n        visited[node]=1;\\n        \\n        for(auto val: reversed[node]){\\n            if(!visited[val]){\\n                dfs2(val,visited,elements);\\n                //break;\\n            }\\n        }\\n\\n         elements.push_back(node);\\n       \\n    }\\n\\n    int dfs3(int a, int b){\\n        //visted\\n        int ans=1;\\n        for(auto val: graph[a]){\\n            if(val==b)continue;\\n            ans=max(ans,dfs3(val,b)+1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maximumInvitations(vector<int>& favorite) {\\n       \\n        int n=favorite.size();\\n        graph.resize(n);\\n        for(int i=0;i<n;i++){\\n            \\n            graph[favorite[i]].push_back(i);\\n        }\\n\\n        \\n\\n\\n        //KOSARAJU\\'s\\n        //STEP-1\\n        vector<int>visited(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,visited);\\n            }\\n        }\\n\\n        //STEP-2\\n        reversed.resize(n);\\n        for(int i=0;i<n;i++){\\n            reversed[i].push_back(favorite[i]);\\n        }\\n        \\n        // for(auto val: reversed){\\n        //     for(auto val1: val){\\n        //         cout<<val1<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        //STEP-3\\n        //length.resize(n);\\n        for(int i=0;i<n;i++){\\n            visited[i]=0;\\n        }\\n        while(!st.empty()){\\n            int curr=st.top();\\n            //cout<<curr<<endl;\\n            st.pop();\\n            if(!visited[curr]){\\n                vector<int>elements;\\n                dfs2(curr,visited,elements);\\n                \\n                length.push_back(elements);\\n            }\\n        }\\n\\n\\n        unsigned long ans=0;\\n        for(auto val:length){\\n            if(val.size()==2){\\n                int a=val[0];\\n                int b=val[1];\\n                ans+=dfs3(a,b)+dfs3(b,a);\\n            }\\n        }\\n\\n        \\n\\n        for(auto val:length){\\n            ans=max(ans,val.size());\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>graph;\\n    stack<int>st;\\n    vector<vector<int>>reversed;\\n    vector<vector<int>>length;\\n    vector<int>visitedDfs3;\\n\\n    void dfs(int node, vector<int>&visited){\\n        visited[node]=1;\\n        for(auto val: graph[node]){\\n            if(!visited[val])dfs(val,visited);\\n        }\\n        st.push(node);\\n    }\\n\\n    void dfs2(int node, vector<int>&visited, vector<int>&elements){\\n      // cout<<\"hi\"<<endl;\\n        visited[node]=1;\\n        \\n        for(auto val: reversed[node]){\\n            if(!visited[val]){\\n                dfs2(val,visited,elements);\\n                //break;\\n            }\\n        }\\n\\n         elements.push_back(node);\\n       \\n    }\\n\\n    int dfs3(int a, int b){\\n        //visted\\n        int ans=1;\\n        for(auto val: graph[a]){\\n            if(val==b)continue;\\n            ans=max(ans,dfs3(val,b)+1);\\n        }\\n\\n        return ans;\\n    }\\n\\n    int maximumInvitations(vector<int>& favorite) {\\n       \\n        int n=favorite.size();\\n        graph.resize(n);\\n        for(int i=0;i<n;i++){\\n            \\n            graph[favorite[i]].push_back(i);\\n        }\\n\\n        \\n\\n\\n        //KOSARAJU\\'s\\n        //STEP-1\\n        vector<int>visited(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,visited);\\n            }\\n        }\\n\\n        //STEP-2\\n        reversed.resize(n);\\n        for(int i=0;i<n;i++){\\n            reversed[i].push_back(favorite[i]);\\n        }\\n        \\n        // for(auto val: reversed){\\n        //     for(auto val1: val){\\n        //         cout<<val1<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        //STEP-3\\n        //length.resize(n);\\n        for(int i=0;i<n;i++){\\n            visited[i]=0;\\n        }\\n        while(!st.empty()){\\n            int curr=st.top();\\n            //cout<<curr<<endl;\\n            st.pop();\\n            if(!visited[curr]){\\n                vector<int>elements;\\n                dfs2(curr,visited,elements);\\n                \\n                length.push_back(elements);\\n            }\\n        }\\n\\n\\n        unsigned long ans=0;\\n        for(auto val:length){\\n            if(val.size()==2){\\n                int a=val[0];\\n                int b=val[1];\\n                ans+=dfs3(a,b)+dfs3(b,a);\\n            }\\n        }\\n\\n        \\n\\n        for(auto val:length){\\n            ans=max(ans,val.size());\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2705117,
                "title": "python-topological-sort-union-find-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        numPeople, res, joinable = len(favorite), 0, 0\\n        cycleSize, union_ = [1] * numPeople, [node for node in range(numPeople)]\\n        ans, inDegree = [1] * numPeople, [0] * numPeople\\n        \\n        def find(node: int) -> int:\\n            if union_[node] == node:\\n                return node\\n            union_[node] = find(union_[node])\\n            return union_[node]\\n        \\n        def union(node1: int, node2: int) -> None:\\n            node1, node2 = find(node1), find(node2)\\n            if node1 == node2:\\n                return\\n            if cycleSize[node1] < cycleSize[node2]:\\n                node1, node2 = node2, node1\\n            cycleSize[node1] += cycleSize[node2]\\n            union_[node2] = union_[node1]\\n            \\n        for node in range(numPeople):\\n            inDegree[favorite[node]] += 1\\n        \\n        queue = deque()\\n        for node in range(numPeople):\\n            if inDegree[node] == 0:\\n                queue.append(node)\\n        while queue:\\n            node = queue.popleft()\\n            favNode = favorite[node]\\n            ans[favNode] = max(ans[favNode], ans[node] + 1)\\n            inDegree[favNode] -= 1\\n            if inDegree[favNode] == 0:\\n                queue.append(favNode)\\n        for node in range(numPeople):\\n            if inDegree[node]:\\n                union(node, favorite[node])\\n        for node in range(numPeople):\\n            if not inDegree[node]:\\n                continue\\n            currentCycleLen = cycleSize[find(node)]\\n            if currentCycleLen == 2:\\n                neighbor = favorite[node]\\n                inDegree[neighbor] -= 1\\n                currentCycleLen = ans[node] + ans[neighbor]\\n                joinable += currentCycleLen\\n            else:\\n                res = max(res, currentCycleLen)\\n        return max(res, joinable)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        numPeople, res, joinable = len(favorite), 0, 0\\n        cycleSize, union_ = [1] * numPeople, [node for node in range(numPeople)]\\n        ans, inDegree = [1] * numPeople, [0] * numPeople\\n        \\n        def find(node: int) -> int:\\n            if union_[node] == node:\\n                return node\\n            union_[node] = find(union_[node])\\n            return union_[node]\\n        \\n        def union(node1: int, node2: int) -> None:\\n            node1, node2 = find(node1), find(node2)\\n            if node1 == node2:\\n                return\\n            if cycleSize[node1] < cycleSize[node2]:\\n                node1, node2 = node2, node1\\n            cycleSize[node1] += cycleSize[node2]\\n            union_[node2] = union_[node1]\\n            \\n        for node in range(numPeople):\\n            inDegree[favorite[node]] += 1\\n        \\n        queue = deque()\\n        for node in range(numPeople):\\n            if inDegree[node] == 0:\\n                queue.append(node)\\n        while queue:\\n            node = queue.popleft()\\n            favNode = favorite[node]\\n            ans[favNode] = max(ans[favNode], ans[node] + 1)\\n            inDegree[favNode] -= 1\\n            if inDegree[favNode] == 0:\\n                queue.append(favNode)\\n        for node in range(numPeople):\\n            if inDegree[node]:\\n                union(node, favorite[node])\\n        for node in range(numPeople):\\n            if not inDegree[node]:\\n                continue\\n            currentCycleLen = cycleSize[find(node)]\\n            if currentCycleLen == 2:\\n                neighbor = favorite[node]\\n                inDegree[neighbor] -= 1\\n                currentCycleLen = ans[node] + ans[neighbor]\\n                joinable += currentCycleLen\\n            else:\\n                res = max(res, currentCycleLen)\\n        return max(res, joinable)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365486,
                "title": "c-solution-using-dfs-and-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>dp;\\n    vector<int>vis;\\n    vector<int>indegree;\\n    vector<int>depth;\\n    void cycle(int x,int d,int &start,int &end,int &cycle_len)\\n    {\\n        vis[x]=1;\\n        depth[x]=d;\\n        for(auto &it:dp[x])\\n        {\\n            if(vis[it]==0)\\n            {\\n                cycle(it,d+1,start,end,cycle_len);\\n            }\\n            else if(vis[it]==1)\\n            {\\n                cycle_len=max(cycle_len,depth[x]-depth[it]+1);\\n                start=x;\\n                end=it;\\n            }\\n        }\\n        vis[x]=2;\\n    }\\n    int maximumInvitations(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        dp=vector<vector<int>>(n+1);\\n        vis=vector<int>(n+1);\\n        indegree=vector<int>(n+1);\\n        depth=vector<int>(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i].push_back(nums[i]);\\n            indegree[nums[i]]++;\\n        }\\n        queue<int>q;\\n        vector<int>len(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            vis[temp]=1;\\n            q.pop();\\n            for(auto it:dp[temp])\\n            {\\n                len[it]=len[temp]+1;\\n                if(--indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int largest_cycle=0; \\n        int two_cycle_and_len=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                int start=-1;\\n                int end=-1;\\n                int cycle_len=0;\\n                cycle(i,0,start,end,cycle_len);\\n                if(cycle_len==2)\\n                {\\n                    two_cycle_and_len+=(2+len[start]+len[end]);\\n                }\\n                else\\n                {\\n                    largest_cycle=max(largest_cycle,cycle_len);\\n                }\\n            }\\n        }\\n        return max(two_cycle_and_len,largest_cycle);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>dp;\\n    vector<int>vis;\\n    vector<int>indegree;\\n    vector<int>depth;\\n    void cycle(int x,int d,int &start,int &end,int &cycle_len)\\n    {\\n        vis[x]=1;\\n        depth[x]=d;\\n        for(auto &it:dp[x])\\n        {\\n            if(vis[it]==0)\\n            {\\n                cycle(it,d+1,start,end,cycle_len);\\n            }\\n            else if(vis[it]==1)\\n            {\\n                cycle_len=max(cycle_len,depth[x]-depth[it]+1);\\n                start=x;\\n                end=it;\\n            }\\n        }\\n        vis[x]=2;\\n    }\\n    int maximumInvitations(vector<int>& nums) \\n    {\\n        n=nums.size();\\n        dp=vector<vector<int>>(n+1);\\n        vis=vector<int>(n+1);\\n        indegree=vector<int>(n+1);\\n        depth=vector<int>(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i].push_back(nums[i]);\\n            indegree[nums[i]]++;\\n        }\\n        queue<int>q;\\n        vector<int>len(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indegree[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            vis[temp]=1;\\n            q.pop();\\n            for(auto it:dp[temp])\\n            {\\n                len[it]=len[temp]+1;\\n                if(--indegree[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        int largest_cycle=0; \\n        int two_cycle_and_len=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                int start=-1;\\n                int end=-1;\\n                int cycle_len=0;\\n                cycle(i,0,start,end,cycle_len);\\n                if(cycle_len==2)\\n                {\\n                    two_cycle_and_len+=(2+len[start]+len[end]);\\n                }\\n                else\\n                {\\n                    largest_cycle=max(largest_cycle,cycle_len);\\n                }\\n            }\\n        }\\n        return max(two_cycle_and_len,largest_cycle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832197,
                "title": "strongly-connected-components-w-pictures",
                "content": "**Problem**\\nAs the hints explain, we can model the array of favorites as a directed graph and there are two possible types of solutions. Either (1) choose a cycle of length >= 3 or (2) combine all maximum chains ending in cycles of length 2. We need to choose the solution with the maximum number of vertices.\\n\\n**Solution**\\n1. First, we find the strongly connected components of the graph (Kosaraju\\'s algorithm is enough). \\n2. The longest strongly connected component is the largest cycle of length >= 2.\\n3. Now we need to combine all maximum chains ending in cycles of length 2 and find the size of this combination. For each cycle of length 2, use BFS (on the transposed graph) from each side of the cycle to find the maximum chain possible from that side. Then, sum the sizes of all maximum chains ending in cycles of length 2.\\n4. Return the maximum of the longest cycle and the combination of chains ending in cycles of length 2.\\n\\n**Example**\\nConsider the following array of favorites: [1, 2, 3, 0, 0, 6, 5, 5, 7, 5, 11, 10]. It corresponds to the graph below:\\n\\n![image](https://assets.leetcode.com/users/images/1a8c9d98-5325-4e2f-ab69-d224e828b9d1_1646777175.4577162.png)\\n\\nThere are 3 strongly connected components with length >= 2: [1, 2, 3, 0]; [11, 10]; [6, 5]\\n\\nThe longest cycle is the largest strongly connected component, i.e. [1, 2, 3, 0]\\n\\nNow, we need to use BFS on the transposed graph to find the maximum chains ending in cycles [11, 10] and [6, 5]. We run BFS for each side of the cycles with length 2 to find the maximum distance from each side.\\n\\nThe final result is:\\n\\n![image](https://assets.leetcode.com/users/images/1779e239-ff86-4296-9ca0-51741f3dcd5e_1646777678.1237504.png)\\n\\nThe combination of chains (BLUE) is longer than the largest cycle (RED). So, the solution is the circular graph [5, 6, 7, 8, 10, 11] which has a length of 6. So, we can have a maximum of 6 employees at the party.\\n\\n**Code (messy but may help someone)**\\n\\n```\\nfrom collections import deque\\n\\n\\nclass BFS:\\n    def __init__(self, graph, isDirectedGraph):\\n        self.graph = graph\\n        self.isDirectedGraph = isDirectedGraph\\n        self.nVertices = len(graph)\\n        self.distance = [float(\\'inf\\')] * self.nVertices\\n        self.processed = [False] * self.nVertices\\n        self.discovered = [False] * self.nVertices\\n\\n    def searchVertex(self, srcVertex, ignoreVertex):\\n        u = srcVertex\\n        self.distance[srcVertex] = 0\\n        self.discovered[srcVertex] = True\\n        q = deque([srcVertex])\\n\\n        self.discovered[ignoreVertex] = True\\n        self.processed[ignoreVertex] = True\\n\\n        maxDistance = 0\\n        while q:\\n            u = q.popleft()\\n            self.processed[u] = True\\n            for v in self.graph[u]:\\n                if not self.discovered[v]:\\n                    self.discovered[v] = True\\n                    # self.parent[v] = u\\n                    self.distance[v] = self.distance[u] + 1\\n                    maxDistance = max(maxDistance, self.distance[v])\\n                    q.append(v)\\n        return maxDistance\\n\\n\\nclass DFS:\\n    def __init__(self, graph, isDirectedGraph):\\n        self.graph = graph\\n        self.isDirectedGraph = isDirectedGraph\\n        self.nVertices = len(graph)\\n        self.processed = [False] * self.nVertices\\n        self.discovered = [False] * self.nVertices\\n\\n    def onVertexAfter(self, u):\\n        pass\\n\\n    def onBeforeSearchAllPass(self, srcVertex):\\n        pass\\n\\n    def searchVertex(self, srcVertex):\\n        u = srcVertex\\n        self.discovered[u] = True\\n        for v in self.graph[u]:\\n            if not self.discovered[v]:\\n                # self.parent[v] = u\\n                self.searchVertex(v)\\n        self.onVertexAfter(u)\\n        self.processed[u] = True\\n\\n    def searchAllVertices(self):\\n        for vertex in range(len(self.graph)):\\n            if not self.discovered[vertex]:\\n                self.onBeforeSearchAllPass(vertex)\\n                self.searchVertex(vertex)\\n\\n\\nclass TopologicalSorter(DFS):\\n    def __init__(self, dag, checkForCycles=True):\\n        super().__init__(dag, isDirectedGraph=True)\\n        self.checkForCycles = checkForCycles\\n        self.sortedVertices = deque()\\n\\n    def onVertexAfter(self, u):\\n        self.sortedVertices.appendleft(u)\\n\\n\\ndef topologicalSort(dag, checkForCycles=True):\\n    tps = TopologicalSorter(dag, checkForCycles)\\n    tps.searchAllVertices()\\n    return tps.sortedVertices\\n\\n\\ndef transpose(unweightedDirectedGraph):\\n    g = unweightedDirectedGraph\\n    newGraph = [[] for _ in range(len(g))]\\n    for u in range(len(g)):\\n        for v in g[u]:\\n            newGraph[v].append(u)\\n    return newGraph\\n\\n\\nclass _StronglyConnectedComponentFinder(DFS):\\n    def onVertexAfter(self, u):\\n        self.components[-1].append(u)\\n\\n    def onBeforeSearchAllPass(self, srcVertex):\\n        self.components.append([])\\n\\n    def searchAllVertices(self):\\n        if not hasattr(self, \\'sortedVertices\\'):\\n            self.components = []\\n            self.sortedVertices = topologicalSort(self.graph, checkForCycles=False)\\n            self.graph = transpose(self.graph)\\n\\n        for vertex in self.sortedVertices:\\n            if not self.discovered[vertex]:\\n                self.onBeforeSearchAllPass(vertex)\\n                self.searchVertex(vertex)\\n\\n\\ndef findStronglyConnectedComponents(directedGraph):\\n    \"\"\"\\n    Uses Kosaraju\\'s algorithm whose simplicity is offset by its need of two DFS passes unlike other\\n    more efficient algorithms which require a single one.\\n    \"\"\"\\n    sccFinder = _StronglyConnectedComponentFinder(directedGraph, isDirectedGraph=True)\\n    sccFinder.searchAllVertices()\\n    return sccFinder.graph, sccFinder.components\\n\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        # 0. Build the graph\\n        graph = [[favorite[i]] for i in range(len(favorite))]\\n\\n        # 1. Find the longest cycle (which is the largest strongly connected component)\\n        transposedGraph, components = findStronglyConnectedComponents(graph)\\n        longestCycle = max(components, key=lambda x: len(x))\\n\\n        # 2. Grow two cycle components by traversing transpose graph with BFS (two cycles are strongly connected components of size 2)\\n        twoCycleComponents = [c for c in components if len(c) == 2]\\n        chainSizes = []\\n        bfs = BFS(transposedGraph, isDirectedGraph=True)\\n        for c in twoCycleComponents:\\n            maxDistance1 = bfs.searchVertex(c[0], ignoreVertex=c[1])\\n            bfs.discovered[c[1]] = False\\n            bfs.processed[c[1]] = False\\n            maxDistance2 = bfs.searchVertex(c[1], ignoreVertex=c[0])\\n            bfs.discovered[c[0]] = False\\n            bfs.processed[c[0]] = False\\n            nVertices = maxDistance1 + maxDistance2 + 2\\n            chainSizes.append(nVertices)\\n\\n        # 3. Combine the chains with two-cycles to find maximum combination\\n        combinedTwoCyclesSize = sum(chainSizes)\\n\\n        return max(len(longestCycle), combinedTwoCyclesSize)\\n```\\n\\n\\n",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass BFS:\\n    def __init__(self, graph, isDirectedGraph):\\n        self.graph = graph\\n        self.isDirectedGraph = isDirectedGraph\\n        self.nVertices = len(graph)\\n        self.distance = [float(\\'inf\\')] * self.nVertices\\n        self.processed = [False] * self.nVertices\\n        self.discovered = [False] * self.nVertices\\n\\n    def searchVertex(self, srcVertex, ignoreVertex):\\n        u = srcVertex\\n        self.distance[srcVertex] = 0\\n        self.discovered[srcVertex] = True\\n        q = deque([srcVertex])\\n\\n        self.discovered[ignoreVertex] = True\\n        self.processed[ignoreVertex] = True\\n\\n        maxDistance = 0\\n        while q:\\n            u = q.popleft()\\n            self.processed[u] = True\\n            for v in self.graph[u]:\\n                if not self.discovered[v]:\\n                    self.discovered[v] = True\\n                    # self.parent[v] = u\\n                    self.distance[v] = self.distance[u] + 1\\n                    maxDistance = max(maxDistance, self.distance[v])\\n                    q.append(v)\\n        return maxDistance\\n\\n\\nclass DFS:\\n    def __init__(self, graph, isDirectedGraph):\\n        self.graph = graph\\n        self.isDirectedGraph = isDirectedGraph\\n        self.nVertices = len(graph)\\n        self.processed = [False] * self.nVertices\\n        self.discovered = [False] * self.nVertices\\n\\n    def onVertexAfter(self, u):\\n        pass\\n\\n    def onBeforeSearchAllPass(self, srcVertex):\\n        pass\\n\\n    def searchVertex(self, srcVertex):\\n        u = srcVertex\\n        self.discovered[u] = True\\n        for v in self.graph[u]:\\n            if not self.discovered[v]:\\n                # self.parent[v] = u\\n                self.searchVertex(v)\\n        self.onVertexAfter(u)\\n        self.processed[u] = True\\n\\n    def searchAllVertices(self):\\n        for vertex in range(len(self.graph)):\\n            if not self.discovered[vertex]:\\n                self.onBeforeSearchAllPass(vertex)\\n                self.searchVertex(vertex)\\n\\n\\nclass TopologicalSorter(DFS):\\n    def __init__(self, dag, checkForCycles=True):\\n        super().__init__(dag, isDirectedGraph=True)\\n        self.checkForCycles = checkForCycles\\n        self.sortedVertices = deque()\\n\\n    def onVertexAfter(self, u):\\n        self.sortedVertices.appendleft(u)\\n\\n\\ndef topologicalSort(dag, checkForCycles=True):\\n    tps = TopologicalSorter(dag, checkForCycles)\\n    tps.searchAllVertices()\\n    return tps.sortedVertices\\n\\n\\ndef transpose(unweightedDirectedGraph):\\n    g = unweightedDirectedGraph\\n    newGraph = [[] for _ in range(len(g))]\\n    for u in range(len(g)):\\n        for v in g[u]:\\n            newGraph[v].append(u)\\n    return newGraph\\n\\n\\nclass _StronglyConnectedComponentFinder(DFS):\\n    def onVertexAfter(self, u):\\n        self.components[-1].append(u)\\n\\n    def onBeforeSearchAllPass(self, srcVertex):\\n        self.components.append([])\\n\\n    def searchAllVertices(self):\\n        if not hasattr(self, \\'sortedVertices\\'):\\n            self.components = []\\n            self.sortedVertices = topologicalSort(self.graph, checkForCycles=False)\\n            self.graph = transpose(self.graph)\\n\\n        for vertex in self.sortedVertices:\\n            if not self.discovered[vertex]:\\n                self.onBeforeSearchAllPass(vertex)\\n                self.searchVertex(vertex)\\n\\n\\ndef findStronglyConnectedComponents(directedGraph):\\n    \"\"\"\\n    Uses Kosaraju\\'s algorithm whose simplicity is offset by its need of two DFS passes unlike other\\n    more efficient algorithms which require a single one.\\n    \"\"\"\\n    sccFinder = _StronglyConnectedComponentFinder(directedGraph, isDirectedGraph=True)\\n    sccFinder.searchAllVertices()\\n    return sccFinder.graph, sccFinder.components\\n\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        # 0. Build the graph\\n        graph = [[favorite[i]] for i in range(len(favorite))]\\n\\n        # 1. Find the longest cycle (which is the largest strongly connected component)\\n        transposedGraph, components = findStronglyConnectedComponents(graph)\\n        longestCycle = max(components, key=lambda x: len(x))\\n\\n        # 2. Grow two cycle components by traversing transpose graph with BFS (two cycles are strongly connected components of size 2)\\n        twoCycleComponents = [c for c in components if len(c) == 2]\\n        chainSizes = []\\n        bfs = BFS(transposedGraph, isDirectedGraph=True)\\n        for c in twoCycleComponents:\\n            maxDistance1 = bfs.searchVertex(c[0], ignoreVertex=c[1])\\n            bfs.discovered[c[1]] = False\\n            bfs.processed[c[1]] = False\\n            maxDistance2 = bfs.searchVertex(c[1], ignoreVertex=c[0])\\n            bfs.discovered[c[0]] = False\\n            bfs.processed[c[0]] = False\\n            nVertices = maxDistance1 + maxDistance2 + 2\\n            chainSizes.append(nVertices)\\n\\n        # 3. Combine the chains with two-cycles to find maximum combination\\n        combinedTwoCyclesSize = sum(chainSizes)\\n\\n        return max(len(longestCycle), combinedTwoCyclesSize)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662956,
                "title": "c-solution-based-on-topology-sort-o-n-time-complexity",
                "content": "**Algorithm**:\\n1. Use Topology Sort to calculate the level of each node. \\n\\t* **Note**: Must calculate level for the ending node which is part of cycle.\\n\\t* After Topology Sort, all visited nodes are not in cycle. So, the un-visited nodes will only be part of cycles.\\n2. Loop each un-visited nodes to count nodes in cycle.\\n\\t* If Count > 2, store the max count of cycle.\\n\\t* If Count == 2, Sum the level of node.\\n3. Return Max value from these two cases.\\n\\n```\\npublic class Solution {\\n    int[] inDegrees = null;\\n    int len = 0;\\n    \\n    public int MaximumInvitations(int[] favorite) {\\n        // Note: 1. Topology Sort to find level for each node which is not in circle\\n        //       2. Processing two typed cycles\\n        len = favorite.Length;\\n        \\n        // top sort\\n        int[] level = new int[len];\\n        int[] visited = new int[len];\\n        TopSort(favorite, level, visited);\\n        \\n        // handle cycle - the node in cycle is not visited yet\\n        int maxCycle = 0;\\n        int maxLinear = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            if (visited[i] == 0)\\n                if (favorite[favorite[i]] == i)\\n                    maxLinear += level[i] + 1;\\n                else\\n                    maxCycle = Math.Max(maxCycle, CountCycle(favorite, i, visited));\\n        \\n        return Math.Max(maxCycle, maxLinear);\\n    }\\n    \\n    void TopSort(int[] favorite, int[] level, int[] visited)\\n    {\\n        // calc inDegrees\\n        inDegrees = new int[len];\\n        for (int i = 0; i < len; i++)\\n            inDegrees[favorite[i]]++;\\n        \\n        // init queue\\n        var q = new Queue<int>();\\n        for (int i = 0; i < len; i++)\\n            if (inDegrees[i] == 0)\\n                q.Enqueue(i);\\n        \\n        // topology sort\\n        int lvl = 0; \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            lvl++;\\n            \\n            while (count > 0)\\n            {\\n                var cur = q.Dequeue();\\n                \\n                visited[cur] = 1;\\n                \\n                var next = favorite[cur];\\n                inDegrees[next]--;\\n                level[next] = lvl;\\n                \\n                if (inDegrees[next] == 0)\\n                    q.Enqueue(next);\\n                \\n                count--;\\n            }\\n        }\\n    }\\n    \\n    int CountCycle(int[] favorite, int start, int[] visited)\\n    {\\n        int count = 0;\\n        var cur = start;\\n        \\n        while (true)\\n        {\\n            if (visited[cur] == 1)\\n                break;\\n\\n            visited[cur] = 1;\\n            cur = favorite[cur];\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    int[] inDegrees = null;\\n    int len = 0;\\n    \\n    public int MaximumInvitations(int[] favorite) {\\n        // Note: 1. Topology Sort to find level for each node which is not in circle\\n        //       2. Processing two typed cycles\\n        len = favorite.Length;\\n        \\n        // top sort\\n        int[] level = new int[len];\\n        int[] visited = new int[len];\\n        TopSort(favorite, level, visited);\\n        \\n        // handle cycle - the node in cycle is not visited yet\\n        int maxCycle = 0;\\n        int maxLinear = 0;\\n        \\n        for (int i = 0; i < len; i++)\\n            if (visited[i] == 0)\\n                if (favorite[favorite[i]] == i)\\n                    maxLinear += level[i] + 1;\\n                else\\n                    maxCycle = Math.Max(maxCycle, CountCycle(favorite, i, visited));\\n        \\n        return Math.Max(maxCycle, maxLinear);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1661643,
                "title": "java",
                "content": "```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    int maxCircle;\\n    int n;\\n    List<List<Integer>> graph;\\n    List<int[]> pairs;\\n\\n    public int maximumInvitations(int[] favorite) {\\n        n = favorite.length;\\n        graph = new ArrayList<>();\\n        pairs = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (i == favorite[favorite[i]]) {\\n                if (i < favorite[i]) {\\n                    pairs.add(new int[]{i, favorite[i]});\\n                }\\n            } else {\\n                graph.get(favorite[i]).add(i);\\n            }\\n        }\\n\\n        int sumPath = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            int pathOne = extend(p1, visited);\\n            int pathTwo = extend(p2, visited);\\n\\n            sumPath += pathOne + pathTwo;\\n        }\\n\\n        maxCircle = 0;\\n        getMaxCircle(visited);\\n\\n        return Math.max(maxCircle, sumPath);\\n    }\\n\\n    private int extend(int index, boolean[] visited) {\\n        visited[index] = true;\\n        int res = 0;\\n        for (Integer next : graph.get(index)) {\\n            visited[next] = true;\\n            int depth = extend(next, visited);\\n            res = Math.max(res, depth);\\n        }\\n        return res + 1;\\n    }\\n\\n    private void getMaxCircle(boolean[] visited) {\\n        boolean[] visitedThisRound = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            dfs(visited, visitedThisRound, i, 0);\\n        }\\n    }\\n\\n    private void dfs(boolean[] visited, boolean[] thisRound, int index, int count) {\\n        if (thisRound[index]) {\\n            maxCircle = Math.max(maxCircle, count);\\n            return;\\n        }\\n        if (visited[index]) {\\n            return;\\n        }\\n        visited[index] = true;\\n        thisRound[index] = true;\\n        for (Integer next : graph.get(index)) {\\n            dfs(visited, thisRound, next, count + 1);\\n        }\\n        thisRound[index] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    int maxCircle;\\n    int n;\\n    List<List<Integer>> graph;\\n    List<int[]> pairs;\\n\\n    public int maximumInvitations(int[] favorite) {\\n        n = favorite.length;\\n        graph = new ArrayList<>();\\n        pairs = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (i == favorite[favorite[i]]) {\\n                if (i < favorite[i]) {\\n                    pairs.add(new int[]{i, favorite[i]});\\n                }\\n            } else {\\n                graph.get(favorite[i]).add(i);\\n            }\\n        }\\n\\n        int sumPath = 0;\\n        boolean[] visited = new boolean[n];\\n        for (int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            int pathOne = extend(p1, visited);\\n            int pathTwo = extend(p2, visited);\\n\\n            sumPath += pathOne + pathTwo;\\n        }\\n\\n        maxCircle = 0;\\n        getMaxCircle(visited);\\n\\n        return Math.max(maxCircle, sumPath);\\n    }\\n\\n    private int extend(int index, boolean[] visited) {\\n        visited[index] = true;\\n        int res = 0;\\n        for (Integer next : graph.get(index)) {\\n            visited[next] = true;\\n            int depth = extend(next, visited);\\n            res = Math.max(res, depth);\\n        }\\n        return res + 1;\\n    }\\n\\n    private void getMaxCircle(boolean[] visited) {\\n        boolean[] visitedThisRound = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            dfs(visited, visitedThisRound, i, 0);\\n        }\\n    }\\n\\n    private void dfs(boolean[] visited, boolean[] thisRound, int index, int count) {\\n        if (thisRound[index]) {\\n            maxCircle = Math.max(maxCircle, count);\\n            return;\\n        }\\n        if (visited[index]) {\\n            return;\\n        }\\n        visited[index] = true;\\n        thisRound[index] = true;\\n        for (Integer next : graph.get(index)) {\\n            dfs(visited, thisRound, next, count + 1);\\n        }\\n        thisRound[index] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661639,
                "title": "c-232ms-94-somewhat-strange-commented",
                "content": "![image](https://assets.leetcode.com/users/images/86f4a248-3e11-4240-b76f-a2ecfe6d0c5f_1641108141.2073827.png)\\nGood day !!! How I consider that task : \\n**we have two possibilities for location of people :**\\n**1.** if we have cycle with len more than 2 : we can locate for table only greatest cycle\\n**2.** if we have cycle with len is equal 2 : we have locate all such cycles with their greatest tailes \\n\\n**3.** so we will do some things in the same time : we will check in array st(**starts**) all vertexes that may be starts of cheins and try to move from current not visited cell (and mark all visited cells ) and check we have cycle ? if have : calculate length of cycle => if len > 2 (check with ans_cycle) if len == 2\\ncontain into map theese two cells and after first loop consider all starts from **st** to theese cells\\n\\n**But my realisation have TLE =(** I will try to fix it (but if speak francly I realy not understand why it have TLE : all operations have linear time)\\n**FIXED VERSION BELOW**\\n\\n**version with TLE** (unordered set isn\\'t fast thing)\\n```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,tuple<int,int,int,int>>mp;              //ci, <id, length of tail>\\n    for(int i = 0; i != n; i++){\\n      st[fav[i]] = 1;\\n      if(vis[i] == 0){\\n        unordered_set<int>st;\\n        \\n        for(int next = i; ;)\\n          if(vis[next] == 0){\\n            st.insert(next);\\n            vis[next] = 1;\\n            next = fav[next];\\n          }\\n          else{\\n            if(!st.count(next)) break;\\n            ci++;\\n            int len = 0, stop = next;\\n            do{\\n              vis[next] = ci;\\n              len++;\\n              next = fav[next];\\n            }while(next != stop);\\n            \\n            if(len == 2) mp[ci] = {stop, 0, fav[stop], 0};\\n            else ans_cycle = max(ans_cycle, len);\\n               \\n            break;\\n          }\\n        \\n        st.clear();\\n      }\\n    }\\n   \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0;\\n        int next = i;\\n        \\n        while(vis[next] == 1){\\n          len++;\\n          next = fav[next];\\n        }\\n            \\n        if(mp.count(vis[next])){\\n          auto [id1, len1, id2, len2] = mp[vis[next]];\\n          if(id1 == next) len1 = max(len1, len);\\n          else            len2 = max(len2, len);\\n          mp[vis[next]] = {id1, len1, id2, len2};\\n        }  \\n      }\\n    \\n    for(auto [c, t] : mp) ans_linear += 2 + get<1>(t) + get<3>(t);\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\\n\\n**I fixed it.**\\nRuntime: 1880 ms, faster than 9.09% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\nMemory Usage: 85.3 MB, less than 100.00% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\n```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,tuple<int,int,int,int>>mp;              //ci, <id, length of tail>\\n    for(int i = 0; i != n; i++){\\n      st[fav[i]] = 1;\\n      if(vis[i] == 0){\\n        ci++;\\n        int len = 0;\\n        \\n        for(int next = i; ;)\\n          if(vis[next] == 0){\\n            vis[next] = ci;\\n            next = fav[next];\\n            len++;\\n          }\\n          else{\\n            int stop = next;\\n            next = i;\\n            while(next != stop) {vis[next] = 1; next = fav[next]; len--;}\\n                \\n            if(len == 2) mp[ci] = {stop, 0, fav[stop], 0};\\n            else if(len) ans_cycle = max(ans_cycle, len);\\n               \\n            break;\\n          }\\n      }\\n    }\\n   \\n    \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0;\\n        int next = i;\\n        \\n        while(vis[next] == 1){\\n          len++;\\n          next = fav[next];\\n        }\\n            \\n        if(mp.count(vis[next])){\\n          auto [id1, len1, id2, len2] = mp[vis[next]];\\n          if(id1 == next) len1 = max(len1, len);\\n          else            len2 = max(len2, len);\\n          mp[vis[next]] = {id1, len1, id2, len2};\\n        }  \\n      }\\n    \\n    for(auto [c, t] : mp) ans_linear += 2 + get<1>(t) + get<3>(t);\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\\n\\n**more compact** (but sometime and it have TLE)\\nRuntime: 1844 ms, faster than 9.09% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\nMemory Usage: 85.5 MB, less than 100.00% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\n```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,int>mp;              //id, length of tail\\n    for(int i = 0; i != n; st[fav[i++]] = 1)\\n      if(vis[i] == 0){\\n        ci++;\\n        \\n        for(int next = i, len = 0; ;len++)\\n          if(vis[next] == 0){\\n            vis[next] = ci;\\n            next = fav[next];\\n          }\\n          else{\\n            int stop = next;\\n            next = i;\\n            while(next != stop) {vis[next] = 1; next = fav[next]; len--;}\\n                \\n            if(len == 2) mp[stop] = mp[fav[stop]] = 0;\\n            else if(len) {ans_cycle = max(ans_cycle, len); vis[i] = ci;}\\n               \\n            break;\\n          }\\n      }\\n    \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0, next = i;\\n        \\n        while(vis[next] == 1)\\n          len++, next = fav[next];\\n        \\n        if(mp.count(fav[next])) mp[fav[next]] = max(len, mp[fav[next]]);        \\n      }\\n    \\n    for(auto [id, len] : mp) ans_linear += 1 + len;\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\\n\\n**last redaction**\\nI understanded why I have so much time with previous versions - I searched **tails** of cycles from end of tails to cycles (and I handled coincident cells many times) => I reversed my search of tails (bfs) and runtime is convinient\\n![image](https://assets.leetcode.com/users/images/3dab9146-8ae6-4077-aeaf-d3cc9b310199_1641134862.3875835.png)\\n\\n\\nRuntime: 232 ms, faster than 93.76% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\nMemory Usage: 134 MB, less than 76.12% of C++ online submissions for Maximum Employees to Be Invited to a Meeting.\\n```\\nclass Solution {\\npublic:\\n  inline int bfs(vector<vector<int>> &g, vector<int> &vis, int id){        //bfs with searching the longest path from one of two cells that are present itself cycle with length 2\\n    queue<int>q;\\n    \\n    int level = 0;\\n    q.push(id);\\n    while(!q.empty()){\\n      int n = q.size();\\n      level++;\\n      while(n--){\\n        int j = q.front(); q.pop();\\n        vis[j] = 1;\\n        for(auto k: g[j])\\n          if(vis[k] == 0) q.push(k);\\n      }\\n    }\\n    return level;\\n  }\\n  \\n  \\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ans_cycle = 0, ans_linear = 0;\\n    \\n    vector<vector<int>> g(n);                                                                //graph with reversed edges for searching and deleting \"tails\"\\n    for(int i = 0; i != n; i++) g[fav[i]].push_back(i);\\n    \\n    vector<int>vis(n,0);                                                                     //for visiting cells\\n    for(int i = 0; i != n; i++)\\n      if(vis[i] == 0)                                                                        //if we not visited this cell we move from this cell and will calculate total length\\n        for(int next = i, len = 0; ;len++)\\n          if(vis[next] == 0){                                                                //while we move we mark our path (1 - visited) \\n            vis[next] = 1;\\n            next = fav[next];\\n          }\\n          else{                                                                              //if we collide to visited cell => we have loop\\n            int stop = next;                                                                 //again move from begin of this path to cell where we have loop\\n            next = i;                                                                        //so we discard from loop cells that are presented itself \"tail\"\\n            while(next != stop) {vis[next] = 0; next = fav[next]; len--;}                    //and remark it as not visited\\n            \\n            if(len == 2) ans_linear += bfs(g, vis, stop) + bfs(g, vis, fav[stop]);           //if len == 2 search the longest tails for ans_linear\\n            else{\\n              ans_cycle = max(ans_cycle, len);                                               //if len > 2 discard all tails for this loop\\n              \\n              queue<int>q;\\n              do{q.push(next); next = fav[next];}while(next != stop);\\n              while(!q.empty()){\\n                int j = q.front(); q.pop();\\n                vis[j] = 1;\\n                for(auto k: g[j])\\n                  if(vis[k] == 0) q.push(k);\\n              }\\n            }\\n            break;\\n          }\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,tuple<int,int,int,int>>mp;              //ci, <id, length of tail>\\n    for(int i = 0; i != n; i++){\\n      st[fav[i]] = 1;\\n      if(vis[i] == 0){\\n        unordered_set<int>st;\\n        \\n        for(int next = i; ;)\\n          if(vis[next] == 0){\\n            st.insert(next);\\n            vis[next] = 1;\\n            next = fav[next];\\n          }\\n          else{\\n            if(!st.count(next)) break;\\n            ci++;\\n            int len = 0, stop = next;\\n            do{\\n              vis[next] = ci;\\n              len++;\\n              next = fav[next];\\n            }while(next != stop);\\n            \\n            if(len == 2) mp[ci] = {stop, 0, fav[stop], 0};\\n            else ans_cycle = max(ans_cycle, len);\\n               \\n            break;\\n          }\\n        \\n        st.clear();\\n      }\\n    }\\n   \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0;\\n        int next = i;\\n        \\n        while(vis[next] == 1){\\n          len++;\\n          next = fav[next];\\n        }\\n            \\n        if(mp.count(vis[next])){\\n          auto [id1, len1, id2, len2] = mp[vis[next]];\\n          if(id1 == next) len1 = max(len1, len);\\n          else            len2 = max(len2, len);\\n          mp[vis[next]] = {id1, len1, id2, len2};\\n        }  \\n      }\\n    \\n    for(auto [c, t] : mp) ans_linear += 2 + get<1>(t) + get<3>(t);\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,tuple<int,int,int,int>>mp;              //ci, <id, length of tail>\\n    for(int i = 0; i != n; i++){\\n      st[fav[i]] = 1;\\n      if(vis[i] == 0){\\n        ci++;\\n        int len = 0;\\n        \\n        for(int next = i; ;)\\n          if(vis[next] == 0){\\n            vis[next] = ci;\\n            next = fav[next];\\n            len++;\\n          }\\n          else{\\n            int stop = next;\\n            next = i;\\n            while(next != stop) {vis[next] = 1; next = fav[next]; len--;}\\n                \\n            if(len == 2) mp[ci] = {stop, 0, fav[stop], 0};\\n            else if(len) ans_cycle = max(ans_cycle, len);\\n               \\n            break;\\n          }\\n      }\\n    }\\n   \\n    \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0;\\n        int next = i;\\n        \\n        while(vis[next] == 1){\\n          len++;\\n          next = fav[next];\\n        }\\n            \\n        if(mp.count(vis[next])){\\n          auto [id1, len1, id2, len2] = mp[vis[next]];\\n          if(id1 == next) len1 = max(len1, len);\\n          else            len2 = max(len2, len);\\n          mp[vis[next]] = {id1, len1, id2, len2};\\n        }  \\n      }\\n    \\n    for(auto [c, t] : mp) ans_linear += 2 + get<1>(t) + get<3>(t);\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ci = 2, ans_cycle = 0, ans_linear = 0;\\n    vector<int>vis(n,0), st(n,0);\\n    \\n    unordered_map<int,int>mp;              //id, length of tail\\n    for(int i = 0; i != n; st[fav[i++]] = 1)\\n      if(vis[i] == 0){\\n        ci++;\\n        \\n        for(int next = i, len = 0; ;len++)\\n          if(vis[next] == 0){\\n            vis[next] = ci;\\n            next = fav[next];\\n          }\\n          else{\\n            int stop = next;\\n            next = i;\\n            while(next != stop) {vis[next] = 1; next = fav[next]; len--;}\\n                \\n            if(len == 2) mp[stop] = mp[fav[stop]] = 0;\\n            else if(len) {ans_cycle = max(ans_cycle, len); vis[i] = ci;}\\n               \\n            break;\\n          }\\n      }\\n    \\n    for(int i = 0; i != n; i++)\\n      if(st[i] == 0){\\n        int len = 0, next = i;\\n        \\n        while(vis[next] == 1)\\n          len++, next = fav[next];\\n        \\n        if(mp.count(fav[next])) mp[fav[next]] = max(len, mp[fav[next]]);        \\n      }\\n    \\n    for(auto [id, len] : mp) ans_linear += 1 + len;\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  inline int bfs(vector<vector<int>> &g, vector<int> &vis, int id){        //bfs with searching the longest path from one of two cells that are present itself cycle with length 2\\n    queue<int>q;\\n    \\n    int level = 0;\\n    q.push(id);\\n    while(!q.empty()){\\n      int n = q.size();\\n      level++;\\n      while(n--){\\n        int j = q.front(); q.pop();\\n        vis[j] = 1;\\n        for(auto k: g[j])\\n          if(vis[k] == 0) q.push(k);\\n      }\\n    }\\n    return level;\\n  }\\n  \\n  \\n  int maximumInvitations(vector<int>& fav) {\\n    int n = fav.size(), ans_cycle = 0, ans_linear = 0;\\n    \\n    vector<vector<int>> g(n);                                                                //graph with reversed edges for searching and deleting \"tails\"\\n    for(int i = 0; i != n; i++) g[fav[i]].push_back(i);\\n    \\n    vector<int>vis(n,0);                                                                     //for visiting cells\\n    for(int i = 0; i != n; i++)\\n      if(vis[i] == 0)                                                                        //if we not visited this cell we move from this cell and will calculate total length\\n        for(int next = i, len = 0; ;len++)\\n          if(vis[next] == 0){                                                                //while we move we mark our path (1 - visited) \\n            vis[next] = 1;\\n            next = fav[next];\\n          }\\n          else{                                                                              //if we collide to visited cell => we have loop\\n            int stop = next;                                                                 //again move from begin of this path to cell where we have loop\\n            next = i;                                                                        //so we discard from loop cells that are presented itself \"tail\"\\n            while(next != stop) {vis[next] = 0; next = fav[next]; len--;}                    //and remark it as not visited\\n            \\n            if(len == 2) ans_linear += bfs(g, vis, stop) + bfs(g, vis, fav[stop]);           //if len == 2 search the longest tails for ans_linear\\n            else{\\n              ans_cycle = max(ans_cycle, len);                                               //if len > 2 discard all tails for this loop\\n              \\n              queue<int>q;\\n              do{q.push(next); next = fav[next];}while(next != stop);\\n              while(!q.empty()){\\n                int j = q.front(); q.pop();\\n                vis[j] = 1;\\n                for(auto k: g[j])\\n                  if(vis[k] == 0) q.push(k);\\n              }\\n            }\\n            break;\\n          }\\n    \\n    return max(ans_cycle, ans_linear);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661409,
                "title": "python3-using-bfs-and-dfs",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:   \\n        def helper(u): # bfs\\n            visited[u] = True\\n            stack = [u]\\n            ans = -1\\n            while stack:\\n                newStack = []                                \\n                ans += 1\\n                for u in stack:                    \\n                    for v in graph[u]:\\n                        visited[v] = True\\n                        newStack.append(v)\\n\\n                stack = newStack\\n            \\n            return ans\\n        \\n        def collaborator(u): # dfs\\n            seen = {}\\n            u = i\\n            cnt = 0\\n            go = True\\n            while u not in seen: \\n                if u not in visited: \\n                    visited[u] = True\\n                    seen[u] = cnt\\n                    cnt += 1\\n\\n                    u = favorite[u]\\n                else: \\n                    go = False\\n                    break\\n                    \\n            return cnt - seen[u] if go else 0\\n        \\n        bestFriends = []\\n        graph = defaultdict(lambda:[])\\n        \\n        for (i, fav) in enumerate(favorite):\\n            if i == favorite[fav]:\\n                if i < fav:\\n                    bestFriends.append((i, fav))\\n            else: \\n                graph[fav].append(i)\\n            \\n        visited = {}\\n        ans = 0\\n        for (u, v) in bestFriends:  \\n            ans += helper(u) + 2 + helper(v)\\n            \\n        n = len(favorite)\\n        \\n        for i in range(n):\\n            if i not in visited: \\n                ans = max(ans, collaborator(i))\\n                \\n        return ans\\n\\t\\t\\n            \\n        ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:   \\n        def helper(u): # bfs\\n            visited[u] = True\\n            stack = [u]\\n            ans = -1\\n            while stack:\\n                newStack = []                                \\n                ans += 1\\n                for u in stack:                    \\n                    for v in graph[u]:\\n                        visited[v] = True\\n                        newStack.append(v)\\n\\n                stack = newStack\\n            \\n            return ans\\n        \\n        def collaborator(u): # dfs\\n            seen = {}\\n            u = i\\n            cnt = 0\\n            go = True\\n            while u not in seen: \\n                if u not in visited: \\n                    visited[u] = True\\n                    seen[u] = cnt\\n                    cnt += 1\\n\\n                    u = favorite[u]\\n                else: \\n                    go = False\\n                    break\\n                    \\n            return cnt - seen[u] if go else 0\\n        \\n        bestFriends = []\\n        graph = defaultdict(lambda:[])\\n        \\n        for (i, fav) in enumerate(favorite):\\n            if i == favorite[fav]:\\n                if i < fav:\\n                    bestFriends.append((i, fav))\\n            else: \\n                graph[fav].append(i)\\n            \\n        visited = {}\\n        ans = 0\\n        for (u, v) in bestFriends:  \\n            ans += helper(u) + 2 + helper(v)\\n            \\n        n = len(favorite)\\n        \\n        for i in range(n):\\n            if i not in visited: \\n                ans = max(ans, collaborator(i))\\n                \\n        return ans\\n\\t\\t\\n            \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 3967349,
                "title": "python3-solution-with-using-dfs-approach-and-cycle-detecting",
                "content": "# Code\\n```\\nclass Solution: \\n    def get_max_cycle_length(self, favorite: List[int]) -> int:\\n        person_cnt = len(favorite)\\n        max_cycle_length = 0\\n\\n        seen = set()\\n\\n        # for each person\\n        for i in range(person_cnt):\\n            # i - person i\\n\\n            # if person not part of any chain (chain with cycle)\\n            if i in seen:\\n                continue\\n            \\n            # begin of chain (chain with cycle)\\n            begin_person = i\\n\\n            # visited nodes inside of chain (chain with cycle)\\n            cur_visited = set()\\n\\n            # cur_person\\n            cur_person = i\\n\\n            # try to build chain with cycle\\n            while cur_person not in seen:\\n                seen.add(cur_person)\\n                cur_visited.add(cur_person)\\n                cur_person = favorite[cur_person]\\n            \\n            # if cycle exists\\n            if cur_person in cur_visited:\\n                # length of chain with cycle\\n                visited_person_cnt = len(cur_visited)\\n\\n                # try to find length of cycle\\n                while begin_person != cur_person:\\n                    visited_person_cnt -= 1\\n                    begin_person = favorite[begin_person]\\n            \\n                max_cycle_length = max(max_cycle_length, visited_person_cnt)\\n        \\n        return max_cycle_length\\n    \\n    def get_max_chain_without_cycle_length(self, favorite: List[int]) -> int:\\n        person_cnt = len(favorite)\\n        max_chain_len = 0\\n\\n        # find mutal-favorite (a <-> b) pairs\\n        pairs = []\\n        visited = set()\\n\\n        for i in range(person_cnt):\\n            if i not in visited and favorite[favorite[i]] == i:\\n                pairs.append((i, favorite[i]))\\n                visited.add(i)\\n                visited.add(favorite[i])\\n\\n        # build deps list, list that consits from deps from i (a -> b and c -> b, we shoul build such list [a,c] for b)\\n        deps = collections.defaultdict(list)\\n        for i in range(person_cnt):\\n            deps[favorite[i]].append(i)\\n\\n        for src, dst in pairs:\\n            # max chain length to src\\n            max_dist_to_src = 0\\n            \\n            q = collections.deque()\\n            for dep in deps[src]:\\n                if dep != dst: q.append((dep, 1)) # dependent node and dist to dependent node\\n            \\n            while q:\\n                cur_dependency, dist = q.popleft()\\n                max_dist_to_src = max(max_dist_to_src, dist)\\n                for next_dep in deps[cur_dependency]:\\n                    q.append((next_dep, dist + 1))\\n            \\n            max_dist_to_dst = 0\\n            q = collections.deque()\\n            for dep in deps[dst]:\\n                if dep != src: q.append((dep, 1))\\n            \\n            while q:\\n                cur_dependency, dist = q.popleft()\\n                max_dist_to_dst = max(max_dist_to_dst, dist)\\n                for next_dep in deps[cur_dependency]:\\n                    q.append((next_dep, dist + 1)) \\n\\n            max_chain_len += 2 + max_dist_to_src + max_dist_to_dst\\n\\n        return max_chain_len\\n\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        return max(self.get_max_cycle_length(favorite), self.get_max_chain_without_cycle_length(favorite))\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution: \\n    def get_max_cycle_length(self, favorite: List[int]) -> int:\\n        person_cnt = len(favorite)\\n        max_cycle_length = 0\\n\\n        seen = set()\\n\\n        # for each person\\n        for i in range(person_cnt):\\n            # i - person i\\n\\n            # if person not part of any chain (chain with cycle)\\n            if i in seen:\\n                continue\\n            \\n            # begin of chain (chain with cycle)\\n            begin_person = i\\n\\n            # visited nodes inside of chain (chain with cycle)\\n            cur_visited = set()\\n\\n            # cur_person\\n            cur_person = i\\n\\n            # try to build chain with cycle\\n            while cur_person not in seen:\\n                seen.add(cur_person)\\n                cur_visited.add(cur_person)\\n                cur_person = favorite[cur_person]\\n            \\n            # if cycle exists\\n            if cur_person in cur_visited:\\n                # length of chain with cycle\\n                visited_person_cnt = len(cur_visited)\\n\\n                # try to find length of cycle\\n                while begin_person != cur_person:\\n                    visited_person_cnt -= 1\\n                    begin_person = favorite[begin_person]\\n            \\n                max_cycle_length = max(max_cycle_length, visited_person_cnt)\\n        \\n        return max_cycle_length\\n    \\n    def get_max_chain_without_cycle_length(self, favorite: List[int]) -> int:\\n        person_cnt = len(favorite)\\n        max_chain_len = 0\\n\\n        # find mutal-favorite (a <-> b) pairs\\n        pairs = []\\n        visited = set()\\n\\n        for i in range(person_cnt):\\n            if i not in visited and favorite[favorite[i]] == i:\\n                pairs.append((i, favorite[i]))\\n                visited.add(i)\\n                visited.add(favorite[i])\\n\\n        # build deps list, list that consits from deps from i (a -> b and c -> b, we shoul build such list [a,c] for b)\\n        deps = collections.defaultdict(list)\\n        for i in range(person_cnt):\\n            deps[favorite[i]].append(i)\\n\\n        for src, dst in pairs:\\n            # max chain length to src\\n            max_dist_to_src = 0\\n            \\n            q = collections.deque()\\n            for dep in deps[src]:\\n                if dep != dst: q.append((dep, 1)) # dependent node and dist to dependent node\\n            \\n            while q:\\n                cur_dependency, dist = q.popleft()\\n                max_dist_to_src = max(max_dist_to_src, dist)\\n                for next_dep in deps[cur_dependency]:\\n                    q.append((next_dep, dist + 1))\\n            \\n            max_dist_to_dst = 0\\n            q = collections.deque()\\n            for dep in deps[dst]:\\n                if dep != src: q.append((dep, 1))\\n            \\n            while q:\\n                cur_dependency, dist = q.popleft()\\n                max_dist_to_dst = max(max_dist_to_dst, dist)\\n                for next_dep in deps[cur_dependency]:\\n                    q.append((next_dep, dist + 1)) \\n\\n            max_chain_len += 2 + max_dist_to_src + max_dist_to_dst\\n\\n        return max_chain_len\\n\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        return max(self.get_max_cycle_length(favorite), self.get_max_chain_without_cycle_length(favorite))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913336,
                "title": "python-3-self-explainatory-code-o-n",
                "content": "# Intuition\\nOnly 2 candidates for an answer:\\n* Longest cycle\\n* Combination of cycles of length 2 with longest tails\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        ans = 0\\n        n = len(favorite)\\n        cycles_of_2 = []\\n        seen = [False for _ in range(n)]\\n        for node in range(n):\\n            if seen[node]:\\n                continue\\n            if favorite[favorite[node]] == node:\\n                cycles_of_2.append((node, favorite[node]))\\n                seen[node] = True\\n                seen[favorite[node]] = True\\n        for node in range(n):\\n            if seen[node]:\\n                continue\\n            cycle_length = self.find_cycle(node, 1, {}, seen, favorite)\\n            ans = max(ans, cycle_length)\\n        \\n        if len(cycles_of_2) != 0:\\n            revfavorite = defaultdict(list)\\n            for node, fav in enumerate(favorite):\\n                if favorite[fav] != node:\\n                    revfavorite[fav].append(node)\\n            total_tail = 0\\n            for x, y in cycles_of_2:\\n                max_tail = self.max_depth(x, revfavorite) + self.max_depth(y, revfavorite)\\n                total_tail += max_tail\\n            ans = max(ans, 2 * len(cycles_of_2) + total_tail)\\n        return ans\\n\\n    def find_cycle(self, node, length, path, seen, favorite):\\n        if seen[node]:\\n            return -1\\n        seen[node] = True\\n        path[node] = length\\n        if favorite[node] in path:\\n            return path[node] - path[favorite[node]] + 1\\n        return self.find_cycle(favorite[node], length+1, path, seen, favorite)\\n    \\n    def max_depth(self, node, graph, depth=0):\\n        res = depth\\n        for neigh in graph[node]:\\n            res = max(res, self.max_depth(neigh, graph, depth+1))\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        ans = 0\\n        n = len(favorite)\\n        cycles_of_2 = []\\n        seen = [False for _ in range(n)]\\n        for node in range(n):\\n            if seen[node]:\\n                continue\\n            if favorite[favorite[node]] == node:\\n                cycles_of_2.append((node, favorite[node]))\\n                seen[node] = True\\n                seen[favorite[node]] = True\\n        for node in range(n):\\n            if seen[node]:\\n                continue\\n            cycle_length = self.find_cycle(node, 1, {}, seen, favorite)\\n            ans = max(ans, cycle_length)\\n        \\n        if len(cycles_of_2) != 0:\\n            revfavorite = defaultdict(list)\\n            for node, fav in enumerate(favorite):\\n                if favorite[fav] != node:\\n                    revfavorite[fav].append(node)\\n            total_tail = 0\\n            for x, y in cycles_of_2:\\n                max_tail = self.max_depth(x, revfavorite) + self.max_depth(y, revfavorite)\\n                total_tail += max_tail\\n            ans = max(ans, 2 * len(cycles_of_2) + total_tail)\\n        return ans\\n\\n    def find_cycle(self, node, length, path, seen, favorite):\\n        if seen[node]:\\n            return -1\\n        seen[node] = True\\n        path[node] = length\\n        if favorite[node] in path:\\n            return path[node] - path[favorite[node]] + 1\\n        return self.find_cycle(favorite[node], length+1, path, seen, favorite)\\n    \\n    def max_depth(self, node, graph, depth=0):\\n        res = depth\\n        for neigh in graph[node]:\\n            res = max(res, self.max_depth(neigh, graph, depth+1))\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764676,
                "title": "python-topological-codes-with-explanation-some-figures-o-n",
                "content": "# **Part 1, definition and property**\\n1. **property one**: there are two kinds of answers. Here the answer means the people finally on the table\\n* The **first one** is pure circle,\\n![image](https://assets.leetcode.com/users/images/48f9d045-4f62-47bc-a266-d8ad9c406207_1667246796.1279542.png)\\n\\n* The **second one** is the combination of several linear **tiny graph**\\n![image](https://assets.leetcode.com/users/images/91b73dbd-f476-4300-a9b3-6b24c1be85d8_1667247967.9738789.png)\\nfor this kind of answer, we could find the tiny part separately and then combine them together.\\n\\n2.   **Definition**: igniter refers to two nodes which need each other\\n![image](https://assets.leetcode.com/users/images/284b1136-ee55-44c5-9217-0056a9eef9a7_1667247495.2060192.png)\\n\\n3.  **property two**: The tiny part must have one and **only one** igniter\\nIt is very intuitive to think there is an igniter in the tiny part. What interesting is \"only one\" \\nWe assume there are two igniter in the tiny part\\n![image](https://assets.leetcode.com/users/images/6be78793-8651-48a4-b4d1-d1fc9c907e03_1667247869.0080996.png)\\nWe can see node A has two out-edges, which is impossible in the problem description.\\n\\n4. **property three**: There is no combination of the tiny part and pure circle part\\nSimilarly, we could draw it out.\\n![image](https://assets.leetcode.com/users/images/d6055e50-6e77-4f67-a985-c4b493817c9d_1667248189.3572.png)\\nObviously, node A has two out-edges and it is impossible\\n\\n# **Part 2, what we are going to do**\\nTill now, our task becomes clear. \\n1. Find the igniters.\\n\\tTopological sorting is the best choice for this task, because it could \\'delete\\' those node without indegree, then the circle and igniters are left in the graph. However, I would not delete the nodes directly as what we did in the typical topological sorting. I will calculate the distance for this node to the end of list. Maybe it is easier to understand this with an example.\\n\\nour initial distance is dist[A] = 1, dist[H] = 1 dist[F] and dist[I] = 1. because they are the start node and has at least 1 node.\\n![image](https://assets.leetcode.com/users/images/bb7e1331-4748-43a0-8663-7b40960d6298_1667248965.316513.png)\\nFirstly I will delete node A, H, F and I. And update their nxt node \\'s distance. dist[nxt] = max(dist[nxt], dist[cur] + 1)\\nSo dist[B] = 2, dist[G] = 2 and dist[E] = 2\\n\\n![image](https://assets.leetcode.com/users/images/be9290b4-560e-43d0-bc36-3ba9ac0db256_1667249266.1309178.png)\\nBecause B has an indegree from C, we only need delete G who has no indegree\\nand update dist[E] = max(2, 2 + 1) = 3\\n\\n![image](https://assets.leetcode.com/users/images/02718280-6f02-4985-9c35-83693bf2e70c_1667249345.0703642.png)\\ndist[D] = 3 + 1 = 4\\n\\n![image](https://assets.leetcode.com/users/images/0ea18a51-7dd8-44b8-8d63-6cc46e082d75_1667249377.7394254.png)\\ndist[C] = 4 + 1 = 5\\n\\n![image](https://assets.leetcode.com/users/images/83152032-2a0b-49f5-a26c-0800ee6f54bc_1667249416.3635645.png)\\nfinally, we can do nothing and an igniter is left.\\ndist[B] ==2 and dist[C] == 5\\n\\nWe could see, the max length for this tiny part is dist[B] + dist[C] = 7.\\n![image](https://assets.leetcode.com/users/images/884e7100-7aed-4796-aa8d-611725cff359_1667250202.6766243.png)\\n\\n\\n2. Find the pure circle and its length\\nAfter our previous step, the pure circle is left in the graph. We do not need do anything else.\\nWe could use dfs or a simple while loop to get the length of the circle.\\n\\n3. combine all tiny parts\\n4. return the max(combintion of all tiny parts, the length of pure circle)\\n\\n\\nCodes\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0] * n\\n        dist = [1] * n\\n        \\n        #topological part init \\n        queue = collections.deque()\\n        for ed in favorite:\\n            indegree[ed] += 1\\n        for node in range(n):\\n            if indegree[node] == 0:\\n                queue.append(node)\\n                \\n        #topological part\\n        while queue:\\n            cur = queue.popleft()\\n            nxt = favorite[cur]\\n            \\n            if dist[nxt] < dist[cur] + 1:\\n                dist[nxt] = dist[cur] + 1\\n            \\n            indegree[nxt] -= 1\\n            if indegree[nxt] == 0:\\n                queue.append(nxt)\\n        \\n        #print(dist, indegree)\\n        #sum of the length for ignite part\\n        sumIgnite = 0\\n        for st in range(n):\\n            if indegree[st] == 0:\\n                continue\\n            ed = favorite[st]\\n            if favorite[ed] == st:\\n                #if they are ignite points\\n                sumIgnite += dist[st] + dist[ed]\\n                indegree[st] -= 1\\n                indegree[ed] -= 1\\n        \\n        #length for each circles\\n        ans = sumIgnite\\n        for st in range(n):\\n            if indegree[st] == 0:\\n                continue\\n            indegree[st] -= 1\\n            nxt = favorite[st]\\n            tmpL = 1\\n            while nxt != st:\\n                tmpL += 1\\n                indegree[nxt] -= 1\\n                nxt = favorite[nxt]\\n            ans = max(ans, tmpL)\\n        \\n        return ans\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0] * n\\n        dist = [1] * n\\n        \\n        #topological part init \\n        queue = collections.deque()\\n        for ed in favorite:\\n            indegree[ed] += 1\\n        for node in range(n):\\n            if indegree[node] == 0:\\n                queue.append(node)\\n                \\n        #topological part\\n        while queue:\\n            cur = queue.popleft()\\n            nxt = favorite[cur]\\n            \\n            if dist[nxt] < dist[cur] + 1:\\n                dist[nxt] = dist[cur] + 1\\n            \\n            indegree[nxt] -= 1\\n            if indegree[nxt] == 0:\\n                queue.append(nxt)\\n        \\n        #print(dist, indegree)\\n        #sum of the length for ignite part\\n        sumIgnite = 0\\n        for st in range(n):\\n            if indegree[st] == 0:\\n                continue\\n            ed = favorite[st]\\n            if favorite[ed] == st:\\n                #if they are ignite points\\n                sumIgnite += dist[st] + dist[ed]\\n                indegree[st] -= 1\\n                indegree[ed] -= 1\\n        \\n        #length for each circles\\n        ans = sumIgnite\\n        for st in range(n):\\n            if indegree[st] == 0:\\n                continue\\n            indegree[st] -= 1\\n            nxt = favorite[st]\\n            tmpL = 1\\n            while nxt != st:\\n                tmpL += 1\\n                indegree[nxt] -= 1\\n                nxt = favorite[nxt]\\n            ans = max(ans, tmpL)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220087,
                "title": "toposort-cpp-with-explanation",
                "content": "# 2 cases\\n1 -- > two are fav. of each other \\n**explnation**\\ni have created graph for them and  found the longest chain possible and added them\\n\\n2 -- > there is cycle \\nin this case we just have to find the largest cycle \\n```\\nclass Solution {\\npublic:\\n    \\n    int res = 0;\\n    vector<int> visited;\\n    int dfs(int curr,vector<int> adj[]){\\n        \\n        visited[curr] = true;\\n        int res = 0;\\n        \\n        for(auto x:adj[curr]){\\n            res = max(res,dfs(x,adj));\\n        }\\n        return res + 1;\\n    }\\n    \\n    int maximumInvitations(vector<int>& fav){\\n        \\n        int n = fav.size();\\n        vector<int> adj[n];\\n        visited.resize(n,false);\\n        for(int i = 0 ; i < n;i++){\\n            if(fav[fav[i]] != i) adj[fav[i]].push_back(i); \\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < n;i++){\\n            if(fav[fav[i]] == i) res += dfs(i,adj);\\n        }\\n        \\n        for(int i = 0;i < n;i++){\\n            int cnt = 0, j = i;\\n            for(;visited[j] == false;j = fav[j]){\\n                visited[j]  = true;\\n                cnt++;\\n            }\\n            for(int k = i;k != j;k = fav[k]) cnt--;\\n            res = max(res,cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int res = 0;\\n    vector<int> visited;\\n    int dfs(int curr,vector<int> adj[]){\\n        \\n        visited[curr] = true;\\n        int res = 0;\\n        \\n        for(auto x:adj[curr]){\\n            res = max(res,dfs(x,adj));\\n        }\\n        return res + 1;\\n    }\\n    \\n    int maximumInvitations(vector<int>& fav){\\n        \\n        int n = fav.size();\\n        vector<int> adj[n];\\n        visited.resize(n,false);\\n        for(int i = 0 ; i < n;i++){\\n            if(fav[fav[i]] != i) adj[fav[i]].push_back(i); \\n        }\\n        \\n        int res = 0;\\n        \\n        for(int i = 0; i < n;i++){\\n            if(fav[fav[i]] == i) res += dfs(i,adj);\\n        }\\n        \\n        for(int i = 0;i < n;i++){\\n            int cnt = 0, j = i;\\n            for(;visited[j] == false;j = fav[j]){\\n                visited[j]  = true;\\n                cnt++;\\n            }\\n            for(int k = i;k != j;k = fav[k]) cnt--;\\n            res = max(res,cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189660,
                "title": "c-topological-sort-o-n-e",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n    vector<bool> vis;\\n    int maximumInvitations(vector<int>& favorite) {\\n        int len=favorite.size();\\n        this->vis=vector<bool>(len,false);\\n        this->G.resize(len);\\n        for(int i=0;i<len;++i) this->G[i]=vector<int>();\\n        \\n        vector<int> armLength(len,1), indegree(len,0);\\n        \\n        int i{};\\n        \\n        // Creating adjList and inDegree array\\n        for(;i<len;++i){\\n            G[i].emplace_back(favorite[i]);\\n            indegree[favorite[i]]++;\\n        }\\n        \\n        queue<int>q;\\n        \\n        i=0;\\n        for(;i<len;++i)\\n            if(!indegree[i]) \\n                q.push(i);\\n        \\n        \\n        // Get the left and right arm length and store for couple cycle\\n        // LeftArmlength --> (LeftNode) <--> (RightNode) <--- RightArmLength\\n        while(!q.empty()){\\n            int parent=q.front();\\n            q.pop();\\n            \\n            vis[parent]=true;\\n            \\n            for(int &x: G[parent]){\\n                armLength[x]=armLength[parent]+1;\\n                indegree[x]--;\\n                if(!indegree[x]) \\n                    q.push(x);\\n            }\\n        }\\n        \\n        int maxCycleLength=0, totalCoupleWithArmLength=0;\\n        \\n        \\n        /*  1. Check for nodes that are not visited yet\\n            2. only the nodes having cycle will remain unvisited\\n            3. cycle length could be either 2 or greater than 2 .\\n            4. Result will be MAX( cycle length greater than 2  OR  sum of All the cycles with length 2 and their arms)        \\n        */\\n        \\n        i=0;\\n        for(;i<len;++i){\\n            if(!vis[i]){\\n                if(i==favorite[favorite[i]]){\\n                    int curArmLength = armLength[i] + armLength[favorite[i]];\\n                    totalCoupleWithArmLength += curArmLength;\\n                    vis[i]=true;\\n                    vis[favorite[i]]=true;\\n                }\\n                else {\\n                    int currCycleLength=getCycleLength(i);\\n                    maxCycleLength = max(maxCycleLength, currCycleLength);\\n                }\\n            }\\n        }\\n        \\n        return max(maxCycleLength, totalCoupleWithArmLength);\\n    }\\n    int getCycleLength(int node){\\n        int count=0;\\n        while(!vis[node]){\\n            vis[node]=true;\\n            for(int x: G[node])\\n                count = 1 + getCycleLength(x);\\n        }\\n        return count;\\n    }\\n};\\nstatic const auto io_syc_off =[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> G;\\n    vector<bool> vis;\\n    int maximumInvitations(vector<int>& favorite) {\\n        int len=favorite.size();\\n        this->vis=vector<bool>(len,false);\\n        this->G.resize(len);\\n        for(int i=0;i<len;++i) this->G[i]=vector<int>();\\n        \\n        vector<int> armLength(len,1), indegree(len,0);\\n        \\n        int i{};\\n        \\n        // Creating adjList and inDegree array\\n        for(;i<len;++i){\\n            G[i].emplace_back(favorite[i]);\\n            indegree[favorite[i]]++;\\n        }\\n        \\n        queue<int>q;\\n        \\n        i=0;\\n        for(;i<len;++i)\\n            if(!indegree[i]) \\n                q.push(i);\\n        \\n        \\n        // Get the left and right arm length and store for couple cycle\\n        // LeftArmlength --> (LeftNode) <--> (RightNode) <--- RightArmLength\\n        while(!q.empty()){\\n            int parent=q.front();\\n            q.pop();\\n            \\n            vis[parent]=true;\\n            \\n            for(int &x: G[parent]){\\n                armLength[x]=armLength[parent]+1;\\n                indegree[x]--;\\n                if(!indegree[x]) \\n                    q.push(x);\\n            }\\n        }\\n        \\n        int maxCycleLength=0, totalCoupleWithArmLength=0;\\n        \\n        \\n        /*  1. Check for nodes that are not visited yet\\n            2. only the nodes having cycle will remain unvisited\\n            3. cycle length could be either 2 or greater than 2 .\\n            4. Result will be MAX( cycle length greater than 2  OR  sum of All the cycles with length 2 and their arms)        \\n        */\\n        \\n        i=0;\\n        for(;i<len;++i){\\n            if(!vis[i]){\\n                if(i==favorite[favorite[i]]){\\n                    int curArmLength = armLength[i] + armLength[favorite[i]];\\n                    totalCoupleWithArmLength += curArmLength;\\n                    vis[i]=true;\\n                    vis[favorite[i]]=true;\\n                }\\n                else {\\n                    int currCycleLength=getCycleLength(i);\\n                    maxCycleLength = max(maxCycleLength, currCycleLength);\\n                }\\n            }\\n        }\\n        \\n        return max(maxCycleLength, totalCoupleWithArmLength);\\n    }\\n    int getCycleLength(int node){\\n        int count=0;\\n        while(!vis[node]){\\n            vis[node]=true;\\n            for(int x: G[node])\\n                count = 1 + getCycleLength(x);\\n        }\\n        return count;\\n    }\\n};\\nstatic const auto io_syc_off =[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return NULL;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1991603,
                "title": "java-path-tracking-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/897a0c20-63fe-40b2-85e9-512050804b39_1651235656.7716706.jpeg)\\n\\nIn the diagram, red dots are \"cycle\" and \"bi-favorite pairs\" (employees who mutually favor each other).\\nTo invite maximum number of employees, we need either the biggest cycle, or the sum of all longest possible acyclic paths.\\nTherefore, the invited employees are those purple outlined in the diagram.\\n\\nApproach:\\n1. Calculate the numbers of followers for each employees.\\n2. Starting from the 0-follower employees (head of acyclic path), make the count, decrement the number of follower and put the next 0-follower node into a queue in order to track down the path until hitting a cycle or bi-favorite pairs.\\n2.1. For branches, they will eventually be decremented to 0 and therefore will be tracked through.\\n2.2. Marked all the tracked nodes so that only cycle and bi-favorite paris remain.\\n3. For each of the unvisited nodes, count the size of the cycle to determine whether its part of the acyclic path, or a cycle.\\n4. Track both the biggest cycle and the summation of all acyclic paths, and return the bigger value.\\n\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int len = fav.length;\\n        \\n        // count the number of \"follower\" for each employees\\n        int[] follow = new int[len];\\n        for (int i = 0; i < len; i++) follow[fav[i]]++;\\n        \\n        // track the length of all paths and stop when cycle is detected (including bi-favorite pairs)\\n        int[] pathlen = new int[len];\\n        boolean[] visit = new boolean[len];\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < len; i++) {\\n            if (follow[i] == 0) q.offer(i);\\n        }\\n        while (!q.isEmpty()) {\\n            int i = q.poll(), j = fav[i];\\n            visit[i] = true; // mark all travelled person as visited (cycle heads and bi-favorite paris will be exclued)\\n            pathlen[j] = Math.max(pathlen[j], pathlen[i] + 1);\\n            if (--follow[j] == 0) q.offer(j);\\n        }\\n        \\n        // track all cycles and bi-favorite pairs\\n        int maxCycle = 0, sumPath = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (visit[i]) continue;\\n            int clen = 0;\\n            while(!visit[i]){\\n                clen++;\\n                visit[i] = true;\\n                i = fav[i];\\n            }\\n            if (clen == 2) sumPath += pathlen[i] + pathlen[fav[i]] + 2;\\n            else maxCycle = Math.max(maxCycle, clen);\\n        }\\n        \\n        return Math.max(maxCycle, sumPath);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int len = fav.length;\\n        \\n        // count the number of \"follower\" for each employees\\n        int[] follow = new int[len];\\n        for (int i = 0; i < len; i++) follow[fav[i]]++;\\n        \\n        // track the length of all paths and stop when cycle is detected (including bi-favorite pairs)\\n        int[] pathlen = new int[len];\\n        boolean[] visit = new boolean[len];\\n        ArrayDeque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < len; i++) {\\n            if (follow[i] == 0) q.offer(i);\\n        }\\n        while (!q.isEmpty()) {\\n            int i = q.poll(), j = fav[i];\\n            visit[i] = true; // mark all travelled person as visited (cycle heads and bi-favorite paris will be exclued)\\n            pathlen[j] = Math.max(pathlen[j], pathlen[i] + 1);\\n            if (--follow[j] == 0) q.offer(j);\\n        }\\n        \\n        // track all cycles and bi-favorite pairs\\n        int maxCycle = 0, sumPath = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (visit[i]) continue;\\n            int clen = 0;\\n            while(!visit[i]){\\n                clen++;\\n                visit[i] = true;\\n                i = fav[i];\\n            }\\n            if (clen == 2) sumPath += pathlen[i] + pathlen[fav[i]] + 2;\\n            else maxCycle = Math.max(maxCycle, clen);\\n        }\\n        \\n        return Math.max(maxCycle, sumPath);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663592,
                "title": "java-solution-find-cycle-dfs",
                "content": "```\\nclass Solution {\\npublic int maximumInvitations(int[] favorite) {\\n\\t\\tint n = favorite.length;\\n\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t// initiate dependencies\\n\\t\\tMap<Integer, Set<Integer>> childToParents = new HashMap<>();\\n\\t\\tfor(int i = 0 ; i < favorite.length ; i++) {\\n\\t\\t\\tchildToParents.computeIfAbsent(favorite[i], k -> new HashSet<>());\\n\\t\\t\\tchildToParents.get(favorite[i]).add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint max = 0;\\n        // all the cycles with size 2, along with its connected chain, can fit into a table\\n        int size2Together = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (visited.contains(i))\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t// cycleSize & cycleEntryPoint\\n\\t\\t\\tint[] tableMeta = findCycle(i, favorite, visited);\\n\\t\\t\\tif (tableMeta[0] == 2) {\\n\\t\\t\\t\\tchildToParents.get(tableMeta[1]).remove(favorite[tableMeta[1]]);\\n\\t\\t\\t\\tchildToParents.get(favorite[tableMeta[1]]).remove(tableMeta[1]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttableMeta[0] = dfs(tableMeta[1], childToParents, visited) + dfs(favorite[tableMeta[1]], childToParents, visited);\\n                size2Together += tableMeta[0];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, tableMeta[0]);\\n\\t\\t}\\n\\n\\t\\treturn Math.max(max, size2Together);\\n\\n\\t}\\n\\n\\t// return : new int[] {cycleSize, entryPoint}\\n\\tprivate int[] findCycle(int startPoint, int[] favorite, Set<Integer> visited) {\\n\\t\\tint next = startPoint;\\n\\t\\tint entryPoint = -1;\\n\\t\\tint cycleSize = 0;\\n\\n\\t\\t// find entry point of cycle\\n\\t\\twhile (entryPoint == -1) {\\n\\t\\t\\tvisited.add(next);\\n\\t\\t\\tcycleSize++;\\n\\t\\t\\tnext = favorite[next];\\n\\t\\t\\tif (visited.contains(next))\\n\\t\\t\\t\\tentryPoint = next;\\n\\t\\t}\\n\\n\\t\\t// remove the segment from startPoint to entryPoint\\n\\t\\tnext = startPoint;\\n\\t\\twhile (next != entryPoint) {\\n\\t\\t\\tcycleSize--;\\n\\t\\t\\tnext = favorite[next];\\n\\t\\t}\\n\\n\\t\\treturn new int[] { cycleSize, entryPoint };\\n\\t}\\n\\t\\n\\tprivate int dfs(int child, Map<Integer, Set<Integer>> childToParents, Set<Integer> visited) {\\n\\t\\tvisited.add(child);\\n\\t\\t\\n\\t\\tif (!childToParents.containsKey(child) || childToParents.get(child).isEmpty())\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tint max = 0;\\n\\t\\tfor(int parent : childToParents.get(child)) {\\n\\t\\t\\tmax = Math.max(max, dfs(parent, childToParents, visited) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int maximumInvitations(int[] favorite) {\\n\\t\\tint n = favorite.length;\\n\\t\\tSet<Integer> visited = new HashSet<>();\\n\\t\\t// initiate dependencies\\n\\t\\tMap<Integer, Set<Integer>> childToParents = new HashMap<>();\\n\\t\\tfor(int i = 0 ; i < favorite.length ; i++) {\\n\\t\\t\\tchildToParents.computeIfAbsent(favorite[i], k -> new HashSet<>());\\n\\t\\t\\tchildToParents.get(favorite[i]).add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint max = 0;\\n        // all the cycles with size 2, along with its connected chain, can fit into a table\\n        int size2Together = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (visited.contains(i))\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t// cycleSize & cycleEntryPoint\\n\\t\\t\\tint[] tableMeta = findCycle(i, favorite, visited);\\n\\t\\t\\tif (tableMeta[0] == 2) {\\n\\t\\t\\t\\tchildToParents.get(tableMeta[1]).remove(favorite[tableMeta[1]]);\\n\\t\\t\\t\\tchildToParents.get(favorite[tableMeta[1]]).remove(tableMeta[1]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttableMeta[0] = dfs(tableMeta[1], childToParents, visited) + dfs(favorite[tableMeta[1]], childToParents, visited);\\n                size2Together += tableMeta[0];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, tableMeta[0]);\\n\\t\\t}\\n\\n\\t\\treturn Math.max(max, size2Together);\\n\\n\\t}\\n\\n\\t// return : new int[] {cycleSize, entryPoint}\\n\\tprivate int[] findCycle(int startPoint, int[] favorite, Set<Integer> visited) {\\n\\t\\tint next = startPoint;\\n\\t\\tint entryPoint = -1;\\n\\t\\tint cycleSize = 0;\\n\\n\\t\\t// find entry point of cycle\\n\\t\\twhile (entryPoint == -1) {\\n\\t\\t\\tvisited.add(next);\\n\\t\\t\\tcycleSize++;\\n\\t\\t\\tnext = favorite[next];\\n\\t\\t\\tif (visited.contains(next))\\n\\t\\t\\t\\tentryPoint = next;\\n\\t\\t}\\n\\n\\t\\t// remove the segment from startPoint to entryPoint\\n\\t\\tnext = startPoint;\\n\\t\\twhile (next != entryPoint) {\\n\\t\\t\\tcycleSize--;\\n\\t\\t\\tnext = favorite[next];\\n\\t\\t}\\n\\n\\t\\treturn new int[] { cycleSize, entryPoint };\\n\\t}\\n\\t\\n\\tprivate int dfs(int child, Map<Integer, Set<Integer>> childToParents, Set<Integer> visited) {\\n\\t\\tvisited.add(child);\\n\\t\\t\\n\\t\\tif (!childToParents.containsKey(child) || childToParents.get(child).isEmpty())\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tint max = 0;\\n\\t\\tfor(int parent : childToParents.get(child)) {\\n\\t\\t\\tmax = Math.max(max, dfs(parent, childToParents, visited) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662076,
                "title": "modified-topological-sort-for-finding-cycles-then-maximizing-lengths",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& fav) {\\n        int n=fav.size();\\n        int dp[n],vis[n],deg[n];\\n        for(int i=0;i<n;i++)    dp[i]=1,vis[i]=deg[i]=0;\\n        for(int i=0;i<n;i++){\\n            deg[fav[i]]++;\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)    \\n            if(!deg[i])\\n                q.push(i);\\n        while(!q.empty()){\\n            int i=q.front();\\n            q.pop();\\n            vis[i]=1;\\n            if(deg[fav[i]]--==1){\\n                q.push(fav[i]);\\n            }\\n            dp[fav[i]]=max(dp[fav[i]],dp[i]+1);\\n        }\\n        int ans2=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                int cnt=0;\\n                int x=i;\\n                while(!vis[x]){\\n                    cnt++;\\n                    vis[x]=1;\\n                    x=fav[x];\\n                }\\n                if(cnt==2){\\n                    ans2+=(dp[i]+dp[fav[i]]);\\n                }else{\\n                    ans=max(ans,cnt);\\n                }\\n            }\\n        }\\n        return max(ans2,ans);\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumInvitations(vector<int>& fav) {\\n        int n=fav.size();\\n        int dp[n],vis[n],deg[n];\\n        for(int i=0;i<n;i++)    dp[i]=1,vis[i]=deg[i]=0;\\n        for(int i=0;i<n;i++){\\n            deg[fav[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1661287,
                "title": "python-union-find-loop-searching-recursive-tree-depth",
                "content": "There are 3 techniques used.\\n\\n1. union find,  find isolated clusters\\n2. loop searching,  iterating 3n  and counter,  count>=2 is in the loop\\n3. recursive tree is for loop size == 2 case\\n\\nA few import variable used:\\n* `rever = defaultdict(list)`  reverse the favorate relation\\n* `d = defaultdict(list)`  each key-value pair represents one cluster\\n\\n\\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = {}\\n    \\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        \\n        if a == b:\\n            return\\n        \\n        if self.rank[a] == self.rank[b]:\\n            self.rank[a] += 1\\n        elif self.rank[b] > self.rank[a]:\\n            a, b = b, a\\n            \\n        self.parent[b] = a\\n    \\n    def find(self, x):\\n        if x not in self.parent:\\n            self.parent[x] = x\\n            self.rank[x] = 0\\n        \\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        \\n        return self.parent[x]\\n\\ndef find_loop( li, fav ):\\n    output = []\\n    n = len(li)\\n    p = li[0]\\n    \\n    d = defaultdict(int)\\n    \\n    for i in range(3*n):\\n        p = fav[p]\\n        d[p] += 1\\n    \\n    out = []\\n    for p in d:\\n        if d[p] >= 2:\\n            out.append(p)\\n        \\n    return out\\n    \\n        \\ndef case_2( a,b, rever ):\\n    \\n    def dfs(i):\\n        if i not in rever:\\n            return 1\\n        else:\\n            out = 0\\n            for j in rever[i]:\\n                if j not in {a,b}:\\n                    out = max( out, dfs(j) )\\n            return out + 1\\n        \\n    return dfs(a) + dfs(b)\\n            \\n    \\n    \\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        uf = UnionFind()\\n        rever = defaultdict(list)\\n        for i,j in enumerate(favorite):\\n            uf.union(i, j)\\n            rever[j].append( i )\\n            \\n        n = len(favorite)\\n        \\n        d = defaultdict(list)\\n        for i in range(n):\\n            k = uf.find(i)\\n            d[k].append(i)\\n        \\n        output = 0\\n        \\n        out2 = 0\\n        for k in d:\\n            ll = find_loop( d[k], favorite )\\n            \\n            daxiao = len(ll)\\n            if daxiao  > 2:\\n                output = max( daxiao , output )\\n            elif daxiao == 2: \\n                out2 = out2 + case_2( ll[0],ll[1], rever )\\n                \\n            \\n        return max(output, out2)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.rank = {}\\n    \\n    def union(self, a, b):\\n        a, b = self.find(a), self.find(b)\\n        \\n        if a == b:\\n            return\\n        \\n        if self.rank[a] == self.rank[b]:\\n            self.rank[a] += 1\\n        elif self.rank[b] > self.rank[a]:\\n            a, b = b, a\\n            \\n        self.parent[b] = a\\n    \\n    def find(self, x):\\n        if x not in self.parent:\\n            self.parent[x] = x\\n            self.rank[x] = 0\\n        \\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        \\n        return self.parent[x]\\n\\ndef find_loop( li, fav ):\\n    output = []\\n    n = len(li)\\n    p = li[0]\\n    \\n    d = defaultdict(int)\\n    \\n    for i in range(3*n):\\n        p = fav[p]\\n        d[p] += 1\\n    \\n    out = []\\n    for p in d:\\n        if d[p] >= 2:\\n            out.append(p)\\n        \\n    return out\\n    \\n        \\ndef case_2( a,b, rever ):\\n    \\n    def dfs(i):\\n        if i not in rever:\\n            return 1\\n        else:\\n            out = 0\\n            for j in rever[i]:\\n                if j not in {a,b}:\\n                    out = max( out, dfs(j) )\\n            return out + 1\\n        \\n    return dfs(a) + dfs(b)\\n            \\n    \\n    \\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        uf = UnionFind()\\n        rever = defaultdict(list)\\n        for i,j in enumerate(favorite):\\n            uf.union(i, j)\\n            rever[j].append( i )\\n            \\n        n = len(favorite)\\n        \\n        d = defaultdict(list)\\n        for i in range(n):\\n            k = uf.find(i)\\n            d[k].append(i)\\n        \\n        output = 0\\n        \\n        out2 = 0\\n        for k in d:\\n            ll = find_loop( d[k], favorite )\\n            \\n            daxiao = len(ll)\\n            if daxiao  > 2:\\n                output = max( daxiao , output )\\n            elif daxiao == 2: \\n                out2 = out2 + case_2( ll[0],ll[1], rever )\\n                \\n            \\n        return max(output, out2)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962954,
                "title": "break-down-into-2-separate-ques-longest-cycle-in-directed-graph-and-open-chains",
                "content": "# Intuition\\nmaking a graph and then there will be closed chains and open chains in the graph .so we have to find longest closed chain which is similar que of finding longest cycle in a directed graph and other is combiing these open chains.(although not the best implementation)\\n\\n# Approach\\nfor open chains , it is possible when a is favorite person of b and b is favoirte person of a , and now we will see the longest chain ending at a and longest chain ending at b. and in the end all open chains can be combined to one.\\n\\n# Complexity\\n- Time complexity:\\nn (2*n)\\n\\n- Space complexity:\\nn (although not the best solution)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    void fun(vector<pair<int,int>>& v,vector<int>& visited,int i,vector<vector<int>>& adj,int parent,unordered_map<int,int>& mp,vector<int>& favorite){\\n     \\n     int j;\\n     mp[i]=1;\\n     visited[i]=1;\\n     int sum;\\n     int c=1;\\n     for(j=0;j<adj[i].size();j++){\\n      \\n       if(visited[adj[i][j]]==0){  \\n         fun(v,visited,adj[i][j],adj,i,mp,favorite); \\n       \\n      }\\n      else if(visited[adj[i][j]]==1){\\n          \\n          if(adj[i][j]==parent){\\n                v.push_back(make_pair(parent,i));    \\n          }     \\n      }\\n      if(adj[i][j]!=parent && favorite[i]!=adj[i][j]){\\n         \\n             sum=1+mp[adj[i][j]];\\n      if(sum>=c){\\n          c=sum;\\n      } \\n      }   \\n\\n     }\\n     mp[i]=c;\\n     return;\\n          \\n    }\\n     void check(vector<int> ad[],int node,vector<int>&vis,int a,int& maxi)\\n    {\\n        \\n        a++;\\n        vis[node]=a;\\n        for(auto x:ad[node])\\n        {\\n            if(vis[x]>0)\\n            {\\n                maxi = max(maxi,vis[node]-vis[x]+1);\\n            }\\n            else if(vis[x]==0)\\n            {\\n                check(ad,x,vis,a,maxi);\\n            }\\n        }\\n        vis[node]=-1;\\n        return;\\n    }\\n    \\n  \\n   \\n    int maximumInvitations(vector<int>& favorite) {\\n        \\n        int i,j;\\n        int ans=0;\\n        int n=favorite.size();\\n        if(n<=2){\\n            return n;\\n        }\\n        vector<vector<int>> adj(n);\\n        for(i=0;i<n;i++){\\n            adj[favorite[i]].push_back(i);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ad[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[i]!=-1)\\n            {\\n                ad[i].push_back(favorite[i]);\\n            }\\n        }\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                int a = 0;\\n                check(ad,i,vis,a,maxi);\\n            }\\n        }\\n        ans=max(ans,maxi);\\n\\n    vector<int> visited(n);\\n    for(i=0;i<n;i++){\\n        visited[i]=0;\\n    }\\n   unordered_map<int,int> mp;\\n   vector<pair<int,int>> v;\\n   vector<int> v1;\\n   \\n   \\n   \\n   for(i=0;i<n;i++){\\n       visited[i]=0;\\n   }\\n   \\n  for(i=0;i<n;i++){\\n      if(visited[i]==0){\\n         \\n          fun(v,visited,i,adj,-1,mp,favorite);\\n      }\\n  }\\n  int score=0;\\n \\n  for(i=0;i<v.size();i++){\\n   \\n      score=score+mp[v[i].first]+mp[v[i].second];\\n  }\\nans=max(ans,score);\\n    \\n   return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    void fun(vector<pair<int,int>>& v,vector<int>& visited,int i,vector<vector<int>>& adj,int parent,unordered_map<int,int>& mp,vector<int>& favorite){\\n     \\n     int j;\\n     mp[i]=1;\\n     visited[i]=1;\\n     int sum;\\n     int c=1;\\n     for(j=0;j<adj[i].size();j++){\\n      \\n       if(visited[adj[i][j]]==0){  \\n         fun(v,visited,adj[i][j],adj,i,mp,favorite); \\n       \\n      }\\n      else if(visited[adj[i][j]]==1){\\n          \\n          if(adj[i][j]==parent){\\n                v.push_back(make_pair(parent,i));    \\n          }     \\n      }\\n      if(adj[i][j]!=parent && favorite[i]!=adj[i][j]){\\n         \\n             sum=1+mp[adj[i][j]];\\n      if(sum>=c){\\n          c=sum;\\n      } \\n      }   \\n\\n     }\\n     mp[i]=c;\\n     return;\\n          \\n    }\\n     void check(vector<int> ad[],int node,vector<int>&vis,int a,int& maxi)\\n    {\\n        \\n        a++;\\n        vis[node]=a;\\n        for(auto x:ad[node])\\n        {\\n            if(vis[x]>0)\\n            {\\n                maxi = max(maxi,vis[node]-vis[x]+1);\\n            }\\n            else if(vis[x]==0)\\n            {\\n                check(ad,x,vis,a,maxi);\\n            }\\n        }\\n        vis[node]=-1;\\n        return;\\n    }\\n    \\n  \\n   \\n    int maximumInvitations(vector<int>& favorite) {\\n        \\n        int i,j;\\n        int ans=0;\\n        int n=favorite.size();\\n        if(n<=2){\\n            return n;\\n        }\\n        vector<vector<int>> adj(n);\\n        for(i=0;i<n;i++){\\n            adj[favorite[i]].push_back(i);\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<int>ad[n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[i]!=-1)\\n            {\\n                ad[i].push_back(favorite[i]);\\n            }\\n        }\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                int a = 0;\\n                check(ad,i,vis,a,maxi);\\n            }\\n        }\\n        ans=max(ans,maxi);\\n\\n    vector<int> visited(n);\\n    for(i=0;i<n;i++){\\n        visited[i]=0;\\n    }\\n   unordered_map<int,int> mp;\\n   vector<pair<int,int>> v;\\n   vector<int> v1;\\n   \\n   \\n   \\n   for(i=0;i<n;i++){\\n       visited[i]=0;\\n   }\\n   \\n  for(i=0;i<n;i++){\\n      if(visited[i]==0){\\n         \\n          fun(v,visited,i,adj,-1,mp,favorite);\\n      }\\n  }\\n  int score=0;\\n \\n  for(i=0;i<v.size();i++){\\n   \\n      score=score+mp[v[i].first]+mp[v[i].second];\\n  }\\nans=max(ans,score);\\n    \\n   return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804820,
                "title": "video-walkthrough-python-11-line-solution",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/iK_E_p-mj3A)\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        G, C, self.maxCycle = [set() for _ in range(len(favorite))], [0] * len(favorite), 0\\n        for u,favorite_u in enumerate(favorite): G[favorite_u].add(u)\\n        def dfs(u,c = 1):\\n            if C[u]: return C[u]\\n            C[u] = c\\n            for v in G[u]: self.maxCycle = max(c + 1 - dfs(v, c+1), self.maxCycle)\\n            C[u] = float(\\'inf\\')\\n            return C[u]\\n        for u in range(len(favorite)): dfs(u)\\n        def dfs(u,p): return 1 + max([dfs(v,u) for v in G[u] if v != p], default=0)\\n        return max( self.maxCycle, sum(dfs(u,v) + dfs(v,u) for u in range(len(favorite)) for v in G[u] if u in G[v])//2)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        G, C, self.maxCycle = [set() for _ in range(len(favorite))], [0] * len(favorite), 0\\n        for u,favorite_u in enumerate(favorite): G[favorite_u].add(u)\\n        def dfs(u,c = 1):\\n            if C[u]: return C[u]\\n            C[u] = c\\n            for v in G[u]: self.maxCycle = max(c + 1 - dfs(v, c+1), self.maxCycle)\\n            C[u] = float(\\'inf\\')\\n            return C[u]\\n        for u in range(len(favorite)): dfs(u)\\n        def dfs(u,p): return 1 + max([dfs(v,u) for v in G[u] if v != p], default=0)\\n        return max( self.maxCycle, sum(dfs(u,v) + dfs(v,u) for u in range(len(favorite)) for v in G[u] if u in G[v])//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522406,
                "title": "c-code-for-beginners-reference-for-future-me",
                "content": "![image](https://assets.leetcode.com/users/images/3f5392fe-b32c-4ca6-b28f-8a6ebe7d863c_1662187651.7187936.png)\\n\\n\\nTwo way cycle in my code means, that yellow colored nodes, which can extend from two favourite persons joined together. That is the reason we make a rev graph, so as to go backwards to look for the largest chain\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\n    list<int>* rev;\\npublic:\\n    void dfs(int node, vector<bool> &vis, vector<bool> &rec, vector<int> &par, int &res){\\n        rec[node]=true;\\n        vis[node]=true;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                par[nei]=node;\\n                dfs(nei,vis,rec,par,res);\\n            }\\n            else if(rec[nei]==true){ // CYCLE FOUND\\n                int vertex=node;\\n                int len=1;\\n                while(vertex!=nei){  // going backwards from vertex to neighbour it is cylic\\n                    len++;\\n                    vertex=par[vertex];\\n                }\\n                res=max(res,len);\\n            }\\n        }\\n        rec[node]=false;\\n    }\\n    \\n    int findLen(int node, int par, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=1;\\n        for(auto nei: rev[node]){\\n            if(par==nei || vis[nei]==true){\\n                continue;\\n            }\\n            res=max(res,1+findLen(nei,node,vis));\\n        }\\n        return res;\\n    }\\n    \\n    int maximumInvitations(vector<int>& fav) {\\n        int V=fav.size();\\n        adj=new list<int>[V];\\n        rev=new list<int>[V];\\n\\n        \\n        vector<bool> rec(V,false);\\n        vector<bool> vis(V,false);\\n        vector<bool> Rvis(V,false);\\n        vector<int> par(V,-1);\\n        \\n        for(int i=0;i<V;i++){\\n            adj[i].push_back(fav[i]);\\n            rev[fav[i]].push_back(i);\\n        }\\n        \\n        int res=0;\\n        int allTwoCycles=0;\\n        for(int i=0;i<V;i++){\\n            if(vis[i]==false){\\n                dfs(i,vis,rec,par,res);\\n            }a\\n            if(i<fav[i] && fav[fav[i]]==i){\\n                allTwoCycles+=(findLen(i,fav[i],Rvis)+findLen(fav[i],i,Rvis));  // we are expanding from the sides, we will be taking the largest chain. See, if a wanna sits with b, so a is directed towards b, so we make a reverse graph to find, how long the chain can extend from the node. WATCH THE DRAWING I ATTACHED IN THE NOTE\\n            }\\n        }\\n        return max(res,allTwoCycles);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    list<int>* adj;\\n    list<int>* rev;\\npublic:\\n    void dfs(int node, vector<bool> &vis, vector<bool> &rec, vector<int> &par, int &res){\\n        rec[node]=true;\\n        vis[node]=true;\\n        for(auto nei: adj[node]){\\n            if(vis[nei]==false){\\n                par[nei]=node;\\n                dfs(nei,vis,rec,par,res);\\n            }\\n            else if(rec[nei]==true){ // CYCLE FOUND\\n                int vertex=node;\\n                int len=1;\\n                while(vertex!=nei){  // going backwards from vertex to neighbour it is cylic\\n                    len++;\\n                    vertex=par[vertex];\\n                }\\n                res=max(res,len);\\n            }\\n        }\\n        rec[node]=false;\\n    }\\n    \\n    int findLen(int node, int par, vector<bool> &vis){\\n        vis[node]=true;\\n        int res=1;\\n        for(auto nei: rev[node]){\\n            if(par==nei || vis[nei]==true){\\n                continue;\\n            }\\n            res=max(res,1+findLen(nei,node,vis));\\n        }\\n        return res;\\n    }\\n    \\n    int maximumInvitations(vector<int>& fav) {\\n        int V=fav.size();\\n        adj=new list<int>[V];\\n        rev=new list<int>[V];\\n\\n        \\n        vector<bool> rec(V,false);\\n        vector<bool> vis(V,false);\\n        vector<bool> Rvis(V,false);\\n        vector<int> par(V,-1);\\n        \\n        for(int i=0;i<V;i++){\\n            adj[i].push_back(fav[i]);\\n            rev[fav[i]].push_back(i);\\n        }\\n        \\n        int res=0;\\n        int allTwoCycles=0;\\n        for(int i=0;i<V;i++){\\n            if(vis[i]==false){\\n                dfs(i,vis,rec,par,res);\\n            }a\\n            if(i<fav[i] && fav[fav[i]]==i){\\n                allTwoCycles+=(findLen(i,fav[i],Rvis)+findLen(fav[i],i,Rvis));  // we are expanding from the sides, we will be taking the largest chain. See, if a wanna sits with b, so a is directed towards b, so we make a reverse graph to find, how long the chain can extend from the node. WATCH THE DRAWING I ATTACHED IN THE NOTE\\n            }\\n        }\\n        return max(res,allTwoCycles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412086,
                "title": "solution-with-approach",
                "content": "**Approach:**\\n\\nTopics covered: Directed graph, Topologocal sorting and cycle length calculation\\n\\nThis is basically a graph problem, where every node has only a `single outgoing directed edge`. It can have `multiple incoming edges`. \\n\\nSome important observations are:\\n1. A cycle **`always`** exists in the graph\\n2. Our main aim is to **find the length of the cycle**\\n3. If the length is \\n\\ti. 2, then return the sum of all the chains(cycle+branches with the nodes involved in cycle) of length 2\\n\\tii. >2, then return only the length of the maximum cycle\\n4. There can be multiple cycles\\n5. For this, first calculate the length of longest chain for every node in a cycle, and store it\\n6. Next calculate the length of the cycle\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int n = fav.length, indegree[] = new int[n], maxLength = 0, cnt=1, dp[][] = new int[n][2], len2=0;\\n        \\n        LinkedList<Integer> q = new LinkedList<Integer>();\\n        \\n        for(int i:fav) \\n            ++indegree[i];\\n        \\n        for(int i=0; i<n; ++i) \\n            if(indegree[i] == 0)\\n                q.add(i);\\n        \\n        while(!q.isEmpty()) {\\n            int qn = q.size();\\n            ++cnt;\\n            for(int i=0; i<qn; ++i) {\\n                int front = q.removeFirst();\\n                --indegree[fav[front]];\\n                if(indegree[fav[front]] == 0)\\n                    q.add(fav[front]);\\n                else \\n                    dp[fav[front]][1] = cnt-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; ++i) \\n            if(indegree[i] > 0) {\\n                if(dp[i][0] == 0) \\n                    dfs(fav, i, dp, 1);\\n                \\n                if(dp[i][0] == 2) {\\n                    len2 += dp[i][1] + dp[i][0] + dp[fav[i]][1];\\n                    indegree[i] = indegree[fav[i]] = 0;\\n                    continue;\\n                }\\n                \\n                maxLength = Math.max(maxLength, dp[i][0]);\\n            }\\n        \\n        return Math.max(maxLength, len2);\\n    }\\n    \\n    private int dfs(int[] fav, int vertex, int[][] dp, int cnt) {\\n        if(dp[vertex][0] > 0) {\\n            dp[vertex][0] = cnt - dp[vertex][0];\\n            return dp[vertex][0];\\n        } \\n        \\n        dp[vertex][0] = cnt;\\n        dp[vertex][0] = dfs(fav, fav[vertex], dp, cnt+1);\\n        return dp[vertex][0];\\n    }\\n}\\n\\n// [1,0,0,2,1,4,7,8,9,6,7,10,8]\\n// [1,0,3,2,5,6,7,4,9,8,11,10,11,12,10]\\n```\\n\\n**TC**: O(n)\\n**SC**: O(n)\\n\\nPlz upvote if u hv liked! :-)",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int n = fav.length, indegree[] = new int[n], maxLength = 0, cnt=1, dp[][] = new int[n][2], len2=0;\\n        \\n        LinkedList<Integer> q = new LinkedList<Integer>();\\n        \\n        for(int i:fav) \\n            ++indegree[i];\\n        \\n        for(int i=0; i<n; ++i) \\n            if(indegree[i] == 0)\\n                q.add(i);\\n        \\n        while(!q.isEmpty()) {\\n            int qn = q.size();\\n            ++cnt;\\n            for(int i=0; i<qn; ++i) {\\n                int front = q.removeFirst();\\n                --indegree[fav[front]];\\n                if(indegree[fav[front]] == 0)\\n                    q.add(fav[front]);\\n                else \\n                    dp[fav[front]][1] = cnt-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; ++i) \\n            if(indegree[i] > 0) {\\n                if(dp[i][0] == 0) \\n                    dfs(fav, i, dp, 1);\\n                \\n                if(dp[i][0] == 2) {\\n                    len2 += dp[i][1] + dp[i][0] + dp[fav[i]][1];\\n                    indegree[i] = indegree[fav[i]] = 0;\\n                    continue;\\n                }\\n                \\n                maxLength = Math.max(maxLength, dp[i][0]);\\n            }\\n        \\n        return Math.max(maxLength, len2);\\n    }\\n    \\n    private int dfs(int[] fav, int vertex, int[][] dp, int cnt) {\\n        if(dp[vertex][0] > 0) {\\n            dp[vertex][0] = cnt - dp[vertex][0];\\n            return dp[vertex][0];\\n        } \\n        \\n        dp[vertex][0] = cnt;\\n        dp[vertex][0] = dfs(fav, fav[vertex], dp, cnt+1);\\n        return dp[vertex][0];\\n    }\\n}\\n\\n// [1,0,0,2,1,4,7,8,9,6,7,10,8]\\n// [1,0,3,2,5,6,7,4,9,8,11,10,11,12,10]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193064,
                "title": "2-options-as-the-hints-say-java",
                "content": "The hints make a lot of sense that there are only 2 options.\\n- optionA: We can either have a huge cycle (> 2 members)\\n- optionB: Or we can have a bunch of small cycle (= 2 members) + its longest chains.\\n\\nWe can do 2 DFS for each option and return the best.\\n- optionA - A standard DFS that returns the max depth of the tree rooted at a person in a 2-member cycle, then add them all up. This is leetcode easy level.\\n\\n- optionB - If there is a cycle, there will **not** be a smaller nested cycle inside because it will violate that each person has only 1 favorite person.                 \\nThis means that we can either go from tails into the cycle or from cycle into the tail. I went with the latter so we need to differentiate between the current DFS vs prior DFS -> seen array is of int type, not boolean.\\n```Java\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int n = fav.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        boolean[] mutual = new boolean[n];\\n        for (int i = 0; i < n; i++){\\n            mutual[i] = fav[fav[i]] == i;\\n            map.computeIfAbsent(fav[i], o -> new ArrayList<>()).add(i);\\n        }\\n\\n        int[] seen = new int[n];\\n        int optionA = 0;\\n        for (int i = 0; i < n; i++){\\n            if (mutual[i]){\\n                optionA += chainLen(i, mutual, seen, map);\\n            }\\n        }\\n\\n        int optionB = 0;\\n        for (int i = 0; i < n; i++){\\n            optionB = Math.max(optionB, cycleLen(i, i+2, seen, map));\\n        }\\n\\n        return Math.max(optionA, optionB);\\n    }\\n\\n    private int chainLen(int idx, boolean[] mutual, int[] seen, Map<Integer, List<Integer>> map){\\n        seen[idx]=1;\\n        int ans = 0;\\n        for (int next : map.getOrDefault(idx, List.of())){\\n            if (!mutual[next]){\\n                ans = Math.max(chainLen(next, mutual, seen, map), ans);\\n            }\\n        }\\n        return ans+1;\\n    }\\n\\n    private int cycleLen(int idx, int visited, int[] seen, Map<Integer, List<Integer>> map){\\n        if (seen[idx]==visited)\\n            return 0;\\n        if (seen[idx] > 0)\\n            return -1000000;\\n        int ans = -1000000;\\n        seen[idx]=visited;\\n        for (int next : map.getOrDefault(idx, List.of())){\\n            ans = Math.max(ans, cycleLen(next, visited, seen, map));\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int maximumInvitations(int[] fav) {\\n        int n = fav.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        boolean[] mutual = new boolean[n];\\n        for (int i = 0; i < n; i++){\\n            mutual[i] = fav[fav[i]] == i;\\n            map.computeIfAbsent(fav[i], o -> new ArrayList<>()).add(i);\\n        }\\n\\n        int[] seen = new int[n];\\n        int optionA = 0;\\n        for (int i = 0; i < n; i++){\\n            if (mutual[i]){\\n                optionA += chainLen(i, mutual, seen, map);\\n            }\\n        }\\n\\n        int optionB = 0;\\n        for (int i = 0; i < n; i++){\\n            optionB = Math.max(optionB, cycleLen(i, i+2, seen, map));\\n        }\\n\\n        return Math.max(optionA, optionB);\\n    }\\n\\n    private int chainLen(int idx, boolean[] mutual, int[] seen, Map<Integer, List<Integer>> map){\\n        seen[idx]=1;\\n        int ans = 0;\\n        for (int next : map.getOrDefault(idx, List.of())){\\n            if (!mutual[next]){\\n                ans = Math.max(chainLen(next, mutual, seen, map), ans);\\n            }\\n        }\\n        return ans+1;\\n    }\\n\\n    private int cycleLen(int idx, int visited, int[] seen, Map<Integer, List<Integer>> map){\\n        if (seen[idx]==visited)\\n            return 0;\\n        if (seen[idx] > 0)\\n            return -1000000;\\n        int ans = -1000000;\\n        seen[idx]=visited;\\n        for (int next : map.getOrDefault(idx, List.of())){\\n            ans = Math.max(ans, cycleLen(next, visited, seen, map));\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874017,
                "title": "c-connected-components",
                "content": "#### Prerequisite : Connected Components\\nAs the problem indicates that its a graph problem. So Atfirst, build a directed graph from the given information. Then, **What can be the possible solution?**\\n\\n### **One possibility can be the longest cycle/connected chain in the graph.**\\nSince the graph can contain many cylces, and all the nodes in the cycle will be strongly connected to each other. So, we can apply Tarjan\\'s algo to find all connected component and then we will take max of size of all the possible components.\\n![image](https://assets.leetcode.com/users/images/6896318c-eab9-4aa3-9b47-9d55b614756f_1647966839.2968485.png)\\nIn the above example, there are 3 Connected Components of size 4 ,3, and 1. So, possible ans is 4.\\n\\n### **2nd possibility is when graph contains one or multiple cycle of 2 nodes**\\nIn this case, all cycle of 2 nodes are independent from each other. So, first find all possible node falling in this categories, put into the **set**. One thing to note that if there are one/more linear chain connected to the elements in the **set**, then max possible lenght chain connected to **each elements** in the set can be included in our ans. Think about it!!. \\nSo, to find out the max possible lenght chain, just treat the elements in the set as root and do dfs to find the lenght of the chain. this can be done by first reversing the graph edges  followed by dfs.\\n\\nMaximum of the Two possibilities will be our ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    set<int> st;\\n    vector<int> re; int k = 1;\\n    int dfs(vector<vector<int>> &nums,vector<int>& vis,vector<int>& re,int in){\\n        if(vis[in]==2) return re[in];\\n        vis[in] = 1; re[in] = min(re[in],k++);\\n        for(int i=0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(vis[j]==2) continue;\\n            else if(vis[j]==1) re[in]=min(re[j],re[in]);\\n            else re[in] = min(re[in],dfs(nums,vis,re,j));\\n        }\\n        vis[in] = 2;\\n        return re[in];\\n    }\\n    int dfs2(vector<vector<int>> &nums,vector<int>& vis,int in,int r){\\n        if(st.find(in)!=st.end() && in!=r) return 0;\\n        if(vis[in]==2) return 0;\\n        vis[in] = 1; int re=0;\\n        for(int i = 0; i<nums[in].size();++i)\\n            re = max(re,dfs2(nums,vis,nums[in][i],r));\\n        vis[in] = 2;\\n        return re+1;\\n    }\\n    int maximumInvitations(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> nums(n+1),nums2(n+1);\\n        for(int i = 0; i<arr.size();++i){\\n            nums[i].push_back(arr[i]);\\n            nums2[arr[i]].push_back(i);\\n            if(arr[arr[i]]==i){\\n                st.insert(i); st.insert(arr[i]);\\n            }\\n        }\\n        vector<int> vis(n,-1),re(n+1,INT_MAX); int n1 = 0,n2=0;\\n        map<int,int> mp;\\n        for(int i = 0; i<n;++i){\\n            dfs(nums,vis,re,i);  mp[re[i]]++;\\n            n1 = max(n1,mp[re[i]]);\\n        }\\n        fill(vis.begin(),vis.end(),0);\\n        for(auto i = st.begin(); i!=st.end(); ++i){\\n            int k = *i;\\n            k = dfs2(nums2,vis,k,k);\\n            n2+=k;            \\n        }\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    set<int> st;\\n    vector<int> re; int k = 1;\\n    int dfs(vector<vector<int>> &nums,vector<int>& vis,vector<int>& re,int in){\\n        if(vis[in]==2) return re[in];\\n        vis[in] = 1; re[in] = min(re[in],k++);\\n        for(int i=0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(vis[j]==2) continue;\\n            else if(vis[j]==1) re[in]=min(re[j],re[in]);\\n            else re[in] = min(re[in],dfs(nums,vis,re,j));\\n        }\\n        vis[in] = 2;\\n        return re[in];\\n    }\\n    int dfs2(vector<vector<int>> &nums,vector<int>& vis,int in,int r){\\n        if(st.find(in)!=st.end() && in!=r) return 0;\\n        if(vis[in]==2) return 0;\\n        vis[in] = 1; int re=0;\\n        for(int i = 0; i<nums[in].size();++i)\\n            re = max(re,dfs2(nums,vis,nums[in][i],r));\\n        vis[in] = 2;\\n        return re+1;\\n    }\\n    int maximumInvitations(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> nums(n+1),nums2(n+1);\\n        for(int i = 0; i<arr.size();++i){\\n            nums[i].push_back(arr[i]);\\n            nums2[arr[i]].push_back(i);\\n            if(arr[arr[i]]==i){\\n                st.insert(i); st.insert(arr[i]);\\n            }\\n        }\\n        vector<int> vis(n,-1),re(n+1,INT_MAX); int n1 = 0,n2=0;\\n        map<int,int> mp;\\n        for(int i = 0; i<n;++i){\\n            dfs(nums,vis,re,i);  mp[re[i]]++;\\n            n1 = max(n1,mp[re[i]]);\\n        }\\n        fill(vis.begin(),vis.end(),0);\\n        for(auto i = st.begin(); i!=st.end(); ++i){\\n            int k = *i;\\n            k = dfs2(nums2,vis,k,k);\\n            n2+=k;            \\n        }\\n        return max(n1,n2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719016,
                "title": "c-dfs-solution-cycle-detection",
                "content": "```\\nclass Solution {\\n    vector<int> adj[100005], rev[100005], id = vector<int>(100005);\\n    bool vis[100005], recStack[100005];\\n    int cycleL, cycleR;\\n    \\n    // assigns increasing depth to each node\\n    void cycleSearch(int u, int i) {\\n        id[u] = i;  // depth factor\\n        vis[u] = recStack[u] = true;\\n        \\n        for(int v: adj[u]) {\\n            if(!vis[v]) {\\n                cycleSearch(v, i+1);\\n            } \\n            else if(recStack[v]) {\\n                // cycle found and we update the first and last cycle nodes\\n                cycleL = v, cycleR = u;\\n            }\\n        }\\n        \\n        // recStack is reset as we\\'re finding cycle in directed graph\\n        // imp: why vis is reset? (explained below) \\n        recStack[u] = vis[u] = false;\\n    }\\n    \\n    // this function runs on the reverse directed graph\\n    // key thing is it traverses through every node in that component\\n    // so we mark all as visited and count the max stretch we can make\\n    //      from current node required in later part of code\\n    int dfs(int u) {\\n        int ans = 0;\\n        vis[u] = true;\\n        \\n        for(int v: rev[u]) {\\n            if(!vis[v]) {\\n                ans = max(ans, dfs(v));\\n            }\\n        }\\n        // add one to consider current node as well\\n        return ans + 1;\\n    }\\n\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        set<int> corners;\\n        \\n        // fullCycleInvitees is the length of the longest cycle with len > 2\\n        // twoDislikedInvitees is the sum of all possible employee clusters\\n        //      wherein len == 2\\n        int fullCycleInvitees = 0, twoDislikedInvitees = 0;\\n        \\n        // create the directed and reverse directed graph\\n        for(int i=0; i<favorite.size(); i++) {\\n            adj[i].push_back(favorite[i]);\\n            rev[favorite[i]].push_back(i);\\n        }\\n        \\n        // traverse through every connected component\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                cycleSearch(i, 0);\\n                int len = id[cycleR] - id[cycleL] + 1;\\n                \\n                if(len > 2) {\\n                    // loop length is the max we get, rest we reject\\n                    // mark all related nodes as visited to avoid duplicacy\\n                    int tmp = dfs(i);\\n                    fullCycleInvitees = max(fullCycleInvitees, len);\\n                } \\n                else {\\n                    // when cycle length is just 2\\n                    // we calculate maximum stretch possible in reverse\\n                    //      directed graphs from both these nodes\\n                    int ans1 = 0, ans2 = 0;\\n                    vis[cycleL] = vis[cycleR] = true;\\n                    \\n                    // stretch left and right from the two nodes\\n                    for(int v: rev[cycleL]) {\\n                        if(v != cycleR) {\\n                            ans1 = max(ans1, dfs(v));\\n                        }\\n                    }\\n                    for(int v: rev[cycleR]) {\\n                        if(v != cycleL) {\\n                            ans2 = max(ans2, dfs(v));\\n                        }\\n                    }\\n                    twoDislikedInvitees += ans1 + ans2 + 2;\\n                }\\n            }\\n        }\\n        \\n        return max(twoDislikedInvitees, fullCycleInvitees);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> adj[100005], rev[100005], id = vector<int>(100005);\\n    bool vis[100005], recStack[100005];\\n    int cycleL, cycleR;\\n    \\n    // assigns increasing depth to each node\\n    void cycleSearch(int u, int i) {\\n        id[u] = i;  // depth factor\\n        vis[u] = recStack[u] = true;\\n        \\n        for(int v: adj[u]) {\\n            if(!vis[v]) {\\n                cycleSearch(v, i+1);\\n            } \\n            else if(recStack[v]) {\\n                // cycle found and we update the first and last cycle nodes\\n                cycleL = v, cycleR = u;\\n            }\\n        }\\n        \\n        // recStack is reset as we\\'re finding cycle in directed graph\\n        // imp: why vis is reset? (explained below) \\n        recStack[u] = vis[u] = false;\\n    }\\n    \\n    // this function runs on the reverse directed graph\\n    // key thing is it traverses through every node in that component\\n    // so we mark all as visited and count the max stretch we can make\\n    //      from current node required in later part of code\\n    int dfs(int u) {\\n        int ans = 0;\\n        vis[u] = true;\\n        \\n        for(int v: rev[u]) {\\n            if(!vis[v]) {\\n                ans = max(ans, dfs(v));\\n            }\\n        }\\n        // add one to consider current node as well\\n        return ans + 1;\\n    }\\n\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        set<int> corners;\\n        \\n        // fullCycleInvitees is the length of the longest cycle with len > 2\\n        // twoDislikedInvitees is the sum of all possible employee clusters\\n        //      wherein len == 2\\n        int fullCycleInvitees = 0, twoDislikedInvitees = 0;\\n        \\n        // create the directed and reverse directed graph\\n        for(int i=0; i<favorite.size(); i++) {\\n            adj[i].push_back(favorite[i]);\\n            rev[favorite[i]].push_back(i);\\n        }\\n        \\n        // traverse through every connected component\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                cycleSearch(i, 0);\\n                int len = id[cycleR] - id[cycleL] + 1;\\n                \\n                if(len > 2) {\\n                    // loop length is the max we get, rest we reject\\n                    // mark all related nodes as visited to avoid duplicacy\\n                    int tmp = dfs(i);\\n                    fullCycleInvitees = max(fullCycleInvitees, len);\\n                } \\n                else {\\n                    // when cycle length is just 2\\n                    // we calculate maximum stretch possible in reverse\\n                    //      directed graphs from both these nodes\\n                    int ans1 = 0, ans2 = 0;\\n                    vis[cycleL] = vis[cycleR] = true;\\n                    \\n                    // stretch left and right from the two nodes\\n                    for(int v: rev[cycleL]) {\\n                        if(v != cycleR) {\\n                            ans1 = max(ans1, dfs(v));\\n                        }\\n                    }\\n                    for(int v: rev[cycleR]) {\\n                        if(v != cycleL) {\\n                            ans2 = max(ans2, dfs(v));\\n                        }\\n                    }\\n                    twoDislikedInvitees += ans1 + ans2 + 2;\\n                }\\n            }\\n        }\\n        \\n        return max(twoDislikedInvitees, fullCycleInvitees);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669742,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0]*n\\n        for val in favorite:\\n            indegree[val]+=1\\n        roots = deque()\\n        length = [0]*n\\n        visited = [0]*n\\n        for index, val in enumerate(indegree):\\n            if not val:\\n                roots.append(index)\\n        while roots:\\n            cur = roots.popleft()\\n            visited[cur] = 1\\n            length[favorite[cur]] = max(length[cur]+1, length[favorite[cur]])\\n            indegree[favorite[cur]] -= 1\\n            if not indegree[favorite[cur]]:\\n                roots.append(favorite[cur])\\n        acyclic = 0\\n        cyclic = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                localLen = 0\\n                cur = i\\n                while not visited[cur]:\\n                    localLen+=1\\n                    visited[cur] = 1\\n                    cur = favorite[cur]\\n                if localLen == 2:\\n                    acyclic += localLen + length[i] + length[favorite[i]]\\n                else:\\n                    cyclic = max(cyclic, localLen)\\n        return max(cyclic, acyclic)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0]*n\\n        for val in favorite:\\n            indegree[val]+=1\\n        roots = deque()\\n        length = [0]*n\\n        visited = [0]*n\\n        for index, val in enumerate(indegree):\\n            if not val:\\n                roots.append(index)\\n        while roots:\\n            cur = roots.popleft()\\n            visited[cur] = 1\\n            length[favorite[cur]] = max(length[cur]+1, length[favorite[cur]])\\n            indegree[favorite[cur]] -= 1\\n            if not indegree[favorite[cur]]:\\n                roots.append(favorite[cur])\\n        acyclic = 0\\n        cyclic = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                localLen = 0\\n                cur = i\\n                while not visited[cur]:\\n                    localLen+=1\\n                    visited[cur] = 1\\n                    cur = favorite[cur]\\n                if localLen == 2:\\n                    acyclic += localLen + length[i] + length[favorite[i]]\\n                else:\\n                    cyclic = max(cyclic, localLen)\\n        return max(cyclic, acyclic)",
                "codeTag": "Java"
            },
            {
                "id": 1662459,
                "title": "c-topo-sort-dfs",
                "content": "```\\nclass Solution {\\n    int max_loop_size;\\n    int max_comb_size;\\n    \\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> indegree(n);\\n        for (auto i : favorite) ++indegree[i];\\n        \\n        // bfs + topological sort to find longest chain attached to each node\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (!indegree[i]) q.push(i) ;\\n        }\\n        vector<int> max_chain(n, 0);\\n        int l = 1;\\n        while (!q.empty()) {\\n            int k = q.size();\\n            while (k-- > 0) {\\n                int node = q.front();\\n                q.pop();\\n                if(--indegree[favorite[node]] == 0) q.push(favorite[node]);\\n                max_chain[favorite[node]] = max(max_chain[favorite[node]], l);\\n            }\\n            ++l;\\n        }\\n        \\n        // all the chains have been removed, use dfs to find the longest loop\\n        max_loop_size = 0, max_comb_size = 0;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; ++i) {\\n            int d = 0;\\n            if (indegree[i] && !visited[i]) dfs(i, d, visited, favorite, max_chain);\\n        }\\n        return max(max_loop_size, max_comb_size);\\n    }\\n    \\n    // find longest loop\\n    void dfs(int i, int& depth, vector<bool>& visited, const vector<int>& favorite, const vector<int>& max_chain) {\\n        if (visited[i]) {\\n            if (depth <= 2) { // loop size <= 2\\n                max_comb_size += depth + max_chain[i] + max_chain[favorite[i]];\\n            } else {\\n                max_loop_size = max(max_loop_size, depth);\\n            }\\n            return;\\n        }\\n        visited[i] = true;\\n        dfs(favorite[i], ++depth, visited, favorite, max_chain);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    int max_loop_size;\\n    int max_comb_size;\\n    \\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> indegree(n);\\n        for (auto i : favorite) ++indegree[i];\\n        \\n        // bfs + topological sort to find longest chain attached to each node\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (!indegree[i]) q.push(i) ;\\n        }\\n        vector<int> max_chain(n, 0);\\n        int l = 1;\\n        while (!q.empty()) {\\n            int k = q.size();\\n            while (k-- > 0) {\\n                int node = q.front();\\n                q.pop();\\n                if(--indegree[favorite[node]] == 0) q.push(favorite[node]);\\n                max_chain[favorite[node]] = max(max_chain[favorite[node]], l);\\n            }\\n            ++l;\\n        }\\n        \\n        // all the chains have been removed, use dfs to find the longest loop\\n        max_loop_size = 0, max_comb_size = 0;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; ++i) {\\n            int d = 0;\\n            if (indegree[i] && !visited[i]) dfs(i, d, visited, favorite, max_chain);\\n        }\\n        return max(max_loop_size, max_comb_size);\\n    }\\n    \\n    // find longest loop\\n    void dfs(int i, int& depth, vector<bool>& visited, const vector<int>& favorite, const vector<int>& max_chain) {\\n        if (visited[i]) {\\n            if (depth <= 2) { // loop size <= 2\\n                max_comb_size += depth + max_chain[i] + max_chain[favorite[i]];\\n            } else {\\n                max_loop_size = max(max_loop_size, depth);\\n            }\\n            return;\\n        }\\n        visited[i] = true;\\n        dfs(favorite[i], ++depth, visited, favorite, max_chain);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661850,
                "title": "java-bfs-dfs-with-a-graph-coloring-silly-oop-design",
                "content": "During the contest, the idea of using DFS to find max length cycle was intuitive (I\\'d say part2 of solution). However, finding a solution to part1 i.e. counting \\'chains\\' of employees connected with a cycle of length 2... pretty tough and I salute for those who solved it on time. Here is my solution with OOP design with graph coloring. I think that crucial point of this puzzle was: \\n```\\ngraph.get(favorite[i]).friends.add(i);\\n```\\n\\nbut not this:\\n```\\ngraph.get(i).friends.add(favorite[i]);\\n```\\n\\nBy building graph with the approach 1 we could perform BFS to count chains of employees. Also, we could use the following trick to find cycle of length 2:\\n```\\nif (favorite[favorite[i]] == i) { \\n```\\n\\nHere is the solution. I hope you will find it useful. \\n```\\nclass Solution {\\n    \\n    enum Color {GREEN, GRAY, BLACK};\\n    \\n    class Friend {\\n        int id;\\n        List<Integer> friends = new ArrayList<>();\\n        Color color = Color.GREEN;\\n        \\n        public Friend(int id) {this.id = id;}\\n        \\n        @Override\\n        public String toString() {\\n        \\treturn id+\":\"+friends.toString();\\n        }\\n    }\\n    \\n    int max = 0;\\n    public int maximumInvitations(int[] favorite) {\\n        Map<Integer, Friend> graph = new HashMap<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            graph.put(i, new Friend(i));\\n        }\\n        \\n        for (int i = 0; i < favorite.length; i++) {\\n        \\tgraph.get(favorite[i]).friends.add(i);\\n        }\\n        \\n        // first, we perform BFS to count chains of friends\\n        int sumOfChains = 0;\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (favorite[favorite[i]] == i) { \\t\\t// cycle of two\\n                \\n            \\tif (graph.get(i).color == Color.GREEN) {\\n\\t            \\tgraph.get(i).color = Color.BLACK;\\n\\t            \\tgraph.get(favorite[i]).color = Color.BLACK;\\n\\t            \\t\\n\\t            \\tint chain1 = bfs(i, graph);\\n\\t            \\tint chain2 = bfs(favorite[i], graph);\\n\\t            \\t\\n\\t            \\tsumOfChains += chain1 + chain2; \\n            \\t}\\n            } \\n        }\\n        \\n        // dfs is used in order to find cycle\\n        for (int i = 0; i < favorite.length; i++) {\\n             max = Math.max(max, dfs(graph, i, 0));\\n        }        \\n        \\n        \\n        return Math.max(max, sumOfChains);\\n    }\\n    \\n\\n    /**\\n     * BFS is used in order to count chain of employees within a \\'cycle of length=2\\'\\n     * @param empId - employee\\'s id\\n     * @param graph\\n     * @return\\n     */\\n    private int bfs(int empId, Map<Integer, Friend> graph) {\\n    \\tint friendsChain = 0;\\n    \\tQueue<Friend> q = new LinkedList<>();\\n    \\tq.add(graph.get(empId));\\n    \\tgraph.get(empId).color = Color.BLACK;\\n    \\twhile (!q.isEmpty()) {\\n    \\t\\t\\n    \\t\\tint size = q.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < size; i++) {\\n\\t    \\t\\tFriend f = q.poll();\\n\\t    \\t\\tfor (int friendId : f.friends) {\\n\\t    \\t\\t\\tFriend nextFriend = graph.get(friendId);\\n\\t    \\t\\t\\tif (nextFriend.color == Color.GREEN) {\\n\\t    \\t    \\t\\tnextFriend.color = Color.BLACK;\\n\\t    \\t\\t\\t\\tq.add(nextFriend);\\n\\t  \\t\\t\\t\\t\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n    \\t\\tfriendsChain++;\\n    \\t}\\n    \\t\\n    \\treturn friendsChain;\\n\\t}\\n\\n\\n\\t/**\\n\\t * DFS is performed to find a cycle. For instance a cycle of length 4: 8->5->6->7->8\\n\\t * @param graph\\n\\t * @param empId\\n\\t * @param employees - number of friends in \\'circle\\'\\n\\t * @return\\n\\t */\\n\\tprivate int dfs(Map<Integer, Friend> graph, int empId, int employees) {\\n        Friend emp = graph.get(empId);\\n        \\n        if (emp.color == Color.BLACK)\\n            return 0;\\n        \\n        if (emp.color == Color.GRAY) // cycle\\n            return employees;\\n        \\n        emp.color = Color.GRAY;\\n        employees += 1;\\n        int max = 0;\\n        for (int friendId : emp.friends) {\\n            max = Math.max(max, dfs(graph, friendId, employees));\\n        }\\n\\n        emp.color = Color.BLACK;\\n        return max;\\n    }\\n    \\n    public static void main(String[] args) {\\n\\t\\tint[] friends = {1,0,3,2,5,6,7,4,9,8,11,10,11,12,10};\\n//\\t\\tint[] friends = {1,0,0,2,1,4,7,8,9,6,7,10,8};\\n//\\t\\tint[] friends = {2,2,1,2};\\n//\\t\\tint[] friends = {1,0,1,4,1};\\n\\t\\tSolution s = new Solution();\\n\\t\\tSystem.out.println(s.maximumInvitations(friends));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ngraph.get(favorite[i]).friends.add(i);\\n```\n```\\ngraph.get(i).friends.add(favorite[i]);\\n```\n```\\nif (favorite[favorite[i]] == i) { \\n```\n```\\nclass Solution {\\n    \\n    enum Color {GREEN, GRAY, BLACK};\\n    \\n    class Friend {\\n        int id;\\n        List<Integer> friends = new ArrayList<>();\\n        Color color = Color.GREEN;\\n        \\n        public Friend(int id) {this.id = id;}\\n        \\n        @Override\\n        public String toString() {\\n        \\treturn id+\":\"+friends.toString();\\n        }\\n    }\\n    \\n    int max = 0;\\n    public int maximumInvitations(int[] favorite) {\\n        Map<Integer, Friend> graph = new HashMap<>();\\n        for (int i = 0; i < favorite.length; i++) {\\n            graph.put(i, new Friend(i));\\n        }\\n        \\n        for (int i = 0; i < favorite.length; i++) {\\n        \\tgraph.get(favorite[i]).friends.add(i);\\n        }\\n        \\n        // first, we perform BFS to count chains of friends\\n        int sumOfChains = 0;\\n        for (int i = 0; i < favorite.length; i++) {\\n            if (favorite[favorite[i]] == i) { \\t\\t// cycle of two\\n                \\n            \\tif (graph.get(i).color == Color.GREEN) {\\n\\t            \\tgraph.get(i).color = Color.BLACK;\\n\\t            \\tgraph.get(favorite[i]).color = Color.BLACK;\\n\\t            \\t\\n\\t            \\tint chain1 = bfs(i, graph);\\n\\t            \\tint chain2 = bfs(favorite[i], graph);\\n\\t            \\t\\n\\t            \\tsumOfChains += chain1 + chain2; \\n            \\t}\\n            } \\n        }\\n        \\n        // dfs is used in order to find cycle\\n        for (int i = 0; i < favorite.length; i++) {\\n             max = Math.max(max, dfs(graph, i, 0));\\n        }        \\n        \\n        \\n        return Math.max(max, sumOfChains);\\n    }\\n    \\n\\n    /**\\n     * BFS is used in order to count chain of employees within a \\'cycle of length=2\\'\\n     * @param empId - employee\\'s id\\n     * @param graph\\n     * @return\\n     */\\n    private int bfs(int empId, Map<Integer, Friend> graph) {\\n    \\tint friendsChain = 0;\\n    \\tQueue<Friend> q = new LinkedList<>();\\n    \\tq.add(graph.get(empId));\\n    \\tgraph.get(empId).color = Color.BLACK;\\n    \\twhile (!q.isEmpty()) {\\n    \\t\\t\\n    \\t\\tint size = q.size();\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < size; i++) {\\n\\t    \\t\\tFriend f = q.poll();\\n\\t    \\t\\tfor (int friendId : f.friends) {\\n\\t    \\t\\t\\tFriend nextFriend = graph.get(friendId);\\n\\t    \\t\\t\\tif (nextFriend.color == Color.GREEN) {\\n\\t    \\t    \\t\\tnextFriend.color = Color.BLACK;\\n\\t    \\t\\t\\t\\tq.add(nextFriend);\\n\\t  \\t\\t\\t\\t\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n    \\t\\t}\\n    \\t\\tfriendsChain++;\\n    \\t}\\n    \\t\\n    \\treturn friendsChain;\\n\\t}\\n\\n\\n\\t/**\\n\\t * DFS is performed to find a cycle. For instance a cycle of length 4: 8->5->6->7->8\\n\\t * @param graph\\n\\t * @param empId\\n\\t * @param employees - number of friends in \\'circle\\'\\n\\t * @return\\n\\t */\\n\\tprivate int dfs(Map<Integer, Friend> graph, int empId, int employees) {\\n        Friend emp = graph.get(empId);\\n        \\n        if (emp.color == Color.BLACK)\\n            return 0;\\n        \\n        if (emp.color == Color.GRAY) // cycle\\n            return employees;\\n        \\n        emp.color = Color.GRAY;\\n        employees += 1;\\n        int max = 0;\\n        for (int friendId : emp.friends) {\\n            max = Math.max(max, dfs(graph, friendId, employees));\\n        }\\n\\n        emp.color = Color.BLACK;\\n        return max;\\n    }\\n    \\n    public static void main(String[] args) {\\n\\t\\tint[] friends = {1,0,3,2,5,6,7,4,9,8,11,10,11,12,10};\\n//\\t\\tint[] friends = {1,0,0,2,1,4,7,8,9,6,7,10,8};\\n//\\t\\tint[] friends = {2,2,1,2};\\n//\\t\\tint[] friends = {1,0,1,4,1};\\n\\t\\tSolution s = new Solution();\\n\\t\\tSystem.out.println(s.maximumInvitations(friends));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661794,
                "title": "c-simple-chain-traversal-commented-code-faster-than-100",
                "content": "Fun problem!\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        /* Approach:\\n           - Interpret this as a directed graph with i pointing to to favorite[i]\\n           - Every path will end in a k-cycle\\n           - We have two choices for seating: Either a single k-cycle with k > 2 or\\n             all longest disjoint paths that end in a 2-cycle\\n        */\\n        int n = favorite.size(), max_cycle = 0;\\n        vector<int> step_number(n, 0), disjoint_id(n, 0);\\n        vector<int> disjoint_lengths;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Been here?\\n            if (disjoint_id[i])\\n                continue;\\n            \\n            // Do a DFS (which is really just following a chain) starting at i\\n            int node = i, counter = 0;\\n            do {\\n                step_number[node] = ++counter;\\n                node = favorite[node];\\n            } while (!disjoint_id[node] && !step_number[node]);\\n            \\n            // Case 1: We found a new path\\n            if (!disjoint_id[node]) {\\n                int cycle_length = counter - step_number[node] + 1;\\n                \\n                // Is it a k-cycle w/ k > 2?\\n                if (cycle_length > 2) {\\n                    max_cycle = max(max_cycle, cycle_length);\\n                    // Set disjoint_id to -1 to mark it as (leading to) a circle\\n                    for (int tmp = i; !disjoint_id[tmp]; tmp = favorite[tmp])\\n                        disjoint_id[tmp] = -1;\\n                } else {\\n                    // Found a new path ending in a 2-cycle\\n                    // Split the 2 cycle into the two nodes\\n                    disjoint_lengths.push_back(--counter);\\n                    int id = disjoint_lengths.size();\\n                    \\n                    // Mark it\\n                    for (int tmp = i; counter; tmp = favorite[tmp], --counter) {\\n                        disjoint_id[tmp] = id;\\n                        step_number[tmp] = counter;\\n                    }\\n                    \\n                    // And add the other one because we can also connect to it separately\\n                    disjoint_lengths.push_back(1);\\n                    step_number[favorite[node]] = 1;\\n                    disjoint_id[favorite[node]] = id + 1;\\n                }\\n            } else {\\n                // Case 2: We stumbled across an existing path\\n                int id = disjoint_id[node];\\n                int eff_counter = counter + step_number[node];\\n                if (id != -1)\\n                    disjoint_lengths[id - 1] = max(disjoint_lengths[id - 1], eff_counter);\\n                \\n                for (int tmp = i; !disjoint_id[tmp]; tmp = favorite[tmp]) {\\n                    disjoint_id[tmp] = id;\\n                    step_number[tmp] = eff_counter--;\\n                }\\n            }\\n            \\n        }\\n        \\n        return max(max_cycle, accumulate(disjoint_lengths.begin(), disjoint_lengths.end(), 0));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        /* Approach:\\n           - Interpret this as a directed graph with i pointing to to favorite[i]\\n           - Every path will end in a k-cycle\\n           - We have two choices for seating: Either a single k-cycle with k > 2 or\\n             all longest disjoint paths that end in a 2-cycle\\n        */\\n        int n = favorite.size(), max_cycle = 0;\\n        vector<int> step_number(n, 0), disjoint_id(n, 0);\\n        vector<int> disjoint_lengths;\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // Been here?\\n            if (disjoint_id[i])\\n                continue;\\n            \\n            // Do a DFS (which is really just following a chain) starting at i\\n            int node = i, counter = 0;\\n            do {\\n                step_number[node] = ++counter;\\n                node = favorite[node];\\n            } while (!disjoint_id[node] && !step_number[node]);\\n            \\n            // Case 1: We found a new path\\n            if (!disjoint_id[node]) {\\n                int cycle_length = counter - step_number[node] + 1;\\n                \\n                // Is it a k-cycle w/ k > 2?\\n                if (cycle_length > 2) {\\n                    max_cycle = max(max_cycle, cycle_length);\\n                    // Set disjoint_id to -1 to mark it as (leading to) a circle\\n                    for (int tmp = i; !disjoint_id[tmp]; tmp = favorite[tmp])\\n                        disjoint_id[tmp] = -1;\\n                } else {\\n                    // Found a new path ending in a 2-cycle\\n                    // Split the 2 cycle into the two nodes\\n                    disjoint_lengths.push_back(--counter);\\n                    int id = disjoint_lengths.size();\\n                    \\n                    // Mark it\\n                    for (int tmp = i; counter; tmp = favorite[tmp], --counter) {\\n                        disjoint_id[tmp] = id;\\n                        step_number[tmp] = counter;\\n                    }\\n                    \\n                    // And add the other one because we can also connect to it separately\\n                    disjoint_lengths.push_back(1);\\n                    step_number[favorite[node]] = 1;\\n                    disjoint_id[favorite[node]] = id + 1;\\n                }\\n            } else {\\n                // Case 2: We stumbled across an existing path\\n                int id = disjoint_id[node];\\n                int eff_counter = counter + step_number[node];\\n                if (id != -1)\\n                    disjoint_lengths[id - 1] = max(disjoint_lengths[id - 1], eff_counter);\\n                \\n                for (int tmp = i; !disjoint_id[tmp]; tmp = favorite[tmp]) {\\n                    disjoint_id[tmp] = id;\\n                    step_number[tmp] = eff_counter--;\\n                }\\n            }\\n            \\n        }\\n        \\n        return max(max_cycle, accumulate(disjoint_lengths.begin(), disjoint_lengths.end(), 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661338,
                "title": "javascript-graph-dfs-bfs",
                "content": "DFS: 885ms\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst mx = Math.max;\\n\\nlet g;\\nconst maximumInvitations = (a) => {\\n    let n = a.length, res = 0, visit = new Set();\\n    g = initializeGraph(n);\\n    for (let i = 0; i < n; i++) g[a[i]].push(i);\\n    for (let i = 0; i < n; i++) { // case 1: no cycle, result is the sum\\n        res += i < a[i] || a[a[i]] != i ? 0 : dfs(i, a[i]) + dfs(a[i], i);\\n    }\\n    for (let i = 0; i < n; i++) { // case 2: has cycle, result is the length of the cycle\\n        let j = i;\\n        if (!visit.has(i)) {\\n            let m = new Map();\\n            for (let k = 0; !visit.has(j); k++) {\\n                visit.add(j);\\n                m.set(j, k);\\n                j = a[j];\\n            }\\n            let tmp = m.size - m.get(j) || 0;\\n            res = mx(res, tmp);\\n        }\\n    }\\n    return res;\\n};\\n\\nconst dfs = (i, j) => {\\n    let max = 0;\\n    for (const child of g[i]) {\\n        max = mx(max, child == j ? 0 : dfs(child, j));\\n    }\\n    return 1 + max;\\n};\\n```\\nBFS: 1100ms, recommend to use bfs\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst mx = Math.max;\\n\\nconst maximumInvitations = (a) => {\\n    let n = a.length, res = 0, visit = new Set(), g = initializeGraph(n), deg = Array(n).fill(0), dp = Array(n).fill(1);\\n    for (let i = 0; i < n; i++) g[a[i]].push(i); // generate graph\\n    for (let i = 0; i < n; i++) { // case 2: has cycle, result is the length of the cycle\\n        if (!visit.has(i)) {\\n            let t = [];\\n            let j = i;\\n            while (!visit.has(j)) {\\n                visit.add(j);\\n                t.push(j);\\n                j = a[j];\\n            }\\n            for (let k = 0; k < t.length; k++) {\\n                if (t[k] == j) res = mx(res, t.length - k);\\n            }\\n        }\\n    }\\n\\t// case 1: no cycle, result is the sum\\n    let q = [];\\n    for (let i = 0; i < n; i++) deg[a[i]]++; // prepare indegree, mock topological Sort process\\n    for (let i = 0; i < n; i++) { // all nodes with no incoming edges \\n        if (deg[i] == 0) q.push(i);\\n    }\\n    while (q.length) { // start BFS\\n        let cur = q.shift();\\n        dp[a[cur]] = mx(dp[a[cur]], dp[cur] + 1);\\n\\t\\t // -- : remove an edge from cur to child, == 0 : child has no other incoming edges, add to q for next bfs\\n        if (--deg[a[cur]] == 0) q.push(a[cur]);\\n    }\\n    let sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[a[i]] == i && a[i] > i) {\\n            sum += dp[i] + dp[a[i]];\\n        }\\n    }\\n    return mx(sum, res);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst mx = Math.max;\\n\\nlet g;\\nconst maximumInvitations = (a) => {\\n    let n = a.length, res = 0, visit = new Set();\\n    g = initializeGraph(n);\\n    for (let i = 0; i < n; i++) g[a[i]].push(i);\\n    for (let i = 0; i < n; i++) { // case 1: no cycle, result is the sum\\n        res += i < a[i] || a[a[i]] != i ? 0 : dfs(i, a[i]) + dfs(a[i], i);\\n    }\\n    for (let i = 0; i < n; i++) { // case 2: has cycle, result is the length of the cycle\\n        let j = i;\\n        if (!visit.has(i)) {\\n            let m = new Map();\\n            for (let k = 0; !visit.has(j); k++) {\\n                visit.add(j);\\n                m.set(j, k);\\n                j = a[j];\\n            }\\n            let tmp = m.size - m.get(j) || 0;\\n            res = mx(res, tmp);\\n        }\\n    }\\n    return res;\\n};\\n\\nconst dfs = (i, j) => {\\n    let max = 0;\\n    for (const child of g[i]) {\\n        max = mx(max, child == j ? 0 : dfs(child, j));\\n    }\\n    return 1 + max;\\n};\\n```\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst mx = Math.max;\\n\\nconst maximumInvitations = (a) => {\\n    let n = a.length, res = 0, visit = new Set(), g = initializeGraph(n), deg = Array(n).fill(0), dp = Array(n).fill(1);\\n    for (let i = 0; i < n; i++) g[a[i]].push(i); // generate graph\\n    for (let i = 0; i < n; i++) { // case 2: has cycle, result is the length of the cycle\\n        if (!visit.has(i)) {\\n            let t = [];\\n            let j = i;\\n            while (!visit.has(j)) {\\n                visit.add(j);\\n                t.push(j);\\n                j = a[j];\\n            }\\n            for (let k = 0; k < t.length; k++) {\\n                if (t[k] == j) res = mx(res, t.length - k);\\n            }\\n        }\\n    }\\n\\t// case 1: no cycle, result is the sum\\n    let q = [];\\n    for (let i = 0; i < n; i++) deg[a[i]]++; // prepare indegree, mock topological Sort process\\n    for (let i = 0; i < n; i++) { // all nodes with no incoming edges \\n        if (deg[i] == 0) q.push(i);\\n    }\\n    while (q.length) { // start BFS\\n        let cur = q.shift();\\n        dp[a[cur]] = mx(dp[a[cur]], dp[cur] + 1);\\n\\t\\t // -- : remove an edge from cur to child, == 0 : child has no other incoming edges, add to q for next bfs\\n        if (--deg[a[cur]] == 0) q.push(a[cur]);\\n    }\\n    let sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[a[i]] == i && a[i] > i) {\\n            sum += dp[i] + dp[a[i]];\\n        }\\n    }\\n    return mx(sum, res);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661265,
                "title": "java-clean-code-explained",
                "content": "This is a graph question. **favourite[a] = b means there is a directed edge: a -> b.**\\n\\nIf you start from **a** (favourite[a] = b), then we come to **b** (favourite[b] = c), then we come to **c** (favourite[c] = d)..., we will end up with 4 cases:\\n1) **a -> b -> c -> d -> .... -> a** (clean self-cycle with whole length greater than 2)\\n2) **a -> b -> a** (clean self-cycle with whole length equals to 2)\\n3) **a -> b -> c -> d -> .... -> c** (dirty self-cycle with clean part length greater than 2, and a dirty chain (aka. a -> b -> c))\\n4) **a -> b -> c -> b** (dirty self-cycle with clean part length equals to 2, and a dirty chain (aka. a -> b))\\n\\nWe could either choose the longest case 1 or the longest case 3 (with only the filtered clean self-cycle) or the sum of all cases 2 and 4. Three choices, choose the best one.\\n\\n```\\nclass Solution\\n{\\n    public int maximumInvitations(int[] fs)\\n    {\\n        int max = 0;\\n        Set<Integer> visited = new HashSet<>();\\n\\t\\t// Using above case 3 as example, {a: [c, 2]; b: [c, 1]}\\n        Map<Integer, int[]> outgoingChainMap = new HashMap<>();\\n\\t\\t// Using above case 3 as example, {c: 2}\\n        Map<Integer, Integer> incomingChainMaxLengthMap = new HashMap<>();\\n        List<List<Integer>> twoPeopleGroups = new ArrayList<>();\\n        for (int i = 0; i < fs.length; i++)\\n        {\\n\\t\\t    // Both currsMap and currsList are tracking the cycle for the current iteration\\n            Map<Integer, Integer> currsMap = new HashMap<>();\\n            List<Integer> currsList = new ArrayList<>();\\n            maximumInvitationsHelper(i, fs, visited, currsMap, 0, currsList, outgoingChainMap, incomingChainMaxLengthMap);\\n\\t\\t\\t// The dirty part is deleted already in the above helper function\\n            if (currsMap.size() == 2)\\n            {\\n                List<Integer> twoPeopleGroup = currsMap.keySet().stream().collect(Collectors.toList());\\n                twoPeopleGroups.add(twoPeopleGroup);\\n            }\\n            else\\n            {\\n                max = Math.max(max, currsMap.size());\\n            }\\n        }\\n        int sum = 0;\\n        for (List<Integer> twoPeopleGroup : twoPeopleGroups)\\n        {\\n            sum += incomingChainMaxLengthMap.getOrDefault(twoPeopleGroup.get(0), 0) + incomingChainMaxLengthMap.getOrDefault(twoPeopleGroup.get(1), 0) + 2;\\n        }\\n        max = Math.max(max, sum);\\n        return max;\\n    }\\n    \\n    private void maximumInvitationsHelper(int curr, int[] fs, Set<Integer> visited, Map<Integer, Integer> currsMap, int idx, List<Integer> currsList, Map<Integer, int[]> outgoingChainMap, Map<Integer, Integer> incomingChainMaxLengthMap)\\n    {\\n\\t    // We encounter the cycle during this iteration\\n        if (currsMap.containsKey(curr))\\n        {\\n            visited.addAll(currsMap.keySet());\\n            int currIdx = currsMap.get(curr);\\n            for (int i = 0; i < currIdx; i++)\\n            {\\n                int num = currsList.get(i);\\n                currsMap.remove(num);\\n                outgoingChainMap.put(num, new int[]{curr, currIdx - i});\\n                incomingChainMaxLengthMap.put(curr, Math.max(incomingChainMaxLengthMap.getOrDefault(curr, 0), currIdx - i));\\n            }\\n            return;\\n        }\\n\\t\\t// We encounter the visited person from the previous iteration\\n        if (visited.contains(curr))\\n        {\\n            visited.addAll(currsMap.keySet());\\n            if (outgoingChainMap.containsKey(curr))\\n            {\\n                int[] val = outgoingChainMap.get(curr);\\n                for (int i = 0; i < currsList.size(); i++)\\n                {\\n                    outgoingChainMap.put(currsList.get(i), new int[]{val[0], currsList.size() - i + val[1]});\\n                    incomingChainMaxLengthMap.put(val[0], Math.max(incomingChainMaxLengthMap.getOrDefault(val[0], 0), currsList.size() - i + val[1]));\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < currsList.size(); i++)\\n                {\\n                    outgoingChainMap.put(currsList.get(i), new int[]{curr, currsList.size() - i});\\n                    incomingChainMaxLengthMap.put(curr, Math.max(incomingChainMaxLengthMap.getOrDefault(curr, 0), currsList.size() - i));\\n                }\\n            }\\n            currsMap.clear();\\n            return;\\n        }\\n        currsMap.put(curr, idx);\\n        currsList.add(curr);\\n        int next = fs[curr];\\n        maximumInvitationsHelper(next, fs, visited, currsMap, idx + 1, currsList, outgoingChainMap, incomingChainMaxLengthMap);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int maximumInvitations(int[] fs)\\n    {\\n        int max = 0;\\n        Set<Integer> visited = new HashSet<>();\\n\\t\\t// Using above case 3 as example, {a: [c, 2]; b: [c, 1]}\\n        Map<Integer, int[]> outgoingChainMap = new HashMap<>();\\n\\t\\t// Using above case 3 as example, {c: 2}\\n        Map<Integer, Integer> incomingChainMaxLengthMap = new HashMap<>();\\n        List<List<Integer>> twoPeopleGroups = new ArrayList<>();\\n        for (int i = 0; i < fs.length; i++)\\n        {\\n\\t\\t    // Both currsMap and currsList are tracking the cycle for the current iteration\\n            Map<Integer, Integer> currsMap = new HashMap<>();\\n            List<Integer> currsList = new ArrayList<>();\\n            maximumInvitationsHelper(i, fs, visited, currsMap, 0, currsList, outgoingChainMap, incomingChainMaxLengthMap);\\n\\t\\t\\t// The dirty part is deleted already in the above helper function\\n            if (currsMap.size() == 2)\\n            {\\n                List<Integer> twoPeopleGroup = currsMap.keySet().stream().collect(Collectors.toList());\\n                twoPeopleGroups.add(twoPeopleGroup);\\n            }\\n            else\\n            {\\n                max = Math.max(max, currsMap.size());\\n            }\\n        }\\n        int sum = 0;\\n        for (List<Integer> twoPeopleGroup : twoPeopleGroups)\\n        {\\n            sum += incomingChainMaxLengthMap.getOrDefault(twoPeopleGroup.get(0), 0) + incomingChainMaxLengthMap.getOrDefault(twoPeopleGroup.get(1), 0) + 2;\\n        }\\n        max = Math.max(max, sum);\\n        return max;\\n    }\\n    \\n    private void maximumInvitationsHelper(int curr, int[] fs, Set<Integer> visited, Map<Integer, Integer> currsMap, int idx, List<Integer> currsList, Map<Integer, int[]> outgoingChainMap, Map<Integer, Integer> incomingChainMaxLengthMap)\\n    {\\n\\t    // We encounter the cycle during this iteration\\n        if (currsMap.containsKey(curr))\\n        {\\n            visited.addAll(currsMap.keySet());\\n            int currIdx = currsMap.get(curr);\\n            for (int i = 0; i < currIdx; i++)\\n            {\\n                int num = currsList.get(i);\\n                currsMap.remove(num);\\n                outgoingChainMap.put(num, new int[]{curr, currIdx - i});\\n                incomingChainMaxLengthMap.put(curr, Math.max(incomingChainMaxLengthMap.getOrDefault(curr, 0), currIdx - i));\\n            }\\n            return;\\n        }\\n\\t\\t// We encounter the visited person from the previous iteration\\n        if (visited.contains(curr))\\n        {\\n            visited.addAll(currsMap.keySet());\\n            if (outgoingChainMap.containsKey(curr))\\n            {\\n                int[] val = outgoingChainMap.get(curr);\\n                for (int i = 0; i < currsList.size(); i++)\\n                {\\n                    outgoingChainMap.put(currsList.get(i), new int[]{val[0], currsList.size() - i + val[1]});\\n                    incomingChainMaxLengthMap.put(val[0], Math.max(incomingChainMaxLengthMap.getOrDefault(val[0], 0), currsList.size() - i + val[1]));\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < currsList.size(); i++)\\n                {\\n                    outgoingChainMap.put(currsList.get(i), new int[]{curr, currsList.size() - i});\\n                    incomingChainMaxLengthMap.put(curr, Math.max(incomingChainMaxLengthMap.getOrDefault(curr, 0), currsList.size() - i));\\n                }\\n            }\\n            currsMap.clear();\\n            return;\\n        }\\n        currsMap.put(curr, idx);\\n        currsList.add(curr);\\n        int next = fs[curr];\\n        maximumInvitationsHelper(next, fs, visited, currsMap, idx + 1, currsList, outgoingChainMap, incomingChainMaxLengthMap);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661156,
                "title": "python-code-and-intuition-for-my-logic-of-the-solution-o-n",
                "content": "So, the trick is the max number of employees (the required ans) is either \\n1. the max size cycle (>= 3 vertices)\\na1-a2-a3-a4...-an-a1 (a cycle with n >= 3)\\nThe max size cycle is a candidate for the answer\\n2. The max size knot structure where I define the \\'knot\\' case as a case where two vertices form a cycle.\\nin case of knot, say 0->1 and 1<-0, let\\'s represent by double bond 0 = 1\\nIn which case let the length of longest path coming in to 0 (upto and including 0) be x and coming in to 1 (upto and including 1) be y\\nthen we can seat x + y people together AND still have the ends of the path free for more people. Let\\'s call this structure of x + y people a knot structure.\\nso Knot structure is :\\na1-a2-a3-a4...ax-0=1-by-...-b2-b1\\nai points right wards and bi points left wards\\nNow a1 and b1 are still free, we can add more such knot structures to either of them.\\n\\nSo the total number of people in all such knot structures is the answer candidate for the knot case.\\n\\nPython code for this:\\n\\'N\\' means none case, that is those nodes can\\'t be part of either a cycle or a knot structure\\n\\nclass Solution:\\n    \\n    def dfs(self, ind, pos):\\n        if self.visited[ind]:\\n            if self.type[ind] == \\'C\\': # Cycle\\n                return \\'N\\', 0\\n            elif self.type[ind] == \\'K\\': # Knot\\n                return \\'K\\', [self.group[ind], self.knot[ind]]\\n            else: # None\\n                return \\'N\\', 0\\n        else:\\n            next_ind = self.favorite[ind]\\n            if next_ind in self.ancestors:\\n                if self.ancestors[next_ind] == pos - 1:\\n                    self.type[ind] = \\'K\\'\\n                    self.group[ind] = 2\\n                    self.visited[ind] = True\\n                    self.knot[ind] = ind\\n                    return \\'K\\', [1, next_ind]\\n                else:\\n                    self.type[ind] = \\'C\\'\\n                    self.group[ind] = pos - self.ancestors[next_ind] + 1\\n                    self.visited[ind] = True\\n                    return \\'C\\', [self.group[ind], self.ancestors[next_ind]]\\n            else:\\n                self.ancestors[ind] = pos\\n                group_type, info = self.dfs(next_ind, pos+1)\\n                if group_type == \\'K\\':\\n                    size, knot_end = info\\n                    self.group[ind] = size + 1\\n                    self.type[ind] = \\'K\\'\\n                    self.visited[ind] = True\\n                    if size + 1 == 2:\\n                        self.knot[ind] = ind\\n                    else:\\n                        self.knot[ind] = knot_end\\n                    return \\'K\\', [size + 1, knot_end]\\n                elif group_type == \\'C\\':\\n                    size, break_pos = info\\n                    self.visited[ind] = True\\n                    if pos >= break_pos:\\n                        self.group[ind] = size\\n                        self.type[ind] = \\'C\\'                        \\n                        return \\'C\\', info\\n                    else:\\n                        self.group[ind] = 0\\n                        self.type[ind] = \\'N\\'\\n                        return \\'N\\', 0\\n                else:\\n                    self.group[ind] = 0\\n                    self.type[ind] = \\'N\\'\\n                    self.visited[ind] = True\\n                    return \\'N\\', 0\\n\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        self.visited = [False for _ in range(n)]\\n        self.group   = [0 for _ in range(n)]\\n        self.type    = [\\'N\\' for _ in range(n)]\\n        self.knot    = [-1 for _ in range(n)]\\n        self.favorite = favorite\\n        for ind in range(n):\\n            if self.visited[ind]:\\n                continue\\n            self.ancestors = {}\\n            self.dfs(ind, 0)\\n        \\n        ans = max(self.group) # Max Cycle or Max path ending in knot        \\n        max_knot_length = collections.defaultdict(int)\\n        for ind in range(n):\\n            if self.type[ind] == \\'K\\':\\n                parent = self.knot[ind]\\n                max_knot_length[parent] = max(max_knot_length[parent], self.group[ind] - 1)\\n        # Another case is combining knot strings together\\n        num_knot_pairs = sum(max_knot_length.values())\\n        ans = max(ans, num_knot_pairs)\\n        return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    \\n    def dfs(self, ind, pos):\\n        if self.visited[ind]:\\n            if self.type[ind] == \\'C\\': # Cycle\\n                return \\'N\\', 0\\n            elif self.type[ind] == \\'K\\': # Knot\\n                return \\'K\\', [self.group[ind], self.knot[ind]]\\n            else: # None\\n                return \\'N\\', 0\\n        else:\\n            next_ind = self.favorite[ind]\\n            if next_ind in self.ancestors:\\n                if self.ancestors[next_ind] == pos - 1:\\n                    self.type[ind] = \\'K\\'\\n                    self.group[ind] = 2\\n                    self.visited[ind] = True\\n                    self.knot[ind] = ind\\n                    return \\'K\\', [1, next_ind]\\n                else:\\n                    self.type[ind] = \\'C\\'\\n                    self.group[ind] = pos - self.ancestors[next_ind] + 1\\n                    self.visited[ind] = True\\n                    return \\'C\\', [self.group[ind], self.ancestors[next_ind]]\\n            else:\\n                self.ancestors[ind] = pos\\n                group_type, info = self.dfs(next_ind, pos+1)\\n                if group_type == \\'K\\':\\n                    size, knot_end = info\\n                    self.group[ind] = size + 1\\n                    self.type[ind] = \\'K\\'\\n                    self.visited[ind] = True\\n                    if size + 1 == 2:\\n                        self.knot[ind] = ind\\n                    else:\\n                        self.knot[ind] = knot_end\\n                    return \\'K\\', [size + 1, knot_end]\\n                elif group_type == \\'C\\':\\n                    size, break_pos = info\\n                    self.visited[ind] = True\\n                    if pos >= break_pos:\\n                        self.group[ind] = size\\n                        self.type[ind] = \\'C\\'                        \\n                        return \\'C\\', info\\n                    else:\\n                        self.group[ind] = 0\\n                        self.type[ind] = \\'N\\'\\n                        return \\'N\\', 0\\n                else:\\n                    self.group[ind] = 0\\n                    self.type[ind] = \\'N\\'\\n                    self.visited[ind] = True\\n                    return \\'N\\', 0\\n\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        self.visited = [False for _ in range(n)]\\n        self.group   = [0 for _ in range(n)]\\n        self.type    = [\\'N\\' for _ in range(n)]\\n        self.knot    = [-1 for _ in range(n)]\\n        self.favorite = favorite\\n        for ind in range(n):\\n            if self.visited[ind]:\\n                continue\\n            self.ancestors = {}",
                "codeTag": "Java"
            },
            {
                "id": 4041821,
                "title": "cpp-linear-traversal-toposort-dp-with-detailed-approach",
                "content": "# Intuition\\nLet\\'s curate a directed graph from given data where each node/person  directs to their preferred node/person with whom they wish to sit, now they will attend the meeting iff they get to sit next to their favorite person at the table. The fact that the table is to be surrounded suggests the presence of a cyclic link of some sort in the arrangements.\\n\\nEVALUATING POSSIBLE ARRANGEMENTS :\\n\\nCASE 1: **DEPENDENCY IS CIRCULAR,AND SO IS ORDERING.**\\n- Node completely surround the table and hence no further node can blend in.\\n*ex. : (0--> 1 --> 2 --> 3 --> 4 --> 0) (5 node cylic dependency)*\\n\\n\\nCASE 2(variation of case 1): **CYCLE CONSISTS OF 2 NODES.**\\n\\n- Nodes does not need to cover the whole table as placed side-by-side would just suffice, when placed adjacent to one-another both are capable of introducing companion nodes(a path of nodes exhibiting linear dependency) on their own.\\n*ex. :  0 --> 1 --> (2 <---> 3) <-- 4 <-- 5 <-- 6 (2 node cylic dependency)*\\n- Again a table can support multiple such arrangements and still meet requirements.\\n*ex. : 0--> (1 <---> 2) , (3 <---> 4) , (5 <--> 6) <-- 7 <-- 8 (three 2 node cylic dependency)*\\n            \\n BOTH OF THE CASES CAN CO-EXIST IN A PROBLEM, AND HENCE WE NEED TO EVALUATE THE OPTIMAL ONE.\\n    \\n---\\n\\n# Approach\\nAs the given graph is successor traversal becomes sequential(linear), complex dfs travesal can be avoided.\\n\\n##### CASE 1 : **Finding longest length cycle..**\\nFinding longest length cycle in digraph is NP-hard problem and can be solved by:\\n**reference :* [*Enumerating elementary circuits of a directed graph*](https://blog.mister-muffin.de/2012/07/04/enumerating-elementary-circuits-of-a-directed_graph/)\\n\\n- Tarjan\\'s algorithm, TC : $$O((n*e)*(c+1))$$\\n- Johnson\\'s algorithm, TC :  $$O((n+e)*(c+1))$$ \\n\\n=>*here, n is the number of vertices, e is the number of edges and c is the number of cycles in the graph.*\\n**In our case graph is successor and every node is either part of a cycle or leads to one and hence can be solved in linear time** via. linear/sequential (dfs) traversal. i.e., $$O(n)$$.\\n\\nCYCLE DETECTION :\\nThe cycle can be detected with the help of path-visited and node visited array that is whether or not the current node is already visited or not and if so then whether or not it is part of current path, if the node is visited and is also a part of current path then cycle is encountered.\\n\\nSIZE OF CYCLE :\\nThe number of nodes visited up untill now is calculated with the help of an offset, which is initialized to \\'0\\' and is similar to the offset in-time of Euler\\'s tour. The offset is incremented each time a node is visited and the offset at previously visited node is also maintained in order to calculate the size of cycle.\\n\\n\\n##### CASE 1 : **Cycle of 2 nodes..**\\nCYCLE OF TWO :\\nEither the aforementioned approach or a straightforward condition may be used to determine whether the graph contains cycles of size 2.\\n    **`favourite [ favourite [ i ] ] = = i`**\\n    =>*here \\'favourite\\' refers to edge extended/child of \\'i\\'*\\nIf cycle (of two) is detected, then nodes making up the cycle are noted for future reference.\\n\\nFREELOADERS :\\nThe freeloaders or the group of node composing longest path ending at the node that are part of \\'cycle of two\\'.This can be done via dynamic programming on top of topological sorting with base case of node with indegree of 0 holding value 1,dp terminates at the node viz. part of the cycle of 2.\\nSummation of longest path length ending at the nodes that are part of cycle of 2 would give us the case 2 ans.\\n\\n$$ $$\\n`FINAL ANS= MAX(CASE 1 ANS, CASE 2 ANS)`\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favourite) {\\n\\n        //CASE 2\\n        //duoNode => member node of a cyclic path consisting of two nodes.\\n        vector<bool>duoNode(favourite.size(),false);\\n        vector<int>indegree(favourite.size(),0);\\n        vector<int>maxPathAt(favourite.size(),1);\\n        for(int i=0;i<favourite.size();i++){\\n            indegree[favourite[i]]++;\\n            if(favourite[favourite[i]]==i){\\n                duoNode[i]=true;\\n                duoNode[favourite[i]]=true;\\n            }\\n        }\\n        int ans=0;\\n        vector<bool>visited(favourite.size(),false);\\n        for(int i=0;i<favourite.size();i++){\\n            if(!indegree[i]){\\n                int cur=i;\\n                while(!duoNode[cur]&&!visited[cur]&&!indegree[cur]){\\n                    visited[cur]=true;\\n                    maxPathAt[favourite[cur]]=max(maxPathAt[favourite[cur]],maxPathAt[cur]+1);\\n                    cur=favourite[cur];\\n                    indegree[cur]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<favourite.size();i++){\\n            if(duoNode[i]){\\n                ans+=maxPathAt[i];\\n            }\\n        }\\n\\n\\n        //CASE 1\\n        \\n        int offset=1;\\n        fill(maxPathAt.begin(),maxPathAt.end(),0);\\n        fill(visited.begin(),visited.end(),false);\\n        int * offsetAt = &maxPathAt[0];\\n        for(int i=0;i<favourite.size();i++){\\n            if(!visited[i]){\\n                int prev,cur=i;\\n                while(!offsetAt[cur]){\\n                    offsetAt[cur]=offset++;\\n                    prev=cur;\\n                    cur=favourite[cur];\\n                }\\n                if(!visited[cur]){\\n                    ans=max(ans,offsetAt[prev]-offsetAt[cur]+1);\\n                }\\n                cur=i;\\n                while(!visited[cur]){\\n                    visited[cur]=true;\\n                    cur=favourite[cur];\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favourite) {\\n\\n        //CASE 2\\n        //duoNode => member node of a cyclic path consisting of two nodes.\\n        vector<bool>duoNode(favourite.size(),false);\\n        vector<int>indegree(favourite.size(),0);\\n        vector<int>maxPathAt(favourite.size(),1);\\n        for(int i=0;i<favourite.size();i++){\\n            indegree[favourite[i]]++;\\n            if(favourite[favourite[i]]==i){\\n                duoNode[i]=true;\\n                duoNode[favourite[i]]=true;\\n            }\\n        }\\n        int ans=0;\\n        vector<bool>visited(favourite.size(),false);\\n        for(int i=0;i<favourite.size();i++){\\n            if(!indegree[i]){\\n                int cur=i;\\n                while(!duoNode[cur]&&!visited[cur]&&!indegree[cur]){\\n                    visited[cur]=true;\\n                    maxPathAt[favourite[cur]]=max(maxPathAt[favourite[cur]],maxPathAt[cur]+1);\\n                    cur=favourite[cur];\\n                    indegree[cur]--;\\n                }\\n            }\\n        }\\n        for(int i=0;i<favourite.size();i++){\\n            if(duoNode[i]){\\n                ans+=maxPathAt[i];\\n            }\\n        }\\n\\n\\n        //CASE 1\\n        \\n        int offset=1;\\n        fill(maxPathAt.begin(),maxPathAt.end(),0);\\n        fill(visited.begin(),visited.end(),false);\\n        int * offsetAt = &maxPathAt[0];\\n        for(int i=0;i<favourite.size();i++){\\n            if(!visited[i]){\\n                int prev,cur=i;\\n                while(!offsetAt[cur]){\\n                    offsetAt[cur]=offset++;\\n                    prev=cur;\\n                    cur=favourite[cur];\\n                }\\n                if(!visited[cur]){\\n                    ans=max(ans,offsetAt[prev]-offsetAt[cur]+1);\\n                }\\n                cur=i;\\n                while(!visited[cur]){\\n                    visited[cur]=true;\\n                    cur=favourite[cur];\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034742,
                "title": "employee-invitations-a-java-solution-to-maximize-meeting-attendance",
                "content": "# Intuition\\nTo solve this problem, we can use a combination of graph theory and dynamic programming. The idea is to model the relationships between employees as a directed graph, where each employee is a node, and the favorite person of an employee is the target node of an edge.\\n\\nWe can then use topological sorting to find acyclic parts of the graph, as those parts can be fully invited. This is because in acyclic parts, there are no circular dependencies among employees\\' favorite persons. For each acyclic part, we can count the number of employees it contains and add that count to the result.\\n\\nAfter processing the acyclic parts, we are left with loops in the graph, where circular dependencies exist. For each loop, we can traverse it to find its length. If the loop has a length of 2, it means that there are two employees, and we can invite both of them. If the loop has a length greater than 2, we can invite only one employee from that loop (as the rest would break the no-circular-dependency rule).\\n\\nWe can also keep track of the longest path leading to each employee exclusively using dynamic programming. This will help us determine the maximum number of employees that can be invited to the meeting while satisfying the conditions.\\n\\nThe final result is the sum of the counts obtained from acyclic parts, the counts for loops of length 2, and the longest paths for loops of length greater than 2.\\n\\nThe intuition behind this approach is to break down the problem into acyclic and cyclic parts, considering the relationships between employees\\' favorite persons and using dynamic programming to optimize the solution.\\n# Approach\\n1. Initialize variables:\\n    - n is the number of employees.\\n    - visited is a boolean array to mark employees as visited.\\n    - indegrees is an array to store the in-degrees (incoming edges) for each employee.\\n    - favorite is the array representing the favorite person of each employee.\\n    - q is a queue for topological sorting.\\n    - dp is an array to store the longest path leading to each employee exclusively.\\n    - result is the count of employees invited to acyclic parts.\\n    - result2 is the count of employees invited to loops of length 2.\\n\\n2. Calculate indegrees:\\n    - Iterate through the favorite array and increment the indegree of the corresponding favorite person for each employee.\\n\\n3. Perform topological sorting:\\n    - Initialize the queue q.\\n    - Iterate through the employees, and if an employee has an indegree of 0 (i.e., no incoming edges), mark them as visited and enqueue them.\\n    - While the queue is not empty, process each employee:\\n            - Update the longest path dp for the favorite person of the employee.\\n            - Decrement the indegree of the favorite person.\\n            - If the indegree becomes 0, mark the favorite person as visited and enqueue them.\\n\\n4. Calculate counts for acyclic parts:\\n    - Iterate through the employees and check if they have been visited. If not, it means they are part of a loop.\\n    - For visited employees, calculate the length of the acyclic part they belong to and add it to the result.\\n\\n5. Calculate counts for loops:\\n    - Iterate through the employees and check if they have been visited. If not, it means they are part of a loop.\\n    - For each unvisited employee, traverse the loop to find its length.\\n    - If the loop has a length of 2, increment result2.\\n    - If the loop has a length greater than 2, ignore the extra employees.\\n\\n6. Calculate the final result:\\n    - The final result is the sum of result (counts for acyclic parts), result2 (counts for loops of length 2), and the maximum value in the dp array (longest paths for loops of length greater than 2).\\n\\n7. Return the final result as the maximum number of employees that can be invited.\\n\\nThis approach ensures that employees are invited based on the relationships between their favorite persons while considering both acyclic and cyclic parts of the graph.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n), where n is the number of employees. This is because we iterate through the employees and their favorite persons once to calculate indegrees and perform topological sorting, and then we iterate through them again to calculate the counts for acyclic parts and loops. All these operations are linear in terms of the number of employees, resulting in an overall time complexity of O(n).\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n), where n is the number of employees. We use several arrays to store information about the employees, such as visited, indegrees, and dp, each of which has a length of n. Additionally, we use a queue to perform the topological sort, which can have at most n elements in it. Therefore, the overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        boolean[] visited = new boolean[n];\\n        // Topological sort to find acyclic part.\\n        int[] indegrees = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int j = favorite[i]; // i -> favorite[i].\\n            ++indegrees[j];\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (indegrees[i] == 0) {\\n                visited[i] = true;\\n                q.offer(i);\\n            }\\n        }\\n        \\n        int[] dp = new int[n]; // dp[i] is the longest path leading to i exclusively.\\n        while (!q.isEmpty()) {\\n            int i = q.poll();\\n            int j = favorite[i];\\n            dp[j] = Math.max(dp[j], dp[i] + 1);\\n            if (--indegrees[j] == 0) {\\n                visited[j] = true;\\n                q.offer(j);\\n            }\\n        }\\n        \\n        // Now not visited nodes are all loops. Check each loop\\'s length.\\n        int result = 0; // Loops of length > 2.\\n        int result2 = 0; // Loops of length 2 and paths leading to both nodes.\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int length = 0;\\n                for (int j = i; !visited[j]; j = favorite[j]) {\\n                    visited[j] = true;\\n                    ++length;\\n                }\\n                if (length == 2) {\\n                    result2 += 2 + dp[i] + dp[favorite[i]];\\n                } else {\\n                    result = Math.max(result, length);\\n                }\\n            }\\n        }\\n        \\n        return Math.max(result, result2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        boolean[] visited = new boolean[n];\\n        // Topological sort to find acyclic part.\\n        int[] indegrees = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            int j = favorite[i]; // i -> favorite[i].\\n            ++indegrees[j];\\n        }\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; ++i) {\\n            if (indegrees[i] == 0) {\\n                visited[i] = true;\\n                q.offer(i);\\n            }\\n        }\\n        \\n        int[] dp = new int[n]; // dp[i] is the longest path leading to i exclusively.\\n        while (!q.isEmpty()) {\\n            int i = q.poll();\\n            int j = favorite[i];\\n            dp[j] = Math.max(dp[j], dp[i] + 1);\\n            if (--indegrees[j] == 0) {\\n                visited[j] = true;\\n                q.offer(j);\\n            }\\n        }\\n        \\n        // Now not visited nodes are all loops. Check each loop\\'s length.\\n        int result = 0; // Loops of length > 2.\\n        int result2 = 0; // Loops of length 2 and paths leading to both nodes.\\n        for (int i = 0; i < n; ++i) {\\n            if (!visited[i]) {\\n                int length = 0;\\n                for (int j = i; !visited[j]; j = favorite[j]) {\\n                    visited[j] = true;\\n                    ++length;\\n                }\\n                if (length == 2) {\\n                    result2 += 2 + dp[i] + dp[favorite[i]];\\n                } else {\\n                    result = Math.max(result, length);\\n                }\\n            }\\n        }\\n        \\n        return Math.max(result, result2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006690,
                "title": "fast-solution-without-additional-graph-using-floyd-s-cycle-detection-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'re given an oriented graph in which every vertex has exactly one vertex coming out of it. In the final arrangement of employees, each vertex must sit next to its child.\\n\\nAfter a bit of thinking one realizes that the only possible arrangement is either a cycle or multiple chains one after the other.\\nBy chain here we mean a chain with the last vertex going into the one before, i.e. a cycle of length two with a tail.\\n\\nThere is also a tricky case where we could have one cycle of length 2, say (0, 1) and chains (3, 2, 0, 1), (5, 4, 1, 0). In this case we can arrange them like (3, 2, 0, 1, 4, 5).\\n\\nSo the answer is max(max cycle, sum of cyc of len 2),\\nwhere for cycles of length 2 we sum over longest tails, and the tails may originate from both ends of the 2-cycle.\\n\\n**Useful observations:**\\n1. If the graph is not connected, then the answer is the maximum among all connected components.\\n2. In one connected component there is exactly one cycle.\\n\\nWe use Floyd\\'s algorithm to detect cycles. See more at https://en.wikipedia.org/wiki/Cycle_detection\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe detect cycles, find its length and update the max cycle if larger cycle is found. The tricky part comes with the addition of 2-cycles, there we store the \"tail length\" from each node going into the two cycle while updating the maximum tail length for each particular 2-cycle. We treat (a, b) differently from (b, a) for reasons described earlier, and later subtract len(pairs) to account for counting pairs twice.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        pairs = set()\\n        for i, j in enumerate(favorite):\\n            if favorite[j] == i:\\n                pairs.add((i, j))\\n        chain_lens_from_elem = {}\\n        chain_lens_from_pair = {(i, j): 2 for (i, j) in pairs}\\n\\n        seen = set()\\n        type_cyc = 1\\n        for i in range(n):\\n            if i in seen: continue\\n            slow_iter, fast_iter = i, i\\n            skip = False\\n            while True:\\n                slow_iter = favorite[slow_iter]\\n                fast_iter = favorite[favorite[fast_iter]]\\n                if slow_iter in seen:\\n                    skip = True\\n                    break\\n                if slow_iter == fast_iter: break\\n            if skip:\\n                iter = i\\n                tail = 0\\n                while iter not in seen:\\n                    seen.add(iter)\\n                    iter = favorite[iter]\\n                    tail += 1\\n                \\n                if iter in chain_lens_from_elem:\\n                    seen_start = iter\\n                    old_len, pair = chain_lens_from_elem[seen_start]\\n                    if seen_start == pair[1]:\\n                        pair = (pair[1], pair[0])\\n                    chain_lens_from_pair[pair] = max(chain_lens_from_pair[pair], old_len + tail)\\n                    iter = i\\n                    while iter != seen_start:\\n                        chain_lens_from_elem[iter] = (old_len + tail, pair)\\n                        iter = favorite[iter]\\n                        tail -= 1\\n\\n                continue\\n\\n            cycle_start = i\\n            tail_len = 0\\n            while cycle_start != slow_iter:\\n                seen.add(cycle_start)\\n                cycle_start = favorite[cycle_start]\\n                slow_iter = favorite[slow_iter]\\n                tail_len += 1\\n            seen.add(cycle_start)\\n            \\n            iter = favorite[cycle_start]\\n            cyc_len = 1\\n            while iter != cycle_start:\\n                seen.add(iter)\\n                cyc_len += 1\\n                iter = favorite[iter]\\n            \\n            type_cyc = max(type_cyc, cyc_len)\\n\\n            if cyc_len == 2:\\n                pair = (cycle_start, favorite[cycle_start])\\n                chain_lens_from_pair[pair] = max(chain_lens_from_pair[pair], 2 + tail_len)\\n                chain_lens_from_elem[pair[0]] = (2, pair)\\n                chain_lens_from_elem[pair[1]] = (2, pair)\\n                iter = i\\n                while iter != cycle_start:\\n                    chain_lens_from_elem[iter] = (2 + tail_len, pair)\\n                    iter = favorite[iter]\\n                    tail_len -= 1\\n        \\n        type_chain = sum(tail_len for (pair, tail_len) in chain_lens_from_pair.items()) - len(pairs)\\n        \\n        return max(type_cyc, type_chain)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        pairs = set()\\n        for i, j in enumerate(favorite):\\n            if favorite[j] == i:\\n                pairs.add((i, j))\\n        chain_lens_from_elem = {}\\n        chain_lens_from_pair = {(i, j): 2 for (i, j) in pairs}\\n\\n        seen = set()\\n        type_cyc = 1\\n        for i in range(n):\\n            if i in seen: continue\\n            slow_iter, fast_iter = i, i\\n            skip = False\\n            while True:\\n                slow_iter = favorite[slow_iter]\\n                fast_iter = favorite[favorite[fast_iter]]\\n                if slow_iter in seen:\\n                    skip = True\\n                    break\\n                if slow_iter == fast_iter: break\\n            if skip:\\n                iter = i\\n                tail = 0\\n                while iter not in seen:\\n                    seen.add(iter)\\n                    iter = favorite[iter]\\n                    tail += 1\\n                \\n                if iter in chain_lens_from_elem:\\n                    seen_start = iter\\n                    old_len, pair = chain_lens_from_elem[seen_start]\\n                    if seen_start == pair[1]:\\n                        pair = (pair[1], pair[0])\\n                    chain_lens_from_pair[pair] = max(chain_lens_from_pair[pair], old_len + tail)\\n                    iter = i\\n                    while iter != seen_start:\\n                        chain_lens_from_elem[iter] = (old_len + tail, pair)\\n                        iter = favorite[iter]\\n                        tail -= 1\\n\\n                continue\\n\\n            cycle_start = i\\n            tail_len = 0\\n            while cycle_start != slow_iter:\\n                seen.add(cycle_start)\\n                cycle_start = favorite[cycle_start]\\n                slow_iter = favorite[slow_iter]\\n                tail_len += 1\\n            seen.add(cycle_start)\\n            \\n            iter = favorite[cycle_start]\\n            cyc_len = 1\\n            while iter != cycle_start:\\n                seen.add(iter)\\n                cyc_len += 1\\n                iter = favorite[iter]\\n            \\n            type_cyc = max(type_cyc, cyc_len)\\n\\n            if cyc_len == 2:\\n                pair = (cycle_start, favorite[cycle_start])\\n                chain_lens_from_pair[pair] = max(chain_lens_from_pair[pair], 2 + tail_len)\\n                chain_lens_from_elem[pair[0]] = (2, pair)\\n                chain_lens_from_elem[pair[1]] = (2, pair)\\n                iter = i\\n                while iter != cycle_start:\\n                    chain_lens_from_elem[iter] = (2 + tail_len, pair)\\n                    iter = favorite[iter]\\n                    tail_len -= 1\\n        \\n        type_chain = sum(tail_len for (pair, tail_len) in chain_lens_from_pair.items()) - len(pairs)\\n        \\n        return max(type_cyc, type_chain)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970517,
                "title": "kosaraju",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI am not sure why my code is failing for cycle cases\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n         Map<Integer,List<Integer>> graph= new HashMap<>();\\n        for(int i =0;i<favorite.length;i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i =0;i<favorite.length;i++){\\n            graph.get(i).add(favorite[i]);\\n        }\\n\\n        boolean [] visited = new boolean [favorite.length];\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i =0;i<favorite.length;i++){\\n            if(!visited[i]){\\n                dfs(graph, i,visited,st );\\n            }\\n            \\n        } \\n\\n        System.out.println(st);\\n\\n         // reverse\\n         Map<Integer,List<Integer>> revGraph= new HashMap<>();\\n          for(int i =0;i<favorite.length;i++){\\n            revGraph.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i =0;i<favorite.length;i++){\\n            revGraph.get(favorite[i]).add(i);\\n        }\\n          System.out.println(graph);\\n        System.out.println(revGraph);\\n\\n        boolean [] visied = new boolean[favorite.length];\\n        int len = 0;\\n        while(!st.isEmpty()){\\n            int pop = st.pop();\\n            if(!visied[pop]){\\n                len = Math.max(len,dfs2(revGraph, pop,visied));\\n            }\\n        }\\n\\n       \\n\\n\\n        return len;\\n    }\\n\\n\\n    void dfs( Map<Integer,List<Integer>> graph, int start, boolean [] seen, Stack<Integer> st){\\n\\n        if(seen[start]){\\n            return;\\n        }\\n       \\n        seen[start]= true;;\\n\\n        //int res =0;\\n        for(int child : graph.get(start)){\\n            dfs(graph, child, seen,st);\\n        }\\n        //return res +1;\\n        st.push(start);\\n\\n    }\\n\\n    int dfs2( Map<Integer,List<Integer>> graph, int start, boolean [] seen){\\n\\n        if(seen[start]){\\n            return 0;\\n        }\\n       \\n        seen[start]= true;;\\n\\n        int res =1;\\n        for(int child : graph.get(start)){\\n            res+=dfs2(graph, child, seen);\\n        }\\n        return res ;\\n        //st.push(start);\\n\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n         Map<Integer,List<Integer>> graph= new HashMap<>();\\n        for(int i =0;i<favorite.length;i++){\\n            graph.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i =0;i<favorite.length;i++){\\n            graph.get(i).add(favorite[i]);\\n        }\\n\\n        boolean [] visited = new boolean [favorite.length];\\n        Stack<Integer> st = new Stack<>();\\n\\n        for(int i =0;i<favorite.length;i++){\\n            if(!visited[i]){\\n                dfs(graph, i,visited,st );\\n            }\\n            \\n        } \\n\\n        System.out.println(st);\\n\\n         // reverse\\n         Map<Integer,List<Integer>> revGraph= new HashMap<>();\\n          for(int i =0;i<favorite.length;i++){\\n            revGraph.put(i, new ArrayList<>());\\n        }\\n\\n        for(int i =0;i<favorite.length;i++){\\n            revGraph.get(favorite[i]).add(i);\\n        }\\n          System.out.println(graph);\\n        System.out.println(revGraph);\\n\\n        boolean [] visied = new boolean[favorite.length];\\n        int len = 0;\\n        while(!st.isEmpty()){\\n            int pop = st.pop();\\n            if(!visied[pop]){\\n                len = Math.max(len,dfs2(revGraph, pop,visied));\\n            }\\n        }\\n\\n       \\n\\n\\n        return len;\\n    }\\n\\n\\n    void dfs( Map<Integer,List<Integer>> graph, int start, boolean [] seen, Stack<Integer> st){\\n\\n        if(seen[start]){\\n            return;\\n        }\\n       \\n        seen[start]= true;;\\n\\n        //int res =0;\\n        for(int child : graph.get(start)){\\n            dfs(graph, child, seen,st);\\n        }\\n        //return res +1;\\n        st.push(start);\\n\\n    }\\n\\n    int dfs2( Map<Integer,List<Integer>> graph, int start, boolean [] seen){\\n\\n        if(seen[start]){\\n            return 0;\\n        }\\n       \\n        seen[start]= true;;\\n\\n        int res =1;\\n        for(int child : graph.get(start)){\\n            res+=dfs2(graph, child, seen);\\n        }\\n        return res ;\\n        //st.push(start);\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966685,
                "title": "lessons-learned",
                "content": "Skip this problem. This is impractical to be asked in a 45 minute interview given the difficulty in thought process, implementation and edge cases. But you can study https://leetcode.com/problems/longest-cycle-in-a-graph/solution/.\\n\\n**Concept**:\\n- This is an application of https://leetcode.com/problems/longest-cycle-in-a-graph/solution/\\n- There is atleast 1 cycle in the seating arangement, given the outdegree of each node is 1. (Indegree could be multiple though)\\n- The seating arrangement could be either of two cycles:\\n\\t- cycle length == 2: there could be multiple branches coming into the two nodes in this cycle. The group with the longest branch with these two nodes stand a candidate. Also take into consideration the possibilty of summation of such groups\\n\\t- cycle length > 2: this is a candidate in itself. There could be multiple such candidates\\n- Return the maximum of the above two\\n- Refer [image](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661037/Java-Detailed-explanation-with-picture.-O(n)-time-complexity)\\n\\n**Code**:\\n```\\n\\n/*\\nPseudocode:\\n\\n0 -> 6 -> 3 <-> 5\\n\\\\<---\\n1 -> 4 <- 2\\n\\ngraph = favorite\\ncreate reverseGraph\\n\\nfor each node:\\n    dfs on graph to compute cycleLength// cycle is obvious\\n        if cycleLength > 2:\\n            add the cycleLength to answer list\\n        if cycleLength == 2:\\n            track length of branches arising from the two nodes (of the cycle): dfs from the two nodes on reverseGraph\\n            linear length = take max 2 lengths + 2 (for the nodes)\\n            add the linearLength to linear length list\\n    sum all linearLengths in the linear length list\\n    add the linearLengthSum to answer list\\n    return max of answer list\\n\\n*/\\n\\nclass Solution {\\n    \\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        List<Integer> ans = new ArrayList<>();\\n        List<Integer> linearLengthList = new ArrayList<>();\\n        List<Integer>[] reverseGraph = createReverseGraph(favorite);\\n        \\n        // printReverseGraph(reverseGraph);\\n        \\n        Set<Integer> visitedNodes = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {  \\n            \\n            // System.out.println(\"i = \" + i);\\n            if(visitedNodes.contains(i)) continue;\\n            Map<Integer, Integer> nodeDistanceMap = new HashMap<>();\\n            nodeDistanceMap.put(i, 1);\\n            int[] cycleLengthWithStartAndEndNodes = getCycleLengthWithStartAndEndNodes(favorite, nodeDistanceMap, visitedNodes, i);\\n            \\n            // System.out.println(\"Cycle length with start and end nodes = \" + Arrays.toString(cycleLengthWithStartAndEndNodes));\\n            \\n            int cycleLength = cycleLengthWithStartAndEndNodes[0];\\n            if (cycleLength == -1) continue;\\n            if (cycleLength > 2) {\\n                ans.add(cycleLength);\\n                // System.out.println(\"ans = \" + Arrays.toString(ans.toArray()));\\n            } else {    // cycleLength == 2\\n                int startNode = cycleLengthWithStartAndEndNodes[1];\\n                int endNode = cycleLengthWithStartAndEndNodes[2];\\n                int startMaxBranchLength = 1;\\n                if (reverseGraph[startNode].size() != 1) {\\n                    startMaxBranchLength = getMaxBranchLength(startNode, reverseGraph, -1, endNode);\\n                }\\n                int endMaxBranchLength = 1;\\n                if (reverseGraph[endNode].size() != 1) {\\n                    endMaxBranchLength = getMaxBranchLength(endNode, reverseGraph, -1, startNode);\\n                }\\n                \\n                // System.out.println(\"startMaxBranchLength = \" + startMaxBranchLength);\\n                // System.out.println(\"endMaxBranchLength = \" + endMaxBranchLength);\\n                \\n                int linearLength = startMaxBranchLength + endMaxBranchLength;\\n                linearLengthList.add(linearLength);\\n                \\n                // System.out.println(\"linearLengthList = \" + Arrays.toString(linearLengthList.toArray()));\\n                \\n            }\\n        }\\n        int linearLengthSum = getSumOfLinearLengths(linearLengthList);\\n        ans.add(linearLengthSum);\\n        return Collections.max(ans);\\n    }\\n    \\n    private List<Integer>[] createReverseGraph(int[] graph) {\\n        int n = graph.length;\\n        List<Integer>[] reverseGraph = new List[n];\\n        for (int i = 0; i < n; ++i) {\\n            int node = graph[i];\\n            int neighbour = i;\\n            if (reverseGraph[node] == null) reverseGraph[node] = new ArrayList<>();\\n            reverseGraph[node].add(neighbour);\\n        }\\n        return reverseGraph;\\n    }\\n    \\n    private int[] getCycleLengthWithStartAndEndNodes(int[] graph, Map<Integer, Integer> nodeDistanceMap, Set<Integer> visited, int node) {\\n        visited.add(node);\\n        int neighbour = graph[node];\\n        \\n        int[] ans = new int[]{-1, -1, -1};\\n        if (nodeDistanceMap.containsKey(neighbour)) {\\n            int length = nodeDistanceMap.get(node) - nodeDistanceMap.get(neighbour) + 1;\\n            int startNode = length == 2 ? neighbour : -1;\\n            int endNode = length == 2 ? node : -1;\\n            ans = new int[] {length, startNode, endNode};\\n        } else if (!visited.contains(neighbour)){\\n            nodeDistanceMap.put(neighbour, nodeDistanceMap.get(node) + 1);\\n            ans = getCycleLengthWithStartAndEndNodes(graph, nodeDistanceMap, visited, neighbour);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMaxBranchLength(int node, List<Integer>[] reverseGraph, int parent, int pair) {\\n        // System.out.println(\"getMaxBranchLength: \" + node);\\n        if (reverseGraph[node] == null) return 1;\\n        int maxLength = Integer.MIN_VALUE;\\n        for (int neighbour : reverseGraph[node]) {\\n            if (neighbour == parent || neighbour == pair) continue;\\n            maxLength = Math.max(maxLength, getMaxBranchLength(neighbour, reverseGraph, node, pair));\\n        }\\n        return maxLength + 1;\\n    }\\n    \\n    private int getSumOfLinearLengths(List<Integer> linearLengthList) {\\n        int sum = linearLengthList.stream().mapToInt(Integer::intValue).sum();\\n        return sum;\\n    }\\n    \\n    private void printReverseGraph(List<Integer>[] reverseGraph){\\n        System.out.println(\"Reverse graph\");\\n        for (int i = 0; i < reverseGraph.length; ++i) {\\n            if (reverseGraph[i] != null) System.out.println(i + \": \" + Arrays.toString(reverseGraph[i].toArray()));\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/*\\nPseudocode:\\n\\n0 -> 6 -> 3 <-> 5\\n\\\\<---\\n1 -> 4 <- 2\\n\\ngraph = favorite\\ncreate reverseGraph\\n\\nfor each node:\\n    dfs on graph to compute cycleLength// cycle is obvious\\n        if cycleLength > 2:\\n            add the cycleLength to answer list\\n        if cycleLength == 2:\\n            track length of branches arising from the two nodes (of the cycle): dfs from the two nodes on reverseGraph\\n            linear length = take max 2 lengths + 2 (for the nodes)\\n            add the linearLength to linear length list\\n    sum all linearLengths in the linear length list\\n    add the linearLengthSum to answer list\\n    return max of answer list\\n\\n*/\\n\\nclass Solution {\\n    \\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        List<Integer> ans = new ArrayList<>();\\n        List<Integer> linearLengthList = new ArrayList<>();\\n        List<Integer>[] reverseGraph = createReverseGraph(favorite);\\n        \\n        // printReverseGraph(reverseGraph);\\n        \\n        Set<Integer> visitedNodes = new HashSet<>();\\n        for (int i = 0; i < n; ++i) {  \\n            \\n            // System.out.println(\"i = \" + i);\\n            if(visitedNodes.contains(i)) continue;\\n            Map<Integer, Integer> nodeDistanceMap = new HashMap<>();\\n            nodeDistanceMap.put(i, 1);\\n            int[] cycleLengthWithStartAndEndNodes = getCycleLengthWithStartAndEndNodes(favorite, nodeDistanceMap, visitedNodes, i);\\n            \\n            // System.out.println(\"Cycle length with start and end nodes = \" + Arrays.toString(cycleLengthWithStartAndEndNodes));\\n            \\n            int cycleLength = cycleLengthWithStartAndEndNodes[0];\\n            if (cycleLength == -1) continue;\\n            if (cycleLength > 2) {\\n                ans.add(cycleLength);\\n                // System.out.println(\"ans = \" + Arrays.toString(ans.toArray()));\\n            } else {    // cycleLength == 2\\n                int startNode = cycleLengthWithStartAndEndNodes[1];\\n                int endNode = cycleLengthWithStartAndEndNodes[2];\\n                int startMaxBranchLength = 1;\\n                if (reverseGraph[startNode].size() != 1) {\\n                    startMaxBranchLength = getMaxBranchLength(startNode, reverseGraph, -1, endNode);\\n                }\\n                int endMaxBranchLength = 1;\\n                if (reverseGraph[endNode].size() != 1) {\\n                    endMaxBranchLength = getMaxBranchLength(endNode, reverseGraph, -1, startNode);\\n                }\\n                \\n                // System.out.println(\"startMaxBranchLength = \" + startMaxBranchLength);\\n                // System.out.println(\"endMaxBranchLength = \" + endMaxBranchLength);\\n                \\n                int linearLength = startMaxBranchLength + endMaxBranchLength;\\n                linearLengthList.add(linearLength);\\n                \\n                // System.out.println(\"linearLengthList = \" + Arrays.toString(linearLengthList.toArray()));\\n                \\n            }\\n        }\\n        int linearLengthSum = getSumOfLinearLengths(linearLengthList);\\n        ans.add(linearLengthSum);\\n        return Collections.max(ans);\\n    }\\n    \\n    private List<Integer>[] createReverseGraph(int[] graph) {\\n        int n = graph.length;\\n        List<Integer>[] reverseGraph = new List[n];\\n        for (int i = 0; i < n; ++i) {\\n            int node = graph[i];\\n            int neighbour = i;\\n            if (reverseGraph[node] == null) reverseGraph[node] = new ArrayList<>();\\n            reverseGraph[node].add(neighbour);\\n        }\\n        return reverseGraph;\\n    }\\n    \\n    private int[] getCycleLengthWithStartAndEndNodes(int[] graph, Map<Integer, Integer> nodeDistanceMap, Set<Integer> visited, int node) {\\n        visited.add(node);\\n        int neighbour = graph[node];\\n        \\n        int[] ans = new int[]{-1, -1, -1};\\n        if (nodeDistanceMap.containsKey(neighbour)) {\\n            int length = nodeDistanceMap.get(node) - nodeDistanceMap.get(neighbour) + 1;\\n            int startNode = length == 2 ? neighbour : -1;\\n            int endNode = length == 2 ? node : -1;\\n            ans = new int[] {length, startNode, endNode};\\n        } else if (!visited.contains(neighbour)){\\n            nodeDistanceMap.put(neighbour, nodeDistanceMap.get(node) + 1);\\n            ans = getCycleLengthWithStartAndEndNodes(graph, nodeDistanceMap, visited, neighbour);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int getMaxBranchLength(int node, List<Integer>[] reverseGraph, int parent, int pair) {\\n        // System.out.println(\"getMaxBranchLength: \" + node);\\n        if (reverseGraph[node] == null) return 1;\\n        int maxLength = Integer.MIN_VALUE;\\n        for (int neighbour : reverseGraph[node]) {\\n            if (neighbour == parent || neighbour == pair) continue;\\n            maxLength = Math.max(maxLength, getMaxBranchLength(neighbour, reverseGraph, node, pair));\\n        }\\n        return maxLength + 1;\\n    }\\n    \\n    private int getSumOfLinearLengths(List<Integer> linearLengthList) {\\n        int sum = linearLengthList.stream().mapToInt(Integer::intValue).sum();\\n        return sum;\\n    }\\n    \\n    private void printReverseGraph(List<Integer>[] reverseGraph){\\n        System.out.println(\"Reverse graph\");\\n        for (int i = 0; i < reverseGraph.length; ++i) {\\n            if (reverseGraph[i] != null) System.out.println(i + \": \" + Arrays.toString(reverseGraph[i].toArray()));\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931043,
                "title": "binary-lifting-dfs-with-explanation",
                "content": "# Approch\\nThe key to solving this problem is identifying the following:\\n\\n1. **Cycles of Length 2:** If there\\'s a pair of employees who favorite each other, then both can be seated. \\nAll the groups having cycles length = 2 can be seated simultaneously.\\n2. **Cycles of Other Lengths:** Only the employees in the longest cycle can be seated since they all have different favorites within the cycle.\\n\\n\\n## Solution Flow\\n\\n### 1. Initialization:\\nThe solution begins by initializing arrays for lengths, visited nodes, parents, and a reverse adjacency list. The result `res` is also set to 0.\\n\\n### 2. Binary Lifting:\\nBinary lifting is a method to find the k-th ancestor of a node in O(log n) time. The function `process()` fills up the `parent` table. This table allows us to \"lift\" a node multiple times, i.e., find its distant ancestor, quickly.\\n\\n### 3. DFS to Assign Unique Values:\\nA DFS (`dfs()`) is run to assign each node (employee) a unique value. This value is the length from the starting node to the end node in a cycle. \\n\\n### 4. Identifying Cycles:\\nEvery node is lifted to its unique length value using the `lift()` function. This helps to reach the cycle\\'s end node. The lengths of these end nodes represent the cycle lengths. If we find a cycle length of 2, the nodes involved are stored in the `ends` set. \\n\\n### 5. Creating the Reverse Graph:\\nThe reverse graph is created to help us navigate the graph backwards. The `reverseGraph()` function populates the reverse adjacency list.\\n\\n### 6. Calculating Maximum Invitations:\\nFor every end node in the `ends` set, we find its two nodes (because cycle length is 2). Then, the `dfs2()` function finds the longest arm for each node, ignoring the other node in the cycle. Summing these lengths gives the total number of employees that can be seated when considering cycles of length 2. Finally, the solution is the maximum between the longest cycle found and the sum of all cycles of length 2.\\n\\n\\n# Code\\n```\\nconst int maxn = 1e5+1;\\nconst int logsize = 21;\\n\\nclass Solution {\\n    // Length array to assign each node a unique value.\\n    int len[maxn];\\n    // Visited array to check which nodes have been visited during DFS.\\n    bool vis[maxn];\\n    // Parent array for binary lifting.\\n    int parent[maxn][logsize];\\n    int n;\\n    // Result variable to store the maximum number of employees.\\n    int res = 0;\\n    // Reverse graph to navigate backwards.\\n    vector<int> radj[maxn];\\n\\npublic:\\n    Solution() {\\n        memset(len, 0, sizeof len);\\n    }\\n\\n    // Function to pre-calculate and fill the parent array for binary lifting.\\n    void process(vector<int> &fav) {\\n        for(int i = 0; i < n; i++)\\n            parent[i][0] = fav[i];\\n        \\n        for(int p = 1; p < logsize; p++)\\n            for(int node = 0; node < n; node++) {\\n                parent[node][p] = parent[parent[node][p-1]][p-1];\\n            }\\n    }\\n\\n    // Function to lift a node \\'k\\' times using the pre-calculated parent array.\\n    int lift(int node, int k) {\\n        for(int i = 0; i < logsize; i++) {\\n            if(k & (1<<i)) {\\n                node = parent[node][i];\\n            }\\n        }\\n        return node;\\n    }\\n\\n    // Function to generate the reverse graph from the original graph.\\n    void reverseGraph() {\\n        for(int u = 0; u < n; u++) {\\n            int v = parent[u][0];\\n            radj[v].push_back(u);\\n        }\\n    }\\n\\n    // DFS function to assign a unique value to each node.\\n    void dfs(int node) {\\n        if(vis[node]) return;\\n        vis[node] = true;\\n        dfs(parent[node][0]);\\n        len[node] = len[parent[node][0]] + 1;\\n    }\\n\\n    // DFS function to find the longest arm of the reverse graph.\\n    void dfs2(int node, int cnt, int &second, int &armLen) {\\n        armLen = max(armLen, cnt);\\n        for(int ngbr : radj[node]) {\\n            if(ngbr == second) continue;\\n            dfs2(ngbr, cnt+1, second, armLen);\\n        }\\n    }\\n\\n    // Main function to calculate and return the maximum number of employees.\\n    int maximumInvitations(vector<int>& favorite) {\\n        n = favorite.size();\\n        process(favorite);  // Fill the binary lift table.\\n\\n        // Assign each node a unique value using DFS.\\n        memset(vis, 0, sizeof vis);\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i])\\n                dfs(i);\\n        }\\n\\n        // Lift each node to its length to reach the cycle\\'s ending node.\\n        unordered_set<int> ends;\\n        for(int node = 0; node < n; node++) {\\n            int endNode = lift(node, len[node]);\\n            res = max(res, len[endNode]);\\n            if(len[endNode] == 2 && ends.find(endNode) == ends.end())\\n                ends.insert(endNode);\\n        }\\n\\n        // Sum the lengths of cycles with length equal to 2.\\n        reverseGraph();\\n        \\n        int sum = 0;\\n        for(auto &node: ends) {\\n            int u = node;  // the first node of the cycle\\n            int v = parent[node][0];  // the second node of the cycle\\n            int arm1 = 0, arm2 = 0;\\n            dfs2(u, 1, v, arm1);\\n            dfs2(v, 1, u, arm2);\\n            sum += arm1+arm2;\\n        }   \\n        res = max(res, sum);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int maxn = 1e5+1;\\nconst int logsize = 21;\\n\\nclass Solution {\\n    // Length array to assign each node a unique value.\\n    int len[maxn];\\n    // Visited array to check which nodes have been visited during DFS.\\n    bool vis[maxn];\\n    // Parent array for binary lifting.\\n    int parent[maxn][logsize];\\n    int n;\\n    // Result variable to store the maximum number of employees.\\n    int res = 0;\\n    // Reverse graph to navigate backwards.\\n    vector<int> radj[maxn];\\n\\npublic:\\n    Solution() {\\n        memset(len, 0, sizeof len);\\n    }\\n\\n    // Function to pre-calculate and fill the parent array for binary lifting.\\n    void process(vector<int> &fav) {\\n        for(int i = 0; i < n; i++)\\n            parent[i][0] = fav[i];\\n        \\n        for(int p = 1; p < logsize; p++)\\n            for(int node = 0; node < n; node++) {\\n                parent[node][p] = parent[parent[node][p-1]][p-1];\\n            }\\n    }\\n\\n    // Function to lift a node \\'k\\' times using the pre-calculated parent array.\\n    int lift(int node, int k) {\\n        for(int i = 0; i < logsize; i++) {\\n            if(k & (1<<i)) {\\n                node = parent[node][i];\\n            }\\n        }\\n        return node;\\n    }\\n\\n    // Function to generate the reverse graph from the original graph.\\n    void reverseGraph() {\\n        for(int u = 0; u < n; u++) {\\n            int v = parent[u][0];\\n            radj[v].push_back(u);\\n        }\\n    }\\n\\n    // DFS function to assign a unique value to each node.\\n    void dfs(int node) {\\n        if(vis[node]) return;\\n        vis[node] = true;\\n        dfs(parent[node][0]);\\n        len[node] = len[parent[node][0]] + 1;\\n    }\\n\\n    // DFS function to find the longest arm of the reverse graph.\\n    void dfs2(int node, int cnt, int &second, int &armLen) {\\n        armLen = max(armLen, cnt);\\n        for(int ngbr : radj[node]) {\\n            if(ngbr == second) continue;\\n            dfs2(ngbr, cnt+1, second, armLen);\\n        }\\n    }\\n\\n    // Main function to calculate and return the maximum number of employees.\\n    int maximumInvitations(vector<int>& favorite) {\\n        n = favorite.size();\\n        process(favorite);  // Fill the binary lift table.\\n\\n        // Assign each node a unique value using DFS.\\n        memset(vis, 0, sizeof vis);\\n        for(int i = 0; i < n; i++) {\\n            if(!vis[i])\\n                dfs(i);\\n        }\\n\\n        // Lift each node to its length to reach the cycle\\'s ending node.\\n        unordered_set<int> ends;\\n        for(int node = 0; node < n; node++) {\\n            int endNode = lift(node, len[node]);\\n            res = max(res, len[endNode]);\\n            if(len[endNode] == 2 && ends.find(endNode) == ends.end())\\n                ends.insert(endNode);\\n        }\\n\\n        // Sum the lengths of cycles with length equal to 2.\\n        reverseGraph();\\n        \\n        int sum = 0;\\n        for(auto &node: ends) {\\n            int u = node;  // the first node of the cycle\\n            int v = parent[node][0];  // the second node of the cycle\\n            int arm1 = 0, arm2 = 0;\\n            dfs2(u, 1, v, arm1);\\n            dfs2(v, 1, u, arm2);\\n            sum += arm1+arm2;\\n        }   \\n        res = max(res, sum);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920860,
                "title": "applied-dfs-with-critical-observations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timer = 1;\\n    int dfs(int node, vector<int>& graph, vector<int>&vis, vector<int>& path){\\n        vis[node] = path[node] = timer++;\\n        if(path[graph[node]]){\\n            path[node] = 0;\\n            return timer - path[graph[node]];\\n        }\\n        if(vis[graph[node]]){\\n            path[node] = 0;\\n            return -1;\\n        }\\n        int ans = dfs(graph[node], graph, vis, path);\\n        path[node] = 0;\\n        return ans;\\n    }\\n    int dfs2(int node, vector<int> revFavorite[]){\\n        int ans = 1;\\n        for(auto it : revFavorite[node]){\\n            ans = max(ans, 1 + dfs2(it,revFavorite));\\n        }\\n        return ans;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> revFavorite[n];\\n        for(int i=0;i<n;i++){\\n            revFavorite[favorite[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        vector<int> revVis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(favorite[favorite[i]] == i and !revVis[i] and !revVis[favorite[i]]){\\n                revVis[i]=1;\\n                revVis[favorite[i]] = 1;\\n                int first = 0;\\n                for(auto it : revFavorite[i]){\\n                    if(it == favorite[i]){\\n                        continue;\\n                    }\\n                    first = max(first, dfs2(it,revFavorite));\\n                }\\n                int second = 0;\\n                for(auto it : revFavorite[favorite[i]]){\\n                    if(it == i){\\n                        continue;\\n                    }\\n                    second = max(second, dfs2(it,revFavorite));\\n                }\\n                ans += 2 + first + second;\\n            }\\n        }\\n        if(ans == 0){\\n            ans = -1;\\n        }\\n        vector<int> vis(n,0);\\n        vector<int> path(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                ans = max(ans, dfs(i,favorite,vis,path));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer = 1;\\n    int dfs(int node, vector<int>& graph, vector<int>&vis, vector<int>& path){\\n        vis[node] = path[node] = timer++;\\n        if(path[graph[node]]){\\n            path[node] = 0;\\n            return timer - path[graph[node]];\\n        }\\n        if(vis[graph[node]]){\\n            path[node] = 0;\\n            return -1;\\n        }\\n        int ans = dfs(graph[node], graph, vis, path);\\n        path[node] = 0;\\n        return ans;\\n    }\\n    int dfs2(int node, vector<int> revFavorite[]){\\n        int ans = 1;\\n        for(auto it : revFavorite[node]){\\n            ans = max(ans, 1 + dfs2(it,revFavorite));\\n        }\\n        return ans;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> revFavorite[n];\\n        for(int i=0;i<n;i++){\\n            revFavorite[favorite[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        vector<int> revVis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(favorite[favorite[i]] == i and !revVis[i] and !revVis[favorite[i]]){\\n                revVis[i]=1;\\n                revVis[favorite[i]] = 1;\\n                int first = 0;\\n                for(auto it : revFavorite[i]){\\n                    if(it == favorite[i]){\\n                        continue;\\n                    }\\n                    first = max(first, dfs2(it,revFavorite));\\n                }\\n                int second = 0;\\n                for(auto it : revFavorite[favorite[i]]){\\n                    if(it == i){\\n                        continue;\\n                    }\\n                    second = max(second, dfs2(it,revFavorite));\\n                }\\n                ans += 2 + first + second;\\n            }\\n        }\\n        if(ans == 0){\\n            ans = -1;\\n        }\\n        vector<int> vis(n,0);\\n        vector<int> path(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                ans = max(ans, dfs(i,favorite,vis,path));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842874,
                "title": "reverse-graph",
                "content": "# Intuition\\nCatch loops and cycles, there can be only one cycle or many loops.\\n\\n# Approach\\nFirstly create a reverse graph and catch pairs (the ones that are friends two each other)\\nThen run the graph (dfs) starting from pairs, collecting loops depth.\\nLastly run through all not vivsited people, catching biggest cycle.\\n\\n# Complexity\\n- Time complexity:\\n1174 ms\\n\\n- Space complexity:\\n60.6 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n\\n        loop_heads = set()\\n        graph: dict[int, set[int]] = {}\\n        for vertex in range(len(favorite)):\\n            try:\\n                graph[vertex].remove(favorite[vertex])\\n                loop = True\\n            except KeyError:\\n                loop = False\\n\\n            if loop:\\n                loop_heads.add(favorite[vertex])\\n                loop_heads.add(vertex)\\n            else:\\n                graph.setdefault(favorite[vertex], set()).add(vertex)\\n\\n        seen = [False for _ in range(len(favorite))]\\n        loops_depth = 0\\n        for head in loop_heads:\\n            max_depth, cur_depth = 0, 0\\n            stack = [(head, cur_depth)]\\n            while stack:\\n                cur_v, cur_depth = stack.pop()\\n                seen[cur_v] = True\\n                cur_depth += 1\\n                if max_depth < cur_depth: max_depth = cur_depth\\n                try:\\n                    for parent in graph[cur_v]:\\n                        stack.append((parent, cur_depth))\\n                except KeyError:\\n                    continue\\n            loops_depth += max_depth\\n\\n        max_cycle_depth = 0\\n        for vertex in range(len(seen)):\\n\\n            if not seen[vertex]:\\n                done = set()\\n                cur_depth = 0\\n                stack = []\\n                while not seen[vertex]:\\n                    done.add(vertex)\\n                    cur_depth += 1\\n                    seen[vertex] = True\\n                    try:\\n                        for vert in graph[vertex]:\\n                            if not seen[vert] or vert in done:\\n                                stack.append((vert, cur_depth))\\n                    except KeyError:\\n                        pass\\n                    if stack:\\n                        vertex, cur_depth = stack.pop()\\n                    else:\\n                        cur_depth = 0\\n                if cur_depth > max_cycle_depth:\\n                    max_cycle_depth = cur_depth\\n\\n        return max((loops_depth, max_cycle_depth))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n\\n        loop_heads = set()\\n        graph: dict[int, set[int]] = {}\\n        for vertex in range(len(favorite)):\\n            try:\\n                graph[vertex].remove(favorite[vertex])\\n                loop = True\\n            except KeyError:\\n                loop = False\\n\\n            if loop:\\n                loop_heads.add(favorite[vertex])\\n                loop_heads.add(vertex)\\n            else:\\n                graph.setdefault(favorite[vertex], set()).add(vertex)\\n\\n        seen = [False for _ in range(len(favorite))]\\n        loops_depth = 0\\n        for head in loop_heads:\\n            max_depth, cur_depth = 0, 0\\n            stack = [(head, cur_depth)]\\n            while stack:\\n                cur_v, cur_depth = stack.pop()\\n                seen[cur_v] = True\\n                cur_depth += 1\\n                if max_depth < cur_depth: max_depth = cur_depth\\n                try:\\n                    for parent in graph[cur_v]:\\n                        stack.append((parent, cur_depth))\\n                except KeyError:\\n                    continue\\n            loops_depth += max_depth\\n\\n        max_cycle_depth = 0\\n        for vertex in range(len(seen)):\\n\\n            if not seen[vertex]:\\n                done = set()\\n                cur_depth = 0\\n                stack = []\\n                while not seen[vertex]:\\n                    done.add(vertex)\\n                    cur_depth += 1\\n                    seen[vertex] = True\\n                    try:\\n                        for vert in graph[vertex]:\\n                            if not seen[vert] or vert in done:\\n                                stack.append((vert, cur_depth))\\n                    except KeyError:\\n                        pass\\n                    if stack:\\n                        vertex, cur_depth = stack.pop()\\n                    else:\\n                        cur_depth = 0\\n                if cur_depth > max_cycle_depth:\\n                    max_cycle_depth = cur_depth\\n\\n        return max((loops_depth, max_cycle_depth))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840575,
                "title": "javascript-topological-sort-dfs",
                "content": "# Intuition\\nTwo scenarios: \\n1. Max is a loop with more than 2 participants. In this case we can\\'t have more people on the table\\n2. Use only graphs that have at most one loop of 2 people. In this case multiple graphs can be on the table\\n\\n# Code\\n```\\n/**\\n * @param {number[]} favorite\\n * @return {number}\\n */\\nvar maximumInvitations = function(favorite) {\\n    const n = favorite.length\\n    let indegree = new Array(n).fill(0), pairs = [], map = {}, out = 0\\n    \\n    for (let i = 0; i < n; i++) {\\n        // Create indegree array\\n        indegree[favorite[i]]++\\n        // Create pair array\\n        if (favorite[favorite[i]] == i && favorite[i] > i) pairs.push([i, favorite[i]])\\n        // Get reverse node map\\n        if (!(favorite[i] in map)) map[favorite[i]] = []\\n        map[favorite[i]].push(i)\\n    }\\n\\n    // Start with loose node and leave all loop nodes\\n    let stack = []\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) {\\n            stack.push(i)\\n        }\\n    }\\n\\n    while (stack.length > 0) {\\n        let cur = stack.pop()\\n        indegree[favorite[cur]]--\\n        if (indegree[favorite[cur]] == 0) stack.push(favorite[cur])\\n    }\\n\\n    // Go through loop nodes to get a max loop with node # > 2\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 1) {\\n            let count = 1, start = i\\n            while (favorite[start] != i) {\\n                indegree[start]--\\n                start = favorite[start]\\n                count++\\n            }\\n            out = Math.max(out, count)\\n        }\\n    }\\n\\n    // Scenario 2: pair favorites, can add up\\n    let pairMax = 0\\n    for (let pair of pairs) {\\n        const max = [1, 1]\\n        for (let i = 0; i < 2; i++) {\\n            let stack = [[pair[i], 1]]\\n            while (stack.length > 0) {\\n                let [cur, len] = stack.pop()\\n                if (!(cur in map)) {\\n                    max[i] = Math.max(max[i], len)\\n                    continue\\n                }\\n                for (let next of map[cur]) {\\n                    if (next == favorite[pair[i]]) continue\\n                    stack.push([next, len + 1])\\n                }\\n            }\\n        }\\n\\n        pairMax += max[0] + max[1]\\n    }\\n    out = Math.max(out, pairMax)\\n\\n    return out\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} favorite\\n * @return {number}\\n */\\nvar maximumInvitations = function(favorite) {\\n    const n = favorite.length\\n    let indegree = new Array(n).fill(0), pairs = [], map = {}, out = 0\\n    \\n    for (let i = 0; i < n; i++) {\\n        // Create indegree array\\n        indegree[favorite[i]]++\\n        // Create pair array\\n        if (favorite[favorite[i]] == i && favorite[i] > i) pairs.push([i, favorite[i]])\\n        // Get reverse node map\\n        if (!(favorite[i] in map)) map[favorite[i]] = []\\n        map[favorite[i]].push(i)\\n    }\\n\\n    // Start with loose node and leave all loop nodes\\n    let stack = []\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 0) {\\n            stack.push(i)\\n        }\\n    }\\n\\n    while (stack.length > 0) {\\n        let cur = stack.pop()\\n        indegree[favorite[cur]]--\\n        if (indegree[favorite[cur]] == 0) stack.push(favorite[cur])\\n    }\\n\\n    // Go through loop nodes to get a max loop with node # > 2\\n    for (let i = 0; i < n; i++) {\\n        if (indegree[i] == 1) {\\n            let count = 1, start = i\\n            while (favorite[start] != i) {\\n                indegree[start]--\\n                start = favorite[start]\\n                count++\\n            }\\n            out = Math.max(out, count)\\n        }\\n    }\\n\\n    // Scenario 2: pair favorites, can add up\\n    let pairMax = 0\\n    for (let pair of pairs) {\\n        const max = [1, 1]\\n        for (let i = 0; i < 2; i++) {\\n            let stack = [[pair[i], 1]]\\n            while (stack.length > 0) {\\n                let [cur, len] = stack.pop()\\n                if (!(cur in map)) {\\n                    max[i] = Math.max(max[i], len)\\n                    continue\\n                }\\n                for (let next of map[cur]) {\\n                    if (next == favorite[pair[i]]) continue\\n                    stack.push([next, len + 1])\\n                }\\n            }\\n        }\\n\\n        pairMax += max[0] + max[1]\\n    }\\n    out = Math.max(out, pairMax)\\n\\n    return out\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753347,
                "title": "solution",
                "content": "# Intuition\\nThe question is a functional graph so if you dont know please read it \\nfirst it will complicate the things less \\nhttps://www.geeksforgeeks.org/successor-graph/\\nnow if you read this u have understood what it is now solve this ques first to proceed this will help u understand how to implement it \\nhttps://cses.fi/problemset/task/1751\\nif not able to solve read this tutorial\\nhttps://usaco.guide/problems/cses-1751-planets-cycles/solution\\nNow u understand the question after trying to make the people seats beside them u will understand only two cases are possible \\n1 ) A cycle of size > 2\\n2 ) A cycle of size 2 + the maximum height u could take of the connected tree to this cycle from both the nodes \\nThank you\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dfs (vector<vector<int>>&g, int st){\\n     int h = 0;\\n     for(auto x : g[st]){\\n          h = max(h , dfs(g, x));\\n     }\\n     return h+1;\\n}\\n    int maximumInvitations(vector<int>& parent) {\\n        int n = parent.size();\\n        vector<vector<int>>back_edges(n);\\n        for(int i =  0 ; i<n; i++){\\n            back_edges[parent[i]].push_back(i);\\n        }\\n        vector<map<int,int>>cycles;\\n        vector<int>cycle_ind(n, -2);\\n        for(int i =  0 ; i<n; i++){\\n            if(cycle_ind[i] != -2){\\n                continue;\\n            }\\n            int at = i;\\n            vector<int>path = {at};\\n            while(cycle_ind[parent[at]] == -2){\\n                at = parent[at];\\n                cycle_ind[at] = -3;\\n                path.push_back(at);\\n            }\\n            bool iscycle = false;\\n            map<int,int>cycle;\\n            for(auto p : path){\\n                iscycle = iscycle || parent[at] == p;\\n                if(iscycle){\\n                   cycle[p] = cycle.size();\\n                   cycle_ind[p] = cycles.size();\\n                } \\n                else{\\n                    cycle_ind[p] = -1;\\n                }\\n            }\\n            if(cycle.size()){\\n                cycles.push_back(cycle);\\n            }\\n        }\\n        vector<set<int>>nodes(n);\\n        for(int i = 0 ; i<n ; i++){\\n            if(cycle_ind[parent[i]] == -1 || cycle_ind[i] != -1){\\n                continue;\\n            }\\n            nodes[parent[i]].insert(i);\\n        }\\n  \\n        int ans = 0 ;\\n        int anst = 0;\\n        for(int i = 0 ; i<cycles.size() ; i++){\\n            int size = cycles[i].size();\\n            ans = max(ans,size);\\n            if(cycles[i].size() == 2){\\n               int h = 2 ;\\n               for(auto [node,_] : cycles[i]){\\n                  int val = 0;\\n                //   cout << node <<\" x  \";\\n                  for(auto nod : nodes[node]){\\n                     val = max(val , dfs(back_edges, nod));\\n                  } \\n                  h += val;\\n                //   cout << val<<\" \";\\n               }\\n            //    cout <<\"h\"<<\" \";\\n               anst +=  h ;\\n            }\\n            \\n        }\\n       ans = max(ans , anst);\\n        return ans;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dfs (vector<vector<int>>&g, int st){\\n     int h = 0;\\n     for(auto x : g[st]){\\n          h = max(h , dfs(g, x));\\n     }\\n     return h+1;\\n}\\n    int maximumInvitations(vector<int>& parent) {\\n        int n = parent.size();\\n        vector<vector<int>>back_edges(n);\\n        for(int i =  0 ; i<n; i++){\\n            back_edges[parent[i]].push_back(i);\\n        }\\n        vector<map<int,int>>cycles;\\n        vector<int>cycle_ind(n, -2);\\n        for(int i =  0 ; i<n; i++){\\n            if(cycle_ind[i] != -2){\\n                continue;\\n            }\\n            int at = i;\\n            vector<int>path = {at};\\n            while(cycle_ind[parent[at]] == -2){\\n                at = parent[at];\\n                cycle_ind[at] = -3;\\n                path.push_back(at);\\n            }\\n            bool iscycle = false;\\n            map<int,int>cycle;\\n            for(auto p : path){\\n                iscycle = iscycle || parent[at] == p;\\n                if(iscycle){\\n                   cycle[p] = cycle.size();\\n                   cycle_ind[p] = cycles.size();\\n                } \\n                else{\\n                    cycle_ind[p] = -1;\\n                }\\n            }\\n            if(cycle.size()){\\n                cycles.push_back(cycle);\\n            }\\n        }\\n        vector<set<int>>nodes(n);\\n        for(int i = 0 ; i<n ; i++){\\n            if(cycle_ind[parent[i]] == -1 || cycle_ind[i] != -1){\\n                continue;\\n            }\\n            nodes[parent[i]].insert(i);\\n        }\\n  \\n        int ans = 0 ;\\n        int anst = 0;\\n        for(int i = 0 ; i<cycles.size() ; i++){\\n            int size = cycles[i].size();\\n            ans = max(ans,size);\\n            if(cycles[i].size() == 2){\\n               int h = 2 ;\\n               for(auto [node,_] : cycles[i]){\\n                  int val = 0;\\n                //   cout << node <<\" x  \";\\n                  for(auto nod : nodes[node]){\\n                     val = max(val , dfs(back_edges, nod));\\n                  } \\n                  h += val;\\n                //   cout << val<<\" \";\\n               }\\n            //    cout <<\"h\"<<\" \";\\n               anst +=  h ;\\n            }\\n            \\n        }\\n       ans = max(ans , anst);\\n        return ans;\\n  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3727492,
                "title": "solution",
                "content": "# Method\\nIterate through each employee and consider them as the starting point of the seating arrangement. It is slow but it works. Kinda...\\nNot the best solution.\\n# Time Complexity\\nThe time complexity of this solution is $$O(n^2)$$ because, in the worst case, we may have to iterate through the entire list of employees for each employee to form a seating arrangement. However, given the maximum constraint of 10^5 employees, this solution should be efficient enough to handle the given constraints.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691964,
                "title": "java-topological-sort",
                "content": "There are two ways that form a circular table:\\n1. a cycle of graph\\n2. all cycles of length 2, each cycle may be followed by at most two chains\\n\\nIf we format the table according to case 1, then only 1 cycle can be used, so we need to find the cycle with longest length.\\nIf we format the table according to case 2, we can use as many as possible, so the length of the table will be the sum of the length of all cycles formated in case 2.\\n\\n1. Use topological sort to find all cycles, which are the nodes in cycles has indegree still greater than 0 after deleting the nodes with 0 indegree. \\n2. Update all nodes\\' depth during sorting\\n3. Since they are all in cycles, so we can iterate using adjacency table which is the array favorite in the context.\\n4. If the cycle has length 2, then do sum operation\\n5. If the cycle has length GE 3, then do max operation\\n\\n\\n![IMG_0777.jpg](https://assets.leetcode.com/users/images/c7ad613d-68a9-4d15-861e-2a2ca1658694_1687936800.4580247.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        // favorite is the adjacency table in this context\\n        int n = favorite.length;\\n        int[] indegrees = new int[n];\\n        int[] depths = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            indegrees[favorite[i]]++;\\n        }\\n        Deque<Integer> deque = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                deque.offerLast(i);\\n            }\\n            // each node firstly have depth\\n            depths[i] = 1;\\n        }\\n        while (!deque.isEmpty()) {\\n            int len = deque.size();\\n            for (int i = 0; i < len; i++) {\\n                Integer cur_node = deque.pollFirst();\\n                int next = favorite[cur_node];\\n                depths[next] = Math.max(depths[next], depths[cur_node] + 1);\\n                indegrees[next]--;\\n                if (indegrees[next] == 0) deque.offerLast(next);\\n            }\\n        }\\n        // find loops\\n        int res = findLoops2ConstructMaxCircularTable(indegrees, depths, favorite);\\n        return res;\\n    }\\n\\n    private int findLoops2ConstructMaxCircularTable(int[] indegrees, int[] depths, int[] favorite) {\\n        int n = indegrees.length;\\n        int sumOfLoopsOfLengthEQ2 = 0;\\n        int maxLoopOfLengthGE3 = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (indegrees[i] != 0) {\\n                indegrees[i]--;\\n                int temp_node = i;\\n                int loop_n = 1;\\n                while (favorite[temp_node] != i) {\\n                    loop_n++;\\n                    temp_node = favorite[temp_node];\\n                    indegrees[temp_node]--;\\n                }\\n                if (loop_n == 2) {\\n                    sumOfLoopsOfLengthEQ2 += depths[i] + depths[temp_node];\\n                } else {\\n                    maxLoopOfLengthGE3 = Math.max(maxLoopOfLengthGE3, loop_n);\\n                }\\n            }\\n        }\\n        return Math.max(maxLoopOfLengthGE3, sumOfLoopsOfLengthEQ2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        // favorite is the adjacency table in this context\\n        int n = favorite.length;\\n        int[] indegrees = new int[n];\\n        int[] depths = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            indegrees[favorite[i]]++;\\n        }\\n        Deque<Integer> deque = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegrees[i] == 0) {\\n                deque.offerLast(i);\\n            }\\n            // each node firstly have depth\\n            depths[i] = 1;\\n        }\\n        while (!deque.isEmpty()) {\\n            int len = deque.size();\\n            for (int i = 0; i < len; i++) {\\n                Integer cur_node = deque.pollFirst();\\n                int next = favorite[cur_node];\\n                depths[next] = Math.max(depths[next], depths[cur_node] + 1);\\n                indegrees[next]--;\\n                if (indegrees[next] == 0) deque.offerLast(next);\\n            }\\n        }\\n        // find loops\\n        int res = findLoops2ConstructMaxCircularTable(indegrees, depths, favorite);\\n        return res;\\n    }\\n\\n    private int findLoops2ConstructMaxCircularTable(int[] indegrees, int[] depths, int[] favorite) {\\n        int n = indegrees.length;\\n        int sumOfLoopsOfLengthEQ2 = 0;\\n        int maxLoopOfLengthGE3 = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (indegrees[i] != 0) {\\n                indegrees[i]--;\\n                int temp_node = i;\\n                int loop_n = 1;\\n                while (favorite[temp_node] != i) {\\n                    loop_n++;\\n                    temp_node = favorite[temp_node];\\n                    indegrees[temp_node]--;\\n                }\\n                if (loop_n == 2) {\\n                    sumOfLoopsOfLengthEQ2 += depths[i] + depths[temp_node];\\n                } else {\\n                    maxLoopOfLengthGE3 = Math.max(maxLoopOfLengthGE3, loop_n);\\n                }\\n            }\\n        }\\n        return Math.max(maxLoopOfLengthGE3, sumOfLoopsOfLengthEQ2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579713,
                "title": "100th-ever-solution-with-80-speed-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees of all nodes\\n        for u in favorite:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        # and calculate the depth of all node at the same time\\n        depth = [1] * n\\n        for u in range(n):\\n            temp = 1\\n            while indegree[u] == 0 and favorite[u] != -1:\\n                v = favorite[u]\\n                favorite[u] = -1\\n                indegree[v] -= 1\\n                depth[v] =max(depth[v], 1 + depth[u]) # it can be itself or prev + 1\\n                u = v\\n    \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        # if the circle lenght is more than 3, just use max, if it is 2 use total to add all of them\\n        visited, res, total_link_loop_2 = set(), 0, 0\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 0\\n            while favorite[u] not in visited:\\n                visited.add(favorite[u])\\n                v = favorite[u]\\n                ans += 1\\n                u = v\\n            if ans == 2:\\n                total_link_loop_2 += depth[u] +depth[favorite[u]]\\n            elif ans >= 3:\\n                res = max(res, ans)\\n        return max(res, total_link_loop_2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees of all nodes\\n        for u in favorite:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        # and calculate the depth of all node at the same time\\n        depth = [1] * n\\n        for u in range(n):\\n            temp = 1\\n            while indegree[u] == 0 and favorite[u] != -1:\\n                v = favorite[u]\\n                favorite[u] = -1\\n                indegree[v] -= 1\\n                depth[v] =max(depth[v], 1 + depth[u]) # it can be itself or prev + 1\\n                u = v\\n    \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        # if the circle lenght is more than 3, just use max, if it is 2 use total to add all of them\\n        visited, res, total_link_loop_2 = set(), 0, 0\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 0\\n            while favorite[u] not in visited:\\n                visited.add(favorite[u])\\n                v = favorite[u]\\n                ans += 1\\n                u = v\\n            if ans == 2:\\n                total_link_loop_2 += depth[u] +depth[favorite[u]]\\n            elif ans >= 3:\\n                res = max(res, ans)\\n        return max(res, total_link_loop_2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493583,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `favorite`\\n */\\nclass Solution {\\n public:\\n  int maximumInvitations(const vector<int> &favorite) {\\n    const int n = static_cast<int>(favorite.size());\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int i = 0; i < n; ++i) {\\n      ++indegrees[favorite[i]];\\n    }\\n    \\n    int favorite_link_length[n];\\n    memset(favorite_link_length, 0, sizeof(favorite_link_length));\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    int link_length = 0;\\n    while (!q.empty()) {\\n      ++link_length;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int node = q.front();\\n        q.pop();\\n        favorite_link_length[favorite[node]] = link_length;\\n        if (--indegrees[favorite[node]] == 0) {\\n          q.emplace(favorite[node]);\\n        }\\n      }\\n    }\\n    \\n    int max_cycle_length = 0;\\n    int sum_of_two_node_cycle = 0;\\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    for (int i = 0; i < n; ++i) {\\n      if (visited[i] || indegrees[i] == 0) {\\n        continue;\\n      }\\n      \\n      int length = 0;\\n      for (int node = i; !visited[node]; node = favorite[node]) {\\n        visited[node] = true;\\n        ++length;\\n      }\\n      if (length == 2) {\\n        sum_of_two_node_cycle += length + favorite_link_length[i] + favorite_link_length[favorite[i]];\\n      } else {\\n        max_cycle_length = max(max_cycle_length, length);\\n      }\\n    }\\n    return max(max_cycle_length, sum_of_two_node_cycle);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `favorite`\\n */\\nclass Solution {\\n public:\\n  int maximumInvitations(const vector<int> &favorite) {\\n    const int n = static_cast<int>(favorite.size());\\n    int indegrees[n];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int i = 0; i < n; ++i) {\\n      ++indegrees[favorite[i]];\\n    }\\n    \\n    int favorite_link_length[n];\\n    memset(favorite_link_length, 0, sizeof(favorite_link_length));\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    int link_length = 0;\\n    while (!q.empty()) {\\n      ++link_length;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int node = q.front();\\n        q.pop();\\n        favorite_link_length[favorite[node]] = link_length;\\n        if (--indegrees[favorite[node]] == 0) {\\n          q.emplace(favorite[node]);\\n        }\\n      }\\n    }\\n    \\n    int max_cycle_length = 0;\\n    int sum_of_two_node_cycle = 0;\\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    for (int i = 0; i < n; ++i) {\\n      if (visited[i] || indegrees[i] == 0) {\\n        continue;\\n      }\\n      \\n      int length = 0;\\n      for (int node = i; !visited[node]; node = favorite[node]) {\\n        visited[node] = true;\\n        ++length;\\n      }\\n      if (length == 2) {\\n        sum_of_two_node_cycle += length + favorite_link_length[i] + favorite_link_length[favorite[i]];\\n      } else {\\n        max_cycle_length = max(max_cycle_length, length);\\n      }\\n    }\\n    return max(max_cycle_length, sum_of_two_node_cycle);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465720,
                "title": "toplogical-sort-consider-to-loops-2-node-with-branches",
                "content": "- The base problem of this one is: 2360. Longest Cycle in a Graph\\nHere is the solution for 2360.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are only 4 cases of the pattern:\\n- 1 linear structure\\n![image.png](https://assets.leetcode.com/users/images/b6c26d03-a976-4b1d-9eba-98d9cd082644_1682744764.2557895.png)\\n- 2 circle\\n![image.png](https://assets.leetcode.com/users/images/c37ad03f-e4b6-4638-95e6-78ad620455e0_1682744867.8634007.png)\\n- 3 circle with branches\\n![image.png](https://assets.leetcode.com/users/images/ea318fdf-f6d1-43d4-93ba-21df61f245fe_1682744920.6607926.png)\\n\\n- 4 combinations of the (1, 2) and (1, 3), as (2, 3) is not possible(outgoing degree at most 1, otherwise should be more difficult)\\n\\n- If we can find a way to trim all branches of the circle, we can get the result using bfs to get the longest.\\n- To trim the branches, we can use topological sort as the branch structure is a topological graph.\\n- we can start form indegree = 0 to trim the graph grudaully, until there is only circle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- 1 get indgrees all nodes\\n- 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n- 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees all nodes\\n        for u in edges:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        for u in range(n):\\n            while indegree[u] == 0 and edges[u] != -1:\\n                v = edges[u]\\n                edges[u] = -1\\n                indegree[v] -= 1\\n                u = v\\n        \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        visited, res = set(), -1\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 1\\n            visited.add(u)\\n            while edges[u] not in visited:\\n                v = edges[u]\\n                ans += 1\\n                u = v\\n            res = max(res, ans)\\n        return res\\n```\\n###  Inorder to solve this one, we need to do some change of the code\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2360. Longest Cycle in a Graph\\n- https://leetcode.com/problems/longest-cycle-in-a-graph/description/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Except the above patterns, need to consider another case:\\n  - loops of 2 node with edges, all these cases can add up together to meet the sitting table conditoion\\n![image.png](https://assets.leetcode.com/users/images/a2997a16-cd7a-4aae-9640-7a01905b625f_1682758952.7499888.png)\\n  - one trick is: depth[v] =max(depth[v], 1 + depth[u]) # it can be itself or prev + 1\\n  - while bfs, need to record the depth array, current node should consider the previou node depth\\n  - Another trick is to change the final bfs structure: visited.add position is changed to void if a loop like 1-2-3-4-1, if use the leetcode 2360 method, it will count to 4-1 case as a loop of 2, which will got the wrong result. This means leetcode 2360\\'s final bfs can be improved\\n  \\n```\\nfor u in range(n):\\n    if indegree[u] == 0 or u in visited:\\n        continue\\n    # bfs to find length\\n    ans = 0\\n    while favorite[u] not in visited:\\n        visited.add(favorite[u])\\n        v = favorite[u]\\n        ans += 1\\n        u = v\\n    if ans == 2:\\n        total_link_loop_2 += depth[u] +depth[favorite[u]]\\n    elif ans >= 3:\\n        res = max(res, ans)\\nreturn max(res, total_link_loop_2)\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees of all nodes\\n        for u in favorite:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        # and calculate the depth of all node at the same time\\n        depth = [1] * n\\n        for u in range(n):\\n            temp = 1\\n            while indegree[u] == 0 and favorite[u] != -1:\\n                v = favorite[u]\\n                favorite[u] = -1\\n                indegree[v] -= 1\\n                depth[v] =max(depth[v], 1 + depth[u]) # it can be itself or prev + 1\\n                u = v\\n    \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        # if the circle lenght is more than 3, just use max, if it is 2 use total to add all of them\\n        visited, res, total_link_loop_2 = set(), 0, 0\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 0\\n            while favorite[u] not in visited:\\n                visited.add(favorite[u])\\n                v = favorite[u]\\n                ans += 1\\n                u = v\\n            if ans == 2:\\n                total_link_loop_2 += depth[u] +depth[favorite[u]]\\n            elif ans >= 3:\\n                res = max(res, ans)\\n        return max(res, total_link_loop_2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees all nodes\\n        for u in edges:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        for u in range(n):\\n            while indegree[u] == 0 and edges[u] != -1:\\n                v = edges[u]\\n                edges[u] = -1\\n                indegree[v] -= 1\\n                u = v\\n        \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        visited, res = set(), -1\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 1\\n            visited.add(u)\\n            while edges[u] not in visited:\\n                v = edges[u]\\n                ans += 1\\n                u = v\\n            res = max(res, ans)\\n        return res\\n```\n```\\nfor u in range(n):\\n    if indegree[u] == 0 or u in visited:\\n        continue\\n    # bfs to find length\\n    ans = 0\\n    while favorite[u] not in visited:\\n        visited.add(favorite[u])\\n        v = favorite[u]\\n        ans += 1\\n        u = v\\n    if ans == 2:\\n        total_link_loop_2 += depth[u] +depth[favorite[u]]\\n    elif ans >= 3:\\n        res = max(res, ans)\\nreturn max(res, total_link_loop_2)\\n```\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        indegree = [0 for i in range(n)]\\n\\n        # 1 get indgrees of all nodes\\n        for u in favorite:\\n            if u == -1:\\n                continue\\n            indegree[u] += 1\\n\\n        # 2 trim nodes with 0 indegree iteratively to make a circle (topological sort: bfs)\\n        # and calculate the depth of all node at the same time\\n        depth = [1] * n\\n        for u in range(n):\\n            temp = 1\\n            while indegree[u] == 0 and favorite[u] != -1:\\n                v = favorite[u]\\n                favorite[u] = -1\\n                indegree[v] -= 1\\n                depth[v] =max(depth[v], 1 + depth[u]) # it can be itself or prev + 1\\n                u = v\\n    \\n        # 3 find the longest cycle amoung all cycles after trimming 0 indgree nodes (bfs)\\n        # if the circle lenght is more than 3, just use max, if it is 2 use total to add all of them\\n        visited, res, total_link_loop_2 = set(), 0, 0\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            # bfs to find length\\n            ans = 0\\n            while favorite[u] not in visited:\\n                visited.add(favorite[u])\\n                v = favorite[u]\\n                ans += 1\\n                u = v\\n            if ans == 2:\\n                total_link_loop_2 += depth[u] +depth[favorite[u]]\\n            elif ans >= 3:\\n                res = max(res, ans)\\n        return max(res, total_link_loop_2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391901,
                "title": "super-easy-to-understand-java-o-n",
                "content": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        // Observation: 1. there can be lots of cycles, but at least one cycle\\n        // 2. if cycle length > 2 -> only one cycle allowed(eg3). if a cycle length = 2, it can have linkedlist point to any point on the cycle(eg1)\\n        // 3. At least one cycle must on table\\n        // method: compare the largest cycle  VS  all length = 2 cycle + the tails to each cycle\\n        // tail means: a linkedlist point to a length=2 cycle\\n\\n        //steps:\\n        //1. topologcal sort to find all the nodes that are on a cycle\\n        //2. find all cycles, the largest cycle has length X\\n        //3. for each length=2 cycle, it has 2 nodes, so at most 2 tails\\n        //                         find the 2 possible tails length -> how to start from 2 nodes and go to find the tails? use reverse graph\\n        //after all length=2 cycles been processed and find all tails, the total nodes are Y\\n        //4. return max(X, Y)\\n        //E = V, O(E+V) = O(n)\\n        int n = favorite.length;\\n        int[] indegree = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            indegree[favorite[i]]++;\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                int next = favorite[cur];\\n                indegree[next]--;\\n                if (indegree[next] == 0) {\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        //all nodes with indegree > 0 are on a cycle\\n        int maxCycleLength = 0;\\n        boolean[] visited = new boolean[n];\\n        List<Integer> cycleLengthTwo = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] != 0) {\\n                //find current cycle and mark as visited and record length of current cycle\\n                int length = 0;\\n                int cur = i;\\n                while (!visited[cur]) {\\n                    visited[cur] = true;\\n                    cur = favorite[cur];\\n                    length++;\\n                }\\n                maxCycleLength = Math.max(maxCycleLength, length);\\n                //if length == 2, store it\\n                if (length == 2) {\\n                    cycleLengthTwo.add(i);\\n                }\\n            }\\n        }\\n        //for each length=2 cycle, find possible tails, as to find tails, need reverse graph\\n        //build reverseGraph\\n        List<List<Integer>> reverseGraph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.get(favorite[i]).add(i);\\n        }\\n        //for each length=2 cycle, find tails using both nodes\\n        int totalCycleTwoLength = 0;\\n        for (int i = 0; i < cycleLengthTwo.size(); i++) {\\n            int curNode = cycleLengthTwo.get(i);\\n            int theOtherNode = favorite[curNode];\\n            totalCycleTwoLength += longestTail(curNode, reverseGraph, theOtherNode);\\n            totalCycleTwoLength += longestTail(theOtherNode, reverseGraph, curNode);\\n        }\\n        return Math.max(maxCycleLength, totalCycleTwoLength);\\n    }\\n\\n    private int longestTail(int cur, List<List<Integer>> reverseGraph, int theOther) {\\n        if (cur == theOther) {\\n            return 0;\\n        }\\n        int maxTail = 0;\\n        for (int next : reverseGraph.get(cur)) {\\n            maxTail = Math.max(maxTail, longestTail(next, reverseGraph, theOther));\\n        }\\n        return maxTail + 1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        // Observation: 1. there can be lots of cycles, but at least one cycle\\n        // 2. if cycle length > 2 -> only one cycle allowed(eg3). if a cycle length = 2, it can have linkedlist point to any point on the cycle(eg1)\\n        // 3. At least one cycle must on table\\n        // method: compare the largest cycle  VS  all length = 2 cycle + the tails to each cycle\\n        // tail means: a linkedlist point to a length=2 cycle\\n\\n        //steps:\\n        //1. topologcal sort to find all the nodes that are on a cycle\\n        //2. find all cycles, the largest cycle has length X\\n        //3. for each length=2 cycle, it has 2 nodes, so at most 2 tails\\n        //                         find the 2 possible tails length -> how to start from 2 nodes and go to find the tails? use reverse graph\\n        //after all length=2 cycles been processed and find all tails, the total nodes are Y\\n        //4. return max(X, Y)\\n        //E = V, O(E+V) = O(n)\\n        int n = favorite.length;\\n        int[] indegree = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            indegree[favorite[i]]++;\\n        }\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                queue.offer(i);\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                int next = favorite[cur];\\n                indegree[next]--;\\n                if (indegree[next] == 0) {\\n                    queue.offer(next);\\n                }\\n            }\\n        }\\n        //all nodes with indegree > 0 are on a cycle\\n        int maxCycleLength = 0;\\n        boolean[] visited = new boolean[n];\\n        List<Integer> cycleLengthTwo = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] != 0) {\\n                //find current cycle and mark as visited and record length of current cycle\\n                int length = 0;\\n                int cur = i;\\n                while (!visited[cur]) {\\n                    visited[cur] = true;\\n                    cur = favorite[cur];\\n                    length++;\\n                }\\n                maxCycleLength = Math.max(maxCycleLength, length);\\n                //if length == 2, store it\\n                if (length == 2) {\\n                    cycleLengthTwo.add(i);\\n                }\\n            }\\n        }\\n        //for each length=2 cycle, find possible tails, as to find tails, need reverse graph\\n        //build reverseGraph\\n        List<List<Integer>> reverseGraph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.add(new ArrayList<>());\\n        }\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.get(favorite[i]).add(i);\\n        }\\n        //for each length=2 cycle, find tails using both nodes\\n        int totalCycleTwoLength = 0;\\n        for (int i = 0; i < cycleLengthTwo.size(); i++) {\\n            int curNode = cycleLengthTwo.get(i);\\n            int theOtherNode = favorite[curNode];\\n            totalCycleTwoLength += longestTail(curNode, reverseGraph, theOtherNode);\\n            totalCycleTwoLength += longestTail(theOtherNode, reverseGraph, curNode);\\n        }\\n        return Math.max(maxCycleLength, totalCycleTwoLength);\\n    }\\n\\n    private int longestTail(int cur, List<List<Integer>> reverseGraph, int theOther) {\\n        if (cur == theOther) {\\n            return 0;\\n        }\\n        int maxTail = 0;\\n        for (int next : reverseGraph.get(cur)) {\\n            maxTail = Math.max(maxTail, longestTail(next, reverseGraph, theOther));\\n        }\\n        return maxTail + 1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376845,
                "title": "kosaraju",
                "content": "find strongly connected componets. \\n\\nsccs with length of two can form a crowd. you have to account for their largest arm on both sides.\\n\\nsccs with length greater than two form a clique.\\n\\nreturn the maximum clique or crowd formed \\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        # build graph and transpose\\n        graph = defaultdict(list)\\n        transpose = defaultdict(list)\\n        for u, v in enumerate(favorite):\\n            graph[u].append(v)\\n            transpose[v].append(u)\\n\\n        # first pass dfs\\n        stack = []\\n        def fill(node):\\n            visited.add(node)\\n            for adjacent in graph[node]:\\n                if adjacent not in visited:\\n                    fill(adjacent)\\n            stack.append(node)\\n\\n        # second pass dfs\\n        sccs = []\\n        scc = set()\\n        def dfs(node):\\n            visited.add(node)\\n            scc.add(node)\\n            for adjacent in transpose[node]:\\n                if adjacent not in visited:\\n                    dfs(adjacent)\\n\\n        # first pass kosaraju\\n        visited = set()\\n        for u in graph:\\n            if u not in visited:\\n                fill(u)\\n\\n        # second pass kosaraju\\n        visited = set()\\n        while stack:\\n            u = stack.pop()\\n            if u not in visited:\\n                scc = set()\\n                dfs(u)\\n                sccs.append(scc)\\n\\n        # find length of arm for joinable crowd\\n        def arm(u, v):\\n            length = 0\\n            for adjacent in transpose[u]:\\n                if adjacent != v:\\n                    length = max(length, arm(adjacent, v)+1)\\n            return length\\n            \\n        # get the max clique\\n        clique = max((len(scc) for scc in sccs if len(scc) != 2), default=0)\\n\\n        # calculate the crowd size\\n        crowd = 0\\n        for u, v in [scc for scc in sccs if len(scc) == 2]:\\n            crowd += 2 + arm(u, v) + arm(v, u)\\n\\n        # return the max clique or crowd possible\\n        return max(clique, crowd)\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        # build graph and transpose\\n        graph = defaultdict(list)\\n        transpose = defaultdict(list)\\n        for u, v in enumerate(favorite):\\n            graph[u].append(v)\\n            transpose[v].append(u)\\n\\n        # first pass dfs\\n        stack = []\\n        def fill(node):\\n            visited.add(node)\\n            for adjacent in graph[node]:\\n                if adjacent not in visited:\\n                    fill(adjacent)\\n            stack.append(node)\\n\\n        # second pass dfs\\n        sccs = []\\n        scc = set()\\n        def dfs(node):\\n            visited.add(node)\\n            scc.add(node)\\n            for adjacent in transpose[node]:\\n                if adjacent not in visited:\\n                    dfs(adjacent)\\n\\n        # first pass kosaraju\\n        visited = set()\\n        for u in graph:\\n            if u not in visited:\\n                fill(u)\\n\\n        # second pass kosaraju\\n        visited = set()\\n        while stack:\\n            u = stack.pop()\\n            if u not in visited:\\n                scc = set()\\n                dfs(u)\\n                sccs.append(scc)\\n\\n        # find length of arm for joinable crowd\\n        def arm(u, v):\\n            length = 0\\n            for adjacent in transpose[u]:\\n                if adjacent != v:\\n                    length = max(length, arm(adjacent, v)+1)\\n            return length\\n            \\n        # get the max clique\\n        clique = max((len(scc) for scc in sccs if len(scc) != 2), default=0)\\n\\n        # calculate the crowd size\\n        crowd = 0\\n        for u, v in [scc for scc in sccs if len(scc) == 2]:\\n            crowd += 2 + arm(u, v) + arm(v, u)\\n\\n        # return the max clique or crowd possible\\n        return max(clique, crowd)\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344443,
                "title": "kosaraju-s-algorithm-java-step-by-step-complete-solution-based-on-kosaraju-s-algo-100-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsolution is short but explanation is long\\nthis is a really hard question took me atleast 7 hours to get it all right.\\nso we simply need to find the maximum no of empoyees who can sit in a table with infinite space, but every employee need to have a other  favorite emplyee beside him is this circular table.\\nso it means every employee has 2 spots around him and one need to be the fav person,other can be anyone.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthis solutions requires you already know kosaraju\\'s algo\\nIn all components  their can be no cycles and the answer will be 1\\nor their are cycles.\\n or components have cycles of length 2 which can also have highest branches of each nodes of cycle other then its partner in cycle added,as in a cycle of 2,both nodes haves each other as fav so their is space for people on 1 side of both nodes.\\nso other branch can be added and even other cycles of 2 of other disconnected components can also be added.\\n\\nOr the cycle of component is greater than 2 ,so no space is left for others and that is the final length of that component.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlog(N+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nlog(N+E)\\n# Code\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {   \\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        int n=favorite.length;\\n\\n       //this solution is based on Kosaraju\\'s algo.\\n       //it contains 3 steps. this all has 3 main steps with conditions for edge cases;\\n       //1. make adjacency list\\n       //2. topological sort saved in a stack\\n       //3. transpose of the graph called \"rev\" ie. reversing all edges of the graph.\\n       // after this kosaraju\\'s algo is modified a bit for thr usecase\\n\\n       //1.making the adjacency list named graph\\n        for(int i=0;i<n;i++)\\n         graph.add(new ArrayList<Integer>());\\n\\n        for(int i=0;i<n;i++)\\n        graph.get(i).add(favorite[i]);\\n       \\n       //stack of topological sort \\n        Stack<Integer> s=new Stack<>();\\n        //visited array\\n        boolean[] vis=new boolean[n];\\n        \\n        //2. topological sort\\n        for(int i=0;i<n;i++)\\n        if(!vis[i])\\n        topo(i,vis,graph,s);\\n        \\n        //3. initializing reverse/tranpose graph \\n        ArrayList<ArrayList<Integer>> rev=new ArrayList<>();\\n\\n         for(int i=0;i<n;i++)\\n         rev.add(new ArrayList<Integer>());\\n       // filling the reverse graph or rev\\n        for(int i=0;i<n;i++)\\n        for(int val : graph.get(i))\\n        rev.get(val).add(i);\\n       \\n       //making the visited array false as it was used in topological sort\\n        for(int i=0;i<n;i++)\\n        vis[i]=false;\\n      \\n      //k is a important variable for edge cases. its for cycle of 2\\'s\\n      //more later\\n        int k=0;\\n    // queue to get the no of node of all strongly connected components(scc)  in a max heap\\n    //ie. decreasing order\\n        PriorityQueue<Integer> q=new PriorityQueue<Integer>((a,b)->b-a);\\n    \\n    // after all 3 steps, now nodes are traversed in dfs according to topollogical sort\\n    //stored in stack \"s\".\\n        while(!s.isEmpty()){\\n            int node=s.pop();\\n            //if a node is not visited means a new component and so we find its length\\n            // and mark all nodes traversed visited \"true\" to save on repetition.\\n            if(!vis[node]){\\n                //finding the length of component and storing in a temporary variable \"temp\"\\n                int temp=dfs(node,vis,rev);\\n                // now their are 3 cases for our answer\\n                //1. their are no cycles and graph is linear so length of all components will be 1\\n                // or their are cycles,cycles are of 2 nodes or more.\\n\\n                //2.  components with cycles of 2 can also have the longest branch of  both the nodes\\n                // added to the final length, below segment does that only and more.\\n                // lengths all the components with cycles of 2  can be added \\n                //for a biffer answer,thus variable k(why? see solotion description),\\n                // which adds all the final lengths of components with cycle of 2 \\n                if(temp==2){\\n                    //start with length to 0\\n                    temp=0;\\n                    //partneer refer to 2nd component of cycle other than node\\n                    int partner=-1;\\n                    //finding partner,which is that child of the node whose child is node itself\\n                    //making a 2 length cycle ie.\\n                    //  node-->child\\n                    //     <---\\n\\n                    for(int child : rev.get(node)){\\n                        for(int child2 : rev.get(child))\\n                        if(node==child2){\\n                        partner=child;\\n                        break;}\\n                        if(partner!=-1)\\n                        break;\\n                    }\\n                    //making another visited array to count length of longest branch\\n                    //including node, other than partner branch and visa versa\\n                    // and adding to temp \\n                    boolean[] dfsvis=new boolean[n];\\n                  temp+=lengthdfs(node,partner,dfsvis,rev);\\n                  temp+=lengthdfs(partner,node,dfsvis,rev);\\n                  //like discussed above add full length of component with cycle of 2 to k\\n                  k+=temp;\\n                }\\n                //3. component has cycle but is greater than 2,length of cycle will be thier final\\n                //length and no branch length will be added\\n                //adding the final length of component\\n                q.offer(temp);\\n            }\\n        }\\n        // largest component\\n        int size=q.poll();\\n        // if k is larger than size that means all combined length of cycles of 2 which is a valid answer\\n        // is the answer otherwise it is the highest length of cycle\\n        return size>k?size:k;      \\n    }\\n    \\n    // dfs to find highest branch of node other than its cycle partner\\'s\\n    public int lengthdfs(int node,int partner,boolean[] dfsvis,ArrayList<ArrayList<Integer>> graph){\\n            dfsvis[node]=true;\\n            int count=0;\\n            for(int child : graph.get(node))\\n                if(child!=partner && dfsvis[child]==false)\\n                count=Math.max(count,lengthdfs(child,node,dfsvis,graph));\\n            \\n            dfsvis[node]=false;\\n            return count+1;\\n    }\\n   //topological sort of graph\\n    public void topo(int node,boolean[] vis,ArrayList<ArrayList<Integer>> graph,Stack<Integer> s){\\n        vis[node]=true;    \\n        for(int child : graph.get(node))\\n            if(!vis[child])\\n                topo(child,vis,graph,s);\\n        \\n        s.push(node);\\n    }\\n   // dfs to find the length of cycle of the component\\n   //this only works if graph(rev) is reversed as components are visible easily\\n     public int dfs(int node,boolean[] vis,ArrayList<ArrayList<Integer>> graph){\\n         vis[node]=true;\\n         int count=1;\\n         for(int child : graph.get(node))\\n             if(!vis[child] )\\n               count+=dfs(child,vis,graph);\\n\\n         return count;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {   \\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        int n=favorite.length;\\n\\n       //this solution is based on Kosaraju\\'s algo.\\n       //it contains 3 steps. this all has 3 main steps with conditions for edge cases;\\n       //1. make adjacency list\\n       //2. topological sort saved in a stack\\n       //3. transpose of the graph called \"rev\" ie. reversing all edges of the graph.\\n       // after this kosaraju\\'s algo is modified a bit for thr usecase\\n\\n       //1.making the adjacency list named graph\\n        for(int i=0;i<n;i++)\\n         graph.add(new ArrayList<Integer>());\\n\\n        for(int i=0;i<n;i++)\\n        graph.get(i).add(favorite[i]);\\n       \\n       //stack of topological sort \\n        Stack<Integer> s=new Stack<>();\\n        //visited array\\n        boolean[] vis=new boolean[n];\\n        \\n        //2. topological sort\\n        for(int i=0;i<n;i++)\\n        if(!vis[i])\\n        topo(i,vis,graph,s);\\n        \\n        //3. initializing reverse/tranpose graph \\n        ArrayList<ArrayList<Integer>> rev=new ArrayList<>();\\n\\n         for(int i=0;i<n;i++)\\n         rev.add(new ArrayList<Integer>());\\n       // filling the reverse graph or rev\\n        for(int i=0;i<n;i++)\\n        for(int val : graph.get(i))\\n        rev.get(val).add(i);\\n       \\n       //making the visited array false as it was used in topological sort\\n        for(int i=0;i<n;i++)\\n        vis[i]=false;\\n      \\n      //k is a important variable for edge cases. its for cycle of 2\\'s\\n      //more later\\n        int k=0;\\n    // queue to get the no of node of all strongly connected components(scc)  in a max heap\\n    //ie. decreasing order\\n        PriorityQueue<Integer> q=new PriorityQueue<Integer>((a,b)->b-a);\\n    \\n    // after all 3 steps, now nodes are traversed in dfs according to topollogical sort\\n    //stored in stack \"s\".\\n        while(!s.isEmpty()){\\n            int node=s.pop();\\n            //if a node is not visited means a new component and so we find its length\\n            // and mark all nodes traversed visited \"true\" to save on repetition.\\n            if(!vis[node]){\\n                //finding the length of component and storing in a temporary variable \"temp\"\\n                int temp=dfs(node,vis,rev);\\n                // now their are 3 cases for our answer\\n                //1. their are no cycles and graph is linear so length of all components will be 1\\n                // or their are cycles,cycles are of 2 nodes or more.\\n\\n                //2.  components with cycles of 2 can also have the longest branch of  both the nodes\\n                // added to the final length, below segment does that only and more.\\n                // lengths all the components with cycles of 2  can be added \\n                //for a biffer answer,thus variable k(why? see solotion description),\\n                // which adds all the final lengths of components with cycle of 2 \\n                if(temp==2){\\n                    //start with length to 0\\n                    temp=0;\\n                    //partneer refer to 2nd component of cycle other than node\\n                    int partner=-1;\\n                    //finding partner,which is that child of the node whose child is node itself\\n                    //making a 2 length cycle ie.\\n                    //  node-->child\\n                    //     <---\\n\\n                    for(int child : rev.get(node)){\\n                        for(int child2 : rev.get(child))\\n                        if(node==child2){\\n                        partner=child;\\n                        break;}\\n                        if(partner!=-1)\\n                        break;\\n                    }\\n                    //making another visited array to count length of longest branch\\n                    //including node, other than partner branch and visa versa\\n                    // and adding to temp \\n                    boolean[] dfsvis=new boolean[n];\\n                  temp+=lengthdfs(node,partner,dfsvis,rev);\\n                  temp+=lengthdfs(partner,node,dfsvis,rev);\\n                  //like discussed above add full length of component with cycle of 2 to k\\n                  k+=temp;\\n                }\\n                //3. component has cycle but is greater than 2,length of cycle will be thier final\\n                //length and no branch length will be added\\n                //adding the final length of component\\n                q.offer(temp);\\n            }\\n        }\\n        // largest component\\n        int size=q.poll();\\n        // if k is larger than size that means all combined length of cycles of 2 which is a valid answer\\n        // is the answer otherwise it is the highest length of cycle\\n        return size>k?size:k;      \\n    }\\n    \\n    // dfs to find highest branch of node other than its cycle partner\\'s\\n    public int lengthdfs(int node,int partner,boolean[] dfsvis,ArrayList<ArrayList<Integer>> graph){\\n            dfsvis[node]=true;\\n            int count=0;\\n            for(int child : graph.get(node))\\n                if(child!=partner && dfsvis[child]==false)\\n                count=Math.max(count,lengthdfs(child,node,dfsvis,graph));\\n            \\n            dfsvis[node]=false;\\n            return count+1;\\n    }\\n   //topological sort of graph\\n    public void topo(int node,boolean[] vis,ArrayList<ArrayList<Integer>> graph,Stack<Integer> s){\\n        vis[node]=true;    \\n        for(int child : graph.get(node))\\n            if(!vis[child])\\n                topo(child,vis,graph,s);\\n        \\n        s.push(node);\\n    }\\n   // dfs to find the length of cycle of the component\\n   //this only works if graph(rev) is reversed as components are visible easily\\n     public int dfs(int node,boolean[] vis,ArrayList<ArrayList<Integer>> graph){\\n         vis[node]=true;\\n         int count=1;\\n         for(int child : graph.get(node))\\n             if(!vis[child] )\\n               count+=dfs(child,vis,graph);\\n\\n         return count;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282038,
                "title": "c-find-circle-and-semi-circle",
                "content": "# Intuition\\nthere are 2 cases:\\n1. circle:  1->2->3->1\\n2. semi-circle  a->b->c...->1<->2<-d<-e....<-z, where 1 and 2 are a friend pair\\n3. if there are more than one semi-circle exist, all of them can sit on the table. \\nso result = max(max circle, sum of semi-circle)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        g = move(favorite);\\n        n = g.size();\\n        isPair.resize(n);\\n        greverse.resize(n);\\n        findPair();\\n        vector<int> result(n, 0), visited(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(g[g[i]] != i) greverse[g[i]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            if(isPair[i]) result[i] = depth(i, visited);\\n\\n        int maxCircle = 0;\\n        for(int i=0;i<n;i++)\\n            findCircle(i, visited, maxCircle);\\n\\n        int pairSum = 0;\\n        for(int i=0;i<n;i++){\\n            if(!isPair[i]) continue;\\n            int j = g[i];\\n            pairSum +=  result[i] + result[j];\\n        }\\n        return max(maxCircle, pairSum/2) ;\\n    }\\n\\n    void findPair(){\\n        for(int i=0;i<g.size();i++){\\n            if(g[g[i]] == i) {\\n                isPair[i] = isPair[g[i]] = true;\\n            }\\n        }\\n    }\\n\\n    int depth(int i, vector<int>& visited){\\n        visited[i] = true;\\n        int res = 0;\\n        for(auto j:greverse[i]){\\n            res = max(res, depth(j, visited));\\n        }\\n        return 1+res;\\n    }\\n\\n    void findCircle(int i, vector<int>& visited, int& res){\\n        if(visited[i]) return;\\n        unordered_map<int,int> visiting;\\n        while(visiting[i] < 2){\\n            if(visited[i]) break;\\n            visiting[i]++;\\n            i = g[i];\\n        }\\n\\n        int count = 0;\\n        for(auto [x, n] : visiting){\\n            visited[x] = true;\\n            if(n>1) count++;\\n        }\\n        res = max(res, count);\\n    }\\n\\n\\n    int n;\\n    vector<int> g;\\n    vector<vector<int>> greverse;\\n    vector<bool> isPair;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        g = move(favorite);\\n        n = g.size();\\n        isPair.resize(n);\\n        greverse.resize(n);\\n        findPair();\\n        vector<int> result(n, 0), visited(n, 0);\\n        for(int i=0;i<n;i++) {\\n            if(g[g[i]] != i) greverse[g[i]].push_back(i);\\n        }\\n        for(int i=0;i<n;i++)\\n            if(isPair[i]) result[i] = depth(i, visited);\\n\\n        int maxCircle = 0;\\n        for(int i=0;i<n;i++)\\n            findCircle(i, visited, maxCircle);\\n\\n        int pairSum = 0;\\n        for(int i=0;i<n;i++){\\n            if(!isPair[i]) continue;\\n            int j = g[i];\\n            pairSum +=  result[i] + result[j];\\n        }\\n        return max(maxCircle, pairSum/2) ;\\n    }\\n\\n    void findPair(){\\n        for(int i=0;i<g.size();i++){\\n            if(g[g[i]] == i) {\\n                isPair[i] = isPair[g[i]] = true;\\n            }\\n        }\\n    }\\n\\n    int depth(int i, vector<int>& visited){\\n        visited[i] = true;\\n        int res = 0;\\n        for(auto j:greverse[i]){\\n            res = max(res, depth(j, visited));\\n        }\\n        return 1+res;\\n    }\\n\\n    void findCircle(int i, vector<int>& visited, int& res){\\n        if(visited[i]) return;\\n        unordered_map<int,int> visiting;\\n        while(visiting[i] < 2){\\n            if(visited[i]) break;\\n            visiting[i]++;\\n            i = g[i];\\n        }\\n\\n        int count = 0;\\n        for(auto [x, n] : visiting){\\n            visited[x] = true;\\n            if(n>1) count++;\\n        }\\n        res = max(res, count);\\n    }\\n\\n\\n    int n;\\n    vector<int> g;\\n    vector<vector<int>> greverse;\\n    vector<bool> isPair;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254147,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_invitations(favorite: Vec<i32>) -> i32 {\\n        let n = favorite.len();\\n        let mut visited = vec![false; n];\\n        let mut to_leaf = vec![0; n];\\n        let mut in_degree = vec![0; n];\\n\\n        for &item in favorite.iter() {\\n            in_degree[item as usize] += 1;\\n        }\\n        let mut q = std::collections::VecDeque::new();\\n        for (i, &item) in in_degree.iter().enumerate() {\\n            if item == 0 {\\n                q.push_back(i);\\n                visited[i] = true;\\n            }\\n        }\\n\\n        while !q.is_empty() {\\n            let el = q.pop_front().unwrap();\\n            let j = favorite[el];\\n            to_leaf[j as usize] = to_leaf[j as usize].max(1 + to_leaf[el]);\\n            in_degree[j as usize] -= 1;\\n            if in_degree[j as usize] == 0 {\\n                visited[j as usize] = true;\\n                q.push_back(j as usize);\\n            }\\n        }\\n\\n        let (mut res, mut res2) = (0, 0);\\n        for i in 0..n {\\n            if !visited[i] {\\n                let mut len = 0;\\n                let mut j = i;\\n                while !visited[j] {\\n                    visited[j] = true;\\n                    len += 1;\\n                    j = favorite[j] as usize;\\n                }\\n                if len == 2 {\\n                    res2 += 2 + to_leaf[i] + to_leaf[favorite[i] as usize];\\n                } else {\\n                    res = res.max(len);\\n                }\\n            }\\n        }\\n\\n        res.max(res2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_invitations(favorite: Vec<i32>) -> i32 {\\n        let n = favorite.len();\\n        let mut visited = vec![false; n];\\n        let mut to_leaf = vec![0; n];\\n        let mut in_degree = vec![0; n];\\n\\n        for &item in favorite.iter() {\\n            in_degree[item as usize] += 1;\\n        }\\n        let mut q = std::collections::VecDeque::new();\\n        for (i, &item) in in_degree.iter().enumerate() {\\n            if item == 0 {\\n                q.push_back(i);\\n                visited[i] = true;\\n            }\\n        }\\n\\n        while !q.is_empty() {\\n            let el = q.pop_front().unwrap();\\n            let j = favorite[el];\\n            to_leaf[j as usize] = to_leaf[j as usize].max(1 + to_leaf[el]);\\n            in_degree[j as usize] -= 1;\\n            if in_degree[j as usize] == 0 {\\n                visited[j as usize] = true;\\n                q.push_back(j as usize);\\n            }\\n        }\\n\\n        let (mut res, mut res2) = (0, 0);\\n        for i in 0..n {\\n            if !visited[i] {\\n                let mut len = 0;\\n                let mut j = i;\\n                while !visited[j] {\\n                    visited[j] = true;\\n                    len += 1;\\n                    j = favorite[j] as usize;\\n                }\\n                if len == 2 {\\n                    res2 += 2 + to_leaf[i] + to_leaf[favorite[i] as usize];\\n                } else {\\n                    res = res.max(len);\\n                }\\n            }\\n        }\\n\\n        res.max(res2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130934,
                "title": "c-solution-topo-sort-dfs-bfs-level-wise-traversal",
                "content": "# Code\\n```\\n// Time Complexity: O(V+E)\\n// Space Complexity: O(V+E)\\nclass Solution {\\npublic:\\n    void toposort(vector<vector<int>>&adjList,vector<int>&visited,stack<int>&st, int node)\\n    {\\n        // mark as visited\\n        visited[node]=1;\\n         \\n        // traverse over neighbors\\n        for(auto adjNode: adjList[node])\\n          // yet not visited\\n           if(!visited[adjNode])\\n              toposort(adjList,visited,st,adjNode);\\n       st.push(node);\\n       \\n    }\\n\\n    int dfs(vector<vector<int>>&adjList,vector<int>&visited,int node,vector<int>&Nodes)\\n    {\\n        // mark as visited\\n         visited[node]=1;\\n          int cnt=1;\\n          Nodes.push_back(node);\\n         // traverse over neighbor nodes\\n         for(auto adjNode: adjList[node])\\n          // yet not visited\\n           if(!visited[adjNode])\\n            cnt+=dfs(adjList,visited,adjNode,Nodes);\\n        \\n        // return \\n        return cnt;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n\\n        // create an adjacency list\\n        int n=favorite.size();\\n        if(n<=3)\\n          return n;\\n        vector<vector<int>>adjList(n,vector<int>());\\n        for(int i=0;i<n;i++)\\n          adjList[i].push_back(favorite[i]);\\n\\n        stack<int>st;\\n        vector<int>visited(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n          if(!visited[i])\\n           toposort(adjList,visited,st,i);\\n        \\n        // transpose of graph\\n        vector<vector<int>>adjT(n,vector<int>());\\n        \\n        for(int i=0;i<n;i++)\\n          {  visited[i]=0;\\n              adjT[favorite[i]].push_back(i);\\n          }\\n        int sum=0;\\n        while(!st.empty())\\n        {   vector<int>Nodes;\\n            int node=st.top();\\n            st.pop();\\n             int lc;\\n            if(!visited[node])\\n             {lc=dfs(adjT,visited,node,Nodes);\\n               if(lc>2)\\n              ans=max(lc,ans);\\n              else\\n              if(lc==2)\\n             {  \\n              \\n                sum+=extendL(adjT,Nodes[0],Nodes[1],n);\\n                sum+=extendL(adjT,Nodes[1],Nodes[0],n);\\n             }\\n              }\\n        }\\n       \\n       return  max(sum,ans);\\n    }\\n    int extendL(vector<vector<int>>&adjT,int node,int parent,int n)\\n    {\\n        // do level wise bfs\\n        queue<int>q;\\n        q.push(node);\\n        vector<int>visited(n,0);\\n\\n        // to count no. of nodes\\n        int cnt=0;\\n\\n        while(!q.empty())\\n        {\\n            int Size=q.size();\\n\\n            for(int i=0;i<Size;i++)\\n            {\\n                int node=q.front();\\n                q.pop();\\n\\n                // traverse over neighbors\\n                for(auto adjNode: adjT[node])\\n                  {\\n                      if(adjNode==parent) continue;\\n                      \\n                      // yet not visited\\n                      if(!visited[adjNode])\\n                      {\\n                          q.push(adjNode);\\n                          // mark as visited\\n                          visited[adjNode]=1;\\n                      }\\n                  }\\n            }\\n             cnt++;\\n        }\\n\\n        // return ans\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n// Time Complexity: O(V+E)\\n// Space Complexity: O(V+E)\\nclass Solution {\\npublic:\\n    void toposort(vector<vector<int>>&adjList,vector<int>&visited,stack<int>&st, int node)\\n    {\\n        // mark as visited\\n        visited[node]=1;\\n         \\n        // traverse over neighbors\\n        for(auto adjNode: adjList[node])\\n          // yet not visited\\n           if(!visited[adjNode])\\n              toposort(adjList,visited,st,adjNode);\\n       st.push(node);\\n       \\n    }\\n\\n    int dfs(vector<vector<int>>&adjList,vector<int>&visited,int node,vector<int>&Nodes)\\n    {\\n        // mark as visited\\n         visited[node]=1;\\n          int cnt=1;\\n          Nodes.push_back(node);\\n         // traverse over neighbor nodes\\n         for(auto adjNode: adjList[node])\\n          // yet not visited\\n           if(!visited[adjNode])\\n            cnt+=dfs(adjList,visited,adjNode,Nodes);\\n        \\n        // return \\n        return cnt;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n\\n        // create an adjacency list\\n        int n=favorite.size();\\n        if(n<=3)\\n          return n;\\n        vector<vector<int>>adjList(n,vector<int>());\\n        for(int i=0;i<n;i++)\\n          adjList[i].push_back(favorite[i]);\\n\\n        stack<int>st;\\n        vector<int>visited(n,0);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n          if(!visited[i])\\n           toposort(adjList,visited,st,i);\\n        \\n        // transpose of graph\\n        vector<vector<int>>adjT(n,vector<int>());\\n        \\n        for(int i=0;i<n;i++)\\n          {  visited[i]=0;\\n              adjT[favorite[i]].push_back(i);\\n          }\\n        int sum=0;\\n        while(!st.empty())\\n        {   vector<int>Nodes;\\n            int node=st.top();\\n            st.pop();\\n             int lc;\\n            if(!visited[node])\\n             {lc=dfs(adjT,visited,node,Nodes);\\n               if(lc>2)\\n              ans=max(lc,ans);\\n              else\\n              if(lc==2)\\n             {  \\n              \\n                sum+=extendL(adjT,Nodes[0],Nodes[1],n);\\n                sum+=extendL(adjT,Nodes[1],Nodes[0],n);\\n             }\\n              }\\n        }\\n       \\n       return  max(sum,ans);\\n    }\\n    int extendL(vector<vector<int>>&adjT,int node,int parent,int n)\\n    {\\n        // do level wise bfs\\n        queue<int>q;\\n        q.push(node);\\n        vector<int>visited(n,0);\\n\\n        // to count no. of nodes\\n        int cnt=0;\\n\\n        while(!q.empty())\\n        {\\n            int Size=q.size();\\n\\n            for(int i=0;i<Size;i++)\\n            {\\n                int node=q.front();\\n                q.pop();\\n\\n                // traverse over neighbors\\n                for(auto adjNode: adjT[node])\\n                  {\\n                      if(adjNode==parent) continue;\\n                      \\n                      // yet not visited\\n                      if(!visited[adjNode])\\n                      {\\n                          q.push(adjNode);\\n                          // mark as visited\\n                          visited[adjNode]=1;\\n                      }\\n                  }\\n            }\\n             cnt++;\\n        }\\n\\n        // return ans\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095838,
                "title": "java-pseudotree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        int len = favorite.length;\\n        //\\u5185\\u5411\\u57FA\\u73AF\\u6811\\n        //\\u6BCF\\u4E2A\\u8282\\u70B9\\u7684\\u5165\\u5EA6\\n        int[] degree = new int[len];\\n        \\n        for (int i = 0; i < favorite.length; i ++) {\\n            degree[favorite[i]] ++;\\n        }\\n\\n        //\\u6700\\u5927\\u6DF1\\u5EA6(\\u7528\\u4E8E\\u6DF1\\u5EA6\\u4E3A2\\u65F6\\u8BA1\\u7B97\\u4F7F\\u7528)\\n        int[] maxDepth = new int[len];\\n\\n        //\\u5148\\u526A\\u679D\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < len; i ++) {\\n            if(degree[i] == 0) {\\n                stack.push(i);\\n            }\\n        }\\n\\n        while (! stack.isEmpty()) {\\n            int cur = stack.pop();\\n            maxDepth[cur] ++;\\n            //\\u53EA\\u6709\\u4E00\\u6761\\u51FA\\u8FB9\\n            int neigh = favorite[cur];\\n            maxDepth[neigh] = Math.max(maxDepth[neigh], maxDepth[cur]);\\n            if (-- degree[neigh] == 0) {\\n                stack.push(neigh);\\n            }\\n        }\\n\\n        int maxRingSize = 0, sumChainSize = 0;\\n\\n        //\\u904D\\u5386\\n        for (int i = 0; i < len; i ++) {\\n            if (degree[i] <= 0){\\n                //\\u8BF4\\u660E\\u662F\\u6811\\u679D\\n                continue;\\n            } \\n            //\\u904D\\u5386\\u73AF\\u4E0A\\u7684\\u8282\\u70B9\\n            degree[i] = -1;\\n            int tempRingSize = 1;\\n            //\\u904D\\u5386\\u73AF\\n            for (int j = favorite[i]; j != i; j = favorite[j]) {\\n                tempRingSize ++;\\n                degree[j] = -1;\\n            }\\n            if (tempRingSize == 2) {\\n                sumChainSize += maxDepth[i] + maxDepth[favorite[i]] + 2;\\n            } else {\\n                maxRingSize = Math.max(maxRingSize, tempRingSize);\\n            }\\n        }\\n\\n        return Math.max(maxRingSize, sumChainSize);\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        int len = favorite.length;\\n        //\\u5185\\u5411\\u57FA\\u73AF\\u6811\\n        //\\u6BCF\\u4E2A\\u8282\\u70B9\\u7684\\u5165\\u5EA6\\n        int[] degree = new int[len];\\n        \\n        for (int i = 0; i < favorite.length; i ++) {\\n            degree[favorite[i]] ++;\\n        }\\n\\n        //\\u6700\\u5927\\u6DF1\\u5EA6(\\u7528\\u4E8E\\u6DF1\\u5EA6\\u4E3A2\\u65F6\\u8BA1\\u7B97\\u4F7F\\u7528)\\n        int[] maxDepth = new int[len];\\n\\n        //\\u5148\\u526A\\u679D\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < len; i ++) {\\n            if(degree[i] == 0) {\\n                stack.push(i);\\n            }\\n        }\\n\\n        while (! stack.isEmpty()) {\\n            int cur = stack.pop();\\n            maxDepth[cur] ++;\\n            //\\u53EA\\u6709\\u4E00\\u6761\\u51FA\\u8FB9\\n            int neigh = favorite[cur];\\n            maxDepth[neigh] = Math.max(maxDepth[neigh], maxDepth[cur]);\\n            if (-- degree[neigh] == 0) {\\n                stack.push(neigh);\\n            }\\n        }\\n\\n        int maxRingSize = 0, sumChainSize = 0;\\n\\n        //\\u904D\\u5386\\n        for (int i = 0; i < len; i ++) {\\n            if (degree[i] <= 0){\\n                //\\u8BF4\\u660E\\u662F\\u6811\\u679D\\n                continue;\\n            } \\n            //\\u904D\\u5386\\u73AF\\u4E0A\\u7684\\u8282\\u70B9\\n            degree[i] = -1;\\n            int tempRingSize = 1;\\n            //\\u904D\\u5386\\u73AF\\n            for (int j = favorite[i]; j != i; j = favorite[j]) {\\n                tempRingSize ++;\\n                degree[j] = -1;\\n            }\\n            if (tempRingSize == 2) {\\n                sumChainSize += maxDepth[i] + maxDepth[favorite[i]] + 2;\\n            } else {\\n                maxRingSize = Math.max(maxRingSize, tempRingSize);\\n            }\\n        }\\n\\n        return Math.max(maxRingSize, sumChainSize);\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075783,
                "title": "python-union-find-topological-pass-use-picture-to-illustrate",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screen Shot 2023-01-19 at 10.35.26 PM.png](https://assets.leetcode.com/users/images/42cce101-6554-4abe-a63d-5ba2ec66eafb_1674196536.7635567.png)\\n\\nUnion-Find + Topological Pass\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        self.size = [1] * n\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr != yr:\\n            if self.size[xr] < self.size[yr]:\\n                x, y = y, x\\n            self.parents[yr] = xr\\n            self.size[xr] += self.size[yr]\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        tail_length = [1] * n\\n        inDegree = [0] * n\\n        # Building Topological Sequences\\n        for curr in range(n):\\n            inDegree[favorite[curr]] += 1\\n        # Calculating the length of tail of each popular person\\n        queue = deque([c for c in range(n) if inDegree[c] == 0])\\n        while queue:\\n            curr = queue.popleft()\\n            fav = favorite[curr]\\n            # beacuse `fav` also have his own preference, as a result, if it previously has a tail\\n            # in other word, ans[fav] > 1, then we want to pick the largest one between the previous\\n            # tail and current tail\\n            tail_length[fav] = max(tail_length[fav], tail_length[curr] + 1)\\n            inDegree[fav] -= 1\\n            if inDegree[fav] == 0:\\n                queue.append(fav)\\n        # Building the Union Find of popular person\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            if inDegree[i]:\\n                uf.union(i, favorite[i])\\n        # Two Situation:\\n        # Either we pick two popular person who like each other and join them together (Union Find size = 2)\\n        # or we we can select the size of this popluar person group (Union Find size > 2)\\n        join = 0\\n        res = 0\\n        for i in range(n):\\n            if not inDegree[i]:\\n                continue\\n            curr = uf.size[uf.find(i)]\\n            if curr == 2:\\n                fav = favorite[i]\\n                inDegree[fav] -= 1\\n                curr = tail_length[i] + tail_length[fav]\\n                join += curr\\n            else:\\n                res = max(res, curr)\\n        return max(res, join)\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Topological Sort"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parents = list(range(n))\\n        self.size = [1] * n\\n    \\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        if xr != yr:\\n            if self.size[xr] < self.size[yr]:\\n                x, y = y, x\\n            self.parents[yr] = xr\\n            self.size[xr] += self.size[yr]\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        tail_length = [1] * n\\n        inDegree = [0] * n\\n        # Building Topological Sequences\\n        for curr in range(n):\\n            inDegree[favorite[curr]] += 1\\n        # Calculating the length of tail of each popular person\\n        queue = deque([c for c in range(n) if inDegree[c] == 0])\\n        while queue:\\n            curr = queue.popleft()\\n            fav = favorite[curr]\\n            # beacuse `fav` also have his own preference, as a result, if it previously has a tail\\n            # in other word, ans[fav] > 1, then we want to pick the largest one between the previous\\n            # tail and current tail\\n            tail_length[fav] = max(tail_length[fav], tail_length[curr] + 1)\\n            inDegree[fav] -= 1\\n            if inDegree[fav] == 0:\\n                queue.append(fav)\\n        # Building the Union Find of popular person\\n        uf = UnionFind(n)\\n        for i in range(n):\\n            if inDegree[i]:\\n                uf.union(i, favorite[i])\\n        # Two Situation:\\n        # Either we pick two popular person who like each other and join them together (Union Find size = 2)\\n        # or we we can select the size of this popluar person group (Union Find size > 2)\\n        join = 0\\n        res = 0\\n        for i in range(n):\\n            if not inDegree[i]:\\n                continue\\n            curr = uf.size[uf.find(i)]\\n            if curr == 2:\\n                fav = favorite[i]\\n                inDegree[fav] -= 1\\n                curr = tail_length[i] + tail_length[fav]\\n                join += curr\\n            else:\\n                res = max(res, curr)\\n        return max(res, join)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912699,
                "title": "c-mutual-favorites-approach-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) \\n# Code\\n```\\nclass Solution {\\n\\n    int dfs(int i, vector<vector<int>>& rvfL){\\n\\n        visited[i] = true;\\n        int res = 0;\\n\\n        for(auto f: rvfL[i]){\\n            res = max(res, dfs(f, rvfL));\\n        }\\n        \\n\\n        return res + 1;\\n    }\\n    bool visited[100000] = {};\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        //find mutual favorites (use reverse fav map) and then \\n        // chain favs of those either side\\n        //Next possible comb is chain of favorites until you hit loop\\n        // length of loop is total length - start to location of loop start.\\n        vector<vector<int>> rvfL(favorite.size()); //reverse favorite\\n        for(int i=0; i < favorite.size(); ++i){\\n            if(favorite[favorite[i]] != i)\\n                rvfL[favorite[i]].push_back(i);\\n        }\\n        int res = 0;\\n        for(int i=0; i < favorite.size(); ++i){\\n            if(favorite[favorite[i]] == i){\\n                res += dfs(i, rvfL);\\n            }\\n        }\\n\\n        //next find longest chain around table\\n        for(int i=0; i < favorite.size(); ++i){\\n\\n            int j=i, cnt = 0;\\n            for(; visited[j] == false; j = favorite[j]){\\n\\n                 visited[j] = true;\\n                 ++cnt;\\n\\n            }\\n\\n            for(int k=i; k != j; k = favorite[k] )\\n            {\\n                --cnt;\\n            }\\n            res = max(res, cnt);\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(int i, vector<vector<int>>& rvfL){\\n\\n        visited[i] = true;\\n        int res = 0;\\n\\n        for(auto f: rvfL[i]){\\n            res = max(res, dfs(f, rvfL));\\n        }\\n        \\n\\n        return res + 1;\\n    }\\n    bool visited[100000] = {};\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        //find mutual favorites (use reverse fav map) and then \\n        // chain favs of those either side\\n        //Next possible comb is chain of favorites until you hit loop\\n        // length of loop is total length - start to location of loop start.\\n        vector<vector<int>> rvfL(favorite.size()); //reverse favorite\\n        for(int i=0; i < favorite.size(); ++i){\\n            if(favorite[favorite[i]] != i)\\n                rvfL[favorite[i]].push_back(i);\\n        }\\n        int res = 0;\\n        for(int i=0; i < favorite.size(); ++i){\\n            if(favorite[favorite[i]] == i){\\n                res += dfs(i, rvfL);\\n            }\\n        }\\n\\n        //next find longest chain around table\\n        for(int i=0; i < favorite.size(); ++i){\\n\\n            int j=i, cnt = 0;\\n            for(; visited[j] == false; j = favorite[j]){\\n\\n                 visited[j] = true;\\n                 ++cnt;\\n\\n            }\\n\\n            for(int k=i; k != j; k = favorite[k] )\\n            {\\n                --cnt;\\n            }\\n            res = max(res, cnt);\\n        }\\n\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911285,
                "title": "c-dfs-kosaraju-s-algorithm",
                "content": "# Approach\\nThis question need some drawing and thinking if we build a directed graph directed to i from favorite[i].\\nAlso, every node has its favorite guy so their will be an originator of the graph that come from someone that shows that our cycle will be originator.\\nWe take cycles first into our vector<cycle> cycles.\\nObservation:\\n> Cycle size greater than 2 will not allow any else to the table.\\nso our ans = max(ans, sizeof(cycle))\\n> Cycle with size 2 we can find the maximum depth from node1 and similiar to node2 and we add all size2 cycle with extended arms.\\nans = max(ans, summationof(sizeof(cycle) == 2 with extended arms)).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    const static int N = 1e5 + 1;\\n    int vis[N];\\n    int cache[N];\\n    vector<int> order;\\n    vector<int> components;\\n    vector<int> g[N];\\n    vector<int> rg[N];\\n    \\n    void dfs1(int node) {\\n        vis[node] = 1;\\n        for(int child : g[node]) {\\n            if(vis[child] == 0) {\\n                dfs1(child);\\n            }    \\n        }\\n        order.push_back(node);\\n    }\\n    \\n    void dfs2(int node) {\\n        vis[node] = 1;\\n        components.push_back(node);\\n        for(int child : rg[node]) {\\n            if(vis[child] == 0) {\\n                dfs2(child);\\n            }\\n        }\\n    }\\n    \\n    int dfs3(int node, int& not_consider) {\\n        int& ans = cache[node];\\n        if(ans != 0) {\\n            return ans;\\n        }\\n        ans = 1;\\n        for(int child : g[node]) {\\n            if(child == not_consider) {\\n                continue;\\n            }\\n            ans = max(ans, 1 + dfs3(child, not_consider));\\n        }\\n        return ans;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        for(int i = 0; i < n; i++) {\\n            g[favorite[i]].push_back(i);\\n            rg[i].push_back(favorite[i]);\\n        }\\n        // firstly find all the cycles because they will be originator\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                dfs1(i);\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        for(int i = 0; i < n; i++) {\\n            vis[i] = 0;\\n        }\\n        vector<vector<int>> cycles;\\n        for(int node : order) {\\n            if(vis[node] == 0) {\\n                components.clear();\\n                dfs2(node);\\n                if(components.size() >= 2) {\\n                    cycles.push_back(components);                    \\n                }\\n            }\\n        }\\n        // Now we got all the cycles\\n        int ans = 0;\\n        for(auto cycle : cycles) {\\n            if((int) cycle.size() == 2) {\\n                int u = cycle[0];\\n                int v = cycle[1];\\n                ans += dfs3(u, v) + dfs3(v, u);\\n            }\\n        }\\n        for(auto cycle : cycles) {\\n            if((int) cycle.size() > 2) {\\n                ans = max(ans, (int)cycle.size());\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const static int N = 1e5 + 1;\\n    int vis[N];\\n    int cache[N];\\n    vector<int> order;\\n    vector<int> components;\\n    vector<int> g[N];\\n    vector<int> rg[N];\\n    \\n    void dfs1(int node) {\\n        vis[node] = 1;\\n        for(int child : g[node]) {\\n            if(vis[child] == 0) {\\n                dfs1(child);\\n            }    \\n        }\\n        order.push_back(node);\\n    }\\n    \\n    void dfs2(int node) {\\n        vis[node] = 1;\\n        components.push_back(node);\\n        for(int child : rg[node]) {\\n            if(vis[child] == 0) {\\n                dfs2(child);\\n            }\\n        }\\n    }\\n    \\n    int dfs3(int node, int& not_consider) {\\n        int& ans = cache[node];\\n        if(ans != 0) {\\n            return ans;\\n        }\\n        ans = 1;\\n        for(int child : g[node]) {\\n            if(child == not_consider) {\\n                continue;\\n            }\\n            ans = max(ans, 1 + dfs3(child, not_consider));\\n        }\\n        return ans;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        for(int i = 0; i < n; i++) {\\n            g[favorite[i]].push_back(i);\\n            rg[i].push_back(favorite[i]);\\n        }\\n        // firstly find all the cycles because they will be originator\\n        for(int i = 0; i < n; i++) {\\n            if(vis[i] == 0) {\\n                dfs1(i);\\n            }\\n        }\\n        reverse(order.begin(), order.end());\\n        for(int i = 0; i < n; i++) {\\n            vis[i] = 0;\\n        }\\n        vector<vector<int>> cycles;\\n        for(int node : order) {\\n            if(vis[node] == 0) {\\n                components.clear();\\n                dfs2(node);\\n                if(components.size() >= 2) {\\n                    cycles.push_back(components);                    \\n                }\\n            }\\n        }\\n        // Now we got all the cycles\\n        int ans = 0;\\n        for(auto cycle : cycles) {\\n            if((int) cycle.size() == 2) {\\n                int u = cycle[0];\\n                int v = cycle[1];\\n                ans += dfs3(u, v) + dfs3(v, u);\\n            }\\n        }\\n        for(auto cycle : cycles) {\\n            if((int) cycle.size() > 2) {\\n                ans = max(ans, (int)cycle.size());\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824383,
                "title": "c-straightforward-2-cases-best-friends-graph-s-diameter-finding-circles",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(std::vector<int> & favorite) {\\n        // Lookup \"best friends\" (when two persons are favorites of each other)\\n        std::vector<std::pair<int, int>> bestFriends;\\n        std::vector<bool> visited(std::size(favorite));\\n        for (int i = 0; i < std::size(favorite); ++i)\\n            if (favorite[favorite[i]] == i && !visited[i] && !visited[favorite[i]])\\n                bestFriends.emplace_back(i, favorite[i]), visited[i] = visited[favorite[i]] = true;\\n\\n        int max = 0;\\n        if (!std::empty(bestFriends)) {\\n            std::vector<std::vector<int>> fans(std::size(favorite));\\n            for (int i = 0; i < std::size(favorite); ++i)\\n                fans[favorite[i]].push_back(i);\\n\\n            std::function<int (int)> getFarMost = [&] (int e) noexcept {\\n                visited[e] = true;\\n                int max = 0;\\n                for (auto n : fans[e])\\n                    if (!visited[n])\\n                        max = std::max(max, getFarMost(n));\\n                return max + 1;\\n            };\\n\\n            for (auto & [e1, e2] : bestFriends)\\n                max += getFarMost(e1) + getFarMost(e2); // Gives us a diameter of the graph\\n        }\\n\\n        // Look up circles\\n        for (int i = 0; i < std::size(favorite); ++i) {\\n            // Find circle\\n            int slow = i, fast = i, size = 0;\\n            do {\\n                slow = favorite[slow];\\n                fast = favorite[favorite[fast]];\\n                if (visited[fast])\\n                    goto next;  // Already got this circle\\n            } while (slow != fast);\\n            do {\\n                slow = favorite[slow];\\n                ++size;\\n            } while (slow != fast);\\n            max = std::max(max, size);\\n            next:   // Mark visited persons\\n            slow = i;\\n            while (!visited[slow]) {\\n                visited[slow] = true;\\n                slow = favorite[slow];\\n            }\\n        }\\n\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(std::vector<int> & favorite) {\\n        // Lookup \"best friends\" (when two persons are favorites of each other)\\n        std::vector<std::pair<int, int>> bestFriends;\\n        std::vector<bool> visited(std::size(favorite));\\n        for (int i = 0; i < std::size(favorite); ++i)\\n            if (favorite[favorite[i]] == i && !visited[i] && !visited[favorite[i]])\\n                bestFriends.emplace_back(i, favorite[i]), visited[i] = visited[favorite[i]] = true;\\n\\n        int max = 0;\\n        if (!std::empty(bestFriends)) {\\n            std::vector<std::vector<int>> fans(std::size(favorite));\\n            for (int i = 0; i < std::size(favorite); ++i)\\n                fans[favorite[i]].push_back(i);\\n\\n            std::function<int (int)> getFarMost = [&] (int e) noexcept {\\n                visited[e] = true;\\n                int max = 0;\\n                for (auto n : fans[e])\\n                    if (!visited[n])\\n                        max = std::max(max, getFarMost(n));\\n                return max + 1;\\n            };\\n\\n            for (auto & [e1, e2] : bestFriends)\\n                max += getFarMost(e1) + getFarMost(e2); // Gives us a diameter of the graph\\n        }\\n\\n        // Look up circles\\n        for (int i = 0; i < std::size(favorite); ++i) {\\n            // Find circle\\n            int slow = i, fast = i, size = 0;\\n            do {\\n                slow = favorite[slow];\\n                fast = favorite[favorite[fast]];\\n                if (visited[fast])\\n                    goto next;  // Already got this circle\\n            } while (slow != fast);\\n            do {\\n                slow = favorite[slow];\\n                ++size;\\n            } while (slow != fast);\\n            max = std::max(max, size);\\n            next:   // Mark visited persons\\n            slow = i;\\n            while (!visited[slow]) {\\n                visited[slow] = true;\\n                slow = favorite[slow];\\n            }\\n        }\\n\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777465,
                "title": "c-convoluted-solution-but-it-works",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> cyc(n, -2);     // part of a cycle or not;\\n        vector<int> cycId(n, -1);   // id of the cycle\\n        vector<int> cycLen(n, -1);  // len of protruding Cycle\\n        vector<int> actualCycLen(n, -1); //real cycle length\\n        auto calcCycleOrNot = [&](int i) {\\n            unordered_set<int> vis;\\n            stack<int> st;\\n            int len = 0, id = INT_MAX, actualLen = 0;\\n            int cyConnect = -1;\\n            bool flag = true;\\n            while (vis.find(i) == vis.end()) {\\n                if (cyc[i] != -2) {//we have already visited this node\\n                    len = cycLen[i];\\n                    actualLen = actualCycLen[i];\\n                    id = cycId[i];\\n                    cyConnect = (cyc[i]==-1?i:cyc[i]);\\n                    flag = false;\\n                    break;\\n                }\\n                vis.insert(i);\\n                st.push(i);\\n                i = a[i];\\n            }\\n            if (flag) {\\n                cyConnect = i;\\n                stack<int> partOfCycle;\\n                while (st.size()) {\\n                    int x = st.top();\\n                    partOfCycle.push(x);\\n                    id = min(id, x);\\n                    st.pop();\\n                    len++;\\n                    actualLen++;\\n                    if (x == i) //i is the point where cycle began\\n                        break;\\n                }\\n                while (partOfCycle.size()) {\\n                    int x = partOfCycle.top();\\n                    partOfCycle.pop();\\n                    cycLen[x] = len;\\n                    actualCycLen[x] = actualLen;\\n                    cycId[x] = id;\\n                    cyc[x] = -1;//-1 means this is a part of cycle\\n                }\\n            }\\n            while (st.size()) {\\n                int x = st.top();\\n                st.pop();\\n                cycLen[x] = ++len;\\n                actualCycLen[x] = actualLen;\\n                cycId[x] = id;\\n                cyc[x] = cyConnect;\\n            }\\n        };\\n        for (int i = 0; i < n; i++)\\n            calcCycleOrNot(i);  // calculating cycle params\\n\\n        int ans=0;//calculation of higher order cycles\\n        unordered_map<int, vector<int>>twoLenCycles;\\n        for(int i=0; i<n; i++){\\n            if(actualCycLen[i]>2)\\n                ans = max(ans, actualCycLen[i]);\\n            else\\n                twoLenCycles[cycId[i]].push_back(i);\\n        }\\n        //now separately handling the 2 length cycle case\\n\\n        auto getMaxEmployees = [&](vector<int>&fam)->int{\\n            unordered_map<int, int>endMaxLen;\\n            for(auto &i:fam){\\n                if(cyc[i]!=-1){//this is an outward tail\\n                    int endPoint = cyc[i];\\n                    endMaxLen[endPoint] = max(endMaxLen[endPoint], cycLen[i]-actualCycLen[i]);\\n                }\\n            }\\n            int ans=actualCycLen[fam[0]];\\n            for(auto &[k, maxLen] : endMaxLen){\\n                ans+=maxLen;\\n            }\\n            return ans;\\n        };\\n\\n        int altAns = 0;\\n        for(auto &[id, cycFamily] : twoLenCycles){\\n            altAns = altAns+getMaxEmployees(cycFamily);\\n        }\\n        return max(ans, altAns);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& a) {\\n        int n = a.size();\\n        vector<int> cyc(n, -2);     // part of a cycle or not;\\n        vector<int> cycId(n, -1);   // id of the cycle\\n        vector<int> cycLen(n, -1);  // len of protruding Cycle\\n        vector<int> actualCycLen(n, -1); //real cycle length\\n        auto calcCycleOrNot = [&](int i) {\\n            unordered_set<int> vis;\\n            stack<int> st;\\n            int len = 0, id = INT_MAX, actualLen = 0;\\n            int cyConnect = -1;\\n            bool flag = true;\\n            while (vis.find(i) == vis.end()) {\\n                if (cyc[i] != -2) {//we have already visited this node\\n                    len = cycLen[i];\\n                    actualLen = actualCycLen[i];\\n                    id = cycId[i];\\n                    cyConnect = (cyc[i]==-1?i:cyc[i]);\\n                    flag = false;\\n                    break;\\n                }\\n                vis.insert(i);\\n                st.push(i);\\n                i = a[i];\\n            }\\n            if (flag) {\\n                cyConnect = i;\\n                stack<int> partOfCycle;\\n                while (st.size()) {\\n                    int x = st.top();\\n                    partOfCycle.push(x);\\n                    id = min(id, x);\\n                    st.pop();\\n                    len++;\\n                    actualLen++;\\n                    if (x == i) //i is the point where cycle began\\n                        break;\\n                }\\n                while (partOfCycle.size()) {\\n                    int x = partOfCycle.top();\\n                    partOfCycle.pop();\\n                    cycLen[x] = len;\\n                    actualCycLen[x] = actualLen;\\n                    cycId[x] = id;\\n                    cyc[x] = -1;//-1 means this is a part of cycle\\n                }\\n            }\\n            while (st.size()) {\\n                int x = st.top();\\n                st.pop();\\n                cycLen[x] = ++len;\\n                actualCycLen[x] = actualLen;\\n                cycId[x] = id;\\n                cyc[x] = cyConnect;\\n            }\\n        };\\n        for (int i = 0; i < n; i++)\\n            calcCycleOrNot(i);  // calculating cycle params\\n\\n        int ans=0;//calculation of higher order cycles\\n        unordered_map<int, vector<int>>twoLenCycles;\\n        for(int i=0; i<n; i++){\\n            if(actualCycLen[i]>2)\\n                ans = max(ans, actualCycLen[i]);\\n            else\\n                twoLenCycles[cycId[i]].push_back(i);\\n        }\\n        //now separately handling the 2 length cycle case\\n\\n        auto getMaxEmployees = [&](vector<int>&fam)->int{\\n            unordered_map<int, int>endMaxLen;\\n            for(auto &i:fam){\\n                if(cyc[i]!=-1){//this is an outward tail\\n                    int endPoint = cyc[i];\\n                    endMaxLen[endPoint] = max(endMaxLen[endPoint], cycLen[i]-actualCycLen[i]);\\n                }\\n            }\\n            int ans=actualCycLen[fam[0]];\\n            for(auto &[k, maxLen] : endMaxLen){\\n                ans+=maxLen;\\n            }\\n            return ans;\\n        };\\n\\n        int altAns = 0;\\n        for(auto &[id, cycFamily] : twoLenCycles){\\n            altAns = altAns+getMaxEmployees(cycFamily);\\n        }\\n        return max(ans, altAns);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762807,
                "title": "c-dfs-chaining",
                "content": "```\\nclass Solution {\\npublic:\\n    bool visited[100001]={};\\n    int dfs(int i, vector<vector<int>>&adj){\\n        visited[i]=true;\\n        int m=0;\\n        for(int nbr:adj[i]){\\n            m = max(m,dfs(nbr,adj));\\n        }\\n        return m+1;\\n    }\\n    int maximumInvitations(vector<int>& fav) {\\n        int res=0;\\n        int n=fav.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n            if(fav[fav[i]]!=i){\\n                adj[fav[i]].push_back(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(fav[fav[i]]==i){\\n                res +=dfs(i,adj);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int j=i,steps=0;\\n            while(visited[j]==false){\\n                steps++;\\n                visited[j]=true;\\n                j = fav[j];\\n            }\\n            for(int k=i;k!=j;k=fav[k]){\\n                steps--;\\n            }\\n            res= max(res,steps);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool visited[100001]={};\\n    int dfs(int i, vector<vector<int>>&adj){\\n        visited[i]=true;\\n        int m=0;\\n        for(int nbr:adj[i]){\\n            m = max(m,dfs(nbr,adj));\\n        }\\n        return m+1;\\n    }\\n    int maximumInvitations(vector<int>& fav) {\\n        int res=0;\\n        int n=fav.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n            if(fav[fav[i]]!=i){\\n                adj[fav[i]].push_back(i);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(fav[fav[i]]==i){\\n                res +=dfs(i,adj);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int j=i,steps=0;\\n            while(visited[j]==false){\\n                steps++;\\n                visited[j]=true;\\n                j = fav[j];\\n            }\\n            for(int k=i;k!=j;k=fav[k]){\\n                steps--;\\n            }\\n            res= max(res,steps);\\n        }\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711315,
                "title": "python-bfs-topological-sort",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        fans = [[] for _ in favorite]\\n        indegrees = [0 for _ in favorite]\\n        seen = set()\\n        for fan, fav in enumerate(favorite):\\n            fans[fav].append(fan)\\n            indegrees[fav] += 1\\n            \\n        def getCycle(start):\\n            q = deque([start])\\n            cycle = set()\\n            while q:\\n                emp = q.popleft()\\n                cycle.add(emp)\\n                \\n                for ngh in fans[emp] + [favorite[emp]]:\\n                    if ngh not in seen:\\n                        q.append(ngh)\\n                        seen.add(ngh)\\n                        \\n            q = deque(filter(lambda c: indegrees[c] == 0, cycle))\\n            while q:\\n                emp = q.popleft()\\n                cycle.remove(emp)\\n                \\n                indegrees[favorite[emp]] -= 1\\n                if indegrees[favorite[emp]] == 0:\\n                    q.append(favorite[emp])\\n                    \\n            return cycle\\n        \\n        def getChain(emp, bad):\\n            chain = 0\\n            for fan in fans[emp]:\\n                if fan != bad:\\n                    chain = max(chain, 1 + getChain(fan, bad))\\n                    \\n            return chain\\n        \\n        circles, pairs = 0, 0\\n        for idx in range(len(favorite)):\\n            if idx not in seen:\\n                cycle = getCycle(idx)\\n                if len(cycle) == 2:\\n                    emp1, emp2 = cycle.pop(), cycle.pop()\\n                    pairs += 2 + getChain(emp1, emp2) + getChain(emp2, emp1)\\n                else:\\n                    circles = max(circles, len(cycle))\\n                    \\n        return max(circles, pairs)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        fans = [[] for _ in favorite]\\n        indegrees = [0 for _ in favorite]\\n        seen = set()\\n        for fan, fav in enumerate(favorite):\\n            fans[fav].append(fan)\\n            indegrees[fav] += 1\\n            \\n        def getCycle(start):\\n            q = deque([start])\\n            cycle = set()\\n            while q:\\n                emp = q.popleft()\\n                cycle.add(emp)\\n                \\n                for ngh in fans[emp] + [favorite[emp]]:\\n                    if ngh not in seen:\\n                        q.append(ngh)\\n                        seen.add(ngh)\\n                        \\n            q = deque(filter(lambda c: indegrees[c] == 0, cycle))\\n            while q:\\n                emp = q.popleft()\\n                cycle.remove(emp)\\n                \\n                indegrees[favorite[emp]] -= 1\\n                if indegrees[favorite[emp]] == 0:\\n                    q.append(favorite[emp])\\n                    \\n            return cycle\\n        \\n        def getChain(emp, bad):\\n            chain = 0\\n            for fan in fans[emp]:\\n                if fan != bad:\\n                    chain = max(chain, 1 + getChain(fan, bad))\\n                    \\n            return chain\\n        \\n        circles, pairs = 0, 0\\n        for idx in range(len(favorite)):\\n            if idx not in seen:\\n                cycle = getCycle(idx)\\n                if len(cycle) == 2:\\n                    emp1, emp2 = cycle.pop(), cycle.pop()\\n                    pairs += 2 + getChain(emp1, emp2) + getChain(emp2, emp1)\\n                else:\\n                    circles = max(circles, len(cycle))\\n                    \\n        return max(circles, pairs)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644815,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void cyc(int node,vector<int>&favorite,vector<int>& visited,int& cnt){\\n        if(visited[node] == 1){\\n            return;\\n        }\\n        visited[node] = 1;\\n        cyc(favorite[node],favorite,visited,cnt);\\n        cnt++;\\n        visited[node] = 2;\\n    }\\n    \\n    void worth(int node,vector<int>&favorite,vector<int>&visited,int& pp){\\n        if(visited[node] == 2){\\n            pp = -1;\\n            return;\\n        }\\n        if(visited[node] == 1){\\n            pp = node;\\n            return;\\n        }\\n        visited[node] = 1;\\n        worth(favorite[node],favorite,visited,pp);\\n        visited[node] = 2;\\n    }\\n    \\n    int sp(int node,vector<vector<int>>&adj,vector<int>&favorite,vector<int>&dp){\\n        if(dp[node] != -1){\\n            return dp[node];\\n        }\\n        int a = 0;\\n        for(auto child:adj[node]){\\n            if(child == favorite[node])continue;\\n            a = max(a,sp(child,adj,favorite,dp));\\n        }\\n        return dp[node] = a+1;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int ans = 1;\\n        int n = favorite.size();\\n        vector<int>visited(n,0),visited2(n,0);\\n        vector<int>two;\\n        for(int i = 0;i < n;i++){\\n            if(visited[i] == 0){\\n                int pp = INT_MAX;\\n                worth(i,favorite,visited,pp);\\n                if(pp == -1)continue;\\n                int cnt = 0;\\n                cyc(pp,favorite,visited2,cnt);\\n                ans = max(ans,cnt);\\n                if(cnt == 2){\\n                    two.push_back(pp);\\n                }\\n            }\\n        }\\n        if(two.size() == 0)return ans;\\n        vector<vector<int>>adj(n);\\n        for(int i = 0;i < n;i++){\\n            adj[favorite[i]].push_back(i);\\n        }\\n        vector<int>dp(n,-1);\\n        int ans2 = 0;\\n        for(auto node:two){\\n            int a = sp(node,adj,favorite,dp);\\n            int b = sp(favorite[node],adj,favorite,dp);\\n            ans2 += a+b;\\n        }\\n        return max(ans,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void cyc(int node,vector<int>&favorite,vector<int>& visited,int& cnt){\\n        if(visited[node] == 1){\\n            return;\\n        }\\n        visited[node] = 1;\\n        cyc(favorite[node],favorite,visited,cnt);\\n        cnt++;\\n        visited[node] = 2;\\n    }\\n    \\n    void worth(int node,vector<int>&favorite,vector<int>&visited,int& pp){\\n        if(visited[node] == 2){\\n            pp = -1;\\n            return;\\n        }\\n        if(visited[node] == 1){\\n            pp = node;\\n            return;\\n        }\\n        visited[node] = 1;\\n        worth(favorite[node],favorite,visited,pp);\\n        visited[node] = 2;\\n    }\\n    \\n    int sp(int node,vector<vector<int>>&adj,vector<int>&favorite,vector<int>&dp){\\n        if(dp[node] != -1){\\n            return dp[node];\\n        }\\n        int a = 0;\\n        for(auto child:adj[node]){\\n            if(child == favorite[node])continue;\\n            a = max(a,sp(child,adj,favorite,dp));\\n        }\\n        return dp[node] = a+1;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int ans = 1;\\n        int n = favorite.size();\\n        vector<int>visited(n,0),visited2(n,0);\\n        vector<int>two;\\n        for(int i = 0;i < n;i++){\\n            if(visited[i] == 0){\\n                int pp = INT_MAX;\\n                worth(i,favorite,visited,pp);\\n                if(pp == -1)continue;\\n                int cnt = 0;\\n                cyc(pp,favorite,visited2,cnt);\\n                ans = max(ans,cnt);\\n                if(cnt == 2){\\n                    two.push_back(pp);\\n                }\\n            }\\n        }\\n        if(two.size() == 0)return ans;\\n        vector<vector<int>>adj(n);\\n        for(int i = 0;i < n;i++){\\n            adj[favorite[i]].push_back(i);\\n        }\\n        vector<int>dp(n,-1);\\n        int ans2 = 0;\\n        for(auto node:two){\\n            int a = sp(node,adj,favorite,dp);\\n            int b = sp(favorite[node],adj,favorite,dp);\\n            ans2 += a+b;\\n        }\\n        return max(ans,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445041,
                "title": "golang",
                "content": "[Good explanation with pictures](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1660944/C%2B%2B-DFS-with-illustration)\\n\\n1. find longest cycle\\n2. find sum of all asyclic dependand\\n3. result will be max of 1 and 2\\n\\n```\\nfunc maximumInvitations(favorite []int) int {   \\n    maxCycle := 0\\n    n := len(favorite)\\n    incount := make(map[int][]int, n)\\n    for i:=range favorite{\\n        incount[favorite[i]] = append(incount[favorite[i]], i)\\n    }\\n    \\n    seen := make(map[int]bool)\\n    //find longest cycle\\n    for i:=0;i<n;i++{\\n        if _, ok := seen[i];ok{\\n            continue\\n        }\\n        \\n        seen[i]=true\\n        current := map[int]int{i:0}\\n        counter := 0\\n        for {\\n            next := favorite[i]\\n            \\n            if r,ok := current[next];ok{\\n                currentCycleLen := counter - r + 1\\n                if maxCycle < currentCycleLen{\\n                    maxCycle = currentCycleLen\\n                }\\n                break\\n            }\\n            \\n            if _, ok := seen[next];ok{\\n                break\\n            }\\n            \\n            seen[next]=true\\n            \\n            counter++\\n            current[next] = counter\\n            i = next\\n        }\\n    }\\n    \\n    \\n\\t//find all acyclic dependant\\n    maxAsync := 0\\n    seenArr := make([]bool, n)\\n    for i:=0;i<n;i++{\\n        if seenArr[i]{\\n            continue\\n        }\\n        if favorite[favorite[i]] == i{\\n            a := i\\n            b := favorite[i]\\n            seenArr[a]=true\\n            seenArr[b]=true\\n            \\n            maxAsync += findMax(incount, a, a,b) + findMax(incount, b, a,b)\\n        }\\n    }\\n    \\n    return max(maxCycle, maxAsync)\\n}\\n\\n//findMax returns length of the chain\\nfunc findMax(graph map[int][]int, i,p1,p2 int) int {\\n    ans := 0\\n    for _, next := range graph[i]{\\n        if next != p1 && next != p2 {\\n            ans = max(ans, findMax(graph, next, p1,p2))    \\n        }\\n        \\n    }\\n    \\n    return ans+1\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumInvitations(favorite []int) int {   \\n    maxCycle := 0\\n    n := len(favorite)\\n    incount := make(map[int][]int, n)\\n    for i:=range favorite{\\n        incount[favorite[i]] = append(incount[favorite[i]], i)\\n    }\\n    \\n    seen := make(map[int]bool)\\n    //find longest cycle\\n    for i:=0;i<n;i++{\\n        if _, ok := seen[i];ok{\\n            continue\\n        }\\n        \\n        seen[i]=true\\n        current := map[int]int{i:0}\\n        counter := 0\\n        for {\\n            next := favorite[i]\\n            \\n            if r,ok := current[next];ok{\\n                currentCycleLen := counter - r + 1\\n                if maxCycle < currentCycleLen{\\n                    maxCycle = currentCycleLen\\n                }\\n                break\\n            }\\n            \\n            if _, ok := seen[next];ok{\\n                break\\n            }\\n            \\n            seen[next]=true\\n            \\n            counter++\\n            current[next] = counter\\n            i = next\\n        }\\n    }\\n    \\n    \\n\\t//find all acyclic dependant\\n    maxAsync := 0\\n    seenArr := make([]bool, n)\\n    for i:=0;i<n;i++{\\n        if seenArr[i]{\\n            continue\\n        }\\n        if favorite[favorite[i]] == i{\\n            a := i\\n            b := favorite[i]\\n            seenArr[a]=true\\n            seenArr[b]=true\\n            \\n            maxAsync += findMax(incount, a, a,b) + findMax(incount, b, a,b)\\n        }\\n    }\\n    \\n    return max(maxCycle, maxAsync)\\n}\\n\\n//findMax returns length of the chain\\nfunc findMax(graph map[int][]int, i,p1,p2 int) int {\\n    ans := 0\\n    for _, next := range graph[i]{\\n        if next != p1 && next != p2 {\\n            ans = max(ans, findMax(graph, next, p1,p2))    \\n        }\\n        \\n    }\\n    \\n    return ans+1\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383509,
                "title": "javascript-solution-with-topological-sort-and-bfs",
                "content": "```\\n/**\\n * @param {number[]} favorite\\n * @return {number}\\n */\\nvar maximumInvitations = function(favorite) {\\n    let res = 0;\\n    let len = favorite.length;\\n    // count the number indegree\\n    let indegree = new Array(len).fill(0);\\n    // save the number relation\\n    let rMap = new Map();\\n    for(let i=0; i<favorite.length; i++){\\n        indegree[favorite[i]] ++;\\n        \\n        if(rMap.has(favorite[i])){\\n            let arr = rMap.get(favorite[i]);\\n            arr.push(i);\\n            rMap.set(favorite[i], arr);\\n        }else{\\n            rMap.set(favorite[i], [i]);\\n        }\\n    }\\n\\t// find the 0 indegree number\\n    let arr = [];\\n    for(let i=0; i<len; i++){\\n        if(indegree[i] === 0){\\n            arr.push(i);\\n        }\\n    }\\n    // check if the circle exist\\n    let search = 0;\\n    // the length of uncircle\\n    let l = 1;\\n\\t// save the number and the length of uncircle\\n    let lMap = new Map();\\n    while(arr.length > 0){\\n        let tmp = [];\\n        for(let i=0; i<arr.length; i++){\\n            lMap.set(arr[i], l);\\n            let next = favorite[arr[i]];\\n            indegree[next] --;\\n            search ++;\\n            if(indegree[next] === 0){\\n                tmp.push(next);\\n            }\\n        }\\n\\t\\t// update the length of uncircle\\n        l ++;\\n        arr = [...tmp];\\n    }\\n\\n    if(search === len){\\n        // circle not exist\\n    }else{\\n        // circle exist\\n        // find the not 0 indegree number\\n        let keys = find(indegree);\\n        // mark the search number in circle\\n        let circleMap = new Map();\\n        // the length of circle\\n        let circleLen = 1;\\n        // the max length of circle\\n        let maxCircleLen = 0;\\n        // sum the length of circle \\n        let sumCircleLen = 0;\\n        let cArr = [keys[0]];\\n        \\n        while(cArr.length > 0){\\n            let tmp = [];\\n            for(let i=0; i<cArr.length; i++){\\n\\t\\t\\t\\t// not find the circle\\n                if(!circleMap.has(cArr[i])){\\n                    circleMap.set(cArr[i], circleLen);\\n                    tmp.push(favorite[cArr[i]]);\\n\\t\\t\\t\\t// find the circle\\t\\n                }else{\\n                    maxCircleLen = Math.max(maxCircleLen, circleLen-1);\\n                    // if the length equals 2 then sum the length\\n                    if(circleLen-1 === 2){\\n                        let m = calc(cArr[i], rMap, lMap) + calc(favorite[cArr[i]], rMap, lMap) + 2;\\n                        sumCircleLen += m;\\n                    }\\n                    // reset the length\\n                    circleLen = 0;\\n                    // find the next number not search\\n                    for(let i=0; i<keys.length; i++){\\n                        if(!circleMap.has(keys[i])){\\n                            tmp.push(keys[i]);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            circleLen ++;\\n            cArr = [...tmp];\\n        }\\n        res = Math.max(res, maxCircleLen, sumCircleLen);\\n    }\\n\\n    return res;    \\n};\\n\\nfunction calc(num, rMap, lMap){\\n    let res = 0;\\n    let arr = rMap.has(num) ? rMap.get(num) : [];\\n    if(arr.length > 0){\\n        for(let i=0; i<arr.length; i++){\\n            let l = lMap.has(arr[i]) ? lMap.get(arr[i]) : 0;\\n            res = Math.max(res, l);\\n        }\\n    }\\n    return res;\\n}\\n\\nfunction find(arr){\\n    let res = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i] > 0){\\n            res.push(i);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} favorite\\n * @return {number}\\n */\\nvar maximumInvitations = function(favorite) {\\n    let res = 0;\\n    let len = favorite.length;\\n    // count the number indegree\\n    let indegree = new Array(len).fill(0);\\n    // save the number relation\\n    let rMap = new Map();\\n    for(let i=0; i<favorite.length; i++){\\n        indegree[favorite[i]] ++;\\n        \\n        if(rMap.has(favorite[i])){\\n            let arr = rMap.get(favorite[i]);\\n            arr.push(i);\\n            rMap.set(favorite[i], arr);\\n        }else{\\n            rMap.set(favorite[i], [i]);\\n        }\\n    }\\n\\t// find the 0 indegree number\\n    let arr = [];\\n    for(let i=0; i<len; i++){\\n        if(indegree[i] === 0){\\n            arr.push(i);\\n        }\\n    }\\n    // check if the circle exist\\n    let search = 0;\\n    // the length of uncircle\\n    let l = 1;\\n\\t// save the number and the length of uncircle\\n    let lMap = new Map();\\n    while(arr.length > 0){\\n        let tmp = [];\\n        for(let i=0; i<arr.length; i++){\\n            lMap.set(arr[i], l);\\n            let next = favorite[arr[i]];\\n            indegree[next] --;\\n            search ++;\\n            if(indegree[next] === 0){\\n                tmp.push(next);\\n            }\\n        }\\n\\t\\t// update the length of uncircle\\n        l ++;\\n        arr = [...tmp];\\n    }\\n\\n    if(search === len){\\n        // circle not exist\\n    }else{\\n        // circle exist\\n        // find the not 0 indegree number\\n        let keys = find(indegree);\\n        // mark the search number in circle\\n        let circleMap = new Map();\\n        // the length of circle\\n        let circleLen = 1;\\n        // the max length of circle\\n        let maxCircleLen = 0;\\n        // sum the length of circle \\n        let sumCircleLen = 0;\\n        let cArr = [keys[0]];\\n        \\n        while(cArr.length > 0){\\n            let tmp = [];\\n            for(let i=0; i<cArr.length; i++){\\n\\t\\t\\t\\t// not find the circle\\n                if(!circleMap.has(cArr[i])){\\n                    circleMap.set(cArr[i], circleLen);\\n                    tmp.push(favorite[cArr[i]]);\\n\\t\\t\\t\\t// find the circle\\t\\n                }else{\\n                    maxCircleLen = Math.max(maxCircleLen, circleLen-1);\\n                    // if the length equals 2 then sum the length\\n                    if(circleLen-1 === 2){\\n                        let m = calc(cArr[i], rMap, lMap) + calc(favorite[cArr[i]], rMap, lMap) + 2;\\n                        sumCircleLen += m;\\n                    }\\n                    // reset the length\\n                    circleLen = 0;\\n                    // find the next number not search\\n                    for(let i=0; i<keys.length; i++){\\n                        if(!circleMap.has(keys[i])){\\n                            tmp.push(keys[i]);\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            circleLen ++;\\n            cArr = [...tmp];\\n        }\\n        res = Math.max(res, maxCircleLen, sumCircleLen);\\n    }\\n\\n    return res;    \\n};\\n\\nfunction calc(num, rMap, lMap){\\n    let res = 0;\\n    let arr = rMap.has(num) ? rMap.get(num) : [];\\n    if(arr.length > 0){\\n        for(let i=0; i<arr.length; i++){\\n            let l = lMap.has(arr[i]) ? lMap.get(arr[i]) : 0;\\n            res = Math.max(res, l);\\n        }\\n    }\\n    return res;\\n}\\n\\nfunction find(arr){\\n    let res = [];\\n    for(let i=0; i<arr.length; i++){\\n        if(arr[i] > 0){\\n            res.push(i);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2373658,
                "title": "c-dfs-solution-beats-40-25",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// To determine length of cycle in graph\\n    pair<int, pair<int, int>> dfs(int node, vector<int>& favorite, vector<int>& cyc, vector<bool>& cycvis){\\n        if(cyc[node]!=-1)\\n            return {false, {node, cyc[node]}};\\n        if(cycvis[node]==true)\\n            return {true, {node, 1}};\\n        cycvis[node] = true;\\n        pair<int, pair<int, int>> p = dfs(favorite[node], favorite, cyc, cycvis);\\n        if(!p.first){\\n            cyc[node] = p.second.second;\\n            return p;\\n        }\\n        cyc[node] = p.second.second;\\n        if(p.second.first==node)\\n            return {false, p.second};\\n        return {true, {p.second.first, p.second.second+1}};\\n    }\\n    \\n\\t// To find the length of largest cycle in the graph\\n    int findLargestCycleLength(vector<int>& favorite){\\n        vector<int> cyc(favorite.size(), -1);\\n        vector<bool> cycvis(favorite.size(), false);\\n        int ans=0;\\n        for(int i=0; i<favorite.size(); i++){\\n            if(cyc[i]!=-1)\\n                continue;\\n            pair<int, pair<int, int>> p = dfs(i, favorite, cyc, cycvis);\\n            ans = max(ans, p.second.second);\\n        }\\n        return ans;\\n    }\\n    \\n\\t// To find the height of a node in the modified adjacency list, as modified by findSumOfArms()\\n    int findHeight(vector<vector<int>>& adjlist, int node){\\n        int height = 0;\\n        for(int i=0; i<adjlist[node].size(); i++)\\n            height = max(height, findHeight(adjlist, adjlist[node][i]));\\n        return height+1;\\n    }\\n    \\n\\t//Function to return sum of all arms\\n    int findSumOfArms(vector<vector<int>>& adjlist, vector<int>& favorite){\\n        vector<bool> vis(favorite.size(), false);\\n        int ans = 0;\\n        for(int i=0; i<favorite.size(); i++){\\n            if(vis[i])\\n                continue;\\n            if(favorite[favorite[i]]==i){\\n                vis[i] = true;\\n                vis[favorite[i]] = true;\\n                for(int j=0; j<adjlist[i].size(); j++)\\n                    if(adjlist[i][j]==favorite[i]){\\n                        adjlist[i].erase(adjlist[i].begin()+j);\\n                        break;\\n                    }\\n                for(int j=0; j<adjlist[favorite[i]].size(); j++)\\n                    if(adjlist[favorite[i]][j]==i){\\n                        adjlist[favorite[i]].erase(adjlist[favorite[i]].begin()+j);\\n                        break;\\n                    }\\n                ans += findHeight(adjlist, i)+findHeight(adjlist, favorite[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\t//Main Function\\n    int maximumInvitations(vector<int>& favorite) {\\n        vector<vector<int>> adjlist(favorite.size());\\n        for(int i=0; i<favorite.size(); i++)\\n            adjlist[favorite[i]].push_back(i);\\n        \\n        int ans1 = findLargestCycleLength(favorite), ans2 = findSumOfArms(adjlist, favorite);\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// To determine length of cycle in graph\\n    pair<int, pair<int, int>> dfs(int node, vector<int>& favorite, vector<int>& cyc, vector<bool>& cycvis){\\n        if(cyc[node]!=-1)\\n            return {false, {node, cyc[node]}};\\n        if(cycvis[node]==true)\\n            return {true, {node, 1}};\\n        cycvis[node] = true;\\n        pair<int, pair<int, int>> p = dfs(favorite[node], favorite, cyc, cycvis);\\n        if(!p.first){\\n            cyc[node] = p.second.second;\\n            return p;\\n        }\\n        cyc[node] = p.second.second;\\n        if(p.second.first==node)\\n            return {false, p.second};\\n        return {true, {p.second.first, p.second.second+1}};\\n    }\\n    \\n\\t// To find the length of largest cycle in the graph\\n    int findLargestCycleLength(vector<int>& favorite){\\n        vector<int> cyc(favorite.size(), -1);\\n        vector<bool> cycvis(favorite.size(), false);\\n        int ans=0;\\n        for(int i=0; i<favorite.size(); i++){\\n            if(cyc[i]!=-1)\\n                continue;\\n            pair<int, pair<int, int>> p = dfs(i, favorite, cyc, cycvis);\\n            ans = max(ans, p.second.second);\\n        }\\n        return ans;\\n    }\\n    \\n\\t// To find the height of a node in the modified adjacency list, as modified by findSumOfArms()\\n    int findHeight(vector<vector<int>>& adjlist, int node){\\n        int height = 0;\\n        for(int i=0; i<adjlist[node].size(); i++)\\n            height = max(height, findHeight(adjlist, adjlist[node][i]));\\n        return height+1;\\n    }\\n    \\n\\t//Function to return sum of all arms\\n    int findSumOfArms(vector<vector<int>>& adjlist, vector<int>& favorite){\\n        vector<bool> vis(favorite.size(), false);\\n        int ans = 0;\\n        for(int i=0; i<favorite.size(); i++){\\n            if(vis[i])\\n                continue;\\n            if(favorite[favorite[i]]==i){\\n                vis[i] = true;\\n                vis[favorite[i]] = true;\\n                for(int j=0; j<adjlist[i].size(); j++)\\n                    if(adjlist[i][j]==favorite[i]){\\n                        adjlist[i].erase(adjlist[i].begin()+j);\\n                        break;\\n                    }\\n                for(int j=0; j<adjlist[favorite[i]].size(); j++)\\n                    if(adjlist[favorite[i]][j]==i){\\n                        adjlist[favorite[i]].erase(adjlist[favorite[i]].begin()+j);\\n                        break;\\n                    }\\n                ans += findHeight(adjlist, i)+findHeight(adjlist, favorite[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n\\t//Main Function\\n    int maximumInvitations(vector<int>& favorite) {\\n        vector<vector<int>> adjlist(favorite.size());\\n        for(int i=0; i<favorite.size(); i++)\\n            adjlist[favorite[i]].push_back(i);\\n        \\n        int ans1 = findLargestCycleLength(favorite), ans2 = findSumOfArms(adjlist, favorite);\\n        return max(ans1, ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290095,
                "title": "dsf-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\t//FINDS THE LONGEST CYCLE EXIXTING IN GRAPH\\n    void dfs(int i,vector<vector<int>>&graph,vector<int>&visited,vector<int>&vst,int cnt)\\n    {\\n        visited[i]=1;\\n        vst[i]=cnt;\\n        for(auto&p:graph[i])\\n        {\\n             if(vst[p]!=0)ans=max(ans,vst[i]-vst[p]+1);\\n            if(visited[p]==1)continue;\\n            else dfs(p,graph,visited,vst,cnt+1);\\n        }\\n        vst[i]=0;\\n        \\n    }\\n\\t//LONGEST CHAIN FOR THE NODES WHICH ARE PART OF 2 LENGTH CYCLE\\n    int dfs2(int i,vector<vector<int>>&graph,vector<int>&vst)\\n    {\\n        vst[i]=1;\\n        int tmp=0;   \\n        for(auto&p:graph[i])\\n        {\\n            if(vst[p]==1)continue;\\n            tmp=max(tmp,dfs2(p,graph,vst));\\n        }\\n        vst[i]=0;\\n        return 1+tmp;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n=favorite.size();\\n        vector<vector<int>>graph(n,vector<int>());\\n        for(int i=0;i<n;i++)graph[i].push_back(favorite[i]);\\n        vector<int>visited(n,0);\\n        vector<int>vst(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n                dfs(i,graph,visited,vst,1);\\n        }\\n        \\n        \\n        \\n         vector<vector<int>>graph1(n,vector<int>());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[favorite[i]]!=i)graph1[favorite[i]].push_back(i);\\n        }\\n            \\n        int sum=0;\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[favorite[i]]==i)\\n            {\\n               \\n                int tmp=dfs2(i,graph1,vst);\\n                int tmp1=dfs2(favorite[i],graph1,vst);\\n                mp[min(i,favorite[i])]=tmp+tmp1;\\n                sum+=tmp+tmp1;\\n                \\n            }\\n        }\\n        sum/=2;\\n        return max(ans,sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\t//FINDS THE LONGEST CYCLE EXIXTING IN GRAPH\\n    void dfs(int i,vector<vector<int>>&graph,vector<int>&visited,vector<int>&vst,int cnt)\\n    {\\n        visited[i]=1;\\n        vst[i]=cnt;\\n        for(auto&p:graph[i])\\n        {\\n             if(vst[p]!=0)ans=max(ans,vst[i]-vst[p]+1);\\n            if(visited[p]==1)continue;\\n            else dfs(p,graph,visited,vst,cnt+1);\\n        }\\n        vst[i]=0;\\n        \\n    }\\n\\t//LONGEST CHAIN FOR THE NODES WHICH ARE PART OF 2 LENGTH CYCLE\\n    int dfs2(int i,vector<vector<int>>&graph,vector<int>&vst)\\n    {\\n        vst[i]=1;\\n        int tmp=0;   \\n        for(auto&p:graph[i])\\n        {\\n            if(vst[p]==1)continue;\\n            tmp=max(tmp,dfs2(p,graph,vst));\\n        }\\n        vst[i]=0;\\n        return 1+tmp;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n=favorite.size();\\n        vector<vector<int>>graph(n,vector<int>());\\n        for(int i=0;i<n;i++)graph[i].push_back(favorite[i]);\\n        vector<int>visited(n,0);\\n        vector<int>vst(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==0)\\n                dfs(i,graph,visited,vst,1);\\n        }\\n        \\n        \\n        \\n         vector<vector<int>>graph1(n,vector<int>());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[favorite[i]]!=i)graph1[favorite[i]].push_back(i);\\n        }\\n            \\n        int sum=0;\\n        map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(favorite[favorite[i]]==i)\\n            {\\n               \\n                int tmp=dfs2(i,graph1,vst);\\n                int tmp1=dfs2(favorite[i],graph1,vst);\\n                mp[min(i,favorite[i])]=tmp+tmp1;\\n                sum+=tmp+tmp1;\\n                \\n            }\\n        }\\n        sum/=2;\\n        return max(ans,sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146280,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        \\n        int [] ind = new int[favorite.length];\\n        for(int i=0; i<favorite.length; i++) {\\n            map.put(i, favorite[i]);\\n            ind[favorite[i]]++;\\n        }\\n        \\n        int res = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        for(int i=0; i<ind.length; i++) {\\n            if(ind[i] == 0) q.add(i);\\n        }\\n\\n        boolean [] vis = new boolean[ind.length];\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                int cur = q.poll();\\n                vis[cur] = true;\\n                int child = map.get(cur);\\n                \\n                ind[child]--;\\n                \\n                if(ind[child] == 0) q.add(child); \\n                else {\\n                    if(map1.containsKey(child)) {\\n                        int t = map1.get(child);\\n                        t = Math.max(t, level);\\n                        map1.put(child, t);\\n                    } else {\\n                        map1.put(child, level);\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n                \\n        int sizeTwo = 0;\\n        for(int i=0; i<ind.length; i++) {\\n            if(!vis[i]) {\\n                int [] cSize = dfs(i, map, map1, vis);   \\n                if(cSize[0] == 2) {\\n                    sizeTwo += cSize[0] + cSize[1];\\n                } else {\\n                    res = Math.max(res, cSize[0]);\\n                }\\n                  \\n            }\\n        }\\n        res = Math.max(sizeTwo, res);\\n        return res;\\n              \\n    }\\n    \\n    private int[] dfs(int src, Map<Integer, Integer> map, Map<Integer, Integer> map1, boolean [] vis) {\\n        if(vis[src]) {\\n            return new int[] {0, 0};\\n        }\\n        vis[src] = true;\\n        int [] t = dfs(map.get(src), map, map1, vis);\\n        \\n        int t2 = t[1] + (map1.containsKey(src) ? map1.get(src) : 0);\\n        \\n        return new int[]{1 + t[0], t2};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumInvitations(int[] favorite) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        \\n        int [] ind = new int[favorite.length];\\n        for(int i=0; i<favorite.length; i++) {\\n            map.put(i, favorite[i]);\\n            ind[favorite[i]]++;\\n        }\\n        \\n        int res = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        for(int i=0; i<ind.length; i++) {\\n            if(ind[i] == 0) q.add(i);\\n        }\\n\\n        boolean [] vis = new boolean[ind.length];\\n        int level = 1;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i=0; i<size; i++) {\\n                int cur = q.poll();\\n                vis[cur] = true;\\n                int child = map.get(cur);\\n                \\n                ind[child]--;\\n                \\n                if(ind[child] == 0) q.add(child); \\n                else {\\n                    if(map1.containsKey(child)) {\\n                        int t = map1.get(child);\\n                        t = Math.max(t, level);\\n                        map1.put(child, t);\\n                    } else {\\n                        map1.put(child, level);\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n                \\n        int sizeTwo = 0;\\n        for(int i=0; i<ind.length; i++) {\\n            if(!vis[i]) {\\n                int [] cSize = dfs(i, map, map1, vis);   \\n                if(cSize[0] == 2) {\\n                    sizeTwo += cSize[0] + cSize[1];\\n                } else {\\n                    res = Math.max(res, cSize[0]);\\n                }\\n                  \\n            }\\n        }\\n        res = Math.max(sizeTwo, res);\\n        return res;\\n              \\n    }\\n    \\n    private int[] dfs(int src, Map<Integer, Integer> map, Map<Integer, Integer> map1, boolean [] vis) {\\n        if(vis[src]) {\\n            return new int[] {0, 0};\\n        }\\n        vis[src] = true;\\n        int [] t = dfs(map.get(src), map, map1, vis);\\n        \\n        int t2 = t[1] + (map1.containsKey(src) ? map1.get(src) : 0);\\n        \\n        return new int[]{1 + t[0], t2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141694,
                "title": "c-17-dfs-then-bfs",
                "content": "# C++17 DFS, then BFS\\nIdea / Approach: DFS to detect circles, and BFS to figure out the max chain length.\\nkey-points:\\n* since each person has only one favorite, the out-degree of each vertex is one.\\n* two cases of seat arrangements:\\n  * general case: k persons form a circle of favorites.\\n  * special case: k groups of two mutually-favorite persons:\\n    * the core consists of 2*k \"core\" persons.\\n    * but each \"core\" person can have a chain of friends.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const auto n = (int)favorite.size();\\n        vector<bool> done(n);\\n        vector<bool> visiting(n);\\n        // set of person-ids (of mutual-favorite persons)\\n        unordered_set<int> mutualFavorites;\\n\\n        int maxCircle = 0;\\n        int countOfTwoPersonCircles = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (done[i]) {\\n                continue;\\n            }\\n            // do DFS starting from person #i, and compute the circle size;\\n            // if no circle is found, zero will be returned.\\n            auto [circleSize, _] = dfs(i, favorite, done, visiting, mutualFavorites);\\n            maxCircle = max(maxCircle, circleSize);\\n            if (circleSize == 2) {\\n                ++countOfTwoPersonCircles;\\n            }\\n        }\\n        // figure out the actual number of persons that can chain up to the circles of twos.\\n        // invert the graph, for bfs\\n        vector<vector<int>> adj(n);\\n        for (int i = 0; i < n; ++i) {\\n            int j = favorite[i];\\n            adj[j].emplace_back(i);\\n        }\\n\\n        // Do BFS on the reversed graph, to grow the chain of friends that rooted at each person in\\n        // circles of twos.\\n        // in other words, for each root vertex we probe for the max depth.\\n        int personsInSpecialCases = 2 * countOfTwoPersonCircles;\\n        for (const auto root : mutualFavorites) {\\n            int depth = bfs(root, adj, mutualFavorites);\\n            personsInSpecialCases += depth;\\n        }\\n\\n        return max(maxCircle, personsInSpecialCases);\\n    }\\n\\nprivate:\\n    static int\\n    bfs(int root, const vector<vector<int>>& adj, const unordered_set<int>& mutualFavorites) {\\n        queue<int> q;\\n        int depth = 0;\\n        // since there aren\\'t circles for these BFSs,\\n        // we don\\'t need to track the visited-ness.\\n        for (int u : adj[root]) {\\n            if (mutualFavorites.count(u) == 0) {\\n                q.emplace(u);\\n            }\\n        }\\n        while (!q.empty()) {\\n            ++depth;\\n            int qsz = q.size();\\n            while (qsz--) {\\n                // for easier debugging, we can use:\\n                // while (qsz > 0) { --qsz; ... }\\n                int u = q.front();\\n                q.pop();\\n                for (auto v : adj[u]) {\\n                    q.emplace(v);\\n                }\\n            }\\n        }\\n        // cout << \"depth from root #\" << root << \" is: \" << depth << endl;\\n        return depth;\\n    }\\n\\n    /// \\\\brief do DFS starting from person #i, and compute the circle size;\\n    /// if no circle is found, zero will be returned.\\n    /// \\\\param mutualFavorites maintains the persons that are in circles of two persons, for they\\n    /// are special cases.\\n    /// \\\\returns a two-tuple, with the first element representing the size of the circle, and the\\n    /// second element indicates whether the current node is within the circle or not.\\n    static tuple<int, bool>\\n    dfs(int i,\\n        const vector<int>& favorite,\\n        vector<bool>& doneFlags,\\n        vector<bool>& visitingFlags,\\n        unordered_set<int>& mutualFavorites) {\\n        if (doneFlags[i]) {\\n            return {0, false};\\n        }\\n        // detected a circle\\n        if (visitingFlags[i]) {\\n            visitingFlags[i] = false; // mark the start/end of the circle.\\n            return {0, true};\\n        }\\n        visitingFlags[i] = true;\\n        auto [circleSize, withinTheCircle] =\\n                dfs(favorite[i], favorite, doneFlags, visitingFlags, mutualFavorites);\\n        doneFlags[i] = true;\\n        if (withinTheCircle) {\\n            if (visitingFlags[i]) {\\n                return {circleSize + 1, true};\\n            } else {\\n                // this is the start/end of the circle.\\n                // so, the parent vertex is no longer within the circle.\\n                int newCircleSize = circleSize + 1;\\n                if (newCircleSize == 2) {\\n                    // this is a circle of couplets.\\n                    // we\\'ll handle it specially\\n                    int j = favorite[i];\\n                    mutualFavorites.insert(i);\\n                    mutualFavorites.insert(j);\\n                }\\n                return {newCircleSize, false};\\n            }\\n        }\\n        return {circleSize, false};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const auto n = (int)favorite.size();\\n        vector<bool> done(n);\\n        vector<bool> visiting(n);\\n        // set of person-ids (of mutual-favorite persons)\\n        unordered_set<int> mutualFavorites;\\n\\n        int maxCircle = 0;\\n        int countOfTwoPersonCircles = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (done[i]) {\\n                continue;\\n            }\\n            // do DFS starting from person #i, and compute the circle size;\\n            // if no circle is found, zero will be returned.\\n            auto [circleSize, _] = dfs(i, favorite, done, visiting, mutualFavorites);\\n            maxCircle = max(maxCircle, circleSize);\\n            if (circleSize == 2) {\\n                ++countOfTwoPersonCircles;\\n            }\\n        }\\n        // figure out the actual number of persons that can chain up to the circles of twos.\\n        // invert the graph, for bfs\\n        vector<vector<int>> adj(n);\\n        for (int i = 0; i < n; ++i) {\\n            int j = favorite[i];\\n            adj[j].emplace_back(i);\\n        }\\n\\n        // Do BFS on the reversed graph, to grow the chain of friends that rooted at each person in\\n        // circles of twos.\\n        // in other words, for each root vertex we probe for the max depth.\\n        int personsInSpecialCases = 2 * countOfTwoPersonCircles;\\n        for (const auto root : mutualFavorites) {\\n            int depth = bfs(root, adj, mutualFavorites);\\n            personsInSpecialCases += depth;\\n        }\\n\\n        return max(maxCircle, personsInSpecialCases);\\n    }\\n\\nprivate:\\n    static int\\n    bfs(int root, const vector<vector<int>>& adj, const unordered_set<int>& mutualFavorites) {\\n        queue<int> q;\\n        int depth = 0;\\n        // since there aren\\'t circles for these BFSs,\\n        // we don\\'t need to track the visited-ness.\\n        for (int u : adj[root]) {\\n            if (mutualFavorites.count(u) == 0) {\\n                q.emplace(u);\\n            }\\n        }\\n        while (!q.empty()) {\\n            ++depth;\\n            int qsz = q.size();\\n            while (qsz--) {\\n                // for easier debugging, we can use:\\n                // while (qsz > 0) { --qsz; ... }\\n                int u = q.front();\\n                q.pop();\\n                for (auto v : adj[u]) {\\n                    q.emplace(v);\\n                }\\n            }\\n        }\\n        // cout << \"depth from root #\" << root << \" is: \" << depth << endl;\\n        return depth;\\n    }\\n\\n    /// \\\\brief do DFS starting from person #i, and compute the circle size;\\n    /// if no circle is found, zero will be returned.\\n    /// \\\\param mutualFavorites maintains the persons that are in circles of two persons, for they\\n    /// are special cases.\\n    /// \\\\returns a two-tuple, with the first element representing the size of the circle, and the\\n    /// second element indicates whether the current node is within the circle or not.\\n    static tuple<int, bool>\\n    dfs(int i,\\n        const vector<int>& favorite,\\n        vector<bool>& doneFlags,\\n        vector<bool>& visitingFlags,\\n        unordered_set<int>& mutualFavorites) {\\n        if (doneFlags[i]) {\\n            return {0, false};\\n        }\\n        // detected a circle\\n        if (visitingFlags[i]) {\\n            visitingFlags[i] = false; // mark the start/end of the circle.\\n            return {0, true};\\n        }\\n        visitingFlags[i] = true;\\n        auto [circleSize, withinTheCircle] =\\n                dfs(favorite[i], favorite, doneFlags, visitingFlags, mutualFavorites);\\n        doneFlags[i] = true;\\n        if (withinTheCircle) {\\n            if (visitingFlags[i]) {\\n                return {circleSize + 1, true};\\n            } else {\\n                // this is the start/end of the circle.\\n                // so, the parent vertex is no longer within the circle.\\n                int newCircleSize = circleSize + 1;\\n                if (newCircleSize == 2) {\\n                    // this is a circle of couplets.\\n                    // we\\'ll handle it specially\\n                    int j = favorite[i];\\n                    mutualFavorites.insert(i);\\n                    mutualFavorites.insert(j);\\n                }\\n                return {newCircleSize, false};\\n            }\\n        }\\n        return {circleSize, false};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2095693,
                "title": "java-topological-sort-o-n",
                "content": "```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    boolean[] visited ;\\n    \\n    public int maximumInvitations(int[] favorite) {\\n    \\t\\n    \\tint length = favorite.length ;\\n    \\tthis.adjList = new ArrayList<>() ;\\n        this.visited = new boolean[length] ;\\n    \\tint[] inDegree = new int[length] ;    \\t\\n    \\tint[] armLength = new int[length] ;\\n        Arrays.fill(armLength , 1);\\n    \\t\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tadjList.add(new ArrayList<>());\\n    \\t}\\n    \\t\\n        // Creating adjList and inDegree array\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tadjList.get(i).add(favorite[i]) ;\\n    \\t\\tinDegree[favorite[i]] = inDegree[favorite[i]]+1 ;\\n    \\t}\\n\\n    \\tQueue<Integer> queue = new LinkedList<Integer>() ;\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tif(inDegree[i] == 0) {\\n    \\t\\t\\tqueue.add(i) ;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n        // Get the left and right arm length and store for couple cycle\\n        // LeftArmlength --> (LeftNode) <--> (RightNode) <--- RightArmLength\\n    \\twhile(!queue.isEmpty()) {\\n    \\t\\tint parent = queue.poll();\\n    \\t\\tvisited[parent] = true ;\\n    \\t\\tfor(Integer child : adjList.get(parent)) {\\n    \\t\\t\\tinDegree[child] = inDegree[child] - 1 ;\\n    \\t\\t\\tarmLength[child] = armLength[parent] + 1 ;\\n    \\t\\t\\tif(inDegree[child] == 0) {\\n    \\t\\t\\t\\tqueue.add(child);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tint Max_CycleLength = 0 ;\\n    \\tint totalCoupleWithArmLength = 0 ;\\n        \\n    \\t/*  1. Check for nodes that are not visited yet\\n            2. only the nodes having cycle will remain unvisited\\n            3. cycle length could be either 2 or greater than 2 .\\n            4. Result will be MAX( cycle length greater than 2  OR  sum of All the cycles with length 2 and their arms)        \\n        */\\n        \\n    \\tfor(int i=0 ; i<length ; i++) {    \\t\\t\\n    \\t\\tif(!visited[i]) {    \\t\\t\\t\\n    \\t\\t\\tif(i == favorite[favorite[i]]) {\\n    \\t\\t\\t\\tint curArmLength = armLength[i] + armLength[favorite[i]] ;\\n    \\t\\t\\t\\ttotalCoupleWithArmLength = totalCoupleWithArmLength + curArmLength ;\\n    \\t\\t\\t\\tvisited[i] = true ;\\n    \\t\\t\\t\\tvisited[favorite[i]] = true ;\\n    \\t\\t\\t}else {\\n    \\t\\t\\t\\tint cur_cycleLength = getCycleLength(i);\\n    \\t\\t\\t\\tMax_CycleLength = Math.max( Max_CycleLength , cur_cycleLength);\\n    \\t\\t\\t}    \\t\\t\\t\\n    \\t\\t}    \\t\\t\\n    \\t}\\n    \\t\\n    \\treturn Math.max( Max_CycleLength , totalCoupleWithArmLength) ;\\n    }\\n    \\n    int getCycleLength(int node) {    \\t\\n    \\tint count = 0 ;\\n    \\twhile(!visited[node]) {\\n    \\t\\tvisited[node] = true ;\\n    \\t\\tfor(Integer child : adjList.get(node)) {\\n    \\t\\t\\tcount = getCycleLength(child) + 1 ;\\n    \\t\\t}    \\t\\t\\n    \\t}    \\t\\n    \\treturn count ;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    List<List<Integer>> adjList ;\\n    boolean[] visited ;\\n    \\n    public int maximumInvitations(int[] favorite) {\\n    \\t\\n    \\tint length = favorite.length ;\\n    \\tthis.adjList = new ArrayList<>() ;\\n        this.visited = new boolean[length] ;\\n    \\tint[] inDegree = new int[length] ;    \\t\\n    \\tint[] armLength = new int[length] ;\\n        Arrays.fill(armLength , 1);\\n    \\t\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tadjList.add(new ArrayList<>());\\n    \\t}\\n    \\t\\n        // Creating adjList and inDegree array\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tadjList.get(i).add(favorite[i]) ;\\n    \\t\\tinDegree[favorite[i]] = inDegree[favorite[i]]+1 ;\\n    \\t}\\n\\n    \\tQueue<Integer> queue = new LinkedList<Integer>() ;\\n    \\tfor(int i=0 ; i<length ; i++) {\\n    \\t\\tif(inDegree[i] == 0) {\\n    \\t\\t\\tqueue.add(i) ;\\n    \\t\\t}\\n    \\t}\\n    \\t\\n        // Get the left and right arm length and store for couple cycle\\n        // LeftArmlength --> (LeftNode) <--> (RightNode) <--- RightArmLength\\n    \\twhile(!queue.isEmpty()) {\\n    \\t\\tint parent = queue.poll();\\n    \\t\\tvisited[parent] = true ;\\n    \\t\\tfor(Integer child : adjList.get(parent)) {\\n    \\t\\t\\tinDegree[child] = inDegree[child] - 1 ;\\n    \\t\\t\\tarmLength[child] = armLength[parent] + 1 ;\\n    \\t\\t\\tif(inDegree[child] == 0) {\\n    \\t\\t\\t\\tqueue.add(child);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tint Max_CycleLength = 0 ;\\n    \\tint totalCoupleWithArmLength = 0 ;\\n        \\n    \\t/*  1. Check for nodes that are not visited yet\\n            2. only the nodes having cycle will remain unvisited\\n            3. cycle length could be either 2 or greater than 2 .\\n            4. Result will be MAX( cycle length greater than 2  OR  sum of All the cycles with length 2 and their arms)        \\n        */\\n        \\n    \\tfor(int i=0 ; i<length ; i++) {    \\t\\t\\n    \\t\\tif(!visited[i]) {    \\t\\t\\t\\n    \\t\\t\\tif(i == favorite[favorite[i]]) {\\n    \\t\\t\\t\\tint curArmLength = armLength[i] + armLength[favorite[i]] ;\\n    \\t\\t\\t\\ttotalCoupleWithArmLength = totalCoupleWithArmLength + curArmLength ;\\n    \\t\\t\\t\\tvisited[i] = true ;\\n    \\t\\t\\t\\tvisited[favorite[i]] = true ;\\n    \\t\\t\\t}else {\\n    \\t\\t\\t\\tint cur_cycleLength = getCycleLength(i);\\n    \\t\\t\\t\\tMax_CycleLength = Math.max( Max_CycleLength , cur_cycleLength);\\n    \\t\\t\\t}    \\t\\t\\t\\n    \\t\\t}    \\t\\t\\n    \\t}\\n    \\t\\n    \\treturn Math.max( Max_CycleLength , totalCoupleWithArmLength) ;\\n    }\\n    \\n    int getCycleLength(int node) {    \\t\\n    \\tint count = 0 ;\\n    \\twhile(!visited[node]) {\\n    \\t\\tvisited[node] = true ;\\n    \\t\\tfor(Integer child : adjList.get(node)) {\\n    \\t\\t\\tcount = getCycleLength(child) + 1 ;\\n    \\t\\t}    \\t\\t\\n    \\t}    \\t\\n    \\treturn count ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049598,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    class Vertex {\\n        int id;\\n        int length;\\n        int inDegree;\\n        Vertex next;\\n        boolean processed;\\n        \\n        public Vertex(int id){\\n            this.id = id;\\n            this.length = 1;\\n            this.inDegree = 0;\\n            this.next = null;\\n            this.processed = false;;\\n        }\\n    }\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        Vertex[] vertices = new Vertex[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            vertices[i] = new Vertex(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int source = i;\\n            int dest = favorite[i];\\n            \\n            vertices[source].next = vertices[dest];\\n            vertices[dest].inDegree++;\\n        }\\n        \\n        Queue<Vertex> sources = new LinkedList<>();\\n        for(Vertex vertex : vertices){\\n            if(vertex.inDegree == 0){\\n                sources.offer(vertex);\\n            }\\n        }\\n        \\n        while(!sources.isEmpty()){\\n            Vertex vertex = sources.poll();\\n            Vertex next = vertex.next;\\n            \\n            next.length = Math.max(next.length, vertex.length + 1);\\n            if(--next.inDegree == 0){\\n                sources.offer(next);\\n            }\\n            \\n            vertex.processed = true;\\n        }\\n\\t\\t\\n        int maxCycleLength = 0;\\n        int couplesWithFollowers = 0; //couldn\\'t think of a better name lol\\n        for(Vertex vertex : vertices){\\n            if(vertex.processed){\\n                continue;\\n            }\\n            if(vertex.next.next == vertex){\\n                couplesWithFollowers += vertex.next.length + vertex.length;\\n                vertex.processed = true;\\n                vertex.next.processed = true;\\n            }\\n            else{\\n                maxCycleLength = Math.max(maxCycleLength, determineCycleLength(vertex));\\n            }\\n        }\\n        return Math.max(maxCycleLength, couplesWithFollowers);\\n    }\\n    \\n    public int determineCycleLength(Vertex vertex){\\n        int cycleLength = 0;\\n        while(!vertex.processed){\\n            vertex.processed = true;\\n            vertex = vertex.next;\\n            cycleLength++;\\n        }\\n        return cycleLength;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    class Vertex {\\n        int id;\\n        int length;\\n        int inDegree;\\n        Vertex next;\\n        boolean processed;\\n        \\n        public Vertex(int id){\\n            this.id = id;\\n            this.length = 1;\\n            this.inDegree = 0;\\n            this.next = null;\\n            this.processed = false;;\\n        }\\n    }\\n    public int maximumInvitations(int[] favorite) {\\n        int n = favorite.length;\\n        Vertex[] vertices = new Vertex[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            vertices[i] = new Vertex(i);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int source = i;\\n            int dest = favorite[i];\\n            \\n            vertices[source].next = vertices[dest];\\n            vertices[dest].inDegree++;\\n        }\\n        \\n        Queue<Vertex> sources = new LinkedList<>();\\n        for(Vertex vertex : vertices){\\n            if(vertex.inDegree == 0){\\n                sources.offer(vertex);\\n            }\\n        }\\n        \\n        while(!sources.isEmpty()){\\n            Vertex vertex = sources.poll();\\n            Vertex next = vertex.next;\\n            \\n            next.length = Math.max(next.length, vertex.length + 1);\\n            if(--next.inDegree == 0){\\n                sources.offer(next);\\n            }\\n            \\n            vertex.processed = true;\\n        }\\n\\t\\t\\n        int maxCycleLength = 0;\\n        int couplesWithFollowers = 0; //couldn\\'t think of a better name lol\\n        for(Vertex vertex : vertices){\\n            if(vertex.processed){\\n                continue;\\n            }\\n            if(vertex.next.next == vertex){\\n                couplesWithFollowers += vertex.next.length + vertex.length;\\n                vertex.processed = true;\\n                vertex.next.processed = true;\\n            }\\n            else{\\n                maxCycleLength = Math.max(maxCycleLength, determineCycleLength(vertex));\\n            }\\n        }\\n        return Math.max(maxCycleLength, couplesWithFollowers);\\n    }\\n    \\n    public int determineCycleLength(Vertex vertex){\\n        int cycleLength = 0;\\n        while(!vertex.processed){\\n            vertex.processed = true;\\n            vertex = vertex.next;\\n            cycleLength++;\\n        }\\n        return cycleLength;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925667,
                "title": "python-neat-30-lines-2-dfs-for-cycle-detection-and-branch-length-computation",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, v in enumerate(favorite): graph[v].append(i)\\n        color = [0] * n\\n        cycles = []\\n        def dfs(v):\\n            color[v] = 1\\n            for u in graph[v]:\\n                if color[u] == 0: dfs(u)\\n                elif color[u] == 1: cycles.append((u, v))\\n            color[v] = 2\\n        for i in range(n):\\n            if color[i] == 0 and graph[i]: dfs(i)\\n        def down(v): return max((1 + down(u) for u in graph[v]), default=1)\\n        ans, l2 = 0, 0\\n        for u, v in cycles:\\n            cycle_len = 1\\n            k = favorite[u]\\n            while k != u:\\n                k = favorite[k]\\n                cycle_len += 1\\n            ans = max(ans, cycle_len)\\n            if cycle_len == 2:\\n                vmax = max((down(k) for k in graph[v] if k != u), default=0)\\n                umax = max((down(k) for k in graph[u] if k != v), default=0)\\n                l2 += cycle_len + umax + vmax\\n        ans = max(ans, l2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, v in enumerate(favorite): graph[v].append(i)\\n        color = [0] * n\\n        cycles = []\\n        def dfs(v):\\n            color[v] = 1\\n            for u in graph[v]:\\n                if color[u] == 0: dfs(u)\\n                elif color[u] == 1: cycles.append((u, v))\\n            color[v] = 2\\n        for i in range(n):\\n            if color[i] == 0 and graph[i]: dfs(i)\\n        def down(v): return max((1 + down(u) for u in graph[v]), default=1)\\n        ans, l2 = 0, 0\\n        for u, v in cycles:\\n            cycle_len = 1\\n            k = favorite[u]\\n            while k != u:\\n                k = favorite[k]\\n                cycle_len += 1\\n            ans = max(ans, cycle_len)\\n            if cycle_len == 2:\\n                vmax = max((down(k) for k in graph[v] if k != u), default=0)\\n                umax = max((down(k) for k in graph[u] if k != v), default=0)\\n                l2 += cycle_len + umax + vmax\\n        ans = max(ans, l2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807402,
                "title": "python-tarjan-s-algorithm-strongly-connected-components",
                "content": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        N = len(favorite)\\n        people = 0\\n        adj_list = defaultdict(list)\\n        indegree = defaultdict(list)\\n        bond = set()\\n        \\n        for a, b in enumerate(favorite):\\n            adj_list[a].append(b)\\n            indegree[b].append(a)\\n            if favorite[b] == a:\\n                bond.add(tuple(sorted([a, b])))\\n        \\n        # 1 case, \\n        # find total number of bonding of 2 people and a tail for each of this person\\n        def find(node, seen):\\n            total = 0\\n            for nei in indegree[node]:\\n                if nei not in seen:\\n                    seen.add(nei)\\n                    total = max(total, find(nei, seen) + 1)\\n            return total\\n        \\n        for a, b in bond:\\n            seen = {a, b}\\n            people += 2 + find(a, seen) + find(b, seen)\\n        \\n        \\n        # 2 case, Tarjan\\'s algorithm\\n        # find max number of nodes in a Strongly Connected Component (SCC)\\n        def dfs(curr):\\n            nonlocal i, scc_max\\n            stack.append(curr)\\n            on_stack[curr] = 1\\n            i += 1\\n            ids[curr] = low[curr] = i\\n            \\n            for nei in adj_list[curr]:\\n                if ids[nei] == -1:\\n                    dfs(nei)\\n                if on_stack[nei]:\\n                    low[curr] = min(low[curr], low[nei])\\n            \\n            if ids[curr] == low[curr]:\\n                scc_length = 0\\n                while stack:\\n                    scc_length += 1\\n                    node = stack.pop()\\n                    on_stack[node] = 0\\n                    low[node] = ids[curr]\\n                    if node == curr:\\n                        break\\n                if scc_length > 2:\\n                    scc_max = max(scc_max, scc_length)\\n        scc_max = 0\\n        i = 0\\n        on_stack = [0] * N\\n        stack = []\\n        ids = [-1] * N\\n        low = [0] * N\\n        \\n        for i in range(N):\\n            if ids[i] == -1:\\n                dfs(i)\\n        \\n        return max(people, scc_max)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        N = len(favorite)\\n        people = 0\\n        adj_list = defaultdict(list)\\n        indegree = defaultdict(list)\\n        bond = set()\\n        \\n        for a, b in enumerate(favorite):\\n            adj_list[a].append(b)\\n            indegree[b].append(a)\\n            if favorite[b] == a:\\n                bond.add(tuple(sorted([a, b])))\\n        \\n        # 1 case, \\n        # find total number of bonding of 2 people and a tail for each of this person\\n        def find(node, seen):\\n            total = 0\\n            for nei in indegree[node]:\\n                if nei not in seen:\\n                    seen.add(nei)\\n                    total = max(total, find(nei, seen) + 1)\\n            return total\\n        \\n        for a, b in bond:\\n            seen = {a, b}\\n            people += 2 + find(a, seen) + find(b, seen)\\n        \\n        \\n        # 2 case, Tarjan\\'s algorithm\\n        # find max number of nodes in a Strongly Connected Component (SCC)\\n        def dfs(curr):\\n            nonlocal i, scc_max\\n            stack.append(curr)\\n            on_stack[curr] = 1\\n            i += 1\\n            ids[curr] = low[curr] = i\\n            \\n            for nei in adj_list[curr]:\\n                if ids[nei] == -1:\\n                    dfs(nei)\\n                if on_stack[nei]:\\n                    low[curr] = min(low[curr], low[nei])\\n            \\n            if ids[curr] == low[curr]:\\n                scc_length = 0\\n                while stack:\\n                    scc_length += 1\\n                    node = stack.pop()\\n                    on_stack[node] = 0\\n                    low[node] = ids[curr]\\n                    if node == curr:\\n                        break\\n                if scc_length > 2:\\n                    scc_max = max(scc_max, scc_length)\\n        scc_max = 0\\n        i = 0\\n        on_stack = [0] * N\\n        stack = []\\n        ids = [-1] * N\\n        low = [0] * N\\n        \\n        for i in range(N):\\n            if ids[i] == -1:\\n                dfs(i)\\n        \\n        return max(people, scc_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801700,
                "title": "python-bfs-topological-sort-o-n",
                "content": "There are 3 main steps in this algorithm\\n1. Count number of inbound favorites to any given person `i`\\n2. Do a breadth first search starting from any person without any inbound favorites. Each edge is the person\\'s own favorite. Decrement the number of inbound favorites for that next person. And only if there are no other inbound favorites to that next person, do a bfs to them. Essentailly we\\'re trying to explore all chains and see the max chain to a cycle. Since every cycle will have an edge coming from within the cycle, we can never visit nodes in the cycle (a little confusing, hope that makes sense).\\n3. Next we visit every cycle and consider 2 cases. Either there is a huge cycle, and that\\'s all that can be at the table (you can\\'t have multiple cycles at a table, it just doesn\\'t work). Or you can have a ton of mutual favorites + chains. In the case of only considering mutual favorites you can have as many as you want at a table so we `add` instead of `max`.\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        indegrees = [0]*len(favorite)\\n        for f in favorite:\\n            indegrees[f] += 1\\n        queue = deque([i for i, c in enumerate(indegrees) if c == 0])\\n        levels = [0]*len(favorite)\\n        visited = [False]*len(favorite)\\n        while len(queue) > 0:\\n            i = queue.popleft()\\n            visited[i] = True\\n            f = favorite[i]\\n            # start level is 0, note that parts of a cycle with inbound favorites will get a degree\\n            levels[f] = max(levels[f], levels[i]+1)\\n            indegrees[f] -= 1\\n            if indegrees[f] == 0:\\n                queue.append(f)\\n\\n        def count_cycle(i):\\n            count = 0\\n            while True:\\n                # once we return to the beginning we would have already visited it\\n                if visited[i]:\\n                    return count\\n                visited[i] = True\\n                count += 1\\n                i = favorite[i]\\n        \\n        chain_count = 0\\n        max_cycle = 0\\n        for i in range(len(favorite)):\\n            if not visited[i]:\\n                # 2 cycle loop\\n                if i == favorite[favorite[i]]:\\n                    chain_count += levels[i] + 1\\n                else:\\n                    max_cycle = max(max_cycle, count_cycle(i))\\n\\n        return max(chain_count, max_cycle)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        indegrees = [0]*len(favorite)\\n        for f in favorite:\\n            indegrees[f] += 1\\n        queue = deque([i for i, c in enumerate(indegrees) if c == 0])\\n        levels = [0]*len(favorite)\\n        visited = [False]*len(favorite)\\n        while len(queue) > 0:\\n            i = queue.popleft()\\n            visited[i] = True\\n            f = favorite[i]\\n            # start level is 0, note that parts of a cycle with inbound favorites will get a degree\\n            levels[f] = max(levels[f], levels[i]+1)\\n            indegrees[f] -= 1\\n            if indegrees[f] == 0:\\n                queue.append(f)\\n\\n        def count_cycle(i):\\n            count = 0\\n            while True:\\n                # once we return to the beginning we would have already visited it\\n                if visited[i]:\\n                    return count\\n                visited[i] = True\\n                count += 1\\n                i = favorite[i]\\n        \\n        chain_count = 0\\n        max_cycle = 0\\n        for i in range(len(favorite)):\\n            if not visited[i]:\\n                # 2 cycle loop\\n                if i == favorite[favorite[i]]:\\n                    chain_count += levels[i] + 1\\n                else:\\n                    max_cycle = max(max_cycle, count_cycle(i))\\n\\n        return max(chain_count, max_cycle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799820,
                "title": "python-first-process-indegree-0-nodes-and-then-process-cycles-o-n-clean-code",
                "content": "Same as the idea of https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661178/Python-Explanation-with-pictures\\nbut much cleaner code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        dp = [1]*(len(favorite))\\n        indeg = defaultdict(int)\\n        stack = []\\n        for i, e in enumerate(favorite):\\n            indeg[favorite[i]] += 1\\n        for i in range(n):\\n            if not indeg[i]:\\n                stack.append(i)\\n        while stack:\\n            i = stack.pop()\\n            dp[favorite[i]] = max(dp[favorite[i]],dp[i]+1)\\n            indeg[favorite[i]] -= 1\\n            if not indeg[favorite[i]]:\\n                stack.append(favorite[i])\\n        res = 0\\n        small_cycles = 0\\n        for i in range(n):\\n            if indeg[i]:\\n                cycle_length = 0\\n                prei = i\\n                while indeg[i]:\\n                    cycle_length += 1\\n                    indeg[i] = 0\\n                    i = favorite[i]\\n                if cycle_length == 2:\\n                    #sum of paths with length-two cycles\\n                    small_cycles += dp[prei]+dp[favorite[prei]]\\n                else:\\n                    res = max(res, cycle_length)\\n        return max(res, small_cycles)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        dp = [1]*(len(favorite))\\n        indeg = defaultdict(int)\\n        stack = []\\n        for i, e in enumerate(favorite):\\n            indeg[favorite[i]] += 1\\n        for i in range(n):\\n            if not indeg[i]:\\n                stack.append(i)\\n        while stack:\\n            i = stack.pop()\\n            dp[favorite[i]] = max(dp[favorite[i]],dp[i]+1)\\n            indeg[favorite[i]] -= 1\\n            if not indeg[favorite[i]]:\\n                stack.append(favorite[i])\\n        res = 0\\n        small_cycles = 0\\n        for i in range(n):\\n            if indeg[i]:\\n                cycle_length = 0\\n                prei = i\\n                while indeg[i]:\\n                    cycle_length += 1\\n                    indeg[i] = 0\\n                    i = favorite[i]\\n                if cycle_length == 2:\\n                    #sum of paths with length-two cycles\\n                    small_cycles += dp[prei]+dp[favorite[prei]]\\n                else:\\n                    res = max(res, cycle_length)\\n        return max(res, small_cycles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1700764,
                "title": "dfs-dp-approach",
                "content": "The answer is either going to be the largest cycle in the graph or series of chains which have only 1 cycle of 2 nodes\\n\\nLook at image Here: https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1674049/Mutual-Favorites\\n\\nThe problem is set up in such a way that there will always be atleast one cycle in the graph lets say:\\ni->j->k then k has to point to either i or j thus forming a cycle (since k cannot point to itself).\\n\\n\\n```\\nclass Solution {\\n    int mx;\\n    vector<int> vis,timer,dp;\\n    vector<vector<int>> g,gt;\\npublic:\\n\\t// finding the largest cycle\\n    void dfs(int u,int cd){\\n        vis[u]=1;\\n        timer[u]=cd;\\n        for(auto v:g[u]){\\n            if(vis[v]){\\n                if(timer[v]>=0)\\n                    mx=max(mx,abs(cd-timer[v]+1));\\n            }\\n            else\\n                dfs(v,cd+1);\\n        }\\n        timer[u]=-1;\\n    }\\n    \\n\\t// finding the largest length acyclic chains attached to a cycle of 2 nodes\\n    int solver(int u,int p){\\n        if(dp[u])\\n            return dp[u];\\n        dp[u]=1;\\n        for(auto v:gt[u])\\n            if(v!=p)\\n                dp[u]=max(dp[u],1+solver(v,p));\\n        return dp[u];\\n    }\\n    \\n    int maximumInvitations(vector<int>& a) {\\n        int n=a.size();\\n        \\n        g.resize(n+2);\\n        gt.resize(n+2);\\n        \\n\\t\\t// to store cycles with only 2 nodes\\n        set<vector<int>> cycles;\\n        \\n        for(int i=0;i<n;i++){\\n            gt[a[i]].push_back(i);\\n            g[i].push_back(a[i]);\\n            if(a[a[i]]==i)\\n                cycles.insert({min(a[i],i),max(i,a[i])});\\n        }\\n        \\n        mx=0;\\n        vis.resize(n+2,0);\\n        timer.resize(n+2,-1);\\n        dp.resize(n+2,0);\\n        \\n        for(int i=0;i<n;i++)\\n            if(!vis[i])\\n                dfs(i,0);\\n        \\n        int cmx=0;\\n        for(auto v:cycles){\\n            int l=solver(v[0],v[1]); // left chain\\n            int r=solver(v[1],v[0]); // right chain\\n            cmx=cmx+l+r;\\n        }\\n        \\n        return max(mx,cmx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int mx;\\n    vector<int> vis,timer,dp;\\n    vector<vector<int>> g,gt;\\npublic:\\n\\t// finding the largest cycle\\n    void dfs(int u,int cd){\\n        vis[u]=1;\\n        timer[u]=cd;\\n        for(auto v:g[u]){\\n            if(vis[v]){\\n                if(timer[v]>=0)\\n                    mx=max(mx,abs(cd-timer[v]+1));\\n            }\\n            else\\n                dfs(v,cd+1);\\n        }\\n        timer[u]=-1;\\n    }\\n    \\n\\t// finding the largest length acyclic chains attached to a cycle of 2 nodes\\n    int solver(int u,int p){\\n        if(dp[u])\\n            return dp[u];\\n        dp[u]=1;\\n        for(auto v:gt[u])\\n            if(v!=p)\\n                dp[u]=max(dp[u],1+solver(v,p));\\n        return dp[u];\\n    }\\n    \\n    int maximumInvitations(vector<int>& a) {\\n        int n=a.size();\\n        \\n        g.resize(n+2);\\n        gt.resize(n+2);\\n        \\n\\t\\t// to store cycles with only 2 nodes\\n        set<vector<int>> cycles;\\n        \\n        for(int i=0;i<n;i++){\\n            gt[a[i]].push_back(i);\\n            g[i].push_back(a[i]);\\n            if(a[a[i]]==i)\\n                cycles.insert({min(a[i],i),max(i,a[i])});\\n        }\\n        \\n        mx=0;\\n        vis.resize(n+2,0);\\n        timer.resize(n+2,-1);\\n        dp.resize(n+2,0);\\n        \\n        for(int i=0;i<n;i++)\\n            if(!vis[i])\\n                dfs(i,0);\\n        \\n        int cmx=0;\\n        for(auto v:cycles){\\n            int l=solver(v[0],v[1]); // left chain\\n            int r=solver(v[1],v[0]); // right chain\\n            cmx=cmx+l+r;\\n        }\\n        \\n        return max(mx,cmx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677847,
                "title": "go-topological-sort",
                "content": "Go version of this solution:\\nhttps://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1661394/Java-Short-solution-based-on-topological-sort-which-leaves-just-loops\\n\\n```\\nfunc maximumInvitations(favorite []int) int {\\n\\tn := len(favorite)\\n\\tindegrees := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tj := favorite[i]\\n\\t\\tindegrees[j]++\\n\\t}\\n\\n\\tvar queue []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif indegrees[i] == 0 {\\n\\t\\t\\tqueue = append(queue, i)\\n\\t\\t}\\n\\t}\\n\\n\\tdp := make([]int, n) // dp[i] is the longest path leading to i exclusively.\\n\\tvar i int\\n\\tfor len(queue) != 0 {\\n\\t\\ti, queue = queue[0], queue[1:] // remove front\\n\\t\\tj := favorite[i]\\n\\t\\tdp[j] = max(dp[j], dp[i]+1)\\n\\n\\t\\tindegrees[j]--\\n\\t\\tif indegrees[j] == 0 {\\n\\t\\t\\tqueue = append(queue, j)\\n\\t\\t}\\n\\t}\\n\\n\\tres, res2 := 0, 0\\n\\tfor i = 0; i < n; i++ {\\n\\t\\tif indegrees[i] != 0 {\\n\\t\\t\\tlength := 0\\n\\t\\t\\tfor j := i; indegrees[j] > 0; j = favorite[j] {\\n\\t\\t\\t\\tindegrees[j] = 0\\n\\t\\t\\t\\tlength++\\n\\t\\t\\t}\\n\\n\\t\\t\\tif length == 2 {\\n\\t\\t\\t\\tres2 += 2 + dp[i] + dp[favorite[i]]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres = max(res, length)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(res, res2)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```\\nfunc maximumInvitations(favorite []int) int {\\n\\tn := len(favorite)\\n\\tindegrees := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tj := favorite[i]\\n\\t\\tindegrees[j]++\\n\\t}\\n\\n\\tvar queue []int\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif indegrees[i] == 0 {\\n\\t\\t\\tqueue = append(queue, i)\\n\\t\\t}\\n\\t}\\n\\n\\tdp := make([]int, n) // dp[i] is the longest path leading to i exclusively.\\n\\tvar i int\\n\\tfor len(queue) != 0 {\\n\\t\\ti, queue = queue[0], queue[1:] // remove front\\n\\t\\tj := favorite[i]\\n\\t\\tdp[j] = max(dp[j], dp[i]+1)\\n\\n\\t\\tindegrees[j]--\\n\\t\\tif indegrees[j] == 0 {\\n\\t\\t\\tqueue = append(queue, j)\\n\\t\\t}\\n\\t}\\n\\n\\tres, res2 := 0, 0\\n\\tfor i = 0; i < n; i++ {\\n\\t\\tif indegrees[i] != 0 {\\n\\t\\t\\tlength := 0\\n\\t\\t\\tfor j := i; indegrees[j] > 0; j = favorite[j] {\\n\\t\\t\\t\\tindegrees[j] = 0\\n\\t\\t\\t\\tlength++\\n\\t\\t\\t}\\n\\n\\t\\t\\tif length == 2 {\\n\\t\\t\\t\\tres2 += 2 + dp[i] + dp[favorite[i]]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres = max(res, length)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(res, res2)\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676672,
                "title": "python-simple-explanation",
                "content": "such a table must be either of the two forms:\\n1. the biggest single cycle. e.g. a->b->c, table is 3.\\n2. all cycles of 2 (couples), plus all of their longest leaf on both sides of each couple. why? first of all, all couples can be on table and remain valid. second look further at one of the couple a, b (whose fav is each other), for a, if c likes a, d likes c, ..., such that a <- c <- d. then d and c can also be on table. so we need to look at the longest fav chain that ends at the couple side a. same for b. same for all other couples. \\n\\n1350ms. 92%\\n```python\\n    def maximumInvitations(self, fav: List[int]) -> int:\\n        # 1st, check max single cycle\\n        n, seen, cycle = len(fav), set(), []\\n        for u in range(n):\\n            if u in seen:\\n                continue\\n            tseen = set()\\n            while u not in seen and u not in tseen:\\n                tseen.add(u)\\n                u = fav[u]\\n            else:\\n                if u in tseen:\\n                    cycle += u,\\n            seen |= tseen\\n\\n        res = 0\\n        for s in cycle:\\n            c, ns = 1, fav[s]\\n            while ns != s:\\n                c, ns = c + 1, fav[ns]\\n            res = max(res, c) \\n        \\n        # 2nd, check all cycle of 2 + their longest leaf\\n        G, couple = [[] for _ in range(n)], []\\n        for i, j in enumerate(fav):\\n            G[j] += i,\\n            if fav[j] == i and i < j:\\n                couple += [i, j],\\n                \\n        c = len(couple) * 2\\n        for i, j in couple:  # couples are guaranteed to be disconnected among each other because one can have only one fav\\n            stck = [(i, i, 0), (j, j, 0)]\\n            D = {i: 0, j: 0}\\n            while stck:\\n                cur, src, d = stck.pop()\\n                D[src] = max(D[src], d)\\n                for suc in G[cur]:\\n                    if suc != i and suc != j:\\n                        stck += (suc, src, d+1),\\n            c += sum(D.values())\\n        \\n        return max(c, res)\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maximumInvitations(self, fav: List[int]) -> int:\\n        # 1st, check max single cycle\\n        n, seen, cycle = len(fav), set(), []\\n        for u in range(n):\\n            if u in seen:\\n                continue\\n            tseen = set()\\n            while u not in seen and u not in tseen:\\n                tseen.add(u)\\n                u = fav[u]\\n            else:\\n                if u in tseen:\\n                    cycle += u,\\n            seen |= tseen\\n\\n        res = 0\\n        for s in cycle:\\n            c, ns = 1, fav[s]\\n            while ns != s:\\n                c, ns = c + 1, fav[ns]\\n            res = max(res, c) \\n        \\n        # 2nd, check all cycle of 2 + their longest leaf\\n        G, couple = [[] for _ in range(n)], []\\n        for i, j in enumerate(fav):\\n            G[j] += i,\\n            if fav[j] == i and i < j:\\n                couple += [i, j],\\n                \\n        c = len(couple) * 2\\n        for i, j in couple:  # couples are guaranteed to be disconnected among each other because one can have only one fav\\n            stck = [(i, i, 0), (j, j, 0)]\\n            D = {i: 0, j: 0}\\n            while stck:\\n                cur, src, d = stck.pop()\\n                D[src] = max(D[src], d)\\n                for suc in G[cur]:\\n                    if suc != i and suc != j:\\n                        stck += (suc, src, d+1),\\n            c += sum(D.values())\\n        \\n        return max(c, res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1674731,
                "title": "swift-solution",
                "content": "The idea is finding\\nCase 1 : 1 strongly coupled emplyoee + farthest perpheral employee.\\nCase 2 : Cycle detection.\\nOther posts have good explanations so please look at those posts if you need one.\\n\\n```\\nclass Solution {\\n    func maximumInvitations(_ favorite: [Int]) -> Int {\\n        var visited = [Int](repeating: 0, count: favorite.count)\\n        var inverse = [[Int]?](repeating: nil, count: favorite.count)\\n        for (i, f) in favorite.enumerated() {\\n            if inverse[f] == nil {\\n                inverse[f] = [Int]()\\n            }\\n            inverse[f]!.append(i)\\n        }\\n        var result = 0\\n        // case 1: one couple cycle + peripheral employees\\n        // All of \"chunks\" can be summed up and build a round table if you think about it.\\n        for (i, f) in favorite.enumerated() {\\n            if i == favorite[f] && f == favorite[i] && visited[i] == 0 {\\n                result += recursive2(&visited, f, inverse, i) + recursive2(&visited, i, inverse, f)\\n            }\\n        }\\n        \\n        // case 2: detect cycle\\n        for i in 0..<favorite.count {\\n            if visited[i] == 0 {\\n                result = max(recursive(&visited, i, favorite, 0), result)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    // we use the inverse to get the farthest the peripheral employee\\n    func recursive2(_ visited: inout [Int], _ i: Int, _ g: [[Int]?], _ op: Int) -> Int {\\n        visited[i] = -1\\n        guard g[i] != nil else { return 1 }\\n        var result = 0\\n        for c in g[i]! {\\n            // don\\'t go to the opposite side\\n            guard c != op else { continue }\\n            result = max(result, recursive2(&visited, c, g, op))\\n        }\\n        return result + 1\\n    }\\n    \\n    // cycle detection(DFS with backward edge check)\\n    func recursive(_ visited: inout [Int], _ i: Int, _ g: [Int], _ count: Int) -> Int {\\n        visited[i] = count + 1\\n        var result = 0\\n        var c = g[i]\\n        if visited[c] == -1 {\\n            result = 0\\n        } else if visited[c] > 0 {\\n            result = visited[i] - visited[c] + 1\\n        } else {\\n            result = recursive(&visited, c, g, count + 1)\\n        }\\n        visited[i] = -1\\n        visited[c] = -1\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumInvitations(_ favorite: [Int]) -> Int {\\n        var visited = [Int](repeating: 0, count: favorite.count)\\n        var inverse = [[Int]?](repeating: nil, count: favorite.count)\\n        for (i, f) in favorite.enumerated() {\\n            if inverse[f] == nil {\\n                inverse[f] = [Int]()\\n            }\\n            inverse[f]!.append(i)\\n        }\\n        var result = 0\\n        // case 1: one couple cycle + peripheral employees\\n        // All of \"chunks\" can be summed up and build a round table if you think about it.\\n        for (i, f) in favorite.enumerated() {\\n            if i == favorite[f] && f == favorite[i] && visited[i] == 0 {\\n                result += recursive2(&visited, f, inverse, i) + recursive2(&visited, i, inverse, f)\\n            }\\n        }\\n        \\n        // case 2: detect cycle\\n        for i in 0..<favorite.count {\\n            if visited[i] == 0 {\\n                result = max(recursive(&visited, i, favorite, 0), result)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    // we use the inverse to get the farthest the peripheral employee\\n    func recursive2(_ visited: inout [Int], _ i: Int, _ g: [[Int]?], _ op: Int) -> Int {\\n        visited[i] = -1\\n        guard g[i] != nil else { return 1 }\\n        var result = 0\\n        for c in g[i]! {\\n            // don\\'t go to the opposite side\\n            guard c != op else { continue }\\n            result = max(result, recursive2(&visited, c, g, op))\\n        }\\n        return result + 1\\n    }\\n    \\n    // cycle detection(DFS with backward edge check)\\n    func recursive(_ visited: inout [Int], _ i: Int, _ g: [Int], _ count: Int) -> Int {\\n        visited[i] = count + 1\\n        var result = 0\\n        var c = g[i]\\n        if visited[c] == -1 {\\n            result = 0\\n        } else if visited[c] > 0 {\\n            result = visited[i] - visited[c] + 1\\n        } else {\\n            result = recursive(&visited, c, g, count + 1)\\n        }\\n        visited[i] = -1\\n        visited[c] = -1\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664868,
                "title": "c-javascript-return-max-maxcyclelength-sumofmaxcycle2chainlengths",
                "content": "---\\n\\n**Weekly Contest 274**\\n  - **Q1** answer\\n    - https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/discuss/1661296/JavaScript-2124.-Check-if-All-A\\'s-Appears-Before-All-B\\'s\\n- **Q2** answer\\n  - https://leetcode.com/problems/number-of-laser-beams-in-a-bank/discuss/1661353/javascript-2125-number-of-laser-beams-in-a-bank\\n- **Q3** answer\\n  - https://leetcode.com/problems/destroying-asteroids/discuss/1661395/JavaScript-2126.-Destroying-Asteroids\\n- **Q4** answer - **C++ & JavaScript**\\n  - https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1664868/C%2B%2B-JavaScript-return-max-(-maxCycleLength-sumOfMaxCycle2ChainLengths-)\\n  - **below**\\n    - In the contest, could get to largest cycle, but not to the 2 cycle chains\\n\\n---\\n\\n- This code is derived from code of **[@Heltion](https://leetcode-cn.com/u/Heltion/)**\\n- Original code can be seen ( **Rank 2 / Heltion/ Q4** ) at https://leetcode.com/contest/weekly-contest-274/ranking\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/8pkq598Q/shared\" frameBorder=\"0\" width=\"900\" height=\"1100\"></iframe>\\n\\n---\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript"
                ],
                "code": "---\\n\\n**Weekly Contest 274**\\n  - **Q1** answer\\n    - https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/discuss/1661296/JavaScript-2124.-Check-if-All-A\\'s-Appears-Before-All-B\\'s\\n- **Q2** answer\\n  - https://leetcode.com/problems/number-of-laser-beams-in-a-bank/discuss/1661353/javascript-2125-number-of-laser-beams-in-a-bank\\n- **Q3** answer\\n  - https://leetcode.com/problems/destroying-asteroids/discuss/1661395/JavaScript-2126.-Destroying-Asteroids\\n- **Q4** answer - **C++ & JavaScript**\\n  - https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1664868/C%2B%2B-JavaScript-return-max-(-maxCycleLength-sumOfMaxCycle2ChainLengths-)\\n  - **below**\\n    - In the contest, could get to largest cycle, but not to the 2 cycle chains\\n\\n---\\n\\n- This code is derived from code of **[@Heltion](https://leetcode-cn.com/u/Heltion/)**\\n- Original code can be seen ( **Rank 2 / Heltion/ Q4** ) at https://leetcode.com/contest/weekly-contest-274/ranking\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/8pkq598Q/shared\" frameBorder=\"0\" width=\"900\" height=\"1100\"></iframe>\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1664257,
                "title": "union-find-topological-sort-c-step-wise-easy-implementation",
                "content": "STEP 1 : We are finding cycles using union find and storing starting and ending pair of cycle in a new array.\\nSTEP 2 : We need to calculate length of each cycle for which we are using this loop:\\n\\n\\twhile(src != dest){\\n        count++;\\n        src = adj[src][0];\\n    }\\n\\nSTEP 3 : If loop size if 2 then we are storing those pairs of starting and ending points in seperate vector, because\\nwe need to process all the loops of size 2. \\nelse if loop size > 2 then we need to store the maximum length among all the loops of size > 2, let\\'s say in the **answer** variable.\\n\\nSTEP 4 : Now before processing loops of size 2, we need to create a distance array which will tell the longest distance of a node from the leaf node. for this we will use standard topological sort algorithm with indegrees.\\n\\nSTEP 5 : We will process each loop of size 2 and calculate the distance of longest branch coming from leaf node to each of the starting and ending node of the loop, for this we will use the array which we had created using the topological sort. And then we will all the 3 distances longest branch from leaf node to starting node of the loop + longest branch from leaf node to ending node of the loop + 2(representing starting node + ending node).\\nHere we need to sum up this preprocessed value for each of the size 2 loop, because each loop will form a separate connected component, and we need to combine all the size 2 loops from each connected component.\\n\\nSTEP 6 : Now we will simply return the maximum of **answer** and **sum of all the processed size 2 loops**.\\n\\n\\t\\t\\t\\n\\n\\n\\n    int get(int x, vector<int> &parent){\\n        return parent[x] = parent[x] == x ? x : get(parent[x], parent);\\n    }\\n    \\n    void merge(int l, int r, vector<int> &parent, vector<int> &rank){\\n        if(rank[l] == rank[r]) rank[l]++;\\n        if(rank[l] > rank[r]) parent[r] = l;\\n        else parent[l] = r;\\n        return;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        if(n==2) return 2;\\n        vector<int> in(n,0);\\n        vector<int> par(n);\\n        vector<int> rank(n,1);\\n        vector<vector<int>> adj(n);\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<n; i++){\\n            par[i] = i;\\n        }\\n        for(int i=0; i<n; i++){\\n            int u = i;\\n            int v = favorite[i];\\n            in[v]++;\\n            adj[i].push_back(v);\\n            u = get(u, par);\\n            v = get(v, par);\\n            if(u == v) {\\n                vp.push_back({favorite[i], i});\\n            }\\n            merge(u,v,par,rank);\\n        }\\n        int ans = 0;\\n        vector<pair<int,int>> pairof2;\\n        for(auto p : vp){\\n            int src = p.first;\\n            int dest = p.second;\\n            int count = 0;\\n            while(src != dest){\\n                count++;\\n                src = adj[src][0];\\n            }\\n            if(count == 1){\\n                pairof2.push_back(p);\\n            }else{\\n                ans = max(count+1, ans);\\n            }\\n        }\\n\\n        queue<int> que;\\n        vector<int> dis(n,0);\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0) que.push(i) ;\\n        }\\n        while(!que.empty()){\\n            auto node = que.front();\\n            que.pop();\\n            for(auto it : adj[node]){\\n                if(--in[it] == 0) {\\n                    que.push(it);\\n                }\\n                dis[it] = max(dis[it], 1 + dis[node]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(auto it: pairof2){\\n            int u = it.first;\\n            int v = it.second;\\n            sum += dis[u] + dis[v] + 2;\\n        }\\n        return max(ans,sum);\\n    }\\n",
                "solutionTags": [],
                "code": "STEP 1 : We are finding cycles using union find and storing starting and ending pair of cycle in a new array.\\nSTEP 2 : We need to calculate length of each cycle for which we are using this loop:\\n\\n\\twhile(src != dest){\\n        count++;\\n        src = adj[src][0];\\n    }\\n\\nSTEP 3 : If loop size if 2 then we are storing those pairs of starting and ending points in seperate vector, because\\nwe need to process all the loops of size 2. \\nelse if loop size > 2 then we need to store the maximum length among all the loops of size > 2, let\\'s say in the **answer** variable.\\n\\nSTEP 4 : Now before processing loops of size 2, we need to create a distance array which will tell the longest distance of a node from the leaf node. for this we will use standard topological sort algorithm with indegrees.\\n\\nSTEP 5 : We will process each loop of size 2 and calculate the distance of longest branch coming from leaf node to each of the starting and ending node of the loop, for this we will use the array which we had created using the topological sort. And then we will all the 3 distances longest branch from leaf node to starting node of the loop + longest branch from leaf node to ending node of the loop + 2(representing starting node + ending node).\\nHere we need to sum up this preprocessed value for each of the size 2 loop, because each loop will form a separate connected component, and we need to combine all the size 2 loops from each connected component.\\n\\nSTEP 6 : Now we will simply return the maximum of **answer** and **sum of all the processed size 2 loops**.\\n\\n\\t\\t\\t\\n\\n\\n\\n    int get(int x, vector<int> &parent){\\n        return parent[x] = parent[x] == x ? x : get(parent[x], parent);\\n    }\\n    \\n    void merge(int l, int r, vector<int> &parent, vector<int> &rank){\\n        if(rank[l] == rank[r]) rank[l]++;\\n        if(rank[l] > rank[r]) parent[r] = l;\\n        else parent[l] = r;\\n        return;\\n    }\\n    \\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        if(n==2) return 2;\\n        vector<int> in(n,0);\\n        vector<int> par(n);\\n        vector<int> rank(n,1);\\n        vector<vector<int>> adj(n);\\n        vector<pair<int,int>> vp;\\n        for(int i=0; i<n; i++){\\n            par[i] = i;\\n        }\\n        for(int i=0; i<n; i++){\\n            int u = i;\\n            int v = favorite[i];\\n            in[v]++;\\n            adj[i].push_back(v);\\n            u = get(u, par);\\n            v = get(v, par);\\n            if(u == v) {\\n                vp.push_back({favorite[i], i});\\n            }\\n            merge(u,v,par,rank);\\n        }\\n        int ans = 0;\\n        vector<pair<int,int>> pairof2;\\n        for(auto p : vp){\\n            int src = p.first;\\n            int dest = p.second;\\n            int count = 0;\\n            while(src != dest){\\n                count++;\\n                src = adj[src][0];\\n            }\\n            if(count == 1){\\n                pairof2.push_back(p);\\n            }else{\\n                ans = max(count+1, ans);\\n            }\\n        }\\n\\n        queue<int> que;\\n        vector<int> dis(n,0);\\n        for(int i=0; i<n; i++){\\n            if(in[i] == 0) que.push(i) ;\\n        }\\n        while(!que.empty()){\\n            auto node = que.front();\\n            que.pop();\\n            for(auto it : adj[node]){\\n                if(--in[it] == 0) {\\n                    que.push(it);\\n                }\\n                dis[it] = max(dis[it], 1 + dis[node]);\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(auto it: pairof2){\\n            int u = it.first;\\n            int v = it.second;\\n            sum += dis[u] + dis[v] + 2;\\n        }\\n        return max(ans,sum);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1663470,
                "title": "c-dfs-bfs-practice-solution-760ms",
                "content": "1. Find all paired favorite\\n2. BFS find chain length, using \"favoriteBy\" \\n\\tmark all the nodes along the path \"visited\", by giving them a sequence number.\\n3. DFS find max cycle length in rest of the nodes, mark nodes \"visiting\" for loop detection, or \"dfs done through this node\" to avoid re-DFS.  \\n4. return Max(maxCycleLen, chainLen)\\n\\n```\\npublic class Solution {\\n    int maxCycleLen = 0;\\n    int[] visitedSeq; //the sequence number of nth person in a cycle ;  -1 indicates ith person already in a formed chain  \\n    List<int>[] favoriteBy;\\n    HashSet<int> pairedFav;\\n    public int MaximumInvitations(int[] favorite) {\\n        visitedSeq = new int[favorite.Length];\\n        favoriteBy = new List<int> [favorite.Length];\\n        pairedFav = new HashSet<int>();\\n        for(var i=0; i<favorite.Length; i++)\\n        {\\n            if(favoriteBy[favorite[i]]==null)\\n                favoriteBy[favorite[i]] = new List<int>();\\n            favoriteBy[favorite[i]].Add(i);\\n            \\n            if(i==favorite[favorite[i]])\\n            {\\n                pairedFav.Add(favorite[i]);\\n                pairedFav.Add(favorite[favorite[i]]);\\n            }         \\n        }\\n            \\n        var chainLen = 0;\\n        foreach(var n in pairedFav)\\n        {\\n            var q = new Queue<int>();\\n             q.Enqueue(n);\\n                var armLen = BfsGetChainLength(q, favoriteBy); \\n                chainLen += armLen;         \\n        }\\n        \\n         \\n        for(var i=0; i<favorite.Length; i++)\\n        {\\n            if(visitedSeq[i]==0){\\n                var cycleLen = DfsGetMaxCycleLength(i, 0, favorite);  \\n                maxCycleLen =  Math.Max(maxCycleLen, cycleLen);                \\n            }\\n        }\\n        return Math.Max(maxCycleLen, chainLen);\\n    }\\n    private int BfsGetChainLength(Queue<int> q,  List<int>[] favoriteBy)\\n    {\\n        var chainLen = 0;\\n        while(q.Any())\\n        {\\n            var size = q.Count;\\n            for(int i=0; i<size; i++)\\n            {\\n                var n = q.Dequeue();\\n                visitedSeq[n] = chainLen;\\n                if(favoriteBy[n]!=null)\\n                {\\n                    foreach(var nb in favoriteBy[n])\\n                    {\\n                        if(!pairedFav.Contains(nb))\\n                        q.Enqueue(nb);\\n                    }\\n                }  \\n            }\\n            chainLen++;\\n        }\\n        return chainLen;\\n    }\\n    private int DfsGetMaxCycleLength(int n, int depth, int[] favorite)\\n    {\\n        if(visitedSeq[n]>0){\\n            var cycleLen = depth-visitedSeq[n];\\n            maxCycleLen = Math.Max(maxCycleLen, cycleLen);\\n        }\\n        else{\\n            visitedSeq[n] = depth;\\n            DfsGetMaxCycleLength(favorite[n], depth+1, favorite);\\n            visitedSeq[n] = -1;\\n        }\\n        return maxCycleLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    int maxCycleLen = 0;\\n    int[] visitedSeq; //the sequence number of nth person in a cycle ;  -1 indicates ith person already in a formed chain  \\n    List<int>[] favoriteBy;\\n    HashSet<int> pairedFav;\\n    public int MaximumInvitations(int[] favorite) {\\n        visitedSeq = new int[favorite.Length];\\n        favoriteBy = new List<int> [favorite.Length];\\n        pairedFav = new HashSet<int>();\\n        for(var i=0; i<favorite.Length; i++)\\n        {\\n            if(favoriteBy[favorite[i]]==null)\\n                favoriteBy[favorite[i]] = new List<int>();\\n            favoriteBy[favorite[i]].Add(i);\\n            \\n            if(i==favorite[favorite[i]])\\n            {\\n                pairedFav.Add(favorite[i]);\\n                pairedFav.Add(favorite[favorite[i]]);\\n            }         \\n        }\\n            \\n        var chainLen = 0;\\n        foreach(var n in pairedFav)\\n        {\\n            var q = new Queue<int>();\\n             q.Enqueue(n);\\n                var armLen = BfsGetChainLength(q, favoriteBy); \\n                chainLen += armLen;         \\n        }\\n        \\n         \\n        for(var i=0; i<favorite.Length; i++)\\n        {\\n            if(visitedSeq[i]==0){\\n                var cycleLen = DfsGetMaxCycleLength(i, 0, favorite);  \\n                maxCycleLen =  Math.Max(maxCycleLen, cycleLen);                \\n            }\\n        }\\n        return Math.Max(maxCycleLen, chainLen);\\n    }\\n    private int BfsGetChainLength(Queue<int> q,  List<int>[] favoriteBy)\\n    {\\n        var chainLen = 0;\\n        while(q.Any())\\n        {\\n            var size = q.Count;\\n            for(int i=0; i<size; i++)\\n            {\\n                var n = q.Dequeue();\\n                visitedSeq[n] = chainLen;\\n                if(favoriteBy[n]!=null)\\n                {\\n                    foreach(var nb in favoriteBy[n])\\n                    {\\n                        if(!pairedFav.Contains(nb))\\n                        q.Enqueue(nb);\\n                    }\\n                }  \\n            }\\n            chainLen++;\\n        }\\n        return chainLen;\\n    }\\n    private int DfsGetMaxCycleLength(int n, int depth, int[] favorite)\\n    {\\n        if(visitedSeq[n]>0){\\n            var cycleLen = depth-visitedSeq[n];\\n            maxCycleLen = Math.Max(maxCycleLen, cycleLen);\\n        }\\n        else{\\n            visitedSeq[n] = depth;\\n            DfsGetMaxCycleLength(favorite[n], depth+1, favorite);\\n            visitedSeq[n] = -1;\\n        }\\n        return maxCycleLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663427,
                "title": "c-2127-maximum-employees-to-be-invited-to-a-meeting",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size(); \\n        vector<vector<int>> graph(n); \\n        for (int i = 0; i < n; ++i) graph[favorite[i]].push_back(i); \\n        \\n        auto fn = [&](int x, unordered_set<int> seen) {\\n            int ans = 0; \\n            deque<int> q; q.push_back(x); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    int u = q.front(); q.pop_front(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen.count(v)) {\\n                            seen.insert(v); \\n                            q.push_back(v); \\n                        }\\n                }\\n            return ans; \\n        }; \\n        \\n        int ans = 0; \\n        vector<bool> seen(n); \\n        for (int i = 0; i < n; ++i) \\n            if (favorite[favorite[i]] == i && !seen[i]) {\\n                seen[i] = seen[favorite[i]] = true; \\n                ans += fn(i, {i, favorite[i]}) + fn(favorite[i], {i, favorite[i]}); \\n            }\\n        \\n        vector<int> dp(n); \\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == 0) {\\n                bool found = false; \\n                int ii = i, val = 0, cycle = 0; \\n                unordered_map<int, int> memo; \\n                for (; !memo.count(ii); ++val, ii = favorite[ii]) {\\n                    if (dp[ii]) {cycle = dp[ii]; found = true; break; }\\n                    memo[ii] = val; \\n                }\\n                if (!found) cycle = val - memo[ii]; \\n                for (auto& [k, v] : memo) dp[k] = cycle; \\n            }\\n        }\\n        return max(ans, *max_element(dp.begin(), dp.end())); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size(); \\n        vector<vector<int>> graph(n); \\n        for (int i = 0; i < n; ++i) graph[favorite[i]].push_back(i); \\n        \\n        auto fn = [&](int x, unordered_set<int> seen) {\\n            int ans = 0; \\n            deque<int> q; q.push_back(x); \\n            for (; q.size(); ++ans) \\n                for (int sz = q.size(); sz; --sz) {\\n                    int u = q.front(); q.pop_front(); \\n                    for (auto& v : graph[u]) \\n                        if (!seen.count(v)) {\\n                            seen.insert(v); \\n                            q.push_back(v); \\n                        }\\n                }\\n            return ans; \\n        }; \\n        \\n        int ans = 0; \\n        vector<bool> seen(n); \\n        for (int i = 0; i < n; ++i) \\n            if (favorite[favorite[i]] == i && !seen[i]) {\\n                seen[i] = seen[favorite[i]] = true; \\n                ans += fn(i, {i, favorite[i]}) + fn(favorite[i], {i, favorite[i]}); \\n            }\\n        \\n        vector<int> dp(n); \\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] == 0) {\\n                bool found = false; \\n                int ii = i, val = 0, cycle = 0; \\n                unordered_map<int, int> memo; \\n                for (; !memo.count(ii); ++val, ii = favorite[ii]) {\\n                    if (dp[ii]) {cycle = dp[ii]; found = true; break; }\\n                    memo[ii] = val; \\n                }\\n                if (!found) cycle = val - memo[ii]; \\n                for (auto& [k, v] : memo) dp[k] = cycle; \\n            }\\n        }\\n        return max(ans, *max_element(dp.begin(), dp.end())); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663165,
                "title": "detect-a-cycle-in-a-directed-graph",
                "content": "For any directed graph, is it possible to detect all cycles in polynomial time?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1663014,
                "title": "c-max-largest-cycle-sum-wing-shape-size",
                "content": "It is not possible to let a single direction linked list to stay in the table since the last node will not be satisfied. So there has to be some cycle. When the cycle is larger than size 2, we have to put the entire cycle into the table and no other person can join further. If the cycle is of size 2, then we can consider another form: each node can go back to find a longest chain it can find (a wing shape). Furthermore, we can allow multiple such wing-shape into the table.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> ind(n);\\n        vector<vector<int>> rev(n);\\n        unordered_map<int, int> pairs;\\n        for (int i = 0; i < n; ++i) {\\n            ++ind[favorite[i]];\\n            rev[favorite[i]].emplace_back(i);\\n            if (i == favorite[favorite[i]]) {\\n                pairs[min(i, favorite[i])] = max(i, favorite[i]);\\n            }\\n        }\\n        queue<int> q;\\n        unordered_set<int> ext;\\n        for (int i = 0; i < n; ++i) {\\n            if (ind[i] == 0) {\\n                q.emplace(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int t = q.front(); q.pop();\\n            ext.emplace(t);\\n            if (--ind[favorite[t]] == 0) {\\n                q.emplace(favorite[t]);\\n            }\\n        }\\n        vector<int> tags(n, 0);\\n        int circle = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!ext.count(i)) {\\n                circle = max(circle, dfs1(i, favorite, tags, 1));\\n            }\\n        }\\n        int chain = 0;\\n        for (auto [left, right] : pairs) {\\n            int one = dfs2(rev, left, left, right);\\n            int two = dfs2(rev, right, right, left);\\n            chain += one + two;\\n        }\\n        return max(circle, chain);\\n    }\\n\\nprivate:\\n    int dfs1(int i, vector<int>& favorite, vector<int>& tags, int tag) {\\n        int ans = 0;\\n        tags[i] = tag;\\n        if (tags[favorite[i]]) {\\n            ans = tag - (tags[favorite[i]] - 1);\\n        } else {\\n            ans = dfs1(favorite[i], favorite, tags, tag + 1);\\n        }\\n        return ans;\\n    }\\n    int dfs2(vector<vector<int>>& rev, int curr, int f1, int f2) {\\n        int ans = 1;\\n        for (int neighbor : rev[curr]) {\\n            if (curr != f1 || neighbor != f2) {\\n                ans = max(ans, 1 + dfs2(rev, neighbor, f1, f2));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n = favorite.size();\\n        vector<int> ind(n);\\n        vector<vector<int>> rev(n);\\n        unordered_map<int, int> pairs;\\n        for (int i = 0; i < n; ++i) {\\n            ++ind[favorite[i]];\\n            rev[favorite[i]].emplace_back(i);\\n            if (i == favorite[favorite[i]]) {\\n                pairs[min(i, favorite[i])] = max(i, favorite[i]);\\n            }\\n        }\\n        queue<int> q;\\n        unordered_set<int> ext;\\n        for (int i = 0; i < n; ++i) {\\n            if (ind[i] == 0) {\\n                q.emplace(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int t = q.front(); q.pop();\\n            ext.emplace(t);\\n            if (--ind[favorite[t]] == 0) {\\n                q.emplace(favorite[t]);\\n            }\\n        }\\n        vector<int> tags(n, 0);\\n        int circle = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (!ext.count(i)) {\\n                circle = max(circle, dfs1(i, favorite, tags, 1));\\n            }\\n        }\\n        int chain = 0;\\n        for (auto [left, right] : pairs) {\\n            int one = dfs2(rev, left, left, right);\\n            int two = dfs2(rev, right, right, left);\\n            chain += one + two;\\n        }\\n        return max(circle, chain);\\n    }\\n\\nprivate:\\n    int dfs1(int i, vector<int>& favorite, vector<int>& tags, int tag) {\\n        int ans = 0;\\n        tags[i] = tag;\\n        if (tags[favorite[i]]) {\\n            ans = tag - (tags[favorite[i]] - 1);\\n        } else {\\n            ans = dfs1(favorite[i], favorite, tags, tag + 1);\\n        }\\n        return ans;\\n    }\\n    int dfs2(vector<vector<int>>& rev, int curr, int f1, int f2) {\\n        int ans = 1;\\n        for (int neighbor : rev[curr]) {\\n            if (curr != f1 || neighbor != f2) {\\n                ans = max(ans, 1 + dfs2(rev, neighbor, f1, f2));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662749,
                "title": "python-bfs-solution-with-comments-time-o-n-space-o-n",
                "content": "Enjoyed this problem.\\n\\n```python\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        n = len(favorite)\\n        # liked_by[j] is the set of all ppl who likes j (worshippers of j)\\n        liked_by = [set() for _ in range(n)]\\n        \\n        # pairs of mutually liked ppl\\n        mutual = set() \\n        \\n        # Constructing the reverse graph liked_by and get mutually like pairs\\n        for i, j in enumerate(favorite):\\n            liked_by[j].add(i)\\n            if favorite[j] == i: mutual.add((min(i,j), max(i,j)))\\n        \\n        seen = set()\\n        def bfs(s):\\n            \"\"\"\\n            Find the longest path from s via the reversing graph\\n            \"\"\"\\n            q = deque([(s, 1)])\\n            seen.add(s)\\n            max_d = 0\\n            while q:\\n                cur, d = q.popleft()\\n                max_d = max(max_d, d)\\n                for i in liked_by[cur]:\\n                    if i not in seen:\\n                        seen.add(i)\\n                        q.append((i, d+1))\\n            \\n            return max_d\\n        \\n        \\n        ans = 0\\n        \\n        # We can stack all paths involving with mutually liked pairs\\n        # Note that for two different pairs, their worshippers do not intersect\\n        for n1, n2 in mutual:\\n            # Ensure that we are not touch the other\\'s worshippers\\n            liked_by[n1].remove(n2)\\n            liked_by[n2].remove(n1)\\n\\t\\t\\t\\n\\t\\t\\t# We extend in both ends as far as possible, via the reverse graph\\n\\t\\t\\t# The total length is the contribution from the path containing this pair and their worshippers\\n\\t\\t\\t\\n            arm1 = bfs(n1)\\n            arm2 = bfs(n2)\\n            ans += arm1 + arm2\\n        \\n        \\n        \\n        def findCircle(s):\\n            \"\"\"Return the length of the circle in the path starting with s\\n               Note that the circle may not include this point s.\\n            \"\"\"\\n            stack = [(s,1)]\\n            visited = {s:1}\\n            seen.add(s)\\n            while stack:\\n                cur, d = stack.pop()\\n                nxt = favorite[cur]\\n                \\n                if nxt in visited:\\n                    return d - visited[nxt] + 1\\n                if nxt in seen: continue\\n                stack.append((nxt, d+1))\\n                visited[nxt] = d+1\\n                seen.add(nxt)\\n            return 0\\n        \\n        \\n        # Compare with the lengths of circles\\n        # Note that circles and the paths from mutually liked pairs do not intersect\\n        for i in range(n):\\n            if i not in seen:\\n                ans = max(ans, findCircle(i))\\n                \\n        return ans\\n                \\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        \\n        n = len(favorite)\\n        # liked_by[j] is the set of all ppl who likes j (worshippers of j)\\n        liked_by = [set() for _ in range(n)]\\n        \\n        # pairs of mutually liked ppl\\n        mutual = set() \\n        \\n        # Constructing the reverse graph liked_by and get mutually like pairs\\n        for i, j in enumerate(favorite):\\n            liked_by[j].add(i)\\n            if favorite[j] == i: mutual.add((min(i,j), max(i,j)))\\n        \\n        seen = set()\\n        def bfs(s):\\n            \"\"\"\\n            Find the longest path from s via the reversing graph\\n            \"\"\"\\n            q = deque([(s, 1)])\\n            seen.add(s)\\n            max_d = 0\\n            while q:\\n                cur, d = q.popleft()\\n                max_d = max(max_d, d)\\n                for i in liked_by[cur]:\\n                    if i not in seen:\\n                        seen.add(i)\\n                        q.append((i, d+1))\\n            \\n            return max_d\\n        \\n        \\n        ans = 0\\n        \\n        # We can stack all paths involving with mutually liked pairs\\n        # Note that for two different pairs, their worshippers do not intersect\\n        for n1, n2 in mutual:\\n            # Ensure that we are not touch the other\\'s worshippers\\n            liked_by[n1].remove(n2)\\n            liked_by[n2].remove(n1)\\n\\t\\t\\t\\n\\t\\t\\t# We extend in both ends as far as possible, via the reverse graph\\n\\t\\t\\t# The total length is the contribution from the path containing this pair and their worshippers\\n\\t\\t\\t\\n            arm1 = bfs(n1)\\n            arm2 = bfs(n2)\\n            ans += arm1 + arm2\\n        \\n        \\n        \\n        def findCircle(s):\\n            \"\"\"Return the length of the circle in the path starting with s\\n               Note that the circle may not include this point s.\\n            \"\"\"\\n            stack = [(s,1)]\\n            visited = {s:1}\\n            seen.add(s)\\n            while stack:\\n                cur, d = stack.pop()\\n                nxt = favorite[cur]\\n                \\n                if nxt in visited:\\n                    return d - visited[nxt] + 1\\n                if nxt in seen: continue\\n                stack.append((nxt, d+1))\\n                visited[nxt] = d+1\\n                seen.add(nxt)\\n            return 0\\n        \\n        \\n        # Compare with the lengths of circles\\n        # Note that circles and the paths from mutually liked pairs do not intersect\\n        for i in range(n):\\n            if i not in seen:\\n                ans = max(ans, findCircle(i))\\n                \\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662179,
                "title": "c-dfs-tree-30-lines",
                "content": "Define i->j, if i goes to the meeting only when j goes. j is the parent node , and i is j\\'s children node.\\n\\ncase 1: two elements forms a cycle 1->3, 3->1, then if 3,1 go to the meeting , thhe children of 3,1 (other than 1,3) can all go to the meeting. The maximum possible is the longest path from root 3,1\\nto their correspoing leaf.\\ncase 2:  a tree with its root pointing to some nodes of its subtree and forms a cycle. In this case,\\nthe answer is the lenght of the cycle.\\nreturn the largest cycle in case 2 or the depth of two trees in case1. \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> child;\\n    unordered_set<int> st;\\n    int ans=0;\\n    int sub(int indx, unordered_set<int>& visit,int level){\\n        int tmp=level;\\n        st.erase(indx);\\n        visit.insert(indx);\\n        for(auto c: child[indx]){\\n\\t\\t   // forms a cycle if c is visited\\n            if(visit.count(c)) {ans= max(ans,level); break;}\\n            else  { if(st.count(c)) {tmp=max(tmp, sub(c,visit,level+1));  }}\\n        }\\n        return tmp;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n=favorite.size(); if(n<=3) return n;\\n        vector<vector<int>> cyc; \\n        child=vector<vector<int>>(n, vector<int>());\\n        for(int i=0;i<n;i++){ \\n         if(favorite[favorite[i]]==i) \\n            {if(favorite[i]<i)cyc.push_back({i, favorite[i]});}\\n         else {st.insert(i); child[favorite[i]].push_back(i);}\\n        }\\n        unordered_set<int> tmp;\\n\\t\\t// case 1\\n        for(auto p:cyc){ ans+=( sub(p[0], tmp,1)+sub(p[1],tmp,1));}\\n\\t\\t// case 2\\n        while(st.size()>0){\\n            int t=*st.begin(); st.erase(t); tmp={};\\n            sub(t,tmp,1);\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> child;\\n    unordered_set<int> st;\\n    int ans=0;\\n    int sub(int indx, unordered_set<int>& visit,int level){\\n        int tmp=level;\\n        st.erase(indx);\\n        visit.insert(indx);\\n        for(auto c: child[indx]){\\n\\t\\t   // forms a cycle if c is visited\\n            if(visit.count(c)) {ans= max(ans,level); break;}\\n            else  { if(st.count(c)) {tmp=max(tmp, sub(c,visit,level+1));  }}\\n        }\\n        return tmp;\\n    }\\n    int maximumInvitations(vector<int>& favorite) {\\n        int n=favorite.size(); if(n<=3) return n;\\n        vector<vector<int>> cyc; \\n        child=vector<vector<int>>(n, vector<int>());\\n        for(int i=0;i<n;i++){ \\n         if(favorite[favorite[i]]==i) \\n            {if(favorite[i]<i)cyc.push_back({i, favorite[i]});}\\n         else {st.insert(i); child[favorite[i]].push_back(i);}\\n        }\\n        unordered_set<int> tmp;\\n\\t\\t// case 1\\n        for(auto p:cyc){ ans+=( sub(p[0], tmp,1)+sub(p[1],tmp,1));}\\n\\t\\t// case 2\\n        while(st.size()>0){\\n            int t=*st.begin(); st.erase(t); tmp={};\\n            sub(t,tmp,1);\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662095,
                "title": "golang",
                "content": "\\nwe need to observe the effects of cycles:\\n\\n1. if a cycle contains just 2 nodes, meaning the nodes are interdependent on each other, a <-> b, any path containing node a and b, are considered valid and harmless to be added to the ans\\n\\n2. the directed cycle is larger than 2 nodes, and no other nodes outside can partake in the table, since they need to be seated next to each other, and one cannot exist without the other.\\n\\nres = max(sum of all case 1, max of case 2)\\n\\nqns i had: what if the path is just a straight path, from head to tail like a linked list. [1,2,3,0]\\nans: not possible, the head, node 0, can only exist if node 1 exists, if node 2 exists, if node 3 exists, if node 0 exists, which is actually case 2 here.\\n\\nAfter understanding this 2 concepts, it just came down to implementation, which was also a challenge in itself, this is just my dfs version, I\\'m sure there are better implementations than this.\\n\\n```\\nfunc maximumInvitations(favorite []int) int {\\n    // our strategy is to consider the 2 cases separately\\n    n := len(favorite)\\n    graph := make([]map[int]bool, n)  // build the reversed graph to traverse in the reversed order\\n    for i, n := range favorite {\\n        if graph[n] == nil {\\n            graph[n] = make(map[int]bool)\\n        }\\n        graph[n][i] = true  // if n exists, i can exist\\n    }\\n    \\n     // find the summation of all case 1s\\n    caseOneVisited := make([]bool, n)\\n    caseOnesCnt := 0\\n    for i := range favorite {\\n        fav := favorite[i]\\n        if graph[i][fav] && graph[fav][i] && !caseOneVisited[i] {  // interdependent and not yet visited\\n            caseOneVisited[i] = true\\n            caseOneVisited[fav] = true // do not need to check for this being true already, because we process i sequentially, if i is not visited, fav must also not be visited yet\\n            caseOnesCnt += dfsOne(graph, &caseOneVisited, i) + dfsOne(graph, &caseOneVisited, fav)\\n        }\\n    }\\n    \\n    // find the max of all case 2s\\n    // as there could be straight paths leading to visited cycles, \\n\\t// we cannot simply check for non zero visited[i] to detect local cycles,\\n\\t// it could result in wrong calculations, so we store an additional value of root, \\n\\t// to ensure that only local cycles are detected and not a mixture of straight path and a previous cycle\\n    visited := make([][]int, n)  // to track local cycles, visited[i] = [root, stepCnt]\\n    caseTwosMax := 0\\n    for i := range favorite {\\n        if visited[i] == nil {\\n            caseTwosMax = max(caseTwosMax, dfsTwo(graph, &visited, i, i, 0))\\n        }\\n    }\\n    \\n    return max(caseTwosMax, caseOnesCnt)\\n}\\n\\nfunc dfsOne(graph []map[int]bool, visited *[]bool, cur int) int {\\n    res := 0\\n    for next := range graph[cur] {\\n        if !(*visited)[next] {\\n            (*visited)[next] = true\\n            res = max(res, dfsOne(graph, visited, next))\\n        }\\n    }\\n    \\n    return res+1\\n}\\n\\n// some important assumptions: each node can only have one directed edge outwards, therefore, there can only ever be a single cycle a path\\nfunc dfsTwo(graph []map[int]bool, visited *[][]int, cur int, root int, step int) int {\\n    (*visited)[cur] = []int{root, step}\\n    for next := range graph[cur] {\\n        if (*visited)[next] != nil && (*visited)[next][0] == root {  // is a local cycle and shares the same root node\\n            return step - (*visited)[next][1] + 1\\n        }\\n        if (*visited)[next] == nil {\\n            if nodesInCycle := dfsTwo(graph, visited, next, root, step+1); nodesInCycle > 0 {\\n                return nodesInCycle\\n            }\\n        }\\n    }\\n    \\n    return 0\\n}\\n\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumInvitations(favorite []int) int {\\n    // our strategy is to consider the 2 cases separately\\n    n := len(favorite)\\n    graph := make([]map[int]bool, n)  // build the reversed graph to traverse in the reversed order\\n    for i, n := range favorite {\\n        if graph[n] == nil {\\n            graph[n] = make(map[int]bool)\\n        }\\n        graph[n][i] = true  // if n exists, i can exist\\n    }\\n    \\n     // find the summation of all case 1s\\n    caseOneVisited := make([]bool, n)\\n    caseOnesCnt := 0\\n    for i := range favorite {\\n        fav := favorite[i]\\n        if graph[i][fav] && graph[fav][i] && !caseOneVisited[i] {  // interdependent and not yet visited\\n            caseOneVisited[i] = true\\n            caseOneVisited[fav] = true // do not need to check for this being true already, because we process i sequentially, if i is not visited, fav must also not be visited yet\\n            caseOnesCnt += dfsOne(graph, &caseOneVisited, i) + dfsOne(graph, &caseOneVisited, fav)\\n        }\\n    }\\n    \\n    // find the max of all case 2s\\n    // as there could be straight paths leading to visited cycles, \\n\\t// we cannot simply check for non zero visited[i] to detect local cycles,\\n\\t// it could result in wrong calculations, so we store an additional value of root, \\n\\t// to ensure that only local cycles are detected and not a mixture of straight path and a previous cycle\\n    visited := make([][]int, n)  // to track local cycles, visited[i] = [root, stepCnt]\\n    caseTwosMax := 0\\n    for i := range favorite {\\n        if visited[i] == nil {\\n            caseTwosMax = max(caseTwosMax, dfsTwo(graph, &visited, i, i, 0))\\n        }\\n    }\\n    \\n    return max(caseTwosMax, caseOnesCnt)\\n}\\n\\nfunc dfsOne(graph []map[int]bool, visited *[]bool, cur int) int {\\n    res := 0\\n    for next := range graph[cur] {\\n        if !(*visited)[next] {\\n            (*visited)[next] = true\\n            res = max(res, dfsOne(graph, visited, next))\\n        }\\n    }\\n    \\n    return res+1\\n}\\n\\n// some important assumptions: each node can only have one directed edge outwards, therefore, there can only ever be a single cycle a path\\nfunc dfsTwo(graph []map[int]bool, visited *[][]int, cur int, root int, step int) int {\\n    (*visited)[cur] = []int{root, step}\\n    for next := range graph[cur] {\\n        if (*visited)[next] != nil && (*visited)[next][0] == root {  // is a local cycle and shares the same root node\\n            return step - (*visited)[next][1] + 1\\n        }\\n        if (*visited)[next] == nil {\\n            if nodesInCycle := dfsTwo(graph, visited, next, root, step+1); nodesInCycle > 0 {\\n                return nodesInCycle\\n            }\\n        }\\n    }\\n    \\n    return 0\\n}\\n\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661907,
                "title": "short-simple-dfs",
                "content": "dfs returns info[x] = {a, b}\\nb is the length of the link from x to first pair of persons who favors each other (if it doesn\\'t exist, then b = -1).\\na is first person in pair of persons who favors each other.\\nInside dfs we can calculate the circle lengths by the differences of timestamps.\\n\\n\\n```\\nclass Solution {\\n    void dfs(int start, int x, const vector<int> &f, int& now, int& r, vector<vector<int>> &info, vector<int> &p, vector<int> &t) {\\n        if (t[x] >= 0) {\\n            if (t[x] >= start) {\\n                r = max(now - t[x], r);\\n            }\\n            return;\\n        }\\n        t[x] = now++;\\n        const int y = f[x];\\n        if (x == f[y]) {\\n            t[y] = now++;\\n            info[x] = {x, 1};\\n            info[y] = {y, 1};\\n            return;\\n        }\\n        dfs(start, y, f, now, r, info, p, t);\\n        info[x][0] = info[y][0];\\n        if (info[y][1] >= 0) {\\n            info[x][1] = info[y][1] + 1;\\n            p[info[x][0]] = max(p[info[x][0]], info[x][1]);\\n        }\\n    }\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const int n = favorite.size();\\n        vector<vector<int>> info(n, {-1, -1});\\n        vector<int> p(n), t(n, -1);\\n        int r = 0;\\n        for (int now = 0, i = 0; i < n; ++i) {\\n            if (t[i] < 0) {\\n                dfs(now, i, favorite, now, r, info, p, t);\\n            }\\n        }\\n        int may = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i < favorite[i] && favorite[favorite[i]] == i) {\\n                may += p[i] + p[favorite[i]];\\n            }\\n        }\\n        return max(r, may);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(int start, int x, const vector<int> &f, int& now, int& r, vector<vector<int>> &info, vector<int> &p, vector<int> &t) {\\n        if (t[x] >= 0) {\\n            if (t[x] >= start) {\\n                r = max(now - t[x], r);\\n            }\\n            return;\\n        }\\n        t[x] = now++;\\n        const int y = f[x];\\n        if (x == f[y]) {\\n            t[y] = now++;\\n            info[x] = {x, 1};\\n            info[y] = {y, 1};\\n            return;\\n        }\\n        dfs(start, y, f, now, r, info, p, t);\\n        info[x][0] = info[y][0];\\n        if (info[y][1] >= 0) {\\n            info[x][1] = info[y][1] + 1;\\n            p[info[x][0]] = max(p[info[x][0]], info[x][1]);\\n        }\\n    }\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const int n = favorite.size();\\n        vector<vector<int>> info(n, {-1, -1});\\n        vector<int> p(n), t(n, -1);\\n        int r = 0;\\n        for (int now = 0, i = 0; i < n; ++i) {\\n            if (t[i] < 0) {\\n                dfs(now, i, favorite, now, r, info, p, t);\\n            }\\n        }\\n        int may = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (i < favorite[i] && favorite[favorite[i]] == i) {\\n                may += p[i] + p[favorite[i]];\\n            }\\n        }\\n        return max(r, may);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661578,
                "title": "go-dfs-golang-version",
                "content": "[ref](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1660944/C%2B%2B-DFS-with-illustration)\\n```go\\nfunc maximumInvitations(favorite []int) int {\\n\\tn := len(favorite)\\n\\tm := make([]int, n)\\n\\tr := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm[i] = -1\\n\\t\\tif len(r[i]) == 0 {\\n\\t\\t\\tr[i] = make([]int, 0)\\n\\t\\t}\\n\\t\\tr[favorite[i]] = append(r[favorite[i]], i)\\n\\t}\\n\\tvar dfs1 func(x int) int\\n\\tdfs1 = func(x int) int {\\n\\t\\tif m[x] != -1 {\\n\\t\\t\\treturn m[x]\\n\\t\\t}\\n\\t\\tans := 0\\n\\t\\tfor _, y := range r[x] {\\n\\t\\t\\tans = max(ans, dfs1(y))\\n\\t\\t}\\n\\t\\tm[x] = ans + 1\\n\\t\\treturn m[x]\\n\\t}\\n\\tans := 0\\n\\tfree := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif m[i] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif favorite[favorite[i]] == i {\\n\\t\\t\\tm[i] = 0\\n\\t\\t\\tm[favorite[i]] = 0\\n\\t\\t\\ta := 0\\n\\t\\t\\tb := 0\\n\\t\\t\\tfor _, next := range r[i] {\\n\\t\\t\\t\\tif next == favorite[i] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = max(a, dfs1(next))\\n\\t\\t\\t}\\n\\t\\t\\tfor _, next := range r[favorite[i]] {\\n\\t\\t\\t\\tif next == i {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tb = max(b, dfs1(next))\\n\\t\\t\\t}\\n\\t\\t\\tfree += a + b + 2\\n\\t\\t}\\n\\t}\\n\\tvar dfs2 func(u int) (int, int, bool)\\n\\tdfs2 = func(u int) (int, int, bool) {\\n\\t\\tif m[u] != -1 {\\n\\t\\t\\treturn u, m[u], false\\n\\t\\t}\\n\\t\\tm[u] = 0\\n\\t\\tmergerPoint, depth, mergePointMet := dfs2(favorite[u])\\n\\t\\tif mergePointMet {\\n\\t\\t\\tm[u] = 0\\n\\t\\t\\treturn mergerPoint, depth, true\\n\\t\\t}\\n\\t\\tm[u] = 1 + depth\\n\\t\\treturn mergerPoint, m[u], u == mergerPoint\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif m[i] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t_, depth, mergePointMet := dfs2(i)\\n\\t\\tif mergePointMet {\\n\\t\\t\\tans = max(ans, depth)\\n\\t\\t}\\n\\t}\\n\\treturn max(ans, free)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x >= y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc maximumInvitations(favorite []int) int {\\n\\tn := len(favorite)\\n\\tm := make([]int, n)\\n\\tr := make([][]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm[i] = -1\\n\\t\\tif len(r[i]) == 0 {\\n\\t\\t\\tr[i] = make([]int, 0)\\n\\t\\t}\\n\\t\\tr[favorite[i]] = append(r[favorite[i]], i)\\n\\t}\\n\\tvar dfs1 func(x int) int\\n\\tdfs1 = func(x int) int {\\n\\t\\tif m[x] != -1 {\\n\\t\\t\\treturn m[x]\\n\\t\\t}\\n\\t\\tans := 0\\n\\t\\tfor _, y := range r[x] {\\n\\t\\t\\tans = max(ans, dfs1(y))\\n\\t\\t}\\n\\t\\tm[x] = ans + 1\\n\\t\\treturn m[x]\\n\\t}\\n\\tans := 0\\n\\tfree := 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif m[i] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif favorite[favorite[i]] == i {\\n\\t\\t\\tm[i] = 0\\n\\t\\t\\tm[favorite[i]] = 0\\n\\t\\t\\ta := 0\\n\\t\\t\\tb := 0\\n\\t\\t\\tfor _, next := range r[i] {\\n\\t\\t\\t\\tif next == favorite[i] {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ta = max(a, dfs1(next))\\n\\t\\t\\t}\\n\\t\\t\\tfor _, next := range r[favorite[i]] {\\n\\t\\t\\t\\tif next == i {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tb = max(b, dfs1(next))\\n\\t\\t\\t}\\n\\t\\t\\tfree += a + b + 2\\n\\t\\t}\\n\\t}\\n\\tvar dfs2 func(u int) (int, int, bool)\\n\\tdfs2 = func(u int) (int, int, bool) {\\n\\t\\tif m[u] != -1 {\\n\\t\\t\\treturn u, m[u], false\\n\\t\\t}\\n\\t\\tm[u] = 0\\n\\t\\tmergerPoint, depth, mergePointMet := dfs2(favorite[u])\\n\\t\\tif mergePointMet {\\n\\t\\t\\tm[u] = 0\\n\\t\\t\\treturn mergerPoint, depth, true\\n\\t\\t}\\n\\t\\tm[u] = 1 + depth\\n\\t\\treturn mergerPoint, m[u], u == mergerPoint\\n\\t}\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif m[i] != -1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t_, depth, mergePointMet := dfs2(i)\\n\\t\\tif mergePointMet {\\n\\t\\t\\tans = max(ans, depth)\\n\\t\\t}\\n\\t}\\n\\treturn max(ans, free)\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x >= y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661530,
                "title": "c-find-max-tree-depths-in-reversed-forest-and-cycles-in-the-original-chain",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const int num_items = favorite.size();\\n\\n        // Build a forest using the reversed \"favorite\" relations. \\n        std::vector<std::vector<int>> forward_nodes(num_items);\\n        for (int idx = 0; idx < num_items; ++idx) {\\n            forward_nodes[favorite[idx]].push_back(idx);\\n        }\\n\\n        // States shared by both search methods.\\n        enum State {INIT = 0, VISITING, TREE, INVALID, CYCLE};    \\n        std::vector<int> node_state(num_items, State::INIT);        \\n        int max_num_nodes = 0;\\n\\n        // Find chains. \\n        {\\n            struct Record {\\n                int node;\\n                int prefix_len = 0;\\n            };\\n            std::stack<Record> next_nodes;\\n            const auto find_max_length = [&](const int root, const int excluded) -> int {\\n                next_nodes.push(Record{.node = root, .prefix_len = 1});\\n                int max_len = 0;\\n                while (!next_nodes.empty()) {\\n                    auto record = next_nodes.top();\\n                    node_state[record.node] = State::TREE;\\n                    max_len = std::max(record.prefix_len, max_len);\\n                    next_nodes.pop();\\n                    for (const int node : forward_nodes[record.node]) {\\n                        if (node == excluded) {\\n                            continue;\\n                        }\\n                        next_nodes.push(Record{.node = node, .prefix_len = record.prefix_len + 1});\\n                    }\\n                }\\n                return max_len;\\n            };    \\n        \\n            int total_chain_size = 0;            \\n            for (int idx = 0; idx < num_items; ++idx) {\\n                if (node_state[idx] != State::INIT) {\\n                    continue;\\n                }\\n                const int src_root = idx, tgt_root = favorite[idx];\\n                if (favorite[tgt_root] != src_root) {\\n                    continue;\\n                }\\n                const int max_len = find_max_length(src_root, tgt_root) + find_max_length(tgt_root, src_root);\\n                total_chain_size += max_len;\\n            }\\n            max_num_nodes = total_chain_size;\\n        }            \\n        \\n        // Find cycles.\\n        {\\n            std::stack<int> path;\\n            for (int idx_init = 0; idx_init < num_items; ++idx_init) {\\n                if (node_state[idx_init] != State::INIT) {\\n                    continue;\\n                }\\n                int idx = idx_init;\\n                path.push(idx);\\n                node_state[idx] = State::VISITING;\\n                while (true) {\\n                    const int idx_next = favorite[idx];\\n                    if (node_state[idx_next] == State::INIT) {\\n                        node_state[idx_next] = State::VISITING;\\n                        idx = idx_next;\\n                        path.push(idx);                    \\n                        continue;\\n                    }\\n                    if (node_state[idx_next] == State::VISITING) {\\n                        // Found cycle! \\n                        int cycle_cnts = 0;\\n                        while (!path.empty()) {\\n                            const int last = path.top();\\n                            path.pop();\\n                            node_state[last] = State::CYCLE;                        \\n                            ++cycle_cnts;\\n                            if (last == idx_next) {\\n                                break;\\n                            }\\n                        }                    \\n                        max_num_nodes = std::max(cycle_cnts, max_num_nodes);\\n                    }\\n                    break;\\n                }\\n                // Mark the rest of the nodes invalid.\\n                for (; !path.empty(); path.pop()) {\\n                    node_state[path.top()] = State::INVALID;\\n                }\\n            }\\n        }\\n        return max_num_nodes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumInvitations(vector<int>& favorite) {\\n        const int num_items = favorite.size();\\n\\n        // Build a forest using the reversed \"favorite\" relations. \\n        std::vector<std::vector<int>> forward_nodes(num_items);\\n        for (int idx = 0; idx < num_items; ++idx) {\\n            forward_nodes[favorite[idx]].push_back(idx);\\n        }\\n\\n        // States shared by both search methods.\\n        enum State {INIT = 0, VISITING, TREE, INVALID, CYCLE};    \\n        std::vector<int> node_state(num_items, State::INIT);        \\n        int max_num_nodes = 0;\\n\\n        // Find chains. \\n        {\\n            struct Record {\\n                int node;\\n                int prefix_len = 0;\\n            };\\n            std::stack<Record> next_nodes;\\n            const auto find_max_length = [&](const int root, const int excluded) -> int {\\n                next_nodes.push(Record{.node = root, .prefix_len = 1});\\n                int max_len = 0;\\n                while (!next_nodes.empty()) {\\n                    auto record = next_nodes.top();\\n                    node_state[record.node] = State::TREE;\\n                    max_len = std::max(record.prefix_len, max_len);\\n                    next_nodes.pop();\\n                    for (const int node : forward_nodes[record.node]) {\\n                        if (node == excluded) {\\n                            continue;\\n                        }\\n                        next_nodes.push(Record{.node = node, .prefix_len = record.prefix_len + 1});\\n                    }\\n                }\\n                return max_len;\\n            };    \\n        \\n            int total_chain_size = 0;            \\n            for (int idx = 0; idx < num_items; ++idx) {\\n                if (node_state[idx] != State::INIT) {\\n                    continue;\\n                }\\n                const int src_root = idx, tgt_root = favorite[idx];\\n                if (favorite[tgt_root] != src_root) {\\n                    continue;\\n                }\\n                const int max_len = find_max_length(src_root, tgt_root) + find_max_length(tgt_root, src_root);\\n                total_chain_size += max_len;\\n            }\\n            max_num_nodes = total_chain_size;\\n        }            \\n        \\n        // Find cycles.\\n        {\\n            std::stack<int> path;\\n            for (int idx_init = 0; idx_init < num_items; ++idx_init) {\\n                if (node_state[idx_init] != State::INIT) {\\n                    continue;\\n                }\\n                int idx = idx_init;\\n                path.push(idx);\\n                node_state[idx] = State::VISITING;\\n                while (true) {\\n                    const int idx_next = favorite[idx];\\n                    if (node_state[idx_next] == State::INIT) {\\n                        node_state[idx_next] = State::VISITING;\\n                        idx = idx_next;\\n                        path.push(idx);                    \\n                        continue;\\n                    }\\n                    if (node_state[idx_next] == State::VISITING) {\\n                        // Found cycle! \\n                        int cycle_cnts = 0;\\n                        while (!path.empty()) {\\n                            const int last = path.top();\\n                            path.pop();\\n                            node_state[last] = State::CYCLE;                        \\n                            ++cycle_cnts;\\n                            if (last == idx_next) {\\n                                break;\\n                            }\\n                        }                    \\n                        max_num_nodes = std::max(cycle_cnts, max_num_nodes);\\n                    }\\n                    break;\\n                }\\n                // Mark the rest of the nodes invalid.\\n                for (; !path.empty(); path.pop()) {\\n                    node_state[path.top()] = State::INVALID;\\n                }\\n            }\\n        }\\n        return max_num_nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661512,
                "title": "python-dfs-solution",
                "content": "If 2 nodes are pair (depends on each other), we calculate the height of each tree under that node. Part 1 of the answer is the total height of all the trees where root is part of a pair.\\n\\nReason is because the longest chain around a pair has 2 spaces left on the leaves node => we can combine the chains together\\n\\nFor example:\\n(space)1->2<->3<-4(space)\\n(space)5<->6(space)\\nTotal seats => 4 + 2 = 6\\n\\nPart 2 of the answer is the longest cycle, because we can\\'t combine the cycles, we can only take the longest one.\\n\\nFinal answer is max of part 1 vs part 2\\n```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        N = len(favorite)\\n        \\n        roots = set()\\n        graph = defaultdict(list)\\n        chains = {}\\n        for u, v in enumerate(favorite):\\n            # don\\'t add the edge between a root pair\\n            if favorite[v] == u:\\n                roots.add(u)\\n                roots.add(v)\\n            else:\\n                graph[v].append(u) \\n\\n                \\n        # part 1, calculate the total straight chain length where root of the chain is a pair with another root\\n        visited = [False] * N\\n        def getHeight(node): # height of the tree where node is root\\n            ans = 0\\n            for nei in graph[node]:\\n                ans = max(ans, getHeight(nei))\\n            return ans + 1\\n        \\n        chain_ans = 0\\n        for r in roots:\\n            hr = getHeight(r)\\n            chain_ans += hr\\n            \\n        # part 2, calculate the largest cycle, using the remaining unvisited nodes \\n        def dfs(node, stack):\\n            nonlocal ans\\n            if node in stack:\\n                # this node has been visited and it is part of the current stack\\n                ans = max(ans, len(stack) - stack[node])\\n            elif not visited[favorite[node]]: \\n                stack[node] = len(stack)\\n                dfs(favorite[node], stack)\\n            visited[node] = True\\n            \\n        ans = 0\\n        for i in range(N):\\n            if not visited[i]:\\n                dfs(i, {})\\n        \\n        return max(ans, chain_ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        N = len(favorite)\\n        \\n        roots = set()\\n        graph = defaultdict(list)\\n        chains = {}\\n        for u, v in enumerate(favorite):\\n            # don\\'t add the edge between a root pair\\n            if favorite[v] == u:\\n                roots.add(u)\\n                roots.add(v)\\n            else:\\n                graph[v].append(u) \\n\\n                \\n        # part 1, calculate the total straight chain length where root of the chain is a pair with another root\\n        visited = [False] * N\\n        def getHeight(node): # height of the tree where node is root\\n            ans = 0\\n            for nei in graph[node]:\\n                ans = max(ans, getHeight(nei))\\n            return ans + 1\\n        \\n        chain_ans = 0\\n        for r in roots:\\n            hr = getHeight(r)\\n            chain_ans += hr\\n            \\n        # part 2, calculate the largest cycle, using the remaining unvisited nodes \\n        def dfs(node, stack):\\n            nonlocal ans\\n            if node in stack:\\n                # this node has been visited and it is part of the current stack\\n                ans = max(ans, len(stack) - stack[node])\\n            elif not visited[favorite[node]]: \\n                stack[node] = len(stack)\\n                dfs(favorite[node], stack)\\n            visited[node] = True\\n            \\n        ans = 0\\n        for i in range(N):\\n            if not visited[i]:\\n                dfs(i, {})\\n        \\n        return max(ans, chain_ans)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565575,
                "content": [
                    {
                        "username": "Chinemerem",
                        "content": "Unsure whether this is a small mistake or simply a misunderstanding on my part.\\n![image](https://assets.leetcode.com/users/images/b9f6e207-9e32-47c7-b096-34f210b3ac56_1641096449.9260314.png)\\n![image](https://assets.leetcode.com/users/images/c94e566f-a653-4dc6-8601-18a74e46c73d_1641096374.721862.png)\\nShouldn\\'t Employee 2\\'s favorite employee be 1?"
                    },
                    {
                        "username": "Thunder_Storm",
                        "content": "Yeah, it should be favorite employee \"1\" are taken."
                    }
                ]
            }
        ]
    }
]