[
    {
        "title": "Minimum Difference in Sums After Removal of Elements",
        "question_content": "You are given a 0-indexed integer array nums consisting of 3 * n elements.\nYou are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts:\n\n\tThe first n elements belonging to the first part and their sum is sumfirst.\n\tThe next n elements belonging to the second part and their sum is sumsecond.\n\nThe difference in sums of the two parts is denoted as sumfirst - sumsecond.\n\n\tFor example, if sumfirst = 3 and sumsecond = 2, their difference is 1.\n\tSimilarly, if sumfirst = 2 and sumsecond = 3, their difference is -1.\n\nReturn the minimum difference possible between the sums of the two parts after the removal of n elements.\n&nbsp;\nExample 1:\n\nInput: nums = [3,1,2]\nOutput: -1\nExplanation: Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n\nExample 2:\n\nInput: nums = [7,9,5,8,1,3]\nOutput: 1\nExplanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1.\n\n&nbsp;\nConstraints:\n\n\tnums.length == 3 * n\n\t1 <= n <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 1747029,
                "title": "python-explanation-with-pictures-priority-queue",
                "content": "This problem equals to:\\n\\n> Divide the array into two halves with A and B numbers, n <= A, B <= 2n.\\nWe need to pick the smallest n numbers from the first half, and the largest n numbers from the second half.\\n\\nAs shown in the picture below.\\n![image](https://assets.leetcode.com/users/images/c5caa01b-8e13-4f9d-b0fa-9be9594d5714_1644076911.6234968.png)\\n\\n\\n\\\\\\n\\\\\\nWe can build **pre_min** to record the sum of the smallest n numbers within **A[0] to A[i + n]** inclusively.\\n\\nGiven the array below (n = 3) as an example:\\nTo begin with, pre_min[0] = sum(A[:3]).\\n\\n![image](https://assets.leetcode.com/users/images/108ca7ab-0cbc-4ef9-8d8c-52888f0812c0_1644076915.9797654.png)\\n\\n\\n\\\\\\n\\\\\\nNow we want to get the **pre_min[1]**, that is, the sum of the smallest 3 numbers in **A[:4]**. \\n> We can always select the smallest 3 numbers using a priority queue. Whenever we reach a new number, we pop the largest number in the current heap, compare its value with this new number, and push the smaller one in the heap.\\n\\n![image](https://assets.leetcode.com/users/images/65bd8f71-ff07-42c4-af26-a58eb5e66bd2_1644076919.0546885.png)\\n\\n\\\\\\n\\\\\\nSo on so forth. \\n> The numbers **(2, 2, 1(** from A **colored in blue** are the numbers we keep in the current heap.  \\n> Notice that we have popped out **3** and **5** because they are too large comparing with new numbers we have met.\\n\\n![image](https://assets.leetcode.com/users/images/6d9980a7-4e78-41ee-8cde-441a29d4ccf0_1644076922.5862534.png)\\n\\n\\\\\\n\\\\\\nUntil we reach **i = 2\\\\*n - 1** . 7 is also too large comparing with current heap so we don\\'t push it into the heap. \\n\\n![image](https://assets.leetcode.com/users/images/173c3a06-c73c-443d-bfd8-b394afbe6579_1644076926.6529837.png)\\n\\n\\\\\\n\\\\\\nBuild **suf_max** using the same method, but keep **the largest n** numbers in the heap.\\n> Notice that we keep **(7, 3, 6)** in the heap since they are the largest 3 numbers.\\n\\n![image](https://assets.leetcode.com/users/images/257fda3e-9795-4132-baf8-f3fdda4b3ba1_1644076929.915481.png)\\n\\n\\\\\\n\\\\\\nThen we just need to iterate over both **pre_min** and **suf_max** and calculate the smallest difference.\\n> For example:\\n> pre_min[0] stands for: What is the sum of the smallest 3 numbers in A[:3]?\\n> suf_max[0] stands for: What is the sum of the largest 3 numbers in A[3:]?\\n\\n![image](https://assets.leetcode.com/users/images/16c3cdcc-a8f8-4548-ac4d-ded557c62b82_1644076935.017122.png)\\n\\n\\\\\\n\\\\\\n**Python**\\n```\\ndef minimumDifference(self, A: List[int]) -> int:\\n        n = len(A) // 3\\n        \\n        # Build pre_min using min-heap.\\n        pre_min, cur_min = [sum(A[:n])], sum(A[:n])\\n        pre_hp = [-x for x in A[:n]]\\n        heapq.heapify(pre_hp)\\n        for i in range(n, 2 * n):\\n            cur_pop = -heapq.heappop(pre_hp)\\n            cur_min -= cur_pop\\n            cur_min += min(cur_pop, A[i])\\n            pre_min.append(cur_min)\\n            heapq.heappush(pre_hp, -min(cur_pop, A[i]))          \\n        \\n        # Build suf_max.\\n        suf_max, cur_max = [sum(A[2*n:])], sum(A[2*n:])\\n        suf_hp = [x for x in A[2*n:]]\\n        heapq.heapify(suf_hp)        \\n        for i in range(2 * n - 1, n - 1, -1):\\n            cur_pop = heapq.heappop(suf_hp)\\n            cur_max -= cur_pop\\n            cur_max += max(cur_pop, A[i])\\n            suf_max.append(cur_max)\\n            heapq.heappush(suf_hp, max(cur_pop, A[i]))\\n        suf_max = suf_max[::-1]\\n        \\n        # Iterate over pre_min and suf_max and get the minimum difference.\\n        ans = math.inf\\n        for a, b in zip(pre_min, suf_max):\\n            ans = min(ans, a - b)\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumDifference(self, A: List[int]) -> int:\\n        n = len(A) // 3\\n        \\n        # Build pre_min using min-heap.\\n        pre_min, cur_min = [sum(A[:n])], sum(A[:n])\\n        pre_hp = [-x for x in A[:n]]\\n        heapq.heapify(pre_hp)\\n        for i in range(n, 2 * n):\\n            cur_pop = -heapq.heappop(pre_hp)\\n            cur_min -= cur_pop\\n            cur_min += min(cur_pop, A[i])\\n            pre_min.append(cur_min)\\n            heapq.heappush(pre_hp, -min(cur_pop, A[i]))          \\n        \\n        # Build suf_max.\\n        suf_max, cur_max = [sum(A[2*n:])], sum(A[2*n:])\\n        suf_hp = [x for x in A[2*n:]]\\n        heapq.heapify(suf_hp)        \\n        for i in range(2 * n - 1, n - 1, -1):\\n            cur_pop = heapq.heappop(suf_hp)\\n            cur_max -= cur_pop\\n            cur_max += max(cur_pop, A[i])\\n            suf_max.append(cur_max)\\n            heapq.heappush(suf_hp, max(cur_pop, A[i]))\\n        suf_max = suf_max[::-1]\\n        \\n        # Iterate over pre_min and suf_max and get the minimum difference.\\n        ans = math.inf\\n        for a, b in zip(pre_min, suf_max):\\n            ans = min(ans, a - b)\\n        return ans \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746989,
                "title": "c-heap-o-nlogn",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Heap\\n\\nSince we are looking for the minimum difference, we want the sum of the first part as small as possible and right part as great as possible.\\n\\nFor the first part, we can use a Max Heap of size `N` to store the smallest `N` digits in it.\\n\\nWe traverse from left to right. For each `A[i]`, we push it into the heap. If the heap size is greater than `N`, we pop the heap top. In this way, we track the smallest `N` digits and their sum.\\n\\nSimilarly for the right part, but we want the greatest `N` digits.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-71/problems/minimum-difference-in-sums-after-removal-of-elements/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n        priority_queue<int> L; // storing the smallest N digits in the first part\\n        priority_queue<int,vector<int>, greater<>> R; // storing the greatest N digits in the right part\\n        long N = A.size() / 3, left = 0, right = 0, ans = LLONG_MAX;\\n        vector<long> tmp(A.size());\\n        for (int i = A.size() - 1; i >= N; --i) { // calculate the greatest N digits in the right part\\n            R.push(A[i]);\\n            right += A[i];\\n            if (R.size() > N) {\\n                right -= R.top();\\n                R.pop();\\n            }\\n            if (R.size() == N) tmp[i] = right; // `tmp[i]` is the maximum sum of `N` digits in `A[i:]`\\n        }\\n        for (int i = 0; i < A.size() - N; ++i) {\\n            L.push(A[i]);\\n            left += A[i];\\n            if (L.size() > N) {\\n                left -= L.top();\\n                L.pop();\\n            }\\n            if (L.size() == N) ans = min(ans, left - tmp[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-71/problems/minimum-difference-in-sums-after-removal-of-elements/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n        priority_queue<int> L; // storing the smallest N digits in the first part\\n        priority_queue<int,vector<int>, greater<>> R; // storing the greatest N digits in the right part\\n        long N = A.size() / 3, left = 0, right = 0, ans = LLONG_MAX;\\n        vector<long> tmp(A.size());\\n        for (int i = A.size() - 1; i >= N; --i) { // calculate the greatest N digits in the right part\\n            R.push(A[i]);\\n            right += A[i];\\n            if (R.size() > N) {\\n                right -= R.top();\\n                R.pop();\\n            }\\n            if (R.size() == N) tmp[i] = right; // `tmp[i]` is the maximum sum of `N` digits in `A[i:]`\\n        }\\n        for (int i = 0; i < A.size() - N; ++i) {\\n            L.push(A[i]);\\n            left += A[i];\\n            if (L.size() > N) {\\n                left -= L.top();\\n                L.pop();\\n            }\\n            if (L.size() == N) ans = min(ans, left - tmp[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747244,
                "title": "two-heaps-and-temp-array",
                "content": "**Intuition:** we remove largest elements if it affects the first array, and smallest - if the second.\\n\\nWe can split the array into two subarrays at some point `i` (`n <= i <= 2 * n`). We remove `i - n` largest elements from the first subarray, and `2 * n - i` smallest elements from the second subarray. That way, for a given split, we get the smallest possible `sum_first`, and largest possible `sum_second`.\\n\\nHere is the example for `[7,9,5,8,1,3]` test case:\\n\\n![image](https://assets.leetcode.com/users/images/b24ba6d9-508f-42d1-9e93-024aed615bef_1644081448.2273228.png)\\n\\nWe track and return the minimum difference among all these splits. To make it efficient, we use max/min heaps to track smallest/largest numbers, and update `sum_first` and `sum_second`.\\n\\n**C++**\\n```cpp\\nlong long minimumDifference(vector<int>& nums) {\\n    int n = nums.size() / 3;\\n    priority_queue<int> pq_l(begin(nums), begin(nums) + n);\\n    priority_queue<int, vector<int>, greater<int>> pq_r(begin(nums) + 2 * n, end(nums));\\n    long long sum_first = accumulate(begin(nums), begin(nums) + n, 0LL);\\n    long long sum_second = accumulate(begin(nums) + 2 * n, end(nums), 0LL); \\n    vector<long long> diffs(n + 1);\\n    for (int i = n; i <= 2 * n; ++i) {\\n        diffs[i - n] = sum_first;\\n        if (pq_l.top() > nums[i]) {\\n            sum_first += nums[i] - pq_l.top();\\n            pq_l.pop();\\n            pq_l.push(nums[i]);\\n        }\\n    }\\n    for (int i = 2 * n - 1; i >= n - 1; --i) {\\n        diffs[i - n + 1] -= sum_second;\\n        if (pq_r.top() < nums[i]) {\\n            sum_second += nums[i] - pq_r.top();\\n            pq_r.pop();\\n            pq_r.push(nums[i]);\\n        }\\n    }\\n    return *min_element(begin(diffs), end(diffs));\\n}\\n```\\n**Complexity Analysys**\\n- Time: O(n log n) for heap operations.\\n- Memory: O(n) for the heaps and temp array.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minimumDifference(vector<int>& nums) {\\n    int n = nums.size() / 3;\\n    priority_queue<int> pq_l(begin(nums), begin(nums) + n);\\n    priority_queue<int, vector<int>, greater<int>> pq_r(begin(nums) + 2 * n, end(nums));\\n    long long sum_first = accumulate(begin(nums), begin(nums) + n, 0LL);\\n    long long sum_second = accumulate(begin(nums) + 2 * n, end(nums), 0LL); \\n    vector<long long> diffs(n + 1);\\n    for (int i = n; i <= 2 * n; ++i) {\\n        diffs[i - n] = sum_first;\\n        if (pq_l.top() > nums[i]) {\\n            sum_first += nums[i] - pq_l.top();\\n            pq_l.pop();\\n            pq_l.push(nums[i]);\\n        }\\n    }\\n    for (int i = 2 * n - 1; i >= n - 1; --i) {\\n        diffs[i - n + 1] -= sum_second;\\n        if (pq_r.top() < nums[i]) {\\n            sum_second += nums[i] - pq_r.top();\\n            pq_r.pop();\\n            pq_r.push(nums[i]);\\n        }\\n    }\\n    return *min_element(begin(diffs), end(diffs));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1746993,
                "title": "python-sortedlist-solution-explained",
                "content": "Let us reformulate this problem: choose index `k in [n, 2n]` and then we need to:\\n1. Choose the `n` smallest element from the `nums[:k]`.\\n2. Choose the `n` biggest elements from the `nums[k:]`.\\n3. Evaluate the difference and update `ans`.\\n\\nNow the question, how to do it efficiently? The answer are heaps or sortedlist. We start with `nums[:n]` and `nums[n:]` sorted lists and do n stepas on each of them we take number from the second list and put it into the first list. Also what we need to so is to update sums of elements.\\n1. When we put `nums[i]` from the right sorted list to left, first we need to find its place in `rgh`. If it is less than `len(rgh) - n`, sum of the biggest `n` values will not change. If it is more or equal, then we need to subtract `nums[i]` from sum and add `rgh[-n-1]` to this sum.\\n2. Similar logic is for the `lft` part, we check if place is `< n` and if it is, umpate sum.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        n = len(nums)//3\\n        lft = SortedList(nums[:n])\\n        rgh = SortedList(nums[n:])\\n        sm1 = sum(lft)\\n        sm2 = sum(rgh[-n:])\\n        ans = sm1 - sm2\\n        for i in range(n, 2*n):  #or 2*n + 1?\\n            idx = rgh.bisect_left(nums[i])\\n            if idx >= len(rgh) - n:   #\\n                sm2 -= nums[i]\\n                sm2 += rgh[-n-1]\\n            idx2 = lft.bisect_left(nums[i])\\n            if idx2 < n:\\n                sm1 += nums[i]\\n                sm1 -= lft[n-1]\\n\\n            rgh.discard(nums[i])\\n            lft.add(nums[i])\\n            ans = min(ans, sm1 - sm2)\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        n = len(nums)//3\\n        lft = SortedList(nums[:n])\\n        rgh = SortedList(nums[n:])\\n        sm1 = sum(lft)\\n        sm2 = sum(rgh[-n:])\\n        ans = sm1 - sm2\\n        for i in range(n, 2*n):  #or 2*n + 1?\\n            idx = rgh.bisect_left(nums[i])\\n            if idx >= len(rgh) - n:   #\\n                sm2 -= nums[i]\\n                sm2 += rgh[-n-1]\\n            idx2 = lft.bisect_left(nums[i])\\n            if idx2 < n:\\n                sm1 += nums[i]\\n                sm1 -= lft[n-1]\\n\\n            rgh.discard(nums[i])\\n            lft.add(nums[i])\\n            ans = min(ans, sm1 - sm2)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747003,
                "title": "python-o-nlogn-priority-queue-with-detailed-explanation",
                "content": "By observation. You can split array into 3 parts, each have size `N`\\n\\npart1: range [0 ~ N): blue\\npart2: range [N ~ 2 * N): orange\\npart3: range [2 * N ~ 3 * N): green\\n\\n![image](https://assets.leetcode.com/users/images/42e00dc7-76b1-4b5d-be92-fb4d6af8b719_1644077235.185129.png)\\n\\nAnd we should find a pivot inside the range of part2, and we can choose `N` numbers before `pivot` (includes part1) as `left_part`, and we want it to be minimum. At the same time, we can choose `N` numbers after `pivot` (includes part3) as `right_part`, and we want it to be maximum.\\n\\nHow can we do this?\\n\\nWe can create two priority queues for `left_part` (max heap) and `right_part` (min heap).\\n\\nFor the `left_part`, we just keep moving the pivot position inside part2, and keep popping out the largest number in `left_part` while replacing. Meanwhile, we keep recording the minimum possible sum of `left_part` at each pivot position in `min_left_part` array. And the `right_part` is the same.\\n\\nIn the end, we just find out which pivot position `i` can give us the minimum `min_left_part[i] - max_right_part[i]` value. (Notice: You will need to do some fine tune of the index for `min_left_part` and `max_right_part`) \\n\\nBelow is my python code\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums)//3 \\n        \\n        left_part = [-n for n in nums[0:N]]\\n        right_part = nums[-N:]\\n        heapq.heapify(left_part)\\n        heapq.heapify(right_part)\\n        \\n        min_left_part = [0] * (N+1)\\n        max_right_part = [0] * (N+1)\\n        min_left_part[0] = -sum(left_part)\\n        max_right_part[-1] = sum(right_part)\\n\\n        for i in range(1, N+1):\\n            n = nums[N+i-1]\\n            heapq.heappush(left_part, -n)\\n            pn = -heapq.heappop(left_part)\\n            min_left_part[i] = min_left_part[i-1] + (n - pn)\\n            \\n        for i in range(N-1, -1, -1):\\n            n = nums[N+i]\\n            heapq.heappush(right_part, n)\\n            pn = heapq.heappop(right_part)\\n            max_right_part[i] = max_right_part[i+1] + (n - pn)\\n        \\n        ans = inf\\n        for i in range(N+1):\\n            ans = min(ans, min_left_part[i] - max_right_part[i])\\n        return ans\\n\\n```\\n\\nHope it helps :)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums)//3 \\n        \\n        left_part = [-n for n in nums[0:N]]\\n        right_part = nums[-N:]\\n        heapq.heapify(left_part)\\n        heapq.heapify(right_part)\\n        \\n        min_left_part = [0] * (N+1)\\n        max_right_part = [0] * (N+1)\\n        min_left_part[0] = -sum(left_part)\\n        max_right_part[-1] = sum(right_part)\\n\\n        for i in range(1, N+1):\\n            n = nums[N+i-1]\\n            heapq.heappush(left_part, -n)\\n            pn = -heapq.heappop(left_part)\\n            min_left_part[i] = min_left_part[i-1] + (n - pn)\\n            \\n        for i in range(N-1, -1, -1):\\n            n = nums[N+i]\\n            heapq.heappush(right_part, n)\\n            pn = heapq.heappop(right_part)\\n            max_right_part[i] = max_right_part[i+1] + (n - pn)\\n        \\n        ans = inf\\n        for i in range(N+1):\\n            ans = min(ans, min_left_part[i] - max_right_part[i])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747033,
                "title": "java-easy-to-understand-solution-using-priority-queues",
                "content": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> b - a);\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        long[] minLeft = new long[3 * n];\\n        \\n        long leftSum = 0;\\n        long rightSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            leftSum += nums[i];\\n            left.add(nums[i]);\\n        }\\n        \\n        minLeft[n-1] = leftSum;\\n        \\n        for (int i = n; i < 2 * n; i++) {\\n            leftSum += nums[i];\\n            left.add(nums[i]);\\n            leftSum -= left.poll();\\n            minLeft[i] = leftSum;\\n        }\\n        \\n        for (int i = 3 * n - 1; i >= 2 * n; i--) {\\n            rightSum += nums[i];\\n            right.add(nums[i]);\\n        }\\n        \\n        long res = minLeft[2 * n - 1] - rightSum;\\n        \\n        for (int i = 2 * n - 1; i >= n; i--) {\\n            rightSum += nums[i];\\n            right.add(nums[i]);\\n            rightSum -= right.poll();\\n            res = Math.min(res, minLeft[i - 1] - rightSum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> left = new PriorityQueue<>((a, b) -> b - a);\\n        PriorityQueue<Integer> right = new PriorityQueue<>();\\n        long[] minLeft = new long[3 * n];\\n        \\n        long leftSum = 0;\\n        long rightSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            leftSum += nums[i];\\n            left.add(nums[i]);\\n        }\\n        \\n        minLeft[n-1] = leftSum;\\n        \\n        for (int i = n; i < 2 * n; i++) {\\n            leftSum += nums[i];\\n            left.add(nums[i]);\\n            leftSum -= left.poll();\\n            minLeft[i] = leftSum;\\n        }\\n        \\n        for (int i = 3 * n - 1; i >= 2 * n; i--) {\\n            rightSum += nums[i];\\n            right.add(nums[i]);\\n        }\\n        \\n        long res = minLeft[2 * n - 1] - rightSum;\\n        \\n        for (int i = 2 * n - 1; i >= n; i--) {\\n            rightSum += nums[i];\\n            right.add(nums[i]);\\n            rightSum -= right.poll();\\n            res = Math.min(res, minLeft[i - 1] - rightSum);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747611,
                "title": "c-explained-using-priority-queue-beats-92",
                "content": "**Intuition:**\\nIn this problem, we need to remove exactly n elements out of the total 3*n elements and then divide the array into two equal parts and return the minimum difference of the sum of elements of both the arrays. \\n\\nWe need to remove larger elements from the first array and smaller elements from the second array to minimize the difference.\\n\\nWe can split the array into two subarrays at some point i (n <= i <= 2 * n). We remove i - n largest elements from the first subarray, and 2 * n - i smallest elements from the second subarray. That way, for a given split, we get the smallest possible sum_first, and largest possible sum_second.\\n\\nWe have used max and min heap to keep track of the largest and smallest elements, respectively. And update the difference.\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        priority_queue<int> pq;\\n        map<int, long long> m;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            pq.push(nums[i]);\\n        }\\n        for(int i=0;i<=n;i++){\\n            if(i == 0){\\n                m[i] = sum;\\n            }\\n            else{\\n                pq.push(nums[n+i-1]);\\n                sum += nums[i+n-1];\\n                sum -= pq.top();\\n                pq.pop();\\n                m[i] = sum;\\n            }\\n        }\\n        sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> p;\\n        for(int i=N-1;i>N-1-n;i--){\\n            sum += nums[i];\\n            p.push(nums[i]);\\n        }\\n        for(int i=0;i<=n;i++){\\n            if(i == 0){\\n                m[n-i] -= sum;\\n            }\\n            else{\\n                p.push(nums[N-n-i]);\\n                sum += nums[N-n-i];\\n                sum -= p.top();\\n                p.pop();\\n                m[n-i] -= sum;\\n            }\\n        }\\n        long long ans = 9223372036854775807;\\n        for(auto it : m){\\n            ans = min(ans, it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Complexity Analysys**\\n\\n***Time***: O(n log n) for heap operations.\\n***Memory***: O(n).\\n\\nDo **Upvote** if you think it\\'s useful :)",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        priority_queue<int> pq;\\n        map<int, long long> m;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            pq.push(nums[i]);\\n        }\\n        for(int i=0;i<=n;i++){\\n            if(i == 0){\\n                m[i] = sum;\\n            }\\n            else{\\n                pq.push(nums[n+i-1]);\\n                sum += nums[i+n-1];\\n                sum -= pq.top();\\n                pq.pop();\\n                m[i] = sum;\\n            }\\n        }\\n        sum = 0;\\n        priority_queue<int, vector<int>, greater<int>> p;\\n        for(int i=N-1;i>N-1-n;i--){\\n            sum += nums[i];\\n            p.push(nums[i]);\\n        }\\n        for(int i=0;i<=n;i++){\\n            if(i == 0){\\n                m[n-i] -= sum;\\n            }\\n            else{\\n                p.push(nums[N-n-i]);\\n                sum += nums[N-n-i];\\n                sum -= p.top();\\n                p.pop();\\n                m[n-i] -= sum;\\n            }\\n        }\\n        long long ans = 9223372036854775807;\\n        for(auto it : m){\\n            ans = min(ans, it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302608,
                "title": "c-simple-c-code-min-heap-max-heap-o-nlogn",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> pqmx; //desc\\n        priority_queue<int, vector<int>, greater<int>> pqmn; // asce\\n        int N = nums.size();\\n        int n = N/3;\\n        vector<long long> fn;\\n        long long sumf = 0, sumt = 0;\\n        //cout<< N;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sumf += nums[i];\\n            pqmx.push(nums[i]);\\n            sumt += nums[N-1-i];\\n            pqmn.push(nums[N-1-i]);\\n        }\\n        //cout << sumf << \" \" << sumt;\\n        fn.push_back(sumf);\\n        for(int i = n; i < 2*n; i++)\\n        {\\n            sumf += nums[i];\\n            pqmx.push(nums[i]);\\n            sumf -= pqmx.top();\\n            fn.push_back(sumf);\\n            pqmx.pop();\\n        }\\n        //cout << fn[0] << \" \" << fn[1] << \" \" << fn[2];\\n        int j = fn.size()-1;\\n        long long ans = 1e12;\\n        fn[j] -= sumt;\\n        //cout << sumt;\\n        //cout << nums[2*n];\\n        for(int i = 2*n-1; i >= n; i--)\\n        {\\n            if(fn[j] < ans)\\n                ans = fn[j];\\n            sumt += nums[i];\\n            pqmn.push(nums[i]);\\n            sumt -= pqmn.top();\\n            j--;\\n            fn[j] -= sumt;\\n            pqmn.pop();\\n        }\\n        if(fn[j] < ans)\\n            ans = fn[j];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> pqmx; //desc\\n        priority_queue<int, vector<int>, greater<int>> pqmn; // asce\\n        int N = nums.size();\\n        int n = N/3;\\n        vector<long long> fn;\\n        long long sumf = 0, sumt = 0;\\n        //cout<< N;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sumf += nums[i];\\n            pqmx.push(nums[i]);\\n            sumt += nums[N-1-i];\\n            pqmn.push(nums[N-1-i]);\\n        }\\n        //cout << sumf << \" \" << sumt;\\n        fn.push_back(sumf);\\n        for(int i = n; i < 2*n; i++)\\n        {\\n            sumf += nums[i];\\n            pqmx.push(nums[i]);\\n            sumf -= pqmx.top();\\n            fn.push_back(sumf);\\n            pqmx.pop();\\n        }\\n        //cout << fn[0] << \" \" << fn[1] << \" \" << fn[2];\\n        int j = fn.size()-1;\\n        long long ans = 1e12;\\n        fn[j] -= sumt;\\n        //cout << sumt;\\n        //cout << nums[2*n];\\n        for(int i = 2*n-1; i >= n; i--)\\n        {\\n            if(fn[j] < ans)\\n                ans = fn[j];\\n            sumt += nums[i];\\n            pqmn.push(nums[i]);\\n            sumt -= pqmn.top();\\n            j--;\\n            fn[j] -= sumt;\\n            pqmn.pop();\\n        }\\n        if(fn[j] < ans)\\n            ans = fn[j];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1747587,
                "title": "short-solution-easy-to-understand",
                "content": "```\\n// Time Complexity:- O(nlogn)\\n// Space Complexity:- O(n)\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define inf LONG_LONG_MAX\\n    long long minimumDifference(vector<int>& nums) {\\n        // SumFirst - SumSecond --> minimised\\n        // SumFirst as min as possible\\n        // SumSecond as max as possible\\n        \\n        int n = nums.size(),N = n / 3;\\n        vector<ll> pref(n,inf),suff(n,inf);\\n        \\n        // pref[i] = sum of first N minimum elements from left side\\n        //suff[i] = sum of first N maximum elements from right side\\n        \\n        ll sum = 0;\\n        priority_queue<ll> q;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            q.push(nums[i]);\\n            \\n            // pop out maximum element\\n            if((int)q.size()>N){\\n                sum -= q.top();\\n                q.pop();\\n            }\\n            \\n            if((int)q.size()==N){\\n                pref[i] = sum;\\n            }\\n        }\\n        \\n        sum = 0;\\n        while(!q.empty()){\\n            q.pop();\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            sum += nums[i];\\n            q.push(-nums[i]);\\n            \\n            // pop out minimum element\\n            if((int)q.size()>N){\\n                sum += q.top();\\n                q.pop();\\n            }\\n            \\n            if((int)q.size()==N){\\n                suff[i] = sum;\\n            }\\n        }\\n        \\n        ll ans = inf;\\n        for(int i=0;i<n-1;i++){\\n            if(pref[i]!=inf and suff[i+1]!=inf){\\n                ans = min(ans,pref[i]-suff[i+1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Time Complexity:- O(nlogn)\\n// Space Complexity:- O(n)\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define inf LONG_LONG_MAX\\n    long long minimumDifference(vector<int>& nums) {\\n        // SumFirst - SumSecond --> minimised\\n        // SumFirst as min as possible\\n        // SumSecond as max as possible\\n        \\n        int n = nums.size(),N = n / 3;\\n        vector<ll> pref(n,inf),suff(n,inf);\\n        \\n        // pref[i] = sum of first N minimum elements from left side\\n        //suff[i] = sum of first N maximum elements from right side\\n        \\n        ll sum = 0;\\n        priority_queue<ll> q;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            q.push(nums[i]);\\n            \\n            // pop out maximum element\\n            if((int)q.size()>N){\\n                sum -= q.top();\\n                q.pop();\\n            }\\n            \\n            if((int)q.size()==N){\\n                pref[i] = sum;\\n            }\\n        }\\n        \\n        sum = 0;\\n        while(!q.empty()){\\n            q.pop();\\n        }\\n        \\n        for(int i=n-1;i>=0;i--){\\n            sum += nums[i];\\n            q.push(-nums[i]);\\n            \\n            // pop out minimum element\\n            if((int)q.size()>N){\\n                sum += q.top();\\n                q.pop();\\n            }\\n            \\n            if((int)q.size()==N){\\n                suff[i] = sum;\\n            }\\n        }\\n        \\n        ll ans = inf;\\n        for(int i=0;i<n-1;i++){\\n            if(pref[i]!=inf and suff[i+1]!=inf){\\n                ans = min(ans,pref[i]-suff[i+1]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747338,
                "title": "java-explanation-with-comments",
                "content": "The goal is to compute:\\nMin (first 1/3 length - second 1/3 length) <= Min(first) -Max(second);\\nSo we use two priority queue to track:\\n\\nthe **min** sum(size=1/3 length) of first m elements [0,...m];\\nthe **max** sum(size=1/3 length) after m elements [m,...n-1];\\nm should be beweet 1/3 length and 2/3 length;\\n\\n.\\n````\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n=nums.length;  //length of nums\\n        int len3=n/3;       // 1/3 length\\n        long res=Long.MAX_VALUE; // final result;\\n        //Try to make first part as min as possible;\\n        //first[m] store the value, the min value of the size=len3, from[0,1,..., m];  \\n        long[] first=new long[n]; \\n        //Try to make second part as max as possible;\\n        //second[m] store the value, the max value of the size=len3, from[m,...,n-1];  \\n        long[] second=new long[n];\\n        \\n//--------------------for first part compute -------------------------------------\\n        //Build max heap for first part;\\n        PriorityQueue<Integer> max=new PriorityQueue<Integer>(Comparator.reverseOrder());\\n        \\n        long sum=0;\\n\\n        // Initialize with the first 1/3 n part.\\n        for(int i=0;i<len3;i++){\\n            sum+=nums[i];\\n            max.add(nums[i]);\\n        }\\n        //For the second part between 1/3 ~ 2/3. When we move to next index.\\n        //we keep the sum as total 1/3n size: each time poll the max one and add the new one;\\n        //And we keep tracking the exchange by long[] first;\\n        //\\n        for(int i=len3;i<=2*len3;i++){\\n            first[i]=sum;     //add sum from  1/3\\n            max.add(nums[i]); //put new one in queue;\\n            sum+=nums[i];     //sum + new one;\\n            sum-=max.poll();  //sum - max one;\\n        }\\n//--------------------for second part compute -----------------------\\n        sum=0;\\n        //Build min heap for first part;\\n        PriorityQueue<Integer> min=new PriorityQueue<Integer>();\\n        // Initialize with the last 1/3 n part.\\n        for(int i=0;i<len3;i++){\\n            sum+=nums[n-1-i];\\n            min.add(nums[n-1-i]);\\n        }\\n        //For the second part between 2/3~1/3 When we move to next index:\\n        // we keep update the sum with(+ new element, - min element), and update second;\\n        for(int i=len3;i<=2*len3;i++){\\n            second[n-i]=sum;\\n            min.add(nums[n-1-i]);\\n            sum+=nums[n-1-i];\\n            sum-=min.poll();\\n        }\\n//-----------------compute the final result------------\\n\\n        //find the max value in second part [ i,..., n-1];\\n        //find the min value in first part [0,....,i];\\n        // find the result;\\n        for(int i=len3;i<=2*len3;i++){\\n            res=Math.min(res,first[i]-second[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n````",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "````\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n=nums.length;  //length of nums\\n        int len3=n/3;       // 1/3 length\\n        long res=Long.MAX_VALUE; // final result;\\n        //Try to make first part as min as possible;\\n        //first[m] store the value, the min value of the size=len3, from[0,1,..., m];  \\n        long[] first=new long[n]; \\n        //Try to make second part as max as possible;\\n        //second[m] store the value, the max value of the size=len3, from[m,...,n-1];  \\n        long[] second=new long[n];\\n        \\n//--------------------for first part compute -------------------------------------\\n        //Build max heap for first part;\\n        PriorityQueue<Integer> max=new PriorityQueue<Integer>(Comparator.reverseOrder());\\n        \\n        long sum=0;\\n\\n        // Initialize with the first 1/3 n part.\\n        for(int i=0;i<len3;i++){\\n            sum+=nums[i];\\n            max.add(nums[i]);\\n        }\\n        //For the second part between 1/3 ~ 2/3. When we move to next index.\\n        //we keep the sum as total 1/3n size: each time poll the max one and add the new one;\\n        //And we keep tracking the exchange by long[] first;\\n        //\\n        for(int i=len3;i<=2*len3;i++){\\n            first[i]=sum;     //add sum from  1/3\\n            max.add(nums[i]); //put new one in queue;\\n            sum+=nums[i];     //sum + new one;\\n            sum-=max.poll();  //sum - max one;\\n        }\\n//--------------------for second part compute -----------------------\\n        sum=0;\\n        //Build min heap for first part;\\n        PriorityQueue<Integer> min=new PriorityQueue<Integer>();\\n        // Initialize with the last 1/3 n part.\\n        for(int i=0;i<len3;i++){\\n            sum+=nums[n-1-i];\\n            min.add(nums[n-1-i]);\\n        }\\n        //For the second part between 2/3~1/3 When we move to next index:\\n        // we keep update the sum with(+ new element, - min element), and update second;\\n        for(int i=len3;i<=2*len3;i++){\\n            second[n-i]=sum;\\n            min.add(nums[n-1-i]);\\n            sum+=nums[n-1-i];\\n            sum-=min.poll();\\n        }\\n//-----------------compute the final result------------\\n\\n        //find the max value in second part [ i,..., n-1];\\n        //find the min value in first part [0,....,i];\\n        // find the result;\\n        for(int i=len3;i<=2*len3;i++){\\n            res=Math.min(res,first[i]-second[i]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747005,
                "title": "python3-simple-solution-with-o-nlogn-time-explained",
                "content": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n    n = len(nums) // 3\\n    # two heap queues, we keep n smallest elements in first, and n greatest elements in second\\n    first, second = list(), list()\\n    sum_1, sum_2 = 0, 0\\n\\n    for i in range(n):\\n        heapq.heappush(first, -nums[i])\\n        sum_1 += nums[i]\\n    for i in range(2 * n, 3 * n):\\n        heapq.heappush(second, nums[i])\\n        sum_2 += nums[i]\\n\\n    # divide nums into two parts: nums[:i] & nums[i + 1:]\\n    # i can only be in range(n + 1, 2 * n)\\n    sum_first = [sum_1] # sum_first stores sum of n smallest elements for i in range(n + 1, 2 * n)\\n    sum_second = [sum_2] # sum_second stores sum of n greatest elements for i in range(2 * n - 1, n, -1)\\n\\n    middle = nums[n : 2 * n]\\n    for i in middle:\\n        rep = heapq.heappushpop(first, -i)\\n        sum_1 += i + rep\\n        sum_first.append(sum_1)\\n\\n    for i in middle[::-1]:\\n        rep = heapq.heappushpop(second, i)\\n        sum_2 += i - rep\\n        sum_second.append(sum_2)\\n\\n    # then sum_first[k] & sum_second[n - 1 - k] will be a pair for the same i\\n    return min(i - j for i, j in zip(sum_first, sum_second[::-1]))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n    n = len(nums) // 3\\n    # two heap queues, we keep n smallest elements in first, and n greatest elements in second\\n    first, second = list(), list()\\n    sum_1, sum_2 = 0, 0\\n\\n    for i in range(n):\\n        heapq.heappush(first, -nums[i])\\n        sum_1 += nums[i]\\n    for i in range(2 * n, 3 * n):\\n        heapq.heappush(second, nums[i])\\n        sum_2 += nums[i]\\n\\n    # divide nums into two parts: nums[:i] & nums[i + 1:]\\n    # i can only be in range(n + 1, 2 * n)\\n    sum_first = [sum_1] # sum_first stores sum of n smallest elements for i in range(n + 1, 2 * n)\\n    sum_second = [sum_2] # sum_second stores sum of n greatest elements for i in range(2 * n - 1, n, -1)\\n\\n    middle = nums[n : 2 * n]\\n    for i in middle:\\n        rep = heapq.heappushpop(first, -i)\\n        sum_1 += i + rep\\n        sum_first.append(sum_1)\\n\\n    for i in middle[::-1]:\\n        rep = heapq.heappushpop(second, i)\\n        sum_2 += i - rep\\n        sum_second.append(sum_2)\\n\\n    # then sum_first[k] & sum_second[n - 1 - k] will be a pair for the same i\\n    return min(i - j for i, j in zip(sum_first, sum_second[::-1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1747004,
                "title": "solution-for-c-dp-and-priority-queue",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long minimumDifference(vector<int> &nums)\\n    {\\n        int w = nums.size();\\n        int n = w / 3;\\n        priority_queue<int> q_first;\\n        priority_queue<int, vector<int>, greater<int>> q_last;\\n        long left_sum = 0;\\n        long right_sum = 0;\\n        long long res = 0;\\n        vector<vector<long long>> record(w, vector<long long>(2));\\n        for (int i = 0; i != 2 * n; ++i)\\n        {\\n            left_sum += nums[i];\\n            q_first.push(nums[i]);\\n            if (q_first.size() > n)\\n            {\\n                left_sum -= q_first.top();\\n                q_first.pop();\\n            }\\n            record[i][0] = left_sum;\\n        }\\n        for (int i = w - 1; i != n - 1; --i)\\n        {\\n            right_sum += nums[i];\\n            q_last.push(nums[i]);\\n            if (q_last.size() > n)\\n            {\\n                right_sum -= q_last.top();\\n                q_last.pop();\\n            }\\n            record[i][1] = right_sum;\\n        }\\n        res = record[n - 1][0] - record[n][1];\\n\\n        for (int i = n - 1; i != 2 * n; ++i)\\n        {\\n            res = min(res, record[i][0] - record[i + 1][1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long minimumDifference(vector<int> &nums)\\n    {\\n        int w = nums.size();\\n        int n = w / 3;\\n        priority_queue<int> q_first;\\n        priority_queue<int, vector<int>, greater<int>> q_last;\\n        long left_sum = 0;\\n        long right_sum = 0;\\n        long long res = 0;\\n        vector<vector<long long>> record(w, vector<long long>(2));\\n        for (int i = 0; i != 2 * n; ++i)\\n        {\\n            left_sum += nums[i];\\n            q_first.push(nums[i]);\\n            if (q_first.size() > n)\\n            {\\n                left_sum -= q_first.top();\\n                q_first.pop();\\n            }\\n            record[i][0] = left_sum;\\n        }\\n        for (int i = w - 1; i != n - 1; --i)\\n        {\\n            right_sum += nums[i];\\n            q_last.push(nums[i]);\\n            if (q_last.size() > n)\\n            {\\n                right_sum -= q_last.top();\\n                q_last.pop();\\n            }\\n            record[i][1] = right_sum;\\n        }\\n        res = record[n - 1][0] - record[n][1];\\n\\n        for (int i = n - 1; i != 2 * n; ++i)\\n        {\\n            res = min(res, record[i][0] - record[i + 1][1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746994,
                "title": "java-priorityqueue",
                "content": "```\\npublic long minimumDifference(int[] nums) {\\n        PriorityQueue<Integer> max = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue();\\n        int n = nums.length/3;\\n        long []leftSum = new long[n+1];\\n        long sum = 0;\\n        for(int i=0;i<2*n;i++){\\n            sum += nums[i];\\n            max.add(nums[i]);\\n            if(i >= n-1){\\n                if(i >= n){\\n                    sum -= max.poll();\\n                }\\n                leftSum[i-n+1] = sum;\\n            }\\n        }\\n        long []rightSum = new long[n+1];\\n        sum = 0;\\n        for(int i=3*n-1;i>=n; i--){\\n            sum += nums[i];\\n            min.add(nums[i]);\\n            if(i <= 2*n){\\n                if(i < 2*n){\\n                    sum -= min.poll();\\n                }\\n                rightSum[2*n - i] = sum;\\n            }\\n        }\\n        long ans = Long.MAX_VALUE;\\n        for(int i=0;i<=n;i++){\\n            ans = Math.min(ans, leftSum[i] - rightSum[n-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic long minimumDifference(int[] nums) {\\n        PriorityQueue<Integer> max = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue();\\n        int n = nums.length/3;\\n        long []leftSum = new long[n+1];\\n        long sum = 0;\\n        for(int i=0;i<2*n;i++){\\n            sum += nums[i];\\n            max.add(nums[i]);\\n            if(i >= n-1){\\n                if(i >= n){\\n                    sum -= max.poll();\\n                }\\n                leftSum[i-n+1] = sum;\\n            }\\n        }\\n        long []rightSum = new long[n+1];\\n        sum = 0;\\n        for(int i=3*n-1;i>=n; i--){\\n            sum += nums[i];\\n            min.add(nums[i]);\\n            if(i <= 2*n){\\n                if(i < 2*n){\\n                    sum -= min.poll();\\n                }\\n                rightSum[2*n - i] = sum;\\n            }\\n        }\\n        long ans = Long.MAX_VALUE;\\n        for(int i=0;i<=n;i++){\\n            ans = Math.min(ans, leftSum[i] - rightSum[n-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3155854,
                "title": "80-faster-c-heap-o-nlogn-easy-to-understand",
                "content": "```\\nlong long minimumDifference(vector<int>& nums) {\\n        long long int n = nums.size(),i;\\n        vector<long long int> l(n,0),r(n,0);\\n        priority_queue<long long int> pq1;\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq2;\\n        long long int sum = 0;\\n        for(i = 0; i < n/3*2; i++){\\n            sum += nums[i];\\n            pq1.push(nums[i]);\\n            if(i>=n/3){\\n                sum -= pq1.top();\\n                pq1.pop();\\n            }\\n            l[i] = sum;\\n        }\\n        sum = 0;\\n        for(i = n-1; i>= n/3; i--){\\n            sum += nums[i];\\n            pq2.push(nums[i]);\\n            if(i<n/3*2){\\n                sum -= pq2.top();\\n                pq2.pop();\\n            }\\n            r[i] = sum;\\n        }\\n        // for(auto &i: l){\\n        //     cout<<i<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(auto &i: r){\\n        //     cout<<i<<\" \";\\n        // }\\n        long long int ans = LONG_MAX;\\n        for(i = n/3-1; i<n/3*2; i++){\\n            ans = min(ans,l[i]-r[i+1]);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlong long minimumDifference(vector<int>& nums) {\\n        long long int n = nums.size(),i;\\n        vector<long long int> l(n,0),r(n,0);\\n        priority_queue<long long int> pq1;\\n        priority_queue<long long int,vector<long long int>,greater<long long int>> pq2;\\n        long long int sum = 0;\\n        for(i = 0; i < n/3*2; i++){\\n            sum += nums[i];\\n            pq1.push(nums[i]);\\n            if(i>=n/3){\\n                sum -= pq1.top();\\n                pq1.pop();\\n            }\\n            l[i] = sum;\\n        }\\n        sum = 0;\\n        for(i = n-1; i>= n/3; i--){\\n            sum += nums[i];\\n            pq2.push(nums[i]);\\n            if(i<n/3*2){\\n                sum -= pq2.top();\\n                pq2.pop();\\n            }\\n            r[i] = sum;\\n        }\\n        // for(auto &i: l){\\n        //     cout<<i<<\" \";\\n        // }\\n        // cout<<endl;\\n        // for(auto &i: r){\\n        //     cout<<i<<\" \";\\n        // }\\n        long long int ans = LONG_MAX;\\n        for(i = n/3-1; i<n/3*2; i++){\\n            ans = min(ans,l[i]-r[i+1]);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 1786427,
                "title": "python-explanation-of-clear-and-short-solution",
                "content": "Explanation:\\n\\nFor the minimum difference we need to minimize sumfirst and maximize sumsecond, so large elements of the left side and small elements of the right side should be removed.\\n\\nImagine we do not delete any n first elements, so sumfirst is sum of first n elements, then sumsecond is sum of the n largest elements on right side and remaining n smallest elements are removed. \\n\\nThen we can traverse first n elements of right side and move it to left. As we move elements to left, we need keep only n elements. There are two possible ways how it may affect sumfirst:\\n\\n1) It does not affect, the element will be largest in left side, so we remove it\\n2) It is smaller than current largest, so we remove largest and sum decrease. \\n\\nAs we add element to left it cannot be part of right side and there are two ways how sumsecond may change:\\n\\n1) It was part of n smallest, so the sumsecond remains the same. However, we need to note that the element is not among n smallest anymore. \\n\\n2) It was among n largest, so we need to replace it with largerst of n smallest, the sum decrease in this case. \\n\\nWe will update the difference only if smaller is found.\\n\\nExample:\\n\\n[7,9,5,8,1,3]\\n\\nn here is 2\\n\\nLeft side: 7,9 -> sumfirst 16\\nRight side: 5,8,1,3 -> 5,8 largest and 1,3 smallest(wil be removed) sumsecond 13\\n\\nDifference is 3\\n\\nWe move 5 to left: \\nLeft: 5,7,9 -> 9 removed, 5+7 = 12\\nRight: 8,1,3 -> we removed 5, so next largest  among smallest element is 3 -> 8+3 = 11\\n\\nDifference is 1\\n\\nWe move 8 to left:\\nLeft: 5,7,8 -> we remove 8 as it became largest, sum is 12\\nRight: we removed 8,  so next largest  among smallest element is 1 -> 1+3 = 4\\n\\nDifference is 8\\n\\nMinimum difference is 1. \\n\\nSee the code for more details. Let me know if you have questions.\\n\\nTime O(nlogn)\\nSpace O(n)\\n\\n```\\nfrom heapq import *\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n= len(nums)//3\\n        left = [-i for i in nums[:n]]\\n        heapify(left)\\n        right =sorted(nums[n:])[:n]\\n        first = sum(nums[:n])  \\n        second = sum(nums[n:])-sum(right)\\n        taken = Counter()\\n        res = first-second\\n        for i in nums[n:-n]:\\n            if i<-left[0]:\\n                first= first+heappop(left)+i\\n                heappush(left, -i)\\n            if i>right[-1]:\\n                while taken[right[-1]]>0:\\n                    taken[right[-1]]-=1\\n                    right.pop()\\n                second= second-i+right[-1]\\n                right.pop()\\n            else:\\n                taken[i]+=1\\n            res = min(res, first-second)\\n        return res\\n        \\n```\\n**!!!Please upvote!!!**",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n= len(nums)//3\\n        left = [-i for i in nums[:n]]\\n        heapify(left)\\n        right =sorted(nums[n:])[:n]\\n        first = sum(nums[:n])  \\n        second = sum(nums[n:])-sum(right)\\n        taken = Counter()\\n        res = first-second\\n        for i in nums[n:-n]:\\n            if i<-left[0]:\\n                first= first+heappop(left)+i\\n                heappush(left, -i)\\n            if i>right[-1]:\\n                while taken[right[-1]]>0:\\n                    taken[right[-1]]-=1\\n                    right.pop()\\n                second= second-i+right[-1]\\n                right.pop()\\n            else:\\n                taken[i]+=1\\n            res = min(res, first-second)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747318,
                "title": "using-two-heaps-python",
                "content": "**Logic:**\\n\\nThe subsequence of elements removed simply divides the array into a left and a right seqment .\\nFor the difference of the left and right segement sum to be minimun , the left segment sum has to be minimum possible and the right segment sum should be maximun possible.\\nSo we use Heaps to keep track of the minimun/maximum sum of the left/right segments using top \"K\" elements (where \"K\" is one third of the array size).\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        h=heapq\\n        k=len(nums)//3\\n        min_heap, max_heap, min_sol, max_sol, min_sum, max_sum, sol=[] , [] , [] , [] , 0 , 0, []\\n        h.heapify(max_heap) , h.heapify(min_heap)\\n        for x in nums[:-k]:\\n            h.heappush(min_heap,-x)\\n            min_sum+=x\\n            if len(min_heap)>k: min_sum+=h.heappop(min_heap)\\n            min_sol.append(min_sum)\\n        for x in nums[::-1][:-k]:\\n            h.heappush(max_heap,x)\\n            max_sum+=x\\n            if len(max_heap)>k: max_sum-=h.heappop(max_heap)\\n            max_sol.append(max_sum)\\n        min_sol =min_sol[k-1:]\\n        max_sol=max_sol[k-1:][::-1]\\n        return min( min_value - max_value for min_value , max_value in zip(min_sol,max_sol) )\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        h=heapq\\n        k=len(nums)//3\\n        min_heap, max_heap, min_sol, max_sol, min_sum, max_sum, sol=[] , [] , [] , [] , 0 , 0, []\\n        h.heapify(max_heap) , h.heapify(min_heap)\\n        for x in nums[:-k]:\\n            h.heappush(min_heap,-x)\\n            min_sum+=x\\n            if len(min_heap)>k: min_sum+=h.heappop(min_heap)\\n            min_sol.append(min_sum)\\n        for x in nums[::-1][:-k]:\\n            h.heappush(max_heap,x)\\n            max_sum+=x\\n            if len(max_heap)>k: max_sum-=h.heappop(max_heap)\\n            max_sol.append(max_sum)\\n        min_sol =min_sol[k-1:]\\n        max_sol=max_sol[k-1:][::-1]\\n        return min( min_value - max_value for min_value , max_value in zip(min_sol,max_sol) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747225,
                "title": "c-priorityqueue",
                "content": "```\\npublic class Solution {\\n    public long MinimumDifference(int[] nums) {\\n        PriorityQueue<long,long> left = new PriorityQueue<long,long>();\\n        PriorityQueue<long,long> right = new PriorityQueue<long,long>();\\n        int n = nums.Length/3;\\n       \\n        long[] sumLeft = new long[n+1];\\n        long[] sumRight = new long[n+1];\\n        long tLeft = 0;\\n        long tRight = 0;\\n        for(int i=0;i<n;i++){\\n            tLeft += nums[i];\\n            left.Enqueue(nums[i],-nums[i]);\\n            tRight += nums[nums.Length-1-i];\\n            right.Enqueue(nums[nums.Length-1-i],nums[nums.Length-1-i]);\\n        }\\n        sumLeft[0] = tLeft;\\n        sumRight[0]= tRight;\\n        for(int i=1;i<n+1;i++){            \\n            long t = left.Dequeue();\\n            if(t>nums[n-1+i]){\\n                sumLeft[i] = sumLeft[i-1]-t+nums[n-1+i];\\n                left.Enqueue(nums[n-1+i],-nums[n-1+i]);\\n            }else{\\n                left.Enqueue(t,-t);\\n                sumLeft[i] = sumLeft[i-1];\\n            }\\n                \\n        }\\n         \\n        for(int i=1;i<n+1;i++){            \\n            long t = right.Dequeue();\\n            if(t<nums[2*n-i]){\\n                sumRight[i] = sumRight[i-1]-t+nums[2*n-i];\\n                right.Enqueue(nums[2*n-i],nums[2*n-i]);\\n            }else{\\n                right.Enqueue(t,t);\\n                sumRight[i] = sumRight[i-1];\\n            }\\n        }\\n        long res = sumLeft[0];\\n        for(int i=0;i<n+1;i++)\\n            res = Math.Min(res,sumLeft[i]-sumRight[n-i]);\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long MinimumDifference(int[] nums) {\\n        PriorityQueue<long,long> left = new PriorityQueue<long,long>();\\n        PriorityQueue<long,long> right = new PriorityQueue<long,long>();\\n        int n = nums.Length/3;\\n       \\n        long[] sumLeft = new long[n+1];\\n        long[] sumRight = new long[n+1];\\n        long tLeft = 0;\\n        long tRight = 0;\\n        for(int i=0;i<n;i++){\\n            tLeft += nums[i];\\n            left.Enqueue(nums[i],-nums[i]);\\n            tRight += nums[nums.Length-1-i];\\n            right.Enqueue(nums[nums.Length-1-i],nums[nums.Length-1-i]);\\n        }\\n        sumLeft[0] = tLeft;\\n        sumRight[0]= tRight;\\n        for(int i=1;i<n+1;i++){            \\n            long t = left.Dequeue();\\n            if(t>nums[n-1+i]){\\n                sumLeft[i] = sumLeft[i-1]-t+nums[n-1+i];\\n                left.Enqueue(nums[n-1+i],-nums[n-1+i]);\\n            }else{\\n                left.Enqueue(t,-t);\\n                sumLeft[i] = sumLeft[i-1];\\n            }\\n                \\n        }\\n         \\n        for(int i=1;i<n+1;i++){            \\n            long t = right.Dequeue();\\n            if(t<nums[2*n-i]){\\n                sumRight[i] = sumRight[i-1]-t+nums[2*n-i];\\n                right.Enqueue(nums[2*n-i],nums[2*n-i]);\\n            }else{\\n                right.Enqueue(t,t);\\n                sumRight[i] = sumRight[i-1];\\n            }\\n        }\\n        long res = sumLeft[0];\\n        for(int i=0;i<n+1;i++)\\n            res = Math.Min(res,sumLeft[i]-sumRight[n-i]);\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747020,
                "title": "c-o-nlogn-heap",
                "content": "The question can be converted to <br>\\n&rarr; `first part selected` - `second part selected` <br>\\n&rarr; (`first part sum` - `first_part_unchoose`) - (`second part sum` - `second_part_unchoose`) <br>\\n&rarr; `first part sum` - `second part sum` - `first_part_unchoose` + `second_part_unchoose` <br>\\nuse a divider to split left and right part, suppose left part contains M element then `first_part_unchoose` should contain M-N elements (choose the M-N top largest)\\n\\t\\nto get the minimum, need to maximize `first_part_unchoose` and minimize `second_part_unchoose`\\n\\n`Time Complexity: O(NlogN)`\\n`Space Complexity: O(N)`\\n\\n```cpp\\ntypedef long long int LLI;\\n\\nclass Cmp {\\npublic:\\n    bool operator()(const int &lhs, const int &rhs) {\\n        return lhs > rhs;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size() / 3;\\n        priority_queue<int, vector<int>> maxHeap(nums.begin(), nums.begin() + N);\\n        priority_queue<int, vector<int>, Cmp> minHeap(nums.begin()+2*N, nums.end());\\n        vector<LLI> unFirst(N+1, 0), unSecond(N+1, 0);\\n        \\n        // Precalculate the largest sum of first_part_unchoose\\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=1; i<=N; ++i) {\\n            maxHeap.push(nums[N+i-1]);\\n\\t\\t\\t// calculate the sum of i top largest element\\n            unFirst[i] = unFirst[i-1] + (LLI)maxHeap.top(); \\n            maxHeap.pop();            \\n        }\\n        \\n        // Precalculate the smallest sum of second_part_unchoose\\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=N-1; i>=0; --i) {\\n            minHeap.push(nums[N+i]);\\n\\t\\t\\t// calculate the sum of N-i top smallest element\\n            unSecond[i] = unSecond[i+1] + (LLI)minHeap.top();\\n            minHeap.pop();            \\n        }\\n        \\n        LLI leftSum = accumulate(nums.begin(), nums.begin()+N, 0L);\\n        LLI rightSum = accumulate(nums.begin()+N, nums.end(), 0L);\\n        LLI result = LLONG_MAX;\\n        \\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=0; i<=N; ++i) {\\n            result = min(result, leftSum - rightSum - unFirst[i] + unSecond[i]);\\n            leftSum += nums[N+i];\\n            rightSum -= nums[N+i];\\n        }   \\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\ntypedef long long int LLI;\\n\\nclass Cmp {\\npublic:\\n    bool operator()(const int &lhs, const int &rhs) {\\n        return lhs > rhs;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size() / 3;\\n        priority_queue<int, vector<int>> maxHeap(nums.begin(), nums.begin() + N);\\n        priority_queue<int, vector<int>, Cmp> minHeap(nums.begin()+2*N, nums.end());\\n        vector<LLI> unFirst(N+1, 0), unSecond(N+1, 0);\\n        \\n        // Precalculate the largest sum of first_part_unchoose\\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=1; i<=N; ++i) {\\n            maxHeap.push(nums[N+i-1]);\\n\\t\\t\\t// calculate the sum of i top largest element\\n            unFirst[i] = unFirst[i-1] + (LLI)maxHeap.top(); \\n            maxHeap.pop();            \\n        }\\n        \\n        // Precalculate the smallest sum of second_part_unchoose\\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=N-1; i>=0; --i) {\\n            minHeap.push(nums[N+i]);\\n\\t\\t\\t// calculate the sum of N-i top smallest element\\n            unSecond[i] = unSecond[i+1] + (LLI)minHeap.top();\\n            minHeap.pop();            \\n        }\\n        \\n        LLI leftSum = accumulate(nums.begin(), nums.begin()+N, 0L);\\n        LLI rightSum = accumulate(nums.begin()+N, nums.end(), 0L);\\n        LLI result = LLONG_MAX;\\n        \\n\\t\\t// first part range is [0, N+i-1] second part range is [N+i, end)\\n        for (int i=0; i<=N; ++i) {\\n            result = min(result, leftSum - rightSum - unFirst[i] + unSecond[i]);\\n            leftSum += nums[N+i];\\n            rightSum -= nums[N+i];\\n        }   \\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551550,
                "title": "python-two-heap-solution",
                "content": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n\\tn = len(nums)//3\\n\\tmid = nums[n:2*n]\\n\\n\\tleft = [-k for k in nums[:n]]\\n\\theapify(left)\\n\\tl_sum = [-sum(left)]\\n\\tfor k in mid:\\n\\t\\theappush(left, -k)\\n\\t\\tl_sum.append(l_sum[-1]+k+heappop(left))\\n\\n\\tright = nums[2*n:]\\n\\theapify(right)\\n\\tr_sum = [sum(right)]\\n\\tfor k in mid[::-1]:\\n\\t\\theappush(right, k)            \\n\\t\\tr_sum.append(r_sum[-1]+k-heappop(right))\\n\\tr_sum = r_sum[::-1]\\n\\n\\treturn min(l_sum[i]-r_sum[i] for i in range(n+1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumDifference(self, nums: List[int]) -> int:\\n\\tn = len(nums)//3\\n\\tmid = nums[n:2*n]\\n\\n\\tleft = [-k for k in nums[:n]]\\n\\theapify(left)\\n\\tl_sum = [-sum(left)]\\n\\tfor k in mid:\\n\\t\\theappush(left, -k)\\n\\t\\tl_sum.append(l_sum[-1]+k+heappop(left))\\n\\n\\tright = nums[2*n:]\\n\\theapify(right)\\n\\tr_sum = [sum(right)]\\n\\tfor k in mid[::-1]:\\n\\t\\theappush(right, k)            \\n\\t\\tr_sum.append(r_sum[-1]+k-heappop(right))\\n\\tr_sum = r_sum[::-1]\\n\\n\\treturn min(l_sum[i]-r_sum[i] for i in range(n+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2392142,
                "title": "python-solution-o-nlogn-explained-with-diagram-heap-and-dp-solution",
                "content": "This solution is a combination of dp and heaps.\\nTime: `O(nlogn)`\\n\\n# Explanation:\\n\\nWe can select in first part:\\n* first `n` elements or\\n* min `n` elements from first `n+1` elements\\n* min `n` elements from first `n-2` elements\\n* ...\\n* min `n` elements from first `2n` elements\\n\\n\\nIn other words,\\nwe need to find a partition such that:\\n* `n` minimum-value elements  from `n+x` are in first part and\\n* `n` maximum-value elements from `2n-x` are in second part\\n\\n![image](https://assets.leetcode.com/users/images/5cd46136-013c-4ee1-8296-75bac48bb32a_1659860519.8895957.png)\\n\\n\\nHere,\\n* difference would be minimum when we choose top minimum-value elements in first part and top maximum-value elements in second part\\n* `x` can move from `[0, n]` \\n\\t* when `x` is `0`, we make sure there are `n` elements in first part \\n\\t  (and from `2n` elements in second part -> `n` maximum-value elements will be selected and other `n` will be removed)\\n\\t* when `x` is `n` we make sure there are `n` elements in second part\\n\\nNow, we need `min_sum` for first part and `max_sum` for second part for all `x` values, then we can calculate the minimum difference (note: this is not absolute difference).\\nWe will store these values in respective arrays and later calculate the minimum difference, shown below:\\n\\n![image](https://assets.leetcode.com/users/images/3c499963-a6ba-4946-893d-6548f0d864b3_1659860963.4037814.png)\\n\\nTo calculate `min_sum` we will use `max_heap` to pop out maximum value for each iteration and insert the current element, \\nsimilarly for calculating `max_sum` we will use `min_heap`\\n\\n# Solution\\n\\nSee code below:\\n\\n\\n```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # calculate max_sum using min_heap for second part\\n        min_heap = nums[(2 * n) :]\\n        heapq.heapify(min_heap)\\n\\n        max_sum = [0] * (n + 2)\\n        max_sum[n + 1] = sum(min_heap)\\n        for i in range((2 * n) - 1, n - 1, -1):\\n            # push current\\n            heapq.heappush(min_heap, nums[i])\\n            # popout minimum from heap\\n            val = heapq.heappop(min_heap)\\n            # max_sum for this partition\\n            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]\\n\\n\\n        # calculate min_sum using max_heap for first part\\n        max_heap = [-x for x in nums[:n]]\\n        heapq.heapify(max_heap)\\n\\n        min_sum = [0] * (n + 2)\\n        min_sum[0] = -sum(max_heap)\\n        for i in range(n, (2 * n)):\\n            # push current\\n            heapq.heappush(max_heap, -nums[i])\\n            # popout maximum from heap\\n            val = -heapq.heappop(max_heap)\\n            # min_sum for this partition\\n            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]\\n\\n\\n        # find min difference bw second part (max_sum) and first part (min_sum)\\n        ans = math.inf\\n        for i in range(0, n + 1):\\n            print(i, min_sum[i], max_sum[i])\\n            ans = min((min_sum[i] - max_sum[i + 1]), ans)\\n\\n        return ans\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # calculate max_sum using min_heap for second part\\n        min_heap = nums[(2 * n) :]\\n        heapq.heapify(min_heap)\\n\\n        max_sum = [0] * (n + 2)\\n        max_sum[n + 1] = sum(min_heap)\\n        for i in range((2 * n) - 1, n - 1, -1):\\n            # push current\\n            heapq.heappush(min_heap, nums[i])\\n            # popout minimum from heap\\n            val = heapq.heappop(min_heap)\\n            # max_sum for this partition\\n            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]\\n\\n\\n        # calculate min_sum using max_heap for first part\\n        max_heap = [-x for x in nums[:n]]\\n        heapq.heapify(max_heap)\\n\\n        min_sum = [0] * (n + 2)\\n        min_sum[0] = -sum(max_heap)\\n        for i in range(n, (2 * n)):\\n            # push current\\n            heapq.heappush(max_heap, -nums[i])\\n            # popout maximum from heap\\n            val = -heapq.heappop(max_heap)\\n            # min_sum for this partition\\n            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]\\n\\n\\n        # find min difference bw second part (max_sum) and first part (min_sum)\\n        ans = math.inf\\n        for i in range(0, n + 1):\\n            print(i, min_sum[i], max_sum[i])\\n            ans = min((min_sum[i] - max_sum[i + 1]), ans)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810551,
                "title": "c-heap",
                "content": "![image](https://assets.leetcode.com/users/images/d4eaee81-0fc3-4b95-9cf6-9409031dfc4c_1646157448.829913.png)\\n\\n\\n```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m = nums.size();\\n        int n = m / 3;\\n        \\n        priority_queue<LL> maxHeap;\\n        LL sum = 0;\\n        vector<LL> left;\\n        for (int i = 0; i < m; ++ i)\\n        {\\n            sum += nums[i];\\n            maxHeap.push(nums[i]);\\n            if (maxHeap.size() > n)\\n            {\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            left.push_back(sum);\\n        }\\n        \\n        \\n        priority_queue<LL, vector<LL>, greater<>> minHeap;\\n        sum = 0;\\n        vector<LL> right;\\n        for (int i = m - 1; i >= 0; -- i)\\n        {\\n            sum += nums[i];\\n            minHeap.push(nums[i]);\\n            if (minHeap.size() > n)\\n            {\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            right.push_back(sum);\\n        }\\n        reverse(right.begin(), right.end());\\n        \\n        LL ans = LONG_LONG_MAX;\\n        for (int i = n - 1; i < 2*n; ++ i)\\n        {\\n            ans = min(ans, left[i] - right[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long LL;\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m = nums.size();\\n        int n = m / 3;\\n        \\n        priority_queue<LL> maxHeap;\\n        LL sum = 0;\\n        vector<LL> left;\\n        for (int i = 0; i < m; ++ i)\\n        {\\n            sum += nums[i];\\n            maxHeap.push(nums[i]);\\n            if (maxHeap.size() > n)\\n            {\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            left.push_back(sum);\\n        }\\n        \\n        \\n        priority_queue<LL, vector<LL>, greater<>> minHeap;\\n        sum = 0;\\n        vector<LL> right;\\n        for (int i = m - 1; i >= 0; -- i)\\n        {\\n            sum += nums[i];\\n            minHeap.push(nums[i]);\\n            if (minHeap.size() > n)\\n            {\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            right.push_back(sum);\\n        }\\n        reverse(right.begin(), right.end());\\n        \\n        LL ans = LONG_LONG_MAX;\\n        for (int i = n - 1; i < 2*n; ++ i)\\n        {\\n            ans = min(ans, left[i] - right[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747773,
                "title": "o-n-log-n-easy-to-understand-with-explanation-c-using-priority-queue",
                "content": "We have to make sure sum1-sum2 as minimum, so we have to make sum1 must be as small possible and sum2 as big. Therefore make sure to remove bigger elements in first half and smaller elements in second half for that I created two vectors front and last, fornt[i] is the the sum of first n elements after removing i elements from first half and last[i] is the sum of last n elements after removing i elements. That is simply min(fornt[i],last[n-i]) where i from 0 to n.\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int n=nums.size()/3;\\n        vector<long>front(n+1,0);//0,n removals\\n        long sum=0;\\n        priority_queue<long>pq;\\n        for(int i=0;i<n;i++) {sum+=nums[i];pq.push(nums[i]);}\\n        front[0]=sum;\\n        for(int i=1;i<=n;i++){\\n            pq.push(nums[i+n-1]);\\n            int t=pq.top(); pq.pop();\\n            sum+=nums[i+n-1];\\n            sum-=t;\\n            front[i]=sum;\\n        }\\n        vector<long>last(n+1,0);  sum=0; priority_queue<long,vector<long>,greater<long>>pq1;\\n        for(int i=3*n-1;i>=2*n;i--){\\n            sum+=nums[i];pq1.push(nums[i]);\\n        }\\n        last[0]=sum;\\n        for(int i=2*n-1;i>=n;i--){\\n            pq1.push(nums[i]); int t=pq1.top(); pq1.pop();\\n            sum+=nums[i]; sum-=t;\\n            last[2*n-i]=sum;\\n        }\\n        long mn=LLONG_MAX;\\n        for(int i=0;i<=n;i++){\\n            long t=front[i]-last[n-i];\\n           if(mn>t) mn=t;\\n        }\\n        return mn;\\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int n=nums.size()/3;\\n        vector<long>front(n+1,0);//0,n removals\\n        long sum=0;\\n        priority_queue<long>pq;\\n        for(int i=0;i<n;i++) {sum+=nums[i];pq.push(nums[i]);}",
                "codeTag": "Java"
            },
            {
                "id": 1747206,
                "title": "python-easy-o-nlogn-with-very-detailed-explanation",
                "content": "```python\\nINF = 1 << 60\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        \"\"\"\\n        The idea is that we want to know while at index j, what\\'s the minimum sum of N elements we can get before j and\\n        what\\'s the maximum sum of N elements we can get after j.\\n        We can simply maintain top-K minimum/maximum elements by priority queue. At each index, we update dp table, where\\n        dp[i] means minimum sum of N elements where these elements comes from nums[0...i]. Same thing for maximum sum (we\\n        do it in reverse order.)\\n        Now, we can just scan all index and know the minimum sum of N elements before current inedx and the maximum sum\\n        of N elements after current index. The answer comes from minimum of those candidates.\\n        \"\"\"\\n        \\n        N = len(nums) // 3\\n        leftpq = []  # priority queue to maintain top-K minimum elements\\n        sumv = 0  # current sum of elements inside priority queue\\n        leftdp = [INF for _ in range(len(nums))]  # dp for minimum sum\\n        for i, num in enumerate(nums):\\n            heappush(leftpq, - num)\\n            sumv += num\\n            if len(leftpq) > N:  # maintain its size\\n                sumv -= (- heappop(leftpq))\\n            if len(leftpq) == N:  # update dp table\\n                leftdp[i] = min(leftdp[i - 1], sumv)\\n        \\n        # same thing for the other side\\n        rightpq = []\\n        sumv = 0\\n        rightdp = [- INF for _ in range(len(nums))]\\n        nums.reverse()  # reverse input array, easy for implementation\\n        for i, num in enumerate(nums):\\n            heappush(rightpq, num)\\n            sumv += num\\n            if len(rightpq) > N:\\n                sumv -= heappop(rightpq)\\n            if len(rightpq) == N:\\n                rightdp[i] = max(rightdp[i - 1], sumv)\\n        rightdp.reverse()  # reverse back\\n        \\n        # find answer\\n        ans = INF\\n        for i in range(len(nums) - 1):                  # leftdp[i] is minimum sum from 1...i\\n            ans = min(ans, leftdp[i] - rightdp[i + 1])  # rightdp[i + 1] is maximum sum from i+1...N\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nINF = 1 << 60\\n\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        \"\"\"\\n        The idea is that we want to know while at index j, what\\'s the minimum sum of N elements we can get before j and\\n        what\\'s the maximum sum of N elements we can get after j.\\n        We can simply maintain top-K minimum/maximum elements by priority queue. At each index, we update dp table, where\\n        dp[i] means minimum sum of N elements where these elements comes from nums[0...i]. Same thing for maximum sum (we\\n        do it in reverse order.)\\n        Now, we can just scan all index and know the minimum sum of N elements before current inedx and the maximum sum\\n        of N elements after current index. The answer comes from minimum of those candidates.\\n        \"\"\"\\n        \\n        N = len(nums) // 3\\n        leftpq = []  # priority queue to maintain top-K minimum elements\\n        sumv = 0  # current sum of elements inside priority queue\\n        leftdp = [INF for _ in range(len(nums))]  # dp for minimum sum\\n        for i, num in enumerate(nums):\\n            heappush(leftpq, - num)\\n            sumv += num\\n            if len(leftpq) > N:  # maintain its size\\n                sumv -= (- heappop(leftpq))\\n            if len(leftpq) == N:  # update dp table\\n                leftdp[i] = min(leftdp[i - 1], sumv)\\n        \\n        # same thing for the other side\\n        rightpq = []\\n        sumv = 0\\n        rightdp = [- INF for _ in range(len(nums))]\\n        nums.reverse()  # reverse input array, easy for implementation\\n        for i, num in enumerate(nums):\\n            heappush(rightpq, num)\\n            sumv += num\\n            if len(rightpq) > N:\\n                sumv -= heappop(rightpq)\\n            if len(rightpq) == N:\\n                rightdp[i] = max(rightdp[i - 1], sumv)\\n        rightdp.reverse()  # reverse back\\n        \\n        # find answer\\n        ans = INF\\n        for i in range(len(nums) - 1):                  # leftdp[i] is minimum sum from 1...i\\n            ans = min(ans, leftdp[i] - rightdp[i + 1])  # rightdp[i + 1] is maximum sum from i+1...N\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746991,
                "title": "python-o-n-log-n-solution-with-heap-detailed-explanation",
                "content": "Suppose we have determined the `border` between first part and second part, i.e. the indicies of first part is all smaller than `border` and the ones of second part is all larger than or equal to `border`.\\n\\nTo minimize `sum_first - sum_second`, we need to minimize `sum_first` and maximize `sum_second`. Since the border is determined,\\n`sum_first = sum of the N smallest numbers in nums[:border]` and \\n`sum_second = sum of the N largest numbers in nums[border:]`.\\n\\nTake the second testcase for example:\\n`nums = [7,9 | 5,8,1,3], border = 2`\\n`sum_first = 7 + 9 = 16, sum_second = 8 + 5 = 13, diff = 3`\\n\\n`nums = [7,9,5 | 8,1,3], border = 3`\\n`sum_first = 5 + 7 = 12, sum_second = 8 + 3 = 11, diff = 1`\\n\\n`nums = [7,9,5,8 | 1,3], border = 4`\\n`sum_first = 5 + 7 = 12, sum_second = 3 + 1 = 4, diff = 8`\\n\\nWe can try all possible borders and find the small `diff`. In this testcase, the answer will be `min(3, 1, 8) = 1`.\\n\\n---\\n\\nOptimization:\\n\\nTo calculate the `sum_first` of different `border`, we can use a `Max Heap` to maintain the current N smallest numbers. We also need a `sum_heap` to maintain the current sum of the heap. As the border moves right, we observe a new number, push it into the heap, pop the top from the heap and update the sum of the current heap. The calculation of `sum_second` can be done in a reversed way.\\n\\n---\\n\\nComplexity Analysis:\\nTime: `O(N log N)` for calculation the `sum_first` and `sum_second` of different `border`.\\nSpace: `O(N)`\\n\\n---\\nPython Scripts:\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        L = len(nums)\\n        N = L // 3\\n        \\n        import heapq as hq\\n        \\n        # calculate sum_first of different borders\\n        first = [-n for n in nums[:N]] # negative symbol for max heap\\n        hq.heapify(first)\\n        curr_sum = sum(nums[:N])\\n        sum_firsts = {N: curr_sum}\\n        for i in range(N, L):\\n            hq.heappush(first, -nums[i])\\n            curr_sum += nums[i] + hq.heappop(first) # substract negative = add positive\\n            sum_firsts[i+1] = curr_sum\\n        \\n        \\n        # calculate sum_second of different borders\\n        second = [n for n in nums[-N:]]\\n        hq.heapify(second)\\n        curr_sum = sum(nums[-N:])\\n        sum_seconds = {2 * N : curr_sum}\\n        for i in range(2*N-1, -1, -1):\\n            hq.heappush(second, nums[i])\\n            curr_sum += nums[i] - hq.heappop(second)\\n            sum_seconds[i] = curr_sum\\n        \\n        # calculate diff for every border\\n        ans = math.inf\\n        for i in range(N, N * 2 + 1):\\n            ans = min(ans, sum_firsts[i] - sum_seconds[i])\\n        \\n        \\n        return ans     \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        L = len(nums)\\n        N = L // 3\\n        \\n        import heapq as hq\\n        \\n        # calculate sum_first of different borders\\n        first = [-n for n in nums[:N]] # negative symbol for max heap\\n        hq.heapify(first)\\n        curr_sum = sum(nums[:N])\\n        sum_firsts = {N: curr_sum}\\n        for i in range(N, L):\\n            hq.heappush(first, -nums[i])\\n            curr_sum += nums[i] + hq.heappop(first) # substract negative = add positive\\n            sum_firsts[i+1] = curr_sum\\n        \\n        \\n        # calculate sum_second of different borders\\n        second = [n for n in nums[-N:]]\\n        hq.heapify(second)\\n        curr_sum = sum(nums[-N:])\\n        sum_seconds = {2 * N : curr_sum}\\n        for i in range(2*N-1, -1, -1):\\n            hq.heappush(second, nums[i])\\n            curr_sum += nums[i] - hq.heappop(second)\\n            sum_seconds[i] = curr_sum\\n        \\n        # calculate diff for every border\\n        ans = math.inf\\n        for i in range(N, N * 2 + 1):\\n            ans = min(ans, sum_firsts[i] - sum_seconds[i])\\n        \\n        \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182539,
                "title": "c-o-n-log-n-minheap-maxheap-beating-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the smallest possible sum `lsum[i]` of the left partition `nums[0..n-1+i]` and the largest possible sum `rsum[i]` of the right partition `nums[n+i..3n-1]`, `i=0 to n`. Find the minimum `lsum[i] - rsum[i]` for all possible `i`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a maxheap to keep the smallest k elements of the first half of array when increasing `i`. If the newly added element is smallest than the greatest element in the priority queue, we have to remove it and add the new element.\\n\\nWe can do the similar thing to the right partition but we have to do it from greater index `i` to smaller. The reason why I don\\'t do this part from left to right is removing an element with a specific key from priority queue is painstaking and is not supported by the C++ standard library. Yet it is still possible to be done by using two `ordered_map`. The benefit is we don\\'t have to create the `small`, `large` arrays and save some memory. However, the space complexity of using two `ordered_map` is still `O(n)`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\n// small[i] store the sum of smallest n element within range nums[0..n+i]\\n// large[i] store the sum of greatest n element within range nums[n+i+1..3n-1]\\nlong long small[100002], large[100002];\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        long long lsum = accumulate(begin(nums), begin(nums)+n, 0LL);\\n        long long rsum = accumulate(begin(nums)+n*2, end(nums), 0LL);\\n        // use a maxheap to store n smallest elements in the left partition\\n        // use a minheap to store n greatest elements in the right partition\\n        priority_queue<int> maxheap(begin(nums), begin(nums)+n);\\n        priority_queue<int, vector<int>, greater<int>> minheap(begin(nums)+n*2, end(nums));\\n        \\n        // boundary conditions\\n        small[0] = lsum, large[n] = rsum;\\n        // updating the n-sum when adding\\n        // i elements starting from n+1 to 2n-1 to the left array\\n        // i elements starting from 2n-1 to n+1 to the right array\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[n+i] < maxheap.top()) {\\n                lsum += nums[n+i] - maxheap.top();\\n                maxheap.pop();\\n                maxheap.push(nums[n+i]);\\n            }\\n            if (nums[2*n-1-i] > minheap.top()) {\\n                rsum += nums[2*n-1-i] - minheap.top();\\n                minheap.pop();\\n                minheap.push(nums[2*n-1-i]);\\n            }\\n            small[i+1] = lsum, large[n-1-i] = rsum;\\n        }\\n        // check the minimumDifference of the partition at every possible positions.\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i <= n; ++i) {\\n            res = min(res, small[i] - large[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// small[i] store the sum of smallest n element within range nums[0..n+i]\\n// large[i] store the sum of greatest n element within range nums[n+i+1..3n-1]\\nlong long small[100002], large[100002];\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        long long lsum = accumulate(begin(nums), begin(nums)+n, 0LL);\\n        long long rsum = accumulate(begin(nums)+n*2, end(nums), 0LL);\\n        // use a maxheap to store n smallest elements in the left partition\\n        // use a minheap to store n greatest elements in the right partition\\n        priority_queue<int> maxheap(begin(nums), begin(nums)+n);\\n        priority_queue<int, vector<int>, greater<int>> minheap(begin(nums)+n*2, end(nums));\\n        \\n        // boundary conditions\\n        small[0] = lsum, large[n] = rsum;\\n        // updating the n-sum when adding\\n        // i elements starting from n+1 to 2n-1 to the left array\\n        // i elements starting from 2n-1 to n+1 to the right array\\n        for (int i = 0; i < n; ++i) {\\n            if (nums[n+i] < maxheap.top()) {\\n                lsum += nums[n+i] - maxheap.top();\\n                maxheap.pop();\\n                maxheap.push(nums[n+i]);\\n            }\\n            if (nums[2*n-1-i] > minheap.top()) {\\n                rsum += nums[2*n-1-i] - minheap.top();\\n                minheap.pop();\\n                minheap.push(nums[2*n-1-i]);\\n            }\\n            small[i+1] = lsum, large[n-1-i] = rsum;\\n        }\\n        // check the minimumDifference of the partition at every possible positions.\\n        long long res = LLONG_MAX;\\n        for (int i = 0; i <= n; ++i) {\\n            res = min(res, small[i] - large[i]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681884,
                "title": "dp-priority-queue-solution-100-fast-100-memory-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long ans = LLONG_MAX, suml = 0, sumr = 0, sumll, sumrr;\\n        int n = nums.size()/3;\\n        priority_queue<int> lpq;\\n        priority_queue<int,vector<int>,greater<int>> rpq;\\n        for(int i=0;i<n;i++) {\\n            lpq.push(nums[i]), suml += nums[i];\\n            rpq.push(nums[i+2*n]), sumr += nums[i+2*n];\\n        }\\n        sumll = suml;\\n        sumrr = sumr;\\n        vector<long long> leftdp(n), rightdp(n);\\n        ans = min(ans,suml-sumr);\\n        for(int i=n;i<2*n;i++){\\n            if(lpq.top()>nums[i]){\\n                suml -= lpq.top();\\n                suml += nums[i];\\n                lpq.pop();\\n                lpq.push(nums[i]);\\n            }\\n            leftdp[i-n] = suml;\\n        }\\n        for(int i=2*n-1;i>=n;i--){\\n            if(rpq.top()<nums[i]){\\n                sumr -= rpq.top();\\n                sumr += nums[i];\\n                rpq.pop();\\n                rpq.push(nums[i]);\\n            }\\n            rightdp[i-n] = sumr;\\n        }\\n        for(int i=0;i+1<n;i++) ans = min(ans,leftdp[i]-rightdp[i+1]);\\n        ans = min(ans,leftdp[n-1]-sumrr);\\n        ans = min(ans,sumll-rightdp[0]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long ans = LLONG_MAX, suml = 0, sumr = 0, sumll, sumrr;\\n        int n = nums.size()/3;\\n        priority_queue<int> lpq;\\n        priority_queue<int,vector<int>,greater<int>> rpq;\\n        for(int i=0;i<n;i++) {\\n            lpq.push(nums[i]), suml += nums[i];\\n            rpq.push(nums[i+2*n]), sumr += nums[i+2*n];\\n        }\\n        sumll = suml;\\n        sumrr = sumr;\\n        vector<long long> leftdp(n), rightdp(n);\\n        ans = min(ans,suml-sumr);\\n        for(int i=n;i<2*n;i++){\\n            if(lpq.top()>nums[i]){\\n                suml -= lpq.top();\\n                suml += nums[i];\\n                lpq.pop();\\n                lpq.push(nums[i]);\\n            }\\n            leftdp[i-n] = suml;\\n        }\\n        for(int i=2*n-1;i>=n;i--){\\n            if(rpq.top()<nums[i]){\\n                sumr -= rpq.top();\\n                sumr += nums[i];\\n                rpq.pop();\\n                rpq.push(nums[i]);\\n            }\\n            rightdp[i-n] = sumr;\\n        }\\n        for(int i=0;i+1<n;i++) ans = min(ans,leftdp[i]-rightdp[i+1]);\\n        ans = min(ans,leftdp[n-1]-sumrr);\\n        ans = min(ans,sumll-rightdp[0]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321876,
                "title": "java-min-priority-queue-max-priority-queue-array-solution",
                "content": "According to problem, there is requirement that one need to remove n elements from 3*n length of array. There are total 3nCn ways of removing the elements in total. Then we could take sum of the two halves and get their difference, compare them and extract the minimum out of all!!!\\n\\n*But looking at the constraint, the time complexity of this process is very high, we need to identify a different algorithm.*\\n\\n**Observation**\\nTo get a minimum difference, *lets say **(a - b)**, more we reduce a and more we increase the value of b, the lesser will be the value of (a - b).* Similar thing can be done in this case also, for array(first half of n elements) - array(second half of n elements). The task would then be limited to pick up the minimum n elements from starting till the ith elements and to pick up maximum of n elements from the i+1th to the end  of the array for all i in range of [n, 2n].\\n\\n**Data Structure**\\nTo implement the above, we would require a data structure which would keep the n minimum elements and pop out the maximum elements - max priority queue, other data structure which can keep the maximum values and pop out the minimum elements - min priority queue and an array to store the results of the difference of the two halves(minimum first half and maximum second half). \\n\\nThe idea is implemented below:- \\n\\n```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        PriorityQueue<Integer> pq_start = new PriorityQueue<>((a,b)->{\\n            return b - a;\\n        });\\n        int n = nums.length, k = n/3, mod = (int)1e9 + 7;\\n        long sum1 = 0;\\n        long[] start_sum = new long[n];\\n        \\n        for(int i=0; i<n ;i++) {\\n            sum1 += nums[i];\\n            pq_start.add(nums[i]);\\n            if(i >= k) {\\n                sum1 -= pq_start.poll();\\n            }\\n            start_sum[i] = sum1;\\n        }\\n        \\n        pq_start = new PriorityQueue<>((a,b)->{\\n            return a - b;\\n        });\\n        \\n        sum1 = 0;\\n        int idx = n - k;\\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i=n-1; i>=k-1; i--) {\\n            if(i < idx) {\\n                ans = Math.min(ans, start_sum[i] - sum1);\\n            }\\n            pq_start.add(nums[i]);\\n            sum1 += nums[i];\\n            if(i < idx) {\\n                sum1 -= pq_start.poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n**Time Complexity:-** O(*nlog(n)*)\\nWe are iterating over entire array of length 3n and on each iteration pushing and poping the element from priority queue - 3n*log(n)*(first iteration) + 3n*log(n)*(second iteration) + n(final iteration for getting the minimum). Thus, Overall the Complexity is O(*nlog(n)*).\\n\\n**Space Complexity:-** O(*n*)\\nThe space taken by array is O(3n), priority queues - O(n) space. \\nThus Overall Space Complexity is O(*n*).",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        PriorityQueue<Integer> pq_start = new PriorityQueue<>((a,b)->{\\n            return b - a;\\n        });\\n        int n = nums.length, k = n/3, mod = (int)1e9 + 7;\\n        long sum1 = 0;\\n        long[] start_sum = new long[n];\\n        \\n        for(int i=0; i<n ;i++) {\\n            sum1 += nums[i];\\n            pq_start.add(nums[i]);\\n            if(i >= k) {\\n                sum1 -= pq_start.poll();\\n            }\\n            start_sum[i] = sum1;\\n        }\\n        \\n        pq_start = new PriorityQueue<>((a,b)->{\\n            return a - b;\\n        });\\n        \\n        sum1 = 0;\\n        int idx = n - k;\\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i=n-1; i>=k-1; i--) {\\n            if(i < idx) {\\n                ans = Math.min(ans, start_sum[i] - sum1);\\n            }\\n            pq_start.add(nums[i]);\\n            sum1 += nums[i];\\n            if(i < idx) {\\n                sum1 -= pq_start.poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254614,
                "title": "c-max-heap-min-heap-explained-solution",
                "content": "```\\n\\n/*\\n\\nsum1-sum2= min ,  so keep sum1 as min as possible and keep sum2 as max as possible\\n\\n\\nIt is also give that all elements of sum1 lies to the left of all elements of sum2\\n\\nNo of elements in sum1 = n\\n\\nNo of elements in sum2= n\\n\\nGeneral : [......(sum1).....| ......(sum2).....]\\n\\n\\n[a,b,c,d,e  |  f,g,h,i,j,k,l,m,n,o]\\n\\nsum1= a+b+c+d+e  , sum2= sum of top 5 max elements in [f,g,h,i,j,k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n[a,b,c,d,e,f | g,h,i,j,k,l,m,n,o]\\n\\nsum1= sum of top 5 min element in [a,b,c,d,e,f]\\n\\nsum2= sum of top 5 max elements in [g,h,i,j,k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n[a,b,c,d,e,f,g | h,i,j,k,l,m,n,o]\\n\\nsum1= sum of top 5 min element in [a,b,c,d,e,f,g]\\n\\nsum2= sum of top 5 max elements in [h,i,j,k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n[a,b,c,d,e,f,g h | i,j,k,l,m,n,o]\\n\\nsum1= sum of top 5 min element in [a,b,c,d,e,f,g.h]\\n\\nsum2= sum of top 5 max elements in [i,j,k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n\\n[a,b,c,d,e,f,g h,i | j,k,l,m,n,o]\\n\\nsum1= sum of top 5 min element in [a,b,c,d,e,f,g,h,i]\\n\\nsum2= sum of top 5 max elements in [j,k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n\\n[a,b,c,d,e,f,g h,i,j | k,l,m,n,o]\\n\\nsum1= sum of top 5 min element in [a,b,c,d,e,f,g,h,i,j]\\n\\nsum2= sum of top 5 max elements in [k,l,m,n,o]\\n\\nans=min(ans,sum1-sum2)\\n\\n\\n\\nCleary we use max haep to store top 5 min element on left side of bar for each position of bar\\n\\nAnd we use min heap to store top 5 max element on right side of bar for each position of bar\\n\\n\\n*/\\n\\n#define lln long long int\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        int n=nums.size()/3;\\n        \\n        \\n        priority_queue<int>pq1;\\n\\n        \\n        vector<lln>v1; \\n        \\n// to store sum of top n min elemennts on left side of bar at each positon of bar\\n        \\n        lln sum1=0;\\n        \\n        for(int i=0;i<2*n;i++){\\n            sum1+=nums[i];\\n            pq1.push(nums[i]);\\n            \\n            if(pq1.size()>n){\\n                sum1-=pq1.top();\\n                pq1.pop();\\n            }\\n            \\n            if(pq1.size()==n)\\n           v1.push_back(sum1);\\n\\n        }\\n        \\n     priority_queue<lln,vector<lln>,greater<int>>pq2;\\n     \\n\\n// to store sum of top n max elemennts on right side of bar at each positon of bar\\n        \\n        vector<lln>v2;\\n        \\n        lln sum2=0;\\n        \\n        for(int i=3*n-1;i>=n;i--){\\n            sum2+=nums[i];\\n            \\n            pq2.push(nums[i]);\\n            \\n            if(pq2.size()>n){\\n                sum2-=pq2.top();\\n                pq2.pop();\\n            }\\n            \\n    \\n         if(pq2.size()==n)\\n          v2.push_back(sum2);\\n            \\n        }\\n        \\n        reverse(v2.begin(),v2.end());\\n        \\n        int sz=v1.size();\\n        \\n        lln ans=1e18;\\n        \\n        for(int i=0;i<sz;i++){\\n            ans=min(ans,v1[i]-v2[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        int n=nums.size()/3;\\n        \\n        \\n        priority_queue<int>pq1;\\n\\n        \\n        vector<lln>v1; \\n        \\n// to store sum of top n min elemennts on left side of bar at each positon of bar\\n        \\n        lln sum1=0;\\n        \\n        for(int i=0;i<2*n;i++){\\n            sum1+=nums[i];\\n            pq1.push(nums[i]);\\n            \\n            if(pq1.size()>n){\\n                sum1-=pq1.top();\\n                pq1.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2244161,
                "title": "java-prefix-priority-queue",
                "content": "```\\nclass Solution {\\n    \\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        Comparator<Integer> maxComparator = new Comparator<Integer>(){\\n            @Override\\n            public int compare(Integer i, Integer j){\\n                return - i.compareTo(j);\\n            }\\n        };\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(n, maxComparator);\\n        long sum = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            maxHeap.offer(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        long prefix[] = new long[n + 1];\\n        prefix[0] = sum;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (maxHeap.peek() > nums[n + i - 1]) {\\n                \\n                prefix[i] = prefix[i - 1] + nums[n + i - 1] - maxHeap.poll();\\n                maxHeap.offer(nums[n + i - 1]);\\n            }\\n            else { prefix[i] = prefix[i - 1]; }\\n        }\\n        \\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(n);\\n        sum = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            minHeap.offer(nums[nums.length - 1 - i]);\\n            sum += nums[nums.length - 1 - i];\\n        }\\n        \\n        long ans = prefix[n] - sum;\\n        for (int i = 0; i < n; i++) {\\n            \\n            int num = nums[nums.length - (n + 1) - i];\\n            if (minHeap.peek() < num) {\\n                sum -= minHeap.poll() - num;\\n                minHeap.offer(num);\\n            }\\n            \\n            ans = Math.min(ans, prefix[n - (i + 1)] - sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        Comparator<Integer> maxComparator = new Comparator<Integer>(){\\n            @Override\\n            public int compare(Integer i, Integer j){\\n                return - i.compareTo(j);\\n            }\\n        };\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(n, maxComparator);\\n        long sum = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            maxHeap.offer(nums[i]);\\n            sum += nums[i];\\n        }\\n        \\n        long prefix[] = new long[n + 1];\\n        prefix[0] = sum;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            if (maxHeap.peek() > nums[n + i - 1]) {\\n                \\n                prefix[i] = prefix[i - 1] + nums[n + i - 1] - maxHeap.poll();\\n                maxHeap.offer(nums[n + i - 1]);\\n            }\\n            else { prefix[i] = prefix[i - 1]; }\\n        }\\n        \\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>(n);\\n        sum = 0;\\n        \\n        for (int i = 0; i < n; i++){\\n            minHeap.offer(nums[nums.length - 1 - i]);\\n            sum += nums[nums.length - 1 - i];\\n        }\\n        \\n        long ans = prefix[n] - sum;\\n        for (int i = 0; i < n; i++) {\\n            \\n            int num = nums[nums.length - (n + 1) - i];\\n            if (minHeap.peek() < num) {\\n                sum -= minHeap.poll() - num;\\n                minHeap.offer(num);\\n            }\\n            \\n            ans = Math.min(ans, prefix[n - (i + 1)] - sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223255,
                "title": "c-code-for-beginners-priority-queue-min-and-max-heap-lucid-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/449cf802-bcee-413d-b427-ccd22b32e13f_1656686213.0541532.png)\\n\\n\\nUse a MAXHEAP to find the minSum on left side for all indices i,\\nUse a MINHEAP to find the maxSum on right side for all indicies i.\\nBecause,\\nmin-max will give the smallest answer, so we try to minimise the left part and maximise the right\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N=nums.size();\\n        int n=N/3;\\n\\t\\t\\n        priority_queue<long long> mxPQ;\\n        priority_queue<long long,vector<long long>,greater<long long>> mnPQ;\\n\\t\\t\\n        vector<long long> mnSum(N);  // each mnSum[i] here tells us the minSum, we can obtain in range [0,i](including i), with n elements\\n\\t\\t\\n        vector<long long> mxSum(N);  // each mxSum[i] here tells us the maxSum, we can obtain in range [0,i](including i), with n elements\\n        \\n\\t\\t\\n        for(int i=0;i<N-n;i++){    // SEE IMAGE TO UNDERSTAND, WE WOULD NOT USE THOSE IGNORED INDICES ANYWAYS\\n            if(mxPQ.size()<n){  // if group size is not achieved, keep pushing and adding\\n                mxPQ.push(nums[i]);  \\n                mnSum[i]=nums[i]+(i-1>=0 ? mnSum[i-1] : 0);\\n            }\\n            else if(mxPQ.top()>nums[i]){  // size is achieved, but the top of maxHeap contains the maximum element of heap, we see nums[i] is less than top, remove top and do the adjustment\\n                mnSum[i]=mnSum[i-1]-mxPQ.top()+nums[i];\\n                mxPQ.pop();\\n                mxPQ.push(nums[i]);\\n            }\\n            else{  // if top is smaller than nums[i] or equal, just take the answer before this index, because it contained the minimum till that point, so that miniSum can be used in this index as well\\n                mnSum[i]=mnSum[i-1];\\n            }\\n        }\\n        \\n        for(int i=N-1;i>=N-2*n;i--){    // SEE IMAGE TO UNDERSTAND, WE WOULD NOT USE THOSE IGNORED INDICES ANYWAYS\\n            if(mnPQ.size()<n){\\n                mnPQ.push(nums[i]);\\n                mxSum[i]=nums[i]+(i+1<N ? mxSum[i+1] : 0);\\n            }\\n            else if(mnPQ.top()<nums[i]){\\n                mxSum[i]=mxSum[i+1]-mnPQ.top()+nums[i];\\n                mnPQ.pop();\\n                mnPQ.push(nums[i]);\\n            }\\n            else{\\n                mxSum[i]=mxSum[i+1];\\n            }\\n        }\\n        \\n        long long res=LONG_MAX;\\n        \\n        // deletion range is from n-1 to 2*n-1(since i+1, otherwise the range should is till 2*n), this is because it is guaranteed that from [0,i], n elements are there, and they constitute the minSum possible, and from [2*n,N], n elements are there, and they constitute maxSum of n elements..So inshort, elements before n-1 and after 2*n are ignored, since their index do not contain answer for n elements sum. PLEASE LOOK THE IMAGE TO UNDERSTAND THIS BETTER\\n        for(int i=n-1;i<2*n;i++){\\n            res=min(res,(long long)mnSum[i]-mxSum[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nSAME QUESTION, BUT NOW MAX\\n\\n![image](https://assets.leetcode.com/users/images/3c347ea5-48bf-4599-bbbe-444f979957c7_1657123422.6407838.png)\\n\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N=nums.size();\\n        int n=N/3;\\n\\t\\t\\n        priority_queue<long long> mxPQ;\\n        priority_queue<long long,vector<long long>,greater<long long>> mnPQ;\\n\\t\\t\\n        vector<long long> mnSum(N);  // each mnSum[i] here tells us the minSum, we can obtain in range [0,i](including i), with n elements\\n\\t\\t\\n        vector<long long> mxSum(N);  // each mxSum[i] here tells us the maxSum, we can obtain in range [0,i](including i), with n elements\\n        \\n\\t\\t\\n        for(int i=0;i<N-n;i++){    // SEE IMAGE TO UNDERSTAND, WE WOULD NOT USE THOSE IGNORED INDICES ANYWAYS\\n            if(mxPQ.size()<n){  // if group size is not achieved, keep pushing and adding\\n                mxPQ.push(nums[i]);  \\n                mnSum[i]=nums[i]+(i-1>=0 ? mnSum[i-1] : 0);\\n            }\\n            else if(mxPQ.top()>nums[i]){  // size is achieved, but the top of maxHeap contains the maximum element of heap, we see nums[i] is less than top, remove top and do the adjustment\\n                mnSum[i]=mnSum[i-1]-mxPQ.top()+nums[i];\\n                mxPQ.pop();\\n                mxPQ.push(nums[i]);\\n            }\\n            else{  // if top is smaller than nums[i] or equal, just take the answer before this index, because it contained the minimum till that point, so that miniSum can be used in this index as well\\n                mnSum[i]=mnSum[i-1];\\n            }\\n        }\\n        \\n        for(int i=N-1;i>=N-2*n;i--){    // SEE IMAGE TO UNDERSTAND, WE WOULD NOT USE THOSE IGNORED INDICES ANYWAYS\\n            if(mnPQ.size()<n){\\n                mnPQ.push(nums[i]);\\n                mxSum[i]=nums[i]+(i+1<N ? mxSum[i+1] : 0);\\n            }\\n            else if(mnPQ.top()<nums[i]){\\n                mxSum[i]=mxSum[i+1]-mnPQ.top()+nums[i];\\n                mnPQ.pop();\\n                mnPQ.push(nums[i]);\\n            }\\n            else{\\n                mxSum[i]=mxSum[i+1];\\n            }\\n        }\\n        \\n        long long res=LONG_MAX;\\n        \\n        // deletion range is from n-1 to 2*n-1(since i+1, otherwise the range should is till 2*n), this is because it is guaranteed that from [0,i], n elements are there, and they constitute the minSum possible, and from [2*n,N], n elements are there, and they constitute maxSum of n elements..So inshort, elements before n-1 and after 2*n are ignored, since their index do not contain answer for n elements sum. PLEASE LOOK THE IMAGE TO UNDERSTAND THIS BETTER\\n        for(int i=n-1;i<2*n;i++){\\n            res=min(res,(long long)mnSum[i]-mxSum[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163353,
                "title": "priority-queue-using-min-and-max-heap-100-faster-c-code",
                "content": "First make two heaps max heap and min heap to store the n/3 smallest numbers from the left-right and n/3 largest numbers from the right-left.We do this by iterating the array from 0 to 2*(n/3) from left and n-1 to n/3 from the right .And we store minimum sum formed at those respective place in an array known as ltor and rtol in the below written code.After doing this we just subtract the respective ltor and rtol and find the minimum answer among those.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        int n = nums.size();\\n        long long sum = 0;\\n        int n1 = n/3;\\n        vector<long long> ltor;\\n        vector<long long > rtol;\\n        ltor.push_back(0);rtol.push_back(0);\\n        for(int i=0;i<n-n1;i++){\\n            if(i<n1){\\n                pq1.push(nums[i]);\\n                sum += nums[i];\\n                ltor[0] = sum;\\n            }\\n            else{\\n                if(pq1.top() > nums[i]){\\n                    sum -= pq1.top();\\n                    pq1.pop();\\n                    pq1.push(nums[i]);\\n                    sum += nums[i];\\n                }\\n                ltor.push_back(sum);\\n            }\\n\\n        }\\n        long long sum2 = 0;\\n        for(int i=n-1,k=0;i>=n1;i--,k++){\\n            if(k<n1){\\n                pq2.push(nums[i]);\\n                sum2 += nums[i];\\n                rtol[0] = sum2;\\n            }\\n            else{\\n                if(pq2.top() < nums[i]){\\n                    sum2 -= pq2.top();\\n                    pq2.pop();\\n                    pq2.push(nums[i]);\\n                    sum2 += nums[i];\\n                }\\n                rtol.push_back(sum2);\\n            }\\n\\n        }\\n        reverse(rtol.begin(),rtol.end());\\n        // cout<<pq1.size()<<\" \"<<pq2.size();\\n        long long ans = 1e12;\\n        for(int i=0;i<rtol.size();i++){\\n            // cout<<ltor[i]<<\" \"<<rtol[i]<<endl;\\n            ans = min(ans,ltor[i] - rtol[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        int n = nums.size();\\n        long long sum = 0;\\n        int n1 = n/3;\\n        vector<long long> ltor;\\n        vector<long long > rtol;\\n        ltor.push_back(0);rtol.push_back(0);\\n        for(int i=0;i<n-n1;i++){\\n            if(i<n1){\\n                pq1.push(nums[i]);\\n                sum += nums[i];\\n                ltor[0] = sum;\\n            }\\n            else{\\n                if(pq1.top() > nums[i]){\\n                    sum -= pq1.top();\\n                    pq1.pop();\\n                    pq1.push(nums[i]);\\n                    sum += nums[i];\\n                }\\n                ltor.push_back(sum);\\n            }\\n\\n        }\\n        long long sum2 = 0;\\n        for(int i=n-1,k=0;i>=n1;i--,k++){\\n            if(k<n1){\\n                pq2.push(nums[i]);\\n                sum2 += nums[i];\\n                rtol[0] = sum2;\\n            }\\n            else{\\n                if(pq2.top() < nums[i]){\\n                    sum2 -= pq2.top();\\n                    pq2.pop();\\n                    pq2.push(nums[i]);\\n                    sum2 += nums[i];\\n                }\\n                rtol.push_back(sum2);\\n            }\\n\\n        }\\n        reverse(rtol.begin(),rtol.end());\\n        // cout<<pq1.size()<<\" \"<<pq2.size();\\n        long long ans = 1e12;\\n        for(int i=0;i<rtol.size();i++){\\n            // cout<<ltor[i]<<\" \"<<rtol[i]<<endl;\\n            ans = min(ans,ltor[i] - rtol[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1815957,
                "title": "c-max-heap-from-left-to-right-and-min-heap-from-right-to-left",
                "content": "The only thing required to solve this problem is to understand that the lowest possible difference can be obtained when the sum of the first n elements in the resultant array is minimum, and the sum of the next n elements is maximum.\\n\\nTo get the minimum sum at any location (i) we can greedly remove the maximum element, but only after having n elements. That can be done using a max-heap. \\n\\nSimilarly, at the same point, we need the maximum sum we get, but for the array on the right of `i`th location in the array. A min-heap can be used while iterating from right to left to get the same. \\n\\nThe solution is straight forward. Let me know if there are any doubts\\n\\nTime Complexity: `O(NlogN)`\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<ll> maxHeap; \\n        priority_queue<ll, vector<ll>, greater<ll>> minHeap; \\n        vector<ll> part1, part2; \\n        ll n = nums.size()/3, sum = 0, i = 0, res = LONG_MAX; \\n        for(i=0;i<n; i++) {\\n            maxHeap.push(nums[i]); \\n            sum += nums[i]; \\n        }\\n        \\n        part1.push_back(sum); \\n        while(i < 2*n){\\n            maxHeap.push(nums[i]); \\n            sum += nums[i]; \\n            sum -= maxHeap.top(); \\n            maxHeap.pop(); \\n            part1.push_back(sum); \\n            i++; \\n        }\\n        i = 3*n-1, sum = 0;\\n        \\n        for(;i>= 2*n; i--){\\n            minHeap.push(nums[i]); \\n            sum += nums[i]; \\n        }\\n        part2.push_back(sum); \\n        \\n        while(i>= n) {\\n            minHeap.push(nums[i]); \\n            sum += nums[i]; \\n            sum -= minHeap.top(); \\n            minHeap.pop(); \\n            part2.push_back(sum); \\n            i--; \\n        }\\n        \\n        reverse(part2.begin(), part2.end()); \\n\\n        for(int i=0; i<part1.size(); i++) res = min(res, part1[i]-part2[i]); \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<ll> maxHeap; \\n        priority_queue<ll, vector<ll>, greater<ll>> minHeap; \\n        vector<ll> part1, part2; \\n        ll n = nums.size()/3, sum = 0, i = 0, res = LONG_MAX; \\n        for(i=0;i<n; i++) {\\n            maxHeap.push(nums[i]); \\n            sum += nums[i]; \\n        }\\n        \\n        part1.push_back(sum); \\n        while(i < 2*n){\\n            maxHeap.push(nums[i]); \\n            sum += nums[i]; \\n            sum -= maxHeap.top(); \\n            maxHeap.pop(); \\n            part1.push_back(sum); \\n            i++; \\n        }\\n        i = 3*n-1, sum = 0;\\n        \\n        for(;i>= 2*n; i--){\\n            minHeap.push(nums[i]); \\n            sum += nums[i]; \\n        }\\n        part2.push_back(sum); \\n        \\n        while(i>= n) {\\n            minHeap.push(nums[i]); \\n            sum += nums[i]; \\n            sum -= minHeap.top(); \\n            minHeap.pop(); \\n            part2.push_back(sum); \\n            i--; \\n        }\\n        \\n        reverse(part2.begin(), part2.end()); \\n\\n        for(int i=0; i<part1.size(); i++) res = min(res, part1[i]-part2[i]); \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770342,
                "title": "java-priority-queue",
                "content": "**Intuition** - Sumfirst should be as min as possible and Sumsecond should be as max as possible to get min difference between Sumfirst and Sumsecond.\\n\\nApproach\\n1. Use minHeap to get sum of N larger elements for Sumsecond on right side. Construct a prefix arr to maintain maxSum from arr[i..n] for choosen N elements on the right side.\\n2. Use maxHeap to get sum of N smaller elements on the left side. Maintain minSum from arr[0..i], i ranges from N to 2N-1.\\n\\n```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int N = n / 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        long rsum = 0;\\n        long[] prefix = new long[n];\\n        for(int i = n-1; i >= N; i--){\\n            minHeap.add(nums[i]);\\n            rsum += nums[i];\\n            if(minHeap.size() > N){\\n                rsum -= minHeap.poll();\\n            }\\n            if(minHeap.size() == N) {\\n                prefix[i] = rsum;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(prefix));\\n        long ans = Long.MAX_VALUE;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n        long lsum = 0;\\n        for(int i = 0; i < 2*N; i++){\\n            maxHeap.add(nums[i]);\\n            lsum += nums[i];\\n            if(maxHeap.size() > N){\\n                lsum -= maxHeap.poll();\\n            }\\n            if(maxHeap.size() == N) {\\n                //System.out.println(lsum +\" \"+prefix[i + 1]);\\n                ans  = Math.min(ans, lsum - prefix[i + 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length;\\n        int N = n / 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        long rsum = 0;\\n        long[] prefix = new long[n];\\n        for(int i = n-1; i >= N; i--){\\n            minHeap.add(nums[i]);\\n            rsum += nums[i];\\n            if(minHeap.size() > N){\\n                rsum -= minHeap.poll();\\n            }\\n            if(minHeap.size() == N) {\\n                prefix[i] = rsum;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(prefix));\\n        long ans = Long.MAX_VALUE;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n        long lsum = 0;\\n        for(int i = 0; i < 2*N; i++){\\n            maxHeap.add(nums[i]);\\n            lsum += nums[i];\\n            if(maxHeap.size() > N){\\n                lsum -= maxHeap.poll();\\n            }\\n            if(maxHeap.size() == N) {\\n                //System.out.println(lsum +\" \"+prefix[i + 1]);\\n                ans  = Math.min(ans, lsum - prefix[i + 1]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764481,
                "title": "java-easy-to-understand-solution-using-priority-queues",
                "content": "\\'\\'\\'\\n long[] prefix= new long[nums.length];\\n            int len=nums.length;\\n             long[] suffix = new long[len];\\n            int n=nums.length/3;\\n            // prefix[i] it stores sum of n minimum element from o-to i\\n            // suffix[i] it stores sum of n maximum element from n-1 to i;\\n            // why ? answer sumFirst-sumSecond now we need to minimize this we are to maximize sumSecond and minimize sumFirst;\\n            // use of priority Queue for for minimum and maximum ele from 0-i as well n-1 to i;\\n          \\n\\t\\t  \\n\\t\\t  \\n\\t\\t  \\n\\t\\t   PriorityQueue<Integer> pq= new PriorityQueue<>((a,b)->b-a);\\n            long left=0;\\n            for(int i=0;i<len-n;i++){\\n                    pq.add(nums[i]);\\n                    left+=nums[i];\\n                    if(pq.size()>n){\\n                            left-=pq.peek();\\n                            pq.poll();\\n                    }\\n                    if(pq.size()==n){\\n                         prefix[i]=left;   \\n                    }\\n                    \\n            }\\n            long right=0;\\n            pq= new PriorityQueue<>();\\n            for(int i=len-1;i>=n;i--){\\n                      pq.add(nums[i]);\\n                    right+=nums[i];\\n                    if(pq.size()>n){\\n                            right-=pq.peek();\\n                            pq.poll();\\n                    }\\n                    if(pq.size()==n){\\n                         suffix[i]=right;   \\n                    }\\n                    \\n            }\\n            long min=Long.MAX_VALUE;\\n            for(int i=n-1;i<len-n;i++){\\n                    min=Math.min(min,prefix[i]-suffix[i+1]);\\n                    \\n            }\\n            return min;",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\'\\'\\'\\n long[] prefix= new long[nums.length];\\n            int len=nums.length;\\n             long[] suffix = new long[len];\\n            int n=nums.length/3;\\n            // prefix[i] it stores sum of n minimum element from o-to i\\n            // suffix[i] it stores sum of n maximum element from n-1 to i;\\n            // why ? answer sumFirst-sumSecond now we need to minimize this we are to maximize sumSecond and minimize sumFirst;\\n            // use of priority Queue for for minimum and maximum ele from 0-i as well n-1 to i;\\n          \\n\\t\\t  \\n\\t\\t  \\n\\t\\t  \\n\\t\\t   PriorityQueue<Integer> pq= new PriorityQueue<>((a,b)->b-a);\\n            long left=0;\\n            for(int i=0;i<len-n;i++){\\n                    pq.add(nums[i]);\\n                    left+=nums[i];\\n                    if(pq.size()>n){\\n                            left-=pq.peek();\\n                            pq.poll();\\n                    }\\n                    if(pq.size()==n){\\n                         prefix[i]=left;   \\n                    }\\n                    \\n            }\\n            long right=0;\\n            pq= new PriorityQueue<>();\\n            for(int i=len-1;i>=n;i--){\\n                      pq.add(nums[i]);\\n                    right+=nums[i];\\n                    if(pq.size()>n){\\n                            right-=pq.peek();\\n                            pq.poll();\\n                    }\\n                    if(pq.size()==n){\\n                         suffix[i]=right;   \\n                    }\\n                    \\n            }\\n            long min=Long.MAX_VALUE;\\n            for(int i=n-1;i<len-n;i++){\\n                    min=Math.min(min,prefix[i]-suffix[i+1]);\\n                    \\n            }\\n            return min;",
                "codeTag": "Unknown"
            },
            {
                "id": 1757811,
                "title": "multiset-prefix-and-suffix-array",
                "content": "Using Prefix and suffix array and multiset also \\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        \\n        vector<long long> pre(N);\\n        vector<long long > suf(N);\\n        multiset<int,greater<int>> ms1;\\n        multiset<int> ms2;\\n        long long sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            pre[i] = INT_MAX;\\n            sum += nums[i];\\n            ms1.insert(nums[i]);\\n        } \\n        pre[n-1] = sum;\\n        for(int i=n;i<(2*N)/3;i++){\\n            int top = *(ms1.begin());\\n            if(top > nums[i]){\\n                ms1.erase(ms1.begin());\\n                ms1.insert(nums[i]);\\n                sum+=nums[i];\\n                sum-=top;\\n            }\\n            pre[i] = sum;\\n        }\\n        sum = 0;\\n        for(int i=N-1;i>=(2*N/3);i--)\\n        {\\n            sum+=nums[i];\\n            suf[i] = INT_MAX;\\n            ms2.insert(nums[i]);\\n        }\\n        suf[(2*N)/3] = sum;\\n        for(int i= (2*N)/3 - 1;i>=n;i--){\\n            int top = *(ms2.begin());\\n            if(top < nums[i]){\\n                ms2.erase(ms2.begin());\\n                ms2.insert(nums[i]);\\n                sum+=nums[i];\\n                sum-=top;\\n            }\\n            suf[i] = sum;\\n        }\\n        long long ans = LONG_MAX;\\n        for(int i=n-1;i<2*n;i++){\\n            ans = min(ans, pre[i] - suf[i+1]);\\n        }\\n     \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        \\n        vector<long long> pre(N);\\n        vector<long long > suf(N);\\n        multiset<int,greater<int>> ms1;\\n        multiset<int> ms2;\\n        long long sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            pre[i] = INT_MAX;\\n            sum += nums[i];\\n            ms1.insert(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1753678,
                "title": "multiset-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/3;\\n        long long left[n+1],right[n+1],lsum=0,rsum=0;\\n        multiset<int> st;\\n        for(int i=0;i<n;i++)lsum+=nums[i],st.insert(nums[i]);\\n        left[0]=lsum;\\n        for(int i=n;i<2*n;i++){\\n            st.insert(nums[i]);\\n            lsum+=nums[i];\\n            auto it=st.end();\\n            it--;\\n            lsum-=*it;\\n            st.erase(it);\\n            left[i-n+1]=lsum;\\n        }\\n        st.clear();\\n        for(int i=2*n;i<3*n;i++)rsum+=nums[i],st.insert(nums[i]);\\n        right[n]=rsum;\\n        for(int i=2*n-1;i>=n;i--){\\n            st.insert(nums[i]);\\n            rsum-=*st.begin();\\n            st.erase(st.begin());\\n            rsum+=nums[i];\\n            right[i-n]=rsum;\\n        }\\n        long long ans=LLONG_MAX;\\n        for(int i=0;i<=n;i++)ans=min(ans,left[i]-right[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/3;\\n        long long left[n+1],right[n+1],lsum=0,rsum=0;\\n        multiset<int> st;\\n        for(int i=0;i<n;i++)lsum+=nums[i],st.insert(nums[i]);\\n        left[0]=lsum;\\n        for(int i=n;i<2*n;i++){\\n            st.insert(nums[i]);\\n            lsum+=nums[i];\\n            auto it=st.end();\\n            it--;\\n            lsum-=*it;\\n            st.erase(it);\\n            left[i-n+1]=lsum;\\n        }\\n        st.clear();\\n        for(int i=2*n;i<3*n;i++)rsum+=nums[i],st.insert(nums[i]);\\n        right[n]=rsum;\\n        for(int i=2*n-1;i>=n;i--){\\n            st.insert(nums[i]);\\n            rsum-=*st.begin();\\n            st.erase(st.begin());\\n            rsum+=nums[i];\\n            right[i-n]=rsum;\\n        }\\n        long long ans=LLONG_MAX;\\n        for(int i=0;i<=n;i++)ans=min(ans,left[i]-right[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753594,
                "title": "c-solution-using-priority-queue",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int reqn=n/3;\\n        //Since we want the minimum difference, we should aim to get the sum of the first part as small \\n        //as possible and right part as large as possible.\\n        vector<long long>minsum;//min sum of reqn elem from start\\n        vector<long long>maxsum;//max sum of reqn elem from end\\n        priority_queue<int>pq1;\\n        priority_queue <int, vector<int>, greater<int>>pq2;\\n        long long sum1=0,sum2=0;\\n        for(int i=0;i<reqn;i++){\\n            sum1+=nums[i];\\n            pq1.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=n-reqn;i--){\\n            sum2+=nums[i];\\n            pq2.push(nums[i]);\\n        }\\n        minsum.push_back(sum1);\\n        maxsum.push_back(sum2);\\n        for(int i=reqn;i<2*reqn;i++){\\n            if(pq1.top()>nums[i]){\\n                minsum.push_back(minsum[minsum.size()-1]-pq1.top()+nums[i]);\\n                pq1.pop();\\n                pq1.push(nums[i]);\\n            }\\n            else\\n                minsum.push_back(minsum[minsum.size()-1]);\\n        }\\n        for(int i=n-reqn-1;i>=reqn;i--){\\n            if(pq2.top()<nums[i]){\\n                maxsum.push_back(maxsum[maxsum.size()-1]-pq2.top()+nums[i]);\\n                pq2.pop();\\n                pq2.push(nums[i]);\\n            }\\n            else\\n                maxsum.push_back(maxsum[maxsum.size()-1]);\\n        }\\n        long long currmin=LLONG_MAX;\\n        for(int i=0;i<=reqn;i++){\\n            currmin=min(currmin,minsum[i]-maxsum[reqn-i]);\\n        }\\n        return currmin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int reqn=n/3;\\n        //Since we want the minimum difference, we should aim to get the sum of the first part as small \\n        //as possible and right part as large as possible.\\n        vector<long long>minsum;//min sum of reqn elem from start\\n        vector<long long>maxsum;//max sum of reqn elem from end\\n        priority_queue<int>pq1;\\n        priority_queue <int, vector<int>, greater<int>>pq2;\\n        long long sum1=0,sum2=0;\\n        for(int i=0;i<reqn;i++){\\n            sum1+=nums[i];\\n            pq1.push(nums[i]);\\n        }\\n        for(int i=n-1;i>=n-reqn;i--){\\n            sum2+=nums[i];\\n            pq2.push(nums[i]);\\n        }\\n        minsum.push_back(sum1);\\n        maxsum.push_back(sum2);\\n        for(int i=reqn;i<2*reqn;i++){\\n            if(pq1.top()>nums[i]){\\n                minsum.push_back(minsum[minsum.size()-1]-pq1.top()+nums[i]);\\n                pq1.pop();\\n                pq1.push(nums[i]);\\n            }\\n            else\\n                minsum.push_back(minsum[minsum.size()-1]);\\n        }\\n        for(int i=n-reqn-1;i>=reqn;i--){\\n            if(pq2.top()<nums[i]){\\n                maxsum.push_back(maxsum[maxsum.size()-1]-pq2.top()+nums[i]);\\n                pq2.pop();\\n                pq2.push(nums[i]);\\n            }\\n            else\\n                maxsum.push_back(maxsum[maxsum.size()-1]);\\n        }\\n        long long currmin=LLONG_MAX;\\n        for(int i=0;i<=reqn;i++){\\n            currmin=min(currmin,minsum[i]-maxsum[reqn-i]);\\n        }\\n        return currmin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752485,
                "title": "c-o-nlogn-solution-with-comments-pictorial-explanation",
                "content": "**Explanation**\\n\\nDifference = <code>sum<sub>first</sub> - sum<sub>second</sub></code>\\nTo minimize this difference, it is easy to see that sum of first part should be minimized and that of the second part should be maximized.\\n\\nLet\\'s divide the whole array of `n` elements into two halves H1 and H2.\\nAs said above, for minimum sum from H1, we choose `n/3` smallest elements and for maximum sum from H2, we choose `n/3` largest elements.\\n\\nFor an array of `n` elements, we have total `n-1` possible ways to partition it. (e.x. 5 ways for array size 6)\\n\\n<img src=\"https://assets.leetcode.com/users/images/cd6e6005-e537-4545-b8e6-7912428cfb29_1644218090.4120839.png\" alt=\"image\" width=\"250\"/>\\n\\nWe find the n smallest elements from the H1 half for every subarray from `A[1...i]` by using a bag (for sake of understanding) and let\\'s label their sum as `min_bag[i]`. And the n largest elements from the H2 half for every subarray from `A[i+1...N]` and let\\'s label their sum as `max_bag[i]`.\\nFinally we find the minimum from the below equation:\\n`min(min_bag[i] - max_bag[i])` for `0<=i<n`\\n\\nLet\\'s consider the example `[7,2,4,3,1,6,9,4,2]`\\n1. Add 7 into the bag and also update the current sum inside the bag.\\n\\t```\\n\\tsum = 7   \\n\\tbag=[7]\\n\\t```\\n2. Since the bag\\'s capacity is not filled, set `min_bag[i]` as some large value and move to next element.\\t\\n\\t```\\n\\tsum = 7  \\n\\tbag=[7]\\n\\tmin_bag[0] = INF\\n\\t```\\n3. Add 2 into the bag and repeat the above two steps. \\n\\t```\\n\\tsum = 9   \\n\\tbag=[2,7]\\n\\tmin_bag[1] = INF\\n\\t```\\n4. Add 4 into the bag and update current sum. Now the bag is full, so update `min_bag[i]` to the current sum.\\n\\t```\\n\\tsum = 13   \\n\\tbag=[2,4,7]\\n\\tmin_bag[2] = 13\\n\\t```\\n5. Now, 3 is the current element which is smaller than the largest element in the bag i.e. 7. So we replace 7 from our bag and current sum with 3.\\n\\t```\\n\\tsum = 9   \\n\\tbag=[2,3,4]\\n\\tmin_bag[3] = 9\\n\\t```\\n6. Now, 6 is the current element which is larger than the largest element in the bag i.e. 7 so optimally we don\\'t do anything here.\\n\\t```\\n\\tsum = 9   \\n\\tbag=[2,3,4]\\n\\tmin_bag[3] = 9\\n\\t```\\n7. Repeat the steps till the second last element.\\n```\\n// After all iterations\\nsum = 9   \\nbag=[2,3,4]\\nmin_bag = [inf,inf,13,9,6,6,6]\\n```\\n\\n<img src=\"https://assets.leetcode.com/users/images/899c7f14-0554-4779-8578-f5751d49a9b1_1644223995.4834244.gif\" alt=\"image\" width=\"400\"/>\\n\\nSimilarly we find the `max_bag` for every `i` starting from the last element to the second element `A[n] -> A[2]` and pop elements from the bag if we find a larger element than the one present in the bag.\\nFor unfilled bag, we set it as a very small value.\\n```\\n// After all iterations\\nmax_bag = [19,19,19,19,19,15,-inf,-inf]\\n```\\n\\nThe subarray sum differences for every partition:\\n```\\nmin_bag = [inf,inf,13,9,6,6,6,6]        max_bag = [19,19,19,19,19,15,-inf,-inf]\\nmin_bag[0] - max_bag[0] = inf\\nmin_bag[1] - max_bag[1] = inf\\nmin_bag[2] - max_bag[2] = -6\\nmin_bag[3] - max_bag[3] = -10\\nmin_bag[4] - max_bag[4] = -13 (Desired output)\\nmin_bag[5] - max_bag[5] = -9\\nmin_bag[6] - max_bag[6] = inf\\nmin_bag[7] - max_bag[7] = inf\\n```\\n\\nThe bag concept can be implemented using a priority_queue.\\n\\n**C++ Code**\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0, first[n-1], second[n-1];\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        // calculating minimum sum of n elements in first subpart\\n        for(int i=0; i<n-1; i++) {\\n            \\n            // if we come across a smaller element and\\n            // our bag is already filled, we remove\\n            // the largest element from the bag and insert\\n            // the smaller element\\n            if(pq1.size() == n/3) {\\n                if(pq1.top() > nums[i]) {\\n                    sum -= pq1.top() - nums[i];\\n                    pq1.pop();\\n                    pq1.push(nums[i]);\\n                }\\n            } \\n            \\n            // we add the element if our bag is not filled\\n            else {\\n                pq1.push(nums[i]);\\n                sum += nums[i];\\n            }\\n            \\n            // set sum for unfilled bag as a huge value\\n            if(pq1.size()<n/3) first[i] = LLONG_MAX/10;\\n            else first[i] = sum;\\n        }\\n        \\n        // calculating maximum sum of n elements in second subpart\\n        sum = 0;\\n        for(int i=n-1; i>=1; i--) {\\n            \\n            // if we come across a larger element and\\n            // our bag is already filled, we remove\\n            // the smallest element from the bag and insert\\n            // the larger element\\n            if(pq2.size() == n/3) {\\n                if(pq2.top() < nums[i]) {\\n                    sum -= pq2.top() - nums[i];\\n                    pq2.pop();\\n                    pq2.push(nums[i]);\\n                }\\n            } \\n            \\n            // we add the element if our bag is not filled\\n            else {\\n                pq2.push(nums[i]);\\n                sum += nums[i];\\n            }\\n            \\n            // set sum for unfilled bag as a very low value\\n            if(pq2.size()<n/3) second[i-1] = LLONG_MIN/10;\\n            else second[i-1] = sum;\\n        }\\n        \\n        for(int i=0; i<n-1; i++) {\\n            sum = min(sum, first[i] - second[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```\\nDo **upvote** the post if you liked the explanation.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tsum = 7   \\n\\tbag=[7]\\n\\t```\n```\\n\\tsum = 7  \\n\\tbag=[7]\\n\\tmin_bag[0] = INF\\n\\t```\n```\\n\\tsum = 9   \\n\\tbag=[2,7]\\n\\tmin_bag[1] = INF\\n\\t```\n```\\n\\tsum = 13   \\n\\tbag=[2,4,7]\\n\\tmin_bag[2] = 13\\n\\t```\n```\\n\\tsum = 9   \\n\\tbag=[2,3,4]\\n\\tmin_bag[3] = 9\\n\\t```\n```\\n\\tsum = 9   \\n\\tbag=[2,3,4]\\n\\tmin_bag[3] = 9\\n\\t```\n```\\n// After all iterations\\nsum = 9   \\nbag=[2,3,4]\\nmin_bag = [inf,inf,13,9,6,6,6]\\n```\n```\\n// After all iterations\\nmax_bag = [19,19,19,19,19,15,-inf,-inf]\\n```\n```\\nmin_bag = [inf,inf,13,9,6,6,6,6]        max_bag = [19,19,19,19,19,15,-inf,-inf]\\nmin_bag[0] - max_bag[0] = inf\\nmin_bag[1] - max_bag[1] = inf\\nmin_bag[2] - max_bag[2] = -6\\nmin_bag[3] - max_bag[3] = -10\\nmin_bag[4] - max_bag[4] = -13 (Desired output)\\nmin_bag[5] - max_bag[5] = -9\\nmin_bag[6] - max_bag[6] = inf\\nmin_bag[7] - max_bag[7] = inf\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0, first[n-1], second[n-1];\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        // calculating minimum sum of n elements in first subpart\\n        for(int i=0; i<n-1; i++) {\\n            \\n            // if we come across a smaller element and\\n            // our bag is already filled, we remove\\n            // the largest element from the bag and insert\\n            // the smaller element\\n            if(pq1.size() == n/3) {\\n                if(pq1.top() > nums[i]) {\\n                    sum -= pq1.top() - nums[i];\\n                    pq1.pop();\\n                    pq1.push(nums[i]);\\n                }\\n            } \\n            \\n            // we add the element if our bag is not filled\\n            else {\\n                pq1.push(nums[i]);\\n                sum += nums[i];\\n            }\\n            \\n            // set sum for unfilled bag as a huge value\\n            if(pq1.size()<n/3) first[i] = LLONG_MAX/10;\\n            else first[i] = sum;\\n        }\\n        \\n        // calculating maximum sum of n elements in second subpart\\n        sum = 0;\\n        for(int i=n-1; i>=1; i--) {\\n            \\n            // if we come across a larger element and\\n            // our bag is already filled, we remove\\n            // the smallest element from the bag and insert\\n            // the larger element\\n            if(pq2.size() == n/3) {\\n                if(pq2.top() < nums[i]) {\\n                    sum -= pq2.top() - nums[i];\\n                    pq2.pop();\\n                    pq2.push(nums[i]);\\n                }\\n            } \\n            \\n            // we add the element if our bag is not filled\\n            else {\\n                pq2.push(nums[i]);\\n                sum += nums[i];\\n            }\\n            \\n            // set sum for unfilled bag as a very low value\\n            if(pq2.size()<n/3) second[i-1] = LLONG_MIN/10;\\n            else second[i-1] = sum;\\n        }\\n        \\n        for(int i=0; i<n-1; i++) {\\n            sum = min(sum, first[i] - second[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751408,
                "title": "java-concise-java-beating-100",
                "content": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        long ans = Long.MAX_VALUE;\\n        int n = nums.length/3;\\n        long minSum = 0, maxSum = 0;\\n        \\n        PriorityQueue<Integer> maxq = new PriorityQueue<>((a, b) -> nums[b] - nums[a]);\\n        PriorityQueue<Integer> minq = new PriorityQueue<>((a, b) -> nums[a] - nums[b]);\\n        \\n        for (int i = 0; i < n; i++) { maxq.add(i); minSum += nums[i]; }\\n        for (int i = 3*n - 1; i >= 2 * n; i--) { minq.add(i); maxSum += nums[i]; }\\n        \\n        long[] left = new long[n + 1]; left[0] = minSum;\\n        long[] right = new long[n + 1]; right[n] = maxSum;\\n        \\n        for (int i = n; i < 2 * n; i++) {\\n            if (nums[i] < nums[maxq.peek()]) {\\n                minSum = minSum - nums[maxq.poll()] + nums[i];\\n                maxq.add(i);\\n            }\\n            left[i - n + 1] = minSum;\\n        }\\n        \\n        for (int i = 2*n - 1; i >= n; i--) {\\n            if (nums[i] > nums[minq.peek()]) {\\n                maxSum = maxSum - nums[minq.poll()] + nums[i];\\n                minq.add(i);\\n            }\\n            right[i - n] = maxSum;\\n        }\\n        \\n        for (int i = 0; i <= n; i++) ans = Math.min(ans, left[i] - right[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        long ans = Long.MAX_VALUE;\\n        int n = nums.length/3;\\n        long minSum = 0, maxSum = 0;\\n        \\n        PriorityQueue<Integer> maxq = new PriorityQueue<>((a, b) -> nums[b] - nums[a]);\\n        PriorityQueue<Integer> minq = new PriorityQueue<>((a, b) -> nums[a] - nums[b]);\\n        \\n        for (int i = 0; i < n; i++) { maxq.add(i); minSum += nums[i]; }\\n        for (int i = 3*n - 1; i >= 2 * n; i--) { minq.add(i); maxSum += nums[i]; }\\n        \\n        long[] left = new long[n + 1]; left[0] = minSum;\\n        long[] right = new long[n + 1]; right[n] = maxSum;\\n        \\n        for (int i = n; i < 2 * n; i++) {\\n            if (nums[i] < nums[maxq.peek()]) {\\n                minSum = minSum - nums[maxq.poll()] + nums[i];\\n                maxq.add(i);\\n            }\\n            left[i - n + 1] = minSum;\\n        }\\n        \\n        for (int i = 2*n - 1; i >= n; i--) {\\n            if (nums[i] > nums[minq.peek()]) {\\n                maxSum = maxSum - nums[minq.poll()] + nums[i];\\n                minq.add(i);\\n            }\\n            right[i - n] = maxSum;\\n        }\\n        \\n        for (int i = 0; i <= n; i++) ans = Math.min(ans, left[i] - right[i]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750867,
                "title": "java-min-max-heaps-calculate-optimal-subsequences-for-every-split-point",
                "content": "The aim is to end up with two subsequences - left with smallest possible sum, right with largest.\\nThe possible split point lies in range [n..2n] - there are n+1 options possible.\\nCalculate min left sum and max right sum for each split point (using heaps), then pick the min difference.\\n```\\npublic long minimumDifference(int[] nums) {\\n\\tint n3= nums.length, n= n3/3, n2= 2*n;\\n\\n\\t//minLSum[i] == minimum sum of subsequence of size n in subarray of nums[0..n+i-1]\\n\\tlong[] minLSum= new long[n+1];\\n\\tlong lSum= 0;\\n\\tPriorityQueue<Integer> lPq= new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tlSum+= nums[i];\\n\\t\\tlPq.offer(nums[i]);\\n\\t}\\n\\tminLSum[0]= lSum;\\n\\tfor(int i=n; i<n2; i++){\\n\\t\\tif(nums[i]<lPq.peek()){\\n\\t\\t\\tlSum+= nums[i]-lPq.poll();\\n\\t\\t\\tlPq.offer(nums[i]);\\n\\t\\t}\\n\\t\\tminLSum[i+1-n]= lSum;            \\n\\t}\\n\\n\\t//maxRSum[i] == maximum sum of subsequence of size n in subarray of nums[n+i...n3]\\n\\tlong[] maxRSum= new long[n+1];\\n\\tlong rSum= 0;\\n\\tPriorityQueue<Integer> rPq= new PriorityQueue<>();\\n\\tfor(int i=n2; i<n3; i++){\\n\\t\\trSum+= nums[i];\\n\\t\\trPq.offer(nums[i]);\\n\\t}\\n\\tmaxRSum[n]= rSum;\\n\\tfor(int i=n2-1; i>=n; i--){\\n\\t\\tif(nums[i]>rPq.peek()){\\n\\t\\t\\trSum+= nums[i]-rPq.poll();\\n\\t\\t\\trPq.offer(nums[i]);\\n\\t\\t}\\n\\t\\tmaxRSum[i-n]= rSum;            \\n\\t}\\n\\n\\tlong ans= Long.MAX_VALUE;\\n\\t//pick minimum diff\\n\\tfor(int i=0; i<=n; i++){\\n\\t\\tans= Math.min(ans, minLSum[i]-maxRSum[i]);\\n\\t}\\n\\treturn ans;\\n}",
                "solutionTags": [],
                "code": "The aim is to end up with two subsequences - left with smallest possible sum, right with largest.\\nThe possible split point lies in range [n..2n] - there are n+1 options possible.\\nCalculate min left sum and max right sum for each split point (using heaps), then pick the min difference.\\n```\\npublic long minimumDifference(int[] nums) {\\n\\tint n3= nums.length, n= n3/3, n2= 2*n;\\n\\n\\t//minLSum[i] == minimum sum of subsequence of size n in subarray of nums[0..n+i-1]\\n\\tlong[] minLSum= new long[n+1];\\n\\tlong lSum= 0;\\n\\tPriorityQueue<Integer> lPq= new PriorityQueue<>(Collections.reverseOrder());\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tlSum+= nums[i];\\n\\t\\tlPq.offer(nums[i]);\\n\\t}\\n\\tminLSum[0]= lSum;\\n\\tfor(int i=n; i<n2; i++){\\n\\t\\tif(nums[i]<lPq.peek()){\\n\\t\\t\\tlSum+= nums[i]-lPq.poll();\\n\\t\\t\\tlPq.offer(nums[i]);\\n\\t\\t}\\n\\t\\tminLSum[i+1-n]= lSum;            \\n\\t}\\n\\n\\t//maxRSum[i] == maximum sum of subsequence of size n in subarray of nums[n+i...n3]\\n\\tlong[] maxRSum= new long[n+1];\\n\\tlong rSum= 0;\\n\\tPriorityQueue<Integer> rPq= new PriorityQueue<>();\\n\\tfor(int i=n2; i<n3; i++){\\n\\t\\trSum+= nums[i];\\n\\t\\trPq.offer(nums[i]);\\n\\t}\\n\\tmaxRSum[n]= rSum;\\n\\tfor(int i=n2-1; i>=n; i--){\\n\\t\\tif(nums[i]>rPq.peek()){\\n\\t\\t\\trSum+= nums[i]-rPq.poll();\\n\\t\\t\\trPq.offer(nums[i]);\\n\\t\\t}\\n\\t\\tmaxRSum[i-n]= rSum;            \\n\\t}\\n\\n\\tlong ans= Long.MAX_VALUE;\\n\\t//pick minimum diff\\n\\tfor(int i=0; i<=n; i++){\\n\\t\\tans= Math.min(ans, minLSum[i]-maxRSum[i]);\\n\\t}\\n\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1750325,
                "title": "c-solution-using-priority-queue",
                "content": "\\n        long long minimumDifference(vector<int>& nums) {\\n        long long ans = LLONG_MAX ;\\n        priority_queue<int>q;\\n        priority_queue<int,vector<int>,greater<int>>p;\\n        int n = nums.size()/3;\\n        long long rsum = 0;\\n        vector<long long>pref(nums.size(),0);\\n        for(int i=nums.size()-1;i>=n;i--){\\n            rsum+=nums[i];\\n            p.push(nums[i]);\\n            if(p.size()>n){\\n                rsum-=p.top();\\n                p.pop();\\n            }\\n            pref[i] = rsum;\\n        }\\n        long long lsum = 0;\\n        for(int i=0;i<nums.size()-n;i++){\\n            lsum+=nums[i];  \\n            q.push(nums[i]);\\n            if(i>=n-1){\\n                if(q.size()>n){\\n                    lsum-=q.top();\\n                    q.pop();\\n                }\\n                ans = min(ans,lsum-pref[i+1]);\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n        long long minimumDifference(vector<int>& nums) {\\n        long long ans = LLONG_MAX ;\\n        priority_queue<int>q;\\n        priority_queue<int,vector<int>,greater<int>>p;\\n        int n = nums.size()/3;\\n        long long rsum = 0;\\n        vector<long long>pref(nums.size(),0);\\n        for(int i=nums.size()-1;i>=n;i--){\\n            rsum+=nums[i];\\n            p.push(nums[i]);\\n            if(p.size()>n){\\n                rsum-=p.top();\\n                p.pop();\\n            }\\n            pref[i] = rsum;\\n        }\\n        long long lsum = 0;\\n        for(int i=0;i<nums.size()-n;i++){\\n            lsum+=nums[i];  \\n            q.push(nums[i]);\\n            if(i>=n-1){\\n                if(q.size()>n){\\n                    lsum-=q.top();\\n                    q.pop();\\n                }\\n                ans = min(ans,lsum-pref[i+1]);\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749592,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int t = nums.size();\\n       int n = t/3;\\n       priority_queue<int> l;\\n       priority_queue<int, vector<int>, greater<int>> r;\\n       vector<long long> v(t);\\n       long long right = 0, left = 0;\\n       long long ans = LLONG_MAX;\\n       for(int i=t-1; i>=n; i--)\\n       {\\n          r.push(nums[i]);\\n          right += nums[i];\\n          if(r.size() > n)\\n          {\\n             right -= r.top();\\n                  r.pop();\\n          }\\n          if(r.size() == n)\\n                  v[i] = right;\\n       }\\n            \\n      for(int i=0; i<t-n; i++)\\n      {\\n          l.push(nums[i]);\\n          left += nums[i];\\n           if(l.size() > n)\\n           {\\n             left -=l.top();\\n             l.pop();\\n           }\\n           if(l.size() == n)\\n           {\\n             ans = min(ans, left - v[i+1]);\\n           }\\n      }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int t = nums.size();\\n       int n = t/3;\\n       priority_queue<int> l;\\n       priority_queue<int, vector<int>, greater<int>> r;\\n       vector<long long> v(t);\\n       long long right = 0, left = 0;\\n       long long ans = LLONG_MAX;\\n       for(int i=t-1; i>=n; i--)\\n       {\\n          r.push(nums[i]);\\n          right += nums[i];\\n          if(r.size() > n)\\n          {\\n             right -= r.top();\\n                  r.pop();\\n          }\\n          if(r.size() == n)\\n                  v[i] = right;\\n       }\\n            \\n      for(int i=0; i<t-n; i++)\\n      {\\n          l.push(nums[i]);\\n          left += nums[i];\\n           if(l.size() > n)\\n           {\\n             left -=l.top();\\n             l.pop();\\n           }\\n           if(l.size() == n)\\n           {\\n             ans = min(ans, left - v[i+1]);\\n           }\\n      }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748372,
                "title": "explanations-of-the-thought-process",
                "content": "I started by wondering if Dynamic Programming could be used for this problem. I quickly decided not to go down that line because the constraints are big. I quickly asked myself if it would be possible to binary search but stopped thinking of that as it is not necessarily monotonic and no easy way to check. \\n\\nIn any problem, it is always important to ask, \"How to iterate over all possibilities ?\" \\nOne way is obviously to iterate over all ways of deleteing N elements. This is C(3n, n). \\nBut, there is another way in which we can iterate over all possibilities. \\n\\nWe can notice that all members of the first sequence should be chosen before the first member of the second sequence. Let us iterate over the final position of the first sequence. \\n\\nIn other words, let us fix i. \\nLet us ensure that all members of the first sequence are in [1, i] and all members of the second sequence are in [i + 1, N] \\nNow, we only need to check N points and this helps us iterate over all the significant possibilities. \\n\\nWhen we fix an i and need to choose the first sequence in [1, i], we need to choose the minimum N elements for the first sequence and the maximum N elements in the second sequence. \\n\\nWe can do both of this with a heap. \\n\\n----\\n\\nMaintain the invariant that the maximum heap always contains the N smallest elements. \\nWhen we move from (i - 1) to i, check if A[i] is smaller than the top of the heap\\nIf yes, we can get a smaller sum by including A[i].\\n\\n----\\n\\nMore of my solutions along with explanation are available[ here](https://github.com/MathProgrammer/LeetCode/tree/master/Contests/Biweekly%20Contest%2071)More of my solutions along with explanation are available[ here](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int> &A) \\n    {\\n        priority_queue <long long, vector <long long>, greater <long long>> PQ; \\n        int n = A.size()/3;\\n        \\n        long long sum = 0;\\n        vector <long long> maximum_sum(A.size() + 1, 0);\\n        for(int i = A.size() - 1; i >= 0; i--)\\n        {\\n            if(PQ.size() < n)\\n            {\\n                PQ.push(A[i]);\\n                sum += A[i];\\n            }\\n            else if(PQ.size() == n)\\n            {\\n                if(PQ.top() < A[i])\\n                {\\n                    sum -= PQ.top(); \\n                    PQ.pop(); \\n                    PQ.push(A[i]);\\n                    sum += A[i];\\n                }\\n            }\\n            \\n            maximum_sum[i] = sum;\\n        }\\n        \\n        const long long oo = 1e14; \\n        sum = 0;\\n        vector <long long> minimum_sum(A.size() + 1, oo);\\n        priority_queue <long long > min_PQ;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(min_PQ.size() < n)\\n            {\\n                min_PQ.push(A[i]);\\n                sum += A[i]; \\n            }\\n            else if(min_PQ.size() == n)\\n            {\\n                if(min_PQ.top() > A[i])\\n                {\\n                    sum -= min_PQ.top(); \\n                    min_PQ.pop(); \\n                    min_PQ.push(A[i]);\\n                    sum += A[i];\\n                }\\n            }\\n            \\n            minimum_sum[i] = sum;\\n        }\\n        \\n        long long answer = oo;\\n        \\n        for(int i = n - 1; i < 2*n; i++)\\n        {\\n            answer = min(answer, minimum_sum[i] - maximum_sum[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int> &A) \\n    {\\n        priority_queue <long long, vector <long long>, greater <long long>> PQ; \\n        int n = A.size()/3;\\n        \\n        long long sum = 0;\\n        vector <long long> maximum_sum(A.size() + 1, 0);\\n        for(int i = A.size() - 1; i >= 0; i--)\\n        {\\n            if(PQ.size() < n)\\n            {\\n                PQ.push(A[i]);\\n                sum += A[i];\\n            }\\n            else if(PQ.size() == n)\\n            {\\n                if(PQ.top() < A[i])\\n                {\\n                    sum -= PQ.top(); \\n                    PQ.pop(); \\n                    PQ.push(A[i]);\\n                    sum += A[i];\\n                }\\n            }\\n            \\n            maximum_sum[i] = sum;\\n        }\\n        \\n        const long long oo = 1e14; \\n        sum = 0;\\n        vector <long long> minimum_sum(A.size() + 1, oo);\\n        priority_queue <long long > min_PQ;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(min_PQ.size() < n)\\n            {\\n                min_PQ.push(A[i]);\\n                sum += A[i]; \\n            }\\n            else if(min_PQ.size() == n)\\n            {\\n                if(min_PQ.top() > A[i])\\n                {\\n                    sum -= min_PQ.top(); \\n                    min_PQ.pop(); \\n                    min_PQ.push(A[i]);\\n                    sum += A[i];\\n                }\\n            }\\n            \\n            minimum_sum[i] = sum;\\n        }\\n        \\n        long long answer = oo;\\n        \\n        for(int i = n - 1; i < 2*n; i++)\\n        {\\n            answer = min(answer, minimum_sum[i] - maximum_sum[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747437,
                "title": "cpp-max-heap-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    // EXPLANATION:\\n    \\n    // 1st stored the first n/3 elements into the max heap p1 and last n/3 elements into the min heap p2\\n    \\n    // Then just traversed the n/3 elements which were there in the middle\\n    // stored the sum of the minimum n/3 elements into vector v1\\n \\n    // Again traversed the n/3 elements which were there in the middle from the backside\\n    // stored the sum of the maximum n/3 elements into vector v2\\n    \\n\\t// Reversed v2\\n\\t\\n    // then just calculated the min difference\\n    \\n    // If u like the explanation, Kindly do upvote:)\\n    \\n    \\n    #define ll long long\\n    long long minimumDifference(vector<int>& arr) {\\n        priority_queue <ll, vector<ll>, greater<ll> >p2;\\n        priority_queue <ll> p1;\\n        ll n=arr.size()/3;\\n        ll s1=0,s2=0;\\n        for(ll i=0;i<n;i++){\\n            p1.push(arr[i]);\\n            s1+=arr[i];\\n        }\\n        for(ll i=2*n;i<arr.size();i++){\\n            p2.push(arr[i]);\\n            s2+=arr[i];\\n        }\\n        vector<ll>v1,v2;\\n        v1.push_back(s1);\\n        for(ll i=n;i<2*n;i++){\\n            ll k=p1.top();\\n            p1.pop();\\n            if(k>arr[i]){p1.push(arr[i]); s1-=k; s1+=arr[i];}\\n            else {p1.push(k); }\\n            v1.push_back(s1);\\n        }\\n        v2.push_back(s2);\\n        for(ll i=2*n-1;i>=n;i--){\\n            ll k=p2.top();\\n            p2.pop();\\n            if(k<arr[i]){p2.push(arr[i]); s2-=k; s2+=arr[i];}\\n            else {p2.push(k); }\\n            v2.push_back(s2);\\n        }\\n        reverse(v2.begin(),v2.end());\\n        ll ans=99999999999999;\\n        for(ll i=0;i<v1.size();i++){\\n            ans=min(ans,v1[i]-v2[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    // Please do ask your doubt in the comment section\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // EXPLANATION:\\n    \\n    // 1st stored the first n/3 elements into the max heap p1 and last n/3 elements into the min heap p2\\n    \\n    // Then just traversed the n/3 elements which were there in the middle\\n    // stored the sum of the minimum n/3 elements into vector v1\\n \\n    // Again traversed the n/3 elements which were there in the middle from the backside\\n    // stored the sum of the maximum n/3 elements into vector v2\\n    \\n\\t// Reversed v2\\n\\t\\n    // then just calculated the min difference\\n    \\n    // If u like the explanation, Kindly do upvote:)\\n    \\n    \\n    #define ll long long\\n    long long minimumDifference(vector<int>& arr) {\\n        priority_queue <ll, vector<ll>, greater<ll> >p2;\\n        priority_queue <ll> p1;\\n        ll n=arr.size()/3;\\n        ll s1=0,s2=0;\\n        for(ll i=0;i<n;i++){\\n            p1.push(arr[i]);\\n            s1+=arr[i];\\n        }\\n        for(ll i=2*n;i<arr.size();i++){\\n            p2.push(arr[i]);\\n            s2+=arr[i];\\n        }\\n        vector<ll>v1,v2;\\n        v1.push_back(s1);\\n        for(ll i=n;i<2*n;i++){\\n            ll k=p1.top();\\n            p1.pop();\\n            if(k>arr[i]){p1.push(arr[i]); s1-=k; s1+=arr[i];}\\n            else {p1.push(k); }\\n            v1.push_back(s1);\\n        }\\n        v2.push_back(s2);\\n        for(ll i=2*n-1;i>=n;i--){\\n            ll k=p2.top();\\n            p2.pop();\\n            if(k<arr[i]){p2.push(arr[i]); s2-=k; s2+=arr[i];}\\n            else {p2.push(k); }\\n            v2.push_back(s2);\\n        }\\n        reverse(v2.begin(),v2.end());\\n        ll ans=99999999999999;\\n        for(ll i=0;i<v1.size();i++){\\n            ans=min(ans,v1[i]-v2[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    // Please do ask your doubt in the comment section\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747399,
                "title": "python-3-sortedlist-solution-time-o-nlogn-space-o-n-equivalent-to-2-heaps",
                "content": "This implementation uses the `SortedList` class in [Python](http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html#sortedcontainers.SortedList.bisect_right), which is equivalent to using 2 heaps (1 max-heap and 1 min-heap).\\n* Time complexity: `O(NlogN)`, as `SortedList` supports add and remove elements in `O(logN)` time.\\n* Space complexity: `O(N)`.\\n\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        # Python solution using SortedList, time complexity O(nlogn), space complexity O(n)\\n        n = len(nums) // 3\\n\\t\\t\\n        from sortedcontainers import SortedList\\n        leftArr = SortedList(nums[ : n])\\n        rightArr = SortedList(nums[n : ])\\n\\t\\t\\n        # leftSum is the minimum subsequence sum of leftArr, rightSum is the maximum subsequence sum of rightArr\\n        leftSum, rightSum = sum(leftArr), sum(rightArr[n : ])\\n        minDiff = leftSum - rightSum\\n\\t\\t\\n        for i in range(n, n * 2):\\n            # if nums[i] belongs to the n smallest values of leftArr, thus leftSum needs to be updated\\n            if nums[i] < leftArr[-1]:\\n                leftSum += nums[i] - leftArr[-1]\\n            leftArr.add(nums[i])\\n            leftArr.pop(-1)\\n\\t\\t\\t\\n            # if nums[i] belongs to the n largest values of rightArr, thus rightSum needs to be updated\\n            if rightArr.bisect_left(nums[i]) - len(rightArr) >= -n:\\n                rightSum += rightArr[-(n + 1)] - nums[i]\\n            rightArr.remove(nums[i])\\n\\t\\t\\t\\n            minDiff = min(minDiff, leftSum - rightSum)\\n\\t\\t\\t\\n        return minDiff\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        # Python solution using SortedList, time complexity O(nlogn), space complexity O(n)\\n        n = len(nums) // 3\\n\\t\\t\\n        from sortedcontainers import SortedList\\n        leftArr = SortedList(nums[ : n])\\n        rightArr = SortedList(nums[n : ])\\n\\t\\t\\n        # leftSum is the minimum subsequence sum of leftArr, rightSum is the maximum subsequence sum of rightArr\\n        leftSum, rightSum = sum(leftArr), sum(rightArr[n : ])\\n        minDiff = leftSum - rightSum\\n\\t\\t\\n        for i in range(n, n * 2):\\n            # if nums[i] belongs to the n smallest values of leftArr, thus leftSum needs to be updated\\n            if nums[i] < leftArr[-1]:\\n                leftSum += nums[i] - leftArr[-1]\\n            leftArr.add(nums[i])\\n            leftArr.pop(-1)\\n\\t\\t\\t\\n            # if nums[i] belongs to the n largest values of rightArr, thus rightSum needs to be updated\\n            if rightArr.bisect_left(nums[i]) - len(rightArr) >= -n:\\n                rightSum += rightArr[-(n + 1)] - nums[i]\\n            rightArr.remove(nums[i])\\n\\t\\t\\t\\n            minDiff = min(minDiff, leftSum - rightSum)\\n\\t\\t\\t\\n        return minDiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036288,
                "title": "c-easy-solution-min-and-max-heap",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        #define ll long long\\n        int n=nums.size()/3;\\n        vector<ll>prefix(nums.size(),-1), surffix(nums.size(),-1);\\n        priority_queue<ll>pq;\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n            if(pq.size()>n)\\n            {\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==n)\\n            {\\n                prefix[i]=sum;\\n            }\\n        }\\n        sum=0;\\n        priority_queue<ll,vector<ll>,greater<ll>>pq2;\\n          for(int i=nums.size()-1;i>0;i--)\\n        {\\n            sum+=nums[i];\\n            pq2.push(nums[i]);\\n            if(pq2.size()>n)\\n            {\\n                sum-=pq2.top();\\n                pq2.pop();\\n            }\\n            if(pq.size()==n)\\n            {\\n                surffix[i]=sum;\\n            }\\n        }\\n        ll ans=LONG_LONG_MAX;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n            ans=min(ans,prefix[i]-surffix[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        #define ll long long\\n        int n=nums.size()/3;\\n        vector<ll>prefix(nums.size(),-1), surffix(nums.size(),-1);\\n        priority_queue<ll>pq;\\n        ll sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n            if(pq.size()>n)\\n            {\\n                sum-=pq.top();\\n                pq.pop();\\n            }\\n            if(pq.size()==n)\\n            {\\n                prefix[i]=sum;\\n            }\\n        }\\n        sum=0;\\n        priority_queue<ll,vector<ll>,greater<ll>>pq2;\\n          for(int i=nums.size()-1;i>0;i--)\\n        {\\n            sum+=nums[i];\\n            pq2.push(nums[i]);\\n            if(pq2.size()>n)\\n            {\\n                sum-=pq2.top();\\n                pq2.pop();\\n            }\\n            if(pq.size()==n)\\n            {\\n                surffix[i]=sum;\\n            }\\n        }\\n        ll ans=LONG_LONG_MAX;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n            ans=min(ans,prefix[i]-surffix[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004426,
                "title": "commented-code-for-explanation-c-2-pq-prefix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n\\n        //ans=min(leftsum) - max(rightsum)\\n        //in queue maintain sums of left and right part\\n        // use prefix array to maintain sum so that elements from left or right part dont get jumbled\\n        priority_queue<long long> pql;\\n        priority_queue<long long, vector<long long>, greater<long long>> pqr;\\n\\n        long long n = nums.size(), s = 0, sum = 0;\\n\\n        //left sum\\n        for (int i = 0; i < n / 3; i++) {\\n            pql.push(nums[i]);\\n            s += nums[i];\\n        }\\n        \\n        //right sum\\n        for (int i = 2 * (n / 3); i < n; i++) {\\n            pqr.push(nums[i]);\\n            sum += nums[i];\\n        }\\n\\n        //prefix array\\n        long long maxi = sum, mini = s;\\n        vector<long long> vr(n, 0);\\n        vr[2 * (n / 3)] = maxi;\\n        for (int i = 2 * (n / 3) - 1; i >= n / 3; i--) {\\n            pqr.push(nums[i]);\\n            long long t = pqr.top();\\n            pqr.pop();\\n            sum -= t;\\n            sum += nums[i];\\n            maxi = max(maxi, sum);\\n            vr[i] = maxi;\\n        }\\n\\n        //ans=min(leftsum) - max(rightsum)\\n        long long ans = LONG_MAX;\\n        ans = min(ans, s - vr[(n / 3)]);\\n        for (int i = n / 3; i < 2 * (n / 3); i++) {\\n            pql.push(nums[i]);\\n            long long t = pql.top();\\n            pql.pop();\\n            s -= t;\\n            s += nums[i];\\n            mini = min(mini, s);\\n            ans = min(ans, mini - vr[i + 1]);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n\\n        //ans=min(leftsum) - max(rightsum)\\n        //in queue maintain sums of left and right part\\n        // use prefix array to maintain sum so that elements from left or right part dont get jumbled\\n        priority_queue<long long> pql;\\n        priority_queue<long long, vector<long long>, greater<long long>> pqr;\\n\\n        long long n = nums.size(), s = 0, sum = 0;\\n\\n        //left sum\\n        for (int i = 0; i < n / 3; i++) {\\n            pql.push(nums[i]);\\n            s += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3994239,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long minimumDifference(vector<int>& nums) {\\n    const int n = nums.size() / 3;\\n    long long ans = LLONG_MAX;\\n    long long leftSum = 0;\\n    long long rightSum = 0;\\n    // Left part as small as possible\\n    priority_queue<int> maxHeap;\\n    // Right part as big as possible\\n    priority_queue<int, vector<int>, greater<>> minHeap;\\n    // minLeftSum[i] := min sum of n nums in nums[:i]\\n    vector<long long> minLeftSum(nums.size());\\n\\n    for (int i = 0; i < 2 * n; ++i) {\\n      maxHeap.push(nums[i]);\\n      leftSum += nums[i];\\n      if (maxHeap.size() == n + 1)\\n        leftSum -= maxHeap.top(), maxHeap.pop();\\n      if (maxHeap.size() == n)\\n        minLeftSum[i] = leftSum;\\n    }\\n\\n    for (int i = nums.size() - 1; i >= n; --i) {\\n      minHeap.push(nums[i]);\\n      rightSum += nums[i];\\n      if (minHeap.size() == n + 1)\\n        rightSum -= minHeap.top(), minHeap.pop();\\n      if (minHeap.size() == n)\\n        ans = min(ans, minLeftSum[i - 1] - rightSum);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long minimumDifference(vector<int>& nums) {\\n    const int n = nums.size() / 3;\\n    long long ans = LLONG_MAX;\\n    long long leftSum = 0;\\n    long long rightSum = 0;\\n    // Left part as small as possible\\n    priority_queue<int> maxHeap;\\n    // Right part as big as possible\\n    priority_queue<int, vector<int>, greater<>> minHeap;\\n    // minLeftSum[i] := min sum of n nums in nums[:i]\\n    vector<long long> minLeftSum(nums.size());\\n\\n    for (int i = 0; i < 2 * n; ++i) {\\n      maxHeap.push(nums[i]);\\n      leftSum += nums[i];\\n      if (maxHeap.size() == n + 1)\\n        leftSum -= maxHeap.top(), maxHeap.pop();\\n      if (maxHeap.size() == n)\\n        minLeftSum[i] = leftSum;\\n    }\\n\\n    for (int i = nums.size() - 1; i >= n; --i) {\\n      minHeap.push(nums[i]);\\n      rightSum += nums[i];\\n      if (minHeap.size() == n + 1)\\n        rightSum -= minHeap.top(), minHeap.pop();\\n      if (minHeap.size() == n)\\n        ans = min(ans, minLeftSum[i - 1] - rightSum);\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961241,
                "title": "using-max-heap-and-min-heap-tc-o-n-logn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long sum = 0;\\n        int n = nums.size()/3;\\n        vector<long long> prefix(nums.size(),-1);\\n        vector<long long> suffix(nums.size(),-1);\\n\\n        priority_queue<long long> maxHeap;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            maxHeap.push(nums[i]);\\n\\n            if(maxHeap.size() > n){\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            if(maxHeap.size() == n)\\n                prefix[i] = sum;\\n        }\\n        sum = 0;\\n\\n        priority_queue<long long,vector<long long>,greater<long long>> minHeap;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            sum += nums[i];\\n            minHeap.push(nums[i]);\\n\\n            if(minHeap.size() > n){\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            if(minHeap.size() == n)\\n                suffix[i] = sum;\\n        }\\n\\n        long long ans = LONG_LONG_MAX;\\n        for(int i = n-1; i < 2*n; i++)\\n            ans = min(ans,prefix[i]-suffix[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long sum = 0;\\n        int n = nums.size()/3;\\n        vector<long long> prefix(nums.size(),-1);\\n        vector<long long> suffix(nums.size(),-1);\\n\\n        priority_queue<long long> maxHeap;\\n        for(int i = 0; i < nums.size(); i++){\\n            sum += nums[i];\\n            maxHeap.push(nums[i]);\\n\\n            if(maxHeap.size() > n){\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n            }\\n            if(maxHeap.size() == n)\\n                prefix[i] = sum;\\n        }\\n        sum = 0;\\n\\n        priority_queue<long long,vector<long long>,greater<long long>> minHeap;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            sum += nums[i];\\n            minHeap.push(nums[i]);\\n\\n            if(minHeap.size() > n){\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n            }\\n            if(minHeap.size() == n)\\n                suffix[i] = sum;\\n        }\\n\\n        long long ans = LONG_LONG_MAX;\\n        for(int i = n-1; i < 2*n; i++)\\n            ans = min(ans,prefix[i]-suffix[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898751,
                "title": "python3-c-priority-queue",
                "content": "# Intuition\\n`min(min_left[i] - max_right[i] | i = n, n+1, ... 2*n - 1, 2*n)`\\n\\n# Approach\\nPlease refer to [this great post](https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/solutions/1747003/python-o-nlogn-priority-queue-with-detailed-explanation/)\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        pq_mx = [-nums[i] for i in range(n)]\\n        heapq.heapify(pq_mx)\\n        mn_ss = -sum(pq_mx)\\n        mn_arr = [mn_ss] * (n+1)\\n\\n        for i in range(n, 2*n):\\n            if nums[i] < -pq_mx[0]:\\n                mx = heapq.heapreplace(pq_mx, -nums[i])\\n                mn_ss += mx + nums[i]\\n            \\n            mn_arr[i-n + 1] = mn_ss\\n\\n        pq_mn = [nums[i] for i in range(2*n, 3*n)]\\n        heapq.heapify(pq_mn)\\n        mx_ss = sum(pq_mn)\\n        mx_arr = [mx_ss] * (n+1)\\n\\n        for i in range(2*n - 1, n-1, -1):\\n            if nums[i] > pq_mn[0]:\\n                mn = heapq.heapreplace(pq_mn, nums[i])\\n                mx_ss += -mn + nums[i]\\n            \\n            mx_arr[i-n] = mx_ss\\n\\n        return min(mn-mx for mn, mx in zip(mn_arr, mx_arr))\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m = nums.size();\\n        int n = m / 3;\\n\\n        long mn_ss = 0;\\n        priority_queue<int> mx_pq;\\n        for (int i = 0; i < n; i++){\\n            mn_ss += nums[i];\\n            mx_pq.push(nums[i]);\\n        }\\n        vector<long> mn_arr(n+1, mn_ss);\\n\\n        for (int i = n; i < 2*n; i++){\\n            if (nums[i] < mx_pq.top()){\\n                \\n                int mx = mx_pq.top();\\n                mx_pq.pop();\\n                mx_pq.push(nums[i]);\\n                mn_ss += -mx + nums[i];\\n            }\\n            mn_arr[i-n + 1] = mn_ss;\\n        }\\n\\n        long mx_ss = 0;\\n        priority_queue<int, vector<int>, greater<>> mn_pq;\\n        for (int i = 2*n; i < m; i++){\\n            mx_ss += nums[i];\\n            mn_pq.push(nums[i]);\\n        }\\n        vector<long> mx_arr(n+1, mx_ss);\\n\\n        for (int i = 2*n - 1; i >= n; i--){\\n            if (nums[i] > mn_pq.top()){\\n                int mn = mn_pq.top();\\n                mn_pq.pop();\\n                mn_pq.push(nums[i]);\\n                mx_ss += -mn + nums[i];\\n            }\\n            \\n            mx_arr[i-n] = mx_ss;\\n        }\\n\\n        long ret = LONG_MAX;\\n        for (int i = 0; i <= n; i++){\\n            ret = min(mn_arr[i] - mx_arr[i], ret);\\n        }\\n\\n        return ret;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        pq_mx = [-nums[i] for i in range(n)]\\n        heapq.heapify(pq_mx)\\n        mn_ss = -sum(pq_mx)\\n        mn_arr = [mn_ss] * (n+1)\\n\\n        for i in range(n, 2*n):\\n            if nums[i] < -pq_mx[0]:\\n                mx = heapq.heapreplace(pq_mx, -nums[i])\\n                mn_ss += mx + nums[i]\\n            \\n            mn_arr[i-n + 1] = mn_ss\\n\\n        pq_mn = [nums[i] for i in range(2*n, 3*n)]\\n        heapq.heapify(pq_mn)\\n        mx_ss = sum(pq_mn)\\n        mx_arr = [mx_ss] * (n+1)\\n\\n        for i in range(2*n - 1, n-1, -1):\\n            if nums[i] > pq_mn[0]:\\n                mn = heapq.heapreplace(pq_mn, nums[i])\\n                mx_ss += -mn + nums[i]\\n            \\n            mx_arr[i-n] = mx_ss\\n\\n        return min(mn-mx for mn, mx in zip(mn_arr, mx_arr))\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m = nums.size();\\n        int n = m / 3;\\n\\n        long mn_ss = 0;\\n        priority_queue<int> mx_pq;\\n        for (int i = 0; i < n; i++){\\n            mn_ss += nums[i];\\n            mx_pq.push(nums[i]);\\n        }\\n        vector<long> mn_arr(n+1, mn_ss);\\n\\n        for (int i = n; i < 2*n; i++){\\n            if (nums[i] < mx_pq.top()){\\n                \\n                int mx = mx_pq.top();\\n                mx_pq.pop();\\n                mx_pq.push(nums[i]);\\n                mn_ss += -mx + nums[i];\\n            }\\n            mn_arr[i-n + 1] = mn_ss;\\n        }\\n\\n        long mx_ss = 0;\\n        priority_queue<int, vector<int>, greater<>> mn_pq;\\n        for (int i = 2*n; i < m; i++){\\n            mx_ss += nums[i];\\n            mn_pq.push(nums[i]);\\n        }\\n        vector<long> mx_arr(n+1, mx_ss);\\n\\n        for (int i = 2*n - 1; i >= n; i--){\\n            if (nums[i] > mn_pq.top()){\\n                int mn = mn_pq.top();\\n                mn_pq.pop();\\n                mn_pq.push(nums[i]);\\n                mx_ss += -mn + nums[i];\\n            }\\n            \\n            mx_arr[i-n] = mx_ss;\\n        }\\n\\n        long ret = LONG_MAX;\\n        for (int i = 0; i <= n; i++){\\n            ret = min(mn_arr[i] - mx_arr[i], ret);\\n        }\\n\\n        return ret;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813941,
                "title": "rust-two-heaps-clear-implementation",
                "content": "# Code\\n```\\nuse std::collections::BinaryHeap;\\n\\npub fn partition(\\n    mut vec: Vec<i32>,\\n    n: usize,\\n) -> (\\n    Vec<i32>,\\n    BinaryHeap<i32>,\\n) {\\n    let mut heap = BinaryHeap::new();\\n    for i in 0..n {\\n        heap.push(vec.pop().unwrap());\\n    }\\n\\n    (vec, heap)\\n}\\n\\npub fn pref_sum(\\n    vec: Vec<i32>,\\n    mut heap: BinaryHeap<i32>,\\n) -> Vec<i64> {\\n    let mut prev = heap.iter()\\n        .map(|&e| e as i64)\\n        .sum::<i64>();\\n    let mut ret = vec![prev];\\n    for e in vec {\\n        heap.push(e);\\n        let e_prev = heap.pop().unwrap();\\n\\n        prev += e as i64;\\n        prev -= e_prev as i64;\\n\\n        ret.push(prev);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn minimum_difference(vec: Vec<i32>) -> i64 {\\n        let n = vec.len() / 3;\\n\\n        let vec = vec.into_iter()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let (vec, heap_back) = partition(vec, n);\\n\\n        let vec = vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let (mut vec, heap_frnt) = partition(vec, n);\\n\\n        vec.reverse();\\n        let pref_sum_vec = pref_sum(vec.clone(), heap_frnt);\\n\\n        let vec = vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let post_sum_vec = pref_sum(vec, heap_back);\\n        let post_sum_vec = post_sum_vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n\\n        pref_sum_vec.into_iter()\\n            .zip(post_sum_vec.into_iter())\\n            .map(|(e0, e1)| e0 - e1)\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\npub fn partition(\\n    mut vec: Vec<i32>,\\n    n: usize,\\n) -> (\\n    Vec<i32>,\\n    BinaryHeap<i32>,\\n) {\\n    let mut heap = BinaryHeap::new();\\n    for i in 0..n {\\n        heap.push(vec.pop().unwrap());\\n    }\\n\\n    (vec, heap)\\n}\\n\\npub fn pref_sum(\\n    vec: Vec<i32>,\\n    mut heap: BinaryHeap<i32>,\\n) -> Vec<i64> {\\n    let mut prev = heap.iter()\\n        .map(|&e| e as i64)\\n        .sum::<i64>();\\n    let mut ret = vec![prev];\\n    for e in vec {\\n        heap.push(e);\\n        let e_prev = heap.pop().unwrap();\\n\\n        prev += e as i64;\\n        prev -= e_prev as i64;\\n\\n        ret.push(prev);\\n    }\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn minimum_difference(vec: Vec<i32>) -> i64 {\\n        let n = vec.len() / 3;\\n\\n        let vec = vec.into_iter()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let (vec, heap_back) = partition(vec, n);\\n\\n        let vec = vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let (mut vec, heap_frnt) = partition(vec, n);\\n\\n        vec.reverse();\\n        let pref_sum_vec = pref_sum(vec.clone(), heap_frnt);\\n\\n        let vec = vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n        let post_sum_vec = pref_sum(vec, heap_back);\\n        let post_sum_vec = post_sum_vec.into_iter().rev()\\n            .map(|e| -e)\\n            .collect::<Vec<_>>();\\n\\n        pref_sum_vec.into_iter()\\n            .zip(post_sum_vec.into_iter())\\n            .map(|(e0, e1)| e0 - e1)\\n            .min()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777921,
                "title": "c-python-two-heap-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/e13a51c8-64d7-4df9-af90-bd88543b7b35_1689589633.6877635.png)\\n\\n tc is O(nlogn)m sc is O(n)\\n### python\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = n // 3\\n\\t\\t\\n\\t\\t# right_max[i] is sum of largest m elements after position i\\n        right_max = [0] * (n - m + 1)\\n\\t\\t\\n\\t\\t# use min heap to find sum of largest m elements after position i\\n        min_heap = nums[-m:]\\n        heapify(min_heap)\\n\\t\\t\\n\\t\\t\\n        right_sum = right_max[-1] = sum(min_heap)\\n\\t\\t\\n        for i in range(n - m - 1, m - 1, -1):\\n            right_sum += nums[i] - heappushpop(min_heap, nums[i])\\n            right_max[i] = right_sum\\n        \\n\\t\\t\\n\\t\\t# use max heap to find sum of smallest m elements before position i\\n        max_heap = list(map(lambda x: -x, nums[:m]))\\n        heapify(max_heap)\\n\\t\\t\\n        left_sum = -sum(max_heap)\\n        ans = left_sum - right_max[m]\\n        for i in range(m, n-m):\\n            left_sum += nums[i] + heappushpop(max_heap, -nums[i])\\n\\t\\t\\t# two sequences can not overlap, left_sum [0, i], right_max [i+1, n)\\n            ans = ans if ans < left_sum - right_max[i+1] else left_sum - right_max[i+1]\\n        return ans\\n\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int m = n / 3;\\n        auto cmp = [] (int& x, int& y) -> bool {return y < x;};\\n        priority_queue<int, vector<int>, decltype(cmp)> min_heap(cmp);\\n        vector<long> right_max(n-m+1);\\n        long right_sum = 0;\\n        \\n        for (int i = n - 1; i >= n-m; i-=1) {\\n            min_heap.emplace(nums[i]);\\n            right_sum += nums[i];\\n        }\\n        \\n        right_max.back() = right_sum;\\n        for (int i = n-m-1; i >= m; i-=1) {\\n            min_heap.emplace(nums[i]);\\n            right_sum += nums[i] - min_heap.top();\\n            min_heap.pop();\\n            right_max[i] = right_sum;\\n        }\\n        long left_sum = 0;\\n        priority_queue<int, vector<int>> max_heap;\\n        for (int i = 0; i < m; i+=1) {\\n            left_sum += nums[i];\\n            max_heap.emplace(nums[i]);\\n        }\\n        \\n        long long ans = left_sum - right_max[m];\\n        for (int i = m; i < n - m; i+=1) {\\n            max_heap.emplace(nums[i]);\\n            left_sum += nums[i] - max_heap.top();\\n            max_heap.pop();\\n            ans = ans < left_sum - right_max[i+1] ? ans: left_sum - right_max[i+1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        m = n // 3\\n\\t\\t\\n\\t\\t# right_max[i] is sum of largest m elements after position i\\n        right_max = [0] * (n - m + 1)\\n\\t\\t\\n\\t\\t# use min heap to find sum of largest m elements after position i\\n        min_heap = nums[-m:]\\n        heapify(min_heap)\\n\\t\\t\\n\\t\\t\\n        right_sum = right_max[-1] = sum(min_heap)\\n\\t\\t\\n        for i in range(n - m - 1, m - 1, -1):\\n            right_sum += nums[i] - heappushpop(min_heap, nums[i])\\n            right_max[i] = right_sum\\n        \\n\\t\\t\\n\\t\\t# use max heap to find sum of smallest m elements before position i\\n        max_heap = list(map(lambda x: -x, nums[:m]))\\n        heapify(max_heap)\\n\\t\\t\\n        left_sum = -sum(max_heap)\\n        ans = left_sum - right_max[m]\\n        for i in range(m, n-m):\\n            left_sum += nums[i] + heappushpop(max_heap, -nums[i])\\n\\t\\t\\t# two sequences can not overlap, left_sum [0, i], right_max [i+1, n)\\n            ans = ans if ans < left_sum - right_max[i+1] else left_sum - right_max[i+1]\\n        return ans\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int m = n / 3;\\n        auto cmp = [] (int& x, int& y) -> bool {return y < x;};\\n        priority_queue<int, vector<int>, decltype(cmp)> min_heap(cmp);\\n        vector<long> right_max(n-m+1);\\n        long right_sum = 0;\\n        \\n        for (int i = n - 1; i >= n-m; i-=1) {\\n            min_heap.emplace(nums[i]);\\n            right_sum += nums[i];\\n        }\\n        \\n        right_max.back() = right_sum;\\n        for (int i = n-m-1; i >= m; i-=1) {\\n            min_heap.emplace(nums[i]);\\n            right_sum += nums[i] - min_heap.top();\\n            min_heap.pop();\\n            right_max[i] = right_sum;\\n        }\\n        long left_sum = 0;\\n        priority_queue<int, vector<int>> max_heap;\\n        for (int i = 0; i < m; i+=1) {\\n            left_sum += nums[i];\\n            max_heap.emplace(nums[i]);\\n        }\\n        \\n        long long ans = left_sum - right_max[m];\\n        for (int i = m; i < n - m; i+=1) {\\n            max_heap.emplace(nums[i]);\\n            left_sum += nums[i] - max_heap.top();\\n            max_heap.pop();\\n            ans = ans < left_sum - right_max[i+1] ? ans: left_sum - right_max[i+1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682536,
                "title": "omg-my-brain-hurts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        vector<long long> minSumLeft(n + 1);\\n        vector<long long> maxSumRight(n + 1);\\n        priority_queue<int> leftQ;\\n        priority_queue<int, vector<int>, greater<>> rightQ;\\n        long long sumLeft = 0, sumRight = 0;\\n        for (int i = 0; i < n; ++i) {\\n            sumLeft += nums[i];\\n            sumRight += nums[2 * n + i];\\n            leftQ.push(nums[i]);\\n            rightQ.push(nums[2 * n + i]);\\n        }\\n        minSumLeft[0] = sumLeft;\\n        maxSumRight.back() = sumRight;\\n        for (int i = 1; i <= n; ++i) {\\n            int val = nums[n - 1 + i];\\n            if ( val < leftQ.top()) {\\n                sumLeft += (long long)val - leftQ.top();\\n                leftQ.push(val);\\n                leftQ.pop();\\n            }\\n            minSumLeft[i] = sumLeft;\\n\\n            val = nums[2 * n - i];\\n            if (val > rightQ.top()) {\\n                sumRight += (long long)val - rightQ.top();\\n                rightQ.push(val);\\n                rightQ.pop();\\n            }\\n            maxSumRight[n - i] = sumRight;\\n        }\\n\\n        long long result = numeric_limits<long long>::max();\\n        for (int i = 0; i <= n; ++i)\\n            result = min(result, minSumLeft[i] - maxSumRight[i]);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        vector<long long> minSumLeft(n + 1);\\n        vector<long long> maxSumRight(n + 1);\\n        priority_queue<int> leftQ;\\n        priority_queue<int, vector<int>, greater<>> rightQ;\\n        long long sumLeft = 0, sumRight = 0;\\n        for (int i = 0; i < n; ++i) {\\n            sumLeft += nums[i];\\n            sumRight += nums[2 * n + i];\\n            leftQ.push(nums[i]);\\n            rightQ.push(nums[2 * n + i]);\\n        }\\n        minSumLeft[0] = sumLeft;\\n        maxSumRight.back() = sumRight;\\n        for (int i = 1; i <= n; ++i) {\\n            int val = nums[n - 1 + i];\\n            if ( val < leftQ.top()) {\\n                sumLeft += (long long)val - leftQ.top();\\n                leftQ.push(val);\\n                leftQ.pop();\\n            }\\n            minSumLeft[i] = sumLeft;\\n\\n            val = nums[2 * n - i];\\n            if (val > rightQ.top()) {\\n                sumRight += (long long)val - rightQ.top();\\n                rightQ.push(val);\\n                rightQ.pop();\\n            }\\n            maxSumRight[n - i] = sumRight;\\n        }\\n\\n        long long result = numeric_limits<long long>::max();\\n        for (int i = 0; i <= n; ++i)\\n            result = min(result, minSumLeft[i] - maxSumRight[i]);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572778,
                "title": "two-direction-scan-with-heap-in-python-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is to find a pivot in between `n` and `2n` (inclusive) so that the sum of the mininum `n` elements in `nums[0:pivot]` -  the sum of the maximum `n` elements in `nums[pivot:3n]` is minimized. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy soluton first scans the elements in from `2n` to `n` in the backward direction. A heap with the `n` maximum elemements can be found at each position is maintained during scanning, and the sum of the `n` elements is stored in a list `backward`. Then, the second scan is performed from `n` to `2n` in the forward direction. A heap with the `n` minimum elements at each poistion is maintained during the scanning, and the best solution can be obtained by using the precomputed information from the backward list. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        left, right = [-v for v in nums[:n]], nums[-n:]\\n        backward = [0] * (n + 1)\\n        backward[n] = sum(right)\\n        heapify(left)\\n        heapify(right)\\n        \\n        for i in range(n-1, -1, -1):\\n            if nums[n + i] > right[0]:\\n                backward[i] = backward[i+1] - heappop(right) + nums[n+i]\\n                heappush(right, nums[n+i])\\n            else:\\n                backward[i] = backward[i+1]\\n        s = -sum(left)\\n        best = s - backward[0]\\n        for i in range(0, n):\\n            if nums[n+i] < -left[0]:\\n                s = s - (-heappop(left)) + nums[n+i]\\n                heappush(left, -nums[n+i])\\n            best = min(best, s - backward[i+1])\\n        return best\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        left, right = [-v for v in nums[:n]], nums[-n:]\\n        backward = [0] * (n + 1)\\n        backward[n] = sum(right)\\n        heapify(left)\\n        heapify(right)\\n        \\n        for i in range(n-1, -1, -1):\\n            if nums[n + i] > right[0]:\\n                backward[i] = backward[i+1] - heappop(right) + nums[n+i]\\n                heappush(right, nums[n+i])\\n            else:\\n                backward[i] = backward[i+1]\\n        s = -sum(left)\\n        best = s - backward[0]\\n        for i in range(0, n):\\n            if nums[n+i] < -left[0]:\\n                s = s - (-heappop(left)) + nums[n+i]\\n                heappush(left, -nums[n+i])\\n            best = min(best, s - backward[i+1])\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520455,
                "title": "easy-heap-solution-two-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are looking for the minimum difference, we want the sum of the first part as small as possible and right part as great as possible.\\n\\nFor the first part(sumFirst), we can use a Max Heap of size N to store the smallest N elements in it.\\n\\nWe traverse from left(0) to right(n-k). For each A[i], we push it into the heap. If the heap size is greater than N, we pop the heap top. In this way, we track the smallest N elements and their sum.\\n\\nSimilarly for the right part, but we want the greatest N elements.\\nFor the second part(sumSecond ), we can use a Min Heap of size N to store the greatest N elements in it.\\n\\nWe traverse from right(n-1) to left(k). For each A[i], we push it into the heap. If the heap size is greater than N, we pop the heap top. In this way, we track the greatest N elements and their sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minimumDifference(nums []int) int64 {\\n    sumFirst, sumSecond := 0, 0\\n    ans := math.MaxInt64\\n    n := len(nums)\\n    k := n/3\\n\\n    maxH := &maxHeap{}\\n    heap.Init(maxH)\\n    minH := &minHeap{}\\n    heap.Init(minH)\\n\\n    temp := make([]int, n)\\n    for i:= n-1 ;i>=k;i-- {\\n        heap.Push(minH, nums[i])\\n        // minH.Push(nums[i])\\n        sumSecond +=nums[i]\\n        if minH.Len() > k {\\n            // sumSecond -= minH.Pop()\\n            sumSecond -= heap.Pop(minH).(int)\\n        }\\n        if minH.Len() == k {\\n            temp[i] = sumSecond\\n        }\\n    }\\n\\n    for i:=0;i<n-k;i++ {\\n        // maxH.Push(nums[i])\\n        heap.Push(maxH, nums[i])\\n        sumFirst += nums[i]\\n        if maxH.Len() > k {\\n            // sumFirst -= maxH.Pop()\\n            sumFirst -= heap.Pop(maxH).(int)\\n        }\\n        if maxH.Len() == k {\\n           if ans > (sumFirst-temp[i+1]) {\\n               ans = sumFirst - temp[i+1]\\n           }\\n        }\\n    }\\n\\n    return int64(ans)\\n\\n}\\n\\n// maxHeap\\ntype maxHeap []int\\n\\nfunc(max maxHeap) Swap(i, j int) {\\n    max[i], max[j] = max[j], max[i]\\n}\\n\\nfunc(max maxHeap) Less(i, j int) bool {\\n    return max[i] > max[j]\\n} \\n\\nfunc(max maxHeap) Len() int {\\n    return len(max)\\n}\\n\\nfunc (max *maxHeap) Push(x any) {\\n    *max = append(*max, x.(int))\\n}\\n\\nfunc(max *maxHeap) Pop() any {\\n    old := *max\\n    n := len(old)\\n    x := old[n-1]\\n    *max = old[0:n-1]\\n    return x\\n}\\n\\n// minHeap\\ntype minHeap []int\\n\\nfunc(min minHeap) Swap(i, j int) {\\n    min[i], min[j] = min[j], min[i]\\n}\\n\\nfunc(min minHeap) Less(i, j int) bool {\\n    return min[i] < min[j]\\n} \\n\\nfunc(min minHeap) Len() int {\\n    return len(min)\\n}\\n\\nfunc (min *minHeap) Push(x any) {\\n    *min = append(*min, x.(int))\\n}\\n\\nfunc(min *minHeap) Pop() any {\\n    old := *min\\n    n := len(old)\\n    x := old[n-1]\\n    *min = old[0:n-1]\\n    return x\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc minimumDifference(nums []int) int64 {\\n    sumFirst, sumSecond := 0, 0\\n    ans := math.MaxInt64\\n    n := len(nums)\\n    k := n/3\\n\\n    maxH := &maxHeap{}\\n    heap.Init(maxH)\\n    minH := &minHeap{}\\n    heap.Init(minH)\\n\\n    temp := make([]int, n)\\n    for i:= n-1 ;i>=k;i-- {\\n        heap.Push(minH, nums[i])\\n        // minH.Push(nums[i])\\n        sumSecond +=nums[i]\\n        if minH.Len() > k {\\n            // sumSecond -= minH.Pop()\\n            sumSecond -= heap.Pop(minH).(int)\\n        }\\n        if minH.Len() == k {\\n            temp[i] = sumSecond\\n        }\\n    }\\n\\n    for i:=0;i<n-k;i++ {\\n        // maxH.Push(nums[i])\\n        heap.Push(maxH, nums[i])\\n        sumFirst += nums[i]\\n        if maxH.Len() > k {\\n            // sumFirst -= maxH.Pop()\\n            sumFirst -= heap.Pop(maxH).(int)\\n        }\\n        if maxH.Len() == k {\\n           if ans > (sumFirst-temp[i+1]) {\\n               ans = sumFirst - temp[i+1]\\n           }\\n        }\\n    }\\n\\n    return int64(ans)\\n\\n}\\n\\n// maxHeap\\ntype maxHeap []int\\n\\nfunc(max maxHeap) Swap(i, j int) {\\n    max[i], max[j] = max[j], max[i]\\n}\\n\\nfunc(max maxHeap) Less(i, j int) bool {\\n    return max[i] > max[j]\\n} \\n\\nfunc(max maxHeap) Len() int {\\n    return len(max)\\n}\\n\\nfunc (max *maxHeap) Push(x any) {\\n    *max = append(*max, x.(int))\\n}\\n\\nfunc(max *maxHeap) Pop() any {\\n    old := *max\\n    n := len(old)\\n    x := old[n-1]\\n    *max = old[0:n-1]\\n    return x\\n}\\n\\n// minHeap\\ntype minHeap []int\\n\\nfunc(min minHeap) Swap(i, j int) {\\n    min[i], min[j] = min[j], min[i]\\n}\\n\\nfunc(min minHeap) Less(i, j int) bool {\\n    return min[i] < min[j]\\n} \\n\\nfunc(min minHeap) Len() int {\\n    return len(min)\\n}\\n\\nfunc (min *minHeap) Push(x any) {\\n    *min = append(*min, x.(int))\\n}\\n\\nfunc(min *minHeap) Pop() any {\\n    old := *min\\n    n := len(old)\\n    x := old[n-1]\\n    *min = old[0:n-1]\\n    return x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3428151,
                "title": "easy-to-understand-c-solution-simplest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/3;\\n        priority_queue<int> lpq;\\n       priority_queue<int,vector<int>, greater<>> rpq;\\n        long long int suml=0;\\n        long long int sumr=0;\\n           long long int l[n+1];\\n        long long int r[n+1];\\n        for(int i=0;i<n;i++){\\n            suml+=nums[i];\\n            lpq.push(nums[i]);\\n            sumr+=nums[2*n+i];\\n            rpq.push(nums[2*n+i]);\\n\\n        }\\n     l[0]=suml;\\n     r[0]=sumr;\\n        for(int i=n;i<2*n;i++){\\n           if(lpq.top()>nums[i]){\\n               suml=suml-lpq.top()+nums[i];\\n               \\n               lpq.pop();\\n               lpq.push(nums[i]);\\n           }\\n           if(rpq.top()<nums[3*n-1-i]){\\n               sumr=sumr-rpq.top()+nums[3*n-1-i];\\n               \\n               rpq.pop();\\n               rpq.push(nums[3*n-1-i]);\\n           }\\n           l[i-n+1]=suml;\\n           r[i-n+1]=sumr;\\n        //    cout<<nums[3*n-1-i]<<endl;\\n        }\\n\\n        long long int ans=LONG_MAX;\\n        for(int i=0;i<n+1;i++){\\n            ans=min(ans,(l[i]-r[n-i]));\\n            cout<<l[i]<<\" \"<<r[i]<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n=nums.size()/3;\\n        priority_queue<int> lpq;\\n       priority_queue<int,vector<int>, greater<>> rpq;\\n        long long int suml=0;\\n        long long int sumr=0;\\n           long long int l[n+1];\\n        long long int r[n+1];\\n        for(int i=0;i<n;i++){\\n            suml+=nums[i];\\n            lpq.push(nums[i]);\\n            sumr+=nums[2*n+i];\\n            rpq.push(nums[2*n+i]);\\n\\n        }\\n     l[0]=suml;\\n     r[0]=sumr;\\n        for(int i=n;i<2*n;i++){\\n           if(lpq.top()>nums[i]){\\n               suml=suml-lpq.top()+nums[i];\\n               \\n               lpq.pop();\\n               lpq.push(nums[i]);\\n           }\\n           if(rpq.top()<nums[3*n-1-i]){\\n               sumr=sumr-rpq.top()+nums[3*n-1-i];\\n               \\n               rpq.pop();\\n               rpq.push(nums[3*n-1-i]);\\n           }\\n           l[i-n+1]=suml;\\n           r[i-n+1]=sumr;\\n        //    cout<<nums[3*n-1-i]<<endl;\\n        }\\n\\n        long long int ans=LONG_MAX;\\n        for(int i=0;i<n+1;i++){\\n            ans=min(ans,(l[i]-r[n-i]));\\n            cout<<l[i]<<\" \"<<r[i]<<endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3281799,
                "title": "488-ms",
                "content": "```ruby\\nclass OMSet < CRBTreeMap\\n\\n    def << x\\n        self[x] = (self[x] || 0) + 1\\n    end\\n\\n    def erase x\\n        delete x if (self[x] -= 1).zero?\\n    end\\n\\n    def min = min_key\\n    def max = max_key\\n\\nend\\n\\ndef minimum_difference a\\n    ls, rs, l, r = 0, 0, *2.times.map { OMSet.new }\\n    [[l, a[0, z = a.size / 3]], [r, a[-z..]]].each do | p |\\n        t, v = *p\\n        v.tally.each { t[_1] = _2 }\\n        ls == 0 ? (ls = v.sum) : (rs = v.sum)\\n    end\\n    d = [nil] * (z + 1)\\n    for i in z...z * 2\\n        d[i - z] = ls\\n        if (x = l.max) > (y = a[i])\\n            ls -= x - y\\n            l.erase x\\n            l << y\\n        end\\n    end\\n    d[-1] = ls - rs\\n    for i in (z...z * 2).reverse_each\\n        if (x = a[i]) > (y = r.min)\\n            rs += x - y\\n            r.erase y\\n            r << x\\n        end\\n        d[i - z] -= rs\\n    end\\n    d.min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass OMSet < CRBTreeMap\\n\\n    def << x\\n        self[x] = (self[x] || 0) + 1\\n    end\\n\\n    def erase x\\n        delete x if (self[x] -= 1).zero?\\n    end\\n\\n    def min = min_key\\n    def max = max_key\\n\\nend\\n\\ndef minimum_difference a\\n    ls, rs, l, r = 0, 0, *2.times.map { OMSet.new }\\n    [[l, a[0, z = a.size / 3]], [r, a[-z..]]].each do | p |\\n        t, v = *p\\n        v.tally.each { t[_1] = _2 }\\n        ls == 0 ? (ls = v.sum) : (rs = v.sum)\\n    end\\n    d = [nil] * (z + 1)\\n    for i in z...z * 2\\n        d[i - z] = ls\\n        if (x = l.max) > (y = a[i])\\n            ls -= x - y\\n            l.erase x\\n            l << y\\n        end\\n    end\\n    d[-1] = ls - rs\\n    for i in (z...z * 2).reverse_each\\n        if (x = a[i]) > (y = r.min)\\n            rs += x - y\\n            r.erase y\\n            r << x\\n        end\\n        d[i - z] -= rs\\n    end\\n    d.min\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255295,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let n = nums.len() as i64;\\n        let mut l = vec![0; n as usize];\\n        let mut r = vec![0; n as usize];\\n        let mut pq1 = BinaryHeap::new();\\n        let mut pq2 = BinaryHeap::<Reverse<i64>>::new();\\n        let mut sum = 0;\\n        for i in 0..n / 3 * 2 {\\n            sum += nums[i as usize];\\n            pq1.push(nums[i as usize]);\\n            if i >= n / 3 {\\n                sum -= pq1.pop().unwrap();\\n            }\\n            l[i as usize] = sum;\\n        }\\n        sum = 0;\\n        for i in (n / 3..n).rev() {\\n            sum += nums[i as usize];\\n            pq2.push(Reverse(nums[i as usize]));\\n            if i < n / 3 * 2 {\\n                sum -= pq2.pop().unwrap().0;\\n            }\\n            r[i as usize] = sum;\\n        }\\n        let mut ans = std::i64::MAX;\\n        for i in (n / 3 - 1..n / 3 * 2).rev() {\\n            ans = ans.min(l[i as usize] - r[i as usize + 1]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_difference(nums: Vec<i32>) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n        let nums = nums.iter().map(|&x| x as i64).collect::<Vec<_>>();\\n        let n = nums.len() as i64;\\n        let mut l = vec![0; n as usize];\\n        let mut r = vec![0; n as usize];\\n        let mut pq1 = BinaryHeap::new();\\n        let mut pq2 = BinaryHeap::<Reverse<i64>>::new();\\n        let mut sum = 0;\\n        for i in 0..n / 3 * 2 {\\n            sum += nums[i as usize];\\n            pq1.push(nums[i as usize]);\\n            if i >= n / 3 {\\n                sum -= pq1.pop().unwrap();\\n            }\\n            l[i as usize] = sum;\\n        }\\n        sum = 0;\\n        for i in (n / 3..n).rev() {\\n            sum += nums[i as usize];\\n            pq2.push(Reverse(nums[i as usize]));\\n            if i < n / 3 * 2 {\\n                sum -= pq2.pop().unwrap().0;\\n            }\\n            r[i as usize] = sum;\\n        }\\n        let mut ans = std::i64::MAX;\\n        for i in (n / 3 - 1..n / 3 * 2).rev() {\\n            ans = ans.min(l[i as usize] - r[i as usize + 1]);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206944,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        n = len(nums)//3\\n\\n        left, right, mid = [-i for i in nums[:n]], nums[2*n:], nums[n:2*n]\\n\\n        left_sum, right_sum = [-sum(left)], [sum(right)]\\n\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n\\n        for i in mid:\\n            heapq.heappush(left,-i)\\n            left_sum.append(left_sum[-1] + i + heapq.heappop(left))\\n\\n        for i in mid[::-1]:\\n            heapq.heappush(right,i)\\n            right_sum.append(right_sum[-1] + i - heapq.heappop(right))\\n\\n        right_sum = right_sum[::-1]\\n\\n        return min([i-j for i,j in zip(left_sum,right_sum)])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums):\\n        n = len(nums)//3\\n\\n        left, right, mid = [-i for i in nums[:n]], nums[2*n:], nums[n:2*n]\\n\\n        left_sum, right_sum = [-sum(left)], [sum(right)]\\n\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n\\n        for i in mid:\\n            heapq.heappush(left,-i)\\n            left_sum.append(left_sum[-1] + i + heapq.heappop(left))\\n\\n        for i in mid[::-1]:\\n            heapq.heappush(right,i)\\n            right_sum.append(right_sum[-1] + i - heapq.heappop(right))\\n\\n        right_sum = right_sum[::-1]\\n\\n        return min([i-j for i,j in zip(left_sum,right_sum)])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178768,
                "title": "python-o-n-log-n-easy-to-understand-explanation-with-pictures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe first thing we should always do when solving a problem is to carefully read the given examples. In this case, it is important to note that the goal is to find the minimum difference, not the minimum absolute difference. Once this detail is understood, the problem becomes more manageable.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nNow that we understand the actual problem, we can focus on approaching it. The first instinct might be to place the lowest elements in the first part of the array and the greatest elements in the second part. \\n\\n![img.png](https://assets.leetcode.com/users/images/89daae42-120c-420f-9cce-a03e60ec93c7_1676264964.2797918.png)\\n\\n\\nWhile this is a good starting point, there are some refinements to be made before starting the implementation.\\n\\nIt should be noted that reordering the entire array is not allowed. Each element can only be shifted up to n positions. This means that the first element of the array cannot be part of the second part once the n elements are removed.\\n\\nTherefore, the first n elements of nums can only be either included in the first part or excluded. The same is true for the last n elements of nums, they can only be included in the second part.\\n\\nThe only remaining decision is whether the elements n+1 to 2n of nums should belong to the first part or the second part. If the first n+k elements belong to the first part and the rest to the second part, then it is clear that the problem reduces to finding this value of k.\\n\\nRemember that our objective is to make the sum of the first part as small as possible, while making the sum of the second part as large as possible. To achieve this, if the first part consists of n + k elements, we remove the k largest elements. Conversely, if the second part consists of 2n - k elements, we remove the n - k smallest elements. This way, we remove exactly n elements from the array, resulting in two parts with exactly n elements each.\\n\\nTo determine the value of k, the only option is to try k = 1, ..., n and determine the best solution by evaluating the difference between the first and second parts.\\n\\nThere are various methods to achieve this, but efficiency is key. One possible approach is to go through the elements of the array twice. The first pass involves finding the n largest elements in nums[:n + k], with k = 1, ..., n. In the second pass, we find the n smallest elements in nums[3n - k:], with k = 1, ..., n.\\n\\nThink of it as gradually increasing the size of a window, considering one more element in each step. In the first case, we are searching for larger numbers, while in the second case, we are searching for smaller numbers.\\n\\nA heap data structure can be used to efficiently find the n smallest or largest elements of the current window. As we consider each new element, we add it to the heap. To update the sum, we pop the first element in the heap and compare it with the newly considered element.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$\\\\mathcal{O}(n \\\\ log \\\\ n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$\\\\mathcal{O}(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        # Max heap\\n        prefix_q = [-x for x in nums[:n]]\\n        heapq.heapify(prefix_q)\\n        \\n        # Initialize diff\\n        diff = [0]*(n+1)\\n        diff[0] = -sum(prefix_q)\\n        \\n        # Expand window rightwise -->\\n        for i in range(n):\\n            r = nums[i+n]        \\n            # Update prefix sum: Consider r. Is it smaller than greatest in queue?        \\n            greatest = -heapq.heappushpop(prefix_q, -r)\\n            diff[i+1] = diff[i] - greatest + r\\n        \\n        # Min heap\\n        suffix_q = nums[2*n:]\\n        heapq.heapify(suffix_q)\\n        \\n        prev_sum = sum(suffix_q)\\n        diff[-1] -= prev_sum\\n        \\n        #Expand window leftwise <--\\n        for i in range(n):\\n            l = nums[len(nums) - 1 - n - i]\\n            \\n            # Update suffix sum: Consider l. Is it greater than smallest in queue?\\n            smallest = heapq.heappushpop(suffix_q, l)\\n            prev_sum = prev_sum - smallest + l\\n            diff[n - 1 - i] -= prev_sum \\n\\n        return min(diff)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        # Max heap\\n        prefix_q = [-x for x in nums[:n]]\\n        heapq.heapify(prefix_q)\\n        \\n        # Initialize diff\\n        diff = [0]*(n+1)\\n        diff[0] = -sum(prefix_q)\\n        \\n        # Expand window rightwise -->\\n        for i in range(n):\\n            r = nums[i+n]        \\n            # Update prefix sum: Consider r. Is it smaller than greatest in queue?        \\n            greatest = -heapq.heappushpop(prefix_q, -r)\\n            diff[i+1] = diff[i] - greatest + r\\n        \\n        # Min heap\\n        suffix_q = nums[2*n:]\\n        heapq.heapify(suffix_q)\\n        \\n        prev_sum = sum(suffix_q)\\n        diff[-1] -= prev_sum\\n        \\n        #Expand window leftwise <--\\n        for i in range(n):\\n            l = nums[len(nums) - 1 - n - i]\\n            \\n            # Update suffix sum: Consider l. Is it greater than smallest in queue?\\n            smallest = heapq.heappushpop(suffix_q, l)\\n            prev_sum = prev_sum - smallest + l\\n            diff[n - 1 - i] -= prev_sum \\n\\n        return min(diff)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065490,
                "title": "82-73-faster-hashmap-priority-queue-c-simple-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        ll n=nums.size(),front=0,back=0,pro=n/3,answer=1e18,count=0;\\n        priority_queue<ll>pq(nums.begin(),nums.begin()+pro);\\n        map<ll,ll,greater<ll>>mp;\\n        unordered_map<ll,ll>used;\\n        for(ll i=0;i<pro;i++){\\n            front+=nums[i];\\n        }\\n        for(ll i=pro;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto &x:mp){\\n            for(ll i=0;i<x.second && count<pro;i++){\\n                used[x.first]++;back+=x.first;count++;\\n            }\\n        }\\n        for(auto &x:used){\\n            for(ll i=0;i<x.second;i++){\\n                mp[x.first]--;\\n                if(mp[x.first]==0){\\n                    mp.erase(x.first);\\n                }\\n            }\\n        }\\n        for(ll i=pro;i<2*pro;i++){\\n            answer=min(answer,front-back);\\n            if(pq.top()>nums[i]){\\n                front-=pq.top();pq.pop();pq.push(nums[i]);front+=nums[i];\\n            }\\n            if(used.find(nums[i])!=used.end()){\\n                if(mp.find(nums[i])!=mp.end()){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)  mp.erase(nums[i]);\\n                }\\n                else{\\n                    back-=nums[i];used[mp.begin()->first]++;back+=mp.begin()->first;mp.begin()->second--;\\n                    if(mp.begin()->second==0)   mp.erase(mp.begin());\\n                }\\n            }\\n            else{\\n                if(mp.find(nums[i])!=mp.end()){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)  mp.erase(nums[i]);\\n                }\\n            }\\n        }\\n        return min(answer,front-back);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        ll n=nums.size(),front=0,back=0,pro=n/3,answer=1e18,count=0;\\n        priority_queue<ll>pq(nums.begin(),nums.begin()+pro);\\n        map<ll,ll,greater<ll>>mp;\\n        unordered_map<ll,ll>used;\\n        for(ll i=0;i<pro;i++){\\n            front+=nums[i];\\n        }\\n        for(ll i=pro;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto &x:mp){\\n            for(ll i=0;i<x.second && count<pro;i++){\\n                used[x.first]++;back+=x.first;count++;\\n            }\\n        }\\n        for(auto &x:used){\\n            for(ll i=0;i<x.second;i++){\\n                mp[x.first]--;\\n                if(mp[x.first]==0){\\n                    mp.erase(x.first);\\n                }\\n            }\\n        }\\n        for(ll i=pro;i<2*pro;i++){\\n            answer=min(answer,front-back);\\n            if(pq.top()>nums[i]){\\n                front-=pq.top();pq.pop();pq.push(nums[i]);front+=nums[i];\\n            }\\n            if(used.find(nums[i])!=used.end()){\\n                if(mp.find(nums[i])!=mp.end()){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)  mp.erase(nums[i]);\\n                }\\n                else{\\n                    back-=nums[i];used[mp.begin()->first]++;back+=mp.begin()->first;mp.begin()->second--;\\n                    if(mp.begin()->second==0)   mp.erase(mp.begin());\\n                }\\n            }\\n            else{\\n                if(mp.find(nums[i])!=mp.end()){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)  mp.erase(nums[i]);\\n                }\\n            }\\n        }\\n        return min(answer,front-back);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735121,
                "title": "c-multiset-int",
                "content": "Idea: scan L->R and R->L\\n we split the nums array into two parts [0...k-1] and [k...3n-1] at k.\\n k is in [n...2n].\\n we select the min sum of n nums in the first part,\\n and select the max sum of n nums from the second part.\\n\\n```\\n// Idea: scan L->R and R->L\\n// we split the nums array into two parts [0...k-1] and [k...3n-1] at k.\\n// k is in [n...2n].\\n// we select the min sum of n nums in the first part,\\n// and select the max sum of n nums from the second part.\\n\\n// from left to right, we gather the sum of the smallest n numbers\\n\\n// from right to left, we compute the sume of the largest n numbers\\n// and we update the min diff.\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        const int n = nums.size() / 3;\\n        // we split the nums array into two parts [0...k-1] and [k...3n-1] at k.\\n        // k is in [n...2n].\\n        // we select the min sum of n nums in the first part,\\n        // and select the max sum of n nums from the second part.\\n        vector<int64_t> mins(n+1);\\n        \\n        multiset<int> s;\\n        int64_t sum = 0;\\n        // from left to right, we gather the sum of the smallest n numbers\\n        for (int i = 0; i < 2*n; ++i) {\\n            sum += nums[i];\\n            s.insert(nums[i]);\\n            if (i >= n) {\\n                // remove the max element from the set\\n                sum -= *s.rbegin();\\n                s.erase(prev(s.end()));\\n            }\\n            if (i >= n-1) {\\n                mins[i - n + 1] = sum;\\n                // cout << \"min[\" << i << \"] = \" << sum << endl;\\n            }\\n        }\\n        \\n        s.clear();\\n        sum = 0;\\n        \\n        // from right to left, we compute the sum of the largest n numbers\\n        // and we update the min diff.\\n        int64_t minDiff = INT64_MAX;\\n        for (int i = 3*n-1; i >= n; --i) {\\n            sum += nums[i];\\n            s.insert(nums[i]);\\n            if (i < 2*n) {\\n                // remove the min element from the set\\n                sum -= *s.begin();\\n                s.erase(s.begin());\\n            }\\n            if (i <= 2*n) {\\n                // look up the mins using i-1\\n                auto before = mins[i-1-n+1];\\n                auto diff = before - sum;\\n                minDiff = min(minDiff, diff);\\n            }\\n        }\\n        return minDiff;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea: scan L->R and R->L\\n// we split the nums array into two parts [0...k-1] and [k...3n-1] at k.\\n// k is in [n...2n].\\n// we select the min sum of n nums in the first part,\\n// and select the max sum of n nums from the second part.\\n\\n// from left to right, we gather the sum of the smallest n numbers\\n\\n// from right to left, we compute the sume of the largest n numbers\\n// and we update the min diff.\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        const int n = nums.size() / 3;\\n        // we split the nums array into two parts [0...k-1] and [k...3n-1] at k.\\n        // k is in [n...2n].\\n        // we select the min sum of n nums in the first part,\\n        // and select the max sum of n nums from the second part.\\n        vector<int64_t> mins(n+1);\\n        \\n        multiset<int> s;\\n        int64_t sum = 0;\\n        // from left to right, we gather the sum of the smallest n numbers\\n        for (int i = 0; i < 2*n; ++i) {\\n            sum += nums[i];\\n            s.insert(nums[i]);\\n            if (i >= n) {\\n                // remove the max element from the set\\n                sum -= *s.rbegin();\\n                s.erase(prev(s.end()));\\n            }\\n            if (i >= n-1) {\\n                mins[i - n + 1] = sum;\\n                // cout << \"min[\" << i << \"] = \" << sum << endl;\\n            }\\n        }\\n        \\n        s.clear();\\n        sum = 0;\\n        \\n        // from right to left, we compute the sum of the largest n numbers\\n        // and we update the min diff.\\n        int64_t minDiff = INT64_MAX;\\n        for (int i = 3*n-1; i >= n; --i) {\\n            sum += nums[i];\\n            s.insert(nums[i]);\\n            if (i < 2*n) {\\n                // remove the min element from the set\\n                sum -= *s.begin();\\n                s.erase(s.begin());\\n            }\\n            if (i <= 2*n) {\\n                // look up the mins using i-1\\n                auto before = mins[i-1-n+1];\\n                auto diff = before - sum;\\n                minDiff = min(minDiff, diff);\\n            }\\n        }\\n        return minDiff;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2667506,
                "title": "priority-queue-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int n=nums.size()/3;\\n        priority_queue<int>pq;\\n        priority_queue<int,vector<int>,greater<int> >pq1;\\n        long long sum=0;\\n        vector<long long> left(3*n,0),right(3*n,0);\\n        for(int i=0;i<3*n;i++)\\n        {\\n            pq.push(nums[i]);\\n            sum+=nums[i];\\n\\n            if(i<n){left[i]=sum;continue;}\\n            \\n            sum-=pq.top();\\n            pq.pop();\\n            left[i]=sum;\\n\\n        }\\n        sum=0;\\n       // pq.clear();\\n        //reverse(nums.begin(),nums.end());\\n        for(int i=3*n-1;i>=0;i--)\\n        {\\n            pq1.push(nums[i]);\\n            sum+=nums[i];\\n\\n            if(i>=2*n){right[i]=sum;continue;}\\n            \\n            sum-=pq1.top();\\n            pq1.pop();\\n            right[i]=sum;\\n\\n        }\\n        long long ans=1e12;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n           // cout<<i<<\" \"<<left[i]<<\" \"<<right[i+1]<<endl;\\n            ans=min(ans,left[i]-right[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n       int n=nums.size()/3;\\n        priority_queue<int>pq;\\n        priority_queue<int,vector<int>,greater<int> >pq1;\\n        long long sum=0;\\n        vector<long long> left(3*n,0),right(3*n,0);\\n        for(int i=0;i<3*n;i++)\\n        {\\n            pq.push(nums[i]);\\n            sum+=nums[i];\\n\\n            if(i<n){left[i]=sum;continue;}\\n            \\n            sum-=pq.top();\\n            pq.pop();\\n            left[i]=sum;\\n\\n        }\\n        sum=0;\\n       // pq.clear();\\n        //reverse(nums.begin(),nums.end());\\n        for(int i=3*n-1;i>=0;i--)\\n        {\\n            pq1.push(nums[i]);\\n            sum+=nums[i];\\n\\n            if(i>=2*n){right[i]=sum;continue;}\\n            \\n            sum-=pq1.top();\\n            pq1.pop();\\n            right[i]=sum;\\n\\n        }\\n        long long ans=1e12;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n           // cout<<i<<\" \"<<left[i]<<\" \"<<right[i+1]<<endl;\\n            ans=min(ans,left[i]-right[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2645291,
                "title": "c-multiset-o-nlognn",
                "content": "```\\n#define ll long long\\nconst ll INF = 1e15;\\nclass Solution {\\npublic:\\n    vector<ll> get_pre(vector<int> &arr, int n){\\n        multiset<int> st;\\n        ll t_sum = 0;\\n        for(int i = 0; i < n; i++)st.insert(arr[i]), t_sum += arr[i];\\n        vector<ll> ans(arr.size(), -INF);\\n        ans[n-1] = t_sum;\\n        for(int i = n; i < arr.size(); i++){\\n            if (arr[i] > *st.begin()){\\n                t_sum += arr[i] - *st.begin();\\n                st.erase(st.begin());\\n                st.insert(arr[i]);\\n            }\\n            ans[i] = t_sum;\\n        }\\n        return ans;\\n    }\\n    vector<ll> get_suf(vector<int> &arr, int n){\\n        multiset<int> st;\\n        ll t_sum = 0;\\n        for(int i = 0; i < n; i++)st.insert(arr[i]), t_sum += arr[i];\\n        vector<ll> ans(arr.size(), INF);\\n        ans[n-1] = t_sum;\\n        for(int i = n; i < arr.size(); i++){\\n            if (arr[i] < *st.rbegin()){\\n                t_sum += arr[i] - *st.rbegin();\\n                st.erase(--st.end());\\n                st.insert(arr[i]);\\n            }\\n            ans[i] = t_sum;\\n        }\\n        return ans;\\n    }\\n    ll minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        vector<ll> w = get_suf(nums, n);\\n        reverse(nums.begin(), nums.end());\\n        vector<ll> v = get_pre(nums, n);\\n        reverse(v.begin(), v.end());\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     cout << w[i] << \\' \\' << v[i] << endl;\\n        // }\\n        ll ans = LLONG_MAX;\\n        for(int i = 0; i < nums.size()-1; i++){\\n            ans = min(ans, w[i] - v[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nconst ll INF = 1e15;\\nclass Solution {\\npublic:\\n    vector<ll> get_pre(vector<int> &arr, int n){\\n        multiset<int> st;\\n        ll t_sum = 0;\\n        for(int i = 0; i < n; i++)st.insert(arr[i]), t_sum += arr[i];\\n        vector<ll> ans(arr.size(), -INF);\\n        ans[n-1] = t_sum;\\n        for(int i = n; i < arr.size(); i++){\\n            if (arr[i] > *st.begin()){\\n                t_sum += arr[i] - *st.begin();\\n                st.erase(st.begin());\\n                st.insert(arr[i]);\\n            }\\n            ans[i] = t_sum;\\n        }\\n        return ans;\\n    }\\n    vector<ll> get_suf(vector<int> &arr, int n){\\n        multiset<int> st;\\n        ll t_sum = 0;\\n        for(int i = 0; i < n; i++)st.insert(arr[i]), t_sum += arr[i];\\n        vector<ll> ans(arr.size(), INF);\\n        ans[n-1] = t_sum;\\n        for(int i = n; i < arr.size(); i++){\\n            if (arr[i] < *st.rbegin()){\\n                t_sum += arr[i] - *st.rbegin();\\n                st.erase(--st.end());\\n                st.insert(arr[i]);\\n            }\\n            ans[i] = t_sum;\\n        }\\n        return ans;\\n    }\\n    ll minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        vector<ll> w = get_suf(nums, n);\\n        reverse(nums.begin(), nums.end());\\n        vector<ll> v = get_pre(nums, n);\\n        reverse(v.begin(), v.end());\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     cout << w[i] << \\' \\' << v[i] << endl;\\n        // }\\n        ll ans = LLONG_MAX;\\n        for(int i = 0; i < nums.size()-1; i++){\\n            ans = min(ans, w[i] - v[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2571763,
                "title": "which-set-of-values-gives-the-minimum-difference-in-sums-after-removal-of-elements",
                "content": "nums=[16, 46, 43, 41, 42, 14, 36, 49, 50, 28, 38, 25, 17, 5, 18, 11, 14, 21, 23, 39, 23]",
                "solutionTags": [],
                "code": "nums=[16, 46, 43, 41, 42, 14, 36, 49, 50, 28, 38, 25, 17, 5, 18, 11, 14, 21, 23, 39, 23]",
                "codeTag": "Unknown"
            },
            {
                "id": 2556932,
                "title": "python-solution-using-2-heaps-and-prefix-sums",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        mid, left, right = nums[n: 2 * n], [-num for num in nums[:n]], nums[2 * n:]\\n        leftSum, rightSum = [-sum(left)], [sum(right)]\\n        heapify(left)\\n        heapify(right)\\n        for num in mid:\\n            heappush(left, -num)\\n            leftSum.append(leftSum[-1] + num + heappop(left))\\n        for num in mid[::-1]:\\n            heappush(right, num)\\n            rightSum.append(rightSum[-1] + num - heappop(right))\\n        rightSum = rightSum[::-1]\\n        return min(leftSum[i] - rightSum[i] for i in range(n + 1))\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        mid, left, right = nums[n: 2 * n], [-num for num in nums[:n]], nums[2 * n:]\\n        leftSum, rightSum = [-sum(left)], [sum(right)]\\n        heapify(left)\\n        heapify(right)\\n        for num in mid:\\n            heappush(left, -num)\\n            leftSum.append(leftSum[-1] + num + heappop(left))\\n        for num in mid[::-1]:\\n            heappush(right, num)\\n            rightSum.append(rightSum[-1] + num - heappop(right))\\n        rightSum = rightSum[::-1]\\n        return min(leftSum[i] - rightSum[i] for i in range(n + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546335,
                "title": "c-solution-priority-queue-based-sol",
                "content": "```\\nclass Solution {\\n    void get_min(vector<long long> &n_min , vector<int> &nums){\\n        long long mn_sum = 0;\\n        priority_queue<long long> store;\\n        \\n        for(int i = 0; i < nums.size()/3; i++){\\n            mn_sum += nums[i];\\n            store.push(nums[i]);\\n        }\\n        \\n      \\n        n_min[nums.size()/3 - 1] = mn_sum;\\n        \\n        for(int i = nums.size()/3; i < nums.size() - nums.size()/3; i++){\\n            store.push(nums[i]);\\n            mn_sum += nums[i];\\n            \\n            mn_sum -= store.top();\\n            store.pop();\\n            \\n            n_min[i] = mn_sum;\\n        }\\n    }\\n    \\n    void get_max(vector<long long> &n_max , vector<int> &nums){\\n        long long mx_sum = 0;\\n        priority_queue<long long , vector<long long> , greater<long long>> store;\\n        \\n        int n = nums.size();\\n        \\n        for(int i = n - 1; i >= n - n/3; i--){\\n            mx_sum += nums[i];\\n            store.push(nums[i]);\\n        }\\n        \\n        n_max[n - n/3] = mx_sum;\\n        \\n        for(int i = n - n/3 - 1; i >= n/3; i--){\\n            mx_sum += nums[i];\\n            store.push(nums[i]);\\n            \\n            mx_sum -= store.top();\\n            store.pop();\\n            \\n            n_max[i] = mx_sum;\\n        }\\n    }\\n    \\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long ans = 1e10 , n = nums.size() , sz = n/3;\\n        vector<long long> n_min(n) , n_max(n);\\n        \\n        \\n        get_min(n_min , nums);\\n        get_max(n_max , nums);\\n        \\n        for(int i = sz - 1; i < n - sz; i++){\\n            long long temp = n_min[i] - n_max[i + 1];\\n            ans = min(ans , temp);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    void get_min(vector<long long> &n_min , vector<int> &nums){\\n        long long mn_sum = 0;\\n        priority_queue<long long> store;\\n        \\n        for(int i = 0; i < nums.size()/3; i++){\\n            mn_sum += nums[i];\\n            store.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2463379,
                "title": "c-easy-to-understand-with-priority-queue",
                "content": "I just save n lowest sum of prefix and n highest sum of suffix, then solution is minimum between these 2 sum. This is my code implement this idea. If you find this helpful, please upvote.\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        n /= 3;\\n        priority_queue<long long> pq_prefix;\\n        long long current = 0;\\n        vector<long long> prefix(3*n, 0);\\n        vector<long long> suffix(3*n, 0);\\n        for(int i=0; i<n; i++){\\n            current += nums[i];\\n            pq_prefix.push(nums[i]);\\n        }\\n        prefix[n-1] = current;\\n        for(int i=n; i<2*n; i++){\\n            if(pq_prefix.top()>nums[i]){\\n                current -= pq_prefix.top();\\n                pq_prefix.pop();\\n                current += nums[i];\\n                pq_prefix.push(nums[i]);\\n            }\\n            prefix[i] = current;\\n        }\\n        \\n        priority_queue<long long, vector<long long>, greater<long long>> pq_suffix;\\n        current = 0;\\n        for(int i=3*n-1; i>=2*n; i--){\\n            current += nums[i];\\n            pq_suffix.push(nums[i]);\\n        }\\n        suffix[2*n] = current;\\n        for(int i=2*n-1; i>=n; i--){\\n            if(pq_suffix.top()<nums[i]){\\n                current -= pq_suffix.top();\\n                pq_suffix.pop();\\n                current += nums[i];\\n                pq_suffix.push(nums[i]);\\n            }\\n            suffix[i] = current;\\n        }\\n        \\n        long long res = LLONG_MAX;\\n        for(int i=n-1; i<2*n; i++){\\n            res = min(prefix[i]-suffix[i+1], res);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        n /= 3;\\n        priority_queue<long long> pq_prefix;\\n        long long current = 0;\\n        vector<long long> prefix(3*n, 0);\\n        vector<long long> suffix(3*n, 0);\\n        for(int i=0; i<n; i++){\\n            current += nums[i];\\n            pq_prefix.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2412649,
                "title": "python-heap",
                "content": "We use a max heap to create the minimum sum of `n` elements at indices `<= i`, and use a min heap to create the maximum sum of elements at indices `>= i`. We store these sums using dictionaries, and take the best possible solution for all possibile division indices. \\n\\n```\\nimport heapq\\n\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        \\n        def build_lookup(nums_enum, mult=1):\\n            lookup = {}\\n            heap = []\\n            curr_sum = 0\\n            for i, num in nums_enum:\\n                heapq.heappush(heap, mult * num)\\n                curr_sum += num\\n                \\n                if len(heap) > n:\\n                    curr_sum -= mult * heapq.heappop(heap)\\n                \\n                if n - 1 <= i <= 2 * n + 1:\\n                    lookup[i] = curr_sum\\n                \\n            return lookup\\n            \\n        min_lookup = build_lookup(enumerate(nums), -1)\\n        max_lookup = build_lookup(reversed(list(enumerate(nums))))\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(n, 2 * n + 1):\\n            min_diff = min(min_diff, min_lookup[i - 1] - max_lookup[i])\\n            \\n        return min_diff\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\n\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        \\n        def build_lookup(nums_enum, mult=1):\\n            lookup = {}\\n            heap = []\\n            curr_sum = 0\\n            for i, num in nums_enum:\\n                heapq.heappush(heap, mult * num)\\n                curr_sum += num\\n                \\n                if len(heap) > n:\\n                    curr_sum -= mult * heapq.heappop(heap)\\n                \\n                if n - 1 <= i <= 2 * n + 1:\\n                    lookup[i] = curr_sum\\n                \\n            return lookup\\n            \\n        min_lookup = build_lookup(enumerate(nums), -1)\\n        max_lookup = build_lookup(reversed(list(enumerate(nums))))\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(n, 2 * n + 1):\\n            min_diff = min(min_diff, min_lookup[i - 1] - max_lookup[i])\\n            \\n        return min_diff\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392573,
                "title": "simple-easy-c-solution-using-max-haep-and-min-heap",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    long long minimumDifference(vector<int> &a)\\n    {\\n        int N = a.size() / 3;\\n        vector<long long> prefixSum;\\n        vector<long long> suffixSum;\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        priority_queue<int> maxHeap;\\n        long long sum = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            maxHeap.push(a[i]);\\n            sum += a[i];\\n        }\\n        prefixSum.push_back(sum);\\n        for (int i = N; i < 2 * N; i++)\\n        {\\n            if (a[i] < maxHeap.top())\\n            {\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n                sum += a[i];\\n                maxHeap.push(a[i]);\\n            }\\n            prefixSum.push_back(sum);\\n        }\\n        sum = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            minHeap.push(a[3 * N - 1 - i]); \\n            sum += a[3 * N - 1 - i];\\n        }\\n        suffixSum.push_back(sum);\\n\\n        for (int i = N; i < 2 * N; i++)\\n        {\\n            if (a[3 * N - 1 - i] > minHeap.top())\\n            {\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n                sum += a[3 * N - 1 - i];\\n                minHeap.push(a[3 * N - 1 - i]);\\n            }\\n            suffixSum.push_back(sum);\\n        }\\n        cout << prefixSum.size() << suffixSum.size() ;\\n        long long ans = LLONG_MAX;\\n        for (int i = 0; i <  suffixSum.size(); i++)\\n        {\\n            long long diff = prefixSum[i] - suffixSum[suffixSum.size() - i - 1];\\n            ans = min(ans, diff);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long minimumDifference(vector<int> &a)\\n    {\\n        int N = a.size() / 3;\\n        vector<long long> prefixSum;\\n        vector<long long> suffixSum;\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n        priority_queue<int> maxHeap;\\n        long long sum = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            maxHeap.push(a[i]);\\n            sum += a[i];\\n        }\\n        prefixSum.push_back(sum);\\n        for (int i = N; i < 2 * N; i++)\\n        {\\n            if (a[i] < maxHeap.top())\\n            {\\n                sum -= maxHeap.top();\\n                maxHeap.pop();\\n                sum += a[i];\\n                maxHeap.push(a[i]);\\n            }\\n            prefixSum.push_back(sum);\\n        }\\n        sum = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            minHeap.push(a[3 * N - 1 - i]); \\n            sum += a[3 * N - 1 - i];\\n        }\\n        suffixSum.push_back(sum);\\n\\n        for (int i = N; i < 2 * N; i++)\\n        {\\n            if (a[3 * N - 1 - i] > minHeap.top())\\n            {\\n                sum -= minHeap.top();\\n                minHeap.pop();\\n                sum += a[3 * N - 1 - i];\\n                minHeap.push(a[3 * N - 1 - i]);\\n            }\\n            suffixSum.push_back(sum);\\n        }\\n        cout << prefixSum.size() << suffixSum.size() ;\\n        long long ans = LLONG_MAX;\\n        for (int i = 0; i <  suffixSum.size(); i++)\\n        {\\n            long long diff = prefixSum[i] - suffixSum[suffixSum.size() - i - 1];\\n            ans = min(ans, diff);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2251871,
                "title": "hard-best-question-variation-of-amazon-2022-recruitment-test",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3,r=0,l=0;\\n        long long cnt=LLONG_MAX;\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        vector<long long int> temp(nums.size());\\n        for(int i=nums.size()-1;i>=0;i--){\\n           R.push(nums[i]);\\n            r+=nums[i];\\n            if(R.size()>n){\\n                r-=R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n) temp[i]=r;\\n        }\\n        for(int i=0;i<nums.size()-n;i++){\\n            L.push(nums[i]);\\n            l+=nums[i];\\n            if(L.size()>n){\\n                l-=L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n) cnt=min(cnt,l-temp[i+1]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3,r=0,l=0;\\n        long long cnt=LLONG_MAX;\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        vector<long long int> temp(nums.size());\\n        for(int i=nums.size()-1;i>=0;i--){\\n           R.push(nums[i]);\\n            r+=nums[i];\\n            if(R.size()>n){\\n                r-=R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n) temp[i]=r;\\n        }\\n        for(int i=0;i<nums.size()-n;i++){\\n            L.push(nums[i]);\\n            l+=nums[i];\\n            if(L.size()>n){\\n                l-=L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n) cnt=min(cnt,l-temp[i+1]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251360,
                "title": "simple-maxheap-minheap-o-nlogn-time-o-n-space",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        // this can be solve using priority queue;\\n        int n=nums.size();\\n        ll left[n],right[n];\\n        priority_queue<ll>pre; // max heap\\n        priority_queue<ll,vector<ll>,greater<ll>>suf;\\n        ll counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre.size()<n/3)\\n            {\\n                pre.push(nums[i]);\\n                counter+=nums[i];\\n            }\\n            else\\n            {\\n                if(pre.top()>nums[i])\\n                {\\n                    counter-= pre.top();\\n                    pre.pop();\\n                    pre.push(nums[i]);\\n                    counter+=nums[i];\\n                }\\n            }\\n            left[i]=counter;\\n        }\\n        counter=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(suf.size()<n/3)\\n            {\\n                suf.push(nums[i]);\\n                counter+=nums[i];\\n            }\\n            else\\n            {\\n                if(nums[i]>suf.top())\\n                {\\n                    counter-=suf.top();\\n                    suf.pop();\\n                    suf.push(nums[i]);\\n                    counter+=nums[i];\\n                }\\n            }\\n            right[i]=counter;\\n        }\\n    \\n        ll ans=LLONG_MAX;\\n        for(int i=(n/3)-1;i<2*(n/3);i++)\\n        ans=min(ans,left[i]-right[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        // this can be solve using priority queue;\\n        int n=nums.size();\\n        ll left[n],right[n];\\n        priority_queue<ll>pre; // max heap\\n        priority_queue<ll,vector<ll>,greater<ll>>suf;\\n        ll counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre.size()<n/3)\\n            {\\n                pre.push(nums[i]);\\n                counter+=nums[i];\\n            }\\n            else\\n            {\\n                if(pre.top()>nums[i])\\n                {\\n                    counter-= pre.top();\\n                    pre.pop();\\n                    pre.push(nums[i]);\\n                    counter+=nums[i];\\n                }\\n            }\\n            left[i]=counter;\\n        }\\n        counter=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(suf.size()<n/3)\\n            {\\n                suf.push(nums[i]);\\n                counter+=nums[i];\\n            }\\n            else\\n            {\\n                if(nums[i]>suf.top())\\n                {\\n                    counter-=suf.top();\\n                    suf.pop();\\n                    suf.push(nums[i]);\\n                    counter+=nums[i];\\n                }\\n            }\\n            right[i]=counter;\\n        }\\n    \\n        ll ans=LLONG_MAX;\\n        for(int i=(n/3)-1;i<2*(n/3);i++)\\n        ans=min(ans,left[i]-right[i+1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244556,
                "title": "c-prefix-suffix-single-priority-queue",
                "content": "To minimise the resultant we will select N minimum values before i and N maximum after i. \\nWe simply store it inside prefix using priority_queue. \\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n      \\n\\t  int N = A.size()/3 ;\\n             \\n        vector<long long int>pf(3*N,0); \\n        priority_queue<long long int>pq;\\n        long long int sum = 0 ;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(pq.size() < N){\\n                pq.push(A[i]);\\n                sum += A[i] ; \\n                pf[i] = sum ;\\n                continue ;\\n            }\\n            if(pq.top() > A[i]){\\n                sum -= pq.top(); \\n                pq.pop(); \\n                pq.push(A[i]); \\n                sum += A[i];\\n            }\\n            pf[i] = sum ;\\n        }\\n        \\n\\t\\t// Cleaning queue for next iteration and using it as min heap\\n        while(!pq.empty()){\\n            pq.pop(); \\n        }\\n        long long int ans = 1e18 ;\\n        sum = 0 ; \\n        for(int i = A.size()-1 ; i >= 0 ; i--){\\n            if(pq.size() < N){\\n                pq.push(-A[i]); \\n                sum += A[i] ; \\n                continue ;\\n            }\\n            \\n            if(i >= N-1 && i < 2*N){\\n                ans = min(ans , pf[i]-sum);\\n            }\\n            if(A[i] > -pq.top()){\\n                sum -= -pq.top(); \\n                pq.pop(); \\n                sum += A[i] ;\\n                pq.push(-A[i]);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n      \\n\\t  int N = A.size()/3 ;\\n             \\n        vector<long long int>pf(3*N,0); \\n        priority_queue<long long int>pq;\\n        long long int sum = 0 ;\\n        for(int i = 0 ; i < A.size() ; i++){\\n            if(pq.size() < N){\\n                pq.push(A[i]);\\n                sum += A[i] ; \\n                pf[i] = sum ;\\n                continue ;\\n            }\\n            if(pq.top() > A[i]){\\n                sum -= pq.top(); \\n                pq.pop(); \\n                pq.push(A[i]); \\n                sum += A[i];\\n            }\\n            pf[i] = sum ;\\n        }\\n        \\n\\t\\t// Cleaning queue for next iteration and using it as min heap\\n        while(!pq.empty()){\\n            pq.pop(); \\n        }\\n        long long int ans = 1e18 ;\\n        sum = 0 ; \\n        for(int i = A.size()-1 ; i >= 0 ; i--){\\n            if(pq.size() < N){\\n                pq.push(-A[i]); \\n                sum += A[i] ; \\n                continue ;\\n            }\\n            \\n            if(i >= N-1 && i < 2*N){\\n                ans = min(ans , pf[i]-sum);\\n            }\\n            if(A[i] > -pq.top()){\\n                sum -= -pq.top(); \\n                pq.pop(); \\n                sum += A[i] ;\\n                pq.push(-A[i]);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242467,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n      \\n      \\n      int N = A.size()/3;\\n      \\n        vector<long long>dp_left(A.size(),0);\\n        vector<long long>dp_right(A.size(),0);\\n        long long left_sum = 0;\\n        long long right_sum = 0;\\n        \\n        // Calculation for left\\n         priority_queue<int> pq_left;\\n        for (int i = 0; i < N; i++)\\n        {\\n            left_sum += A[i];\\n            pq_left.push(A[i]);\\n        }\\n        \\n        dp_left[N-1] = left_sum;\\n        \\n        for (int i = N; i < 2*N; i++)\\n        {\\n            int top = pq_left.top();\\n            int curr = A[i];\\n            \\n            if (curr < top)\\n            {\\n                pq_left.pop();\\n                pq_left.push(curr);\\n                left_sum -= top;\\n                left_sum += curr;\\n            }\\n            dp_left[i] = left_sum;\\n        }\\n        \\n        \\n        // calculation for right\\n        priority_queue<int,vector<int>,greater<int>> pq_right;\\n        for (int i = A.size()-1; i >=  2*N; i--)\\n        {\\n            right_sum += A[i];\\n            pq_right.push(A[i]);\\n        }\\n        \\n        dp_right[2*N] = right_sum;\\n        \\n        for (int i = 2*N-1; i >= N; i--)\\n        {\\n            int top = pq_right.top();\\n            int curr = A[i];\\n            \\n            if (curr > top)\\n            {\\n                pq_right.pop();\\n                pq_right.push(curr);\\n                right_sum -= top;\\n                right_sum += curr;\\n            }\\n            dp_right[i] = right_sum;\\n        }\\n        \\n        // Calculation of difference;\\n        \\n        // show_vector(dp_left);\\n        // show_vector(dp_right);\\n        long long answer = LLONG_MAX;\\n        for (int i = N-1; i < 2*N; i++ )\\n        {\\n            answer = min(answer,dp_left[i] - dp_right[i+1]);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n      \\n      \\n      int N = A.size()/3;\\n      \\n        vector<long long>dp_left(A.size(),0);\\n        vector<long long>dp_right(A.size(),0);\\n        long long left_sum = 0;\\n        long long right_sum = 0;\\n        \\n        // Calculation for left\\n         priority_queue<int> pq_left;\\n        for (int i = 0; i < N; i++)\\n        {\\n            left_sum += A[i];\\n            pq_left.push(A[i]);\\n        }\\n        \\n        dp_left[N-1] = left_sum;\\n        \\n        for (int i = N; i < 2*N; i++)\\n        {\\n            int top = pq_left.top();\\n            int curr = A[i];\\n            \\n            if (curr < top)\\n            {\\n                pq_left.pop();\\n                pq_left.push(curr);\\n                left_sum -= top;\\n                left_sum += curr;\\n            }\\n            dp_left[i] = left_sum;\\n        }\\n        \\n        \\n        // calculation for right\\n        priority_queue<int,vector<int>,greater<int>> pq_right;\\n        for (int i = A.size()-1; i >=  2*N; i--)\\n        {\\n            right_sum += A[i];\\n            pq_right.push(A[i]);\\n        }\\n        \\n        dp_right[2*N] = right_sum;\\n        \\n        for (int i = 2*N-1; i >= N; i--)\\n        {\\n            int top = pq_right.top();\\n            int curr = A[i];\\n            \\n            if (curr > top)\\n            {\\n                pq_right.pop();\\n                pq_right.push(curr);\\n                right_sum -= top;\\n                right_sum += curr;\\n            }\\n            dp_right[i] = right_sum;\\n        }\\n        \\n        // Calculation of difference;\\n        \\n        // show_vector(dp_left);\\n        // show_vector(dp_right);\\n        long long answer = LLONG_MAX;\\n        for (int i = N-1; i < 2*N; i++ )\\n        {\\n            answer = min(answer,dp_left[i] - dp_right[i+1]);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235143,
                "title": "o-n-log-n-heap-queue-solution",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        L = len(nums)\\n        N = L // 3\\n        \\n        import heapq as hq\\n        \\n        # calculate sum_first of different borders\\n        first = [-n for n in nums[:N]] # negative symbol for max heap\\n        hq.heapify(first)\\n        curr_sum = sum(nums[:N])\\n        sum_firsts = {N: curr_sum}\\n        for i in range(N, L):\\n            hq.heappush(first, -nums[i])\\n            curr_sum += nums[i] + hq.heappop(first) # substract negative = add positive\\n            sum_firsts[i+1] = curr_sum\\n        \\n        \\n        # calculate sum_second of different borders\\n        second = [n for n in nums[-N:]]\\n        hq.heapify(second)\\n        curr_sum = sum(nums[-N:])\\n        sum_seconds = {2 * N : curr_sum}\\n        for i in range(2*N-1, -1, -1):\\n            hq.heappush(second, nums[i])\\n            curr_sum += nums[i] - hq.heappop(second)\\n            sum_seconds[i] = curr_sum\\n        \\n        # calculate diff for every border\\n        ans = math.inf\\n        for i in range(N, N * 2 + 1):\\n            ans = min(ans, sum_firsts[i] - sum_seconds[i])\\n        \\n        \\n        return ans     \\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        L = len(nums)\\n        N = L // 3\\n        \\n        import heapq as hq\\n        \\n        # calculate sum_first of different borders\\n        first = [-n for n in nums[:N]] # negative symbol for max heap\\n        hq.heapify(first)\\n        curr_sum = sum(nums[:N])\\n        sum_firsts = {N: curr_sum}\\n        for i in range(N, L):\\n            hq.heappush(first, -nums[i])\\n            curr_sum += nums[i] + hq.heappop(first) # substract negative = add positive\\n            sum_firsts[i+1] = curr_sum\\n        \\n        \\n        # calculate sum_second of different borders\\n        second = [n for n in nums[-N:]]\\n        hq.heapify(second)\\n        curr_sum = sum(nums[-N:])\\n        sum_seconds = {2 * N : curr_sum}\\n        for i in range(2*N-1, -1, -1):\\n            hq.heappush(second, nums[i])\\n            curr_sum += nums[i] - hq.heappop(second)\\n            sum_seconds[i] = curr_sum\\n        \\n        # calculate diff for every border\\n        ans = math.inf\\n        for i in range(N, N * 2 + 1):\\n            ans = min(ans, sum_firsts[i] - sum_seconds[i])\\n        \\n        \\n        return ans     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225758,
                "title": "cpp-priority-queue-easy",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m=nums.size();\\n        int n=m/3;\\n        ll sum=0;\\n        vector<ll>lft(m,0);\\n        priority_queue<ll>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n        lft[n-1]=sum;\\n        for(int i=n;i<m;i++)\\n        {\\n            if(pq.top()>nums[i])\\n            {\\n                lft[i]=lft[i-1]-pq.top()+nums[i];\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n            else lft[i]=lft[i-1];\\n        }\\n       \\n        \\n        sum=0;\\n        priority_queue<ll,vector<ll>,greater<ll>>pq1;\\n        vector<ll>rgt(m,0);\\n        for(int i=m-1;i>=m-n;i--)\\n        {\\n            sum+=nums[i];\\n            pq1.push(nums[i]);\\n        }\\n        rgt[m-n]=sum;\\n        for(int i=m-n-1;i>=0;i--)\\n        {\\n            if(nums[i]>pq1.top())\\n            {\\n                rgt[i]=rgt[i+1]-pq1.top()+nums[i];\\n                pq1.pop();\\n                pq1.push(nums[i]);\\n            }\\n            else rgt[i]=rgt[i+1];\\n        }\\n         //for(auto&p:rgt)cout<<p<<\" \";\\n        \\n        ll ans=1e18;\\n        for(int i=n-1;i<m-n;i++)\\n        {\\n            if(lft[i]-rgt[i+1]<ans)\\n            ans=lft[i]-rgt[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int m=nums.size();\\n        int n=m/3;\\n        ll sum=0;\\n        vector<ll>lft(m,0);\\n        priority_queue<ll>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pq.push(nums[i]);\\n        }\\n        lft[n-1]=sum;\\n        for(int i=n;i<m;i++)\\n        {\\n            if(pq.top()>nums[i])\\n            {\\n                lft[i]=lft[i-1]-pq.top()+nums[i];\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n            else lft[i]=lft[i-1];\\n        }\\n       \\n        \\n        sum=0;\\n        priority_queue<ll,vector<ll>,greater<ll>>pq1;\\n        vector<ll>rgt(m,0);\\n        for(int i=m-1;i>=m-n;i--)\\n        {\\n            sum+=nums[i];\\n            pq1.push(nums[i]);\\n        }\\n        rgt[m-n]=sum;\\n        for(int i=m-n-1;i>=0;i--)\\n        {\\n            if(nums[i]>pq1.top())\\n            {\\n                rgt[i]=rgt[i+1]-pq1.top()+nums[i];\\n                pq1.pop();\\n                pq1.push(nums[i]);\\n            }\\n            else rgt[i]=rgt[i+1];\\n        }\\n         //for(auto&p:rgt)cout<<p<<\" \";\\n        \\n        ll ans=1e18;\\n        for(int i=n-1;i<m-n;i++)\\n        {\\n            if(lft[i]-rgt[i+1]<ans)\\n            ans=lft[i]-rgt[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2222445,
                "title": "c-easy-to-understand-using-priorityqueue-and-prefixsum",
                "content": "```\\n        public long MinimumDifference(int[] nums)\\n        {\\n            long res = long.MaxValue;\\n            int m = nums.Length;\\n            int n = m / 3;\\n\\n            long maxSum = 0;//sum of removed, must remove max from left side\\n            long sum1 = 0;//total sum from left\\n            long[] prefixSum1 = new long[m];//after removed sum from 0 to i (inclusive), [0,i]\\n            PriorityQueue<long, long> maxHeap = new PriorityQueue<long, long>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                sum1 += nums[i];\\n                maxHeap.Enqueue(nums[i], -nums[i]);\\n            }\\n            prefixSum1[n - 1] = sum1;//sum1-0\\n            //i must <m-1 due to right side [m-n,m-1] contain n elements\\n            for (int i = n; i < m - n; i++)\\n            {\\n                sum1 += nums[i];\\n                maxHeap.Enqueue(nums[i], -nums[i]);\\n                maxSum += maxHeap.Dequeue();\\n                prefixSum1[i] = sum1 - maxSum;\\n            }\\n\\n            long sum2 = 0;//sum from right\\n            long minSum = 0;//sum of removed , must remove min from right side\\n            long[] prefixSum2 = new long[m];//after removed sum from i(exclusive) to m-1 , (i,m-1]\\n            PriorityQueue<long, long> minHeap = new PriorityQueue<long, long>();\\n            for (int i = m - 1; i >= m - n; i--)\\n            {\\n                sum2 += nums[i];\\n                minHeap.Enqueue(nums[i], nums[i]);\\n            }\\n            //i must >=n-1 ,due to left side [0,n-1] contains n elements\\n            for (int i = m - n - 1; i >= n - 1; i--)\\n            {\\n                prefixSum2[i] = sum2 - minSum;\\n                sum2 += nums[i];\\n                minHeap.Enqueue(nums[i], nums[i]);\\n                minSum += minHeap.Dequeue();\\n            }\\n            //i must >=n-1 and i<m-n to ensure left and right both atleast contain n elements\\n            for (int i = n - 1; i < m - n; i++)\\n            {\\n                res = Math.Min(res, prefixSum1[i] - prefixSum2[i]);\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public long MinimumDifference(int[] nums)\\n        {\\n            long res = long.MaxValue;\\n            int m = nums.Length;\\n            int n = m / 3;\\n\\n            long maxSum = 0;//sum of removed, must remove max from left side\\n            long sum1 = 0;//total sum from left\\n            long[] prefixSum1 = new long[m];//after removed sum from 0 to i (inclusive), [0,i]\\n            PriorityQueue<long, long> maxHeap = new PriorityQueue<long, long>();\\n            for (int i = 0; i < n; i++)\\n            {\\n                sum1 += nums[i];\\n                maxHeap.Enqueue(nums[i], -nums[i]);\\n            }\\n            prefixSum1[n - 1] = sum1;//sum1-0\\n            //i must <m-1 due to right side [m-n,m-1] contain n elements\\n            for (int i = n; i < m - n; i++)\\n            {\\n                sum1 += nums[i];\\n                maxHeap.Enqueue(nums[i], -nums[i]);\\n                maxSum += maxHeap.Dequeue();\\n                prefixSum1[i] = sum1 - maxSum;\\n            }\\n\\n            long sum2 = 0;//sum from right\\n            long minSum = 0;//sum of removed , must remove min from right side\\n            long[] prefixSum2 = new long[m];//after removed sum from i(exclusive) to m-1 , (i,m-1]\\n            PriorityQueue<long, long> minHeap = new PriorityQueue<long, long>();\\n            for (int i = m - 1; i >= m - n; i--)\\n            {\\n                sum2 += nums[i];\\n                minHeap.Enqueue(nums[i], nums[i]);\\n            }\\n            //i must >=n-1 ,due to left side [0,n-1] contains n elements\\n            for (int i = m - n - 1; i >= n - 1; i--)\\n            {\\n                prefixSum2[i] = sum2 - minSum;\\n                sum2 += nums[i];\\n                minHeap.Enqueue(nums[i], nums[i]);\\n                minSum += minHeap.Dequeue();\\n            }\\n            //i must >=n-1 and i<m-n to ensure left and right both atleast contain n elements\\n            for (int i = n - 1; i < m - n; i++)\\n            {\\n                res = Math.Min(res, prefixSum1[i] - prefixSum2[i]);\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204758,
                "title": "c-priority-queue",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        int n = a.size()/3;\\n        ll pre[3*n];ll suf[3*n];\\n        ll sum = 0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){sum+=a[i];pq.push(a[i]);}\\n        pre[n-1] = sum;\\n        for(int i=n;i<2*n;i++)\\n        {\\n            ll p = pq.top();\\n            pq.pop();\\n            sum -= p;\\n            ll t = min((ll)a[i],p);\\n            sum += t;\\n            pq.push(t);\\n            pre[i] = sum;\\n        }\\n        while(pq.size())pq.pop();\\n        sum = 0;\\n        for(int i=2*n;i<3*n;i++){sum+=a[i];pq.push(-1*a[i]);}\\n        suf[2*n] = sum;\\n        for(int i=2*n-1;i>=n;i--)\\n        {\\n            ll p = pq.top();\\n            pq.pop();\\n            p*=-1;\\n            sum -= p;\\n            ll t = max((ll)a[i],p);\\n            sum += t;\\n            pq.push(-1*t);\\n            suf[i] = sum;\\n        }\\n        ll ans = 1e17;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n            ans = min(ans,pre[i]-suf[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        int n = a.size()/3;\\n        ll pre[3*n];ll suf[3*n];\\n        ll sum = 0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){sum+=a[i];pq.push(a[i]);}\\n        pre[n-1] = sum;\\n        for(int i=n;i<2*n;i++)\\n        {\\n            ll p = pq.top();\\n            pq.pop();\\n            sum -= p;\\n            ll t = min((ll)a[i],p);\\n            sum += t;\\n            pq.push(t);\\n            pre[i] = sum;\\n        }\\n        while(pq.size())pq.pop();\\n        sum = 0;\\n        for(int i=2*n;i<3*n;i++){sum+=a[i];pq.push(-1*a[i]);}\\n        suf[2*n] = sum;\\n        for(int i=2*n-1;i>=n;i--)\\n        {\\n            ll p = pq.top();\\n            pq.pop();\\n            p*=-1;\\n            sum -= p;\\n            ll t = max((ll)a[i],p);\\n            sum += t;\\n            pq.push(-1*t);\\n            suf[i] = sum;\\n        }\\n        ll ans = 1e17;\\n        for(int i=n-1;i<2*n;i++)\\n        {\\n            ans = min(ans,pre[i]-suf[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195607,
                "title": "python-heap-divide-easy-to-understand",
                "content": "ideas:\\n(1) loop through all the possible boundary of first array and second array;\\n(2) use heap to precompute the first min n items, and the last max n items;\\n(3) iterate all the boundary k in the middle\\n\\n```\\n def minimumDifference(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        n=m//3\\n        cnt=0\\n        left=[0]*m ## left min n sum for nums[:k]\\n        right=[0]*m ## right max n sum nums[k:]\\n        left[n-1]=sum(nums[0:n])\\n        q1=[-a for a in nums[0:n]]\\n        heapify(q1)\\n        for k in range(n,2*n):\\n            heappush(q1,-nums[k])\\n            left[k]=left[k-1]+nums[k]+heappop(q1)\\n        right[2*n]=sum(nums[2*n:m])\\n        q2=nums[2*n:m]\\n        heapify(q2)\\n        for k in range(2*n-1,n-1,-1):\\n            heappush(q2,nums[k])\\n            right[k]=right[k+1]+nums[k]-heappop(q2)\\n        res=float(\\'inf\\')\\n        for i in range(n-1,2*n):\\n            res=min(res,left[i]-right[i+1])\\n        return res",
                "solutionTags": [],
                "code": "ideas:\\n(1) loop through all the possible boundary of first array and second array;\\n(2) use heap to precompute the first min n items, and the last max n items;\\n(3) iterate all the boundary k in the middle\\n\\n```\\n def minimumDifference(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        n=m//3\\n        cnt=0\\n        left=[0]*m ## left min n sum for nums[:k]\\n        right=[0]*m ## right max n sum nums[k:]\\n        left[n-1]=sum(nums[0:n])\\n        q1=[-a for a in nums[0:n]]\\n        heapify(q1)\\n        for k in range(n,2*n):\\n            heappush(q1,-nums[k])\\n            left[k]=left[k-1]+nums[k]+heappop(q1)\\n        right[2*n]=sum(nums[2*n:m])\\n        q2=nums[2*n:m]\\n        heapify(q2)\\n        for k in range(2*n-1,n-1,-1):\\n            heappush(q2,nums[k])\\n            right[k]=right[k+1]+nums[k]-heappop(q2)\\n        res=float(\\'inf\\')\\n        for i in range(n-1,2*n):\\n            res=min(res,left[i]-right[i+1])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2192207,
                "title": "c-min-and-max-heap-solution",
                "content": "Lets make a partition in the array such that both halves have at least `n` elements. Then how can we select `n` elements from each halves such that the difference between the sum of left `n` elements and sum of right `n` elements is minimised? We take the lowest `n` elements from the left half and highest `n` elements from right half. For the left half, push all the elements in the max heap and remove the top elements till the size of the heap is `n`. For the right half, push all the elements in the min heap and remove the top elements till the size of heap is `n`. We will keep an extra variable for the running sum of all the elements in the heap. The difference is the sum of elements in left max heap and right min heap. Do this for all possible partitions. There are `n+1` such partitions(from the left side of `n`th index to right side of `2*n-1`th index). To compute diff of each partition, it would take `O(n*logn)`, and there are `O(n)` such partitions, so total time would be `O(n*n*logn)`. We can identify and remove redundant computations. Lets say you have found minimum `n` elements till index `i` for some `n <= i < 2*n-1`. To get the minimum `n` elemets for index `i+1`, just add that element in the left max heap, remove the top max element, and update the running sum. This can be done in `O(1)` time. Thus, sum of minimum `n` elements in the left half of all possible partitions can be done in `O(n*logn)` time. The sum of maximum `n` elements in the right half of all possible partitions can be done in similar fashion.\\n\\nComplexity:\\nTime: `O(n*logn)`\\nSpace: `O(n)` (extra for heap and left and right partition sums)\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long int leftSum = 0, rightSum = 0, minDiff;\\n        priority_queue<long long int> maxHeap;\\n        priority_queue<long long int, vector<long long int>, greater<long long int>> minHeap;\\n        int n = nums.size()/3, i = 0, j = 3*n-1;\\n        i = 0;\\n        while(i < n){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n            i++;\\n        }\\n        vector<long long int> prefixLeft;\\n        prefixLeft.push_back(leftSum);\\n        while(i < 2*n){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n            leftSum -= maxHeap.top();\\n            maxHeap.pop();\\n            prefixLeft.push_back(leftSum);\\n            i++;\\n        }\\n        j = 3*n-1;\\n        while(2*n <= j){\\n            rightSum += nums[j];\\n            minHeap.push(nums[j]);\\n            j--;\\n        }\\n        vector<long long int> prefixRight;\\n        prefixRight.push_back(rightSum);\\n        while(n <= j){\\n            rightSum += nums[j];\\n            minHeap.push(nums[j]);\\n            rightSum -= minHeap.top();\\n            minHeap.pop();\\n            prefixRight.push_back(rightSum);\\n            j--;\\n        }\\n        reverse(prefixRight.begin(), prefixRight.end());\\n        minDiff = prefixLeft[0] - prefixRight[0];\\n        for(int i = 1; i <= n; i++){\\n            minDiff = min(minDiff, prefixLeft[i] - prefixRight[i]);\\n        }\\n        return minDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long int leftSum = 0, rightSum = 0, minDiff;\\n        priority_queue<long long int> maxHeap;\\n        priority_queue<long long int, vector<long long int>, greater<long long int>> minHeap;\\n        int n = nums.size()/3, i = 0, j = 3*n-1;\\n        i = 0;\\n        while(i < n){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n            i++;\\n        }\\n        vector<long long int> prefixLeft;\\n        prefixLeft.push_back(leftSum);\\n        while(i < 2*n){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n            leftSum -= maxHeap.top();\\n            maxHeap.pop();\\n            prefixLeft.push_back(leftSum);\\n            i++;\\n        }\\n        j = 3*n-1;\\n        while(2*n <= j){\\n            rightSum += nums[j];\\n            minHeap.push(nums[j]);\\n            j--;\\n        }\\n        vector<long long int> prefixRight;\\n        prefixRight.push_back(rightSum);\\n        while(n <= j){\\n            rightSum += nums[j];\\n            minHeap.push(nums[j]);\\n            rightSum -= minHeap.top();\\n            minHeap.pop();\\n            prefixRight.push_back(rightSum);\\n            j--;\\n        }\\n        reverse(prefixRight.begin(), prefixRight.end());\\n        minDiff = prefixLeft[0] - prefixRight[0];\\n        for(int i = 1; i <= n; i++){\\n            minDiff = min(minDiff, prefixLeft[i] - prefixRight[i]);\\n        }\\n        return minDiff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146135,
                "title": "priority-queue-solution-min-and-max-heap-java",
                "content": "class Solution {\\n    public long minimumDifference(int[] nums) {\\n        \\n        int n= nums.length/3;\\n        \\n        //fill rightMaxSum array\\n        //take out n maximum elements, so minHeap\\n        PriorityQueue<Long> pq= new PriorityQueue<>();\\n        long[] rightMaxSumArr= new long[nums.length];\\n        \\n        long sum=0;\\n        for(int i=nums.length-1; i> n-1; i--){\\n            \\n            long val= nums[i];\\n            pq.offer(val); //add into minHeap\\n            sum+= val;\\n            \\n            if(pq.size()<=n){\\n                rightMaxSumArr[i]=sum;\\n                continue;\\n            }\\n            \\n            long removedItem= pq.poll();\\n            sum= sum- removedItem;\\n            \\n            rightMaxSumArr[i]=sum;\\n        }\\n        \\n        //fill leftMinSumArray array\\n        //take out n minimum elements, so maxHeap\\n        PriorityQueue<Long> maxHeap= new PriorityQueue<>(Comparator.reverseOrder());\\n        long[] leftMinSumArray= new long[nums.length];\\n        \\n        sum=0;\\n        for(int i=0; i<nums.length-n; i++){\\n            \\n            long val= nums[i];\\n            maxHeap.offer(val); //add into maxHeap\\n            sum+= val;\\n            \\n            if(maxHeap.size()<=n){\\n                leftMinSumArray[i]=sum;\\n                continue;\\n            }\\n            \\n            long removedItem= maxHeap.poll();\\n            sum= sum- removedItem;\\n            \\n            leftMinSumArray[i]=sum;\\n        }\\n        \\n        //calculate maximum difference\\n        long minDiff= Long.MAX_VALUE;\\n        for(int i=n; i<=nums.length-n; i++){\\n            long diff=leftMinSumArray[i-1]- rightMaxSumArr[i];\\n            minDiff= Math.min(minDiff,diff);\\n            \\n        }\\n        \\n        return minDiff;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public long minimumDifference(int[] nums) {\\n        \\n        int n= nums.length/3;\\n        \\n        //fill rightMaxSum array\\n        //take out n maximum elements, so minHeap\\n        PriorityQueue<Long> pq= new PriorityQueue<>();\\n        long[] rightMaxSumArr= new long[nums.length];\\n        \\n        long sum=0;\\n        for(int i=nums.length-1; i> n-1; i--){\\n            \\n            long val= nums[i];\\n            pq.offer(val); //add into minHeap\\n            sum+= val;\\n            \\n            if(pq.size()<=n){\\n                rightMaxSumArr[i]=sum;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2081084,
                "title": "js-pq",
                "content": "```\\nfunction PriorityQueue(comparator) {\\n\\t//...\\n\\t//For js pq :     https://myleetcode.vercel.app/editor?type=open&no=1439\\n}\\nvar minimumDifference = function (nums) {\\n\\tconst n = nums.length / 3,\\n\\t\\tbuildMaxMinArrays = (start, dir, comparator) => {\\n\\t\\t\\tlet sum = 0,\\n\\t\\t\\t\\tpeek;\\n\\t\\t\\tconst pq = new PriorityQueue(comparator),\\n\\t\\t\\t\\tminMaxSum = [],\\n\\t\\t\\t\\tindex = dir === 1 ? 0 : 2 * n,\\n\\t\\t\\t\\tadd = num => {\\n\\t\\t\\t\\t\\tsum += num - pq.poll();\\n\\t\\t\\t\\t\\tpq.add(num);\\n\\t\\t\\t\\t};\\n\\t\\t\\t//add first n elements to pq for minSum\\n\\t\\t\\t//add last n elements to pq for maxSum\\n\\t\\t\\t//find initial sum as sum of added elements\\n\\t\\t\\tfor (let i = index; i - index < n; i++) {\\n\\t\\t\\t\\tpq.add(nums[i]);\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t}\\n\\t\\t\\t//find minSum of n elements before index i and push it to minSum arr\\n\\t\\t\\t//find maxSum of n elements after index i and unshift it to maxSum arr\\n\\t\\t\\tfor (let i = start; Math.abs(i - start) <= n; i += dir) {\\n\\t\\t\\t\\tminMaxSum.push(sum);\\n\\t\\t\\t\\tpeek = pq.peek();\\n\\t\\t\\t\\t//peek is max for dir=1, min for dir=-1\\n\\t\\t\\t\\t//while finding minsum, if cur item is less than max we should remove max from pq and add cur\\n\\t\\t\\t\\t//while finding maxsum, if cur item is bigger than min we should remove min from pq and add cur\\n\\t\\t\\t\\tdir === 1\\n\\t\\t\\t\\t\\t? nums[i] < peek && add(nums[i])\\n\\t\\t\\t\\t\\t: nums[i] > peek && add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t//instead of unshifting an element into arr each time, reverse the array at the end.\\n\\t\\t\\tdir === -1 && minMaxSum.reverse();\\n\\t\\t\\treturn minMaxSum;\\n\\t\\t},\\n\\t\\tminSum = buildMaxMinArrays(n, 1),\\n\\t\\tmaxSum = buildMaxMinArrays(2 * n - 1, -1, (a, b) => a < b);\\n\\t//return min of minsum[i]-maxsum[i]\\n\\treturn maxSum.reduce(\\n\\t\\t(acc, cur, i) => Math.min(acc, minSum[i] - cur),\\n\\t\\tminSum[0] - maxSum[0]\\n\\t);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction PriorityQueue(comparator) {\\n\\t//...\\n\\t//For js pq :     https://myleetcode.vercel.app/editor?type=open&no=1439\\n}\\nvar minimumDifference = function (nums) {\\n\\tconst n = nums.length / 3,\\n\\t\\tbuildMaxMinArrays = (start, dir, comparator) => {\\n\\t\\t\\tlet sum = 0,\\n\\t\\t\\t\\tpeek;\\n\\t\\t\\tconst pq = new PriorityQueue(comparator),\\n\\t\\t\\t\\tminMaxSum = [],\\n\\t\\t\\t\\tindex = dir === 1 ? 0 : 2 * n,\\n\\t\\t\\t\\tadd = num => {\\n\\t\\t\\t\\t\\tsum += num - pq.poll();\\n\\t\\t\\t\\t\\tpq.add(num);\\n\\t\\t\\t\\t};\\n\\t\\t\\t//add first n elements to pq for minSum\\n\\t\\t\\t//add last n elements to pq for maxSum\\n\\t\\t\\t//find initial sum as sum of added elements\\n\\t\\t\\tfor (let i = index; i - index < n; i++) {\\n\\t\\t\\t\\tpq.add(nums[i]);\\n\\t\\t\\t\\tsum += nums[i];\\n\\t\\t\\t}\\n\\t\\t\\t//find minSum of n elements before index i and push it to minSum arr\\n\\t\\t\\t//find maxSum of n elements after index i and unshift it to maxSum arr\\n\\t\\t\\tfor (let i = start; Math.abs(i - start) <= n; i += dir) {\\n\\t\\t\\t\\tminMaxSum.push(sum);\\n\\t\\t\\t\\tpeek = pq.peek();\\n\\t\\t\\t\\t//peek is max for dir=1, min for dir=-1\\n\\t\\t\\t\\t//while finding minsum, if cur item is less than max we should remove max from pq and add cur\\n\\t\\t\\t\\t//while finding maxsum, if cur item is bigger than min we should remove min from pq and add cur\\n\\t\\t\\t\\tdir === 1\\n\\t\\t\\t\\t\\t? nums[i] < peek && add(nums[i])\\n\\t\\t\\t\\t\\t: nums[i] > peek && add(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\t//instead of unshifting an element into arr each time, reverse the array at the end.\\n\\t\\t\\tdir === -1 && minMaxSum.reverse();\\n\\t\\t\\treturn minMaxSum;\\n\\t\\t},\\n\\t\\tminSum = buildMaxMinArrays(n, 1),\\n\\t\\tmaxSum = buildMaxMinArrays(2 * n - 1, -1, (a, b) => a < b);\\n\\t//return min of minsum[i]-maxsum[i]\\n\\treturn maxSum.reduce(\\n\\t\\t(acc, cur, i) => Math.min(acc, minSum[i] - cur),\\n\\t\\tminSum[0] - maxSum[0]\\n\\t);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076357,
                "title": "c-easy-solution-using-queue-time-o-nlogn-space-o-n",
                "content": "**Approch- Minimize the sum of first part and maximize the sum of second part.**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int m = n/3;\\n        long long sum1=0, sum2 = 0;\\n        priority_queue<int> q;\\n        for(int i=0;i<m;i++)\\n        {\\n            sum1 += a[i];\\n            q.push(a[i]);\\n        }\\n        vector<pair<int,int>> v,p;\\n        for(int i=m;i<n;i++)\\n        {\\n            v.push_back({a[i],i-m});\\n            p.push_back({a[i],0});\\n        }\\n        sort(v.begin(),v.end(),greater<pair<int,int>> ());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(i<m)\\n                sum2 += v[i].first;\\n            p[v[i].second].second = i;\\n        }\\n        int k=m-1;\\n        long long ans = sum1-sum2;\\n        for(int i=0;i<m;i++)\\n        {\\n            q.push(p[i].first);\\n            sum1 += p[i].first;\\n            sum1 -= q.top();\\n            q.pop();\\n            if(p[i].second<=k)\\n            {\\n                sum2 -= p[i].first;\\n                k++;\\n                while(v[k].first==-1)\\n                    k++;\\n                sum2+=v[k].first;\\n            }\\n            else\\n                v[p[i].second].first = -1;\\n            ans = min(ans,sum1-sum2);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int m = n/3;\\n        long long sum1=0, sum2 = 0;\\n        priority_queue<int> q;\\n        for(int i=0;i<m;i++)\\n        {\\n            sum1 += a[i];\\n            q.push(a[i]);\\n        }\\n        vector<pair<int,int>> v,p;\\n        for(int i=m;i<n;i++)\\n        {\\n            v.push_back({a[i],i-m});\\n            p.push_back({a[i],0});\\n        }\\n        sort(v.begin(),v.end(),greater<pair<int,int>> ());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(i<m)\\n                sum2 += v[i].first;\\n            p[v[i].second].second = i;\\n        }\\n        int k=m-1;\\n        long long ans = sum1-sum2;\\n        for(int i=0;i<m;i++)\\n        {\\n            q.push(p[i].first);\\n            sum1 += p[i].first;\\n            sum1 -= q.top();\\n            q.pop();\\n            if(p[i].second<=k)\\n            {\\n                sum2 -= p[i].first;\\n                k++;\\n                while(v[k].first==-1)\\n                    k++;\\n                sum2+=v[k].first;\\n            }\\n            else\\n                v[p[i].second].first = -1;\\n            ans = min(ans,sum1-sum2);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997136,
                "title": "hard-priority-queue-brainstorming-que-variation-of-amazon-2022-recruitment-test",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3,r=0,l=0;\\n        long long cnt=LLONG_MAX;\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        vector<long long int> temp(nums.size());\\n        for(int i=nums.size()-1;i>=0;i--){\\n           R.push(nums[i]);\\n            r+=nums[i];\\n            if(R.size()>n){\\n                r-=R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n) temp[i]=r;\\n        }\\n        for(int i=0;i<nums.size()-n;i++){\\n            L.push(nums[i]);\\n            l+=nums[i];\\n            if(L.size()>n){\\n                l-=L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n) cnt=min(cnt,l-temp[i+1]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3,r=0,l=0;\\n        long long cnt=LLONG_MAX;\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        vector<long long int> temp(nums.size());\\n        for(int i=nums.size()-1;i>=0;i--){\\n           R.push(nums[i]);\\n            r+=nums[i];\\n            if(R.size()>n){\\n                r-=R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n) temp[i]=r;\\n        }\\n        for(int i=0;i<nums.size()-n;i++){\\n            L.push(nums[i]);\\n            l+=nums[i];\\n            if(L.size()>n){\\n                l-=L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n) cnt=min(cnt,l-temp[i+1]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942178,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums)\\n    {\\n        priority_queue<int> l;// storing smallest n element from left\\n        priority_queue<int,vector<int>,greater<int>> r; // storing greatest n element from right\\n        long long  n=nums.size()/3,left=0,right=0;\\n        vector<long long > dp(nums.size()); //like dp;\\n        long long ans=LLONG_MAX;\\n        for(int i=nums.size()-1;i>=n;i--)\\n        {\\n            r.push(nums[i]);\\n            right+=nums[i];\\n            if(r.size()>n)\\n            {\\n                right-=r.top();\\n                r.pop();\\n            }\\n            if(r.size()==n)\\n            {\\n                dp[i]=right;\\n            }\\n        }\\n        for(int i=0;i<nums.size()-n;i++)\\n        {\\n            l.push(nums[i]);\\n            left+=nums[i];\\n            if(l.size()>n)\\n            {\\n                left-=l.top();\\n                l.pop();\\n            }\\n            if(l.size()==n)\\n            {\\n                ans=min(ans,left-dp[i+1]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n// if you like the  solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums)\\n    {\\n        priority_queue<int> l;// storing smallest n element from left\\n        priority_queue<int,vector<int>,greater<int>> r; // storing greatest n element from right\\n        long long  n=nums.size()/3,left=0,right=0;\\n        vector<long long > dp(nums.size()); //like dp;\\n        long long ans=LLONG_MAX;\\n        for(int i=nums.size()-1;i>=n;i--)\\n        {\\n            r.push(nums[i]);\\n            right+=nums[i];\\n            if(r.size()>n)\\n            {\\n                right-=r.top();\\n                r.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1939244,
                "title": "heap-explained-in-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> maxh; //lower half\\n        priority_queue<int, vector<int>, greater<int>> minh; //upper half\\n        int n=nums.size();\\n        int n1=n/3;\\n        // from left side, we want smallest n/3 elements and from right side, we want greatest n/3 elements\\n        // so that sumLeft-sumRight is minimised.\\n\\t\\t// for each index from 0 to n, we will check what can be sum of the smallest n/3 elements from left and sum of the greatest n/3 elements from right\\n        vector<long long> left(n,0);\\n        vector<long long> right(n,0);\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            s+=x;\\n            maxh.push(x);\\n            if(maxh.size()>n1){\\n                int v=maxh.top();\\n                maxh.pop();\\n                s-=v;\\n            }\\n            left[i]=s;\\n        }\\n        s=0;\\n        for(int i=n-1;i>=0;i--){\\n            int x=nums[i];\\n            s+=x;\\n            minh.push(nums[i]);\\n            if(minh.size()>n1){\\n                int v=minh.top();\\n                minh.pop();\\n                s-=v;\\n            }\\n            right[i]=s;\\n        }\\n        long long ans=LLONG_MAX;\\n        for(int i=n1-1;i<2*n1;i++){\\n            ans=min(ans, left[i]-right[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> maxh; //lower half\\n        priority_queue<int, vector<int>, greater<int>> minh; //upper half\\n        int n=nums.size();\\n        int n1=n/3;\\n        // from left side, we want smallest n/3 elements and from right side, we want greatest n/3 elements\\n        // so that sumLeft-sumRight is minimised.\\n\\t\\t// for each index from 0 to n, we will check what can be sum of the smallest n/3 elements from left and sum of the greatest n/3 elements from right\\n        vector<long long> left(n,0);\\n        vector<long long> right(n,0);\\n        long long s=0;\\n        for(int i=0;i<n;i++){\\n            int x=nums[i];\\n            s+=x;\\n            maxh.push(x);\\n            if(maxh.size()>n1){\\n                int v=maxh.top();\\n                maxh.pop();\\n                s-=v;\\n            }\\n            left[i]=s;\\n        }\\n        s=0;\\n        for(int i=n-1;i>=0;i--){\\n            int x=nums[i];\\n            s+=x;\\n            minh.push(nums[i]);\\n            if(minh.size()>n1){\\n                int v=minh.top();\\n                minh.pop();\\n                s-=v;\\n            }\\n            right[i]=s;\\n        }\\n        long long ans=LLONG_MAX;\\n        for(int i=n1-1;i<2*n1;i++){\\n            ans=min(ans, left[i]-right[i+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899621,
                "title": "c-priorityqueue-with-clear-functions-using-linq",
                "content": "\\n    public long MinimumDifference(int[] nums)\\n\\t{\\n        var n = nums.Count() / 3;\\n        var leftQueue = Build(nums[..n], true, out var leftSum);\\n        var leftBests = Traverse(leftQueue, nums[n..(2*n)], n, leftSum, true);\\n        var rightQueue = Build(nums[(2*n)..], false, out var rightSum);\\n        var rightBests = Traverse(rightQueue, nums[n..(2*n)].Reverse().ToArray(), n, rightSum, false).Reverse();\\n        var minDiff = Enumerable.Zip(leftBests, rightBests).Select(pair => pair.First - pair.Second).Min();\\n        return minDiff;\\n    }\\n    \\n    private PriorityQueue<int, int> Build(int[] nums, bool left, out long sum)\\n    {\\n        var queue = new PriorityQueue<int, int>();\\n        foreach (var num in nums)\\n        {\\n            var prior = left ? -num : num;\\n            queue.Enqueue(num, prior);\\n        }\\n        sum = nums.Select(num => (long)num).Sum();\\n        return queue;\\n    }\\n    \\n    private IList<long> Traverse(PriorityQueue<int, int> queue, int[] nums, int n, long sum, bool left)\\n    {\\n        var bestSum = new List<long> { sum };\\n        foreach (var num in nums)\\n        {\\n            var prior = left ? -num : num;\\n            queue.Enqueue(num, prior);\\n            var pop = queue.Dequeue();\\n            sum += (num - pop);\\n            bestSum.Add(sum);\\n        }\\n        return bestSum;\\n    }",
                "solutionTags": [],
                "code": "\\n    public long MinimumDifference(int[] nums)\\n\\t{\\n        var n = nums.Count() / 3;\\n        var leftQueue = Build(nums[..n], true, out var leftSum);\\n        var leftBests = Traverse(leftQueue, nums[n..(2*n)], n, leftSum, true);\\n        var rightQueue = Build(nums[(2*n)..], false, out var rightSum);\\n        var rightBests = Traverse(rightQueue, nums[n..(2*n)].Reverse().ToArray(), n, rightSum, false).Reverse();\\n        var minDiff = Enumerable.Zip(leftBests, rightBests).Select(pair => pair.First - pair.Second).Min();\\n        return minDiff;\\n    }\\n    \\n    private PriorityQueue<int, int> Build(int[] nums, bool left, out long sum)\\n    {\\n        var queue = new PriorityQueue<int, int>();\\n        foreach (var num in nums)\\n        {\\n            var prior = left ? -num : num;\\n            queue.Enqueue(num, prior);\\n        }\\n        sum = nums.Select(num => (long)num).Sum();\\n        return queue;\\n    }\\n    \\n    private IList<long> Traverse(PriorityQueue<int, int> queue, int[] nums, int n, long sum, bool left)\\n    {\\n        var bestSum = new List<long> { sum };\\n        foreach (var num in nums)\\n        {\\n            var prior = left ? -num : num;\\n            queue.Enqueue(num, prior);\\n            var pop = queue.Dequeue();\\n            sum += (num - pop);\\n            bestSum.Add(sum);\\n        }\\n        return bestSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1848099,
                "title": "python-2-heaps-explained",
                "content": "If remaining elements are divided into 2 parts at position i, to minimize Sum_first - Sum_secode, we would selet the n smallest elements in nums[:i] and n largest elements in nums[i:].\\n\\nNow the question is to\\n* compute the sum of n smallest elements in nums[:i] (n<i<=2n)\\n* compute the sum of n largest elements in nums[i:] (n<i<=2n)\\n\\nUse heap to reduce the time spent on summation, so we can achieve O(NlogN).\\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        \\n        maxHeap = [-i for i in nums[:n]]\\n        heapq.heapify(maxHeap)\\n        sum1 = [sum(nums[:n])]\\n        for i in range(n, 2*n):\\n            heapq.heappush(maxHeap, -nums[i])\\n            delete = -heapq.heappop(maxHeap)\\n            sum1.append(sum1[-1] + nums[i] - delete)\\n        \\n        minHeap = nums[2*n:]\\n        heapq.heapify(minHeap)\\n        sum2 = [sum(minHeap)]\\n        for i in range(2*n-1, n-1, -1):\\n            heapq.heappush(minHeap, nums[i])\\n            delete = heapq.heappop(minHeap)\\n            sum2.insert(0, sum2[0] + nums[i] - delete)\\n\\t\\t\\n        return min(sum1[i] - sum2[i] for i in range(n+1))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n        \\n        maxHeap = [-i for i in nums[:n]]\\n        heapq.heapify(maxHeap)\\n        sum1 = [sum(nums[:n])]\\n        for i in range(n, 2*n):\\n            heapq.heappush(maxHeap, -nums[i])\\n            delete = -heapq.heappop(maxHeap)\\n            sum1.append(sum1[-1] + nums[i] - delete)\\n        \\n        minHeap = nums[2*n:]\\n        heapq.heapify(minHeap)\\n        sum2 = [sum(minHeap)]\\n        for i in range(2*n-1, n-1, -1):\\n            heapq.heappush(minHeap, nums[i])\\n            delete = heapq.heappop(minHeap)\\n            sum2.insert(0, sum2[0] + nums[i] - delete)\\n\\t\\t\\n        return min(sum1[i] - sum2[i] for i in range(n+1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818365,
                "title": "go-golang-two-heaps",
                "content": "```\\nfunc minimumDifference(nums []int) int64 {\\n\\tn := len(nums) / 3\\n\\n\\tmaxH, minH := maxHeap(make([]int, 0, n)), minHeap(make([]int, 0, n))\\n\\tleftSum, rightSum := 0, 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tleftSum += nums[i]\\n\\t\\tmaxH = append(maxH, nums[i])\\n\\n\\t\\tj := len(nums) - i - 1\\n\\t\\trightSum += nums[j]\\n\\t\\tminH = append(minH, nums[j])\\n\\t}\\n\\n\\theap.Init(&maxH)\\n\\theap.Init(&minH)\\n\\n\\tdiff := make([]int, n+1)\\n\\tfor i := range diff {\\n\\t\\tdiff[i] += leftSum\\n\\t\\tdiff[len(diff)-i-1] -= rightSum\\n\\n\\t\\tl, r := n+i, len(nums)-n-i-1\\n\\t\\theap.Push(&maxH, nums[l])\\n\\t\\theap.Push(&minH, nums[r])\\n\\n\\t\\tleftSum += nums[l]\\n\\t\\tleftSum -= heap.Pop(&maxH).(int)\\n\\n\\t\\trightSum += nums[r]\\n\\t\\trightSum -= heap.Pop(&minH).(int)\\n\\t}\\n\\n\\tres := math.MaxInt64\\n\\tfor _, d := range diff {\\n\\t\\tif d < res {\\n\\t\\t\\tres = d\\n\\t\\t}\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n\\ntype minHeap []int\\n\\nfunc (h minHeap) Len() int            { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool  { return h[i] < h[j] }\\nfunc (h minHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *minHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *minHeap) Pop() (v interface{}) {\\n\\tv = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\n\\treturn v\\n}\\n\\ntype maxHeap []int\\n\\nfunc (h maxHeap) Len() int            { return len(h) }\\nfunc (h maxHeap) Less(i, j int) bool  { return h[i] > h[j] }\\nfunc (h maxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *maxHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *maxHeap) Pop() (v interface{}) {\\n\\tv = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\n\\treturn v\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc minimumDifference(nums []int) int64 {\\n\\tn := len(nums) / 3\\n\\n\\tmaxH, minH := maxHeap(make([]int, 0, n)), minHeap(make([]int, 0, n))\\n\\tleftSum, rightSum := 0, 0\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tleftSum += nums[i]\\n\\t\\tmaxH = append(maxH, nums[i])\\n\\n\\t\\tj := len(nums) - i - 1\\n\\t\\trightSum += nums[j]\\n\\t\\tminH = append(minH, nums[j])\\n\\t}\\n\\n\\theap.Init(&maxH)\\n\\theap.Init(&minH)\\n\\n\\tdiff := make([]int, n+1)\\n\\tfor i := range diff {\\n\\t\\tdiff[i] += leftSum\\n\\t\\tdiff[len(diff)-i-1] -= rightSum\\n\\n\\t\\tl, r := n+i, len(nums)-n-i-1\\n\\t\\theap.Push(&maxH, nums[l])\\n\\t\\theap.Push(&minH, nums[r])\\n\\n\\t\\tleftSum += nums[l]\\n\\t\\tleftSum -= heap.Pop(&maxH).(int)\\n\\n\\t\\trightSum += nums[r]\\n\\t\\trightSum -= heap.Pop(&minH).(int)\\n\\t}\\n\\n\\tres := math.MaxInt64\\n\\tfor _, d := range diff {\\n\\t\\tif d < res {\\n\\t\\t\\tres = d\\n\\t\\t}\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n\\ntype minHeap []int\\n\\nfunc (h minHeap) Len() int            { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool  { return h[i] < h[j] }\\nfunc (h minHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *minHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *minHeap) Pop() (v interface{}) {\\n\\tv = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\n\\treturn v\\n}\\n\\ntype maxHeap []int\\n\\nfunc (h maxHeap) Len() int            { return len(h) }\\nfunc (h maxHeap) Less(i, j int) bool  { return h[i] > h[j] }\\nfunc (h maxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *maxHeap) Push(x interface{}) { *h = append(*h, x.(int)) }\\nfunc (h *maxHeap) Pop() (v interface{}) {\\n\\tv = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\n\\treturn v\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797902,
                "title": "python-3",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        m=len(nums)\\n        n=m//3\\n        left=[-nums[x] for x in range(n)]\\n        heapq.heapify(left)\\n        right=nums[2*n:]\\n        heapq.heapify(right)\\n        currleft=sum(nums[:n])\\n        currright=sum(nums[2*n:])\\n        dp=[0]*(n+1)\\n        dp[0]+=currleft\\n        dp[-1]-=currright\\n        for i in range(n,2*n):\\n            pop=heapq.heappushpop(left,-nums[i])\\n            currleft=currleft+pop+nums[i]\\n            popr=heapq.heappushpop(right,nums[m-1-i])\\n            currright=currright-popr+nums[m-1-i]\\n            dp[i-n+1]+=currleft\\n            dp[-(i-n+1)-1]-=currright\\n        return min(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        \\n        m=len(nums)\\n        n=m//3\\n        left=[-nums[x] for x in range(n)]\\n        heapq.heapify(left)\\n        right=nums[2*n:]\\n        heapq.heapify(right)\\n        currleft=sum(nums[:n])\\n        currright=sum(nums[2*n:])\\n        dp=[0]*(n+1)\\n        dp[0]+=currleft\\n        dp[-1]-=currright\\n        for i in range(n,2*n):\\n            pop=heapq.heappushpop(left,-nums[i])\\n            currleft=currleft+pop+nums[i]\\n            popr=heapq.heappushpop(right,nums[m-1-i])\\n            currright=currright-popr+nums[m-1-i]\\n            dp[i-n+1]+=currleft\\n            dp[-(i-n+1)-1]-=currright\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782466,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e16 + 7;\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n / 3;\\n        vector<long long> left(n);\\n        vector<long long> right(n);\\n        multiset<int> l;\\n        multiset<int> r;\\n        left[0] = nums[0];\\n        l.insert(nums[0]);\\n        for(int i = 1; i < n; i++) {\\n            int le = i + 1;\\n            l.insert(nums[i]);\\n            if(le <= len) {\\n                left[i] = left[i - 1] + nums[i];\\n            }\\n            else {\\n                int val = *prev(l.end());\\n                left[i] = left[i - 1] + nums[i] - val;\\n                l.erase(l.lower_bound(val));\\n            \\n            }\\n        }\\n        right[n - 1] = nums[n - 1];\\n        r.insert(nums[n - 1]);\\n        for(int i = n - 2; i >= 0; i--) {\\n            int le = n - i;\\n            r.insert(nums[i]);\\n            if(le <= len) {\\n                right[i] = right[i + 1] + nums[i];\\n            }\\n            else {\\n                int val = *r.begin();\\n                right[i] = right[i + 1] + nums[i] - val;\\n                r.erase(r.lower_bound(val));\\n            }\\n        }\\n        long long sol = INF;\\n        for(int i = len - 1; i < n - len; i++) {\\n            sol = min(sol, left[i] - right[i + 1]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e16 + 7;\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int len = n / 3;\\n        vector<long long> left(n);\\n        vector<long long> right(n);\\n        multiset<int> l;\\n        multiset<int> r;\\n        left[0] = nums[0];\\n        l.insert(nums[0]);\\n        for(int i = 1; i < n; i++) {\\n            int le = i + 1;\\n            l.insert(nums[i]);\\n            if(le <= len) {\\n                left[i] = left[i - 1] + nums[i];\\n            }\\n            else {\\n                int val = *prev(l.end());\\n                left[i] = left[i - 1] + nums[i] - val;\\n                l.erase(l.lower_bound(val));\\n            \\n            }\\n        }\\n        right[n - 1] = nums[n - 1];\\n        r.insert(nums[n - 1]);\\n        for(int i = n - 2; i >= 0; i--) {\\n            int le = n - i;\\n            r.insert(nums[i]);\\n            if(le <= len) {\\n                right[i] = right[i + 1] + nums[i];\\n            }\\n            else {\\n                int val = *r.begin();\\n                right[i] = right[i + 1] + nums[i] - val;\\n                r.erase(r.lower_bound(val));\\n            }\\n        }\\n        long long sol = INF;\\n        for(int i = len - 1; i < n - len; i++) {\\n            sol = min(sol, left[i] - right[i + 1]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775246,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) \\n    {\\n        long long n=nums.size();\\n        long long N=n/3;\\n        vector<long long>prefix(n,1e17),suffix(n,1e17);\\n        priority_queue<long long>pq_max;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pq_max.push(nums[i]);\\n            if(pq_max.size()>N)\\n            {\\n                sum-=pq_max.top();\\n                pq_max.pop();\\n            }\\n            if(pq_max.size()==N)\\n            {\\n                prefix[i]=sum;\\n            }\\n        }\\n        priority_queue<long long,vector<long long>,greater<long long>>pq_min;\\n        sum=0;\\n        for(int i=n-1;~i;i--)\\n        {\\n            sum+=nums[i];\\n            pq_min.push(nums[i]);\\n            if(pq_min.size()>N)\\n            {\\n                sum-=pq_min.top();\\n                pq_min.pop();\\n            }\\n            if(pq_min.size()==N)\\n            {\\n                suffix[i]=sum;\\n            }\\n        }\\n        long long ans=1e17;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(prefix[i]!=1e17&&suffix[i+1]!=1e17)\\n            {\\n                ans=min(ans,prefix[i]-suffix[i+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) \\n    {\\n        long long n=nums.size();\\n        long long N=n/3;\\n        vector<long long>prefix(n,1e17),suffix(n,1e17);\\n        priority_queue<long long>pq_max;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            pq_max.push(nums[i]);\\n            if(pq_max.size()>N)\\n            {\\n                sum-=pq_max.top();\\n                pq_max.pop();\\n            }\\n            if(pq_max.size()==N)\\n            {\\n                prefix[i]=sum;\\n            }\\n        }\\n        priority_queue<long long,vector<long long>,greater<long long>>pq_min;\\n        sum=0;\\n        for(int i=n-1;~i;i--)\\n        {\\n            sum+=nums[i];\\n            pq_min.push(nums[i]);\\n            if(pq_min.size()>N)\\n            {\\n                sum-=pq_min.top();\\n                pq_min.pop();\\n            }\\n            if(pq_min.size()==N)\\n            {\\n                suffix[i]=sum;\\n            }\\n        }\\n        long long ans=1e17;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(prefix[i]!=1e17&&suffix[i+1]!=1e17)\\n            {\\n                ans=min(ans,prefix[i]-suffix[i+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771515,
                "title": "javascript-solution-with-heap",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n//Creating heap \\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                return b-a;\\n            }else{\\n                return a-b;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    let maxHeap=new Heap(),minHeap=new Heap(\\'min\\'),sum=0;\\n    let n = nums.length/3,leftArr=[],rightArr=[];\\n    for(let i=0;i<2*n;i++){\\n        if(maxHeap.getSize()<n){\\n            sum += nums[i];\\n            maxHeap.insert(nums[i]);\\n        }else{\\n            if(maxHeap.getTop()>nums[i]){\\n                let top = maxHeap.removeTop();\\n                sum -= top;\\n                sum += nums[i];\\n                maxHeap.insert(nums[i]);\\n            }\\n            \\n        }\\n        if(maxHeap.getSize()===n){\\n            leftArr.push(sum);\\n        }\\n    }\\n    sum=0;\\n    for(let i=3*n-1;i>=n;i--){\\n        if(minHeap.getSize()<n){\\n            sum += nums[i];\\n            minHeap.insert(nums[i]);\\n        }else{\\n            if(minHeap.getTop()<nums[i]){\\n                let top = minHeap.removeTop();\\n                sum -= top;\\n                sum += nums[i];\\n                minHeap.insert(nums[i]);\\n            }\\n            \\n        }\\n        if(minHeap.getSize()===n){\\n            rightArr.push(sum);\\n        }\\n    }\\n    rightArr.reverse();\\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    for(let i=0;i<leftArr.length;i++){\\n        min = Math.min(min,leftArr[i]-rightArr[i]);\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n//Creating heap \\n    class Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                return b-a;\\n            }else{\\n                return a-b;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n    let maxHeap=new Heap(),minHeap=new Heap(\\'min\\'),sum=0;\\n    let n = nums.length/3,leftArr=[],rightArr=[];\\n    for(let i=0;i<2*n;i++){\\n        if(maxHeap.getSize()<n){\\n            sum += nums[i];\\n            maxHeap.insert(nums[i]);\\n        }else{\\n            if(maxHeap.getTop()>nums[i]){\\n                let top = maxHeap.removeTop();\\n                sum -= top;\\n                sum += nums[i];\\n                maxHeap.insert(nums[i]);\\n            }\\n            \\n        }\\n        if(maxHeap.getSize()===n){\\n            leftArr.push(sum);\\n        }\\n    }\\n    sum=0;\\n    for(let i=3*n-1;i>=n;i--){\\n        if(minHeap.getSize()<n){\\n            sum += nums[i];\\n            minHeap.insert(nums[i]);\\n        }else{\\n            if(minHeap.getTop()<nums[i]){\\n                let top = minHeap.removeTop();\\n                sum -= top;\\n                sum += nums[i];\\n                minHeap.insert(nums[i]);\\n            }\\n            \\n        }\\n        if(minHeap.getSize()===n){\\n            rightArr.push(sum);\\n        }\\n    }\\n    rightArr.reverse();\\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    for(let i=0;i<leftArr.length;i++){\\n        min = Math.min(min,leftArr[i]-rightArr[i]);\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762385,
                "title": "python3-two-pass-greedy-priority-queue-solution-with-brief-explanation",
                "content": "The greedy idea is that we want to get the top n smallest elements from the first half and get the top n largest element from the second half and then take the difference. We take the difference at each possible pivot and return the smallest difference as our answer.\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        pq = []\\n        n = len(nums)\\n        tmp = [None] * n\\n        su = 0\\n        for i, x in enumerate(nums):\\n            heappush(pq, -x)\\n            su += x\\n            if len(pq) > n // 3:\\n                val = heappop(pq)\\n                su += val\\n            if len(pq) == n // 3:\\n                tmp[i] = su\\n        pq.clear()\\n        su = 0\\n        res = float(\\'inf\\')\\n        for i in range(n - 1, -1, -1):\\n            heappush(pq, nums[i])\\n            su += nums[i]\\n            if len(pq) > n // 3:\\n                val = heappop(pq)\\n                su -= val\\n            if len(pq) == n // 3:\\n                if i - 1 >= 0 and tmp[i - 1] != None:\\n                    res = min(res, tmp[i - 1] - su)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        pq = []\\n        n = len(nums)\\n        tmp = [None] * n\\n        su = 0\\n        for i, x in enumerate(nums):\\n            heappush(pq, -x)\\n            su += x\\n            if len(pq) > n // 3:\\n                val = heappop(pq)\\n                su += val\\n            if len(pq) == n // 3:\\n                tmp[i] = su\\n        pq.clear()\\n        su = 0\\n        res = float(\\'inf\\')\\n        for i in range(n - 1, -1, -1):\\n            heappush(pq, nums[i])\\n            su += nums[i]\\n            if len(pq) > n // 3:\\n                val = heappop(pq)\\n                su -= val\\n            if len(pq) == n // 3:\\n                if i - 1 >= 0 and tmp[i - 1] != None:\\n                    res = min(res, tmp[i - 1] - su)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759485,
                "title": "python3",
                "content": "sum of min heap of size n from the left side - sum of max heap of size n from right side\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        left, right, diff = list(), list(), [0]*(n+1)\\n        i, sum_left, sum_right = 0, 0, 0\\n        while i<n:\\n            left.append(-nums[i])\\n            sum_left+=nums[i]\\n            right.append(nums[len(nums)-1-i])\\n            sum_right+=nums[len(nums)-1-i]\\n            i+=1\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n        diff[0], diff[n] = sum_left, -sum_right\\n        index_left, index_right = 1, n-1\\n        while i<2*n:\\n            popped = heapq.heappushpop(left, -nums[i])\\n            sum_left += popped + nums[i]\\n            diff[index_left] += sum_left\\n            index_left+=1\\n            popped = heapq.heappushpop(right, nums[len(nums)-i-1])\\n            sum_right = sum_right - popped + nums[len(nums)-i-1]\\n            diff[index_right] += -sum_right\\n            index_right-=1        \\n            i+=1            \\n        return min(diff)\\n            \\n             \\n            \\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "sum of min heap of size n from the left side - sum of max heap of size n from right side\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        left, right, diff = list(), list(), [0]*(n+1)\\n        i, sum_left, sum_right = 0, 0, 0\\n        while i<n:\\n            left.append(-nums[i])\\n            sum_left+=nums[i]\\n            right.append(nums[len(nums)-1-i])\\n            sum_right+=nums[len(nums)-1-i]\\n            i+=1\\n        heapq.heapify(left)\\n        heapq.heapify(right)\\n        diff[0], diff[n] = sum_left, -sum_right\\n        index_left, index_right = 1, n-1\\n        while i<2*n:\\n            popped = heapq.heappushpop(left, -nums[i])\\n            sum_left += popped + nums[i]\\n            diff[index_left] += sum_left\\n            index_left+=1\\n            popped = heapq.heappushpop(right, nums[len(nums)-i-1])\\n            sum_right = sum_right - popped + nums[len(nums)-i-1]\\n            diff[index_right] += -sum_right\\n            index_right-=1        \\n            i+=1            \\n        return min(diff)\\n            \\n             \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1756823,
                "title": "java-o-n-logn-heap-memo",
                "content": "To get the minimum difference, consider dividing the array into two halves: on the left side, we want to pick the min N numbers, on the right side, we want to pick the max N numbers.\\n\\nLet\\'s only consider the left side case aka picking min N numbers from index 0 -> i, we define the following variables:\\n` maxHeap ` to keep track of min N numbers so far, remove the highest number if heap size reaches n + 1.\\n` current ` to keep track of current sum of those N numbers\\n` leftMemo[i] ` to record the ` current ` value for each index i\\n\\nThen we can do the same thing for the max N numbers starting from index nums.length - 1 to the left, from which we get ` rightMemo[i] `, which records the max N sum from index  i -> nums.length - 1.\\n\\nWe do a final iteration to get the min(leftMemo[i] - rightMemo[i + 1]).\\n \\n\\n```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n        long[] leftMemo = new long[nums.length];\\n        long[] rightMemo = new long[nums.length];\\n        long current = 0L;\\n        for (int i = 0; i <= 2 * n - 1; i++) {\\n            current += nums[i];\\n            maxHeap.add(nums[i]);\\n            if (maxHeap.size() > n) {\\n                int removed = maxHeap.poll();\\n                current -= removed;\\n                leftMemo[i] = current;\\n            }\\n            if (maxHeap.size() == n) {\\n                leftMemo[i] = current;\\n            }\\n        }\\n        current = 0;\\n        for (int i = nums.length - 1; i >= n; i--) {\\n            current += nums[i];\\n            minHeap.add(nums[i]);\\n            if (minHeap.size() > n) {\\n                int removed = minHeap.poll();\\n                current -= removed;\\n            }\\n            if (minHeap.size() == n) {\\n                rightMemo[i] = current;\\n            }\\n        }\\n        long min = Long.MAX_VALUE;\\n        for (int i = n - 1; i <= 2 * n - 1; i++) {\\n            min = Math.min(min, leftMemo[i] - rightMemo[i + 1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\\n        long[] leftMemo = new long[nums.length];\\n        long[] rightMemo = new long[nums.length];\\n        long current = 0L;\\n        for (int i = 0; i <= 2 * n - 1; i++) {\\n            current += nums[i];\\n            maxHeap.add(nums[i]);\\n            if (maxHeap.size() > n) {\\n                int removed = maxHeap.poll();\\n                current -= removed;\\n                leftMemo[i] = current;\\n            }\\n            if (maxHeap.size() == n) {\\n                leftMemo[i] = current;\\n            }\\n        }\\n        current = 0;\\n        for (int i = nums.length - 1; i >= n; i--) {\\n            current += nums[i];\\n            minHeap.add(nums[i]);\\n            if (minHeap.size() > n) {\\n                int removed = minHeap.poll();\\n                current -= removed;\\n            }\\n            if (minHeap.size() == n) {\\n                rightMemo[i] = current;\\n            }\\n        }\\n        long min = Long.MAX_VALUE;\\n        for (int i = n - 1; i <= 2 * n - 1; i++) {\\n            min = Math.min(min, leftMemo[i] - rightMemo[i + 1]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756707,
                "title": "both-tle-and-optimised-solution",
                "content": "For Diagrams Check [Solution 1](https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/discuss/1747244/Two-Heaps-and-Temp-Array) and [Solution 2](https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/discuss/1747029/Python-Explanation-with-pictures-Priority-Queue.)\\n\\n**First: Optimised Solution Using Heap:**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let prefixMin = [];\\n    let suffixMax = [];\\n    \\n    let min = Infinity;\\n    \\n    const maxHeap = new Heap((a,b) => {\\n        return a.val < b.val\\n    },  Infinity);\\n    \\n    const minHeap = new Heap((a,b) => {\\n        return a.val > b.val\\n    },  -Infinity);\\n    \\n    let sum = 0;\\n    for(let i = 0; i < n; i++) {\\n        let data = { val: nums[i] };\\n        maxHeap.insert(data);\\n        sum += nums[i];\\n    }\\n    prefixMin.push(sum);\\n    \\n    \\n    for(let i = n; i < nums.length - n; i++) {\\n        let top = maxHeap.peek();\\n        let data = { val: nums[i] };\\n        \\n        if(top.val > nums[i]) {\\n            let max = maxHeap.extractMax();\\n            let lastSum = prefixMin[prefixMin.length - 1];\\n            lastSum -= max.val;\\n            lastSum += nums[i];\\n            maxHeap.insert(data);\\n            prefixMin.push(lastSum);\\n        } else {\\n            let lastSum = prefixMin[prefixMin.length - 1];\\n            prefixMin.push(lastSum);\\n        }\\n    }\\n    \\n    sum = 0;\\n    for(let i = nums.length - 1; i >= nums.length - n; i--) {\\n        let data = { val: nums[i] };\\n        minHeap.insert(data);\\n        sum += nums[i];\\n    }\\n    suffixMax.push(sum);\\n    \\n    for(let i = nums.length - n - 1; i >= n; i--) {\\n        let top = minHeap.peek();\\n        let data = { val: nums[i] };\\n        \\n        if(top.val < nums[i]) {\\n            let max = minHeap.extractMax();\\n            let lastSum = suffixMax[suffixMax.length - 1];\\n            lastSum -= max.val;\\n            lastSum += nums[i];\\n            minHeap.insert(data);\\n            suffixMax.push(lastSum);\\n        } else {\\n            let lastSum = suffixMax[suffixMax.length - 1];\\n            suffixMax.push(lastSum);\\n        }\\n    }\\n    \\n    let l = prefixMin.length;\\n    suffixMax.reverse();\\n    \\n    for(let i = 0; i < l; i++) {\\n        min = Math.min(prefixMin[i] - suffixMax[i], min);\\n    }\\n    \\n    return min;\\n};\\n\\nclass Heap {\\n\\tconstructor(compare, value) {\\n\\t\\tthis.heap = [];\\n        this.compare = compare;\\n        this.value = value;\\n\\t}\\n\\t\\n    leftChild(index) {\\n        return index * 2 + 1;\\n    }\\n\\n    rightChild(index) {\\n        return index * 2 + 2;\\n    }\\n\\n    parent(index) {\\n        return Math.floor((index\\u200A-\\u200A1) / 2);\\n    }\\n\\t\\n    insert(element) { //log n)\\n       this.heap.push(element);\\n\\t   \\n       // the index of the element we have just pushed\\n       let i = this.heap.length\\u200A-\\u200A1;\\n       element.index = i;\\n\\t   \\n       this.__bubbleUp(i);\\n    }\\n\\n    __bubbleUp(i) {\\n      // if the element is greater than its parent:\\n      // swap element with its parent\\n      //Bubble Up / Sift Up\\n      while(i > 0) {\\n        let p = this.parent(i);\\n\\n         if( this.compare(this.heap[p], this.heap[i]) ) {\\n                let temp = this.heap[i];\\n                this.heap[i] = this.heap[p];\\n                this.heap[p] = temp;\\n             \\n                this.heap[i].index = i;\\n                this.heap[p].index = p;\\n                i = p;\\n          } else {\\n               break;\\n          }\\n       }\\n     }\\n\\t \\n\\t extractMax() {\\n         if(this.heap.length === 1)\\n             return this.heap.pop();\\n\\n        let data = this.heap;\\n\\n        // stroing maximum value\\n        let root = data[0];\\n         \\n        // making root equal to the last element\\n        let end = data.pop();\\n\\n        data[0] = end;\\n        data[0].index = 0;\\n         \\n        let eIdx = data.length - 1;\\n\\n        // correctly re-position heap\\n        // as root is not following max-heap property\\n        this.__siftDown(0, eIdx);\\n\\n        return root;\\n\\t }\\n\\t \\n     __siftDown(start, end) {//O(log n)\\n         let left = this.leftChild(start);\\n         let right = this.rightChild(start);\\n\\n         let largest;\\n\\n         if(\\n             (left <= end) && \\n             this.heap[start] &&\\n             this.heap[left] &&\\n             ( this.compare(this.heap[start], this.heap[left]) )\\n           ) {\\n             largest = left\\n            } else  {\\n                 largest = start;\\n          }\\n\\n         if(\\n             (right <= end) && \\n             this.heap[largest] && \\n             this.heap[right] && \\n             ( this.compare(this.heap[largest], this.heap[right]) )\\n         ) {\\n             largest = right;\\n         }\\n\\n         if(largest !== start) {\\n             const tmp = this.heap[largest];\\n             this.heap[largest] = this.heap[start];\\n             this.heap[start] = tmp;\\n             \\n             this.heap[largest].index = largest;\\n             this.heap[start].index = start;\\n             \\n             this.__siftDown(largest, end);\\n         }\\n     }\\n    \\n    remove(pos) {\\n        this.heap[pos].price = this.value;\\n        this.__bubbleUp(pos);\\n        this.extractMax();\\n    }\\n\\t \\n     peek() {\\n         // the root is always the highest priority item\\n         return this.heap[0];\\n     }\\n\\t \\n}\\n ```\\n \\n **Second: TLE or Brute Force using Sorting**\\n \\n ```\\n /**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let left = [];\\n    let prefixMin = [];\\n    \\n    let right = [];\\n    let suffixMax = [];\\n    \\n    for(let i = 0; i < n; i++) {\\n        left.push(nums[i]);\\n    }\\n    \\n    let first = true;\\n    \\n    for(let i = n - 1; i < nums.length - n; i++) {\\n        let front = nums[i];\\n        \\n        if(!first)\\n            left.push(front);\\n        //Sort and select first n\\n        left.sort((a, b) => a - b);\\n        \\n        let sum = 0;\\n        for(let k = 0; k < n; k++) {\\n            sum += left[k];\\n        }\\n        \\n        prefixMin.push(sum);\\n        first = false;\\n    }\\n    \\n    for(let i = nums.length - 1; i >= nums.length - n; i--) {\\n        right.push(nums[i]);\\n    }\\n    \\n    first = true;\\n    \\n    for(let i = nums.length - n; i >= n; i--) {\\n        let back = nums[i];\\n        \\n        if(!first)\\n            right.push(back);\\n        //Sort and select  n from last\\n        right.sort((a, b) => a - b);\\n        \\n        let sum = 0;\\n        for(let k = right.length - 1; k >= right.length - n; k--) {\\n            sum += right[k];\\n        }\\n        \\n        suffixMax.push(sum);\\n        first = false;\\n    }\\n    \\n    suffixMax.reverse();\\n    \\n    let min = Infinity;\\n    let l = prefixMin.length;\\n    \\n    for(let i = 0; i < l; i++) {\\n        min = Math.min(prefixMin[i] - suffixMax[i], min);\\n    }\\n    \\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let prefixMin = [];\\n    let suffixMax = [];\\n    \\n    let min = Infinity;\\n    \\n    const maxHeap = new Heap((a,b) => {\\n        return a.val < b.val\\n    },  Infinity);\\n    \\n    const minHeap = new Heap((a,b) => {\\n        return a.val > b.val\\n    },  -Infinity);\\n    \\n    let sum = 0;\\n    for(let i = 0; i < n; i++) {\\n        let data = { val: nums[i] };\\n        maxHeap.insert(data);\\n        sum += nums[i];\\n    }\\n    prefixMin.push(sum);\\n    \\n    \\n    for(let i = n; i < nums.length - n; i++) {\\n        let top = maxHeap.peek();\\n        let data = { val: nums[i] };\\n        \\n        if(top.val > nums[i]) {\\n            let max = maxHeap.extractMax();\\n            let lastSum = prefixMin[prefixMin.length - 1];\\n            lastSum -= max.val;\\n            lastSum += nums[i];\\n            maxHeap.insert(data);\\n            prefixMin.push(lastSum);\\n        } else {\\n            let lastSum = prefixMin[prefixMin.length - 1];\\n            prefixMin.push(lastSum);\\n        }\\n    }\\n    \\n    sum = 0;\\n    for(let i = nums.length - 1; i >= nums.length - n; i--) {\\n        let data = { val: nums[i] };\\n        minHeap.insert(data);\\n        sum += nums[i];\\n    }\\n    suffixMax.push(sum);\\n    \\n    for(let i = nums.length - n - 1; i >= n; i--) {\\n        let top = minHeap.peek();\\n        let data = { val: nums[i] };\\n        \\n        if(top.val < nums[i]) {\\n            let max = minHeap.extractMax();\\n            let lastSum = suffixMax[suffixMax.length - 1];\\n            lastSum -= max.val;\\n            lastSum += nums[i];\\n            minHeap.insert(data);\\n            suffixMax.push(lastSum);\\n        } else {\\n            let lastSum = suffixMax[suffixMax.length - 1];\\n            suffixMax.push(lastSum);\\n        }\\n    }\\n    \\n    let l = prefixMin.length;\\n    suffixMax.reverse();\\n    \\n    for(let i = 0; i < l; i++) {\\n        min = Math.min(prefixMin[i] - suffixMax[i], min);\\n    }\\n    \\n    return min;\\n};\\n\\nclass Heap {\\n\\tconstructor(compare, value) {\\n\\t\\tthis.heap = [];\\n        this.compare = compare;\\n        this.value = value;\\n\\t}\\n\\t\\n    leftChild(index) {\\n        return index * 2 + 1;\\n    }\\n\\n    rightChild(index) {\\n        return index * 2 + 2;\\n    }\\n\\n    parent(index) {\\n        return Math.floor((index\\u200A-\\u200A1) / 2);\\n    }\\n\\t\\n    insert(element) { //log n)\\n       this.heap.push(element);\\n\\t   \\n       // the index of the element we have just pushed\\n       let i = this.heap.length\\u200A-\\u200A1;\\n       element.index = i;\\n\\t   \\n       this.__bubbleUp(i);\\n    }\\n\\n    __bubbleUp(i) {\\n      // if the element is greater than its parent:\\n      // swap element with its parent\\n      //Bubble Up / Sift Up\\n      while(i > 0) {\\n        let p = this.parent(i);\\n\\n         if( this.compare(this.heap[p], this.heap[i]) ) {\\n                let temp = this.heap[i];\\n                this.heap[i] = this.heap[p];\\n                this.heap[p] = temp;\\n             \\n                this.heap[i].index = i;\\n                this.heap[p].index = p;\\n                i = p;\\n          } else {\\n               break;\\n          }\\n       }\\n     }\\n\\t \\n\\t extractMax() {\\n         if(this.heap.length === 1)\\n             return this.heap.pop();\\n\\n        let data = this.heap;\\n\\n        // stroing maximum value\\n        let root = data[0];\\n         \\n        // making root equal to the last element\\n        let end = data.pop();\\n\\n        data[0] = end;\\n        data[0].index = 0;\\n         \\n        let eIdx = data.length - 1;\\n\\n        // correctly re-position heap\\n        // as root is not following max-heap property\\n        this.__siftDown(0, eIdx);\\n\\n        return root;\\n\\t }\\n\\t \\n     __siftDown(start, end) {//O(log n)\\n         let left = this.leftChild(start);\\n         let right = this.rightChild(start);\\n\\n         let largest;\\n\\n         if(\\n             (left <= end) && \\n             this.heap[start] &&\\n             this.heap[left] &&\\n             ( this.compare(this.heap[start], this.heap[left]) )\\n           ) {\\n             largest = left\\n            } else  {\\n                 largest = start;\\n          }\\n\\n         if(\\n             (right <= end) && \\n             this.heap[largest] && \\n             this.heap[right] && \\n             ( this.compare(this.heap[largest], this.heap[right]) )\\n         ) {\\n             largest = right;\\n         }\\n\\n         if(largest !== start) {\\n             const tmp = this.heap[largest];\\n             this.heap[largest] = this.heap[start];\\n             this.heap[start] = tmp;\\n             \\n             this.heap[largest].index = largest;\\n             this.heap[start].index = start;\\n             \\n             this.__siftDown(largest, end);\\n         }\\n     }\\n    \\n    remove(pos) {\\n        this.heap[pos].price = this.value;\\n        this.__bubbleUp(pos);\\n        this.extractMax();\\n    }\\n\\t \\n     peek() {\\n         // the root is always the highest priority item\\n         return this.heap[0];\\n     }\\n\\t \\n}\\n ```\n```\\n /**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minimumDifference = function(nums) {\\n    let n = nums.length / 3;\\n    \\n    let left = [];\\n    let prefixMin = [];\\n    \\n    let right = [];\\n    let suffixMax = [];\\n    \\n    for(let i = 0; i < n; i++) {\\n        left.push(nums[i]);\\n    }\\n    \\n    let first = true;\\n    \\n    for(let i = n - 1; i < nums.length - n; i++) {\\n        let front = nums[i];\\n        \\n        if(!first)\\n            left.push(front);\\n        //Sort and select first n\\n        left.sort((a, b) => a - b);\\n        \\n        let sum = 0;\\n        for(let k = 0; k < n; k++) {\\n            sum += left[k];\\n        }\\n        \\n        prefixMin.push(sum);\\n        first = false;\\n    }\\n    \\n    for(let i = nums.length - 1; i >= nums.length - n; i--) {\\n        right.push(nums[i]);\\n    }\\n    \\n    first = true;\\n    \\n    for(let i = nums.length - n; i >= n; i--) {\\n        let back = nums[i];\\n        \\n        if(!first)\\n            right.push(back);\\n        //Sort and select  n from last\\n        right.sort((a, b) => a - b);\\n        \\n        let sum = 0;\\n        for(let k = right.length - 1; k >= right.length - n; k--) {\\n            sum += right[k];\\n        }\\n        \\n        suffixMax.push(sum);\\n        first = false;\\n    }\\n    \\n    suffixMax.reverse();\\n    \\n    let min = Infinity;\\n    let l = prefixMin.length;\\n    \\n    for(let i = 0; i < l; i++) {\\n        min = Math.min(prefixMin[i] - suffixMax[i], min);\\n    }\\n    \\n    return min;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755896,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can reduce the asymptotic bounds for finding the `best` solution by preprocessing the input, ie. calculate the minimum prefix sums from left-to-right and the maximum suffix sums from right-to-left.  Perform a linear scan of the preprocessed input to consider each `i`<sup>th</sup> candidate `cand = L[i] - R[i + 1]`, ie. the minimum prefix sum to-the-left of index `i` inclusive subtracted by the maximum suffix sum to-the-right of index `i` non-inclusive.  Since `N=1e5` we need a near-linear runtime to avoid TLE; thus we use min/max priority queues to greedily \"cherry pick\" the min/max `K` values for these preprocessed inputs, where `K = N / 3` and `N` is the cardinality of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumDifference(A: IntArray): Long {\\n        var N = A.size\\n        var K = N / 3\\n        fun f(beg: Int, end: Int): LongArray {\\n            var B = LongArray(N) { 0L }\\n            var (t, q) = Pair(0L, PriorityQueue(Comparator{ a: Int, b: Int -> if (beg < end) b.compareTo(a) else a.compareTo(b) }))\\n            var i = beg\\n            while (if (beg < end) i <= end else end <= i) {\\n                t += A[i]; q.add(A[i])\\n                if (K < q.size)\\n                    t -= q.poll()\\n                B[i] = t\\n                i = if (beg < end) i + 1 else i - 1\\n            }\\n            return B\\n        }\\n        var L = f(0, N - 1)\\n        var R = f(N - 1, 0)\\n        var best = Long.MAX_VALUE\\n        for (i in K - 1..2 * K - 1) {\\n            var cand = L[i] - R[i + 1]\\n            best = Math.min(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minimumDifference = (A, best = Infinity) => {\\n    let N = A.length,\\n        K = N / 3;\\n    let f = (beg, end, cmp = beg < end ? Math.max : Math.min) => {\\n        let B = Array(N);\\n        let [t, q] = [0, []];\\n        for (let i = beg; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            t += A[i], heappush(q, A[i], cmp);\\n            if (K < q.length)\\n                t -= heappop(q, cmp);\\n            B[i] = t;\\n        }\\n        return B;\\n    };\\n    let L = f(0, N - 1),\\n        R = f(N - 1, 0);\\n    for (let i = K - 1; i < 2 * K; ++i) {\\n        let cand = L[i] - R[i + 1];\\n        best = Math.min(best, cand);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumDifference(self, A: List[int], best = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        K = N // 3\\n        def f(beg, end):\\n            B = [0] * N\\n            t, q = 0, []\\n            for i in range(beg, end, 1 if beg < end else -1):\\n                take = -A[i] if beg < end else A[i]\\n                t += take; heappush(q, take)\\n                B[i] = t = t if len(q) <= K else t - heappop(q)\\n            return [-x if beg < end else x for x in B]\\n        L = f(0, N - 1)\\n        R = f(N - 1, 0)\\n        for i in range(K - 1, 2 * K):\\n            cand = L[i] - R[i + 1]\\n            best = min(best, cand)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using MinQ = priority_queue<LL, VL, ::greater<LL>>;\\n    using MaxQ = priority_queue<LL, VL, ::less<LL>>;\\n    LL minimumDifference(VI& A, LL best = numeric_limits<LL>::max()) {\\n        int N = A.size(),\\n            K = N / 3;\\n        auto L = f(MaxQ{}, A, 0, N - 1),\\n             R = f(MinQ{}, A, N - 1, 0);\\n        for (auto i{ K - 1 }; i < 2 * K; ++i) {\\n            LL cand = L[i] - R[i + 1];\\n            best = min(best, cand);\\n        }\\n        return best;\\n    }\\n    template<typename Queue>\\n    VL f(Queue&& q, VI& A, int beg, int end, LL t = 0) {\\n        int N = A.size(),\\n            K = N / 3;\\n        VL B(N);\\n        for (auto i{ beg }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            t += A[i], q.push(A[i]);\\n            if (K < q.size())\\n                t -= q.top(), q.pop();\\n            B[i] = t;\\n        }\\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumDifference(A: IntArray): Long {\\n        var N = A.size\\n        var K = N / 3\\n        fun f(beg: Int, end: Int): LongArray {\\n            var B = LongArray(N) { 0L }\\n            var (t, q) = Pair(0L, PriorityQueue(Comparator{ a: Int, b: Int -> if (beg < end) b.compareTo(a) else a.compareTo(b) }))\\n            var i = beg\\n            while (if (beg < end) i <= end else end <= i) {\\n                t += A[i]; q.add(A[i])\\n                if (K < q.size)\\n                    t -= q.poll()\\n                B[i] = t\\n                i = if (beg < end) i + 1 else i - 1\\n            }\\n            return B\\n        }\\n        var L = f(0, N - 1)\\n        var R = f(N - 1, 0)\\n        var best = Long.MAX_VALUE\\n        for (i in K - 1..2 * K - 1) {\\n            var cand = L[i] - R[i + 1]\\n            best = Math.min(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minimumDifference = (A, best = Infinity) => {\\n    let N = A.length,\\n        K = N / 3;\\n    let f = (beg, end, cmp = beg < end ? Math.max : Math.min) => {\\n        let B = Array(N);\\n        let [t, q] = [0, []];\\n        for (let i = beg; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            t += A[i], heappush(q, A[i], cmp);\\n            if (K < q.length)\\n                t -= heappop(q, cmp);\\n            B[i] = t;\\n        }\\n        return B;\\n    };\\n    let L = f(0, N - 1),\\n        R = f(N - 1, 0);\\n    for (let i = K - 1; i < 2 * K; ++i) {\\n        let cand = L[i] - R[i + 1];\\n        best = Math.min(best, cand);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minimumDifference(self, A: List[int], best = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        K = N // 3\\n        def f(beg, end):\\n            B = [0] * N\\n            t, q = 0, []\\n            for i in range(beg, end, 1 if beg < end else -1):\\n                take = -A[i] if beg < end else A[i]\\n                t += take; heappush(q, take)\\n                B[i] = t = t if len(q) <= K else t - heappop(q)\\n            return [-x if beg < end else x for x in B]\\n        L = f(0, N - 1)\\n        R = f(N - 1, 0)\\n        for i in range(K - 1, 2 * K):\\n            cand = L[i] - R[i + 1]\\n            best = min(best, cand)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using MinQ = priority_queue<LL, VL, ::greater<LL>>;\\n    using MaxQ = priority_queue<LL, VL, ::less<LL>>;\\n    LL minimumDifference(VI& A, LL best = numeric_limits<LL>::max()) {\\n        int N = A.size(),\\n            K = N / 3;\\n        auto L = f(MaxQ{}, A, 0, N - 1),\\n             R = f(MinQ{}, A, N - 1, 0);\\n        for (auto i{ K - 1 }; i < 2 * K; ++i) {\\n            LL cand = L[i] - R[i + 1];\\n            best = min(best, cand);\\n        }\\n        return best;\\n    }\\n    template<typename Queue>\\n    VL f(Queue&& q, VI& A, int beg, int end, LL t = 0) {\\n        int N = A.size(),\\n            K = N / 3;\\n        VL B(N);\\n        for (auto i{ beg }; beg < end ? i <= end : end <= i; beg < end ? ++i : --i) {\\n            t += A[i], q.push(A[i]);\\n            if (K < q.size())\\n                t -= q.top(), q.pop();\\n            B[i] = t;\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755854,
                "title": "2163-minimum-difference-in-sums-after-removal-of-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        vector<int>v1;\\n        vector<int>v2;\\n        long long s1 = 0,s2 = 0;\\n        //finding s1 from i = n-1 to N-n-1;s1 should be minimum\\n        priority_queue<int>pq;\\n        for(int i = 0;i<N-n;++i){\\n            s1+=nums[i];\\n            pq.push(nums[i]);\\n            if(i==n-1){\\n                v1.push_back(s1);\\n            }\\n            else if(i>n-1){\\n                s1-=pq.top();\\n                pq.pop();\\n                v1.push_back(s1);\\n            }\\n        }\\n        \\n        //finding s2 from i = N-n to i = n and reverse vector\\n        //s2 should be max\\n        priority_queue<int,vector<int>,greater<int>>qp;\\n        for(int i = N-1;i>=n;--i){\\n            s2+=nums[i];\\n            qp.push(nums[i]);\\n            if(i==N-n){\\n                v2.push_back(s2);\\n            }\\n            else if(i<N-n){\\n                s2-=qp.top();\\n                qp.pop();\\n                v2.push_back(s2);\\n            }\\n        }\\n        reverse(v2.begin(),v2.end());\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0 ; i < v1.size();++i){\\n            ans = min(ans,(v1[i]-v2[i]));\\n        }\\n        long long k = ans;\\n        return k;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int N = nums.size();\\n        int n = N/3;\\n        vector<int>v1;\\n        vector<int>v2;\\n        long long s1 = 0,s2 = 0;\\n        //finding s1 from i = n-1 to N-n-1;s1 should be minimum\\n        priority_queue<int>pq;\\n        for(int i = 0;i<N-n;++i){\\n            s1+=nums[i];\\n            pq.push(nums[i]);\\n            if(i==n-1){\\n                v1.push_back(s1);\\n            }\\n            else if(i>n-1){\\n                s1-=pq.top();\\n                pq.pop();\\n                v1.push_back(s1);\\n            }\\n        }\\n        \\n        //finding s2 from i = N-n to i = n and reverse vector\\n        //s2 should be max\\n        priority_queue<int,vector<int>,greater<int>>qp;\\n        for(int i = N-1;i>=n;--i){\\n            s2+=nums[i];\\n            qp.push(nums[i]);\\n            if(i==N-n){\\n                v2.push_back(s2);\\n            }\\n            else if(i<N-n){\\n                s2-=qp.top();\\n                qp.pop();\\n                v2.push_back(s2);\\n            }\\n        }\\n        reverse(v2.begin(),v2.end());\\n        \\n        int ans = INT_MAX;\\n        for(int i = 0 ; i < v1.size();++i){\\n            ans = min(ans,(v1[i]-v2[i]));\\n        }\\n        long long k = ans;\\n        return k;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755234,
                "title": "runtime-597-ms-faster-than-56-98-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        long long n=nums.size()/3,left=0,right=0,ans=LLONG_MAX;\\n        vector<long> temp(nums.size());\\n        for(int i=nums.size()-1;i>=n;i--)\\n        {\\n            R.push(nums[i]);\\n            right += nums[i];\\n            if(R.size()>n)\\n            {\\n                right-= R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n)\\n            {\\n                temp[i]=right;\\n            }\\n        }\\n        for(int i=0;i<nums.size()-n;i++)\\n        {\\n            L.push(nums[i]);\\n            left += nums[i];\\n            if(L.size()>n)\\n            {\\n                left -= L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n)\\n            {\\n                ans = min(ans,left-temp[i+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        priority_queue<int> L;\\n        priority_queue<int,vector<int>,greater<int>> R;\\n        long long n=nums.size()/3,left=0,right=0,ans=LLONG_MAX;\\n        vector<long> temp(nums.size());\\n        for(int i=nums.size()-1;i>=n;i--)\\n        {\\n            R.push(nums[i]);\\n            right += nums[i];\\n            if(R.size()>n)\\n            {\\n                right-= R.top();\\n                R.pop();\\n            }\\n            if(R.size()==n)\\n            {\\n                temp[i]=right;\\n            }\\n        }\\n        for(int i=0;i<nums.size()-n;i++)\\n        {\\n            L.push(nums[i]);\\n            left += nums[i];\\n            if(L.size()>n)\\n            {\\n                left -= L.top();\\n                L.pop();\\n            }\\n            if(L.size()==n)\\n            {\\n                ans = min(ans,left-temp[i+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755150,
                "title": "c-240ms-99-81-maxheap-minheap",
                "content": "Runtime: 240 ms, faster than 99.81% of C++ online submissions for Minimum Difference in Sums After Removal of Elements.\\nMemory Usage: 127.3 MB, less than 96.12% of C++ online submissions for Minimum Difference in Sums After Removal of Elements.\\n```\\nclass Solution {\\npublic:\\n  long long minimumDifference(vector<int>& nums) {\\n    int n  = nums.size()/3;\\n    int n2 = n<<1;\\n    vector<long>lmin(n);\\n    \\n    \\n    priority_queue<int, vector<int>> left(nums.begin(), nums.begin()+n);\\n    long lsum = accumulate(nums.begin(), nums.begin() + n, 0L);\\n      \\n    for(int i = n, j = 0; i != n2; i++, j++){\\n      lmin[j] = lsum;\\n      if(left.top() > nums[i]){\\n        lsum += nums[i] - left.top();\\n        left.pop();\\n        left.push(nums[i]);\\n      }\\n    }\\n    \\n    \\n    priority_queue<int, vector<int>, greater<int>> right(nums.begin() + n2, nums.end());\\n    long rsum = accumulate(nums.begin() + n2, nums.end(), 0L);\\n    \\n    long dif = lsum - rsum; \\n    for(int i = n2 - 1, j = n-1; i >= n; i--, j--){\\n      if(right.top() < nums[i]){\\n        rsum += nums[i] - right.top();\\n        right.pop();\\n        right.push(nums[i]);\\n      }\\n      dif = min<long>(dif, lmin[j] - rsum);\\n    }\\n    \\n    return dif;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minimumDifference(vector<int>& nums) {\\n    int n  = nums.size()/3;\\n    int n2 = n<<1;\\n    vector<long>lmin(n);\\n    \\n    \\n    priority_queue<int, vector<int>> left(nums.begin(), nums.begin()+n);\\n    long lsum = accumulate(nums.begin(), nums.begin() + n, 0L);\\n      \\n    for(int i = n, j = 0; i != n2; i++, j++){\\n      lmin[j] = lsum;\\n      if(left.top() > nums[i]){\\n        lsum += nums[i] - left.top();\\n        left.pop();\\n        left.push(nums[i]);\\n      }\\n    }\\n    \\n    \\n    priority_queue<int, vector<int>, greater<int>> right(nums.begin() + n2, nums.end());\\n    long rsum = accumulate(nums.begin() + n2, nums.end(), 0L);\\n    \\n    long dif = lsum - rsum; \\n    for(int i = n2 - 1, j = n-1; i >= n; i--, j--){\\n      if(right.top() < nums[i]){\\n        rsum += nums[i] - right.top();\\n        right.pop();\\n        right.push(nums[i]);\\n      }\\n      dif = min<long>(dif, lmin[j] - rsum);\\n    }\\n    \\n    return dif;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753071,
                "title": "c-solution-explained-priority-queue-and-prefix-suffix-array",
                "content": "**Intution** : The lowest possible difference can be obtained when the sum of the first n elements in the resultant array is minimum, and the sum of the next n elements is maximum.\\n\\nWe will try to seperate the entire array in 3 segments as follows:\\n**I** : [0 , n/3) \\n**II** : [n/3 , (2*n)/3) \\n**III**: [(2*n)/3) , n)\\n\\nNow we can deduce that after all the optimal  deletion from the array , segment **I** can have elements only from segments **I** and **II** , and similarly segment **III** can have elements only from segments **II** and **III**.\\n\\nNow we can evaluate the seperation created by values of segment **II** when adopted by **I** , (adoption means , evicting one element of segment **I** and chosing one value of segment **II**)\\nusing prefix array .\\n\\nSimilary we will evaluate the seperation created by values of segment **II** when adopted by **III** ,\\nusing suffix array.\\n\\nUpon formulating both prefix array  and suffix array we can find the partition where max seperation(lowest difference) would have been created.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long diff = 0;\\n        \\n        priority_queue<int> pq1;  // priority queue for storing elements [0,n/3)\\n        priority_queue<int, vector<int>, greater<int> > pq2; // priority queue for storing elements [(2*n)/3,n)\\n        \\n        \\n        for(int i = 0 ; i<n/3 ; i++)\\n        {\\n            pq1.push(nums[i]);\\n            diff+=nums[i];\\n            \\n            pq2.push(nums[i+(2*n)/3]);\\n            diff-=nums[i+(2*n)/3];\\n        }\\n        \\n        vector<long long>pre(n/3) , suff(n/3);\\n        \\n        for(int i = 0 ; i<n/3 ; i++)\\n        {\\n                int x = pq1.top();\\n                pq1.pop();\\n            \\n\\n                if(i > 0) pre[i] = pre[i-1] + x-nums[i+n/3];\\n                else pre[i] = x-nums[i+n/3];\\n\\t\\t\\t\\t\\n                pq1.push(nums[i+n/3]);\\n            \\n        }\\n        for(int i = n/3-1 ; i>=0 ; i--)\\n        {\\n                int x = pq2.top();\\n                pq2.pop();\\n            \\n                if(i < n/3-1) suff[i] = suff[i+1] + nums[n/3 + i]-x;\\n                else suff[i] = nums[n/3 + i]-x;\\n\\t\\t\\t\\t\\n                pq2.push(nums[i+n/3]);\\n            \\n        }\\n        \\n        long long ans = 0 ; ans = max(pre[n/3-1] , suff[0]);\\n        \\n        for(int i = 0 ; i<n/3-1 ; i++) ans = max(ans , pre[i] + suff[i+1]);\\n        \\n        return diff - ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long diff = 0;\\n        \\n        priority_queue<int> pq1;  // priority queue for storing elements [0,n/3)\\n        priority_queue<int, vector<int>, greater<int> > pq2; // priority queue for storing elements [(2*n)/3,n)\\n        \\n        \\n        for(int i = 0 ; i<n/3 ; i++)\\n        {\\n            pq1.push(nums[i]);\\n            diff+=nums[i];\\n            \\n            pq2.push(nums[i+(2*n)/3]);\\n            diff-=nums[i+(2*n)/3];\\n        }\\n        \\n        vector<long long>pre(n/3) , suff(n/3);\\n        \\n        for(int i = 0 ; i<n/3 ; i++)\\n        {\\n                int x = pq1.top();\\n                pq1.pop();\\n            \\n\\n                if(i > 0) pre[i] = pre[i-1] + x-nums[i+n/3];\\n                else pre[i] = x-nums[i+n/3];\\n\\t\\t\\t\\t\\n                pq1.push(nums[i+n/3]);\\n            \\n        }\\n        for(int i = n/3-1 ; i>=0 ; i--)\\n        {\\n                int x = pq2.top();\\n                pq2.pop();\\n            \\n                if(i < n/3-1) suff[i] = suff[i+1] + nums[n/3 + i]-x;\\n                else suff[i] = nums[n/3 + i]-x;\\n\\t\\t\\t\\t\\n                pq2.push(nums[i+n/3]);\\n            \\n        }\\n        \\n        long long ans = 0 ; ans = max(pre[n/3-1] , suff[0]);\\n        \\n        for(int i = 0 ; i<n/3-1 ; i++) ans = max(ans , pre[i] + suff[i+1]);\\n        \\n        return diff - ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752707,
                "title": "c-simple-explaination-priority-queue-clean-code-o-nlogn",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/Stacks%20%26%20Queues/Minimum%20Difference%20in%20Sums%20After%20Removal%20of%20Elements.cpp\\n```\\n// Manish Kumar, IIIT Allahabad\\n// Hard-Medium, priority_queue\\n// TC: O(NlogN), SC: O(N)\\n\\n// first<> stores curr min sum of n elements at ith index from left\\n// second<> stores curr max sum of n elements at ith index from right\\n// Then final answer is just min(first[i] - second[i+1]) for all possible indexes\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumDifference(vector<int>& nums) {\\n        int sz = nums.size();\\n        int n = sz/3;\\n        vector<ll> first(sz, 0), second(sz, 0);\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        first[0] = (ll)nums[0];\\n        pq1.push(nums[0]);\\n        for(int i = 1; i < 2*n; i++){\\n            if(i < n){\\n                first[i] = (ll)nums[i] + first[i-1];\\n                pq1.push(nums[i]);\\n            }\\n            else{\\n                pq1.push(nums[i]);\\n                first[i] = first[i-1] + (ll)nums[i] - (ll)pq1.top();\\n                pq1.pop();\\n            }\\n        }\\n        \\n        second[sz-1] = (ll)nums[sz-1];\\n        pq2.push(nums[sz-1]);\\n        for(int i = sz-2; i >= 0; i--){\\n            if(i >= 2*n){\\n                second[i] = (ll)nums[i] + second[i+1];\\n                pq2.push(nums[i]);\\n            }\\n            else{\\n                pq2.push(nums[i]);\\n                second[i] = second[i+1] + (ll)nums[i] - (ll)pq2.top();\\n                pq2.pop();\\n            }\\n        }\\n        \\n        ll ans = LLONG_MAX;\\n        for(int i = n-1; i < 2*n; i++)\\n            ans = min(ans, first[i] - second[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Manish Kumar, IIIT Allahabad\\n// Hard-Medium, priority_queue\\n// TC: O(NlogN), SC: O(N)\\n\\n// first<> stores curr min sum of n elements at ith index from left\\n// second<> stores curr max sum of n elements at ith index from right\\n// Then final answer is just min(first[i] - second[i+1]) for all possible indexes\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumDifference(vector<int>& nums) {\\n        int sz = nums.size();\\n        int n = sz/3;\\n        vector<ll> first(sz, 0), second(sz, 0);\\n        \\n        priority_queue<int> pq1;\\n        priority_queue<int, vector<int>, greater<int>> pq2;\\n        \\n        first[0] = (ll)nums[0];\\n        pq1.push(nums[0]);\\n        for(int i = 1; i < 2*n; i++){\\n            if(i < n){\\n                first[i] = (ll)nums[i] + first[i-1];\\n                pq1.push(nums[i]);\\n            }\\n            else{\\n                pq1.push(nums[i]);\\n                first[i] = first[i-1] + (ll)nums[i] - (ll)pq1.top();\\n                pq1.pop();\\n            }\\n        }\\n        \\n        second[sz-1] = (ll)nums[sz-1];\\n        pq2.push(nums[sz-1]);\\n        for(int i = sz-2; i >= 0; i--){\\n            if(i >= 2*n){\\n                second[i] = (ll)nums[i] + second[i+1];\\n                pq2.push(nums[i]);\\n            }\\n            else{\\n                pq2.push(nums[i]);\\n                second[i] = second[i+1] + (ll)nums[i] - (ll)pq2.top();\\n                pq2.pop();\\n            }\\n        }\\n        \\n        ll ans = LLONG_MAX;\\n        for(int i = n-1; i < 2*n; i++)\\n            ans = min(ans, first[i] - second[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752360,
                "title": "java-solution-priorityqueue-short-answer-100",
                "content": "```\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n\\n        PriorityQueue<Integer> pql = new PriorityQueue<>(Comparator.reverseOrder()); // max n elements from left\\n        PriorityQueue<Integer> pqr = new PriorityQueue<>(); // min n elements from right\\n        long[] suml = new long[nums.length]; // sum of pql\\n        long[] sumr = new long[nums.length]; // sum of pqr\\n\\n        for (int i = 0; i < n; i++) {\\n            suml[n - 1] += nums[i];\\n            pql.offer(nums[i]);\\n        }\\n\\n        for (int i = n; i < nums.length; i++) {\\n            pql.offer(nums[i]);\\n            suml[i] = suml[i - 1] + nums[i] - pql.poll();\\n        }\\n\\n        for (int i = nums.length - 1; i > nums.length - 1 - n; i--) {\\n            sumr[nums.length - n] += nums[i];\\n            pqr.offer(nums[i]);\\n        }\\n\\n        for (int i = nums.length - 1 - n; i >= 0; i--) {\\n            pqr.offer(nums[i]);\\n            sumr[i] = sumr[i + 1] + nums[i] - pqr.poll();\\n        }\\n\\n        long rst = Long.MAX_VALUE;\\n        for (int i = n - 1; i < nums.length - n; i++)\\n            rst = Math.min(rst, suml[i] - sumr[i + 1]);\\n        return rst;\\n\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n\\n        PriorityQueue<Integer> pql = new PriorityQueue<>(Comparator.reverseOrder()); // max n elements from left\\n        PriorityQueue<Integer> pqr = new PriorityQueue<>(); // min n elements from right\\n        long[] suml = new long[nums.length]; // sum of pql\\n        long[] sumr = new long[nums.length]; // sum of pqr\\n\\n        for (int i = 0; i < n; i++) {\\n            suml[n - 1] += nums[i];\\n            pql.offer(nums[i]);\\n        }\\n\\n        for (int i = n; i < nums.length; i++) {\\n            pql.offer(nums[i]);\\n            suml[i] = suml[i - 1] + nums[i] - pql.poll();\\n        }\\n\\n        for (int i = nums.length - 1; i > nums.length - 1 - n; i--) {\\n            sumr[nums.length - n] += nums[i];\\n            pqr.offer(nums[i]);\\n        }\\n\\n        for (int i = nums.length - 1 - n; i >= 0; i--) {\\n            pqr.offer(nums[i]);\\n            sumr[i] = sumr[i + 1] + nums[i] - pqr.poll();\\n        }\\n\\n        long rst = Long.MAX_VALUE;\\n        for (int i = n - 1; i < nums.length - n; i++)\\n            rst = Math.min(rst, suml[i] - sumr[i + 1]);\\n        return rst;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1751469,
                "title": "c-maxheap-minheap-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        vector<long long> left(n+1), right(n+1);\\n        priority_queue<int> minHeap, maxHeap;\\n        long long leftSum = 0;\\n        for(int i=0; i<n; i++){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n        }\\n        left[0] = leftSum;\\n        for(int i=n; i<2*n; i++){\\n            if(nums[i] < maxHeap.top()){\\n                leftSum = leftSum - maxHeap.top() + nums[i];\\n                maxHeap.pop();\\n                maxHeap.push(nums[i]);\\n            }\\n            left[i-n+1] = leftSum;\\n        }\\n        long long rightSum = 0;\\n        for(int i=2*n; i<3*n; i++){\\n            rightSum += nums[i];\\n            minHeap.push(-nums[i]);\\n        }\\n        right[n] = rightSum;\\n        for(int i=2*n-1; i>=n; i--){\\n            if(nums[i] > -minHeap.top()){\\n                rightSum = rightSum + minHeap.top() + nums[i];\\n                minHeap.pop();\\n                minHeap.push(-nums[i]);\\n            }\\n            right[i-n] = rightSum;\\n        }\\n        long long ans = left[0] - right[0];\\n        for(int i=1; i<=n; i++)\\n            ans = min(ans, left[i] - right[i]);\\n        return ans;\\n    }\\n};\\n```\\n<b>IF YOU FIND IT HELPFUL, PLEASE UPVOTE</b>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        vector<long long> left(n+1), right(n+1);\\n        priority_queue<int> minHeap, maxHeap;\\n        long long leftSum = 0;\\n        for(int i=0; i<n; i++){\\n            leftSum += nums[i];\\n            maxHeap.push(nums[i]);\\n        }\\n        left[0] = leftSum;\\n        for(int i=n; i<2*n; i++){\\n            if(nums[i] < maxHeap.top()){\\n                leftSum = leftSum - maxHeap.top() + nums[i];\\n                maxHeap.pop();\\n                maxHeap.push(nums[i]);\\n            }\\n            left[i-n+1] = leftSum;\\n        }\\n        long long rightSum = 0;\\n        for(int i=2*n; i<3*n; i++){\\n            rightSum += nums[i];\\n            minHeap.push(-nums[i]);\\n        }\\n        right[n] = rightSum;\\n        for(int i=2*n-1; i>=n; i--){\\n            if(nums[i] > -minHeap.top()){\\n                rightSum = rightSum + minHeap.top() + nums[i];\\n                minHeap.pop();\\n                minHeap.push(-nums[i]);\\n            }\\n            right[i-n] = rightSum;\\n        }\\n        long long ans = left[0] - right[0];\\n        for(int i=1; i<=n; i++)\\n            ans = min(ans, left[i] - right[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751370,
                "title": "javascript-100-both-memory-and-time-complexity",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nclass Heap {\\n\\tconstructor(){\\n\\t\\tthis.arr = [];\\n\\t};\\n\\t\\n\\tadd(number){\\n\\t\\tthis.arr.push(number);\\n\\t\\tthis.siftUp();\\n\\t}\\n\\t\\n\\tsiftUp(){\\n\\t\\tlet currentIdx = this.arr.length-1;\\n\\t\\tlet parentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t\\n\\t\\twhile(this.arr[parentIdx] > this.arr[currentIdx]){\\n\\t\\t\\tthis.swap(parentIdx, currentIdx, this.arr);\\n\\t\\t\\tcurrentIdx = parentIdx;\\n\\t\\t\\tparentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t}\\n\\t}\\n\\tsum(){\\n        return this.arr.reduce(function (a, b) { return a + b; }, 0)\\n    }\\n\\tswap(first,second, arr){\\n\\t\\tlet temp = this.arr[first];\\n\\t\\tthis.arr[first] = this.arr[second];\\n\\t\\tthis.arr[second] = temp;\\n\\t}\\n\\t\\n\\tgetParent(){\\n\\t\\treturn this.arr[0];\\n\\t}\\n\\t\\n\\textract(){\\n\\t\\tlet valuePopped = this.arr[0];\\n\\t\\tthis.siftDown();\\n\\t\\treturn valuePopped;\\n\\t}\\n\\t\\n\\tgetSize(){\\n\\t\\treturn this.arr.length;\\n\\t}\\n\\t\\n\\tsiftDown(){\\n\\t\\tthis.swap(0, this.arr.length-1);\\n\\t\\tthis.arr.pop();\\n\\t\\t\\n\\t\\tlet currentIdx = 0;\\n\\t\\tlet firstChild = currentIdx * 2 + 1;\\n\\t\\tlet secondChild = currentIdx * 2 + 2;\\n\\t\\t\\n\\t\\twhile(this.arr.length > firstChild){\\n\\t\\t\\tlet curIdx\\n\\t\\t\\tif(secondChild < this.arr.length){\\n\\t\\t\\t\\t//then compare the two\\n\\t\\t\\t\\tif(this.arr[firstChild] > this.arr[secondChild]){\\n\\t\\t\\t\\t\\tcurIdx = secondChild;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// the last floor\\n\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(this.arr[curIdx] < this.arr[currentIdx]){\\n\\t\\t\\t\\tthis.swap(currentIdx, curIdx, this.arr);\\n\\t\\t\\t\\tcurrentIdx = curIdx;\\n\\t\\t\\t\\tfirstChild = currentIdx *2 + 1;\\n\\t\\t\\t\\tsecondChild = currentIdx * 2 + 2;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nclass maxHeap {\\n\\tconstructor(){\\n\\t\\tthis.arr = [];\\n\\t\\tconsole.log(\\'maxheap created!\\');\\n\\t};\\n    \\n    current(){\\n        return this.arr\\n    }\\n\\tsum(){\\n        return this.arr.reduce(function (a, b) { return a + b; }, 0)\\n    }\\n\\tadd(number){\\n\\t\\tthis.arr.push(number);\\n\\t\\tthis.siftUp();\\n\\t}\\n\\t\\n\\tgetSize(){\\n\\t\\treturn this.arr.length;\\n\\t}\\n\\t\\n\\tsiftUp(){\\n\\t\\tlet currentIdx = this.arr.length-1;\\n\\t\\tlet parentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t\\n\\t\\twhile(this.arr[parentIdx] < this.arr[currentIdx]){\\n\\t\\t\\tthis.swap(parentIdx, currentIdx, this.arr);\\n\\t\\t\\tcurrentIdx = parentIdx;\\n\\t\\t\\tparentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tswap(first,second, arr){\\n\\t\\tlet temp = this.arr[first];\\n\\t\\tthis.arr[first] = this.arr[second];\\n\\t\\tthis.arr[second] = temp;\\n\\t}\\n\\t\\n\\tgetParent(){\\n\\t\\treturn this.arr[0];\\n\\t}\\n\\t\\n\\textract(){\\n\\t\\tlet valuePopped = this.arr[0];\\n\\t\\tthis.siftDown();\\n\\t\\treturn valuePopped;\\n\\t}\\n\\t\\n\\tsiftDown(){\\n\\t\\tthis.swap(0, this.arr.length-1);\\n\\t\\tthis.arr.pop();\\n\\t\\t\\n\\t\\tlet currentIdx = 0;\\n\\t\\tlet firstChild = currentIdx * 2 + 1;\\n\\t\\tlet secondChild = currentIdx * 2 + 2;\\n        \\n       \\n\\t\\t\\n\\t\\twhile(this.arr.length > firstChild){\\n\\t\\t\\tlet curIdx\\n\\t\\t\\tif(secondChild < this.arr.length){\\n\\t\\t\\t\\t//then compare the two\\n\\t\\t\\t\\tif(this.arr[firstChild] < this.arr[secondChild]){\\n\\t\\t\\t\\t\\tcurIdx = secondChild;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// the last floor\\n\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(this.arr[curIdx] > this.arr[currentIdx]){\\n\\t\\t\\t\\tthis.swap(currentIdx, curIdx, this.arr);\\n\\t\\t\\t\\tcurrentIdx = curIdx;\\n\\t\\t\\t\\tfirstChild = currentIdx *2 + 1;\\n\\t\\t\\t\\tsecondChild = currentIdx * 2 + 2;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nvar minimumDifference = function(nums) {\\n    // console.log(heap.extract())\\n    let limit = parseInt(nums.length/3)\\n    \\n    let first = new maxHeap();\\n    let second = new Heap();\\n    \\n    \\n    for(let i = 0; i < limit; i++){\\n        first.add(nums[i]);\\n        second.add(nums[nums.length-i-1])\\n    }\\n    let solution = first.sum() - second.sum();\\n    \\n    let curArr = [];\\n    let curArrSecond = [];\\n    \\n    let firstSum = first.sum();\\n    let secondSum = second.sum()\\n    curArr.push(firstSum)\\n    curArrSecond.unshift(secondSum)\\n    \\n    for(let i = 0; i < limit; i++){\\n        let curIdx = i + limit;\\n        \\n        \\n        first.add(nums[curIdx]);\\n        let firstMinus = first.extract();\\n        firstSum += nums[curIdx] - firstMinus\\n        curArr.push(firstSum);\\n        \\n        second.add(nums[nums.length-curIdx-1]);\\n        let secondMinus = second.extract();\\n        secondSum += nums[nums.length-curIdx-1] - secondMinus\\n        curArrSecond.unshift(secondSum);\\n    }\\n    \\n    \\n    for(let i = 0; i < curArr.length; i++){\\n        solution = Math.min(solution, curArr[i] - curArrSecond[i])\\n    }\\n    \\n    \\n    return solution\\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nclass Heap {\\n\\tconstructor(){\\n\\t\\tthis.arr = [];\\n\\t};\\n\\t\\n\\tadd(number){\\n\\t\\tthis.arr.push(number);\\n\\t\\tthis.siftUp();\\n\\t}\\n\\t\\n\\tsiftUp(){\\n\\t\\tlet currentIdx = this.arr.length-1;\\n\\t\\tlet parentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t\\n\\t\\twhile(this.arr[parentIdx] > this.arr[currentIdx]){\\n\\t\\t\\tthis.swap(parentIdx, currentIdx, this.arr);\\n\\t\\t\\tcurrentIdx = parentIdx;\\n\\t\\t\\tparentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t}\\n\\t}\\n\\tsum(){\\n        return this.arr.reduce(function (a, b) { return a + b; }, 0)\\n    }\\n\\tswap(first,second, arr){\\n\\t\\tlet temp = this.arr[first];\\n\\t\\tthis.arr[first] = this.arr[second];\\n\\t\\tthis.arr[second] = temp;\\n\\t}\\n\\t\\n\\tgetParent(){\\n\\t\\treturn this.arr[0];\\n\\t}\\n\\t\\n\\textract(){\\n\\t\\tlet valuePopped = this.arr[0];\\n\\t\\tthis.siftDown();\\n\\t\\treturn valuePopped;\\n\\t}\\n\\t\\n\\tgetSize(){\\n\\t\\treturn this.arr.length;\\n\\t}\\n\\t\\n\\tsiftDown(){\\n\\t\\tthis.swap(0, this.arr.length-1);\\n\\t\\tthis.arr.pop();\\n\\t\\t\\n\\t\\tlet currentIdx = 0;\\n\\t\\tlet firstChild = currentIdx * 2 + 1;\\n\\t\\tlet secondChild = currentIdx * 2 + 2;\\n\\t\\t\\n\\t\\twhile(this.arr.length > firstChild){\\n\\t\\t\\tlet curIdx\\n\\t\\t\\tif(secondChild < this.arr.length){\\n\\t\\t\\t\\t//then compare the two\\n\\t\\t\\t\\tif(this.arr[firstChild] > this.arr[secondChild]){\\n\\t\\t\\t\\t\\tcurIdx = secondChild;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// the last floor\\n\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(this.arr[curIdx] < this.arr[currentIdx]){\\n\\t\\t\\t\\tthis.swap(currentIdx, curIdx, this.arr);\\n\\t\\t\\t\\tcurrentIdx = curIdx;\\n\\t\\t\\t\\tfirstChild = currentIdx *2 + 1;\\n\\t\\t\\t\\tsecondChild = currentIdx * 2 + 2;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nclass maxHeap {\\n\\tconstructor(){\\n\\t\\tthis.arr = [];\\n\\t\\tconsole.log(\\'maxheap created!\\');\\n\\t};\\n    \\n    current(){\\n        return this.arr\\n    }\\n\\tsum(){\\n        return this.arr.reduce(function (a, b) { return a + b; }, 0)\\n    }\\n\\tadd(number){\\n\\t\\tthis.arr.push(number);\\n\\t\\tthis.siftUp();\\n\\t}\\n\\t\\n\\tgetSize(){\\n\\t\\treturn this.arr.length;\\n\\t}\\n\\t\\n\\tsiftUp(){\\n\\t\\tlet currentIdx = this.arr.length-1;\\n\\t\\tlet parentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t\\n\\t\\twhile(this.arr[parentIdx] < this.arr[currentIdx]){\\n\\t\\t\\tthis.swap(parentIdx, currentIdx, this.arr);\\n\\t\\t\\tcurrentIdx = parentIdx;\\n\\t\\t\\tparentIdx = currentIdx % 2 ===0 ? (currentIdx-2)/2 : (currentIdx-1)/2;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tswap(first,second, arr){\\n\\t\\tlet temp = this.arr[first];\\n\\t\\tthis.arr[first] = this.arr[second];\\n\\t\\tthis.arr[second] = temp;\\n\\t}\\n\\t\\n\\tgetParent(){\\n\\t\\treturn this.arr[0];\\n\\t}\\n\\t\\n\\textract(){\\n\\t\\tlet valuePopped = this.arr[0];\\n\\t\\tthis.siftDown();\\n\\t\\treturn valuePopped;\\n\\t}\\n\\t\\n\\tsiftDown(){\\n\\t\\tthis.swap(0, this.arr.length-1);\\n\\t\\tthis.arr.pop();\\n\\t\\t\\n\\t\\tlet currentIdx = 0;\\n\\t\\tlet firstChild = currentIdx * 2 + 1;\\n\\t\\tlet secondChild = currentIdx * 2 + 2;\\n        \\n       \\n\\t\\t\\n\\t\\twhile(this.arr.length > firstChild){\\n\\t\\t\\tlet curIdx\\n\\t\\t\\tif(secondChild < this.arr.length){\\n\\t\\t\\t\\t//then compare the two\\n\\t\\t\\t\\tif(this.arr[firstChild] < this.arr[secondChild]){\\n\\t\\t\\t\\t\\tcurIdx = secondChild;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// the last floor\\n\\t\\t\\t\\tcurIdx = firstChild;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(this.arr[curIdx] > this.arr[currentIdx]){\\n\\t\\t\\t\\tthis.swap(currentIdx, curIdx, this.arr);\\n\\t\\t\\t\\tcurrentIdx = curIdx;\\n\\t\\t\\t\\tfirstChild = currentIdx *2 + 1;\\n\\t\\t\\t\\tsecondChild = currentIdx * 2 + 2;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\nvar minimumDifference = function(nums) {\\n    // console.log(heap.extract())\\n    let limit = parseInt(nums.length/3)\\n    \\n    let first = new maxHeap();\\n    let second = new Heap();\\n    \\n    \\n    for(let i = 0; i < limit; i++){\\n        first.add(nums[i]);\\n        second.add(nums[nums.length-i-1])\\n    }\\n    let solution = first.sum() - second.sum();\\n    \\n    let curArr = [];\\n    let curArrSecond = [];\\n    \\n    let firstSum = first.sum();\\n    let secondSum = second.sum()\\n    curArr.push(firstSum)\\n    curArrSecond.unshift(secondSum)\\n    \\n    for(let i = 0; i < limit; i++){\\n        let curIdx = i + limit;\\n        \\n        \\n        first.add(nums[curIdx]);\\n        let firstMinus = first.extract();\\n        firstSum += nums[curIdx] - firstMinus\\n        curArr.push(firstSum);\\n        \\n        second.add(nums[nums.length-curIdx-1]);\\n        let secondMinus = second.extract();\\n        secondSum += nums[nums.length-curIdx-1] - secondMinus\\n        curArrSecond.unshift(secondSum);\\n    }\\n    \\n    \\n    for(let i = 0; i < curArr.length; i++){\\n        solution = Math.min(solution, curArr[i] - curArrSecond[i])\\n    }\\n    \\n    \\n    return solution\\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751244,
                "title": "c-2163-minimum-difference-in-sums-after-removal-of-elements",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        long ans = 0;  \\n        priority_queue<int> left; \\n        for (int i = 0; i < n; ++i) {\\n            left.push(nums[i]); \\n            ans += nums[i]; \\n        }\\n        priority_queue<int, vector<int>, greater<>> right; \\n        for (int i = 2*n; i < 3*n; ++i) {\\n            right.push(nums[i]); \\n            ans -= nums[i]; \\n        }\\n        vector<long> prefix = {0}; \\n        for (int i = n; i < 2*n; ++i) \\n            if (nums[i] < left.top()) {\\n                prefix.push_back(prefix.back() + nums[i] - left.top()); \\n                left.pop(); \\n                left.push(nums[i]); \\n            } else prefix.push_back(prefix.back()); \\n        long extra = prefix.back(), suffix = 0;\\n        for (int i = 2*n-1; i >= n; --i) {\\n            if (nums[i] > right.top()) {\\n                suffix += right.top() - nums[i]; \\n                right.pop(); \\n                right.push(nums[i]); \\n            }\\n            extra = min(extra, prefix[i-n] + suffix); \\n        }\\n        return ans + extra; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size()/3;\\n        long ans = 0;  \\n        priority_queue<int> left; \\n        for (int i = 0; i < n; ++i) {\\n            left.push(nums[i]); \\n            ans += nums[i]; \\n        }\\n        priority_queue<int, vector<int>, greater<>> right; \\n        for (int i = 2*n; i < 3*n; ++i) {\\n            right.push(nums[i]); \\n            ans -= nums[i]; \\n        }\\n        vector<long> prefix = {0}; \\n        for (int i = n; i < 2*n; ++i) \\n            if (nums[i] < left.top()) {\\n                prefix.push_back(prefix.back() + nums[i] - left.top()); \\n                left.pop(); \\n                left.push(nums[i]); \\n            } else prefix.push_back(prefix.back()); \\n        long extra = prefix.back(), suffix = 0;\\n        for (int i = 2*n-1; i >= n; --i) {\\n            if (nums[i] > right.top()) {\\n                suffix += right.top() - nums[i]; \\n                right.pop(); \\n                right.push(nums[i]); \\n            }\\n            extra = min(extra, prefix[i-n] + suffix); \\n        }\\n        return ans + extra; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751089,
                "title": "python-o-nlogn-time-k-integers-of-extra-space",
                "content": "This reuses the input to store the heaps. We only need extra storage for the mid-section.\\n```\\nclass SolutionExceedsExpectations:\\n    def minimumDifference(self, nums: List[int]) -> int:       \\n        k=len(nums)//3\\n\\n        def build_array(h, seg, sgn):\\n            yield (a := sum(h))\\n            for i in range(len(h)):\\n                h[i] *= sgn\\n            heapify(h)\\n            for num in seg:\\n                yield (a := a + num - sgn*heappushpop(h, sgn*num))\\n\\n        A = build_array(nums[:k], nums[k:-k], -1)\\n        nums[-k:].reverse\\n        B = build_array(nums[-k:], reversed(nums[k:-k]), 1)\\n        return min(a - b for a, b in zip(A, reversed(list(B))))\\n```",
                "solutionTags": [],
                "code": "```\\nclass SolutionExceedsExpectations:\\n    def minimumDifference(self, nums: List[int]) -> int:       \\n        k=len(nums)//3\\n\\n        def build_array(h, seg, sgn):\\n            yield (a := sum(h))\\n            for i in range(len(h)):\\n                h[i] *= sgn\\n            heapify(h)\\n            for num in seg:\\n                yield (a := a + num - sgn*heappushpop(h, sgn*num))\\n\\n        A = build_array(nums[:k], nums[k:-k], -1)\\n        nums[-k:].reverse\\n        B = build_array(nums[-k:], reversed(nums[k:-k]), 1)\\n        return min(a - b for a, b in zip(A, reversed(list(B))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750862,
                "title": "c-natural-thought-process-using-heaps-logic-building-and-explanation-o-nlogn",
                "content": "This was a nice problem, took me time to figure out the details. \\nIn this post I would be sharing some insights and the overall approach.\\n\\n**1. First Intuition**\\n* We need to delete `n / 3` elements, so from where we delete them doesn\\'t matter.\\n* We need to find `first_sum - second_sum` this forces that any element from the window of second sums can\\'t appear before any element in first sum (this is basically what the question means by first n elements and last n elements, but thought I should share it).\\n* The first `n` elements window end point can only start from `n/3` (this is pretty obvious, if you can\\'t get it then think a little hard)\\n* Similarly the second `n` elements window left point can be at most `2*(n /3)`. \\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/900c75d6-a0f4-44f3-add4-048682f5d409_1644175202.4247098.jpeg\" alt=\"closed_paren\" title=\"Partition\" width=\"650\" height=\"200\"/>\\n\\n**2. Second Intuition**\\n* To think, the question wants us to minimize `diff = first_sum - second_sum`, this forces us to think that the bigger the `second_sum` and smaller the `first_sum` the minimum the value of `diff` would be. \\n* So, our short term goal should be maximizing `second_sum` and minimizing `first_sum`.\\nWe will get back to the use of this later, now focus on other aspect.\\n\\n**3. Intution About Partition**\\nHow should we partition the `nums` array such that we get at least `n/3` elements in the first section and at least `n/3` in the second section?\\n\\nWhat we can do is take a pointer `i` in range `[n/3 - 1 , 2n/3]` and now we have the liberty of satisfying the above condition.\\n\\n*So far so good?*\\n\\n**4. What now?**\\n* From the step 3, if for each `i` I can get what is the least possible value from choosing `n/3` elements from`<= i` (which would constitute first window), and at the same time ask what is maximum possible value by choosing `n/3` elements from `>i` (which would constitute second window).\\n* If we can get the above 2 things then the current possible difference would be `first_window_sum_i - second_window_sum_(i + 1)`  \\nThis value would be a possible contender for a optimal answer, so we keep taking the minimum out of all the possible `i in range [n/3 - 1 , 2n/3]` and the final value would be our answer :).\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/cabd34ad-9a6b-4269-925f-4ae8e0ac15ed_1644176534.5899453.jpeg\" alt=\"closed_paren\" title=\"diffval\" width=\"850\" height=\"300\"/>\\n\\n**FEW ADDITIONAL DETAILS**\\n**5. What about deleting the elements?**\\nNote that we are strictly choosing only `n/3` elements for first window and second window, hence the deletion is implicit.\\n\\n**6. How to find what we need in the 4th step?**\\nWe can use heap for that.\\n* For getting the minimum possible sum for some `i` in first window by exactly selecting `n/3` elements, we will use max heap. So that we can reject the biggest possible value and inculcate a lower value.\\n* For getting the max possible sum for some `i` in second window by exactly selecting `n/3` elements, we can use min heaps. Since, we need to reject the minimum values, and make space for better higher values.\\n\\nThe above computation will take `O(nlog(n))` time.\\n\\n**7. Now, finally the code:**\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n        //@Precomputations  \\n        //Finding min_poss_sum\\n        priority_queue<int> first; //max heap\\n        vector<ll> min_poss_sum(n);\\n        ll running_sum = 0;\\n        \\n        for(int i = 0 ; i < n / 3 ; i++){\\n            first.push(nums[i]);\\n            running_sum += (ll)nums[i];\\n            min_poss_sum[i] = running_sum;\\n        }\\n        for(int i = n / 3 ; i <= 2 * n / 3 ; i++){\\n            int max_in_heap = first.top();\\n            if(max_in_heap > nums[i]){\\n                first.pop();\\n                first.push(nums[i]);\\n                min_poss_sum[i] = running_sum + (ll)nums[i] - (ll)max_in_heap;\\n                running_sum = min_poss_sum[i];\\n            }\\n            else{\\n                min_poss_sum[i] = running_sum;\\n            }\\n        }\\n        \\n        //Finding max_poss_sum from the right\\n        priority_queue<int , vector<int> , greater<int>> second;//min heap\\n        vector<ll> max_poss_sum(n);\\n        running_sum = 0;\\n        \\n        for(int i = n - 1 ; i >= 2 * n / 3 ; i--){\\n            second.push(nums[i]);\\n            running_sum += (ll)nums[i];\\n            max_poss_sum[i] = running_sum;\\n        }\\n        for(int i = 2 * n / 3 - 1 ; i >= n/3 - 1; i--){\\n            int min_in_heap = second.top();\\n            if(min_in_heap < nums[i]){\\n                second.pop();\\n                second.push(nums[i]);\\n                max_poss_sum[i] = running_sum + (ll)nums[i] - (ll)min_in_heap;\\n                running_sum = max_poss_sum[i];\\n            }\\n            else{\\n                max_poss_sum[i] = running_sum;\\n            }\\n        }\\n\\n        \\n        ll diff = LONG_MAX;\\n        for(int i = (n / 3) - 1 ; i < 2 * n / 3 ; i++){\\n            ll first_window_sum = min_poss_sum[i];\\n            ll second_window_sum = max_poss_sum[i + 1];\\n            ll poss_diff = first_window_sum - second_window_sum;\\n            diff = min(diff , poss_diff);\\n        }\\n        \\n        return diff;\\n\\n    }\\n};\\n```\\n\\nIf you liked the post, I would be really glad if you could upvote :)",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n        //@Precomputations  \\n        //Finding min_poss_sum\\n        priority_queue<int> first; //max heap\\n        vector<ll> min_poss_sum(n);\\n        ll running_sum = 0;\\n        \\n        for(int i = 0 ; i < n / 3 ; i++){\\n            first.push(nums[i]);\\n            running_sum += (ll)nums[i];\\n            min_poss_sum[i] = running_sum;\\n        }\\n        for(int i = n / 3 ; i <= 2 * n / 3 ; i++){\\n            int max_in_heap = first.top();\\n            if(max_in_heap > nums[i]){\\n                first.pop();\\n                first.push(nums[i]);\\n                min_poss_sum[i] = running_sum + (ll)nums[i] - (ll)max_in_heap;\\n                running_sum = min_poss_sum[i];\\n            }\\n            else{\\n                min_poss_sum[i] = running_sum;\\n            }\\n        }\\n        \\n        //Finding max_poss_sum from the right\\n        priority_queue<int , vector<int> , greater<int>> second;//min heap\\n        vector<ll> max_poss_sum(n);\\n        running_sum = 0;\\n        \\n        for(int i = n - 1 ; i >= 2 * n / 3 ; i--){\\n            second.push(nums[i]);\\n            running_sum += (ll)nums[i];\\n            max_poss_sum[i] = running_sum;\\n        }\\n        for(int i = 2 * n / 3 - 1 ; i >= n/3 - 1; i--){\\n            int min_in_heap = second.top();\\n            if(min_in_heap < nums[i]){\\n                second.pop();\\n                second.push(nums[i]);\\n                max_poss_sum[i] = running_sum + (ll)nums[i] - (ll)min_in_heap;\\n                running_sum = max_poss_sum[i];\\n            }\\n            else{\\n                max_poss_sum[i] = running_sum;\\n            }\\n        }\\n\\n        \\n        ll diff = LONG_MAX;\\n        for(int i = (n / 3) - 1 ; i < 2 * n / 3 ; i++){\\n            ll first_window_sum = min_poss_sum[i];\\n            ll second_window_sum = max_poss_sum[i + 1];\\n            ll poss_diff = first_window_sum - second_window_sum;\\n            diff = min(diff , poss_diff);\\n        }\\n        \\n        return diff;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750601,
                "title": "python-heapq-nlogn",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        n=m//3\\n        #mmin[i]=min sum subsequence from 0 to i\\n        #mmax[i]=max sum subsequence from i+1 till end\\n        mmin,mmax=[None]*m,[None]*m \\n        #heap according to name max and min\\n        max_heap,min_heap=[],[]\\n        ans=sys.maxsize\\n        for i in range(2*n):\\n            if len(max_heap)<n:\\n                heapq.heappush(max_heap,-nums[i])\\n                if len(max_heap)==n:\\n                    ssum=-sum(max_heap)\\n                    mmin[i]=ssum\\n                continue\\n            if nums[i]<(-max_heap[0]):\\n                ssum-=(-heapq.heappop(max_heap))\\n                heapq.heappush(max_heap,-nums[i])\\n                ssum+=nums[i]\\n            mmin[i]=ssum\\n        for i in range(3*n-1,n-1,-1):\\n            if len(min_heap)<n:\\n                heapq.heappush(min_heap,nums[i])\\n                if len(min_heap)==n:\\n                    ssum=sum(min_heap)\\n                    mmax[i-1]=ssum\\n                continue\\n            if nums[i]>min_heap[0]:\\n                ssum-=heapq.heappop(min_heap)\\n                heapq.heappush(min_heap,nums[i])\\n                ssum+=nums[i]\\n            mmax[i-1]=ssum\\n        #check every element from n-1 to 2n-1 of mmin[i]-mmax[i] and take min\\n        for i in range(n-1,2*n):\\n            ans=min(ans,mmin[i]-mmax[i])\\n        return ans\\n        \\n            \\n                        \\n```\\nUpvote !!",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        n=m//3\\n        #mmin[i]=min sum subsequence from 0 to i\\n        #mmax[i]=max sum subsequence from i+1 till end\\n        mmin,mmax=[None]*m,[None]*m \\n        #heap according to name max and min\\n        max_heap,min_heap=[],[]\\n        ans=sys.maxsize\\n        for i in range(2*n):\\n            if len(max_heap)<n:\\n                heapq.heappush(max_heap,-nums[i])\\n                if len(max_heap)==n:\\n                    ssum=-sum(max_heap)\\n                    mmin[i]=ssum\\n                continue\\n            if nums[i]<(-max_heap[0]):\\n                ssum-=(-heapq.heappop(max_heap))\\n                heapq.heappush(max_heap,-nums[i])\\n                ssum+=nums[i]\\n            mmin[i]=ssum\\n        for i in range(3*n-1,n-1,-1):\\n            if len(min_heap)<n:\\n                heapq.heappush(min_heap,nums[i])\\n                if len(min_heap)==n:\\n                    ssum=sum(min_heap)\\n                    mmax[i-1]=ssum\\n                continue\\n            if nums[i]>min_heap[0]:\\n                ssum-=heapq.heappop(min_heap)\\n                heapq.heappush(min_heap,nums[i])\\n                ssum+=nums[i]\\n            mmax[i-1]=ssum\\n        #check every element from n-1 to 2n-1 of mmin[i]-mmax[i] and take min\\n        for i in range(n-1,2*n):\\n            ans=min(ans,mmin[i]-mmax[i])\\n        return ans\\n        \\n            \\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749650,
                "title": "c-solution-using-priority-queue",
                "content": "```\\nlong long minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=n/3;\\n        vector<long long> v1(n),v2(n);v1[0]=nums[0];v2[n-1]=nums[n-1];\\n        priority_queue<int> q1;\\n        priority_queue<int,vector<int>,greater<int>>q2;\\n        q1.push(nums[0]);q2.push(nums[n-1]);\\n        for(int i=1;i<2*s;i++){\\n            if(i<s){\\n                q1.push(nums[i]);\\n                v1[i]=v1[i-1]+nums[i];\\n            }\\n            else{\\n                int x=q1.top();\\n                if(nums[i]<x){\\n                    v1[i]=v1[i-1]+(nums[i]-x);\\n                    q1.pop();\\n                    q1.push(nums[i]);\\n                }\\n                else{\\n                    v1[i]=v1[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-2;i>=s;i--){\\n            if(i>=2*s){\\n                q2.push(nums[i]);\\n                v2[i]=v2[i+1]+nums[i];\\n            }\\n            else{\\n                int x=q2.top();\\n                if(nums[i]>x){\\n                    v2[i]=v2[i+1]+(nums[i]-x);\\n                    q2.pop();\\n                    q2.push(nums[i]);\\n                }\\n                else{\\n                    v2[i]=v2[i+1];\\n                }\\n            }\\n        }\\n        long long tot=LLONG_MAX;\\n        for(int i=s-1;i<2*s;i++){\\n            tot=min(tot,v1[i]-v2[i+1]);\\n        }\\n        return tot;\\n    }",
                "solutionTags": [],
                "code": "```\\nlong long minimumDifference(vector<int>& nums) {\\n        int n=nums.size();\\n        int s=n/3;\\n        vector<long long> v1(n),v2(n);v1[0]=nums[0];v2[n-1]=nums[n-1];\\n        priority_queue<int> q1;\\n        priority_queue<int,vector<int>,greater<int>>q2;\\n        q1.push(nums[0]);q2.push(nums[n-1]);\\n        for(int i=1;i<2*s;i++){\\n            if(i<s){\\n                q1.push(nums[i]);\\n                v1[i]=v1[i-1]+nums[i];\\n            }\\n            else{\\n                int x=q1.top();\\n                if(nums[i]<x){\\n                    v1[i]=v1[i-1]+(nums[i]-x);\\n                    q1.pop();\\n                    q1.push(nums[i]);\\n                }\\n                else{\\n                    v1[i]=v1[i-1];\\n                }\\n            }\\n        }\\n        for(int i=n-2;i>=s;i--){\\n            if(i>=2*s){\\n                q2.push(nums[i]);\\n                v2[i]=v2[i+1]+nums[i];\\n            }\\n            else{\\n                int x=q2.top();\\n                if(nums[i]>x){\\n                    v2[i]=v2[i+1]+(nums[i]-x);\\n                    q2.pop();\\n                    q2.push(nums[i]);\\n                }\\n                else{\\n                    v2[i]=v2[i+1];\\n                }\\n            }\\n        }\\n        long long tot=LLONG_MAX;\\n        for(int i=s-1;i<2*s;i++){\\n            tot=min(tot,v1[i]-v2[i+1]);\\n        }\\n        return tot;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1749563,
                "title": "simple-solution-using-priority-queue-with-explanation",
                "content": "here the goal is to minimize the sum of left n elements and maximizing the sum of right n elements so that the difference is minimum\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3;\\n        long long leftsum=0,rightsum=0;\\n        long long minn=LLONG_MAX;    \\n        \\n        priority_queue<int>l;      // for left half remaining\\n        priority_queue<int,vector<int>,greater<int>>r;    // for right half remaining\\n        vector<long long>tmp(3*n,0);  //to store the prefix sum index wise\\n        \\n        for(int i=3*n-1;i>=n;i--)\\n        {\\n            r.push(nums[i]);\\n            rightsum+=nums[i];\\n            if(r.size()>n)     //removing the smallest element\\n            {\\n                rightsum-=r.top();\\n                r.pop();\\n            }\\n            if(r.size()==n) tmp[i]=rightsum;       //storing the sum once we have n elements in right half\\n        }\\n        \\n       for(int i=0;i<2*n;i++)\\n       {\\n           l.push(nums[i]);\\n           leftsum+=nums[i];\\n           if(l.size()>n)             //removing the largest element\\n           {\\n               leftsum-=l.top();\\n               l.pop();\\n           }\\n           if(l.size()==n)\\n           {\\n               minn=min(leftsum-tmp[i+1],minn);        //calculating the difference between leftsum and rightsum once we have n elements in left half\\n           }\\n       }\\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long n=nums.size()/3;\\n        long long leftsum=0,rightsum=0;\\n        long long minn=LLONG_MAX;    \\n        \\n        priority_queue<int>l;      // for left half remaining\\n        priority_queue<int,vector<int>,greater<int>>r;    // for right half remaining\\n        vector<long long>tmp(3*n,0);  //to store the prefix sum index wise\\n        \\n        for(int i=3*n-1;i>=n;i--)\\n        {\\n            r.push(nums[i]);\\n            rightsum+=nums[i];\\n            if(r.size()>n)     //removing the smallest element\\n            {\\n                rightsum-=r.top();\\n                r.pop();\\n            }\\n            if(r.size()==n) tmp[i]=rightsum;       //storing the sum once we have n elements in right half\\n        }\\n        \\n       for(int i=0;i<2*n;i++)\\n       {\\n           l.push(nums[i]);\\n           leftsum+=nums[i];\\n           if(l.size()>n)             //removing the largest element\\n           {\\n               leftsum-=l.top();\\n               l.pop();\\n           }\\n           if(l.size()==n)\\n           {\\n               minn=min(leftsum-tmp[i+1],minn);        //calculating the difference between leftsum and rightsum once we have n elements in left half\\n           }\\n       }\\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749013,
                "title": "using-priority-queue",
                "content": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        \\n        priority_queue<int> pq;\\n        \\n        int n = nums.size();\\n        \\n        long long dp1[n];\\n        \\n        long long dp2[n];\\n        \\n        int k = n/3;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        \\n        long long sum = 0;\\n        \\n        for(int i = k;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n            \\n            sum += pq.top();\\n            \\n            pq.pop();\\n            \\n            dp1[i] = sum;\\n            /*priority_queue<int> pq1;\\n            \\n            pq1 = pq;\\n            \\n            int remove = (i+1) - k;\\n            \\n            int cnt = 1;\\n            \\n            long long sum = 0;\\n            \\n            while(cnt <= remove)\\n            {\\n               \\n                \\n                sum += pq.top();\\n                \\n                pq.pop();\\n                \\n                cnt++;\\n                \\n            }\\n            \\n            dp1[i] = sum;\\n            \\n          //  cout<<\"dp1\"<<\" \"<<i<<\" \"<<sum<<endl;\\n            pq = pq1;*/\\n            \\n        }\\n        \\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        \\n        for(int i = n-1;i >=n-k;i--)\\n        {\\n            pq2.push(nums[i]);\\n        }\\n        \\n        //sum = 0;\\n        \\n        long long pref[n];\\n        \\n        long long suff[n];\\n        \\n        long long sum1 = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum1 += nums[i];\\n            \\n            pref[i] = sum1;\\n        }\\n        \\n        sum1 = 0;\\n        \\n        \\n        for(int i = n-1;i >=0;i--)\\n        {\\n            sum1 += nums[i];\\n            \\n            suff[i] = sum1;\\n        }\\n        \\n       \\n        sum1 = 0;\\n        \\n        for(int i = n-k-1;i >= 0;i--)\\n        {\\n            pq2.push(nums[i]);\\n            \\n            sum1 += pq2.top();\\n            \\n            pq2.pop();\\n            \\n           /* priority_queue<int,vector<int>,greater<int>> pq3;\\n            \\n            pq3 = pq2;\\n            \\n            int remove = (n-1 -i +1) - k;\\n            \\n            int cnt = 1;\\n            \\n            long long sum = 0;\\n            \\n            while(cnt <= remove)\\n            {\\n               \\n                \\n                sum += pq2.top();\\n                \\n                pq2.pop();\\n                \\n                cnt++;\\n                \\n            }*/\\n            \\n            dp2[i] = sum1;\\n            \\n            //cout<<\"dp2\"<<\" \"<<i<<\" \"<<sum<<endl;\\n            //pq2 = pq3;\\n            \\n        }\\n        \\n        long long mini1 = pow(10,18);\\n        \\n        for(int i = k-1;i <=n-k;i++)\\n        {\\n            if(i == k-1)\\n            {\\n                long long  r1 = pref[i];\\n                \\n                long long r2 = suff[i+1] - dp2[i+1];\\n                \\n                mini1 = min(mini1,r1-r2);\\n            }\\n            else if(i == n-k)\\n            {\\n                long long r1 = pref[i-1] - dp1[i-1];\\n                \\n                long long r2 = suff[i];\\n                \\n                \\n                mini1 = min(mini1,r1-r2);\\n                \\n            }\\n            else\\n            {\\n                long long r1 = pref[i] - dp1[i];\\n                \\n                long long r2 = suff[i+1] - dp2[i+1];\\n                \\n               \\n                 mini1 = min(mini1,r1-r2);\\n            }\\n                \\n        }\\n        \\n        return mini1;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        \\n        priority_queue<int> pq;\\n        \\n        int n = nums.size();\\n        \\n        long long dp1[n];\\n        \\n        long long dp2[n];\\n        \\n        int k = n/3;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1748301,
                "title": "java-100",
                "content": "```java\\n// keep left as small as possible\\n// keep right as large as possible\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        long ans=Long.MAX_VALUE;\\n        int length=nums.length;\\n        int n = length/3;\\n        long leftsum=0, rightsum=0;\\n        long[] leftprefix = new long[n+1];\\n        long[] rightprefix = new long[n+1];\\n        PriorityQueue<Long> leftpq = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Long> rightpq = new PriorityQueue<>();\\n        \\n        // calculate left prefix\\n        for(int i=0; i<n; i++){\\n            leftpq.add((long)nums[i]);\\n            leftsum+=nums[i];\\n        }\\n        leftprefix[0]=leftsum;\\n        \\n        int counter=1;\\n        for(int i=n; i<2*n; i++){\\n            leftpq.add((long)nums[i]);\\n            leftsum+=nums[i];\\n            leftsum-=leftpq.poll();\\n            leftprefix[counter++]=leftsum;\\n        }\\n        \\n        // calculate rightprefix backward\\n        for(int i=length-1; i>=2*n; i--){\\n            rightpq.add((long)nums[i]);\\n            rightsum+=nums[i];\\n        }\\n        rightprefix[n]=rightsum;\\n        \\n        counter=n-1;\\n        for(int i=2*n-1; i>=n; i--){\\n            rightpq.add((long)nums[i]);\\n            rightsum+=nums[i];\\n            rightsum-=rightpq.poll();\\n            rightprefix[counter--]=rightsum;\\n        }\\n        \\n        for(int i=0; i<n+1; i++){\\n            ans = Math.min(leftprefix[i]-rightprefix[i], ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// keep left as small as possible\\n// keep right as large as possible\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        long ans=Long.MAX_VALUE;\\n        int length=nums.length;\\n        int n = length/3;\\n        long leftsum=0, rightsum=0;\\n        long[] leftprefix = new long[n+1];\\n        long[] rightprefix = new long[n+1];\\n        PriorityQueue<Long> leftpq = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Long> rightpq = new PriorityQueue<>();\\n        \\n        // calculate left prefix\\n        for(int i=0; i<n; i++){\\n            leftpq.add((long)nums[i]);\\n            leftsum+=nums[i];\\n        }\\n        leftprefix[0]=leftsum;\\n        \\n        int counter=1;\\n        for(int i=n; i<2*n; i++){\\n            leftpq.add((long)nums[i]);\\n            leftsum+=nums[i];\\n            leftsum-=leftpq.poll();\\n            leftprefix[counter++]=leftsum;\\n        }\\n        \\n        // calculate rightprefix backward\\n        for(int i=length-1; i>=2*n; i--){\\n            rightpq.add((long)nums[i]);\\n            rightsum+=nums[i];\\n        }\\n        rightprefix[n]=rightsum;\\n        \\n        counter=n-1;\\n        for(int i=2*n-1; i>=n; i--){\\n            rightpq.add((long)nums[i]);\\n            rightsum+=nums[i];\\n            rightsum-=rightpq.poll();\\n            rightprefix[counter--]=rightsum;\\n        }\\n        \\n        for(int i=0; i<n+1; i++){\\n            ans = Math.min(leftprefix[i]-rightprefix[i], ans);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748164,
                "title": "python-heap-sorted-list-and-cumulative-sum",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n\\n        cumsum = [0]\\n        n = 0\\n        for num in nums:\\n            n += num\\n            cumsum.append(n)\\n\\n        n = len(nums) // 3\\n\\n        current_left = [-elem for elem in nums[:n]]\\n        heapify(current_left)\\n        sum_excluded_left = 0\\n\\n        excluded_right = sorted(nums[n:])[:n]\\n        # Use a sorted list because:\\n        # - remove element is log(n) (vs. n in normal list since we have to rewrite everything)\\n        # - check element presence is log(n) (vs. n in normal list)\\n        excluded_right = SortedList(excluded_right)\\n        right = cumsum[(3 * n)] - cumsum[n] - sum(sorted(nums[n:])[:n])\\n\\n        res = cumsum[n] - right\\n\\n        for i in range(n):\\n            candidate = nums[n + i]\\n\\n            to_exclude = -heappushpop(current_left, -candidate)\\n            sum_excluded_left += to_exclude\\n            left = cumsum[n + i + 1] - sum_excluded_left\\n\\n            if candidate in excluded_right:\\n                excluded_right.remove(candidate)\\n            else:\\n                to_include = excluded_right[-1]\\n                excluded_right.remove(to_include)\\n                right += to_include - candidate\\n\\n            res = min(res, left - right)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n\\n        cumsum = [0]\\n        n = 0\\n        for num in nums:\\n            n += num\\n            cumsum.append(n)\\n\\n        n = len(nums) // 3\\n\\n        current_left = [-elem for elem in nums[:n]]\\n        heapify(current_left)\\n        sum_excluded_left = 0\\n\\n        excluded_right = sorted(nums[n:])[:n]\\n        # Use a sorted list because:\\n        # - remove element is log(n) (vs. n in normal list since we have to rewrite everything)\\n        # - check element presence is log(n) (vs. n in normal list)\\n        excluded_right = SortedList(excluded_right)\\n        right = cumsum[(3 * n)] - cumsum[n] - sum(sorted(nums[n:])[:n])\\n\\n        res = cumsum[n] - right\\n\\n        for i in range(n):\\n            candidate = nums[n + i]\\n\\n            to_exclude = -heappushpop(current_left, -candidate)\\n            sum_excluded_left += to_exclude\\n            left = cumsum[n + i + 1] - sum_excluded_left\\n\\n            if candidate in excluded_right:\\n                excluded_right.remove(candidate)\\n            else:\\n                to_include = excluded_right[-1]\\n                excluded_right.remove(to_include)\\n                right += to_include - candidate\\n\\n            res = min(res, left - right)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748132,
                "title": "c-minheap-and-maxheap-o-nlogn-plus-draft-interpretation",
                "content": "Problem description wants to delete n elements, and divide set into 2 set of n, making sumleft - sumright the minimum.\\n\\nIn other word, we can view it as find a split line, choose n elements in the left and choose n elements in the right, making sumleft - sumright the mininum.\\n\\nTo find min(sumleft) and max(sumright), we use 2 array left_minN, right_maxN to store them.\\nAnd we use maxheap to store min n elements in the left, minheap to store max n elements in the right \\n![image](https://assets.leetcode.com/users/images/1fbe3914-a9a1-4d85-813f-841276ff3e92_1644103761.6946115.png)\\n\\nTime complexity O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int M = nums.size();\\n        int n = M/3;\\n        vector<long long> left_minN(n+1,0);\\n        vector<long long> right_maxN(n+1,0);\\n        priority_queue<long long> q;\\n        long long sum = 0;\\n        for (int i =0;i<n;i++){\\n            q.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        left_minN[0] = sum;\\n        for (int i =n;i<2*n;i++){\\n            sum+=nums[i];\\n            q.push(nums[i]);\\n            long long tmp = q.top();\\n            q.pop();\\n            sum-=tmp;\\n            left_minN[i-n+1] = sum;\\n        }\\n        // right\\n        sum = 0;\\n        priority_queue<long long, vector<long long>,greater<long long>>qq; //min-heap\\n        for (int i =3*n-1;i>=2*n;i--){\\n            qq.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        right_maxN[n] = sum;\\n        for (int i =2*n-1;i>=n;i--){\\n            sum+=nums[i];\\n            qq.push(nums[i]);\\n            long long tmp = qq.top();\\n            // cout<<tmp<<endl;\\n            qq.pop();\\n            sum-=tmp;\\n            right_maxN[i-n] = sum;\\n        }\\n        long long ans = 1e15;\\n        for (int i = 0;i<=n;i++){\\n            // cout<<left_minN[i]<<\\' \\'<<right_maxN[i]<<endl;\\n            ans = min(ans, left_minN[i] - right_maxN[i]);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int M = nums.size();\\n        int n = M/3;\\n        vector<long long> left_minN(n+1,0);\\n        vector<long long> right_maxN(n+1,0);\\n        priority_queue<long long> q;\\n        long long sum = 0;\\n        for (int i =0;i<n;i++){\\n            q.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        left_minN[0] = sum;\\n        for (int i =n;i<2*n;i++){\\n            sum+=nums[i];\\n            q.push(nums[i]);\\n            long long tmp = q.top();\\n            q.pop();\\n            sum-=tmp;\\n            left_minN[i-n+1] = sum;\\n        }\\n        // right\\n        sum = 0;\\n        priority_queue<long long, vector<long long>,greater<long long>>qq; //min-heap\\n        for (int i =3*n-1;i>=2*n;i--){\\n            qq.push(nums[i]);\\n            sum+=nums[i];\\n        }\\n        right_maxN[n] = sum;\\n        for (int i =2*n-1;i>=n;i--){\\n            sum+=nums[i];\\n            qq.push(nums[i]);\\n            long long tmp = qq.top();\\n            // cout<<tmp<<endl;\\n            qq.pop();\\n            sum-=tmp;\\n            right_maxN[i-n] = sum;\\n        }\\n        long long ans = 1e15;\\n        for (int i = 0;i<=n;i++){\\n            // cout<<left_minN[i]<<\\' \\'<<right_maxN[i]<<endl;\\n            ans = min(ans, left_minN[i] - right_maxN[i]);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1748061,
                "title": "python3-priority-queue",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/57fa31fc309c7347ae7fae475880a8bfdefcea66) for solutions of biweekly 71. \\n\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        pq0 = [-x for x in nums[:n]]\\n        pq1 = nums[-n:]\\n        \\n        heapify(pq0)\\n        heapify(pq1)\\n        \\n        ans = -sum(pq0) - sum(pq1)\\n        prefix = [0]\\n        for i in range(n, 2*n): \\n            prefix.append(prefix[-1])\\n            if nums[i] < -pq0[0]: \\n                prefix[-1] += nums[i] + pq0[0]\\n                heapreplace(pq0, -nums[i])\\n        extra = prefix[-1]\\n        suffix = 0 \\n        for i in reversed(range(n, 2*n)): \\n            if nums[i] > pq1[0]: \\n                suffix += pq1[0] - nums[i]\\n                heapreplace(pq1, nums[i])\\n            extra = min(extra, prefix[i-n] + suffix)\\n        return ans + extra\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        pq0 = [-x for x in nums[:n]]\\n        pq1 = nums[-n:]\\n        \\n        heapify(pq0)\\n        heapify(pq1)\\n        \\n        ans = -sum(pq0) - sum(pq1)\\n        prefix = [0]\\n        for i in range(n, 2*n): \\n            prefix.append(prefix[-1])\\n            if nums[i] < -pq0[0]: \\n                prefix[-1] += nums[i] + pq0[0]\\n                heapreplace(pq0, -nums[i])\\n        extra = prefix[-1]\\n        suffix = 0 \\n        for i in reversed(range(n, 2*n)): \\n            if nums[i] > pq1[0]: \\n                suffix += pq1[0] - nums[i]\\n                heapreplace(pq1, nums[i])\\n            extra = min(extra, prefix[i-n] + suffix)\\n        return ans + extra\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747874,
                "title": "python-min-heap-max-heap-beats-88",
                "content": "```\\nclass Solution:\\n    import heapq\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        \\n        left_heap = []\\n        cur_sum = 0\\n        for i in range(n):\\n            heapq.heappush(left_heap, -nums[i])\\n            cur_sum+=nums[i]\\n        left_sums=[cur_sum]\\n        \\n        right_heap = []\\n        cur_sum = 0\\n        for i in range(2*n, 3*n):\\n            heapq.heappush(right_heap, nums[i])\\n            cur_sum+=nums[i]\\n        right_sums=[cur_sum]      \\n        \\n        for i in range(n,2*n):\\n            pop = heapq.heappushpop(left_heap, -nums[i])\\n            left_sums.append(left_sums[-1] + nums[i] + pop)\\n        \\n        for i in range(2*n-1,n-1,-1):\\n            pop = heapq.heappushpop(right_heap, nums[i])\\n            right_sums.append(right_sums[-1] + nums[i] - pop)\\n            \\n        return min(left_sums[i]-right_sums[n-i] for i in range(n+1))\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    import heapq\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        \\n        left_heap = []\\n        cur_sum = 0\\n        for i in range(n):\\n            heapq.heappush(left_heap, -nums[i])\\n            cur_sum+=nums[i]\\n        left_sums=[cur_sum]\\n        \\n        right_heap = []\\n        cur_sum = 0\\n        for i in range(2*n, 3*n):\\n            heapq.heappush(right_heap, nums[i])\\n            cur_sum+=nums[i]\\n        right_sums=[cur_sum]      \\n        \\n        for i in range(n,2*n):\\n            pop = heapq.heappushpop(left_heap, -nums[i])\\n            left_sums.append(left_sums[-1] + nums[i] + pop)\\n        \\n        for i in range(2*n-1,n-1,-1):\\n            pop = heapq.heappushpop(right_heap, nums[i])\\n            right_sums.append(right_sums[-1] + nums[i] - pop)\\n            \\n        return min(left_sums[i]-right_sums[n-i] for i in range(n+1))\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1747738,
                "title": "c-explanation-using-priority-queue",
                "content": "**here to minimize the difference  we have to minimize the first half and maximize the second half \\nTo do so we gonna use two   heaps  (minheap & maxheap) \\nwhile traversing forward we will generate the prefix array and store all the minimum values in the maxheap \\nand while traversing backwards we will generate the suffix array and store all the maximum values in the minheap.**\\n\\n**TC = ~ O(NlogN)**\\n**SC = ~ O(N) **\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = n/3;\\n        vector<ll > pref(n,0);\\n        vector<ll > suff(n,0);\\n        ll sum =0;\\n        \\n        \\n        priority_queue<int, vector<int> , greater<int> > pqb; // min heap for suffix array\\n        priority_queue<int > pqf;     // max heap for prefix array\\n        for(int i=0; i< k; i++){\\n           \\n            sum += nums[i];\\n            pref[i] = sum;\\n            pqf.push(nums[i]);\\n        }\\n        \\n        for(int i=k; i< n-k; i++){\\n            if( nums[i] < pqf.top()  ){\\n                sum-=pqf.top();\\n                pqf.pop();\\n                sum+= nums[i];\\n                pqf.push(nums[i]);\\n            }\\n            \\n            pref[i] = sum;\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i= n-1; i>= n- k; i-- ){\\n            sum += nums[i];\\n            suff[i] = sum;\\n            pqb.push(nums[i]);\\n        }\\n        \\n        for(int i=n-k-1; i >=k ; i-- ){\\n            \\n            if(nums[i] > pqb.top() ){\\n                sum -= pqb.top();\\n                pqb.pop();\\n                sum+= nums[i];\\n                pqb.push(nums[i]);\\n            }\\n            \\n            suff[i] = sum;\\n        }\\n        \\n       \\n        \\n        ll ans = INT64_MAX;\\n        for(int i=k ;i<= n- k ; i++ ){\\n            \\n            ans = min ( ans ,  pref[i-1] - suff[i]  );\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size();\\n        int k = n/3;\\n        vector<ll > pref(n,0);\\n        vector<ll > suff(n,0);\\n        ll sum =0;\\n        \\n        \\n        priority_queue<int, vector<int> , greater<int> > pqb; // min heap for suffix array\\n        priority_queue<int > pqf;     // max heap for prefix array\\n        for(int i=0; i< k; i++){\\n           \\n            sum += nums[i];\\n            pref[i] = sum;\\n            pqf.push(nums[i]);\\n        }\\n        \\n        for(int i=k; i< n-k; i++){\\n            if( nums[i] < pqf.top()  ){\\n                sum-=pqf.top();\\n                pqf.pop();\\n                sum+= nums[i];\\n                pqf.push(nums[i]);\\n            }\\n            \\n            pref[i] = sum;\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i= n-1; i>= n- k; i-- ){\\n            sum += nums[i];\\n            suff[i] = sum;\\n            pqb.push(nums[i]);\\n        }\\n        \\n        for(int i=n-k-1; i >=k ; i-- ){\\n            \\n            if(nums[i] > pqb.top() ){\\n                sum -= pqb.top();\\n                pqb.pop();\\n                sum+= nums[i];\\n                pqb.push(nums[i]);\\n            }\\n            \\n            suff[i] = sum;\\n        }\\n        \\n       \\n        \\n        ll ans = INT64_MAX;\\n        for(int i=k ;i<= n- k ; i++ ){\\n            \\n            ans = min ( ans ,  pref[i-1] - suff[i]  );\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747708,
                "title": "heap-pre-computation-c",
                "content": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        ll int n=a.size();\\n        ll int arr[n+1];\\n        for(int i=1;i<=n;i++)arr[i]=a[i-1];\\n        priority_queue< ll int> pq;\\n        ll int ans=0;\\n        ll int temp=n/3;\\n        ll int pre[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans+=arr[i];\\n            pq.push(arr[i]);\\n            if(pq.size()>temp)\\n            {\\n                ans-=pq.top();\\n                pq.pop();\\n            }\\n            pre[i]=ans;\\n        }\\n        priority_queue< ll int, vector<ll int> , greater<ll int> > pq1;\\n        ll int post[n+1];\\n        ans=0;\\n        for(int i=n;i>=1;i--)\\n        {\\n            ans+=arr[i];\\n            pq1.push(arr[i]);\\n            if(pq1.size()>temp)\\n            {\\n                ans-=pq1.top();\\n                pq1.pop();\\n            }\\n            post[i]=ans;\\n        }\\n        ll int mn_ans=10000000000000000;\\n        for(int i=temp;i<=2*temp;i++)\\n        {\\n            //cout<<pre[i]<<\" \"<<post[i+1]<<endl;\\n            mn_ans=min(mn_ans,pre[i]-post[i+1]);\\n        }\\n        return mn_ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n    long long minimumDifference(vector<int>& a) {\\n        ll int n=a.size();\\n        ll int arr[n+1];\\n        for(int i=1;i<=n;i++)arr[i]=a[i-1];\\n        priority_queue< ll int> pq;\\n        ll int ans=0;\\n        ll int temp=n/3;\\n        ll int pre[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans+=arr[i];\\n            pq.push(arr[i]);\\n            if(pq.size()>temp)\\n            {\\n                ans-=pq.top();\\n                pq.pop();\\n            }\\n            pre[i]=ans;\\n        }\\n        priority_queue< ll int, vector<ll int> , greater<ll int> > pq1;\\n        ll int post[n+1];\\n        ans=0;\\n        for(int i=n;i>=1;i--)\\n        {\\n            ans+=arr[i];\\n            pq1.push(arr[i]);\\n            if(pq1.size()>temp)\\n            {\\n                ans-=pq1.top();\\n                pq1.pop();\\n            }\\n            post[i]=ans;\\n        }\\n        ll int mn_ans=10000000000000000;\\n        for(int i=temp;i<=2*temp;i++)\\n        {\\n            //cout<<pre[i]<<\" \"<<post[i+1]<<endl;\\n            mn_ans=min(mn_ans,pre[i]-post[i+1]);\\n        }\\n        return mn_ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1747569,
                "title": "c-268ms-two-heaps-and-sum-top-n-in-n-2n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int l = nums.size();\\n        int n = l / 3;\\n        \\n        long long ret = 0x7FFFFFFFFFFFFFFFLL;\\n        long long s0 = 0,s1 = 0;\\n        vector<long long> head(n+1,0), tail(n+1,0);\\n\\n        priority_queue <int,vector<int>,less<int> > q0;\\n        priority_queue <int,vector<int>,greater<int> > q1;\\n        \\n\\n        for(int i=0; i<n; i++) {\\n            s0 += nums[i];\\n            q0.push(nums[i]);\\n        }\\n        head[0]=s0;\\n\\n        for(int i=2*n; i<3*n; i++) {\\n            s1 += nums[i];\\n            q1.push(nums[i]);\\n        }\\n        tail[0]=s1;\\n\\n        for(int i=0; i<n; i++) {\\n            int d0 = nums[n+i]-q0.top();\\n            if (d0<0) {\\n            s0 += d0;\\n            q0.pop();\\n            q0.push(nums[n+i]);\\n            }\\n            int d1 = nums[2*n-1-i]-q1.top();\\n            if (d1>0) {\\n            s1 += d1;\\n            q1.pop();\\n            q1.push(nums[2*n-1-i]);\\n            }\\n            head[i+1]=s0;\\n            tail[i+1]=s1;\\n        }\\n\\n        for(int i=0; i<=n; i++) {\\n            // printf(\"[%d]%d-%d=%d\\\\n\", i,head[i],tail[n-i], head[i]-tail[n-i]); //\\n            long long tmp = head[i]-tail[n-i];\\n            if (tmp < ret) {\\n                ret = tmp;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int l = nums.size();\\n        int n = l / 3;\\n        \\n        long long ret = 0x7FFFFFFFFFFFFFFFLL;\\n        long long s0 = 0,s1 = 0;\\n        vector<long long> head(n+1,0), tail(n+1,0);\\n\\n        priority_queue <int,vector<int>,less<int> > q0;\\n        priority_queue <int,vector<int>,greater<int> > q1;\\n        \\n\\n        for(int i=0; i<n; i++) {\\n            s0 += nums[i];\\n            q0.push(nums[i]);\\n        }\\n        head[0]=s0;\\n\\n        for(int i=2*n; i<3*n; i++) {\\n            s1 += nums[i];\\n            q1.push(nums[i]);\\n        }\\n        tail[0]=s1;\\n\\n        for(int i=0; i<n; i++) {\\n            int d0 = nums[n+i]-q0.top();\\n            if (d0<0) {\\n            s0 += d0;\\n            q0.pop();\\n            q0.push(nums[n+i]);\\n            }\\n            int d1 = nums[2*n-1-i]-q1.top();\\n            if (d1>0) {\\n            s1 += d1;\\n            q1.pop();\\n            q1.push(nums[2*n-1-i]);\\n            }\\n            head[i+1]=s0;\\n            tail[i+1]=s1;\\n        }\\n\\n        for(int i=0; i<=n; i++) {\\n            // printf(\"[%d]%d-%d=%d\\\\n\", i,head[i],tail[n-i], head[i]-tail[n-i]); //\\n            long long tmp = head[i]-tail[n-i];\\n            if (tmp < ret) {\\n                ret = tmp;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747545,
                "title": "java-min-and-max-heap-solution",
                "content": "```\\n/**\\n\\tIf we remove n elements then the first elements will not contain any of the last n elements\\n\\tand similarly the last n elements will not contain any of the first n elements\\n\\tno matter what the case.\\n\\t\\n\\tSince we need to minimize the difference so for each index from n to 2*n\\n\\twe find the maximum suffix and minimum prefix sum of n elements only\\n\\t\\n\\tSo to achieve this for n<=i<=2n, we remove i-n max Elements from the left subarray and 2n-i min Elements from \\n\\tright subarray  and then we finally find the minimum differences of prefix and suffix sums\\n*/\\n\\nclass Solution {\\n    \\n    public long minimumDifference(int[] nums) {\\n        \\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        long sum=0;\\n        \\n        long[] leftSum=new long[n + 1];\\n        long[] rightSum=new long[n + 1];\\n        \\n        for (int i = 0; i < 2 * n; i++) {\\n            maxHeap.add(nums[i]);\\n            sum+=nums[i];\\n            \\n            if (i < n) \\n                leftSum[0] =sum;\\n            else {\\n                sum-=maxHeap.poll();\\n                leftSum[i-n+1] = sum;\\n            }\\n        }\\n        \\n        sum=0;\\n        \\n        for (int i=3*n-1;i>n-1;i--) {\\n            minHeap.add(nums[i]);\\n            sum+=nums[i];\\n            \\n            if (i>2*n-1) \\n                rightSum[0] =sum;\\n            \\n            else {\\n                sum-=minHeap.poll();\\n                rightSum[2*n-i] =sum;\\n            }\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        for (int k = 0; k <= n; k++) \\n            ans = Math.min(ans, leftSum[k]-rightSum[n-k]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n\\tIf we remove n elements then the first elements will not contain any of the last n elements\\n\\tand similarly the last n elements will not contain any of the first n elements\\n\\tno matter what the case.\\n\\t\\n\\tSince we need to minimize the difference so for each index from n to 2*n\\n\\twe find the maximum suffix and minimum prefix sum of n elements only\\n\\t\\n\\tSo to achieve this for n<=i<=2n, we remove i-n max Elements from the left subarray and 2n-i min Elements from \\n\\tright subarray  and then we finally find the minimum differences of prefix and suffix sums\\n*/\\n\\nclass Solution {\\n    \\n    public long minimumDifference(int[] nums) {\\n        \\n        int n = nums.length / 3;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        long sum=0;\\n        \\n        long[] leftSum=new long[n + 1];\\n        long[] rightSum=new long[n + 1];\\n        \\n        for (int i = 0; i < 2 * n; i++) {\\n            maxHeap.add(nums[i]);\\n            sum+=nums[i];\\n            \\n            if (i < n) \\n                leftSum[0] =sum;\\n            else {\\n                sum-=maxHeap.poll();\\n                leftSum[i-n+1] = sum;\\n            }\\n        }\\n        \\n        sum=0;\\n        \\n        for (int i=3*n-1;i>n-1;i--) {\\n            minHeap.add(nums[i]);\\n            sum+=nums[i];\\n            \\n            if (i>2*n-1) \\n                rightSum[0] =sum;\\n            \\n            else {\\n                sum-=minHeap.poll();\\n                rightSum[2*n-i] =sum;\\n            }\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        for (int k = 0; k <= n; k++) \\n            ans = Math.min(ans, leftSum[k]-rightSum[n-k]);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747530,
                "title": "c-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size();\\n        vector<int>num(n+1);//for 1 based indexing\\n        \\n        for(int i=0;i<n;i++){\\n            num[i+1]=nums[i];\\n        }\\n        \\n        int cnt=n/3;\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq;  \\n        \\n        long long int sum=0;\\n        for(int i=n;i>=0;i--){\\n            pq.push(num[i]);\\n            sum+=num[i];\\n            cnt--;\\n            if(cnt==0)break;\\n        }\\n        \\n       long long int right[n+1]; //max sum we can get by choosing n/3 elements from i to n\\n        \\n        right[2*(n/3)+1]=sum;\\n        \\n        for(int i= 2*(n/3);i>n/3;i--){\\n            \\n            if(num[i]>pq.top()){\\n\\t\\t\\t\\n               sum= sum-pq.top();\\n                pq.pop();\\n               sum+=num[i];\\n               pq.push(num[i]);\\n                \\n            }\\n            \\n            right[i]=sum;    \\n        }\\n        \\n       long long int left[n+1];   //min sum we can get by choosing n/3 elements from 1 to i\\n        \\n        priority_queue<int>pq2;\\n        sum=0;\\n\\t\\t\\n        for(int i=1;i<=n/3;i++){\\n            pq2.push(num[i]);\\n            sum+=num[i];\\n        }\\n\\t\\t\\n        left[n/3]=sum;\\n        \\n        for(int i=n/3+1;i<=2*(n/3);i++){\\n            \\n             if(num[i]<pq2.top()){\\n               sum= sum-pq2.top();\\n                pq2.pop();\\n               sum+=num[i];\\n               pq2.push(num[i]);\\n            }\\n            left[i]=sum;\\n        }\\n        \\n       long long int ans=LONG_MAX;\\n\\t   \\n        for(int j=n/3;j<=2*(n/3);j++){\\n            ans=min(ans,left[j]-right[j+1]);\\n        }        \\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size();\\n        vector<int>num(n+1);//for 1 based indexing\\n        \\n        for(int i=0;i<n;i++){\\n            num[i+1]=nums[i];\\n        }\\n        \\n        int cnt=n/3;\\n        \\n        priority_queue<int,vector<int>,greater<int>>pq;  \\n        \\n        long long int sum=0;\\n        for(int i=n;i>=0;i--){\\n            pq.push(num[i]);\\n            sum+=num[i];\\n            cnt--;\\n            if(cnt==0)break;\\n        }\\n        \\n       long long int right[n+1]; //max sum we can get by choosing n/3 elements from i to n\\n        \\n        right[2*(n/3)+1]=sum;\\n        \\n        for(int i= 2*(n/3);i>n/3;i--){\\n            \\n            if(num[i]>pq.top()){\\n\\t\\t\\t\\n               sum= sum-pq.top();\\n                pq.pop();\\n               sum+=num[i];\\n               pq.push(num[i]);\\n                \\n            }\\n            \\n            right[i]=sum;    \\n        }\\n        \\n       long long int left[n+1];   //min sum we can get by choosing n/3 elements from 1 to i\\n        \\n        priority_queue<int>pq2;\\n        sum=0;\\n\\t\\t\\n        for(int i=1;i<=n/3;i++){\\n            pq2.push(num[i]);\\n            sum+=num[i];\\n        }\\n\\t\\t\\n        left[n/3]=sum;\\n        \\n        for(int i=n/3+1;i<=2*(n/3);i++){\\n            \\n             if(num[i]<pq2.top()){\\n               sum= sum-pq2.top();\\n                pq2.pop();\\n               sum+=num[i];\\n               pq2.push(num[i]);\\n            }\\n            left[i]=sum;\\n        }\\n        \\n       long long int ans=LONG_MAX;\\n\\t   \\n        for(int j=n/3;j<=2*(n/3);j++){\\n            ans=min(ans,left[j]-right[j+1]);\\n        }        \\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747520,
                "title": "c-nlogn-350ms-algorithm-explained",
                "content": "**Algorithm:**\\n1. So we have to remove any n numbers from the given 3*n numbers in array. Lets assume L(0,i) be left part of the array remaing and R(i+1, 3*n) be the right part of the array.\\n2. So we have the option to remove some elements from left part and remove some option from second part. More formally,\\n    Remove 0 element from left, n elemets from right,\\n\\tRemove 1 element from left, n-1 elemets from right,\\n\\tRemove 2 elements from left, n-2 elemets from right,\\n\\t......\\n\\tRemove n elements from left, 0 elemet from right\\nAnd the configuration for which the difference will be minimum will be the answer.\\n\\t\\n3. Since we want the minimum difference we want to remove the largest elements from the left part of array and remove smallest elements from right part of the array.\\n4. So first we can start with nums[0,n] and in each step remove the largest element and then add next elements. Do this till index 2*n-1, Why? Try to think little. We can have a array leftSumRemoved, where leftSumRemoved[i] represents total sum of i numbers removed. This can be done by using max heap in logN time. Do the same thing for right part of array. \\n5. Now we have two arrays leftSumRemoved and rightSumRemoved where each index i represents commulative sum of i numbers removed.\\n6. Now we can use this to implement point 2 in O(N).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        \\n        priority_queue<int> leftPQ;\\n        for(int i= 0; i < n; i++) {\\n            leftPQ.push(nums[i]);\\n        }\\n        \\n        \\n        vector<long long> leftSumRemoved(n+1, 0);\\n\\n        for(int i = 1; i <= n; i++) {\\n            leftPQ.push(nums[i+n-1]);\\n            leftSumRemoved[i] = leftSumRemoved[i-1] + leftPQ.top();\\n            leftPQ.pop();\\n        }\\n        \\n        priority_queue<int, vector<int>, greater<int> > rightPQ;\\n\\n        for(int i= 2*n; i < 3*n; i++) {\\n            rightPQ.push(nums[i]);\\n        }\\n        \\n        vector<long long> rightSumRemoved(n+1, 0);\\n       \\n        for(int i = 1; i <= n; i++) {\\n            rightPQ.push(nums[2*n-i]);\\n            rightSumRemoved[i] = rightSumRemoved[i-1] + rightPQ.top();\\n            rightPQ.pop();\\n        }\\n        \\n        \\n        \\n        vector<long long> cumSum(3*n);\\n        cumSum[0] = nums[0];\\n        for(int i = 1 ; i < 3*n; i++) {\\n            cumSum[i] = cumSum[i-1] + nums[i];\\n        }\\n        \\n        \\n        long long ans = 10e12;\\n        for(int i = 0; i <= n; i++) {\\n            long long firstHalf = cumSum[n+i-1] - leftSumRemoved[i] ;\\n            long long secondHalf = cumSum[3*n-1] - cumSum[n+i-1] - rightSumRemoved[n-i] ;\\n            ans = min(ans, firstHalf - secondHalf);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease do upvote if you get the full understanding. Else please comment if having trouble understanding. Thank you.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        int n = nums.size() / 3;\\n        \\n        priority_queue<int> leftPQ;\\n        for(int i= 0; i < n; i++) {\\n            leftPQ.push(nums[i]);\\n        }\\n        \\n        \\n        vector<long long> leftSumRemoved(n+1, 0);\\n\\n        for(int i = 1; i <= n; i++) {\\n            leftPQ.push(nums[i+n-1]);\\n            leftSumRemoved[i] = leftSumRemoved[i-1] + leftPQ.top();\\n            leftPQ.pop();\\n        }\\n        \\n        priority_queue<int, vector<int>, greater<int> > rightPQ;\\n\\n        for(int i= 2*n; i < 3*n; i++) {\\n            rightPQ.push(nums[i]);\\n        }\\n        \\n        vector<long long> rightSumRemoved(n+1, 0);\\n       \\n        for(int i = 1; i <= n; i++) {\\n            rightPQ.push(nums[2*n-i]);\\n            rightSumRemoved[i] = rightSumRemoved[i-1] + rightPQ.top();\\n            rightPQ.pop();\\n        }\\n        \\n        \\n        \\n        vector<long long> cumSum(3*n);\\n        cumSum[0] = nums[0];\\n        for(int i = 1 ; i < 3*n; i++) {\\n            cumSum[i] = cumSum[i-1] + nums[i];\\n        }\\n        \\n        \\n        long long ans = 10e12;\\n        for(int i = 0; i <= n; i++) {\\n            long long firstHalf = cumSum[n+i-1] - leftSumRemoved[i] ;\\n            long long secondHalf = cumSum[3*n-1] - cumSum[n+i-1] - rightSumRemoved[n-i] ;\\n            ans = min(ans, firstHalf - secondHalf);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747507,
                "title": "c-priority-queue-prefix-array-time-o-nlogn-space-o-n",
                "content": "**Approach**\\nMinimize the sumleft and maximize the sumright.There will be a point of separation in array ```i``` ( N<=i<=2xN ) where answer exist for min sum from index 0 to i-1 and max sum for i+1 to 3xN-1. This can be done by using priority queue.\\n* considering only n min elements, left will contain the min sum of elements from 0 to i-1. \\n* considering only n max elements, right will contain the max sum of elements from i to last.\\n\\nusing max heap we can find the min sum for every index of ```left```. Maintain a variable ```sum```. start loop from i = 0.\\n1. do sum+=nums[i] , push element into queue\\n1. if queue.size()>n, do sum-=queue.top() (which is the max element)  and pop it.\\n\\nusing min heap we can find the max sum for every index of ```right```. Maintain a variable ```sum```. start the loop from last of nums.\\n1. do sum+=nums[i] , push element into queue\\n1. if queue.size()>n, do sum-=queue.top() (which is the min element)  and pop it.\\n\\nfinally, for every index ```i``` ( N<=i<=2xN ), calculate ```left[i-1] -right[i] ```and find the min value.\\n```time complexity = O(NlogN), space complexity = O(N)```\\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long sum = 0;\\n        int n = nums.size()/3;\\n        vector<long long> left(n*3,0);\\n        vector<long long> right(n*3,0);\\n        priority_queue<int> q;\\n        for(int i = 0; i<nums.size();++i){\\n            sum+=nums[i]; q.push(nums[i]);\\n            if(q.size()>n){\\n                int t = q.top(); sum-=t; q.pop();\\n            }\\n            if(q.size()==n) left[i] = sum;\\n        }\\n        sum = 0;\\n        priority_queue<int,vector<int>,greater<int>> mp;\\n        for(int i = nums.size()-1; i>=0;--i){\\n            sum+=nums[i]; mp.push(nums[i]);\\n            if(mp.size()>n){\\n                int t = mp.top(); sum-=t; mp.pop();\\n            }\\n            if(mp.size()==n) right[i] = sum;\\n        }\\n        long long re = LONG_MAX;\\n        for(int i = n;i<=2*n;++i) re = min(re,left[i-1]-right[i]);\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```i```\n```left```\n```sum```\n```right```\n```sum```\n```i```\n```left[i-1] -right[i] ```\n```time complexity = O(NlogN), space complexity = O(N)```\n```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& nums) {\\n        long long sum = 0;\\n        int n = nums.size()/3;\\n        vector<long long> left(n*3,0);\\n        vector<long long> right(n*3,0);\\n        priority_queue<int> q;\\n        for(int i = 0; i<nums.size();++i){\\n            sum+=nums[i]; q.push(nums[i]);\\n            if(q.size()>n){\\n                int t = q.top(); sum-=t; q.pop();\\n            }\\n            if(q.size()==n) left[i] = sum;\\n        }\\n        sum = 0;\\n        priority_queue<int,vector<int>,greater<int>> mp;\\n        for(int i = nums.size()-1; i>=0;--i){\\n            sum+=nums[i]; mp.push(nums[i]);\\n            if(mp.size()>n){\\n                int t = mp.top(); sum-=t; mp.pop();\\n            }\\n            if(mp.size()==n) right[i] = sum;\\n        }\\n        long long re = LONG_MAX;\\n        for(int i = n;i<=2*n;++i) re = min(re,left[i-1]-right[i]);\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747504,
                "title": "python3-using-heaps",
                "content": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:       \\n        k=len(nums)//3\\n        \\n        minHeap, maxHeap = [], []\\n        minLeft, maxRight = [], []\\n        \\n        minSum, maxSum = 0, 0\\n        \\n        for num in nums[:-k]:\\n            heappush(minHeap, -num)\\n            minSum += num\\n            if len(minHeap) > k: \\n                minSum += heappop(minHeap)\\n            \\n            minLeft.append(minSum)\\n            \\n        for num in nums[::-1][:-k]:\\n            heappush(maxHeap,num)\\n            maxSum += num\\n            if len(maxHeap) > k: \\n                maxSum -= heappop(maxHeap)\\n            \\n            maxRight.append(maxSum)\\n            \\n        minLeft = minLeft[k-1:]\\n        maxRight = maxRight[k-1:][::-1]\\n        \\n        ans = inf\\n        for i in range(k + 1):\\n            ans = min(ans, minLeft[i] - maxRight[i])\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:       \\n        k=len(nums)//3\\n        \\n        minHeap, maxHeap = [], []\\n        minLeft, maxRight = [], []\\n        \\n        minSum, maxSum = 0, 0\\n        \\n        for num in nums[:-k]:\\n            heappush(minHeap, -num)\\n            minSum += num\\n            if len(minHeap) > k: \\n                minSum += heappop(minHeap)\\n            \\n            minLeft.append(minSum)\\n            \\n        for num in nums[::-1][:-k]:\\n            heappush(maxHeap,num)\\n            maxSum += num\\n            if len(maxHeap) > k: \\n                maxSum -= heappop(maxHeap)\\n            \\n            maxRight.append(maxSum)\\n            \\n        minLeft = minLeft[k-1:]\\n        maxRight = maxRight[k-1:][::-1]\\n        \\n        ans = inf\\n        for i in range(k + 1):\\n            ans = min(ans, minLeft[i] - maxRight[i])\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747473,
                "title": "python-3-use-counter",
                "content": "\\n```\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        l,r = n,2*n\\n        sumL,sumR = sum(nums[:l]),sum(nums[r:])\\n        \\n        cntrL,cntrR = Counter(nums[:l]),Counter(nums[r:])\\n        listM = nums[l:r]\\n        \\n        listL,listR = sorted(cntrL.keys()),sorted(cntrR.keys())\\n        \\n\\t\\t# if (i+1) elements are deleted for sumL and sumR optimally, what is the change in sumL and sumR, respectively\\n        listChL,listChR = [0]*(n+1),[0]*(n+1)\\n        for i in range(n):                             \\n            vD,vA = listL[-1],listM[i]                             # candidate value to delete and value to add for optimized sumL\\n            listChL[1+i],listChR[1+i] = listChL[i],listChR[i]\\n            if vD>vA:                             # if vD>vA, delete vD and add vA, otherwise, delete vA (do nothing)\\n                listChL[1+i] += -vD+vA\\n                cntrL[vD] -= 1\\n                if not cntrL[vD]:                    listL.pop()\\n                if vA not in cntrL:\\n                    k = bisect_left(listL,vA)\\n                    listL.insert(k,vA)\\n                cntrL[vA] += 1\\n            vD,vA = listR[0],listM[-1-i]                             # candidate value to delete and value to add for optimized sumR\\n            if vD<vA:                            # if vD<vA, delete vD and add vA, otherwise, delete vA (do nothing)\\n                listChR[1+i] += -vD+vA\\n                cntrR[vD] -= 1\\n                if not cntrR[vD]:                    listR.pop(0)\\n                if vA not in cntrR:\\n                    k = bisect_left(listR,vA)\\n                    listR.insert(k,vA)\\n                cntrR[vA] += 1\\n        listChL = list(accumulate(listChL, min))\\n        listChR = list(accumulate(listChR, max))[::-1]\\n        \\n        return sumL-sumR + min( listChL[i]-listChR[i] for i in range(n+1) )",
                "solutionTags": [],
                "code": "\\n```\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums)//3\\n        l,r = n,2*n\\n        sumL,sumR = sum(nums[:l]),sum(nums[r:])\\n        \\n        cntrL,cntrR = Counter(nums[:l]),Counter(nums[r:])\\n        listM = nums[l:r]\\n        \\n        listL,listR = sorted(cntrL.keys()),sorted(cntrR.keys())\\n        \\n\\t\\t# if (i+1) elements are deleted for sumL and sumR optimally, what is the change in sumL and sumR, respectively\\n        listChL,listChR = [0]*(n+1),[0]*(n+1)\\n        for i in range(n):                             \\n            vD,vA = listL[-1],listM[i]                             # candidate value to delete and value to add for optimized sumL\\n            listChL[1+i],listChR[1+i] = listChL[i],listChR[i]\\n            if vD>vA:                             # if vD>vA, delete vD and add vA, otherwise, delete vA (do nothing)\\n                listChL[1+i] += -vD+vA\\n                cntrL[vD] -= 1\\n                if not cntrL[vD]:                    listL.pop()\\n                if vA not in cntrL:\\n                    k = bisect_left(listL,vA)\\n                    listL.insert(k,vA)\\n                cntrL[vA] += 1\\n            vD,vA = listR[0],listM[-1-i]                             # candidate value to delete and value to add for optimized sumR\\n            if vD<vA:                            # if vD<vA, delete vD and add vA, otherwise, delete vA (do nothing)\\n                listChR[1+i] += -vD+vA\\n                cntrR[vD] -= 1\\n                if not cntrR[vD]:                    listR.pop(0)\\n                if vA not in cntrR:\\n                    k = bisect_left(listR,vA)\\n                    listR.insert(k,vA)\\n                cntrR[vA] += 1\\n        listChL = list(accumulate(listChL, min))\\n        listChR = list(accumulate(listChR, max))[::-1]\\n        \\n        return sumL-sumR + min( listChL[i]-listChR[i] for i in range(n+1) )",
                "codeTag": "Python3"
            },
            {
                "id": 1747451,
                "title": "python-left-and-right-heaps",
                "content": "Basically a DP problem where we track the subarray sum containing n elements from the left and from the right. \\nThe left subarray sum `l[i]`  is the sum of the minimum `n+i` elements.\\n```py\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n1, n2, n3 = [-x for x in nums[:len(nums)//3]], nums[len(nums)//3:2*len(nums)//3], nums[2*len(nums)//3:]\\n        heapify(n1)\\n        heapify(n3)\\n        l = [0]*(len(n2)+1)\\n        l[0] = -sum(n1)\\n        for i, num in enumerate(n2, 1):\\n            hval = -heappop(n1)\\n            if num < hval:\\n                l[i] = l[i-1] + (num - hval)\\n                heappush(n1, -num)\\n            else:\\n                l[i] = l[i-1]\\n                heappush(n1, -hval)\\n        \\n        r = [0]*(len(n2)+1)\\n        r[-1] = sum(n3)\\n        for i in range(len(n2)-1, -1, -1):\\n            hval = heappop(n3)\\n            num = n2[i]\\n            if num > hval:\\n                r[i] = r[i+1] + (num - hval)\\n                heappush(n3, num)\\n            else:\\n                r[i] = r[i+1]\\n                heappush(n3, hval)\\n        return min(a-b for a, b in zip(l, r))\\n```py",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n1, n2, n3 = [-x for x in nums[:len(nums)//3]], nums[len(nums)//3:2*len(nums)//3], nums[2*len(nums)//3:]\\n        heapify(n1)\\n        heapify(n3)\\n        l = [0]*(len(n2)+1)\\n        l[0] = -sum(n1)\\n        for i, num in enumerate(n2, 1):\\n            hval = -heappop(n1)\\n            if num < hval:\\n                l[i] = l[i-1] + (num - hval)\\n                heappush(n1, -num)\\n            else:\\n                l[i] = l[i-1]\\n                heappush(n1, -hval)\\n        \\n        r = [0]*(len(n2)+1)\\n        r[-1] = sum(n3)\\n        for i in range(len(n2)-1, -1, -1):\\n            hval = heappop(n3)\\n            num = n2[i]\\n            if num > hval:\\n                r[i] = r[i+1] + (num - hval)\\n                heappush(n3, num)\\n            else:\\n                r[i] = r[i+1]\\n                heappush(n3, hval)\\n        return min(a-b for a, b in zip(l, r))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747391,
                "title": "c-solution-dynamic-programming-min-max-heap-priority-queue",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minimumDifference(vector<int>& nums) {\\n\\t\\t\\tlong long n=nums.size();\\n\\t\\t\\tlong long sumDp[n];\\n\\t\\t\\tsumDp[0]=nums[0];\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tsumDp[i]=sumDp[i-1]+nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tlong long maxNL[n+1];\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tmaxNL[i]=0;\\n\\t\\t\\t}\\n\\t\\t\\tpriority_queue<int> gg;\\n\\t\\t\\tfor(int i=0;i<2*n/3;i++){\\n\\t\\t\\t\\tgg.push(nums[i]);\\n\\t\\t\\t\\tif(i>=n/3){\\n\\t\\t\\t\\t\\tmaxNL[i]=maxNL[i-1]+gg.top();\\n\\t\\t\\t\\t\\tgg.pop();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n        priority_queue<int,vector<int>,greater<int>> ff;\\n        long long maxNR[n+1];\\n        for(int i=0;i<n;i++){\\n            maxNR[i]=0;\\n        }\\n        for(int i=n-1;i>n/3-1;i--){\\n            ff.push(nums[i]);\\n            if(i<=2*n/3-1){\\n                maxNR[i]=maxNR[i+1]+ff.top();\\n                ff.pop();\\n            }\\n            \\n        }\\n        long long ans=100000000000000000;\\n        for(int i=n/3-1;i<2*n/3;i++){\\n            long long temp=(sumDp[i]-maxNL[i])-((sumDp[n-1]-sumDp[i])-maxNR[i+1]);\\n            ans=min(ans,temp);\\n        }\\n        return ans;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minimumDifference(vector<int>& nums) {\\n\\t\\t\\tlong long n=nums.size();\\n\\t\\t\\tlong long sumDp[n];\\n\\t\\t\\tsumDp[0]=nums[0];\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tsumDp[i]=sumDp[i-1]+nums[i];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1747371,
                "title": "python3-heap-solution-o-nlogn-with-comments",
                "content": "```\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # Create heaps for the left and right n elements\\n        # Since we are looking for the maximum values we have to multiply all left elements with -1\\n        # as heappop returns the minimum\\n        left = [-l for l in nums[:n]]\\n        heapify(left)\\n        right = nums[n*2:]\\n        heapify(right)\\n        \\n        # Calculate the (n+1) sums for all possible left subarrays assuming we are shifing 0...n elements\\n        # of the middle part to left\\n        sum_left = [0] * (n+1)\\n        s = -sum(left)\\n        sum_left[0] = s\\n\\n        for i in range(1, n+1):\\n            s += nums[n+i-1]\\n            heappush(left, -nums[n+i-1])\\n            s += heappop(left)\\n            sum_left[i] = s\\n\\n            \\n        # Calculate the (n+1) sums for all possible right subarrays assuming we are shifing 0...n elements\\n        # of the middle part to right\\n        sums_right = [0] * (n+1)\\n        s = sum(right)\\n        sums_right[0] = s\\n        \\n        for i in range(1, n+1):\\n            s += nums[2*n-i]\\n            heappush(right, nums[2*n-i])\\n            s -= heappop(right)\\n            sums_right[i] = s\\n            \\n        # Go through all precalculated solutions and find the minimum\\n        res = float(\\'inf\\')\\n        for i in range(n+1):\\n            res = min(res, sum_left[i] - sums_right[n-i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # Create heaps for the left and right n elements\\n        # Since we are looking for the maximum values we have to multiply all left elements with -1\\n        # as heappop returns the minimum\\n        left = [-l for l in nums[:n]]\\n        heapify(left)\\n        right = nums[n*2:]\\n        heapify(right)\\n        \\n        # Calculate the (n+1) sums for all possible left subarrays assuming we are shifing 0...n elements\\n        # of the middle part to left\\n        sum_left = [0] * (n+1)\\n        s = -sum(left)\\n        sum_left[0] = s\\n\\n        for i in range(1, n+1):\\n            s += nums[n+i-1]\\n            heappush(left, -nums[n+i-1])\\n            s += heappop(left)\\n            sum_left[i] = s\\n\\n            \\n        # Calculate the (n+1) sums for all possible right subarrays assuming we are shifing 0...n elements\\n        # of the middle part to right\\n        sums_right = [0] * (n+1)\\n        s = sum(right)\\n        sums_right[0] = s\\n        \\n        for i in range(1, n+1):\\n            s += nums[2*n-i]\\n            heappush(right, nums[2*n-i])\\n            s -= heappop(right)\\n            sums_right[i] = s\\n            \\n        # Go through all precalculated solutions and find the minimum\\n        res = float(\\'inf\\')\\n        for i in range(n+1):\\n            res = min(res, sum_left[i] - sums_right[n-i])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1747336,
                "title": "max-and-min-heaps-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n        priority_queue<int> maxpq;\\n        priority_queue<int, vector<int>, greater<int>> minpq;\\n        \\n        int m = A.size();\\n        int n = m / 3;\\n        vector<long> l(m), r(m);\\n\\n        for(int i = 0; i < m; i++){\\n            if(maxpq.size() < n) {\\n                maxpq.push(A[i]);\\n                l[i] = (i > 0 ? l[i - 1] : 0) + A[i];\\n            }\\n            else if(maxpq.top() > A[i]){\\n                l[i] = l[i - 1];\\n                l[i] -= maxpq.top();\\n                l[i] += A[i];\\n                maxpq.pop();\\n                maxpq.push(A[i]);\\n            }\\n            else l[i] = l[i - 1];\\n        }\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            if(minpq.size() < n) {\\n                minpq.push(A[i]);\\n                r[i] = (i + 1 < m ? r[i + 1] : 0) + A[i];\\n            }\\n            else if(minpq.top() < A[i]){\\n                r[i] = r[i + 1];\\n                r[i] -= minpq.top();\\n                r[i] += A[i];\\n                minpq.pop();\\n                minpq.push(A[i]);\\n            }\\n            else r[i] = r[i + 1];\\n        }\\n        \\n        long ans = LONG_MAX;\\n        for(int i = n - 1; i < m - n; i++){\\n            ans = min(ans, l[i] - r[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumDifference(vector<int>& A) {\\n        priority_queue<int> maxpq;\\n        priority_queue<int, vector<int>, greater<int>> minpq;\\n        \\n        int m = A.size();\\n        int n = m / 3;\\n        vector<long> l(m), r(m);\\n\\n        for(int i = 0; i < m; i++){\\n            if(maxpq.size() < n) {\\n                maxpq.push(A[i]);\\n                l[i] = (i > 0 ? l[i - 1] : 0) + A[i];\\n            }\\n            else if(maxpq.top() > A[i]){\\n                l[i] = l[i - 1];\\n                l[i] -= maxpq.top();\\n                l[i] += A[i];\\n                maxpq.pop();\\n                maxpq.push(A[i]);\\n            }\\n            else l[i] = l[i - 1];\\n        }\\n        \\n        for(int i = m - 1; i >= 0; i--){\\n            if(minpq.size() < n) {\\n                minpq.push(A[i]);\\n                r[i] = (i + 1 < m ? r[i + 1] : 0) + A[i];\\n            }\\n            else if(minpq.top() < A[i]){\\n                r[i] = r[i + 1];\\n                r[i] -= minpq.top();\\n                r[i] += A[i];\\n                minpq.pop();\\n                minpq.push(A[i]);\\n            }\\n            else r[i] = r[i + 1];\\n        }\\n        \\n        long ans = LONG_MAX;\\n        for(int i = n - 1; i < m - n; i++){\\n            ans = min(ans, l[i] - r[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747301,
                "title": "java-priorityqueue-to-generate-prefix-and-suffix-sums",
                "content": "The idea is that at index `i`, one needs : \\n* min prefix sum from `[0...i-1]`, considering only n elements\\n* max suffix sum from `[i...n]` considering only n elements\\nthen `diff[i] = prefix[i-1]-suffix[i]`.\\n\\n`considering only n elements` -> this clause makes the `i` varies from `n` to `2*n`\\n\\nThe answer would be the minimum of all such diffs.\\n\\nI used two heaps (max for prefix and min for suffix) to generate the sums required at index i and calculate the `globalMin`.\\n\\n``\\nTime - O(NlogN)\\nSpace - O(N)\\n``\\n```\\n    public long minimumDifference(int[] nums) {\\n        int N = nums.length;\\n        int n = N/3;\\n        \\n\\t\\t// to save the prefix calculated at index i\\n        long[] dp = new long[N];\\n    \\n\\t    // generating prefix sum\\n\\t\\t// 1. adding 1st \\'n\\' numbers to the heap\\n\\t\\t// 2. traversing next \\'n\\' numbers and polling the max out if \\'nums[i]\\' is lesser\\n\\t\\t// 3. saving the prefix sum in the \\'dp[i]\\'\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        long prefix = 0;\\n        for(int i=0; i<n; i++){\\n            maxHeap.add(nums[i]);\\n            prefix += nums[i];\\n        }\\n        \\n        dp[n-1] = prefix;\\n        for(int i=n; i<2*n; i++){\\n            if(maxHeap.peek()>nums[i]){\\n                prefix -= maxHeap.poll();\\n                prefix += nums[i];\\n                maxHeap.add(nums[i]);\\n            }\\n            dp[i] = prefix;\\n        }\\n        \\n\\t\\t// similar idea to generate suffix sum\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        long suffix = 0;\\n        for(int i=N-1; i>=2*n; i--){\\n            minHeap.add(nums[i]);\\n            suffix += nums[i];\\n        }\\n        long globalMin = dp[2*n-1]-suffix;\\n        for(int i=2*n-1; i>=n; i--){\\n            if(minHeap.peek()<nums[i]){\\n                suffix -= minHeap.poll();\\n                suffix += nums[i];\\n                minHeap.add(nums[i]);\\n            }\\n\\t\\t\\t// storing the global minimum\\n            globalMin = Math.min(globalMin, dp[i-1]-suffix);\\n        }\\n\\n        return globalMin;\\n    }\\n```\\n\\nPS: there could be better/concise implementation to this problem, this is what I came up with during the contest.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public long minimumDifference(int[] nums) {\\n        int N = nums.length;\\n        int n = N/3;\\n        \\n\\t\\t// to save the prefix calculated at index i\\n        long[] dp = new long[N];\\n    \\n\\t    // generating prefix sum\\n\\t\\t// 1. adding 1st \\'n\\' numbers to the heap\\n\\t\\t// 2. traversing next \\'n\\' numbers and polling the max out if \\'nums[i]\\' is lesser\\n\\t\\t// 3. saving the prefix sum in the \\'dp[i]\\'\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        long prefix = 0;\\n        for(int i=0; i<n; i++){\\n            maxHeap.add(nums[i]);\\n            prefix += nums[i];\\n        }\\n        \\n        dp[n-1] = prefix;\\n        for(int i=n; i<2*n; i++){\\n            if(maxHeap.peek()>nums[i]){\\n                prefix -= maxHeap.poll();\\n                prefix += nums[i];\\n                maxHeap.add(nums[i]);\\n            }\\n            dp[i] = prefix;\\n        }\\n        \\n\\t\\t// similar idea to generate suffix sum\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        long suffix = 0;\\n        for(int i=N-1; i>=2*n; i--){\\n            minHeap.add(nums[i]);\\n            suffix += nums[i];\\n        }\\n        long globalMin = dp[2*n-1]-suffix;\\n        for(int i=2*n-1; i>=n; i--){\\n            if(minHeap.peek()<nums[i]){\\n                suffix -= minHeap.poll();\\n                suffix += nums[i];\\n                minHeap.add(nums[i]);\\n            }\\n\\t\\t\\t// storing the global minimum\\n            globalMin = Math.min(globalMin, dp[i-1]-suffix);\\n        }\\n\\n        return globalMin;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747284,
                "title": "all-possibilities-of-minutes-and-seconds-picture",
                "content": "![image](https://assets.leetcode.com/users/images/17fddf4b-b855-43a2-b649-6628ea380117_1644078596.7560885.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/17fddf4b-b855-43a2-b649-6628ea380117_1644078596.7560885.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1747257,
                "title": "java-2-heaps-o-nlogn",
                "content": "(1) divide the array to first part and second part from position n to 2n , \\n(2) for each divide position, the next step is to remove the biggest nums from part 1 and remove the smalles nums from part 2; \\n(3) hence the running heap.\\n\\ntime complexity: n*log(n);\\n\\n```\\nclass Solution {\\n    long[] prevMaxMem;\\n    long[] postMinMem;\\n    int n;\\n    public long minimumDifference(int[] nums) {\\n        this.n = nums.length/3;\\n        long[] sum = new long[nums.length+1];\\n        for(int i=0;i<nums.length;i++){\\n            sum[i+1]=sum[i]+nums[i];\\n        }\\n        calcPreMax(nums);\\n        calcPostMin(nums);\\n        \\n        long minD = Long.MAX_VALUE;\\n        for(int i=n-1;i<=2*n;i++){\\n            long prevMax = prevMaxMem[i];\\n            long postMin = postMinMem[i];\\n            long curD = 2*sum[i+1] - prevMax + postMin - sum[nums.length]; \\n\\n            minD = Math.min(minD,curD);\\n        }\\n        return minD;\\n    } \\n\\n    private void calcPreMax(int[] nums){\\n        this.prevMaxMem = new long[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((o1,o2)->(o2-o1));\\n        for(int i=0;i<n;i++){\\n            pq.offer(nums[i]);\\n        }\\n        prevMaxMem[n-1] = 0;\\n\\n        long sumMax = 0;\\n        for(int i=n;i<n*2;i++){\\n            pq.offer(nums[i]);\\n            sumMax += pq.poll();\\n            prevMaxMem[i] = sumMax;\\n        }\\n    }\\n    \\n    private void calcPostMin(int[] nums){\\n        this.postMinMem = new long[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=nums.length-1;i>=n*2;i--){\\n            pq.offer(nums[i]);\\n        }\\n        //System.out.println(pq); \\n        postMinMem[n*2-1] = 0;\\n        long sumMin = 0;\\n        for(int i=n*2-1;i>=n;i--){\\n            pq.offer(nums[i]);\\n            sumMin += pq.poll();\\n            postMinMem[i-1] = sumMin;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long[] prevMaxMem;\\n    long[] postMinMem;\\n    int n;\\n    public long minimumDifference(int[] nums) {\\n        this.n = nums.length/3;\\n        long[] sum = new long[nums.length+1];\\n        for(int i=0;i<nums.length;i++){\\n            sum[i+1]=sum[i]+nums[i];\\n        }\\n        calcPreMax(nums);\\n        calcPostMin(nums);\\n        \\n        long minD = Long.MAX_VALUE;\\n        for(int i=n-1;i<=2*n;i++){\\n            long prevMax = prevMaxMem[i];\\n            long postMin = postMinMem[i];\\n            long curD = 2*sum[i+1] - prevMax + postMin - sum[nums.length]; \\n\\n            minD = Math.min(minD,curD);\\n        }\\n        return minD;\\n    } \\n\\n    private void calcPreMax(int[] nums){\\n        this.prevMaxMem = new long[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((o1,o2)->(o2-o1));\\n        for(int i=0;i<n;i++){\\n            pq.offer(nums[i]);\\n        }\\n        prevMaxMem[n-1] = 0;\\n\\n        long sumMax = 0;\\n        for(int i=n;i<n*2;i++){\\n            pq.offer(nums[i]);\\n            sumMax += pq.poll();\\n            prevMaxMem[i] = sumMax;\\n        }\\n    }\\n    \\n    private void calcPostMin(int[] nums){\\n        this.postMinMem = new long[nums.length];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=nums.length-1;i>=n*2;i--){\\n            pq.offer(nums[i]);\\n        }\\n        //System.out.println(pq); \\n        postMinMem[n*2-1] = 0;\\n        long sumMin = 0;\\n        for(int i=n*2-1;i>=n;i--){\\n            pq.offer(nums[i]);\\n            sumMin += pq.poll();\\n            postMinMem[i-1] = sumMin;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747248,
                "title": "java-clear-solution",
                "content": "```java\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        \\n        long[] lSum = new long[n + 1];\\n        long[] rSum = new long[n + 1];\\n            \\n        var maxHeap = new PriorityQueue<Integer>((a, b) -> b - a);\\n        var minHeap = new PriorityQueue<Integer>();\\n        \\n        for (int i = 0; i < 2 * n; i++) {\\n            maxHeap.offer(nums[i]);\\n            \\n            if (i < n) {\\n                lSum[0] += nums[i];\\n            } else {\\n                lSum[i - n + 1] = lSum[i - n] + nums[i] - maxHeap.poll();\\n            }\\n        }\\n        \\n        for (int j = 3 * n - 1; j > n - 1; j--) {\\n            minHeap.offer(nums[j]);\\n            \\n            if (j > 2 * n - 1) {\\n                rSum[0] += nums[j];\\n            } else {\\n                rSum[2 * n - j] = rSum[2 * n - j - 1] + nums[j] - minHeap.poll();\\n            }\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for (int k = 0; k <= n; k++) {\\n            ans = Math.min(ans, lSum[k] - rSum[n - k]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public long minimumDifference(int[] nums) {\\n        int n = nums.length / 3;\\n        \\n        long[] lSum = new long[n + 1];\\n        long[] rSum = new long[n + 1];\\n            \\n        var maxHeap = new PriorityQueue<Integer>((a, b) -> b - a);\\n        var minHeap = new PriorityQueue<Integer>();\\n        \\n        for (int i = 0; i < 2 * n; i++) {\\n            maxHeap.offer(nums[i]);\\n            \\n            if (i < n) {\\n                lSum[0] += nums[i];\\n            } else {\\n                lSum[i - n + 1] = lSum[i - n] + nums[i] - maxHeap.poll();\\n            }\\n        }\\n        \\n        for (int j = 3 * n - 1; j > n - 1; j--) {\\n            minHeap.offer(nums[j]);\\n            \\n            if (j > 2 * n - 1) {\\n                rSum[0] += nums[j];\\n            } else {\\n                rSum[2 * n - j] = rSum[2 * n - j - 1] + nums[j] - minHeap.poll();\\n            }\\n        }\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for (int k = 0; k <= n; k++) {\\n            ans = Math.min(ans, lSum[k] - rSum[n - k]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1774747,
                "content": [
                    {
                        "username": "dostonbek_tilavov",
                        "content": "I bet most people think that this is not hard question from first read"
                    }
                ]
            }
        ]
    }
]