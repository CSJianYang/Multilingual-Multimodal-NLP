[
    {
        "title": "Recover a Tree From Preorder Traversal",
        "question_content": "We run a&nbsp;preorder&nbsp;depth-first search (DFS) on the root of a binary tree.\nAt each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.&nbsp; If the depth of a node is D, the depth of its immediate child is D + 1.&nbsp; The depth of the root node is 0.\nIf a node has only one child, that child is guaranteed to be the left child.\nGiven the output traversal of this traversal, recover the tree and return its root.\n&nbsp;\nExample 1:\n\nInput: traversal = \"1-2--3--4-5--6--7\"\nOutput: [1,2,5,3,4,6,7]\n\nExample 2:\n\nInput: traversal = \"1-2--3---4-5--6---7\"\nOutput: [1,2,5,3,null,6,null,4,null,7]\n\nExample 3:\n\nInput: traversal = \"1-401--349---90--88\"\nOutput: [1,401,null,349,88,90]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the original tree is in the range [1, 1000].\n\t1 <= Node.val <= 109",
        "solutions": [
            {
                "id": 274621,
                "title": "java-c-python-iterative-stack-solution",
                "content": "## **Explanation**\\nWe save the construction path in a `stack`.\\nIn each loop,\\nwe get the number `level` of `\\'-\\'`\\nwe get the value `val` of `node` to add.\\n\\nIf the size of stack is bigger than the level of node,\\nwe pop the stack until it\\'s not.\\n\\nFinally we return the first element in the stack, as it\\'s root of our tree.\\n\\n## **Complexity**\\n\\nTime `O(S)`, Space `O(N)`\\n\\n\\n**Java**\\n```\\n    public TreeNode recoverFromPreorder(String S) {\\n        int level, val;\\n        Stack<TreeNode> stack = new Stack<>();\\n        for (int i = 0; i < S.length();) {\\n            for (level = 0; S.charAt(i) == \\'-\\'; i++) {\\n                level++;\\n            }\\n            for (val = 0; i < S.length() && S.charAt(i) != \\'-\\'; i++) {\\n                val = val * 10 + (S.charAt(i) - \\'0\\');\\n            }\\n            while (stack.size() > level) {\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                if (stack.peek().left == null) {\\n                    stack.peek().left = node;\\n                } else {\\n                    stack.peek().right = node;\\n                }\\n            }\\n            stack.add(node);\\n        }\\n        while (stack.size() > 1) {\\n            stack.pop();\\n        }\\n        return stack.pop();\\n    }\\n```\\n\\n**C++**\\n```\\n    TreeNode* recoverFromPreorder(string S) {\\n        vector<TreeNode*> stack;\\n        for (int i = 0, level, val; i < S.length();) {\\n            for (level = 0; S[i] == \\'-\\'; i++)\\n                level++;\\n            for (val = 0; i < S.length() && S[i] != \\'-\\'; i++)\\n                val = val * 10 + S[i] - \\'0\\';\\n            TreeNode* node = new TreeNode(val);\\n            while (stack.size() > level) stack.pop_back();\\n            if (!stack.empty())\\n                if (!stack.back()->left) stack.back()->left = node;\\n                else stack.back()->right = node;\\n            stack.push_back(node);\\n        }\\n        return stack[0];\\n    }\\n```\\n\\n**Python:**\\n```\\n    def recoverFromPreorder(self, S):\\n        stack, i = [], 0\\n        while i < len(S):\\n            level, val = 0, \"\"\\n            while i < len(S) and S[i] == \\'-\\':\\n                level, i = level + 1, i + 1\\n            while i < len(S) and S[i] != \\'-\\':\\n                val, i = val + S[i], i + 1\\n            while len(stack) > level:\\n                stack.pop()\\n            node = TreeNode(val)\\n            if stack and stack[-1].left is None:\\n                stack[-1].left = node\\n            elif stack:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        int level, val;\\n        Stack<TreeNode> stack = new Stack<>();\\n        for (int i = 0; i < S.length();) {\\n            for (level = 0; S.charAt(i) == \\'-\\'; i++) {\\n                level++;\\n            }\\n            for (val = 0; i < S.length() && S.charAt(i) != \\'-\\'; i++) {\\n                val = val * 10 + (S.charAt(i) - \\'0\\');\\n            }\\n            while (stack.size() > level) {\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                if (stack.peek().left == null) {\\n                    stack.peek().left = node;\\n                } else {\\n                    stack.peek().right = node;\\n                }\\n            }\\n            stack.add(node);\\n        }\\n        while (stack.size() > 1) {\\n            stack.pop();\\n        }\\n        return stack.pop();\\n    }\\n```\n```\\n    TreeNode* recoverFromPreorder(string S) {\\n        vector<TreeNode*> stack;\\n        for (int i = 0, level, val; i < S.length();) {\\n            for (level = 0; S[i] == \\'-\\'; i++)\\n                level++;\\n            for (val = 0; i < S.length() && S[i] != \\'-\\'; i++)\\n                val = val * 10 + S[i] - \\'0\\';\\n            TreeNode* node = new TreeNode(val);\\n            while (stack.size() > level) stack.pop_back();\\n            if (!stack.empty())\\n                if (!stack.back()->left) stack.back()->left = node;\\n                else stack.back()->right = node;\\n            stack.push_back(node);\\n        }\\n        return stack[0];\\n    }\\n```\n```\\n    def recoverFromPreorder(self, S):\\n        stack, i = [], 0\\n        while i < len(S):\\n            level, val = 0, \"\"\\n            while i < len(S) and S[i] == \\'-\\':\\n                level, i = level + 1, i + 1\\n            while i < len(S) and S[i] != \\'-\\':\\n                val, i = val + S[i], i + 1\\n            while len(stack) > level:\\n                stack.pop()\\n            node = TreeNode(val)\\n            if stack and stack[-1].left is None:\\n                stack[-1].left = node\\n            elif stack:\\n                stack[-1].right = node\\n            stack.append(node)\\n        return stack[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 276002,
                "title": "java-simple-inline-iterative-solution-with-hashmap",
                "content": "Count the dashes and the numbers as you iterate the string.\\n\\n```java\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        Map<Integer, TreeNode> levels = new HashMap<>();\\n        int i = 0;\\n        while(i < S.length()) {\\n            int curLevel = 0, curNum = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') {\\n                ++curLevel;\\n                ++i;\\n            }\\n            while(i < S.length() && S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\') {\\n                curNum = curNum*10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            TreeNode curNode = new TreeNode(curNum);\\n            levels.put(curLevel, curNode);\\n            if(curLevel > 0) {\\n                TreeNode parent = levels.get(curLevel - 1);\\n                if(parent.left == null) parent.left = curNode;\\n                else parent.right = curNode;\\n            }\\n        }\\n        return levels.get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        Map<Integer, TreeNode> levels = new HashMap<>();\\n        int i = 0;\\n        while(i < S.length()) {\\n            int curLevel = 0, curNum = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') {\\n                ++curLevel;\\n                ++i;\\n            }\\n            while(i < S.length() && S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\') {\\n                curNum = curNum*10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            TreeNode curNode = new TreeNode(curNum);\\n            levels.put(curLevel, curNode);\\n            if(curLevel > 0) {\\n                TreeNode parent = levels.get(curLevel - 1);\\n                if(parent.left == null) parent.left = curNode;\\n                else parent.right = curNode;\\n            }\\n        }\\n        return levels.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274656,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    int index = 0;\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 0);\\n    }\\n    \\n    public TreeNode helper(String s, int depth) {\\n        int numDash = 0;\\n        while (index + numDash < s.length() && s.charAt(index + numDash) == \\'-\\') {\\n            numDash++;\\n        }\\n        if (numDash != depth) return null;\\n        int next = index + numDash;\\n        while (next < s.length() && s.charAt(next) != \\'-\\') next++;\\n        int val = Integer.parseInt(s.substring(index + numDash, next));\\n        index = next;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(s, depth + 1);\\n        root.right = helper(s, depth + 1);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int index = 0;\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 0);\\n    }\\n    \\n    public TreeNode helper(String s, int depth) {\\n        int numDash = 0;\\n        while (index + numDash < s.length() && s.charAt(index + numDash) == \\'-\\') {\\n            numDash++;\\n        }\\n        if (numDash != depth) return null;\\n        int next = index + numDash;\\n        while (next < s.length() && s.charAt(next) != \\'-\\') next++;\\n        int val = Integer.parseInt(s.substring(index + numDash, next));\\n        index = next;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(s, depth + 1);\\n        root.right = helper(s, depth + 1);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274633,
                "title": "c-simple-recursive-preorder",
                "content": "Similar to solving `#331 Verify Preorder Serialization of a Binary Tree` and `#297 Serialize and Deserialize Binary Tree` and a few other similar questions.\\n\\nThe idea is pretty simple, at each depth make sure that the number of `\\'-\\'` is same as the depth, if it\\'s not return `NULL` else continue the recursive preorder traversal.\\n\\nIn general the preorder traversal through recursion is:\\n```c++\\nvoid preorder(Treenode* root)\\n{\\n\\tif(!root)\\n\\t{\\n\\t\\tcout<<\"NULL\";\\n\\t\\treturn;\\n\\t}\\n\\tcout<<root->val;\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n```\\n\\nWhat we are doing here is the same, just imagine the string is in form of a tree and make sure that the boundaries for print(case above)/set root->val(this case) or returning/printing NULL are set right (according to the question).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* recoverFromPreorder(string &S,int d)\\n    {\\n        int nextDigitPos=S.find_first_of(\"1234567890\",i);                          // Get index of the first number after i.\\n        if(nextDigitPos-i!=d)                                                      // If number of \\'-\\' in between != depth return NULL\\n            return NULL;\\n        int nextDashPos=S.find(\"-\",nextDigitPos);                                  // Get the index of the next \\'-\\'\\n        int rootValue=stoi(S.substr(nextDigitPos,nextDashPos-nextDigitPos));\\n        TreeNode* root=new TreeNode(rootValue);                                    // Create the root with the node\\'s value\\n        i=nextDashPos;                                                             // Move index forward for future recursions.\\n        root->left=recoverFromPreorder(S,d+1);                                     // Create left subtree\\n        root->right=recoverFromPreorder(S,d+1);                                    // Create right subtree\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string S)\\n    {\\n        return recoverFromPreorder(S,0);\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(h)` where `h` is the height of tree. This is due to recursion stack. Worst case this can be equal to number of nodes in the tree.\\nTime: `O(n)`. where `n` is the length of the string.\\n\\n**Note:**\\nThere is some extra time spent when the number of `-` in between is not equal to current `depth`. This is due to the next recursion again finding the position of the next digit in the first line for `nextDigitPos`. This can be avoided by moving it out as a global variable and only calculating it once. This would make it a true `O(n)` recursive solution. However the difference is negligible and hence I am not adding that solution.",
                "solutionTags": [],
                "code": "```c++\\nvoid preorder(Treenode* root)\\n{\\n\\tif(!root)\\n\\t{\\n\\t\\tcout<<\"NULL\";\\n\\t\\treturn;\\n\\t}\\n\\tcout<<root->val;\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int i=0;\\n    TreeNode* recoverFromPreorder(string &S,int d)\\n    {\\n        int nextDigitPos=S.find_first_of(\"1234567890\",i);                          // Get index of the first number after i.\\n        if(nextDigitPos-i!=d)                                                      // If number of \\'-\\' in between != depth return NULL\\n            return NULL;\\n        int nextDashPos=S.find(\"-\",nextDigitPos);                                  // Get the index of the next \\'-\\'\\n        int rootValue=stoi(S.substr(nextDigitPos,nextDashPos-nextDigitPos));\\n        TreeNode* root=new TreeNode(rootValue);                                    // Create the root with the node\\'s value\\n        i=nextDashPos;                                                             // Move index forward for future recursions.\\n        root->left=recoverFromPreorder(S,d+1);                                     // Create left subtree\\n        root->right=recoverFromPreorder(S,d+1);                                    // Create right subtree\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string S)\\n    {\\n        return recoverFromPreorder(S,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 274605,
                "title": "c-iterative-stack",
                "content": "1. Track the current level (count \\'-\\'s). Then get the value.\\n2. Create the current node using the value.\\n3. Remove elements from the stack until its size equals to the current level.\\n4. If the stack is not empty, make the current element the left (or right, if left is occupied) child of the node at the top.\\n5. Push the current node into the stack.\\n```\\nTreeNode* recoverFromPreorder(string S) {\\n  stack<TreeNode*> st;\\n  for (auto p = 0, len = 0, level = 0; p < S.size(); p += len) {\\n    level = 0, len = 0;\\n    while (S[p] == \\'-\\') ++level, ++p;\\n    while (p + len < S.size() && S[p + len] != \\'-\\') ++len;\\n    TreeNode* n = new TreeNode(stoi(S.substr(p, len)));\\n    while (st.size() > level) st.pop();\\n    if (!st.empty()) {\\n      if (st.top()->left == nullptr) st.top()->left = n;\\n      else st.top()->right = n;\\n    }\\n    st.push(n);\\n  }\\n  while (st.size() > 1) st.pop();\\n  return st.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder(string S) {\\n  stack<TreeNode*> st;\\n  for (auto p = 0, len = 0, level = 0; p < S.size(); p += len) {\\n    level = 0, len = 0;\\n    while (S[p] == \\'-\\') ++level, ++p;\\n    while (p + len < S.size() && S[p + len] != \\'-\\') ++len;\\n    TreeNode* n = new TreeNode(stoi(S.substr(p, len)));\\n    while (st.size() > level) st.pop();\\n    if (!st.empty()) {\\n      if (st.top()->left == nullptr) st.top()->left = n;\\n      else st.top()->right = n;\\n    }\\n    st.push(n);\\n  }\\n  while (st.size() > 1) st.pop();\\n  return st.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537706,
                "title": "c-short-easy-o-n-solution",
                "content": "The idea is simple: \\ngo through the string only once and each time when we reach a none root number (a node), it is the left or right child of the last appeared number (node) whose number of dashes is 1 less than the current one\\'s.\\n\\nuse a map with the key being the number of dashes of each node.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> mp;\\n        int cur = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'-\\') {\\n                cur += 1;\\n            }\\n            else {\\n                string num = \"\";\\n                while (i < S.size() && S[i] >= \\'0\\' && S[i] <= \\'9\\')\\n                    num += S[i++];\\n                i--;\\n                int cn = stoi(num);\\n                mp[cur] = new TreeNode(cn);\\n                if (cur)\\n                    if (mp[cur - 1]->left)\\n                        mp[cur - 1]->right = mp[cur];\\n                    else\\n                        mp[cur - 1]->left = mp[cur];\\n                cur = 0;\\n            }\\n        }\\n        return mp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> mp;\\n        int cur = 0;\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] == \\'-\\') {\\n                cur += 1;\\n            }\\n            else {\\n                string num = \"\";\\n                while (i < S.size() && S[i] >= \\'0\\' && S[i] <= \\'9\\')\\n                    num += S[i++];\\n                i--;\\n                int cn = stoi(num);\\n                mp[cur] = new TreeNode(cn);\\n                if (cur)\\n                    if (mp[cur - 1]->left)\\n                        mp[cur - 1]->right = mp[cur];\\n                    else\\n                        mp[cur - 1]->left = mp[cur];\\n                cur = 0;\\n            }\\n        }\\n        return mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274596,
                "title": "screencast-of-leetcode-weekly-contest-132",
                "content": "https://www.youtube.com/watch?v=ZYu2-7ovvw8\\n\\nWasted 4 mins debugging the last problem, and turns out I misread the test case...\\notherwise, I would have won this contest. sad...",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=ZYu2-7ovvw8\\n\\nWasted 4 mins debugging the last problem, and turns out I misread the test case...\\notherwise, I would have won this contest. sad...",
                "codeTag": "Unknown"
            },
            {
                "id": 274874,
                "title": "java-regex-solution",
                "content": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 1);\\n    }\\n    \\n    TreeNode helper(String S, int depth) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        String regex = \"(?<=\\\\\\\\d)[-]{\" + depth + \"}(?=\\\\\\\\d)\"; \\n        String[] s = S.split(regex);\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(s[0]));\\n        \\n        if (s.length > 1) {\\n            root.left = helper(s[1], depth+1);\\n        }\\n        if (s.length > 2) {\\n            root.right = helper(s[2], depth+1);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(S, 1);\\n    }\\n    \\n    TreeNode helper(String S, int depth) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        String regex = \"(?<=\\\\\\\\d)[-]{\" + depth + \"}(?=\\\\\\\\d)\"; \\n        String[] s = S.split(regex);\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(s[0]));\\n        \\n        if (s.length > 1) {\\n            root.left = helper(s[1], depth+1);\\n        }\\n        if (s.length > 2) {\\n            root.right = helper(s[2], depth+1);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282366,
                "title": "java-clean-code-list-solution",
                "content": "Less code, and easy to read.\\n\\n```\\n public TreeNode recoverFromPreorder(String S) {\\n        String[] tokens = S.split(\"-\");\\n        List<TreeNode> list = new ArrayList<>();\\n        \\n        list.add(new TreeNode(Integer.valueOf(tokens[0])));\\n        int level = 1;\\n        for(int i=1; i<tokens.length; i++){\\n        \\n            if(!tokens[i].isEmpty()){\\n                TreeNode node = new TreeNode(Integer.valueOf(tokens[i]));\\n                list.add(level, node);\\n                \\n                TreeNode parent = list.get(level-1);\\n                if(parent.left == null){\\n                    parent.left  = node;\\n                }else{\\n                    parent.right = node;\\n                }\\n                \\n                level = 1;\\n            }else{\\n                level++;\\n            }\\n        }\\n        \\n        return list.get(0);\\n    }",
                "solutionTags": [],
                "code": "Less code, and easy to read.\\n\\n```\\n public TreeNode recoverFromPreorder(String S) {\\n        String[] tokens = S.split(\"-\");\\n        List<TreeNode> list = new ArrayList<>();\\n        \\n        list.add(new TreeNode(Integer.valueOf(tokens[0])));\\n        int level = 1;\\n        for(int i=1; i<tokens.length; i++){\\n        \\n            if(!tokens[i].isEmpty()){\\n                TreeNode node = new TreeNode(Integer.valueOf(tokens[i]));\\n                list.add(level, node);\\n                \\n                TreeNode parent = list.get(level-1);\\n                if(parent.left == null){\\n                    parent.left  = node;\\n                }else{\\n                    parent.right = node;\\n                }\\n                \\n                level = 1;\\n            }else{\\n                level++;\\n            }\\n        }\\n        \\n        return list.get(0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1355318,
                "title": "o-n-dfs-easy-to-understand-8ms-faster-than-99",
                "content": "## Approach:\\n\\n##### We first count the level of the current node and check if it is equal to the current level our node is in using recursion. If it is, we add a new node and do the same for left and right otherwise, we return NULL.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int index;\\n    \\n    TreeNode* makeTree(string& pre, int level)\\n    {\\n        if(pre[index] == \\'\\\\0\\') return NULL;\\n        \\n        int currLevel = 0;\\n        \\n        while(pre[index + currLevel] == \\'-\\')\\n            currLevel++;\\n        \\n        if(currLevel == level)\\n        {\\n            index += currLevel;\\n            \\n            int currVal = 0;\\n            \\n            while(pre[index] >= \\'0\\' && pre[index] <= \\'9\\')\\n            {\\n                currVal = (10 * currVal) + (pre[index] - \\'0\\');\\n                index++;\\n            }\\n            \\n            TreeNode *root = new TreeNode(currVal);\\n            \\n            root->left = makeTree(pre, level + 1);\\n            root->right = makeTree(pre, level + 1);\\n            \\n            return root;\\n        }\\n        \\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) \\n    {\\n        index = 0;\\n        \\n        return makeTree(traversal, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int index;\\n    \\n    TreeNode* makeTree(string& pre, int level)\\n    {\\n        if(pre[index] == \\'\\\\0\\') return NULL;\\n        \\n        int currLevel = 0;\\n        \\n        while(pre[index + currLevel] == \\'-\\')\\n            currLevel++;\\n        \\n        if(currLevel == level)\\n        {\\n            index += currLevel;\\n            \\n            int currVal = 0;\\n            \\n            while(pre[index] >= \\'0\\' && pre[index] <= \\'9\\')\\n            {\\n                currVal = (10 * currVal) + (pre[index] - \\'0\\');\\n                index++;\\n            }\\n            \\n            TreeNode *root = new TreeNode(currVal);\\n            \\n            root->left = makeTree(pre, level + 1);\\n            root->right = makeTree(pre, level + 1);\\n            \\n            return root;\\n        }\\n        \\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) \\n    {\\n        index = 0;\\n        \\n        return makeTree(traversal, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293669,
                "title": "python-solution-with-dictionary-68ms-13-5mb",
                "content": "Track each last node seen at a given depth in a dictionary indexed by depth. \\n\\nCollisions are ok, because we will have processed the node and stored a pointer to it from our `head` by the time we get to the other subtree.\\n\\n# Time:\\n\\nO(n)\\n# Space:\\nO(h) space where h is the tree height. Best case: O (log n) Worst case: O(n)\\n\\n```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n        depth = 0\\n        dd = collections.defaultdict(TreeNode)\\n        head = TreeNode(-1)\\n        dd[-1] = head\\n        cur_num = \\'\\'        \\n        for i, c in enumerate(S):\\n            if c != \\'-\\':\\n                if (i < len(S)-1 and S[i+1] != \\'-\\'): \\n                    cur_num += c\\n                else:\\n                    prev = dd[depth-1]\\n                    cur = TreeNode(cur_num + c)\\n                    dd[depth] = cur\\n                    \\n                    if prev.left:\\n                        prev.right = cur\\n                    else:\\n                        prev.left = cur\\n\\n                    depth = 0\\n                    cur_num = \\'\\'\\n            else:\\n                depth += 1\\n            \\n        return head.left\\n```",
                "solutionTags": [],
                "code": "```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n        depth = 0\\n        dd = collections.defaultdict(TreeNode)\\n        head = TreeNode(-1)\\n        dd[-1] = head\\n        cur_num = \\'\\'        \\n        for i, c in enumerate(S):\\n            if c != \\'-\\':\\n                if (i < len(S)-1 and S[i+1] != \\'-\\'): \\n                    cur_num += c\\n                else:\\n                    prev = dd[depth-1]\\n                    cur = TreeNode(cur_num + c)\\n                    dd[depth] = cur\\n                    \\n                    if prev.left:\\n                        prev.right = cur\\n                    else:\\n                        prev.left = cur\\n\\n                    depth = 0\\n                    cur_num = \\'\\'\\n            else:\\n                depth += 1\\n            \\n        return head.left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3117894,
                "title": "c-o-n-non-recursive-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo points to notice here:\\n\\n1) In preorder traversal, parent is traversed before any node. Also lets say depth of the parent is d(p) and depth of the node is d(n).\\n2) During preorder traversal, if we are traversing any node at depth d(n), the last traversed node at depth d(p) will be the current node\\'s parent.\\n\\nSo solutions goes like this:\\n\\nTraverse the input string and keep track of last traversed nodes corresponding to depths.\\nWe can calculate the depth of the current node by counting the \\'-\\' in the input string before the value. (lets call it d).\\nThe current node\\'s parent will be at depth d-1.\\nAssign the parent.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nA map(m) is used to store last traversed Node pointer at depth d;\\n\\nTraverse the input string;\\nCalculate depth d of the current node;\\nCalculate value val of the current node;\\nCreate node;\\nGet the parent of the node, which is the last processed node at depth d-1.\\nAssign to the left/right of the parent.\\nMark the current node as last processed node at depth d. (ie. insert it into map at depth d).\\n\\nreturn the node at depth d=0;\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool isDigit(char c){\\n        return c>=\\'0\\'&&c<=\\'9\\';\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> m;\\n        \\n        int i = 0;\\n        while(i<traversal.size()){\\n            int d = 0;\\n            while(i<traversal.size() && traversal[i]==\\'-\\'){\\n                d++;\\n                i++;\\n            }\\n            string s = \"\";\\n            while(i<traversal.size() && isDigit(traversal[i])){\\n                s+= traversal[i];\\n                i++;\\n            }\\n            int val = stoi(s);\\n            TreeNode* node = new TreeNode(val);\\n            if(d>0){\\n                TreeNode* p = m[d-1];\\n                if(p->left==NULL){\\n                    p->left = node;\\n                }\\n                else{\\n                    p->right = node;\\n                }\\n            }\\n            m[d] = node;\\n        }\\n        \\n        return m[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    bool isDigit(char c){\\n        return c>=\\'0\\'&&c<=\\'9\\';\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> m;\\n        \\n        int i = 0;\\n        while(i<traversal.size()){\\n            int d = 0;\\n            while(i<traversal.size() && traversal[i]==\\'-\\'){\\n                d++;\\n                i++;\\n            }\\n            string s = \"\";\\n            while(i<traversal.size() && isDigit(traversal[i])){\\n                s+= traversal[i];\\n                i++;\\n            }\\n            int val = stoi(s);\\n            TreeNode* node = new TreeNode(val);\\n            if(d>0){\\n                TreeNode* p = m[d-1];\\n                if(p->left==NULL){\\n                    p->left = node;\\n                }\\n                else{\\n                    p->right = node;\\n                }\\n            }\\n            m[d] = node;\\n        }\\n        \\n        return m[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328780,
                "title": "8-line-python-recursion-40ms-beats-100",
                "content": "https://leetcode.com/submissions/detail/241310130/\\n\\n```\\nimport re\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nimport re\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276751,
                "title": "easy-recursive-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        self.index = 0\\n        def dfs(depth):\\n            if self.index == len(s):\\n                return\\n            for i in range(depth):\\n                if s[self.index+i] != \\'-\\':\\n                    return\\n            self.index += depth\\n            curr = 0\\n            while self.index < len(s) and s[self.index].isdigit():\\n                curr = curr * 10 + int(s[self.index])\\n                self.index += 1\\n            node = TreeNode(curr)\\n            node.left = dfs(depth+1)\\n            node.right = dfs(depth+1)\\n            return node\\n        return dfs(0)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        self.index = 0\\n        def dfs(depth):\\n            if self.index == len(s):\\n                return\\n            for i in range(depth):\\n                if s[self.index+i] != \\'-\\':\\n                    return\\n            self.index += depth\\n            curr = 0\\n            while self.index < len(s) and s[self.index].isdigit():\\n                curr = curr * 10 + int(s[self.index])\\n                self.index += 1\\n            node = TreeNode(curr)\\n            node.left = dfs(depth+1)\\n            node.right = dfs(depth+1)\\n            return node\\n        return dfs(0)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116747,
                "title": "javascript-dfs-solution-with-only-one-function",
                "content": "#### core concept \\nSplitting by the ```depth+1``` number of \"-\" in ```dfs``` and every layer in ```dfs``` only handles the depth+1 of \\'-\\' .\\nIt would split ```traversal``` into three part: ```[val , leftStr , rightStr]```\\nAnd using regex as separator.\\n\\n```  ex: \\'1-2--3--4-5--6--7\\' split by \\'-\\'  ==>  [\\'1\\',\\'2--3--4\\',\\'5--6--7\\'] ```\\n\\n(By using regex , we could ignore \\'--\\' when splitting by \\'-\\' )\\n\\n---\\n\\nHere comes the code.\\n\\n\\n```\\nvar recoverFromPreorder = function(traversal) {\\n    \\n    let n = traversal.length;\\n    \\n    // Every layer in dfs handles the depth+1 of \\'-\\' only.\\n    // ex: \\n    //   depth=0 -> find \\'-\\'  as splitter\\n    //   depth=1 -> find \\'--\\' as splitter\\n    //   depth=2 -> find \\'---\\' as splitter\\n    let dfs = (str,depth)=>{\\n        if(str.indexOf(\"-\") === -1) return new TreeNode(str);\\n\\t\\t\\n\\t\\t// 1. We split by the depth+1 number of \\'-\\'\\n        // Using regex to split is much easier. -> str.split(/(?<=\\\\d)-(?=\\\\d)/g)\\n\\t\\t// where (?<=\\\\d)  means positive lookbehind , ex: \"1- ...\", then we\\'ll split \\'-\\' excluding 1.\\n\\t\\t// Similarly , (?=\\\\d) means positive lookahead , ex: \"-5 ...\",  then we\\'ll split \\'-\\' excluding 5.\\n\\t\\t\\n        let re = new RegExp(`(?<=\\\\\\\\d)${\"-\".repeat(depth+1)}(?=\\\\\\\\d)`,\\'g\\');\\n        let [val,leftStr,rightStr] = str.split(re);\\n        // ex: 1-2--3--4-5--6--7 --> [\\'1\\',\\'2--3--4\\',\\'5--6--7\\']\\n        \\n\\t\\t// 2. After splitting,  we\\'ll get [val,leftStr,rightStr]\\n\\t\\t// Then we could handle left / right node in the next dfs layer intuitively.\\n        let node = new TreeNode(val);\\n        if(leftStr)  node.left  = dfs(leftStr,depth+1);\\n        if(rightStr) node.right = dfs(rightStr,depth+1);\\n        \\n        return node;\\n    };\\n    \\n    return dfs(traversal,0);\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```depth+1```\n```dfs```\n```dfs```\n```traversal```\n```[val , leftStr , rightStr]```\n```  ex: \\'1-2--3--4-5--6--7\\' split by \\'-\\'  ==>  [\\'1\\',\\'2--3--4\\',\\'5--6--7\\'] ```\n```\\nvar recoverFromPreorder = function(traversal) {\\n    \\n    let n = traversal.length;\\n    \\n    // Every layer in dfs handles the depth+1 of \\'-\\' only.\\n    // ex: \\n    //   depth=0 -> find \\'-\\'  as splitter\\n    //   depth=1 -> find \\'--\\' as splitter\\n    //   depth=2 -> find \\'---\\' as splitter\\n    let dfs = (str,depth)=>{\\n        if(str.indexOf(\"-\") === -1) return new TreeNode(str);\\n\\t\\t\\n\\t\\t// 1. We split by the depth+1 number of \\'-\\'\\n        // Using regex to split is much easier. -> str.split(/(?<=\\\\d)-(?=\\\\d)/g)\\n\\t\\t// where (?<=\\\\d)  means positive lookbehind , ex: \"1- ...\", then we\\'ll split \\'-\\' excluding 1.\\n\\t\\t// Similarly , (?=\\\\d) means positive lookahead , ex: \"-5 ...\",  then we\\'ll split \\'-\\' excluding 5.\\n\\t\\t\\n        let re = new RegExp(`(?<=\\\\\\\\d)${\"-\".repeat(depth+1)}(?=\\\\\\\\d)`,\\'g\\');\\n        let [val,leftStr,rightStr] = str.split(re);\\n        // ex: 1-2--3--4-5--6--7 --> [\\'1\\',\\'2--3--4\\',\\'5--6--7\\']\\n        \\n\\t\\t// 2. After splitting,  we\\'ll get [val,leftStr,rightStr]\\n\\t\\t// Then we could handle left / right node in the next dfs layer intuitively.\\n        let node = new TreeNode(val);\\n        if(leftStr)  node.left  = dfs(leftStr,depth+1);\\n        if(rightStr) node.right = dfs(rightStr,depth+1);\\n        \\n        return node;\\n    };\\n    \\n    return dfs(traversal,0);\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191195,
                "title": "c-100-fast-8ms",
                "content": "**Idea :** As mentioned in the description of the ques **\\'-\\'** represents depth of the node succeeding the **\\'-\\'**. This means if string is **1-2--3** This means 1 is root and 2 is let child of 1 and 3 is left child of 2  as mentioned in the description if there is only one  node at a level it is **left child**. So here I have made a **recursive solution** in line of preorder dfs traversal with the string and starting index being global variables. The idea of the function is to only pass the depth of the required node and then the function checks the required no. of dashes equal to depth , if yes then it creates a node and updates starting index and if no it returns NULL.\\n**Why starting index global?**\\nYou might come up with a question that why starting index is global as in the question it is mentioned that if there is a only child of a node it is compulsory to be left child so if a function discovers a node at a depth it is marked as left child of the parent first and then the starting index is updated as then when right child function is called it checks at the updated index and if found then mark the right child otherwise NULL so Starting index has to be global for correct marking.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    string s;\\n    TreeNode* solve(int depth)\\n    {\\n        if(s.length()<depth)\\n        {\\n            return NULL;\\n        }\\n        for(int i=ind;i<ind+depth;i++)\\n        {\\n                  if(s[i]!=\\'-\\')\\n                  {\\n                      return NULL;\\n                  }\\n        }\\n\\t\\t//This string is basically to store numeric value of the node ( as it can be any digit no.)\\n        string temp;\\n        int st=ind+depth;\\n        while(s[st]!=\\'-\\' && st<s.length())\\n        {\\n            temp+=s[st];\\n            st++;\\n        }\\n        int j= stoi(temp);\\n        TreeNode*root= new TreeNode(j);\\n        ind=st;\\n        root->left=solve(depth+1);\\n        root->right=solve(depth+1);\\n        return root;      \\n        \\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        TreeNode*root=solve(0);\\n        return root;\\n    }\\n};\\n\\n```\\n**I hope you liked my solution , Please Upvote!**\\n![image](https://assets.leetcode.com/users/images/f2f04366-10c8-402c-861b-4b34e5e4e81f_1620140225.0532122.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    string s;\\n    TreeNode* solve(int depth)\\n    {\\n        if(s.length()<depth)\\n        {\\n            return NULL;\\n        }\\n        for(int i=ind;i<ind+depth;i++)\\n        {\\n                  if(s[i]!=\\'-\\')\\n                  {\\n                      return NULL;\\n                  }\\n        }\\n\\t\\t//This string is basically to store numeric value of the node ( as it can be any digit no.)\\n        string temp;\\n        int st=ind+depth;\\n        while(s[st]!=\\'-\\' && st<s.length())\\n        {\\n            temp+=s[st];\\n            st++;\\n        }\\n        int j= stoi(temp);\\n        TreeNode*root= new TreeNode(j);\\n        ind=st;\\n        root->left=solve(depth+1);\\n        root->right=solve(depth+1);\\n        return root;      \\n        \\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        TreeNode*root=solve(0);\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376427,
                "title": "easy-to-understand-java-recursive-solution-with-explanation",
                "content": "/**\\nbased on this logic:\\n**1.**\\nat each level, we need split S based on the splitter on each level\\nat level 1, splitter is \"-\" (note: it is \"-\" only, not \"--\", not \"---\")\\nat level 2, splitter is \"--\"\\nat level 3, splitter is \"---\"\\nand so on\\nthe splitter is made of \"-\"s, and count of \"-\" equal to level\\n\\n**2.**\\nafter we find splitter, we need split our input S based on 3 cases:\\n   a. if no splitter found in S, the whole S used as value of node,  return node\\n   b. if only one splitter found, then we Split S as two parts, first part is node, second part is left child tree for node.\\n   c. if two splitter found, then we split S into 3 parts, first is for node, second part is for node.left, and third for node.right.\\n   \\n   \\n**3**\\nhow to find splitter for each level ( here is the key point for the logic )\\n    first we find the index of \"-\"(assume at index i), to make sure the \"-\" is the splitter, we need check value of S at index(i+level),\\n\\t\\ta. if it is not \"-\", we found the splitter.\\n\\t\\tb. if it is \"-\", that means it is for future level, we need skip all the next \"-\"s until a not \"-\" found, we need start   find splitter after it. \\n\\nfor example \\nS= \"1-2--3--4-5--6--7\"  \\nat level 1, splitter is \"-\", we found two, so separate it into 3 parts\\nnode: 1\\nnode.left:  S=\"2--3--4\" (recursive call with level = 2)\\nnode.right  S=\"5--6--7\" (recursive call with level = 2)\\nreturn node;\\nhow to find \"-\", first we find \"-\" at index of i (i=1), to make sure it is the splitter \"-\"\\nwe need check value at i + level (i=1, level=1), so we check S(2), it is not \"-\" but \"2\", so we find one splitter. to find second one, we continue search \"-\", found it at index j=3, but S(j+level) is \"-\", so we know it is not splitter, need increment j until S(j) is not \"-\", finally we\\'ll find another splitter at index 9,\\nso we S split into **1** ,      **2--3--4**   ,  **5--6--7**, please note we need remove the splitter itself when split S.\\n\\n\\n\\nfor recurse call level 2, splitter is \"--\"\\nin 2--3--4 we find two splitter \"--\"s, so split into 3 parts\\nnode: 2\\nnode.left: S=\"3\"  (recursive call with level = 3)\\nnode.right:S=\"4\" (recursive call with level = 3)\\nreturn node;\\n\\n...\\n\\n**/\\n```\\n\\n\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recoverTreeByLevel(S, 1);\\n\\n    }\\n\\n   private TreeNode recoverTreeByLevel(String S, int level) {\\n\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int leftIndex = -1;\\n        int rightIndex = -1;\\n\\t\\t//try to find first splitter \\n        for (int i = 1; i < S.length() - level; i++) {\\n            //we found left child if below condition evaluated to true;\\n            if (S.charAt(i) == \\'-\\' && S.charAt(i + level) != \\'-\\') {\\n                leftIndex = i;\\n                break;\\n            }\\n        }\\n        //if there is no left, just create a TreeNode and return; \\n        if (leftIndex == -1) {\\n            return new TreeNode(Integer.parseInt(S));\\n        }\\n \\n        //if we find left node, we create create the node, from substring from [0, i) of S.\\n        TreeNode node = new TreeNode(Integer.parseInt(S.substring(0, leftIndex)));\\n\\n        //we need skip the splitter of \\'-\\', which the count of level\\n        leftIndex += level;\\n       \\n\\t   //try to find the second splitter\\n        //then we need to check if we has right child node in S start from leftIndex\\n        for (int j = leftIndex; j < S.length() - level; j++) {\\n            //in below case, it means we have right child\\n            if (S.charAt(j) == \\'-\\') {\\n                if (S.charAt(j + level) != \\'-\\') {\\n                    rightIndex = j;\\n                    break;\\n                } else {\\n                    //below is to skip all those \\'-\\' which for levels greater than current level;\\n                    while(S.charAt(++j)==\\'-\\');\\n                }\\n            }\\n        }\\n\\n        //if no right child node find, we only use recursive call to build left child and return node\\n        if (rightIndex == -1) {\\n            node.left = recoverTreeByLevel(S.substring(leftIndex), level + 1);\\n            return node;\\n        }\\n\\n        \\n        //if we find both left and right, we need build both children and then return\\n        node.left = recoverTreeByLevel(S.substring(leftIndex, rightIndex), level + 1);\\n        node.right = recoverTreeByLevel(S.substring(rightIndex+level), level + 1);\\n        return node;\\n\\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recoverTreeByLevel(S, 1);\\n\\n    }\\n\\n   private TreeNode recoverTreeByLevel(String S, int level) {\\n\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int leftIndex = -1;\\n        int rightIndex = -1;\\n\\t\\t//try to find first splitter \\n        for (int i = 1; i < S.length() - level; i++) {\\n            //we found left child if below condition evaluated to true;\\n            if (S.charAt(i) == \\'-\\' && S.charAt(i + level) != \\'-\\') {\\n                leftIndex = i;\\n                break;\\n            }\\n        }\\n        //if there is no left, just create a TreeNode and return; \\n        if (leftIndex == -1) {\\n            return new TreeNode(Integer.parseInt(S));\\n        }\\n \\n        //if we find left node, we create create the node, from substring from [0, i) of S.\\n        TreeNode node = new TreeNode(Integer.parseInt(S.substring(0, leftIndex)));\\n\\n        //we need skip the splitter of \\'-\\', which the count of level\\n        leftIndex += level;\\n       \\n\\t   //try to find the second splitter\\n        //then we need to check if we has right child node in S start from leftIndex\\n        for (int j = leftIndex; j < S.length() - level; j++) {\\n            //in below case, it means we have right child\\n            if (S.charAt(j) == \\'-\\') {\\n                if (S.charAt(j + level) != \\'-\\') {\\n                    rightIndex = j;\\n                    break;\\n                } else {\\n                    //below is to skip all those \\'-\\' which for levels greater than current level;\\n                    while(S.charAt(++j)==\\'-\\');\\n                }\\n            }\\n        }\\n\\n        //if no right child node find, we only use recursive call to build left child and return node\\n        if (rightIndex == -1) {\\n            node.left = recoverTreeByLevel(S.substring(leftIndex), level + 1);\\n            return node;\\n        }\\n\\n        \\n        //if we find both left and right, we need build both children and then return\\n        node.left = recoverTreeByLevel(S.substring(leftIndex, rightIndex), level + 1);\\n        node.right = recoverTreeByLevel(S.substring(rightIndex+level), level + 1);\\n        return node;\\n\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532929,
                "title": "java-recursive-simple-and-short",
                "content": "```\\nclass Solution {\\n\\tint index = 0;\\n\\tpublic TreeNode recoverFromPreorder(String s) {\\n\\t\\treturn helper(s, 0);\\n\\t}\\n\\n\\tpublic TreeNode helper(String s, int depth) {\\n\\t\\tint temp = 0;\\n\\t\\twhile (index + temp < s.length() && s.charAt(index + temp) == \\'-\\') {\\n\\t\\t\\ttemp++;\\n\\t\\t}\\n\\t\\tif (temp != depth) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tint nd = 0;\\n\\t\\twhile (index + temp + nd < s.length() && s.charAt(index + temp + nd) != \\'-\\') {\\n\\t\\t\\tnd++;\\n\\t\\t}\\n\\t\\tint val = Integer.parseInt(s.substring(index + temp, index + temp + nd));\\n\\t\\tindex = index + temp + nd;\\n\\n\\t\\tTreeNode node = new TreeNode(val);\\n\\t\\tnode.left = helper(s, depth + 1);\\n\\t\\tnode.right = helper(s, depth + 1);\\n\\n\\t\\treturn node;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\tint index = 0;\\n\\tpublic TreeNode recoverFromPreorder(String s) {\\n\\t\\treturn helper(s, 0);\\n\\t}\\n\\n\\tpublic TreeNode helper(String s, int depth) {\\n\\t\\tint temp = 0;\\n\\t\\twhile (index + temp < s.length() && s.charAt(index + temp) == \\'-\\') {\\n\\t\\t\\ttemp++;\\n\\t\\t}\\n\\t\\tif (temp != depth) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tint nd = 0;\\n\\t\\twhile (index + temp + nd < s.length() && s.charAt(index + temp + nd) != \\'-\\') {\\n\\t\\t\\tnd++;\\n\\t\\t}\\n\\t\\tint val = Integer.parseInt(s.substring(index + temp, index + temp + nd));\\n\\t\\tindex = index + temp + nd;\\n\\n\\t\\tTreeNode node = new TreeNode(val);\\n\\t\\tnode.left = helper(s, depth + 1);\\n\\t\\tnode.right = helper(s, depth + 1);\\n\\n\\t\\treturn node;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430236,
                "title": "cpp-solution-using-map",
                "content": "**Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1019379,
                "title": "easy-stack-based-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    TreeNode* recoverFromPreorder(string S) \\n    {\\n        stack<TreeNode *>stk;\\n        int i=0;\\n        while(i<S.length())\\n        {\\n            int level=0;\\n            while(i<S.length() && S[i]==\\'-\\')\\n            {\\n                level++;\\n                i++;\\n            }\\n            if(i==S.length())\\n            {\\n                break;\\n            }\\n            int start=i;\\n            while(i<S.length() && S[i]!=\\'-\\')\\n            {\\n                i++;\\n            }\\n            int x=stoi(S.substr(start,i-start));\\n            TreeNode *tmp=new TreeNode(x);\\n            if(stk.empty())\\n            {\\n                stk.push(tmp);\\n                continue;\\n            }\\n            while(stk.size()>level)\\n            {\\n                stk.pop();\\n            }\\n            if(stk.top()->left)\\n            {\\n                stk.top()->right=tmp;\\n            }\\n            else\\n            {\\n                stk.top()->left=tmp;\\n            }\\n            stk.push(tmp);\\n        }\\n        while(stk.size()!=1)\\n        {\\n            stk.pop();\\n        }\\n        return stk.top();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    TreeNode* recoverFromPreorder(string S) \\n    {\\n        stack<TreeNode *>stk;\\n        int i=0;\\n        while(i<S.length())\\n        {\\n            int level=0;\\n            while(i<S.length() && S[i]==\\'-\\')\\n            {\\n                level++;\\n                i++;\\n            }\\n            if(i==S.length())\\n            {\\n                break;\\n            }\\n            int start=i;\\n            while(i<S.length() && S[i]!=\\'-\\')\\n            {\\n                i++;\\n            }\\n            int x=stoi(S.substr(start,i-start));\\n            TreeNode *tmp=new TreeNode(x);\\n            if(stk.empty())\\n            {\\n                stk.push(tmp);\\n                continue;\\n            }\\n            while(stk.size()>level)\\n            {\\n                stk.pop();\\n            }\\n            if(stk.top()->left)\\n            {\\n                stk.top()->right=tmp;\\n            }\\n            else\\n            {\\n                stk.top()->left=tmp;\\n            }\\n            stk.push(tmp);\\n        }\\n        while(stk.size()!=1)\\n        {\\n            stk.pop();\\n        }\\n        return stk.top();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786958,
                "title": "well-commented-and-explained-step-by-step-process-time-beats-94",
                "content": "### Our approach is:\\n1. find the depth of up comming node with the help of \\'-\\'\\n2. find the node val because node value can be of more than one digit\\n3. do iterative version of dfs:\\n\\t* \\tif our stack top node has depht 1 less then upcoming node then append the curr node to left of  top of node of stack because string has in-order based..\\n\\t* \\tnow the problem is *what if when we have depth of curr node greater than top of node of stack*,    In this condition we start poping all the node *(as we do dfs)* till the point where node at the top of stack has one difference with current upcoming node.. And we decide to append the currnode with the top of stack\\'s node on right side.... Because input is inorder and we have back track i.e. we have filled the left subtree for node which is at the top of stack and now turn comes for right subtree\\n\\nRest of process my commend will do:)\\n```\\nTreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```\\nPlease vote if it help you:)\\nHappy coding!!!",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476158,
                "title": "simple-java-recursive-solution-with-detailed-explanation-100-time",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private int index;      // index for chars\\n    private char[] chars;   // chars for string S\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        // initialize global values for a fresh run\\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    \\n    private void helper(int level, TreeNode parent) {\\n        // keep tracking next number of dashes\\n        int numOfDashes = getNumOfDashes();\\n        \\n        // as long as the number of dashes is directly 1 more than level, we append it as a direct child\\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;       // move index to next non-dash character\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            // \"If a node has only one child, that child is guaranteed to be the left child.\"\\n            // always first try to append new node to the left of parent node\\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            // recursively append children in the next level\\n            helper(level + 1, newNode);\\n            \\n            // see if there exist right child node\\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    \\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        // update index\\n        index = i;\\n        return count;\\n    }\\n    \\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    private int index;      // index for chars\\n    private char[] chars;   // chars for string S\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        // initialize global values for a fresh run\\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    \\n    private void helper(int level, TreeNode parent) {\\n        // keep tracking next number of dashes\\n        int numOfDashes = getNumOfDashes();\\n        \\n        // as long as the number of dashes is directly 1 more than level, we append it as a direct child\\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;       // move index to next non-dash character\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            // \"If a node has only one child, that child is guaranteed to be the left child.\"\\n            // always first try to append new node to the left of parent node\\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            // recursively append children in the next level\\n            helper(level + 1, newNode);\\n            \\n            // see if there exist right child node\\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    \\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        // update index\\n        index = i;\\n        return count;\\n    }\\n    \\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353177,
                "title": "c-simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* util(int &in, string s, int level) {\\n        if(in >= s.length())return NULL;\\n        int count=0;\\n        while(s[in+count] == \\'-\\'){count++;}\\n        \\n        if(count == level){\\n            in += count;\\n            \\n            long int val=0;\\n            while(isdigit(s[in])){\\n                val = 10*val + (s[in]-\\'0\\');\\n                in++;\\n            }\\n            \\n            TreeNode *node = new TreeNode(val);\\n            node->left = util(in,s,level+1);\\n            node->right = util(in,s,level+1);\\n            return node;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        int in=0,level=0;\\n        return util(in,S,level);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* util(int &in, string s, int level) {\\n        if(in >= s.length())return NULL;\\n        int count=0;\\n        while(s[in+count] == \\'-\\'){count++;}\\n        \\n        if(count == level){\\n            in += count;\\n            \\n            long int val=0;\\n            while(isdigit(s[in])){\\n                val = 10*val + (s[in]-\\'0\\');\\n                in++;\\n            }\\n            \\n            TreeNode *node = new TreeNode(val);\\n            node->left = util(in,s,level+1);\\n            node->right = util(in,s,level+1);\\n            return node;\\n        }\\n        return NULL;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        int in=0,level=0;\\n        return util(in,S,level);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352551,
                "title": "simple-and-easy-javascript-solution",
                "content": "I guess this problem is not so hard as seems. Just parse `S`, where a number of dashes is level (or depth). You know values and its levels (or depths) respectively. Then construct a tree iterating values and its levels (or depths). To find out the parent of some node use `nodeOnLevel` table (`par = nodeOnLevel[lev - 1]`)\\n```\\nconst levs = S.split(/\\\\d/).filter(s => s !== \\'\\').map(s => s.length)\\nconst nums = S.split(/-+/) \\n\\nconst root = new TreeNode(nums.shift())\\nconst nodeOnLevel = [root]\\n\\nlet i = 0\\n\\nwhile (i < nums.length) {\\n\\tconst val = nums[i]\\n\\tconst node = new TreeNode(val)\\n\\tconst lev = levs[i]\\n\\tconst par = nodeOnLevel[lev - 1]\\n\\n\\tif (!par.left) par.left = node\\n\\telse if (!par.right) par.right = node\\n\\n\\tnodeOnLevel[lev] = node\\n\\ti++\\n}\\n\\nreturn root\\n```",
                "solutionTags": [],
                "code": "```\\nconst levs = S.split(/\\\\d/).filter(s => s !== \\'\\').map(s => s.length)\\nconst nums = S.split(/-+/) \\n\\nconst root = new TreeNode(nums.shift())\\nconst nodeOnLevel = [root]\\n\\nlet i = 0\\n\\nwhile (i < nums.length) {\\n\\tconst val = nums[i]\\n\\tconst node = new TreeNode(val)\\n\\tconst lev = levs[i]\\n\\tconst par = nodeOnLevel[lev - 1]\\n\\n\\tif (!par.left) par.left = node\\n\\telse if (!par.right) par.right = node\\n\\n\\tnodeOnLevel[lev] = node\\n\\ti++\\n}\\n\\nreturn root\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2893500,
                "title": "c-solution-hasp-map-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince first node at a particular level will always be the left child of its parent element, we cannot have a tree that will have a ```NULL``` left subtree and a ```!NULL``` right subtree. So at a level, if we have a left child, we assign the current node to the right pointer of the parent, else to the left pointer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a hash map to store the last node added at any level. Then while iterating we, keep track of the current level ```d```. Then we use the map to find the parent element of this node from the map i.e ```mp[d-1]```, and assign the node to the parent\\'s right or left pointer accordingly.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        if(t.size()==0) return NULL;\\n        unordered_map<int,TreeNode*> mp;\\n        int num = 0, i = 0;\\n        int n = t.size();\\n        while(i<n && isdigit(t[i])){\\n            num = num*10 + (t[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        mp[0] = root;\\n        int d = 0;\\n        while(i<n){\\n            if(t[i]==\\'-\\'){\\n                d++;i++;\\n            }\\n            else{\\n                num = 0;\\n                while(i<n && isdigit(t[i])){\\n                    num = num*10 + (t[i]-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode* node = mp[d-1];\\n                if(!node->left){\\n                    node->left = new TreeNode(num);\\n                    mp[d]=node->left;\\n                }\\n                else{\\n                    node->right = new TreeNode(num);\\n                    mp[d]=node->right;\\n                }\\n                d=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```NULL```\n```!NULL```\n```d```\n```mp[d-1]```\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        if(t.size()==0) return NULL;\\n        unordered_map<int,TreeNode*> mp;\\n        int num = 0, i = 0;\\n        int n = t.size();\\n        while(i<n && isdigit(t[i])){\\n            num = num*10 + (t[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode* root = new TreeNode(num);\\n        mp[0] = root;\\n        int d = 0;\\n        while(i<n){\\n            if(t[i]==\\'-\\'){\\n                d++;i++;\\n            }\\n            else{\\n                num = 0;\\n                while(i<n && isdigit(t[i])){\\n                    num = num*10 + (t[i]-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode* node = mp[d-1];\\n                if(!node->left){\\n                    node->left = new TreeNode(num);\\n                    mp[d]=node->left;\\n                }\\n                else{\\n                    node->right = new TreeNode(num);\\n                    mp[d]=node->right;\\n                }\\n                d=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448129,
                "title": "short-easy-iterative-solution-using-hashmap-c-solution",
                "content": "```\\nTreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> node;\\n        node[-1] = new TreeNode(0);\\n        int dep = 0;\\n        int n = traversal.length();\\n        for(int i=0;i<n;){\\n            if(traversal[i]==\\'-\\'){\\n                dep = 0;\\n                while(traversal[i]==\\'-\\'){\\n                    dep++;i++;\\n                }\\n            }\\n            else{\\n                int val;\\n                string temp = \"\";\\n                while(i<n && traversal[i]!=\\'-\\'){\\n                    temp+=traversal[i];\\n                    i++;\\n                }\\n                val = stoi(temp);\\n                TreeNode* curr = new TreeNode(val);\\n                if(node[dep-1]->left)\\n                    node[dep-1]->right = curr;\\n                else \\n                    node[dep-1]->left = curr;\\n                node[dep] = curr;\\n            }\\n        }\\n        \\n        return node[-1]->left;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nTreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*> node;\\n        node[-1] = new TreeNode(0);\\n        int dep = 0;\\n        int n = traversal.length();\\n        for(int i=0;i<n;){\\n            if(traversal[i]==\\'-\\'){\\n                dep = 0;\\n                while(traversal[i]==\\'-\\'){\\n                    dep++;i++;\\n                }\\n            }\\n            else{\\n                int val;\\n                string temp = \"\";\\n                while(i<n && traversal[i]!=\\'-\\'){\\n                    temp+=traversal[i];\\n                    i++;\\n                }\\n                val = stoi(temp);\\n                TreeNode* curr = new TreeNode(val);\\n                if(node[dep-1]->left)\\n                    node[dep-1]->right = curr;\\n                else \\n                    node[dep-1]->left = curr;\\n                node[dep] = curr;\\n            }\\n        }\\n        \\n        return node[-1]->left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778322,
                "title": "c-with-intuition-and-commented-code",
                "content": "\\n**The Intuition**\\nIf we find the depth of a node, it must be 1 greater than its parent. So using this we can find out if a node is a child of the previous value or not. If a node has depth 1 greater than the previous value in the string, then it should be joined to the previous node else we must return NULL. Now, we can build the tree using the power of recursion.\\n\\n\\n\\n\\n\\n\\tclass Solution {\\n\\n\\t\\tint n;\\t\\t\\t//Length of string\\n\\n\\n\\t\\t//Returns the numerical digit of character digit\\n\\t\\tint char_int(char a){\\n\\t\\t\\treturn (a-\\'0\\');\\n\\t\\t}\\n\\n\\n\\t\\t//Finds the depth of the value with respect to the \\'-\\' present before it in the string\\n\\t\\tint count_depth(string &traversal,int str){\\n\\t\\t\\tint cnt=0;\\n\\n\\t\\t//Running the loop until we get any numeric digit\\n\\t\\t\\twhile(traversal[str]==\\'-\\'){str++;cnt++;}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\n\\t\\t//Returns the value of the node\\n\\t\\tint value(string& traversal,int &str){\\n\\t\\t\\tint val=0;\\n\\n\\t\\t//Running the loop until we get \\'-\\' or the end of string\\n\\t\\t\\twhile(str<n&&traversal[str]>=\\'0\\'&&traversal[str]<=\\'9\\')val=(val*10+char_int(traversal[str++]));\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\n\\n\\n\\t\\t/*We pass the string, the index pointer and the depth of the previous value in the string\\n\\t\\tWe are passing the index pointer by reference, as it would be helpful \\n\\t\\tin eliminating unnecessary syntax of increasing the index pointer, \\n\\t\\twhich may lead to some errors, which can be difficult to debug. */\\n\\t\\tTreeNode* gen_tree(string &traversal,int &str,int dep){\\n\\n\\t\\t\\tif(str>=n)return NULL;\\t// Returns NULL whenever the string is complete\\n\\n\\t\\t\\tint depth=count_depth(traversal,str);\\t\\t// Finding the depth of the node\\n\\n\\t\\t/*If the depth is not 1 greater than the depth of the previous value,\\n\\t\\tthen it cannot be a child of it, so we return NULL*/\\n\\t\\t\\tif(depth!=dep+1)return NULL;\\n\\n\\t\\t/* If it is a child of the previous value, then we are\\n\\t\\tjust increasing the pointer to the value portion of the string*/\\n\\t\\t\\tstr+=depth;\\n\\n\\n\\t\\t\\tTreeNode* root=new TreeNode(value(traversal,str));\\t//Creating the node using the value\\n\\n\\n\\n\\t\\t\\troot->left=gen_tree(traversal,str,depth);\\t//Calling the recursion for the left child\\n\\n\\n\\t\\t\\troot->right=gen_tree(traversal,str,depth);\\t//Calling the recursion for the right child\\n\\n\\t\\t\\treturn root;\\t//Returning the root\\n\\t\\t}\\n\\n\\t\\tpublic:\\n\\t\\tTreeNode* recoverFromPreorder(string traversal) {\\n\\t\\t\\tn=traversal.size();\\n\\t\\t\\tint str=0;\\n\\n\\t\\t/* We are passing the depth as -1, as the depth of the root is 0, \\n\\t\\tso it will upheld the parent-child depth relationship*/\\n\\t\\t\\treturn gen_tree(traversal,str,-1);\\t\\n\\t\\t}\\n\\t};\\n\\n\\nThanks for reading the blog. Any suggesstions will be highly appreciated\\uD83D\\uDE4F",
                "solutionTags": [
                    "Tree",
                    "Recursion",
                    "Interactive"
                ],
                "code": "class Solution {\\n\\n\\t\\tint n;\\t\\t\\t//Length of string\\n\\n\\n\\t\\t//Returns the numerical digit of character digit\\n\\t\\tint char_int(char a){\\n\\t\\t\\treturn (a-\\'0\\');\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1722014,
                "title": "c-easy-preorder-traversal-solution",
                "content": "```\\n#define l left\\n#define r right\\n#define null nullptr\\nclass Solution {\\npublic:\\n    vector<char> v;\\n    int i = 0;\\n    void solve(TreeNode* root,int pd, int& cd,int& x){\\n        if (i<v.size() && v[i]==\\'-\\'){\\n            if(x==-1){\\n                cd++;\\n                i++;\\n                solve(root,pd,cd,x);\\n            }else{\\n                i--;\\n            }\\n        }else if(i<v.size() && x==-1){\\n            x=v[i]-\\'0\\';\\n            i++;\\n            solve(root,pd,cd,x);\\n        }else if (i<v.size() && v[i-1]!=\\'-\\' && v[i]!=\\'-\\'){\\n            x=x*10+(v[i]-\\'0\\');\\n            i++;\\n            solve(root,pd,cd,x);\\n        }\\n        if(cd>pd){\\n            root->l= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->l,pd,cd,x);\\n        }else{\\n            return ;\\n        }\\n        if(cd==pd){\\n            root->r= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->r,pd,cd,x);\\n        }\\n        return ;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        for (auto j : traversal )\\n            v.push_back(j);\\n        TreeNode* root = new TreeNode();\\n        int x =0;\\n        while(i<v.size() && v[i]!=\\'-\\'){\\n            x=x*10 + (v[i]-\\'0\\');\\n            i++;\\n        }\\n        root->val=x;\\n        if(traversal.size()==1) return root;\\n        int d = 0;x=-1;\\n        solve(root,0,d,x);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define l left\\n#define r right\\n#define null nullptr\\nclass Solution {\\npublic:\\n    vector<char> v;\\n    int i = 0;\\n    void solve(TreeNode* root,int pd, int& cd,int& x){\\n        if (i<v.size() && v[i]==\\'-\\'){\\n            if(x==-1){\\n                cd++;\\n                i++;\\n                solve(root,pd,cd,x);\\n            }else{\\n                i--;\\n            }\\n        }else if(i<v.size() && x==-1){\\n            x=v[i]-\\'0\\';\\n            i++;\\n            solve(root,pd,cd,x);\\n        }else if (i<v.size() && v[i-1]!=\\'-\\' && v[i]!=\\'-\\'){\\n            x=x*10+(v[i]-\\'0\\');\\n            i++;\\n            solve(root,pd,cd,x);\\n        }\\n        if(cd>pd){\\n            root->l= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->l,pd,cd,x);\\n        }else{\\n            return ;\\n        }\\n        if(cd==pd){\\n            root->r= new TreeNode(x);\\n            x=-1;\\n            i++;\\n            pd=cd;\\n            cd=0;\\n            solve(root->r,pd,cd,x);\\n        }\\n        return ;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        for (auto j : traversal )\\n            v.push_back(j);\\n        TreeNode* root = new TreeNode();\\n        int x =0;\\n        while(i<v.size() && v[i]!=\\'-\\'){\\n            x=x*10 + (v[i]-\\'0\\');\\n            i++;\\n        }\\n        root->val=x;\\n        if(traversal.size()==1) return root;\\n        int d = 0;x=-1;\\n        solve(root,0,d,x);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664886,
                "title": "c-intuitive-solution",
                "content": "Follow the following steps:\\n1. Retrieve the depth of the node\\n2. Retrieve the value of the node\\n3. Save the node at depth using a hashmap\\n4. Check for the parent node and link the parent and child node together\\nHere\\'s the code, Happy Coding! \\uD83D\\uDE01\\n```\\nclass Solution {\\npublic:   \\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        unordered_map<int, TreeNode*>hash;        \\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            string temp = \"\";\\n            while(i < t.length() and !isdigit(t[i]))\\n            {\\n                temp += t[i];\\n                i++;\\n            }//Getting the dashes for depth    \\n            \\n            string curr_s = \"\";\\n            while(i < t.length() and isdigit(t[i]))\\n            {\\n                curr_s += t[i];\\n                i++;\\n            }//Getting the value of node          \\n            \\n            TreeNode *curr = new TreeNode(stoi(curr_s));\\n            hash[temp.length()] = curr;//Saving the node with depth\\n            \\n            if(hash.find(temp.length() - 1) != hash.end())\\n            {                \\n                TreeNode *parent = hash[temp.length() - 1];\\n                if(parent -> left == NULL)\\n                    parent -> left = curr;\\n                else\\n                    parent -> right = curr;\\n            }//Finding parent and linking the child\\n            i--;\\n        }\\n        return hash[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        unordered_map<int, TreeNode*>hash;        \\n        for(int i = 0; i < t.length(); i++)\\n        {\\n            string temp = \"\";\\n            while(i < t.length() and !isdigit(t[i]))\\n            {\\n                temp += t[i];\\n                i++;\\n            }//Getting the dashes for depth    \\n            \\n            string curr_s = \"\";\\n            while(i < t.length() and isdigit(t[i]))\\n            {\\n                curr_s += t[i];\\n                i++;\\n            }//Getting the value of node          \\n            \\n            TreeNode *curr = new TreeNode(stoi(curr_s));\\n            hash[temp.length()] = curr;//Saving the node with depth\\n            \\n            if(hash.find(temp.length() - 1) != hash.end())\\n            {                \\n                TreeNode *parent = hash[temp.length() - 1];\\n                if(parent -> left == NULL)\\n                    parent -> left = curr;\\n                else\\n                    parent -> right = curr;\\n            }//Finding parent and linking the child\\n            i--;\\n        }\\n        return hash[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441088,
                "title": "java-recursion-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(1, traversal);\\n    }\\n    \\n    private TreeNode helper(int level, String str){\\n        int i = 0;\\n        while(i < str.length() && str.charAt(i) != \\'-\\')\\n            i++;\\n        TreeNode root = new TreeNode(Integer.parseInt(str.substring(0, i)));\\n        if(i < str.length()){\\n            String rem = str.substring(i + level);\\n            int j = getidx(rem, level);\\n            if(j != -1){\\n                root.left = helper(level + 1, rem.substring(0, j));\\n                root.right = helper(level + 1, rem.substring(j + level));\\n            } else\\n                root.left = helper(level + 1, rem);\\n        }\\n        return root;\\n    }\\n    \\n    private int getidx(String str, int dash){\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str.charAt(i) == \\'-\\')\\n                count++;\\n            else{\\n                if(count == dash)\\n                    return i - dash;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(1, traversal);\\n    }\\n    \\n    private TreeNode helper(int level, String str){\\n        int i = 0;\\n        while(i < str.length() && str.charAt(i) != \\'-\\')\\n            i++;\\n        TreeNode root = new TreeNode(Integer.parseInt(str.substring(0, i)));\\n        if(i < str.length()){\\n            String rem = str.substring(i + level);\\n            int j = getidx(rem, level);\\n            if(j != -1){\\n                root.left = helper(level + 1, rem.substring(0, j));\\n                root.right = helper(level + 1, rem.substring(j + level));\\n            } else\\n                root.left = helper(level + 1, rem);\\n        }\\n        return root;\\n    }\\n    \\n    private int getidx(String str, int dash){\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str.charAt(i) == \\'-\\')\\n                count++;\\n            else{\\n                if(count == dash)\\n                    return i - dash;\\n                count = 0;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351559,
                "title": "c-simple-approach-easy-to-understand",
                "content": "We are storing the number of levels to help us understand the relation between nodes better and the value starting point and end point to insert the whole value in the stack.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack <TreeNode*> s;\\n        for (int i = 0; i < traversal.length();){\\n            int level = 0;\\n            while(traversal[i] == \\'-\\')\\n                level++, i++;\\n            int strt = i;\\n            while(isdigit(traversal[i]))\\n                i++;\\n            int val = stoi(traversal.substr(strt, i - strt + 1));\\n            TreeNode* result = new TreeNode(val);\\n            if (s.empty())    \\n                {s.emplace(result); continue;}\\n            while(s.size() > level) \\n                s.pop();\\n            if (s.top()->left)  \\n                s.top()->right = result;\\n            else \\n                s.top()->left = result;\\n            s.emplace(result);\\n        }\\n        while(s.size() > 1)\\n            s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack <TreeNode*> s;\\n        for (int i = 0; i < traversal.length();){\\n            int level = 0;\\n            while(traversal[i] == \\'-\\')\\n                level++, i++;\\n            int strt = i;\\n            while(isdigit(traversal[i]))\\n                i++;\\n            int val = stoi(traversal.substr(strt, i - strt + 1));\\n            TreeNode* result = new TreeNode(val);\\n            if (s.empty())    \\n                {s.emplace(result); continue;}\\n            while(s.size() > level) \\n                s.pop();\\n            if (s.top()->left)  \\n                s.top()->right = result;\\n            else \\n                s.top()->left = result;\\n            s.emplace(result);\\n        }\\n        while(s.size() > 1)\\n            s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179506,
                "title": "python3-stack",
                "content": "\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        stack = []\\n        depth, val = 0, \"\"\\n        for i, x in enumerate(S): \\n            if x == \"-\": \\n                depth += 1\\n                val = \"\"\\n            else: \\n                val += S[i]\\n                if i+1 == len(S) or S[i+1] == \"-\": \\n                    node = TreeNode(int(val))\\n                    while len(stack) > depth: stack.pop()\\n                    if stack:\\n                        if not stack[-1].left: stack[-1].left = node\\n                        else: stack[-1].right = node\\n                    stack.append(node)\\n                    depth = 0\\n        return stack[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        stack = []\\n        depth, val = 0, \"\"\\n        for i, x in enumerate(S): \\n            if x == \"-\": \\n                depth += 1\\n                val = \"\"\\n            else: \\n                val += S[i]\\n                if i+1 == len(S) or S[i+1] == \"-\": \\n                    node = TreeNode(int(val))\\n                    while len(stack) > depth: stack.pop()\\n                    if stack:\\n                        if not stack[-1].left: stack[-1].left = node\\n                        else: stack[-1].right = node\\n                    stack.append(node)\\n                    depth = 0\\n        return stack[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415217,
                "title": "python-recursion-solution-beat-99-31",
                "content": "This solution beats 99.31% of python3 submission.\\nI find result of S.split(\\'-\\') is a horrible thing. So I change something to make it work.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        for i in range(30, -1, -1):\\n            if S.find(\\'-\\' * i) != 0:\\n                S = S.replace(\\'-\\' * i, chr(i + 65))\\n        \\n        def helper(s, depth):\\n            tmp = s.split(chr(depth + 65))\\n            root = TreeNode(tmp[0])\\n            root.left = helper(tmp[1], depth+1) if len(tmp) > 1 else None\\n            root.right = helper(tmp[2], depth+1) if len(tmp) > 2 else None\\n            return root\\n        \\n        return helper(S, 1)\\n```\\nor iteration is better ~ But use more space.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if not S: return\\n        l = S.split(\\'-\\')\\n        s, depth = [[TreeNode(l[0]), 0]], 1\\n        for item in l[1:]:\\n            if not item:\\n                depth += 1\\n                continue\\n            node = TreeNode(item)\\n            while s[-1][1] != depth - 1:\\n                s.pop()\\n            if not s[-1][0].left: \\n                s[-1][0].left = node\\n            else:\\n                s[-1][0].right = node\\n            s.append([node, depth])\\n            depth = 1\\n        return s[0][0]\\n```\\nIf you don\\'t like my solution, maybe his is more suitable for you.\\n[[Python] Beat 98.86%, 64ms, O(N) time](https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/discuss/275367/Python-Beat-98.86-64ms-O(N)-time)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        for i in range(30, -1, -1):\\n            if S.find(\\'-\\' * i) != 0:\\n                S = S.replace(\\'-\\' * i, chr(i + 65))\\n        \\n        def helper(s, depth):\\n            tmp = s.split(chr(depth + 65))\\n            root = TreeNode(tmp[0])\\n            root.left = helper(tmp[1], depth+1) if len(tmp) > 1 else None\\n            root.right = helper(tmp[2], depth+1) if len(tmp) > 2 else None\\n            return root\\n        \\n        return helper(S, 1)\\n```\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if not S: return\\n        l = S.split(\\'-\\')\\n        s, depth = [[TreeNode(l[0]), 0]], 1\\n        for item in l[1:]:\\n            if not item:\\n                depth += 1\\n                continue\\n            node = TreeNode(item)\\n            while s[-1][1] != depth - 1:\\n                s.pop()\\n            if not s[-1][0].left: \\n                s[-1][0].left = node\\n            else:\\n                s[-1][0].right = node\\n            s.append([node, depth])\\n            depth = 1\\n        return s[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323636,
                "title": "simple-java-solution-beating-92-in-speed-and-memory",
                "content": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        if(S == null || S.isEmpty())\\n            return null;\\n        \\n        int[] index = new int[1];\\n        index[0] = 0;\\n        \\n        return recoverMyTree(S, index, 0);\\n        \\n    }\\n    \\n    public TreeNode recoverMyTree(String S, int[] index, int depth)   {\\n        \\n        if(index[0] >= S.length())\\n            return null;\\n        \\n        //check if number of dashes are equal to depth\\n        \\n        int count = 0;\\n        for(int i = index[0]; i < S.length() && S.charAt(i) == \\'-\\'; i++)\\n            count++;\\n        \\n        TreeNode node = null;\\n        \\n        if(count == depth)  {\\n            index[0] += count;\\n            node = new TreeNode(getNumber(S, index));\\n            \\n            \\n            node.left = recoverMyTree(S, index, depth + 1);\\n            node.right = recoverMyTree(S, index, depth + 1);\\n        }\\n        \\n        return node;\\n        \\n    }\\n    \\n    public int getNumber(String S, int[] index) {\\n        \\n        int i = index[0];\\n        \\n        int number = 0;\\n        int mult = 10;\\n        \\n        while(index[0] < S.length() && S.charAt(index[0]) != \\'-\\') {\\n            \\n            number = (number*mult) + Character.getNumericValue(S.charAt(index[0]));\\n            index[0]++;\\n        }\\n        \\n        return number;\\n    }\\n    \\n}```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        if(S == null || S.isEmpty())\\n            return null;\\n        \\n        int[] index = new int[1];\\n        index[0] = 0;\\n        \\n        return recoverMyTree(S, index, 0);\\n        \\n    }\\n    \\n    public TreeNode recoverMyTree(String S, int[] index, int depth)   {\\n        \\n        if(index[0] >= S.length())\\n            return null;\\n        \\n        //check if number of dashes are equal to depth\\n        \\n        int count = 0;\\n        for(int i = index[0]; i < S.length() && S.charAt(i) == \\'-\\'; i++)\\n            count++;\\n        \\n        TreeNode node = null;\\n        \\n        if(count == depth)  {\\n            index[0] += count;\\n            node = new TreeNode(getNumber(S, index));\\n            \\n            \\n            node.left = recoverMyTree(S, index, depth + 1);\\n            node.right = recoverMyTree(S, index, depth + 1);\\n        }\\n        \\n        return node;\\n        \\n    }\\n    \\n    public int getNumber(String S, int[] index) {\\n        \\n        int i = index[0];\\n        \\n        int number = 0;\\n        int mult = 10;\\n        \\n        while(index[0] < S.length() && S.charAt(index[0]) != \\'-\\') {\\n            \\n            number = (number*mult) + Character.getNumericValue(S.charAt(index[0]));\\n            index[0]++;\\n        }\\n        \\n        return number;\\n    }\\n    \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 302415,
                "title": "java-map-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S == null || S.length() == 0) return null;\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        int end = 0;\\n        while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n        TreeNode root = new TreeNode(Integer.valueOf(S.substring(0,end)));\\n        map.put(1, root);\\n        while(end< S.length()) {\\n            int prev = end;\\n            while(S.charAt(end) == \\'-\\') end++;\\n            int level = end - prev;\\n            TreeNode parent = map.get(level);\\n            prev = end;\\n            while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n            TreeNode child = new TreeNode(Integer.valueOf(S.substring(prev,end)));\\n            if(parent.left == null) parent.left = child;\\n            else parent.right = child;\\n            map.put(level+1,child);\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S == null || S.length() == 0) return null;\\n        Map<Integer, TreeNode> map = new HashMap<>();\\n        int end = 0;\\n        while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n        TreeNode root = new TreeNode(Integer.valueOf(S.substring(0,end)));\\n        map.put(1, root);\\n        while(end< S.length()) {\\n            int prev = end;\\n            while(S.charAt(end) == \\'-\\') end++;\\n            int level = end - prev;\\n            TreeNode parent = map.get(level);\\n            prev = end;\\n            while(end < S.length() && S.charAt(end) != \\'-\\') end++;\\n            TreeNode child = new TreeNode(Integer.valueOf(S.substring(prev,end)));\\n            if(parent.left == null) parent.left = child;\\n            else parent.right = child;\\n            map.put(level+1,child);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3282474,
                "title": "java-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return traverse(traversal,0);\\n    }\\n    public TreeNode traverse(String traversal,int level)\\n    {\\n        if(i==traversal.length())return null;\\n        int j=i,c=0;\\n        while(traversal.charAt(j)==\\'-\\')\\n        {\\n            c+=1;\\n            j+=1;\\n        }\\n        if(c==level)\\n        {\\n            int k=j;\\n            while(j<traversal.length() && traversal.charAt(j)!=\\'-\\')j+=1;\\n            String sub=traversal.substring(k,j);\\n            i=j;\\n            TreeNode root=new TreeNode(Integer.parseInt(sub));\\n            root.left=traverse(traversal,level+1);\\n            root.right=traverse(traversal,level+1);\\n            return root;\\n        }\\n        else return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return traverse(traversal,0);\\n    }\\n    public TreeNode traverse(String traversal,int level)\\n    {\\n        if(i==traversal.length())return null;\\n        int j=i,c=0;\\n        while(traversal.charAt(j)==\\'-\\')\\n        {\\n            c+=1;\\n            j+=1;\\n        }\\n        if(c==level)\\n        {\\n            int k=j;\\n            while(j<traversal.length() && traversal.charAt(j)!=\\'-\\')j+=1;\\n            String sub=traversal.substring(k,j);\\n            i=j;\\n            TreeNode root=new TreeNode(Integer.parseInt(sub));\\n            root.left=traverse(traversal,level+1);\\n            root.right=traverse(traversal,level+1);\\n            return root;\\n        }\\n        else return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355265,
                "title": "c-simple-iterative-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the index of \\'-\\' if present otherwise returns the string length\\n    int findIndex(int ind, string &traversal){\\n        int req = traversal.size();\\n        for(int i=ind; i<traversal.size(); i++){\\n            if(traversal[i] == \\'-\\'){\\n                req = i;\\n                break;\\n            }\\n        }\\n        return req;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        // Pushing the node along with its depth into the stack\\n        int depth = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        \\n\\t\\t// Finding the root node\\n        int ind = findIndex(0, traversal);\\n        string str = traversal.substr(0, ind);\\n        TreeNode *root = new TreeNode(stoi(str));\\n        \\n\\t\\t// Pushing the root node along with its depth\\n        st.push({root, 0});\\n\\t\\t\\n\\t\\t// Starting from \\'ind\\' as it has the next \\'-\\' character\\n        int i = ind;\\n        \\n        while(i<traversal.size()){\\n\\t\\t\\t// Increment the depth\\n            if(traversal[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n                continue;\\n            }\\n            \\n            // Find the complete number as no.of digits can be > 1\\n            int ind = findIndex(i, traversal);\\n            string str = traversal.substr(i, ind-i);\\n            TreeNode *node = new TreeNode(stoi(str));\\n            \\n            // Finding its appropriate parent, whose depth is one less than current depth\\n            while(!st.empty() && st.top().second != depth-1){\\n                st.pop();\\n            }\\n            \\n            // There is already left child for the parent\\n            if(st.top().first->left){\\n                st.top().first->right = node;\\n            }\\n            else{\\n                st.top().first->left = node;\\n            }\\n            \\n            // Pushing that node and its depth into stack\\n            st.push({node, depth});\\n            depth = 0;\\n            i = ind;\\n        }\\n    \\n        return root;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Returns the index of \\'-\\' if present otherwise returns the string length\\n    int findIndex(int ind, string &traversal){\\n        int req = traversal.size();\\n        for(int i=ind; i<traversal.size(); i++){\\n            if(traversal[i] == \\'-\\'){\\n                req = i;\\n                break;\\n            }\\n        }\\n        return req;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        // Pushing the node along with its depth into the stack\\n        int depth = 0;\\n        stack<pair<TreeNode*,int>> st;\\n        \\n\\t\\t// Finding the root node\\n        int ind = findIndex(0, traversal);\\n        string str = traversal.substr(0, ind);\\n        TreeNode *root = new TreeNode(stoi(str));\\n        \\n\\t\\t// Pushing the root node along with its depth\\n        st.push({root, 0});\\n\\t\\t\\n\\t\\t// Starting from \\'ind\\' as it has the next \\'-\\' character\\n        int i = ind;\\n        \\n        while(i<traversal.size()){\\n\\t\\t\\t// Increment the depth\\n            if(traversal[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n                continue;\\n            }\\n            \\n            // Find the complete number as no.of digits can be > 1\\n            int ind = findIndex(i, traversal);\\n            string str = traversal.substr(i, ind-i);\\n            TreeNode *node = new TreeNode(stoi(str));\\n            \\n            // Finding its appropriate parent, whose depth is one less than current depth\\n            while(!st.empty() && st.top().second != depth-1){\\n                st.pop();\\n            }\\n            \\n            // There is already left child for the parent\\n            if(st.top().first->left){\\n                st.top().first->right = node;\\n            }\\n            else{\\n                st.top().first->left = node;\\n            }\\n            \\n            // Pushing that node and its depth into stack\\n            st.push({node, depth});\\n            depth = 0;\\n            i = ind;\\n        }\\n    \\n        return root;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336413,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(!traversal.contains(\"-\"))\\n            return new TreeNode(Integer.parseInt(traversal));\\n        String number = \"\";\\n        int i = 0;\\n        while(traversal.charAt(i)!=\\'-\\'){\\n            number+=traversal.charAt(i);\\n            i++;\\n        }\\n        //System.out.print(\"root = \" + number + \" \" + i + \"     \");\\n        TreeNode root = new TreeNode(Integer.parseInt(number));\\n        StringBuilder str = new StringBuilder();\\n        int bk = 0;\\n        for(int j = i; i < traversal.length(); i++){\\n            if(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\' && traversal.charAt(i+1) != \\'-\\')\\n                bk = str.toString().length();\\n            else if(!(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\'))\\n                str.append(traversal.charAt(i));\\n        }\\n        String divide = str.toString();\\n        \\n        TreeNode left = (bk==0)?recoverFromPreorder(divide):recoverFromPreorder(divide.substring(0,bk));\\n        TreeNode right = (bk==0)?null:recoverFromPreorder(divide.substring(bk,divide.length()));\\n        root.left = left;\\n        root.right = right;\\n            \\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(!traversal.contains(\"-\"))\\n            return new TreeNode(Integer.parseInt(traversal));\\n        String number = \"\";\\n        int i = 0;\\n        while(traversal.charAt(i)!=\\'-\\'){\\n            number+=traversal.charAt(i);\\n            i++;\\n        }\\n        //System.out.print(\"root = \" + number + \" \" + i + \"     \");\\n        TreeNode root = new TreeNode(Integer.parseInt(number));\\n        StringBuilder str = new StringBuilder();\\n        int bk = 0;\\n        for(int j = i; i < traversal.length(); i++){\\n            if(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\' && traversal.charAt(i+1) != \\'-\\')\\n                bk = str.toString().length();\\n            else if(!(traversal.charAt(i-1) != \\'-\\' && traversal.charAt(i) == \\'-\\'))\\n                str.append(traversal.charAt(i));\\n        }\\n        String divide = str.toString();\\n        \\n        TreeNode left = (bk==0)?recoverFromPreorder(divide):recoverFromPreorder(divide.substring(0,bk));\\n        TreeNode right = (bk==0)?null:recoverFromPreorder(divide.substring(bk,divide.length()));\\n        root.left = left;\\n        root.right = right;\\n            \\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900554,
                "title": "cpp-easy-to-understand",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint ix = 0;\\n\\t\\tTreeNode* help(string t, int pnthgt){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile(ix < t.size() && isdigit(t[ix])){\\n\\t\\t\\t\\tval = val*10 + t[ix]-\\'0\\';\\n\\t\\t\\t\\tix = ix+1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(val == 0)return nullptr;\\n\\t\\t\\tTreeNode* root = new TreeNode(val);\\n\\t\\t\\tstring str;\\n\\t\\t\\tstr.append(pnthgt+1, \\'-\\');\\n\\t\\t\\tif(str == t.substr(ix, pnthgt+1)){\\n\\t\\t\\t\\tix = ix + pnthgt + 1;\\n\\t\\t\\t\\troot->left = help(t, pnthgt+1);\\n\\t\\t\\t}\\n\\t\\t\\telse return root;\\n\\n\\t\\t\\tif(str == t.substr(ix, pnthgt+1)){\\n\\t\\t\\t\\tix = ix + pnthgt + 1;\\n\\t\\t\\t\\troot->right = help(t, pnthgt+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn root;\\n\\n\\t\\t}\\n\\t\\tTreeNode* recoverFromPreorder(string t) {\\n\\t\\t\\tint ix = 0;\\n\\t\\t\\treturn help(t, 0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint ix = 0;\\n\\t\\tTreeNode* help(string t, int pnthgt){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile(ix < t.size() && isdigit(t[ix])){\\n\\t\\t\\t\\tval = val*10 + t[ix]-\\'0\\';\\n\\t\\t\\t\\tix = ix+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1800427,
                "title": "java-easy-clean-and-detailed-recursive-solution",
                "content": "```\\nclass Solution {\\n    int ptr = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return find(traversal, 0);\\n    }\\n    \\n    public TreeNode find(String traversal, int level){\\n        if(ptr == traversal.length())\\n            return null;\\n        int i = ptr;\\n        int count = 0;\\n        while(traversal.charAt(i) == \\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count == level){\\n            int start = i;\\n            while(i < traversal.length() && traversal.charAt(i) != \\'-\\')\\n                i++;\\n            int val = Integer.parseInt(traversal.substring(start, i));\\n            ptr = i;\\n            TreeNode root = new TreeNode(val);\\n            root.left = find(traversal, level + 1);\\n            root.right = find(traversal, level + 1);\\n            return root;\\n        }else\\n            return null;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ptr = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return find(traversal, 0);\\n    }\\n    \\n    public TreeNode find(String traversal, int level){\\n        if(ptr == traversal.length())\\n            return null;\\n        int i = ptr;\\n        int count = 0;\\n        while(traversal.charAt(i) == \\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count == level){\\n            int start = i;\\n            while(i < traversal.length() && traversal.charAt(i) != \\'-\\')\\n                i++;\\n            int val = Integer.parseInt(traversal.substring(start, i));\\n            ptr = i;\\n            TreeNode root = new TreeNode(val);\\n            root.left = find(traversal, level + 1);\\n            root.right = find(traversal, level + 1);\\n            return root;\\n        }else\\n            return null;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922334,
                "title": "java-build-tree-recursively-with-photo-and-comments",
                "content": "![image](https://assets.leetcode.com/users/images/4a27bdc3-8224-4aeb-ab48-97f699c2aad2_1604429624.6136794.png)\\n```java\\n    public TreeNode recoverFromPreorder(String s) {\\n        final char[] chars = s.toCharArray();\\n        return build(chars, 0, chars.length - 1, 1);\\n    }\\n\\n    private TreeNode build(char[] chars, int start, int end, int level) {\\n        if (start > end) {\\n            return null;\\n        }\\n        // convert chars to integer, take example of \"405 - - 1 - - 22\", the first int is 405, NOT 4\\n        final StringBuilder stringBuilder = new StringBuilder();\\n        while (start <= end && chars[start] != \\'-\\') {\\n            stringBuilder.append(chars[start]);\\n            start++;\\n        }\\n        // root of node\\n        final TreeNode root = new TreeNode(Integer.parseInt(stringBuilder.toString()));\\n        if (start == end) {\\n            return root;\\n        }\\n        // calculate left start\\n        final int leftStart = start + level;\\n        int interval = 0;\\n        int rightStart = leftStart + 1;\\n        // calculate right start, if exists one, it must have count of \"-\" equals to level\\n        while (rightStart < chars.length) {\\n            if (chars[rightStart] == \\'-\\') {\\n                interval++;\\n            } else {\\n                if (interval == level) {\\n                    break;\\n                }\\n                interval = 0;\\n            }\\n            ++rightStart;\\n        }\\n        // recalculate left end, it may have rightStart > end, so we take end\\n        final int leftEnd = rightStart > end ? end : rightStart - level - 1;\\n        // build tree recursively\\n        root.left = build(chars, leftStart, leftEnd, level + 1);\\n        root.right = build(chars, rightStart, end, level + 1);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public TreeNode recoverFromPreorder(String s) {\\n        final char[] chars = s.toCharArray();\\n        return build(chars, 0, chars.length - 1, 1);\\n    }\\n\\n    private TreeNode build(char[] chars, int start, int end, int level) {\\n        if (start > end) {\\n            return null;\\n        }\\n        // convert chars to integer, take example of \"405 - - 1 - - 22\", the first int is 405, NOT 4\\n        final StringBuilder stringBuilder = new StringBuilder();\\n        while (start <= end && chars[start] != \\'-\\') {\\n            stringBuilder.append(chars[start]);\\n            start++;\\n        }\\n        // root of node\\n        final TreeNode root = new TreeNode(Integer.parseInt(stringBuilder.toString()));\\n        if (start == end) {\\n            return root;\\n        }\\n        // calculate left start\\n        final int leftStart = start + level;\\n        int interval = 0;\\n        int rightStart = leftStart + 1;\\n        // calculate right start, if exists one, it must have count of \"-\" equals to level\\n        while (rightStart < chars.length) {\\n            if (chars[rightStart] == \\'-\\') {\\n                interval++;\\n            } else {\\n                if (interval == level) {\\n                    break;\\n                }\\n                interval = 0;\\n            }\\n            ++rightStart;\\n        }\\n        // recalculate left end, it may have rightStart > end, so we take end\\n        final int leftEnd = rightStart > end ? end : rightStart - level - 1;\\n        // build tree recursively\\n        root.left = build(chars, leftStart, leftEnd, level + 1);\\n        root.right = build(chars, rightStart, end, level + 1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676572,
                "title": "simple-recursive-preorder-traversal",
                "content": "Keep a ptr to the current position in the string. At each level check if the next value is for the current level. if it is create a node and return it to the parent else return empty node.\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        ptr = 0\\n        def traverse(level: int) -> TreeNode:\\n            nonlocal ptr\\n            nextLevel = 0\\n            while ptr < len(S) and S[ptr] == \\'-\\':\\n                nextLevel += 1\\n                ptr += 1\\n                \\n            if level == nextLevel: \\n                val = \\'\\'\\n                while ptr < len(S) and S[ptr] != \\'-\\':\\n                    val += S[ptr]\\n                    ptr += 1\\n                node = TreeNode(int(val))\\n                node.left = traverse(level+1)\\n                node.right = traverse(level+1)\\n                return node\\n            else:\\n                ptr -= nextLevel\\n                return None\\n\\n        return traverse(0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        ptr = 0\\n        def traverse(level: int) -> TreeNode:\\n            nonlocal ptr\\n            nextLevel = 0\\n            while ptr < len(S) and S[ptr] == \\'-\\':\\n                nextLevel += 1\\n                ptr += 1\\n                \\n            if level == nextLevel: \\n                val = \\'\\'\\n                while ptr < len(S) and S[ptr] != \\'-\\':\\n                    val += S[ptr]\\n                    ptr += 1\\n                node = TreeNode(int(val))\\n                node.left = traverse(level+1)\\n                node.right = traverse(level+1)\\n                return node\\n            else:\\n                ptr -= nextLevel\\n                return None\\n\\n        return traverse(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426849,
                "title": "c-simple-map-solution-this-should-be-a-medium",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int parse_dash(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] != \\'-\\') break;\\n            ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\n    int parse_num(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] == \\'-\\') break;\\n            ans = ans*10 + (S[i]-\\'0\\');\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode*> m;\\n        int n = S.length();\\n        int i = 0;\\n        while(i < n) {\\n            int dash = parse_dash(S, i);\\n            int num = parse_num(S, i);\\n            TreeNode* curr = new TreeNode(num);\\n            if(dash != 0) {\\n                TreeNode* parent = m[dash-1];\\n                if(!parent->left) parent->left = curr;\\n                else parent->right = curr;\\n            }\\n            m[dash] = curr;\\n        }\\n        return m[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int parse_dash(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] != \\'-\\') break;\\n            ans++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\n    int parse_num(string& S, int& i) {\\n        int ans = 0;\\n        while(i < S.length()) {\\n            if(S[i] == \\'-\\') break;\\n            ans = ans*10 + (S[i]-\\'0\\');\\n            i++;\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode*> m;\\n        int n = S.length();\\n        int i = 0;\\n        while(i < n) {\\n            int dash = parse_dash(S, i);\\n            int num = parse_num(S, i);\\n            TreeNode* curr = new TreeNode(num);\\n            if(dash != 0) {\\n                TreeNode* parent = m[dash-1];\\n                if(!parent->left) parent->left = curr;\\n                else parent->right = curr;\\n            }\\n            m[dash] = curr;\\n        }\\n        return m[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341110,
                "title": "easiest-c-solution-no-recursion-and-also-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef TreeNode* btptr;\\n    TreeNode* recoverFromPreorder(string s) \\n    {\\n      btptr root=NULL;\\n        int cnt=0;\\n        if(s.length()==0)\\n             return root;\\n         vector<pair<btptr,int> >ump;\\n        // pair stores the newly formed node with their depths as the second                //parameter\\n        int i=0,n=s.length();\\n        while(i<n)\\n        {\\n            int d=0;\\n            while(i<n&&s[i]!=\\'-\\')\\n            {\\n                d=d*10+(s[i]-\\'0\\');\\n                i++;\\n            }\\n            btptr y=new TreeNode(d);// formed new node \\n            ump.push_back(make_pair(y,cnt));\\n            cnt=0;\\n            while(i<n&&s[i]==\\'-\\')\\n            {\\n                i++;\\n                cnt++;// calculating depths for every node \\n            }\\n        }\\n        // forming the tree with the help of vector<pair<btptr,int>>ump;\\n        // which stored the newly formed nodes with their depths \\n        // and for every node searched the nearest node that is at depth lesser \\n        // than the current node if we got such node\\n        // then break at that point and if for that node if left is null then \\n        // assign first left as said in question \\n        // if left is not null then assign right\\n        for(int i=1;i<ump.size();i++)\\n        {\\n            for(int u=i-1;u>=0;u--)\\n            {\\n                if(ump[u].second<ump[i].second)\\n                {\\n                    if(ump[u].first->left==NULL)\\n                        ump[u].first->left=ump[i].first;\\n                    else\\n                        ump[u].first->right=ump[i].first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ump[0].first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef TreeNode* btptr;\\n    TreeNode* recoverFromPreorder(string s) \\n    {\\n      btptr root=NULL;\\n        int cnt=0;\\n        if(s.length()==0)\\n             return root;\\n         vector<pair<btptr,int> >ump;\\n        // pair stores the newly formed node with their depths as the second                //parameter\\n        int i=0,n=s.length();\\n        while(i<n)\\n        {\\n            int d=0;\\n            while(i<n&&s[i]!=\\'-\\')\\n            {\\n                d=d*10+(s[i]-\\'0\\');\\n                i++;\\n            }\\n            btptr y=new TreeNode(d);// formed new node \\n            ump.push_back(make_pair(y,cnt));\\n            cnt=0;\\n            while(i<n&&s[i]==\\'-\\')\\n            {\\n                i++;\\n                cnt++;// calculating depths for every node \\n            }\\n        }\\n        // forming the tree with the help of vector<pair<btptr,int>>ump;\\n        // which stored the newly formed nodes with their depths \\n        // and for every node searched the nearest node that is at depth lesser \\n        // than the current node if we got such node\\n        // then break at that point and if for that node if left is null then \\n        // assign first left as said in question \\n        // if left is not null then assign right\\n        for(int i=1;i<ump.size();i++)\\n        {\\n            for(int u=i-1;u>=0;u--)\\n            {\\n                if(ump[u].second<ump[i].second)\\n                {\\n                    if(ump[u].first->left==NULL)\\n                        ump[u].first->left=ump[i].first;\\n                    else\\n                        ump[u].first->right=ump[i].first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ump[0].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290160,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        self.i = 0\\n        self.L = len(S)\\n        \\n        def build_tree(level):\\n            node = TreeNode(get_value())\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.left = build_tree(next_level)\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.right = build_tree(next_level)\\n            return node\\n            \\n        def get_level():\\n            level = 0\\n            while self.i < self.L and S[self.i] == \\'-\\':\\n                level += 1\\n                self.i+=1\\n            return level\\n\\n        def get_value():\\n            val = \"\"\\n            while self.i < self.L and S[self.i] != \\'-\\':\\n                val += S[self.i]\\n                self.i+=1\\n            return val\\n        \\n        return build_tree(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: TreeNode\\n        \"\"\"\\n        self.i = 0\\n        self.L = len(S)\\n        \\n        def build_tree(level):\\n            node = TreeNode(get_value())\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.left = build_tree(next_level)\\n            next_level = get_level()\\n            if next_level <= level:\\n                self.i -= next_level\\n                return node\\n            node.right = build_tree(next_level)\\n            return node\\n            \\n        def get_level():\\n            level = 0\\n            while self.i < self.L and S[self.i] == \\'-\\':\\n                level += 1\\n                self.i+=1\\n            return level\\n\\n        def get_value():\\n            val = \"\"\\n            while self.i < self.L and S[self.i] != \\'-\\':\\n                val += S[self.i]\\n                self.i+=1\\n            return val\\n        \\n        return build_tree(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278544,
                "title": "this-should-not-be-hard",
                "content": "This should not be hard, relative to other hard. I don\\'t use any tricks or algorithm, just brute force and it is the best solution:\\n```\\n    public TreeNode RecoverFromPreorder(string S) {\\n        TreeNode root = null;\\n        var parents = new Stack<TreeNode>();\\n        \\n        for (int i = 0; i < S.Length; ) {\\n            \\n            // parse depth and value\\n            int depth = 0, val = 0;\\n            for (; i < S.Length && S[i] == \\'-\\'; i++) depth++;\\n            for (; i < S.Length && S[i] != \\'-\\'; i++) val = val*10 + (S[i]-\\'0\\');\\n            var node = new TreeNode(val);\\n            \\n            while (parents.Count > depth) parents.Pop();\\n            \\n            if (root == null) {\\n                root = node;\\n            } else {\\n                var p = parents.Peek();\\n                if (p.left == null) p.left = node;\\n                else p.right  = node;\\n            }\\n            \\n            parents.Push(node);\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode RecoverFromPreorder(string S) {\\n        TreeNode root = null;\\n        var parents = new Stack<TreeNode>();\\n        \\n        for (int i = 0; i < S.Length; ) {\\n            \\n            // parse depth and value\\n            int depth = 0, val = 0;\\n            for (; i < S.Length && S[i] == \\'-\\'; i++) depth++;\\n            for (; i < S.Length && S[i] != \\'-\\'; i++) val = val*10 + (S[i]-\\'0\\');\\n            var node = new TreeNode(val);\\n            \\n            while (parents.Count > depth) parents.Pop();\\n            \\n            if (root == null) {\\n                root = node;\\n            } else {\\n                var p = parents.Peek();\\n                if (p.left == null) p.left = node;\\n                else p.right  = node;\\n            }\\n            \\n            parents.Push(node);\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276736,
                "title": "rust-recursive-solution",
                "content": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn recover_from_preorder(s: String) -> Option<Rc<RefCell<TreeNode>>> {\\n        let vals: Vec<i32> = s.split(\\'-\\').filter(|x| x.len() > 0).map(|x| x.parse().unwrap()).collect();\\n        let mut depths: Vec<i32> = s.split(char::is_numeric).filter(|x| x.len() > 0).map(|x| x.len() as i32).collect();\\n        depths.insert(0, 0); // \\u6839\\u8282\\u70B9\\n\\n        Solution::build_tree(&vals, &depths, 0, 0).0\\n    }\\n\\n    fn build_tree(vals: &Vec<i32>, depths: &Vec<i32>, idx: usize, depth: usize) -> (Option<Rc<RefCell<TreeNode>>>, usize) {\\n        if idx >= vals.len() || depth as i32 > depths[idx]  {\\n            return (None, idx);\\n        }\\n        let child = Some(Rc::new(RefCell::new(TreeNode::new(vals[idx]))));\\n        let (left, left_idx) = Solution::build_tree(vals, depths, idx + 1, depth + 1);\\n        let mut next_idx = left_idx;\\n        child.as_ref().unwrap().borrow_mut().left = left;\\n        if left_idx > idx { // \\u6709\\u53F3\\u5B50\\u6811\\n            let (right, right_idx) = Solution::build_tree(vals, depths, left_idx, depth + 1);\\n            next_idx = right_idx;\\n            child.as_ref().unwrap().borrow_mut().right = right;\\n        }\\n\\n        (child, next_idx)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn recover_from_preorder(s: String) -> Option<Rc<RefCell<TreeNode>>> {\\n        let vals: Vec<i32> = s.split(\\'-\\').filter(|x| x.len() > 0).map(|x| x.parse().unwrap()).collect();\\n        let mut depths: Vec<i32> = s.split(char::is_numeric).filter(|x| x.len() > 0).map(|x| x.len() as i32).collect();\\n        depths.insert(0, 0); // \\u6839\\u8282\\u70B9\\n\\n        Solution::build_tree(&vals, &depths, 0, 0).0\\n    }\\n\\n    fn build_tree(vals: &Vec<i32>, depths: &Vec<i32>, idx: usize, depth: usize) -> (Option<Rc<RefCell<TreeNode>>>, usize) {\\n        if idx >= vals.len() || depth as i32 > depths[idx]  {\\n            return (None, idx);\\n        }\\n        let child = Some(Rc::new(RefCell::new(TreeNode::new(vals[idx]))));\\n        let (left, left_idx) = Solution::build_tree(vals, depths, idx + 1, depth + 1);\\n        let mut next_idx = left_idx;\\n        child.as_ref().unwrap().borrow_mut().left = left;\\n        if left_idx > idx { // \\u6709\\u53F3\\u5B50\\u6811\\n            let (right, right_idx) = Solution::build_tree(vals, depths, left_idx, depth + 1);\\n            next_idx = right_idx;\\n            child.as_ref().unwrap().borrow_mut().right = right;\\n        }\\n\\n        (child, next_idx)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243162,
                "title": "simple-c-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string path;\\n    int getDepth() {\\n        int n = path.length(), idx = 0;\\n        for(; idx < n && path[idx] == \\'-\\'; idx++){}\\n        return idx;\\n    }\\n    int getValue() {\\n        int n = path.length(), idx = 0, num = 0;\\n        for(; idx < n; ++idx) {\\n            if(path[idx] != \\'-\\') break;\\n        }\\n        for(; idx < n; idx++) {\\n            if(path[idx] == \\'-\\') break;\\n            int digit = path[idx] - \\'0\\';\\n            num = num * 10 + digit;\\n        }\\n        path = path.substr(idx);\\n        return num;\\n    }\\n    TreeNode* dfs(int required_depth) {\\n        int available_depth = getDepth();\\n        if(required_depth > available_depth) {\\n            return NULL;\\n        }\\n        int value = getValue();\\n        TreeNode* root = new TreeNode(value);\\n        root->left = dfs(required_depth + 1);\\n        root->right = dfs(required_depth + 1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        path = traversal;\\n        return dfs(0);\\n    }\\n};\\n\\n// 1 [2 3 4 5 6 7\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string path;\\n    int getDepth() {\\n        int n = path.length(), idx = 0;\\n        for(; idx < n && path[idx] == \\'-\\'; idx++){}\\n        return idx;\\n    }\\n    int getValue() {\\n        int n = path.length(), idx = 0, num = 0;\\n        for(; idx < n; ++idx) {\\n            if(path[idx] != \\'-\\') break;\\n        }\\n        for(; idx < n; idx++) {\\n            if(path[idx] == \\'-\\') break;\\n            int digit = path[idx] - \\'0\\';\\n            num = num * 10 + digit;\\n        }\\n        path = path.substr(idx);\\n        return num;\\n    }\\n    TreeNode* dfs(int required_depth) {\\n        int available_depth = getDepth();\\n        if(required_depth > available_depth) {\\n            return NULL;\\n        }\\n        int value = getValue();\\n        TreeNode* root = new TreeNode(value);\\n        root->left = dfs(required_depth + 1);\\n        root->right = dfs(required_depth + 1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        path = traversal;\\n        return dfs(0);\\n    }\\n};\\n\\n// 1 [2 3 4 5 6 7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094251,
                "title": "hashmap-solution-easy-cpp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n            int i = 0;\\n            string l = \"\";\\n            // Find root of the tree\\n\\t\\t\\twhile(i < s.length() && s[i] != \\'-\\')\\n                    l += s[i],i++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n            \\n            // Create root by converting string to integer\\n            TreeNode* root  = new TreeNode(stoi(l));\\n            TreeNode* ans = root;\\n            map<int,TreeNode*> mp;\\n            \\n            \\n            // Root is on 0 level, at one time only one node will open at any level\\n            mp[0]  = root;\\n\\t\\t\\t\\n            \\n            while(i < s.length())\\n            {\\n                    int count = 0;\\n\\t\\t\\t\\t\\t// Find the depth of next element\\n                    while(i < s.length() && s[i] == \\'-\\')\\n                            count++,i++;\\n                  //  cout<<count<<\"\\\\n\";\\n                    \\n\\t\\t\\t\\t\\t// Find the element\\n                    string local = \"\";\\n                    while(i < s.length() && s[i] != \\'-\\')\\n                            local += s[i],i++;\\n                    \\n\\t\\t\\t\\t\\t// Create Node\\n                    TreeNode* temp = new TreeNode(stoi(local));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// If at depth count-1 left position is NULL then insert there\\n                    if(mp[count-1]->left == NULL)\\n                    {\\n                            mp[count-1]->left = temp;\\n                            mp[count] = temp;\\n                            \\n                    }else{\\n                            \\n                            mp[count-1]->right = temp;\\n                            mp[count] = temp; \\n                    }\\n                   \\n            }\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n            int i = 0;\\n            string l = \"\";\\n            // Find root of the tree\\n\\t\\t\\twhile(i < s.length() && s[i] != \\'-\\')\\n                    l += s[i],i++;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n            \\n            // Create root by converting string to integer\\n            TreeNode* root  = new TreeNode(stoi(l));\\n            TreeNode* ans = root;\\n            map<int,TreeNode*> mp;\\n            \\n            \\n            // Root is on 0 level, at one time only one node will open at any level\\n            mp[0]  = root;\\n\\t\\t\\t\\n            \\n            while(i < s.length())\\n            {\\n                    int count = 0;\\n\\t\\t\\t\\t\\t// Find the depth of next element\\n                    while(i < s.length() && s[i] == \\'-\\')\\n                            count++,i++;\\n                  //  cout<<count<<\"\\\\n\";\\n                    \\n\\t\\t\\t\\t\\t// Find the element\\n                    string local = \"\";\\n                    while(i < s.length() && s[i] != \\'-\\')\\n                            local += s[i],i++;\\n                    \\n\\t\\t\\t\\t\\t// Create Node\\n                    TreeNode* temp = new TreeNode(stoi(local));\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// If at depth count-1 left position is NULL then insert there\\n                    if(mp[count-1]->left == NULL)\\n                    {\\n                            mp[count-1]->left = temp;\\n                            mp[count] = temp;\\n                            \\n                    }else{\\n                            \\n                            mp[count-1]->right = temp;\\n                            mp[count] = temp; \\n                    }\\n                   \\n            }\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2990144,
                "title": "ruby-2-liner",
                "content": "```\\ndef recover_from_preorder(traversal)\\n\\n  r,*c = traversal.split /(?<=\\\\d)-(?=\\\\d)/\\n  TreeNode.new r, *c.map{ recover_from_preorder _1.gsub /-(-+)/, \\'\\\\1\\' }\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef recover_from_preorder(traversal)\\n\\n  r,*c = traversal.split /(?<=\\\\d)-(?=\\\\d)/\\n  TreeNode.new r, *c.map{ recover_from_preorder _1.gsub /-(-+)/, \\'\\\\1\\' }\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2896048,
                "title": "recursive-java-solution-using-stack-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the traversals string into two lists such that one represents the integer values and the other represents the depths where such nodes are found. Make sure to put in zero as the first element of the other array. It represents zero as the depth of our root node.\\n2. Prepare an empty stack for storing a tuple of TreeNode objects, and their depth.\\n3. Create a dummy node and push it into the stack with a depth of -1\\n4. Call a build function on the first index `i = 0` of the two lists in `1` above.\\n5. If the top element on the stack has a lower value depth than the depth of the current item, create a new TreeNode with value and depths at index i and label it as the left child of the top element on the stack and push the new TreeNode unto the stack.\\n6. If the previous condition was false, keep popping off items from the stack until you get a TreeNode whose depth is lower than the current depth at `i`.\\n7. After popping of items, create a new TreeNode with the current value label it as the right child of the Top element of the stack. Pop the top element of the stack and push the new TreeNode and current depth on top of the stack.\\n8. Recursively repeat the steps until `i` goes out of bounds.\\n\\n# Complexity\\n- Time complexity: **$$O(n)$$**\\n\\n- Space complexity: **$$O(n)$$**\\n\\n# Code\\n```\\nclass Tup<A, B> {\\n\\tA first;\\n\\tB second;\\n\\n\\tpublic Tup(A a, B b) {\\n\\t\\tthis.first = a;\\n\\t\\tthis.second = b;\\n\\t}\\n\\n}\\n\\nclass Solution {\\n\\tStack<Tup<TreeNode, Integer>> stack = new Stack<>();\\n\\tTreeNode root = new TreeNode();\\n\\tTup<ArrayList<Integer>, ArrayList<Integer>> content;\\n\\tint n;\\n\\n\\tpublic TreeNode recoverFromPreorder(String traversal) {\\n\\t\\tcontent = modify(traversal);\\n\\t\\tn = content.first.size();\\n\\t\\tstack.push(new Tup<>(root, -1));\\n\\t\\tbuild(0);\\n\\t\\treturn root.left;\\n\\t}\\n\\n\\tprivate void build(int i) {\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn;\\n\\n\\t\\tTreeNode newNode = new TreeNode(content.first.get(i));\\n\\t\\tint depth = content.second.get(i);\\n\\n\\t\\tif (depth > stack.peek().second) {\\n\\t\\t\\tstack.peek().first.left = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t} else {\\n\\t\\t\\twhile (stack.peek().second >= depth) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop().first.right = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t}\\n\\n\\t\\tbuild(i + 1);\\n\\t}\\n\\n\\tprivate Tup<ArrayList<Integer>, ArrayList<Integer>> modify(String con) {\\n\\t\\tint n = con.length();\\n\\t\\tint i = 0;\\n\\n\\t\\tTup<ArrayList<Integer>, ArrayList<Integer>> ans = new Tup<>(new ArrayList<>(), new ArrayList<>());\\n\\t\\tans.second.add(0);\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.second.add(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) != \\'-\\') {\\n\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\tnum += con.charAt(i) - \\'0\\';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans.first.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Tup<A, B> {\\n\\tA first;\\n\\tB second;\\n\\n\\tpublic Tup(A a, B b) {\\n\\t\\tthis.first = a;\\n\\t\\tthis.second = b;\\n\\t}\\n\\n}\\n\\nclass Solution {\\n\\tStack<Tup<TreeNode, Integer>> stack = new Stack<>();\\n\\tTreeNode root = new TreeNode();\\n\\tTup<ArrayList<Integer>, ArrayList<Integer>> content;\\n\\tint n;\\n\\n\\tpublic TreeNode recoverFromPreorder(String traversal) {\\n\\t\\tcontent = modify(traversal);\\n\\t\\tn = content.first.size();\\n\\t\\tstack.push(new Tup<>(root, -1));\\n\\t\\tbuild(0);\\n\\t\\treturn root.left;\\n\\t}\\n\\n\\tprivate void build(int i) {\\n\\t\\tif (i >= n)\\n\\t\\t\\treturn;\\n\\n\\t\\tTreeNode newNode = new TreeNode(content.first.get(i));\\n\\t\\tint depth = content.second.get(i);\\n\\n\\t\\tif (depth > stack.peek().second) {\\n\\t\\t\\tstack.peek().first.left = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t} else {\\n\\t\\t\\twhile (stack.peek().second >= depth) {\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.pop().first.right = newNode;\\n\\t\\t\\tstack.push(new Tup<>(newNode, depth));\\n\\t\\t}\\n\\n\\t\\tbuild(i + 1);\\n\\t}\\n\\n\\tprivate Tup<ArrayList<Integer>, ArrayList<Integer>> modify(String con) {\\n\\t\\tint n = con.length();\\n\\t\\tint i = 0;\\n\\n\\t\\tTup<ArrayList<Integer>, ArrayList<Integer>> ans = new Tup<>(new ArrayList<>(), new ArrayList<>());\\n\\t\\tans.second.add(0);\\n\\n\\t\\twhile (i < n) {\\n\\t\\t\\tif (con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\tint c = 0;\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) == \\'-\\') {\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.second.add(c);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint num = 0;\\n\\n\\t\\t\\t\\twhile (i < n && con.charAt(i) != \\'-\\') {\\n\\t\\t\\t\\t\\tnum *= 10;\\n\\t\\t\\t\\t\\tnum += con.charAt(i) - \\'0\\';\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans.first.add(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894918,
                "title": "python-minimal-code-without-stack-or-recursion-the-best",
                "content": "# Approach\\nNote that the empty tree is supported as well.\\n\\nThe Best!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        root = None\\n        for val in traversal.split(\\'-\\'):\\n            if not root or val == \\'\\':\\n                parent = (parent.right if parent.right else parent.left) if root else (root := TreeNode(int(val)))\\n            else:\\n                parent, _ = root, setattr(parent, \\'right\\' if parent.left else \\'left\\', TreeNode(int(val)))\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        root = None\\n        for val in traversal.split(\\'-\\'):\\n            if not root or val == \\'\\':\\n                parent = (parent.right if parent.right else parent.left) if root else (root := TreeNode(int(val)))\\n            else:\\n                parent, _ = root, setattr(parent, \\'right\\' if parent.left else \\'left\\', TreeNode(int(val)))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769002,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int,TreeNode*>m;\\n        TreeNode* root,*ptr;\\n        int i=0;\\n        string num=\"\";\\n        while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n            num+=traversal[i];\\n            i++;\\n        }\\n        \\n        ptr =new TreeNode(stoi(num));\\n        m[0]=ptr;\\n        root=ptr;\\n        \\n        while(i<traversal.size()){\\n            int dash=0;\\n            string s=\"\";\\n            while(traversal[i]==\\'-\\'){\\n                dash++;\\n                i++;\\n            }\\n            \\n            while(i<traversal.size() && traversal[i]!=\\'-\\'){\\n                s+=traversal[i];\\n                i++;\\n            }\\n            \\n            auto ele=new TreeNode(stoi(s));\\n            if(!m[dash-1]->left)m[dash-1]->left=ele;\\n            else m[dash-1]->right=ele;\\n            \\n            m[dash]=ele;\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465019,
                "title": "c-short-and-simple-code",
                "content": "Runtime 22ms\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode* rec(vector<pair<int,int>> &v,int &i,int dashes){\\n        if(i>=v.size()||dashes!=v[i].second){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(v[i].first);\\n        i++;\\n        root->left=rec(v,i,dashes+1);\\n        root->right=rec(v,i,dashes+1);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        vector<pair<int,int>> v;\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]!=\\'-\\'){\\n                string s=\"\";\\n                while(i<str.size()&&str[i]!=\\'-\\')\\n                    s+=str[i++];\\n                i--;\\n                v.push_back({stoi(s),count});\\n                count=0;\\n            }\\n            else count++;\\n              \\n        }\\n        int x=0;\\n        return rec(v,x,0);\\n    }\\n};\\n```\\nTime Complexity O(n) Space Complexity O(n)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    TreeNode* rec(vector<pair<int,int>> &v,int &i,int dashes){\\n        if(i>=v.size()||dashes!=v[i].second){\\n            return NULL;\\n        }\\n        TreeNode* root=new TreeNode(v[i].first);\\n        i++;\\n        root->left=rec(v,i,dashes+1);\\n        root->right=rec(v,i,dashes+1);\\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        vector<pair<int,int>> v;\\n        int count=0;\\n        for(int i=0;i<str.size();i++){\\n            if(str[i]!=\\'-\\'){\\n                string s=\"\";\\n                while(i<str.size()&&str[i]!=\\'-\\')\\n                    s+=str[i++];\\n                i--;\\n                v.push_back({stoi(s),count});\\n                count=0;\\n            }\\n            else count++;\\n              \\n        }\\n        int x=0;\\n        return rec(v,x,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447190,
                "title": "python-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # preorder = root -> left -> right\\n    # Then the task at hand is to look for \"digit\"+ -\"+ \"digit\" in string\\n    # Assign the first appearance to the left tree, the second to right\\n    # We need to shorten - streaks by one in the resultant string\\n    def dash_reducer(self, ori_string):\\n        count, result_string = 0, \"\"\\n        for c in ori_string:\\n            if c.isdigit():\\n                if count > 0:\\n                    result_string += \"-\"*(count-1)\\n                    count = 0\\n                result_string += c\\n            else:\\n                count += 1\\n        return result_string\\n        \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        i, curr, finished_root, start = 0, 0, False, []\\n        for i, c in enumerate(traversal):\\n            if not finished_root:\\n                if c.isdigit():\\n                    curr *= 10\\n                    curr += int(c)\\n                else:\\n                    finished_root = True\\n                    root = TreeNode(curr)\\n            if c == \"-\" and traversal[i-1].isdigit() and traversal[i+1].isdigit():\\n                start.append(i+1)\\n        if len(start) == 0:\\n            finished_root = True\\n            root = TreeNode(curr)\\n        elif len(start) == 1:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:]))\\n        else:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:start[1]-1]))\\n            root.right = self.recoverFromPreorder(self.dash_reducer(traversal[start[1]:]))\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    # preorder = root -> left -> right\\n    # Then the task at hand is to look for \"digit\"+ -\"+ \"digit\" in string\\n    # Assign the first appearance to the left tree, the second to right\\n    # We need to shorten - streaks by one in the resultant string\\n    def dash_reducer(self, ori_string):\\n        count, result_string = 0, \"\"\\n        for c in ori_string:\\n            if c.isdigit():\\n                if count > 0:\\n                    result_string += \"-\"*(count-1)\\n                    count = 0\\n                result_string += c\\n            else:\\n                count += 1\\n        return result_string\\n        \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        i, curr, finished_root, start = 0, 0, False, []\\n        for i, c in enumerate(traversal):\\n            if not finished_root:\\n                if c.isdigit():\\n                    curr *= 10\\n                    curr += int(c)\\n                else:\\n                    finished_root = True\\n                    root = TreeNode(curr)\\n            if c == \"-\" and traversal[i-1].isdigit() and traversal[i+1].isdigit():\\n                start.append(i+1)\\n        if len(start) == 0:\\n            finished_root = True\\n            root = TreeNode(curr)\\n        elif len(start) == 1:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:]))\\n        else:\\n            root.left = self.recoverFromPreorder(self.dash_reducer(traversal[start[0]:start[1]-1]))\\n            root.right = self.recoverFromPreorder(self.dash_reducer(traversal[start[1]:]))\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352614,
                "title": "c-solution-time-o-n-memory-o-n-beats-95-iterative-stack",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        int start = 0, index = 0;\\n        while (index < traversal.Length) {\\n            int depth = 0;\\n            while (index < traversal.Length && traversal[index] == \\'-\\') { depth++; index++; }\\n            \\n            int number = 0;\\n            while (index < traversal.Length && char.IsDigit(traversal[index])) {\\n                number = number * 10 + traversal[index] - \\'0\\';\\n                index++;\\n            }\\n            \\n            bool wentBack = stack.Count > depth;\\n            while (stack.Count > depth) stack.Pop();\\n            \\n            TreeNode current = new TreeNode(number);\\n            if (stack.Count > 0) {\\n                TreeNode top = stack.Peek();\\n                if (wentBack) top.right = current;\\n                else top.left = current;\\n            }\\n            \\n            stack.Push(current);\\n        }\\n        \\n        while (stack.Count > 1) stack.Pop();\\n        return stack.Peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        int start = 0, index = 0;\\n        while (index < traversal.Length) {\\n            int depth = 0;\\n            while (index < traversal.Length && traversal[index] == \\'-\\') { depth++; index++; }\\n            \\n            int number = 0;\\n            while (index < traversal.Length && char.IsDigit(traversal[index])) {\\n                number = number * 10 + traversal[index] - \\'0\\';\\n                index++;\\n            }\\n            \\n            bool wentBack = stack.Count > depth;\\n            while (stack.Count > depth) stack.Pop();\\n            \\n            TreeNode current = new TreeNode(number);\\n            if (stack.Count > 0) {\\n                TreeNode top = stack.Peek();\\n                if (wentBack) top.right = current;\\n                else top.left = current;\\n            }\\n            \\n            stack.Push(current);\\n        }\\n        \\n        while (stack.Count > 1) stack.Pop();\\n        return stack.Peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278817,
                "title": "c-easiest-solution",
                "content": "**Pls Upvote if you like the Solution!**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        vector <TreeNode*> st;                       //Stack Declaration\\n        for(int i=0; i<s.size(); ){\\n            int level=0, val=0;                      //Variables for level and number\\n            while(s[i] == \\'-\\')\\n                level++, i++;                        //Calculating Level\\n            while(i < s.size() && s[i] != \\'-\\'){      //Storing number in val\\n                val*=10;\\n                val+=s[i]-\\'0\\';                       //Converting char to int\\n                i++;\\n            }\\n            TreeNode* node = new TreeNode(val);                   //Creating new node\\n            while(st.size()>level) st.pop_back();                 //Finding right level to Insert\\n            if(!st.empty()){\\n                if(!st.back()->left) st.back()->left=node;        //Checking left child first\\n                else st.back()->right=node;                       //Creating right child if left child already present\\n            }\\n            st.push_back(node);                                   //Pushing new node to stack\\n        }\\n        return st[0];                                             //Returning head\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        vector <TreeNode*> st;                       //Stack Declaration\\n        for(int i=0; i<s.size(); ){\\n            int level=0, val=0;                      //Variables for level and number\\n            while(s[i] == \\'-\\')\\n                level++, i++;                        //Calculating Level\\n            while(i < s.size() && s[i] != \\'-\\'){      //Storing number in val\\n                val*=10;\\n                val+=s[i]-\\'0\\';                       //Converting char to int\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2278157,
                "title": "faster-than-95-99-of-c-iterative-stack",
                "content": "```\\nTreeNode recoverFromPreorder(string traversal){\\n        stack<TreeNode> stk;\\n        for(int i=0;i<traversal.length();){\\n            int level=0;\\n            while(traversal[i]==\\'-\\')++level,++i;\\n            int start = i;\\n            while(isdigit(traversal[i]))++i;\\n            int val=stoi(traversal.substr(start,i-start+1));\\n            TreeNodetmp = new TreeNode(val);\\n            if(stk.empty()) {stk.emplace(tmp);continue;}\\n            while(stk.size()>level)stk.pop();\\n            if(stk.top()->left)stk.top()->right=tmp;\\n            else stk.top()->left=tmp;\\n            stk.emplace(tmp);\\n        }\\n        while(stk.size()>1)stk.pop();\\n        return stk.top();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode recoverFromPreorder(string traversal){\\n        stack<TreeNode> stk;\\n        for(int i=0;i<traversal.length();){\\n            int level=0;\\n            while(traversal[i]==\\'-\\')++level,++i;\\n            int start = i;\\n            while(isdigit(traversal[i]))++i;\\n            int val=stoi(traversal.substr(start,i-start+1));\\n            TreeNodetmp = new TreeNode(val);\\n            if(stk.empty()) {stk.emplace(tmp);continue;}\\n            while(stk.size()>level)stk.pop();\\n            if(stk.top()->left)stk.top()->right=tmp;\\n            else stk.top()->left=tmp;\\n            stk.emplace(tmp);\\n        }\\n        while(stk.size()>1)stk.pop();\\n        return stk.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153637,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        int sz = s.size();\\n        int idx = 0;\\n        string rootval = \"\";\\n        while(idx<sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n        {\\n            rootval += s[idx];\\n            idx++;\\n        }\\n        TreeNode* root = new TreeNode(stoll(rootval));\\n        //TreeNode* rootNode = root;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root,0});\\n        while(idx < sz)\\n        {\\n            int level = 0;\\n            while(s[idx] == \\'-\\')\\n            {\\n                level++;\\n                idx++;\\n            }\\n            string sm = \"\"; \\n            while(idx < sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n            {\\n                sm += s[idx];\\n                idx++;\\n            }\\n            while(st.top().second >= level)\\n            {\\n                st.pop();\\n            }\\n            TreeNode* tmp = new TreeNode(stoll(sm));\\n            if(!st.top().first->left)\\n            {\\n                st.top().first->left = tmp;\\n            }\\n            else\\n            {\\n                st.top().first->right = tmp;\\n            }\\n            st.push({tmp, level});\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        int sz = s.size();\\n        int idx = 0;\\n        string rootval = \"\";\\n        while(idx<sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n        {\\n            rootval += s[idx];\\n            idx++;\\n        }\\n        TreeNode* root = new TreeNode(stoll(rootval));\\n        //TreeNode* rootNode = root;\\n        stack<pair<TreeNode*, int>> st;\\n        st.push({root,0});\\n        while(idx < sz)\\n        {\\n            int level = 0;\\n            while(s[idx] == \\'-\\')\\n            {\\n                level++;\\n                idx++;\\n            }\\n            string sm = \"\"; \\n            while(idx < sz && s[idx] >= \\'0\\' && s[idx] <= \\'9\\')\\n            {\\n                sm += s[idx];\\n                idx++;\\n            }\\n            while(st.top().second >= level)\\n            {\\n                st.pop();\\n            }\\n            TreeNode* tmp = new TreeNode(stoll(sm));\\n            if(!st.top().first->left)\\n            {\\n                st.top().first->left = tmp;\\n            }\\n            else\\n            {\\n                st.top().first->right = tmp;\\n            }\\n            st.push({tmp, level});\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134294,
                "title": "java-easy-preorder-traversal-solution-easy-to-understand",
                "content": "class Solution {\\n\\n    int i = 0;\\n    public TreeNode helper(String str, int depth){\\n        int d = 0;\\n        while(i+d<str.length() && str.charAt(i+d) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        int nd = 0;\\n        \\n        while(i + d + nd <str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i + d + nd;\\n        TreeNode root = new TreeNode(val);\\n        root.left = helper(str,depth+1);\\n        root.right = helper(str,depth+1);\\n        \\n        return root;\\n        \\n    }\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal.length()==0){\\n            return null;\\n        }\\n        \\n        return helper(traversal,0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    int i = 0;\\n    public TreeNode helper(String str, int depth){\\n        int d = 0;\\n        while(i+d<str.length() && str.charAt(i+d) == \\'-\\'){\\n            d++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2123129,
                "title": "java-simple-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(traversal,0);\\n    }\\n    \\n    public TreeNode helper(String str, int depth){\\n        //d == number of dashes\\n        int d = 0;\\n        while(i+d < str.length() && str.charAt((i+d)) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        //if dashes is not equal to depth add null \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        //nd --> Non dash \\n        int nd = 0;\\n        while((i+d+nd) < str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n\\t\\t//create val from dashes ending to non-dashes ending\\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left = helper(str,depth+1);\\n        node.right = helper(str,depth+1);\\n        \\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i = 0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        return helper(traversal,0);\\n    }\\n    \\n    public TreeNode helper(String str, int depth){\\n        //d == number of dashes\\n        int d = 0;\\n        while(i+d < str.length() && str.charAt((i+d)) == \\'-\\'){\\n            d++;\\n        }\\n        \\n        //if dashes is not equal to depth add null \\n        if(d != depth){\\n            return null;\\n        }\\n        \\n        //nd --> Non dash \\n        int nd = 0;\\n        while((i+d+nd) < str.length() && str.charAt(i+d+nd) != \\'-\\'){\\n            nd++;\\n        }\\n        \\n\\t\\t//create val from dashes ending to non-dashes ending\\n        int val = Integer.parseInt(str.substring(i+d,i+d+nd));\\n        i = i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left = helper(str,depth+1);\\n        node.right = helper(str,depth+1);\\n        \\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074837,
                "title": "c-iterative-traversal-stack",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        t+=\"-\";\\n        int n=t.size();\\n        int c=0;\\n       \\n        vector<int>level;\\n        vector<int>nodes;\\n        \\n        for(int i=0;i<n;)\\n        {\\n            if(t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(i<n&&t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n                {\\n                    num=num*10+(t[i]-48);\\n                    i++;\\n                }\\n                nodes.push_back(num);\\n                level.push_back(c);\\n                c=0;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        \\n        TreeNode* root=new TreeNode(nodes[0]);\\n        stack<pair<TreeNode*,int>>st;\\n        st.push({root,0});\\n        \\n        for(int i=1;i<nodes.size();i++)\\n        {\\n            if(level[st.top().ss]<level[i])\\n                st.push({new TreeNode(nodes[i]),i});\\n            else\\n            {\\n                while(!st.empty()&&level[st.top().ss]>=level[i])\\n                {\\n                    TreeNode* l=st.top().ff;st.pop();\\n                    if(!st.empty())\\n                    {if(st.top().ff->left==NULL)st.top().ff->left=l;}\\n                }\\n                st.top().ff->right=new TreeNode(nodes[i]);\\n                st.push({st.top().ff->right,i});\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode* node=st.top().ff;st.pop();\\n            if(!st.empty())\\n            {\\n                if(st.top().ff->left==NULL)st.top().ff->left=node;\\n                else st.top().ff->right=node;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) \\n    {\\n        t+=\"-\";\\n        int n=t.size();\\n        int c=0;\\n       \\n        vector<int>level;\\n        vector<int>nodes;\\n        \\n        for(int i=0;i<n;)\\n        {\\n            if(t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n            {\\n                int num=0;\\n                while(i<n&&t[i]>=\\'0\\'&&t[i]<=\\'9\\')\\n                {\\n                    num=num*10+(t[i]-48);\\n                    i++;\\n                }\\n                nodes.push_back(num);\\n                level.push_back(c);\\n                c=0;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        \\n        TreeNode* root=new TreeNode(nodes[0]);\\n        stack<pair<TreeNode*,int>>st;\\n        st.push({root,0});\\n        \\n        for(int i=1;i<nodes.size();i++)\\n        {\\n            if(level[st.top().ss]<level[i])\\n                st.push({new TreeNode(nodes[i]),i});\\n            else\\n            {\\n                while(!st.empty()&&level[st.top().ss]>=level[i])\\n                {\\n                    TreeNode* l=st.top().ff;st.pop();\\n                    if(!st.empty())\\n                    {if(st.top().ff->left==NULL)st.top().ff->left=l;}\\n                }\\n                st.top().ff->right=new TreeNode(nodes[i]);\\n                st.push({st.top().ff->right,i});\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode* node=st.top().ff;st.pop();\\n            if(!st.empty())\\n            {\\n                if(st.top().ff->left==NULL)st.top().ff->left=node;\\n                else st.top().ff->right=node;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994477,
                "title": "c-iterative-stack-18-ms-faster-than-90-of-c-online-submissions",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        int n = traversal.size();\\n        \\n        stack<pair<TreeNode*, int>> st;\\n        \\n        while(p2 < n && traversal[p2] != \\'-\\')\\n            p2++;\\n        \\n        string str = traversal.substr(0, p2);\\n        \\n        TreeNode* root = new TreeNode(stoi(str));\\n        \\n        st.push({root, 0});\\n        \\n        while(p2 < n){\\n            while(p1 < n && traversal[p1] != \\'-\\'){\\n                p1++;\\n            }\\n            while(p2 < n && traversal[p2] == \\'-\\')\\n                p2++;\\n            \\n            int level = p2 - p1;\\n            \\n            p1 = p2;\\n            \\n            while(p2 < n && traversal[p2] != \\'-\\')\\n                p2++;\\n            \\n            int y = p2 - p1;\\n            \\n            string str = traversal.substr(p1, y);\\n            \\n            TreeNode* newNode = new TreeNode(stoi(str));\\n            \\n            while(st.top().second != level -1)\\n                st.pop();\\n            \\n            auto temp = st.top().first;\\n            \\n            if(!(temp -> left)){\\n                temp -> left = newNode;\\n            }else{\\n                temp -> right = newNode;\\n            }\\n            \\n            st.push({newNode, level});\\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        int p1 = 0;\\n        int p2 = 0;\\n        \\n        int n = traversal.size();\\n        \\n        stack<pair<TreeNode*, int>> st;\\n        \\n        while(p2 < n && traversal[p2] != \\'-\\')\\n            p2++;\\n        \\n        string str = traversal.substr(0, p2);\\n        \\n        TreeNode* root = new TreeNode(stoi(str));\\n        \\n        st.push({root, 0});\\n        \\n        while(p2 < n){\\n            while(p1 < n && traversal[p1] != \\'-\\'){\\n                p1++;\\n            }\\n            while(p2 < n && traversal[p2] == \\'-\\')\\n                p2++;\\n            \\n            int level = p2 - p1;\\n            \\n            p1 = p2;\\n            \\n            while(p2 < n && traversal[p2] != \\'-\\')\\n                p2++;\\n            \\n            int y = p2 - p1;\\n            \\n            string str = traversal.substr(p1, y);\\n            \\n            TreeNode* newNode = new TreeNode(stoi(str));\\n            \\n            while(st.top().second != level -1)\\n                st.pop();\\n            \\n            auto temp = st.top().first;\\n            \\n            if(!(temp -> left)){\\n                temp -> left = newNode;\\n            }else{\\n                temp -> right = newNode;\\n            }\\n            \\n            st.push({newNode, level});\\n            \\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960912,
                "title": "python-simple-iterative-solution-using-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, traversal):\\n        \"\"\"\\n        As, given input traversal is in the form of string. To process data we need to\\n        seperate out numbers and dashes.\\n\\n        maintain hashmap for each node and dashes.\\n        key - TreeNode object, value - number of dashes in front of respective number\\n\\n        Ex. traversal =  \"1--3---4\" \\n            treeMap = {TreeNode(1):0, TreeNode(3): 2, TreeNode(4): 3}\\n        \"\"\"\\n\\n        treeMap = {}\\n        traversal = traversal + \\'-\\'\\n        num = dash = \\'\\'\\n        stack = []\\n\\n        #loop through traversal to fill up treeMap\\n        for idx in range(len(traversal)):\\n            if traversal[idx] == \\'-\\':\\n                dash += \\'-\\'\\n            if traversal[idx].isnumeric():\\n                num += traversal[idx]\\n            if traversal[idx].isnumeric() and traversal[idx + 1] == \\'-\\':\\n                intNum = int(num)\\n                node = TreeNode(intNum)\\n                treeMap[node] = len(dash)\\n                num = dash = \\'\\'\\n\\n\\n                # use stack to create tree\\n                if not stack:\\n                    stack.append(node)\\n                else:\\n                    while(treeMap[stack[-1]] >= treeMap[node]):\\n                        stack.pop() \\n                    if not stack[-1].left:\\n                        stack[-1].left = node\\n                    else:\\n                        stack[-1].right = node\\n                    stack.append(node)\\n\\n        return stack[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\n\\nclass Solution(object):\\n    def recoverFromPreorder(self, traversal):\\n        \"\"\"\\n        As, given input traversal is in the form of string. To process data we need to\\n        seperate out numbers and dashes.\\n\\n        maintain hashmap for each node and dashes.\\n        key - TreeNode object, value - number of dashes in front of respective number\\n\\n        Ex. traversal =  \"1--3---4\" \\n            treeMap = {TreeNode(1):0, TreeNode(3): 2, TreeNode(4): 3}\\n        \"\"\"\\n\\n        treeMap = {}\\n        traversal = traversal + \\'-\\'\\n        num = dash = \\'\\'\\n        stack = []\\n\\n        #loop through traversal to fill up treeMap\\n        for idx in range(len(traversal)):\\n            if traversal[idx] == \\'-\\':\\n                dash += \\'-\\'\\n            if traversal[idx].isnumeric():\\n                num += traversal[idx]\\n            if traversal[idx].isnumeric() and traversal[idx + 1] == \\'-\\':\\n                intNum = int(num)\\n                node = TreeNode(intNum)\\n                treeMap[node] = len(dash)\\n                num = dash = \\'\\'\\n\\n\\n                # use stack to create tree\\n                if not stack:\\n                    stack.append(node)\\n                else:\\n                    while(treeMap[stack[-1]] >= treeMap[node]):\\n                        stack.pop() \\n                    if not stack[-1].left:\\n                        stack[-1].left = node\\n                    else:\\n                        stack[-1].right = node\\n                    stack.append(node)\\n\\n        return stack[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869558,
                "title": "c-dfs-single-string-traversal-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    void dfs(TreeNode* root, int& curr, int n, string& s, int lvl)\\n    {\\n        if(curr >= n)\\n            return;\\n        \\n        int d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            \\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->left = new TreeNode(num);\\n            dfs(root->left, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n        \\n        \\n        d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->right = new TreeNode(num);\\n            dfs(root->right, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string t) {\\n        \\n        int n = t.size();\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n        \\n        int curr = 0;\\n        int num = (int)t[curr] - 48;\\n        ++curr;\\n        while((curr<n)&&(t[curr] != \\'-\\'))\\n        {\\n            num = num*10 + ((int)t[curr] - 48);\\n            ++curr;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        \\n        dfs(root, curr, n, t, 1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    void dfs(TreeNode* root, int& curr, int n, string& s, int lvl)\\n    {\\n        if(curr >= n)\\n            return;\\n        \\n        int d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            \\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->left = new TreeNode(num);\\n            dfs(root->left, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n        \\n        \\n        d = 0;\\n        while((curr < n)&&(s[curr] == \\'-\\'))\\n        {\\n            ++d;\\n            ++curr;\\n        }\\n        \\n        if(d == lvl)\\n        {\\n            int num = (int)s[curr] - 48;\\n            ++curr;\\n            while((curr<n)&&(s[curr] != \\'-\\'))\\n            {\\n                num = num*10 + ((int)s[curr] - 48);\\n                ++curr;\\n            }\\n            root->right = new TreeNode(num);\\n            dfs(root->right, curr, n, s, lvl + 1);\\n        }\\n        else\\n        {\\n            curr -= d;\\n            return;\\n        }\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string t) {\\n        \\n        int n = t.size();\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n        \\n        int curr = 0;\\n        int num = (int)t[curr] - 48;\\n        ++curr;\\n        while((curr<n)&&(t[curr] != \\'-\\'))\\n        {\\n            num = num*10 + ((int)t[curr] - 48);\\n            ++curr;\\n        }\\n        \\n        TreeNode* root = new TreeNode(num);\\n        \\n        dfs(root, curr, n, t, 1);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841215,
                "title": "easy-to-understand-dfs-pointer-to-pointer-solution",
                "content": "Algo:\\n- Current Heigh (ch) equals to Expected height(eh), add new node here with the val. And regenerate new ch, and eh.\\n- if eh > ch, the next node should be in left as **\"If a node has only one child, that child is guaranteed to be the left child.\"**\\n- if again eh> ch, the next node should be in right side.\\n- if eh < ch, next node should be upper in the tree from current location. \\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    string traversal;\\npublic:\\n    void buildTree(TreeNode **node, int &eh,int ch,int &ci){\\n        /*\\n        *node=new TreeNode(5);\\n        \\n        cout<<(*node)->val<<\" \"<<&((*node)->left)<<endl;\\n        TreeNode **x=(&((*node)->left));\\n        *x=new TreeNode(6);\\n        cout<<(*x)->val<<endl;\\n        return;\\n        */\\n        //cout<<ch<<\" \"<<eh<<\" \"<<ci<<endl;\\n        if(ch==eh){\\n            stringstream ss;\\n            while(ci < traversal.length() && traversal[ci]!=\\'-\\'){\\n                ss<<traversal[ci];\\n                ci++;\\n            }\\n            int v;\\n            ss>>v;\\n            *node = new TreeNode(v);\\n            \\n            if(ci==traversal.length()) {\\n                eh=-1;\\n                return;\\n            }\\n            eh=1;\\n            while(traversal[++ci]==\\'-\\'){\\n                eh++;\\n            }\\n            \\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->left),eh,ch+1,ci);\\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->right),eh,ch+1,ci);\\n        }\\n        \\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        this->traversal=traversal;\\n        TreeNode *root;\\n        int eh=0,ci=0;\\n        \\n        buildTree(&root,eh,0,ci);\\n        //cout<<\"Finish\"<<endl;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    string traversal;\\npublic:\\n    void buildTree(TreeNode **node, int &eh,int ch,int &ci){\\n        /*\\n        *node=new TreeNode(5);\\n        \\n        cout<<(*node)->val<<\" \"<<&((*node)->left)<<endl;\\n        TreeNode **x=(&((*node)->left));\\n        *x=new TreeNode(6);\\n        cout<<(*x)->val<<endl;\\n        return;\\n        */\\n        //cout<<ch<<\" \"<<eh<<\" \"<<ci<<endl;\\n        if(ch==eh){\\n            stringstream ss;\\n            while(ci < traversal.length() && traversal[ci]!=\\'-\\'){\\n                ss<<traversal[ci];\\n                ci++;\\n            }\\n            int v;\\n            ss>>v;\\n            *node = new TreeNode(v);\\n            \\n            if(ci==traversal.length()) {\\n                eh=-1;\\n                return;\\n            }\\n            eh=1;\\n            while(traversal[++ci]==\\'-\\'){\\n                eh++;\\n            }\\n            \\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->left),eh,ch+1,ci);\\n        }\\n        if(eh> ch){\\n            buildTree(&((*node)->right),eh,ch+1,ci);\\n        }\\n        \\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        this->traversal=traversal;\\n        TreeNode *root;\\n        int eh=0,ci=0;\\n        \\n        buildTree(&root,eh,0,ci);\\n        //cout<<\"Finish\"<<endl;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1840180,
                "title": "java-recursive-code-should-be-clear-clean",
                "content": "```\\nclass Solution {\\n    private int index;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal == null || traversal.length() == 0) return null;\\n        \\n        index = 0;\\n        return buildIt(traversal, 0); \\n    }\\n    \\n    private TreeNode buildIt(String data, int level){\\n        if(index >= data.length()) return null; // end of string\\n        \\n        // get level\\n        int dashs = getDashs(data);\\n        if(dashs < level) return null; \\n        \\n        // correct level, adjust index\\n        index += dashs;\\n        \\n        // get number\\n        int val = getNumber(data);\\n        \\n        TreeNode root = new TreeNode(val);\\n        \\n        root.left = buildIt(data, level+1);\\n        root.right = buildIt(data, level+1); \\n        \\n        return root; \\n    }\\n    \\n    // do not move index, we need to know first if the \\n    // level is correct.\\n    private int getDashs(String s){\\n        int dashs = 0;\\n        while(s.charAt(index+dashs) == \\'-\\'){\\n            dashs++;\\n        }\\n        return dashs;\\n    }\\n    \\n    private int getNumber(String s){\\n        StringBuilder sb = new StringBuilder();\\n        while(index < s.length() && s.charAt(index) != \\'-\\'){\\n            sb.append(s.charAt(index++));\\n        }\\n        return Integer.parseInt(sb.toString()); \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private int index;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if(traversal == null || traversal.length() == 0) return null;\\n        \\n        index = 0;\\n        return buildIt(traversal, 0); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1771754,
                "title": "easy-python-solution-stack",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def find_level(self , s):\\n        if s[0] != \"-\":\\n            return 0 , s\\n        level = 0\\n        while(s[0] == \"-\"):\\n            level +=1\\n            s = s[1:]\\n        \\n        return (level , s)\\n    \\n    def find_num(self , s):\\n        if s[0] == \"-\":\\n            return None\\n        ans = \"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \"-\":\\n                break\\n            ans += s[i]\\n            count +=1\\n        \\n        return (int(ans) , s[count:])\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        \\n        s = traversal\\n        levels = []\\n        values = []\\n        while(s):\\n            level , s = self.find_level(s) \\n            num , s = self.find_num(s)\\n            levels.append(level)\\n            values.append(num)\\n        \\n        root = TreeNode(values[0])\\n        \\n        stack = [(root , 0)]\\n        for i in range(1 , len(values)):\\n            current_level = levels[i]\\n            current_val = values[i]\\n            \\n            while(stack and current_level <= stack[-1][1]):\\n                stack.pop()\\n            node , level = stack[-1]\\n            current_node = TreeNode(current_val)\\n            \\n            if node.left:\\n                node.right = current_node\\n            else:\\n                node.left = current_node\\n            \\n            stack.append((current_node, current_level))\\n        \\n        return stack[0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def find_level(self , s):\\n        if s[0] != \"-\":\\n            return 0 , s\\n        level = 0\\n        while(s[0] == \"-\"):\\n            level +=1\\n            s = s[1:]\\n        \\n        return (level , s)\\n    \\n    def find_num(self , s):\\n        if s[0] == \"-\":\\n            return None\\n        ans = \"\"\\n        count = 0\\n        for i in range(len(s)):\\n            if s[i] == \"-\":\\n                break\\n            ans += s[i]\\n            count +=1\\n        \\n        return (int(ans) , s[count:])\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        \\n        s = traversal\\n        levels = []\\n        values = []\\n        while(s):\\n            level , s = self.find_level(s) \\n            num , s = self.find_num(s)\\n            levels.append(level)\\n            values.append(num)\\n        \\n        root = TreeNode(values[0])\\n        \\n        stack = [(root , 0)]\\n        for i in range(1 , len(values)):\\n            current_level = levels[i]\\n            current_val = values[i]\\n            \\n            while(stack and current_level <= stack[-1][1]):\\n                stack.pop()\\n            node , level = stack[-1]\\n            current_node = TreeNode(current_val)\\n            \\n            if node.left:\\n                node.right = current_node\\n            else:\\n                node.left = current_node\\n            \\n            stack.append((current_node, current_level))\\n        \\n        return stack[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684682,
                "title": "c-stack-solution-beats-91",
                "content": "Assume the dashes(\"-\") as the height of the node from the root , if the # of dashes are greater than that of the stack top element , that means it is it\\'s child , and if\\n\\nthe # of dashes are less than that of the stack top element then pop from the stack. It is a recursive approach but done via a stack :) .\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n    \\n        stack<pair<TreeNode *,int>> st;\\n        \\n        int i=0;\\n        int n=s.size();\\n        while(i<n)\\n        {\\n            string val=\"\";\\n            int dashes=0;\\n            while( i<n && s[i]==\\'-\\')\\n            {\\n                dashes++;\\n                i++;\\n            }\\n            while(i<n && s[i]!=\\'-\\')\\n                val+=s[i++];\\n            int num=stoi(val);\\n            TreeNode * newNode =new TreeNode(num); \\n            if(st.empty())\\n            {\\n                st.push({newNode,dashes});                \\n            }\\n            else\\n            {\\n                while(!st.empty() && st.top().second>=dashes)\\n                    st.pop();\\n                \\n                if(st.top().first->left==NULL)\\n                    st.top().first->left=newNode;\\n                else \\n                    st.top().first->right=newNode;\\n                \\n                st.push({newNode,dashes});\\n                    \\n            }\\n                \\n        }\\n        while(st.size()!=1)\\n            st.pop();\\n        return st.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n    \\n        stack<pair<TreeNode *,int>> st;\\n        \\n        int i=0;\\n        int n=s.size();\\n        while(i<n)\\n        {\\n            string val=\"\";\\n            int dashes=0;\\n            while( i<n && s[i]==\\'-\\')\\n            {\\n                dashes++;\\n                i++;\\n            }\\n            while(i<n && s[i]!=\\'-\\')\\n                val+=s[i++];\\n            int num=stoi(val);\\n            TreeNode * newNode =new TreeNode(num); \\n            if(st.empty())\\n            {\\n                st.push({newNode,dashes});                \\n            }\\n            else\\n            {\\n                while(!st.empty() && st.top().second>=dashes)\\n                    st.pop();\\n                \\n                if(st.top().first->left==NULL)\\n                    st.top().first->left=newNode;\\n                else \\n                    st.top().first->right=newNode;\\n                \\n                st.push({newNode,dashes});\\n                    \\n            }\\n                \\n        }\\n        while(st.size()!=1)\\n            st.pop();\\n        return st.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569363,
                "title": "c-unordered-map-based-approach",
                "content": "```\\nclass Solution {\\npublic:    \\n    TreeNode* recoverFromPreorder(string st) {\\n        unordered_map<int,queue<TreeNode*>> mapi;\\n        \\n        int i=0;\\n        string num = \"\";\\n        while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n        }\\n        int numbu = stoi(num);\\n        TreeNode* root = new TreeNode(numbu);\\n        mapi[0].push(root);\\n        \\n        while(i < st.size()){\\n            int depth = 0;\\n            while(st[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n            }\\n            int k = depth;\\n            while(mapi.find(k)!=mapi.end()){\\n                mapi.erase(k);\\n                k++;\\n            } \\n            string num = \"\";\\n            while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n            }\\n            int numb = stoi(num);\\n            \\n            TreeNode * temp = mapi[depth-1].front();\\n            \\n            TreeNode* temp1 = new TreeNode(numb);\\n            \\n            if(temp->left == NULL){\\n                temp->left = temp1;\\n            } else {\\n                temp->right = temp1;\\n            }\\n            \\n            if(temp->left&&temp->right){\\n                mapi[depth-1].pop();\\n            }\\n            mapi[depth].push(temp1);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    TreeNode* recoverFromPreorder(string st) {\\n        unordered_map<int,queue<TreeNode*>> mapi;\\n        \\n        int i=0;\\n        string num = \"\";\\n        while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n        }\\n        int numbu = stoi(num);\\n        TreeNode* root = new TreeNode(numbu);\\n        mapi[0].push(root);\\n        \\n        while(i < st.size()){\\n            int depth = 0;\\n            while(st[i] == \\'-\\'){\\n                depth++;\\n                i++;\\n            }\\n            int k = depth;\\n            while(mapi.find(k)!=mapi.end()){\\n                mapi.erase(k);\\n                k++;\\n            } \\n            string num = \"\";\\n            while(i<st.size()&&st[i]!=\\'-\\'){\\n                num = num + st[i];\\n                i++;\\n            }\\n            int numb = stoi(num);\\n            \\n            TreeNode * temp = mapi[depth-1].front();\\n            \\n            TreeNode* temp1 = new TreeNode(numb);\\n            \\n            if(temp->left == NULL){\\n                temp->left = temp1;\\n            } else {\\n                temp->right = temp1;\\n            }\\n            \\n            if(temp->left&&temp->right){\\n                mapi[depth-1].pop();\\n            }\\n            mapi[depth].push(temp1);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530376,
                "title": "java-stack-solution",
                "content": "```\\n// Stack Solution\\n// Keep the top element in stack is the parent of current node.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if (traversal == null || traversal.isEmpty()) return null;\\n        final int L = traversal.length();\\n        TreeNode root = null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        int idx = 0;\\n        while (idx < L) {\\n            int depth = 0;\\n            while (idx < L && traversal.charAt(idx) == \\'-\\') {\\n                idx++;\\n                depth++;\\n            }\\n            int val = 0;\\n            while (idx < L && traversal.charAt(idx) != \\'-\\') {\\n                val = traversal.charAt(idx) - \\'0\\' + val * 10;\\n                idx++;\\n            }\\n            while (stack.size() > depth) { // Pop the nodes at same level or below.\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                TreeNode parent = stack.peek();\\n                if (parent.left == null) {\\n                    parent.left = node;\\n                } else {\\n                    parent.right = node;\\n                }\\n            }\\n            stack.push(node);\\n            if (root == null) root = node;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Stack Solution\\n// Keep the top element in stack is the parent of current node.\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        if (traversal == null || traversal.isEmpty()) return null;\\n        final int L = traversal.length();\\n        TreeNode root = null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        int idx = 0;\\n        while (idx < L) {\\n            int depth = 0;\\n            while (idx < L && traversal.charAt(idx) == \\'-\\') {\\n                idx++;\\n                depth++;\\n            }\\n            int val = 0;\\n            while (idx < L && traversal.charAt(idx) != \\'-\\') {\\n                val = traversal.charAt(idx) - \\'0\\' + val * 10;\\n                idx++;\\n            }\\n            while (stack.size() > depth) { // Pop the nodes at same level or below.\\n                stack.pop();\\n            }\\n            TreeNode node = new TreeNode(val);\\n            if (!stack.isEmpty()) {\\n                TreeNode parent = stack.peek();\\n                if (parent.left == null) {\\n                    parent.left = node;\\n                } else {\\n                    parent.right = node;\\n                }\\n            }\\n            stack.push(node);\\n            if (root == null) root = node;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495610,
                "title": "cpp-simple-understandable-code",
                "content": "```\\nstring s;\\n    int p = 0;\\n    \\n    int Getnum(){\\n        int temp = 0;\\n        while(p < s.size() && s[p] != \\'-\\'){\\n            temp *= 10;\\n            temp += (int)(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return temp;\\n    }\\n    \\n    int getdepth(){\\n        int cnt = 0;\\n        while(p < s.size() && s[p] == \\'-\\'){\\n            cnt++;\\n            p++;\\n        }\\n        return cnt;\\n    }\\n    \\n    TreeNode* find(TreeNode* root, int depth){\\n        \\n        int cnt = getdepth();\\n        if(cnt != depth){ \\n            p -= cnt;\\n            return NULL;\\n        }\\n        \\n        int num = Getnum();\\n        \\n        root = new TreeNode(num);\\n        root->left = find(root->left, depth+1);\\n        root->right = find(root->right, depth+1);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        TreeNode* root = NULL;\\n        this->s = traversal;\\n        \\n        root = find(root, 0);\\n        \\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring s;\\n    int p = 0;\\n    \\n    int Getnum(){\\n        int temp = 0;\\n        while(p < s.size() && s[p] != \\'-\\'){\\n            temp *= 10;\\n            temp += (int)(s[p] - \\'0\\');\\n            p++;\\n        }\\n        return temp;\\n    }\\n    \\n    int getdepth(){\\n        int cnt = 0;\\n        while(p < s.size() && s[p] == \\'-\\'){\\n            cnt++;\\n            p++;\\n        }\\n        return cnt;\\n    }\\n    \\n    TreeNode* find(TreeNode* root, int depth){\\n        \\n        int cnt = getdepth();\\n        if(cnt != depth){ \\n            p -= cnt;\\n            return NULL;\\n        }\\n        \\n        int num = Getnum();\\n        \\n        root = new TreeNode(num);\\n        root->left = find(root->left, depth+1);\\n        root->right = find(root->right, depth+1);\\n        \\n        return root;\\n        \\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        \\n        TreeNode* root = NULL;\\n        this->s = traversal;\\n        \\n        root = find(root, 0);\\n        \\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460447,
                "title": "python-3-python-recover-a-tree-from-preorder-traversal",
                "content": "```\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack=[]\\n        res=\\'\\'\\n        i=0\\n        while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n            res+=traversal[i]\\n            i+=1\\n        root=TreeNode()\\n        root.val=int(res)\\n        stack=[[0,root]]\\n        while i<len(traversal):\\n            count=0\\n            while i<len(traversal) and traversal[i]<=\\'-\\':\\n                count+=1\\n                i+=1\\n            res=\\'\\'\\n            while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n                res+=traversal[i]\\n                i+=1\\n            node=TreeNode()\\n            node.val=int(res)\\n            while stack and stack[-1][0]!=count-1:\\n                stack.pop()\\n            if stack[-1][1].left==None:\\n                stack[-1][1].left=node\\n            else:\\n                stack[-1][1].right=node\\n            stack.append([count,node])\\n        return root\\n                \\n            \\n            \\n            \\n            \\n       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack=[]\\n        res=\\'\\'\\n        i=0\\n        while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n            res+=traversal[i]\\n            i+=1\\n        root=TreeNode()\\n        root.val=int(res)\\n        stack=[[0,root]]\\n        while i<len(traversal):\\n            count=0\\n            while i<len(traversal) and traversal[i]<=\\'-\\':\\n                count+=1\\n                i+=1\\n            res=\\'\\'\\n            while i<len(traversal) and \\'0\\'<= traversal[i]<=\\'9\\':\\n                res+=traversal[i]\\n                i+=1\\n            node=TreeNode()\\n            node.val=int(res)\\n            while stack and stack[-1][0]!=count-1:\\n                stack.pop()\\n            if stack[-1][1].left==None:\\n                stack[-1][1].left=node\\n            else:\\n                stack[-1][1].right=node\\n            stack.append([count,node])\\n        return root\\n                \\n            \\n            \\n            \\n            \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345076,
                "title": "c-simple-recursive-preorder",
                "content": "Store the values in pre order along with their depth. Then create a tree with the matching depth and values. Return NULL when the depth doesn\\'t match or the preorder traversal ends.\\n\\n```\\nclass Solution {\\n    vector <pair<int,int>> v;\\n    int idx = 0;\\npublic:\\n    TreeNode* preOrder(int depth){\\n        if(idx>=v.size() || depth != v[idx].first)\\n            return NULL;\\n        TreeNode* root = new TreeNode(v[idx].second);\\n        idx += 1;\\n        root->left = preOrder(depth+1);\\n        root->right = preOrder(depth+1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int dash = 0;\\n        int num=traversal[0] - \\'0\\';\\n        for(int i=1;i<traversal.size();i++){\\n            if(traversal[i] == \\'-\\'){\\n                if(traversal[i-1] != \\'-\\'){\\n                    v.push_back({dash,num});\\n                    dash = 0;\\n                    num = 0;\\n                }\\n                dash++;\\n            }else{\\n                num = num*10 + traversal[i] - \\'0\\';\\n            }\\n        }\\n        v.push_back({dash,num});\\n        return preOrder(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector <pair<int,int>> v;\\n    int idx = 0;\\npublic:\\n    TreeNode* preOrder(int depth){\\n        if(idx>=v.size() || depth != v[idx].first)\\n            return NULL;\\n        TreeNode* root = new TreeNode(v[idx].second);\\n        idx += 1;\\n        root->left = preOrder(depth+1);\\n        root->right = preOrder(depth+1);\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int dash = 0;\\n        int num=traversal[0] - \\'0\\';\\n        for(int i=1;i<traversal.size();i++){\\n            if(traversal[i] == \\'-\\'){\\n                if(traversal[i-1] != \\'-\\'){\\n                    v.push_back({dash,num});\\n                    dash = 0;\\n                    num = 0;\\n                }\\n                dash++;\\n            }else{\\n                num = num*10 + traversal[i] - \\'0\\';\\n            }\\n        }\\n        v.push_back({dash,num});\\n        return preOrder(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189399,
                "title": "recursive-simple-approach-c",
                "content": "- We recursively find required level and curr level,by calculating the no of \"-\" and if curr and req level match then it is going to be a child.\\n- Else we return NULL.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nint i=0;\\nclass Solution {\\npublic:\\n    //converting the given string to a number\\n    int convert(vector<int> vect){\\n        int j=vect.size()-1,k=0,m=0;\\n        while(j>=0){\\n            m+=vect[j]*pow(10,k);\\n            k++;j--;\\n        }\\n        return m;\\n    }\\n    //Recursively genrating the tree form string S\\n    TreeNode *construct(string S,int req_level){\\n           int j=i,curr_level=0;\\n           if(i==S.size()) return NULL;\\n           j--;\\n           while(j>=0 && S[j]==\\'-\\'){\\n               curr_level++;\\n               j--;\\n           }\\n           //if current level is not equal to required level return NULL\\n           if(curr_level!=req_level) return NULL;\\n           vector<int> vect;\\n           while(i!=S.size() && S[i]!=\\'-\\'){\\n               vect.push_back(S[i]-\\'0\\');\\n               i++;\\n           }\\n           while(i!=S.size() && S[i]==\\'-\\') i++;\\n           int num = convert(vect);\\n           TreeNode *node = new TreeNode(num);\\n           node->left = construct(S,curr_level+1);\\n           node->right = construct(S,curr_level+1);\\n           return node;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        i=0;\\n        TreeNode *root = construct(S,0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nint i=0;\\nclass Solution {\\npublic:\\n    //converting the given string to a number\\n    int convert(vector<int> vect){\\n        int j=vect.size()-1,k=0,m=0;\\n        while(j>=0){\\n            m+=vect[j]*pow(10,k);\\n            k++;j--;\\n        }\\n        return m;\\n    }\\n    //Recursively genrating the tree form string S\\n    TreeNode *construct(string S,int req_level){\\n           int j=i,curr_level=0;\\n           if(i==S.size()) return NULL;\\n           j--;\\n           while(j>=0 && S[j]==\\'-\\'){\\n               curr_level++;\\n               j--;\\n           }\\n           //if current level is not equal to required level return NULL\\n           if(curr_level!=req_level) return NULL;\\n           vector<int> vect;\\n           while(i!=S.size() && S[i]!=\\'-\\'){\\n               vect.push_back(S[i]-\\'0\\');\\n               i++;\\n           }\\n           while(i!=S.size() && S[i]==\\'-\\') i++;\\n           int num = convert(vect);\\n           TreeNode *node = new TreeNode(num);\\n           node->left = construct(S,curr_level+1);\\n           node->right = construct(S,curr_level+1);\\n           return node;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        i=0;\\n        TreeNode *root = construct(S,0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107935,
                "title": "c-faster-than-48-o-n-single-pass-with-hashmap",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string S) {\\n        Dictionary<int, TreeNode> _lastAtLevel = new Dictionary<int, TreeNode>();\\n        \\n        int currentLevel=0;\\n        int lastIndex=0;\\n        \\n        while(lastIndex<S.Length){\\n            currentLevel=0;\\n            \\n            while(lastIndex<S.Length && S[lastIndex]==\\'-\\'){\\n                lastIndex++;\\n                currentLevel++;\\n            }\\n\\n            int valStartIndex = lastIndex;\\n\\n            while(lastIndex<S.Length && S[lastIndex]!=\\'-\\'){\\n                lastIndex++;\\n            }\\n\\n            string val=S.Substring(valStartIndex, lastIndex-valStartIndex);\\n\\n            TreeNode tn = new TreeNode(int.Parse(val));\\n\\n            if(currentLevel>0){\\n                TreeNode parent = _lastAtLevel[currentLevel-1];\\n\\n                if(parent.left==null){\\n                    parent.left = tn;\\n                }\\n                else{\\n                    parent.right = tn;\\n                }\\n            }\\n\\n            _lastAtLevel[currentLevel]=tn;\\n        }\\n        \\n        return _lastAtLevel[0];\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string S) {\\n        Dictionary<int, TreeNode> _lastAtLevel = new Dictionary<int, TreeNode>();\\n        \\n        int currentLevel=0;\\n        int lastIndex=0;\\n        \\n        while(lastIndex<S.Length){\\n            currentLevel=0;\\n            \\n            while(lastIndex<S.Length && S[lastIndex]==\\'-\\'){\\n                lastIndex++;\\n                currentLevel++;\\n            }\\n\\n            int valStartIndex = lastIndex;\\n\\n            while(lastIndex<S.Length && S[lastIndex]!=\\'-\\'){\\n                lastIndex++;\\n            }\\n\\n            string val=S.Substring(valStartIndex, lastIndex-valStartIndex);\\n\\n            TreeNode tn = new TreeNode(int.Parse(val));\\n\\n            if(currentLevel>0){\\n                TreeNode parent = _lastAtLevel[currentLevel-1];\\n\\n                if(parent.left==null){\\n                    parent.left = tn;\\n                }\\n                else{\\n                    parent.right = tn;\\n                }\\n            }\\n\\n            _lastAtLevel[currentLevel]=tn;\\n        }\\n        \\n        return _lastAtLevel[0];\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047405,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\n    TreeNode* helper(const string& str, int& idx, int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        \\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n        \\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        \\n        TreeNode* node = new TreeNode(val);\\n        node->left = helper(str, idx, curDepth + 1);\\n        node->right = helper(str, idx, curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int idx = 0;\\n        return helper(S, idx, 0);\\n    }\\n};\\n```\\n\\n\\nSlightly refactored:\\n```\\nclass Solution {\\n    int idx = 0;\\n    string str;\\n    \\n    int getDepth() {\\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        return depth;\\n    }\\n    \\n    int getVal() {\\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* helper(int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        auto depth = getDepth();\\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n                \\n        auto node = new TreeNode(getVal());\\n        node->left = helper(curDepth + 1);\\n        node->right = helper(curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        str = S;\\n        return helper(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeNode* helper(const string& str, int& idx, int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        \\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n        \\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        \\n        TreeNode* node = new TreeNode(val);\\n        node->left = helper(str, idx, curDepth + 1);\\n        node->right = helper(str, idx, curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int idx = 0;\\n        return helper(S, idx, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int idx = 0;\\n    string str;\\n    \\n    int getDepth() {\\n        int depth = 0;\\n        while (idx < str.size() && str[idx] == \\'-\\') {\\n            ++depth;\\n            ++idx;\\n        }\\n        return depth;\\n    }\\n    \\n    int getVal() {\\n        int val = 0;\\n        while (idx < str.size() && isdigit(str[idx])) {\\n            val = val * 10 + str[idx] - \\'0\\';\\n            ++idx;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* helper(int curDepth) {\\n        if (idx == str.size()) return nullptr;\\n        \\n        auto depth = getDepth();\\n        if (depth < curDepth) {\\n            idx -= depth;\\n            return nullptr;\\n        }\\n                \\n        auto node = new TreeNode(getVal());\\n        node->left = helper(curDepth + 1);\\n        node->right = helper(curDepth + 1);\\n        \\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        str = S;\\n        return helper(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958849,
                "title": "using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        int n = S.length();\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        int i = 0;\\n        TreeNode ans = new TreeNode(-1);\\n        stack.addLast(new Pair(ans, -1)); // temp node\\n        while (i < n) {\\n            int d = 0; //depth\\n            while (i < n && S.charAt(i) == \\'-\\') {\\n                d++; i++;\\n            }\\n            int num = 0;\\n            while (i < n && (S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\')) {\\n                num = num * 10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode cur = new TreeNode(num);\\n            // if we see the new node depth as stack[-1].d + 1, then \\n            // add this node as left to top of stack node\\n            if (stack.getLast().getValue()+1 == d) {\\n                TreeNode top = stack.getLast().getKey();\\n                top.left = cur; \\n            } else {\\n                // pop stack till we get stack[-1].d+1 == d\\n                while (stack.getLast().getValue()+1 != d) {\\n                    stack.removeLast();\\n                }\\n                TreeNode top = stack.getLast().getKey();\\n                top.right = cur;\\n            }\\n            stack.addLast(new Pair(cur, d));\\n        }\\n        return ans.left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        int n = S.length();\\n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque<>();\\n        int i = 0;\\n        TreeNode ans = new TreeNode(-1);\\n        stack.addLast(new Pair(ans, -1)); // temp node\\n        while (i < n) {\\n            int d = 0; //depth\\n            while (i < n && S.charAt(i) == \\'-\\') {\\n                d++; i++;\\n            }\\n            int num = 0;\\n            while (i < n && (S.charAt(i) >= \\'0\\' && S.charAt(i) <= \\'9\\')) {\\n                num = num * 10 + (S.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode cur = new TreeNode(num);\\n            // if we see the new node depth as stack[-1].d + 1, then \\n            // add this node as left to top of stack node\\n            if (stack.getLast().getValue()+1 == d) {\\n                TreeNode top = stack.getLast().getKey();\\n                top.left = cur; \\n            } else {\\n                // pop stack till we get stack[-1].d+1 == d\\n                while (stack.getLast().getValue()+1 != d) {\\n                    stack.removeLast();\\n                }\\n                TreeNode top = stack.getLast().getKey();\\n                top.right = cur;\\n            }\\n            stack.addLast(new Pair(cur, d));\\n        }\\n        return ans.left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925378,
                "title": "simple-java-solution-for-slow-learners-like-myself-using-2-queues",
                "content": "//Runtime: O(n) to parse string and build queue, O(n) to build tree from queue -> O(n) where n is the length of string\\n//Space: O(n + h) where h is depth of expected tree\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        s = s == null ? \"\" : s;\\n        \\n        Queue<Integer> numQueue = new LinkedList<>(), dashQueue = new LinkedList<>();\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            int num = 0, dash = 0;\\n            \\n            while (i < s.length() && s.charAt(i) == \\'-\\') {\\n                dash++;\\n                i++;\\n            }\\n\\n            while (i < s.length() && s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') \\n                num = num * 10 + (s.charAt(i++) - \\'0\\');\\n            \\n            numQueue.offer(num);\\n            dashQueue.offer(dash);\\n        }\\n\\n        return build(numQueue, dashQueue, 0);\\n    }\\n    \\n\\n    private TreeNode build(Queue<Integer> numQueue, Queue<Integer> dashQueue, int level) {\\n        if (dashQueue.isEmpty() || dashQueue.peek() != level) \\n            return null;\\n        \\n        int num = numQueue.poll();\\n        dashQueue.poll();\\n        \\n        TreeNode root = new TreeNode(num);\\n        root.left = build(numQueue, dashQueue, level + 1);\\n        root.right = build(numQueue, dashQueue, level + 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        s = s == null ? \"\" : s;\\n        \\n        Queue<Integer> numQueue = new LinkedList<>(), dashQueue = new LinkedList<>();\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            int num = 0, dash = 0;\\n            \\n            while (i < s.length() && s.charAt(i) == \\'-\\') {\\n                dash++;\\n                i++;\\n            }\\n\\n            while (i < s.length() && s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') \\n                num = num * 10 + (s.charAt(i++) - \\'0\\');\\n            \\n            numQueue.offer(num);\\n            dashQueue.offer(dash);\\n        }\\n\\n        return build(numQueue, dashQueue, 0);\\n    }\\n    \\n\\n    private TreeNode build(Queue<Integer> numQueue, Queue<Integer> dashQueue, int level) {\\n        if (dashQueue.isEmpty() || dashQueue.peek() != level) \\n            return null;\\n        \\n        int num = numQueue.poll();\\n        dashQueue.poll();\\n        \\n        TreeNode root = new TreeNode(num);\\n        root.left = build(numQueue, dashQueue, level + 1);\\n        root.right = build(numQueue, dashQueue, level + 1);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900032,
                "title": "java-dfs-solution",
                "content": "1. If number of \"-\" are 1 more than current level insert a node to the left or right..\\n2. If number of \"-\" are <= current level return back to upper level.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    TreeNode root = null;\\n    String S = null;\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S.isEmpty())\\n            return null;\\n        this.S=S;\\n        String number = \"\";\\n        while(i<S.length() && Character.isDigit(S.charAt(i))){\\n            number+=S.charAt(i);\\n            i++;\\n        }\\n        root=new TreeNode(Integer.valueOf(number));\\n        recover(root,0);\\n        return root;\\n    }\\n    \\n    \\n    public int recover(TreeNode root,int level){\\n        if(i==S.length())\\n            return 0;\\n        int count=0;\\n        while(S.charAt(i)==\\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count==level+1){\\n                if(root.left==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                        number+=S.charAt(i);\\n                        i++;\\n                    }\\n                    root.left=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.left,level+1);\\n                    if(x<=level){\\n                        return x;\\n                    }\\n                } \\n                if(root.right==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                    number+=S.charAt(i);\\n                    i++;\\n                    }\\n                    root.right=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.right,level+1);\\n                    if(x<=level)\\n                    return x;\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    TreeNode root = null;\\n    String S = null;\\n    public TreeNode recoverFromPreorder(String S) {\\n        if(S.isEmpty())\\n            return null;\\n        this.S=S;\\n        String number = \"\";\\n        while(i<S.length() && Character.isDigit(S.charAt(i))){\\n            number+=S.charAt(i);\\n            i++;\\n        }\\n        root=new TreeNode(Integer.valueOf(number));\\n        recover(root,0);\\n        return root;\\n    }\\n    \\n    \\n    public int recover(TreeNode root,int level){\\n        if(i==S.length())\\n            return 0;\\n        int count=0;\\n        while(S.charAt(i)==\\'-\\'){\\n            count++;\\n            i++;\\n        }\\n        if(count==level+1){\\n                if(root.left==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                        number+=S.charAt(i);\\n                        i++;\\n                    }\\n                    root.left=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.left,level+1);\\n                    if(x<=level){\\n                        return x;\\n                    }\\n                } \\n                if(root.right==null){\\n                    String number = \"\";\\n                    while(i<S.length() && Character.isDigit(S.charAt(i))){\\n                    number+=S.charAt(i);\\n                    i++;\\n                    }\\n                    root.right=new TreeNode(Integer.valueOf(number));\\n                    int x =  recover(root.right,level+1);\\n                    if(x<=level)\\n                    return x;\\n                }\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842076,
                "title": "java-without-recursion-queue-or-stack",
                "content": "Solution relies on straight forward observation that if I am currently considering node of deapth D, its parent will be most recently visited node with deapth [D-1]. And this will hold true for preorder traversal.\\n\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        int cur = 0;\\n        int n = s.length();\\n        char[] a = s.toCharArray();\\n        HashMap<Integer, TreeNode> lastNodeAtDeapth = new HashMap<>();\\n        \\n        // Root is always first, find its value.\\n        int val = 0;\\n        while (cur < n && a[cur] != \\'-\\') {\\n            val *= 10;\\n            val += (a[cur] - \\'0\\');\\n            cur++;\\n        }\\n        \\n        TreeNode root = new TreeNode(val);\\n        lastNodeAtDeapth.put(0, root);\\n        \\n        while (cur < n) {\\n            int deapth = 0;\\n            while (cur < n && a[cur] == \\'-\\') {\\n                deapth++;\\n                cur++;\\n            }\\n            int curVal = 0;\\n            while (cur < n && a[cur] != \\'-\\') {\\n                curVal *= 10;\\n                curVal += (a[cur] - \\'0\\');\\n                cur++;\\n            }\\n            TreeNode node = new TreeNode(curVal);\\n            lastNodeAtDeapth.put(deapth, node);\\n            TreeNode parent = lastNodeAtDeapth.get(deapth - 1);\\n            if (parent.left == null)\\n                parent.left = node;\\n            else \\n                parent.right = node;\\n        }\\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String s) {\\n        int cur = 0;\\n        int n = s.length();\\n        char[] a = s.toCharArray();\\n        HashMap<Integer, TreeNode> lastNodeAtDeapth = new HashMap<>();\\n        \\n        // Root is always first, find its value.\\n        int val = 0;\\n        while (cur < n && a[cur] != \\'-\\') {\\n            val *= 10;\\n            val += (a[cur] - \\'0\\');\\n            cur++;\\n        }\\n        \\n        TreeNode root = new TreeNode(val);\\n        lastNodeAtDeapth.put(0, root);\\n        \\n        while (cur < n) {\\n            int deapth = 0;\\n            while (cur < n && a[cur] == \\'-\\') {\\n                deapth++;\\n                cur++;\\n            }\\n            int curVal = 0;\\n            while (cur < n && a[cur] != \\'-\\') {\\n                curVal *= 10;\\n                curVal += (a[cur] - \\'0\\');\\n                cur++;\\n            }\\n            TreeNode node = new TreeNode(curVal);\\n            lastNodeAtDeapth.put(deapth, node);\\n            TreeNode parent = lastNodeAtDeapth.get(deapth - 1);\\n            if (parent.left == null)\\n                parent.left = node;\\n            else \\n                parent.right = node;\\n        }\\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776700,
                "title": "simple-python-solution-with-a-stack",
                "content": "A simple Python solution that uses `re` for parsing and a stack for appending tree nodes.\\n\\n```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n    import re\\n    if not S:\\n        return None\\n    groups = re.findall(r\\'(-*)([^-]+)\\', S)\\n    pending = [TreeNode(int(groups[0][1]))]\\n    for g in groups[1:]:\\n        depth = len(g[0])\\n        val = int(g[1])\\n        if depth >= len(pending):\\n            pending[-1].left = TreeNode(val)\\n            pending.append(pending[-1].left)\\n        else:\\n            del pending[depth:]\\n            pending[-1].right = TreeNode(val)\\n            pending.append(pending[-1].right)\\n    return pending[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef recoverFromPreorder(self, S: str) -> TreeNode:\\n    import re\\n    if not S:\\n        return None\\n    groups = re.findall(r\\'(-*)([^-]+)\\', S)\\n    pending = [TreeNode(int(groups[0][1]))]\\n    for g in groups[1:]:\\n        depth = len(g[0])\\n        val = int(g[1])\\n        if depth >= len(pending):\\n            pending[-1].left = TreeNode(val)\\n            pending.append(pending[-1].left)\\n        else:\\n            del pending[depth:]\\n            pending[-1].right = TreeNode(val)\\n            pending.append(pending[-1].right)\\n    return pending[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 730295,
                "title": "c-solution-using-hash-map-time-o-n-space-o-h-h-height-of-the-tree",
                "content": "For explanation and better understanding refer to the link below:\\nhttps://docs.google.com/document/d/1gFIH55uhUHdLtvBErh9tQLf4pBf-KGBeMHtz2z0d1Is/edit?usp=sharing\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newnode(int data)\\n    {\\n        TreeNode* n=new TreeNode;\\n        n->val=data;\\n        n->left=NULL;\\n        n->right=NULL;\\n        return n;\\n    }\\n    TreeNode* recoverFromPreorder(string S) {\\n        \\n        unordered_map<int,TreeNode*> level;\\n        TreeNode* root;\\n        int i,c=0;\\n        for(i=0;i<S.size();)\\n        {\\n            if(S[i]==\\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            else\\n            {\\n                string n=\"\";\\n                while(i<S.size()&&S[i]>=\\'0\\'&&S[i]<=\\'9\\')\\n                {\\n                    n+=S[i];   \\n                    i++;\\n                }\\n                level[c]=newnode(stoi(n));\\n                if(c>0)\\n                {\\n                    TreeNode* parent=level[c-1];\\n                    if(!parent->left)\\n                        parent->left=level[c];\\n                    else\\n                        parent->right=level[c];\\n                }\\n                else\\n                    root=level[c];\\n                c=0;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* newnode(int data)\\n    {\\n        TreeNode* n=new TreeNode;\\n        n->val=data;\\n        n->left=NULL;\\n        n->right=NULL;\\n        return n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 683190,
                "title": "c-simple-solution-using-memoization",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, vector<TreeNode*>> vmap;\\n        int idx = 0, dash = 0, val = 0;\\n        while (idx < S.length()) {\\n            //cout << idx << \":\" << dash << \":\" << val << endl;\\n            if (isdigit(S[idx])) {\\n                val = val * 10 + (S[idx] - \\'0\\');\\n                if ((idx + 1 < S.length() && S[idx + 1] == \\'-\\') ||\\n                   (idx == S.length() - 1)) {\\n                    \\n                    TreeNode* nd = new TreeNode(val);\\n                    if (dash == 0) {\\n                        vmap[0].push_back(nd);\\n                    } else {\\n                        int n = vmap[dash - 1].size();\\n                        if (vmap[dash - 1][n - 1]->left == NULL)  vmap[dash - 1][n - 1]->left = nd;\\n                        else vmap[dash - 1][n - 1]->right = nd;\\n                        vmap[dash].push_back(nd);\\n                    }\\n                    dash = 0;\\n                } \\n            } else {\\n                val = 0;\\n                dash++;\\n            }\\n            idx++;\\n        }\\n        return vmap[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, vector<TreeNode*>> vmap;\\n        int idx = 0, dash = 0, val = 0;\\n        while (idx < S.length()) {\\n            //cout << idx << \":\" << dash << \":\" << val << endl;\\n            if (isdigit(S[idx])) {\\n                val = val * 10 + (S[idx] - \\'0\\');\\n                if ((idx + 1 < S.length() && S[idx + 1] == \\'-\\') ||\\n                   (idx == S.length() - 1)) {\\n                    \\n                    TreeNode* nd = new TreeNode(val);\\n                    if (dash == 0) {\\n                        vmap[0].push_back(nd);\\n                    } else {\\n                        int n = vmap[dash - 1].size();\\n                        if (vmap[dash - 1][n - 1]->left == NULL)  vmap[dash - 1][n - 1]->left = nd;\\n                        else vmap[dash - 1][n - 1]->right = nd;\\n                        vmap[dash].push_back(nd);\\n                    }\\n                    dash = 0;\\n                } \\n            } else {\\n                val = 0;\\n                dash++;\\n            }\\n            idx++;\\n        }\\n        return vmap[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 669992,
                "title": "c-solution-preorder-traverse-using-stack-or-vector",
                "content": "```\\nclass Solution {\\n  private:\\n    int idx, N;\\n    int nextInt(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]!=\\'-\\')\\n        ++idx;\\n      return stoi(s.substr(p, idx-p));\\n    }\\n    int nextDepth(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]==\\'-\\')\\n        ++idx;\\n      return idx-p;\\n    }\\n  public:\\n    TreeNode* recoverFromPreorder(string S) {\\n      idx = 0;\\n      N = S.size();\\n      int val = nextInt(S), depth;\\n      TreeNode* root = new TreeNode(val);\\n      // vector<TreeNode*> memo(1000);\\n      // memo[0] = root;\\n      stack<TreeNode*> s;\\n      s.push(root);\\n      while (idx<N) {\\n        depth = nextDepth(S);\\n        val = nextInt(S);\\n        // memo[depth] = new TreeNode(val);\\n        // if (memo[depth-1]->left)\\n        //   memo[depth-1]->right = memo[depth];\\n        // else\\n        //   memo[depth-1]->left = memo[depth];\\n        TreeNode* node = new TreeNode(val);\\n        while (s.size()>depth)\\n          s.pop();\\n        if (s.top()->left)\\n          s.top()->right = node;\\n        else\\n          s.top()->left = node;\\n        s.push(node);\\n      }\\n      return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private:\\n    int idx, N;\\n    int nextInt(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]!=\\'-\\')\\n        ++idx;\\n      return stoi(s.substr(p, idx-p));\\n    }\\n    int nextDepth(string& s) {\\n      int p = idx;\\n      while (idx<N && s[idx]==\\'-\\')\\n        ++idx;\\n      return idx-p;\\n    }\\n  public:\\n    TreeNode* recoverFromPreorder(string S) {\\n      idx = 0;\\n      N = S.size();\\n      int val = nextInt(S), depth;\\n      TreeNode* root = new TreeNode(val);\\n      // vector<TreeNode*> memo(1000);\\n      // memo[0] = root;\\n      stack<TreeNode*> s;\\n      s.push(root);\\n      while (idx<N) {\\n        depth = nextDepth(S);\\n        val = nextInt(S);\\n        // memo[depth] = new TreeNode(val);\\n        // if (memo[depth-1]->left)\\n        //   memo[depth-1]->right = memo[depth];\\n        // else\\n        //   memo[depth-1]->left = memo[depth];\\n        TreeNode* node = new TreeNode(val);\\n        while (s.size()>depth)\\n          s.pop();\\n        if (s.top()->left)\\n          s.top()->right = node;\\n        else\\n          s.top()->left = node;\\n        s.push(node);\\n      }\\n      return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669647,
                "title": "c-iterative-solution-using-map-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newNode(int val)\\n    {\\n        TreeNode* node = new TreeNode(val);\\n        return node;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        map<int , vector<TreeNode*>> freq;\\n        \\n        int len = str.length();\\n        \\n        if( len == 0)\\n            return NULL;\\n        \\n        string t = \"\";\\n        int i =0;\\n        while(i<len && str[i] != \\'-\\')\\n        {\\n            t+=str[i];\\n            i++;\\n        }\\n        TreeNode* root = newNode(stoi(t));\\n        freq[0].push_back(root);\\n        int count = 0;\\n        for( ;i<len ;i++)\\n        {\\n            int c = 0;\\n            while( i < len && str[i] == \\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            if( i == len)\\n                break;\\n            \\n            string t = \"\";\\n            while( i< len && str[i] != \\'-\\')\\n            {\\n                t+=str[i];\\n                i++;\\n            }  \\n            i--;\\n            TreeNode* temp = newNode(stoi(t));\\n            freq[c].push_back(temp);\\n            if( freq.count(c-1))\\n            {               \\n                TreeNode* temp2 = freq[c-1].back();\\n                freq[c-1].pop_back();\\n                if( temp2->left == NULL)\\n                    temp2->left = temp;\\n                else\\n                    temp2->right = temp;\\n                freq[c-1].push_back(temp2);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* newNode(int val)\\n    {\\n        TreeNode* node = new TreeNode(val);\\n        return node;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string str) {\\n        map<int , vector<TreeNode*>> freq;\\n        \\n        int len = str.length();\\n        \\n        if( len == 0)\\n            return NULL;\\n        \\n        string t = \"\";\\n        int i =0;\\n        while(i<len && str[i] != \\'-\\')\\n        {\\n            t+=str[i];\\n            i++;\\n        }\\n        TreeNode* root = newNode(stoi(t));\\n        freq[0].push_back(root);\\n        int count = 0;\\n        for( ;i<len ;i++)\\n        {\\n            int c = 0;\\n            while( i < len && str[i] == \\'-\\')\\n            {\\n                c++;\\n                i++;\\n            }\\n            if( i == len)\\n                break;\\n            \\n            string t = \"\";\\n            while( i< len && str[i] != \\'-\\')\\n            {\\n                t+=str[i];\\n                i++;\\n            }  \\n            i--;\\n            TreeNode* temp = newNode(stoi(t));\\n            freq[c].push_back(temp);\\n            if( freq.count(c-1))\\n            {               \\n                TreeNode* temp2 = freq[c-1].back();\\n                freq[c-1].pop_back();\\n                if( temp2->left == NULL)\\n                    temp2->left = temp;\\n                else\\n                    temp2->right = temp;\\n                freq[c-1].push_back(temp2);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668537,
                "title": "c-recursion",
                "content": "\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode* help(char **str, int prev, int *count) {\\n    \\n    int curr=0;\\n    int val=0;\\n    int update=0;\\n    \\n    struct TreeNode *temp;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return NULL;\\n\\n    \\n    temp = malloc(sizeof(struct TreeNode));\\n    while(**str != \\'-\\' && **str != \\'\\\\0\\') {\\n        val = val*10;\\n        val += **str-\\'0\\';\\n        printf(\"val=%d\\\\n\",val);\\n        (*str)++;\\n    }\\n    temp->val = val;\\n    temp->left = NULL;\\n    temp->right = NULL;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return temp;\\n    \\n    while(**str == \\'-\\') {\\n        (*str)++;\\n        curr++;\\n    }\\n    \\n    if(curr <= prev) {\\n    *count = curr;\\n    return temp;\\n    }\\n    \\n    //left child\\n    if(curr == prev+1)\\n        temp->left = help(str,curr,count);\\n    \\n    if(*count == prev+1)\\n        temp->right = help(str,curr,count);\\n    \\n    return temp;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * S){\\n\\n    int prev = 0;\\n    int count = 0;\\n    int len = strlen(S);\\n    if(len == 0)\\n        return NULL;\\n    \\n    return help(&S,prev,&count);\\n    \\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nstruct TreeNode* help(char **str, int prev, int *count) {\\n    \\n    int curr=0;\\n    int val=0;\\n    int update=0;\\n    \\n    struct TreeNode *temp;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return NULL;\\n\\n    \\n    temp = malloc(sizeof(struct TreeNode));\\n    while(**str != \\'-\\' && **str != \\'\\\\0\\') {\\n        val = val*10;\\n        val += **str-\\'0\\';\\n        printf(\"val=%d\\\\n\",val);\\n        (*str)++;\\n    }\\n    temp->val = val;\\n    temp->left = NULL;\\n    temp->right = NULL;\\n    \\n    if(**str == \\'\\\\0\\')\\n        return temp;\\n    \\n    while(**str == \\'-\\') {\\n        (*str)++;\\n        curr++;\\n    }\\n    \\n    if(curr <= prev) {\\n    *count = curr;\\n    return temp;\\n    }\\n    \\n    //left child\\n    if(curr == prev+1)\\n        temp->left = help(str,curr,count);\\n    \\n    if(*count == prev+1)\\n        temp->right = help(str,curr,count);\\n    \\n    return temp;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * S){\\n\\n    int prev = 0;\\n    int count = 0;\\n    int len = strlen(S);\\n    if(len == 0)\\n        return NULL;\\n    \\n    return help(&S,prev,&count);\\n    \\n}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 665137,
                "title": "c-dfs-easy",
                "content": "```\\n\\nclass Solution {\\n    \\n    string s; // copy of string\\n    int N;\\n    int i; // to iterate string\\n    \\n    // Calculate Depth based on number of \\'-\\'\\n    inline int calcdepth () {\\n        int d=0;\\n        while (s[i]==\\'-\\') {\\n            i++;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    // Calculate Val till we hit next \\'-\\'\\n    inline int get_val () {\\n        int n=0;\\n        while ((i<N) && (s[i]!=\\'-\\')) {\\n            n = n*10 + (int)s[i] - (int) \\'0\\';\\n            i++;\\n        }\\n        return n;\\n    }\\n    \\n    // Create node for current call.\\n    // check for left and right children if any\\n    TreeNode* dfs_depth (int depth)\\n    {\\n        if (i>=N) return NULL;\\n        TreeNode * node = new TreeNode (get_val());\\n\\t\\t\\n        // x==0 -> Left node\\n        // x==1 -> Right node\\n        for (int x=0; x<2; x++) { \\n            if (i<N) {\\n                int ibuff = i; // Buffering i for later use if d is not greater than depth \\n\\t\\t\\t\\t               // is important to maintain integrity of tree.\\n                int d = calcdepth();\\n                if (d>depth) {\\n                    if (x==0) node->left = dfs_depth(d);  // x==0\\n                    else node->right = dfs_depth(d);      // x==1\\n                } else {\\n                    i = ibuff;\\n                }\\n            }            \\n        }\\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        N = s.size();\\n        i = 0;\\n        return dfs_depth(0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    string s; // copy of string\\n    int N;\\n    int i; // to iterate string\\n    \\n    // Calculate Depth based on number of \\'-\\'\\n    inline int calcdepth () {\\n        int d=0;\\n        while (s[i]==\\'-\\') {\\n            i++;\\n            d++;\\n        }\\n        return d;\\n    }\\n    \\n    // Calculate Val till we hit next \\'-\\'\\n    inline int get_val () {\\n        int n=0;\\n        while ((i<N) && (s[i]!=\\'-\\')) {\\n            n = n*10 + (int)s[i] - (int) \\'0\\';\\n            i++;\\n        }\\n        return n;\\n    }\\n    \\n    // Create node for current call.\\n    // check for left and right children if any\\n    TreeNode* dfs_depth (int depth)\\n    {\\n        if (i>=N) return NULL;\\n        TreeNode * node = new TreeNode (get_val());\\n\\t\\t\\n        // x==0 -> Left node\\n        // x==1 -> Right node\\n        for (int x=0; x<2; x++) { \\n            if (i<N) {\\n                int ibuff = i; // Buffering i for later use if d is not greater than depth \\n\\t\\t\\t\\t               // is important to maintain integrity of tree.\\n                int d = calcdepth();\\n                if (d>depth) {\\n                    if (x==0) node->left = dfs_depth(d);  // x==0\\n                    else node->right = dfs_depth(d);      // x==1\\n                } else {\\n                    i = ibuff;\\n                }\\n            }            \\n        }\\n        return node;\\n    }\\n    \\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        s=S;\\n        N = s.size();\\n        i = 0;\\n        return dfs_depth(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649402,
                "title": "java-2ms-faster-than-94-12",
                "content": "\\nclass Solution {\\n\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S.length() == 0) {\\n            return null;\\n        }\\n        int params[] = new int[2]; // params[0] to store current index of string and params[1] to store count of dashes.\\n        return formTree(S, params, 0);\\n    }\\n\\t\\n    static TreeNode formTree(String str, int params[], int level) {\\n        if (params[0] > str.length()) {\\n            return null;\\n        }\\n        TreeNode node = null;\\n        if (params[1] == level) {\\n            int num = getCurrentNodeValue(str, params);\\n            node = new TreeNode(num);\\n            params[1] = countDashes(str, params[0]);\\n            params[0] = params[0] + params[1];\\n            node.left = formTree(str, params, level+1);\\n            node.right = formTree(str, params, level+1);\\n        }\\n        return node;\\n    \\n    }\\n    \\n    static int getCurrentNodeValue(String str, int params[]) {\\n        int num = 0;\\n        while (params[0] < str.length()) {\\n            if (str.charAt(params[0]) < 58 && str.charAt(params[0]) > 47) {\\n                num = num * 10 + (str.charAt(params[0]) - 48);\\n                params[0]++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return num;\\n    }\\n    \\n    static int countDashes(String str, int index) {\\n        int count = 0;\\n        if (index > str.length()) {\\n            return count;\\n        }\\n        count++;\\n        while (index < str.length() - 1) {\\n            if (str.charAt(index) == str.charAt(index+1) && str.charAt(index) == \\'-\\') {\\n                count++;\\n                index++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S.length() == 0) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 630854,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        Stack<TreeNode> s= new Stack<>();\\n\\n        for(int i =0; i<S.length(); ){\\n            int level=0;\\n            while(S.charAt(i)==\\'-\\'){\\n                level++;\\n                i++;\\n            }\\n            int num=0;\\n            while(i<S.length() && S.charAt(i)!=\\'-\\'){\\n                char c= S.charAt(i);\\n                num =(num*10)+ Character.getNumericValue(c);\\n                i++;\\n                \\n            }\\n\\n           while(s.size()>level){\\n               s.pop();\\n           }\\n            TreeNode n= new TreeNode(num);\\n            if(!s.empty()){\\n                TreeNode curNode= s.peek();\\n                if(s.peek().left== null){\\n                    s.peek().left= n;\\n                }else{\\n                    s.peek().right=n;\\n                }\\n            }\\n            \\n            s.push(n);\\n        }\\n        \\n        while(s.size()>1){\\n            s.pop();\\n        }\\n        \\n        return s.pop();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        \\n        Stack<TreeNode> s= new Stack<>();\\n\\n        for(int i =0; i<S.length(); ){\\n            int level=0;\\n            while(S.charAt(i)==\\'-\\'){\\n                level++;\\n                i++;\\n            }\\n            int num=0;\\n            while(i<S.length() && S.charAt(i)!=\\'-\\'){\\n                char c= S.charAt(i);\\n                num =(num*10)+ Character.getNumericValue(c);\\n                i++;\\n                \\n            }\\n\\n           while(s.size()>level){\\n               s.pop();\\n           }\\n            TreeNode n= new TreeNode(num);\\n            if(!s.empty()){\\n                TreeNode curNode= s.peek();\\n                if(s.peek().left== null){\\n                    s.peek().left= n;\\n                }else{\\n                    s.peek().right=n;\\n                }\\n            }\\n            \\n            s.push(n);\\n        }\\n        \\n        while(s.size()>1){\\n            s.pop();\\n        }\\n        \\n        return s.pop();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597610,
                "title": "java-easy-understand-recursive-using-regex",
                "content": "As we know the number of dash represents the level of the tree. For example \"1-2--3--4-5--6--7\"\\nStep1. Spilt by exactly \"-\", we can get \"1\", \"2--3--4\", \"5--6--7\". \"1\" is the root, \"2--3--4\" is the left child, \"5--6--7\" is the right child.\\nStep2. Spilt \"2--3--4\" by exactly \"--\"\\uFF0C we can get \"2\", \"3\", \"4\", \"2\" is the root, \"3\" is the left child, \"4\" is the right child. So this part is resolved.\\nStep3. Do the same sa Step2 for \"5--6--7\"\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, 1);\\n    }\\n\\n    TreeNode recover(String s, int level) {\\n        //there is no \"-\", then it\\'s a leaf node\\n        if (!s.contains(\"-\")) {\\n            return new TreeNode(Integer.parseInt(s));\\n        }\\n        //spilt s by the level, lv1 is \"-\", lv2 is \"--\" and so on, we must ensure there is no \"-\" before or after\\n        String part[] = s.split(\"(?<!-)-{\" + level+ \"}(?!-)\");\\n        //parse the node\\n        TreeNode node = new TreeNode(Integer.parseInt(part[0]));\\n        //parse the left child\\n        node.left = recover(part[1], level + 1);\\n        //parse the right if there is a right\\n        if (part.length == 3) {\\n            node.right = recover(part[2], level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, 1);\\n    }\\n\\n    TreeNode recover(String s, int level) {\\n        //there is no \"-\", then it\\'s a leaf node\\n        if (!s.contains(\"-\")) {\\n            return new TreeNode(Integer.parseInt(s));\\n        }\\n        //spilt s by the level, lv1 is \"-\", lv2 is \"--\" and so on, we must ensure there is no \"-\" before or after\\n        String part[] = s.split(\"(?<!-)-{\" + level+ \"}(?!-)\");\\n        //parse the node\\n        TreeNode node = new TreeNode(Integer.parseInt(part[0]));\\n        //parse the left child\\n        node.left = recover(part[1], level + 1);\\n        //parse the right if there is a right\\n        if (part.length == 3) {\\n            node.right = recover(part[2], level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573530,
                "title": "simple-c-recursive",
                "content": "```\\nTreeNode* recoverFromPreorder_(string S, int level, int& idx, int& nextLevel) {\\n\\n\\tif (idx >= S.length()) return nullptr;\\n\\n\\tint val = 0;\\n\\tfor (; idx < S.length() && S[idx] <= \\'9\\' && S[idx] >= \\'0\\'; ++idx) val = val * 10 + (S[idx] - \\'0\\');\\n\\n\\tTreeNode* newNode = new TreeNode(val);\\n\\n\\tint nextDepth = 0;\\n\\tfor (; idx < S.length() && S[idx] == \\'-\\'; ++idx) ++nextDepth;\\n\\tnextLevel = nextDepth;\\n\\n\\tif (nextDepth > level) newNode->leftLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\telse return newNode;\\n\\n\\tif (nextLevel > level) newNode->rightLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\n\\treturn newNode;\\n}\\n\\nTreeNode* recoverFromPreorder(string S) {\\n\\tint idx = 0, nextLevel = 0;\\n\\treturn recoverFromPreorder_(S, 0, idx, nextLevel);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* recoverFromPreorder_(string S, int level, int& idx, int& nextLevel) {\\n\\n\\tif (idx >= S.length()) return nullptr;\\n\\n\\tint val = 0;\\n\\tfor (; idx < S.length() && S[idx] <= \\'9\\' && S[idx] >= \\'0\\'; ++idx) val = val * 10 + (S[idx] - \\'0\\');\\n\\n\\tTreeNode* newNode = new TreeNode(val);\\n\\n\\tint nextDepth = 0;\\n\\tfor (; idx < S.length() && S[idx] == \\'-\\'; ++idx) ++nextDepth;\\n\\tnextLevel = nextDepth;\\n\\n\\tif (nextDepth > level) newNode->leftLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\telse return newNode;\\n\\n\\tif (nextLevel > level) newNode->rightLeaf = recoverFromPreorder_(S, level + 1, idx, nextLevel);\\n\\n\\treturn newNode;\\n}\\n\\nTreeNode* recoverFromPreorder(string S) {\\n\\tint idx = 0, nextLevel = 0;\\n\\treturn recoverFromPreorder_(S, 0, idx, nextLevel);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556087,
                "title": "c-unordered-map-76-speed-21-memory",
                "content": "Use an unordered_map to keep track of the incomplete node in the level immediately above the current level as we iterate through the string S. Since it is a preorder traversal, we will never have more than one node in the map at the same level that is incomplete (i.e. no conflicts).\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> LevelNode;                 //level, node\\n        int lvl = 0;                                              //running level counter\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] != \\'-\\') {                                      //parse dashes to get level\\n                string num = \"\";\\n                while (i < S.size() && isdigit(S[i])) {\\n                    num += S[i];                              //get number as a string\\n                    i++;\\n                }\\n                int val = stoi(num);                                //get number as integer\\n                LevelNode[lvl] = new TreeNode(val);                 //add the node to the map indexed by level\\n                if (lvl > 0){                                       //if there is a higher node, set the current node as left or right\\n                    if (LevelNode[lvl - 1]->left) LevelNode[lvl - 1]->right = LevelNode[lvl];       \\n                    else LevelNode[lvl - 1]->left = LevelNode[lvl];\\n                }\\n                lvl = 0;                           //reset level counter\\n                i--;                               //set i position for next iteration--this counteracts the i++ at the end of the iteration\\n            }\\n            else {\\n               lvl++;\\n            }\\n        }\\n        return LevelNode[0];                                       //return the root\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        unordered_map<int, TreeNode *> LevelNode;                 //level, node\\n        int lvl = 0;                                              //running level counter\\n        for (int i = 0; i < S.size(); i++) {\\n            if (S[i] != \\'-\\') {                                      //parse dashes to get level\\n                string num = \"\";\\n                while (i < S.size() && isdigit(S[i])) {\\n                    num += S[i];                              //get number as a string\\n                    i++;\\n                }\\n                int val = stoi(num);                                //get number as integer\\n                LevelNode[lvl] = new TreeNode(val);                 //add the node to the map indexed by level\\n                if (lvl > 0){                                       //if there is a higher node, set the current node as left or right\\n                    if (LevelNode[lvl - 1]->left) LevelNode[lvl - 1]->right = LevelNode[lvl];       \\n                    else LevelNode[lvl - 1]->left = LevelNode[lvl];\\n                }\\n                lvl = 0;                           //reset level counter\\n                i--;                               //set i position for next iteration--this counteracts the i++ at the end of the iteration\\n            }\\n            else {\\n               lvl++;\\n            }\\n        }\\n        return LevelNode[0];                                       //return the root\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506748,
                "title": "modern-c-solution-with-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        if (S.empty()) return nullptr;\\n        auto pos = 0;\\n        return decode(S, pos, 0);\\n    }\\n    \\nprivate:\\n    TreeNode *decode(const std::string &s, int &pos, int dashCount) {\\n        if (pos >= s.size()) return nullptr;\\n        auto curPos = pos;\\n        while (curPos < s.size() && s[curPos] == \\'-\\') ++curPos;\\n        if (curPos - pos != dashCount) return nullptr;\\n        int val = 0;\\n        for(; curPos < s.size() && s[curPos] != \\'-\\'; ++curPos)\\n            val = val * 10 + s[curPos] - \\'0\\';\\n        auto node = new TreeNode(val);\\n        pos = curPos;\\n        node->left = decode(s, pos, dashCount + 1);\\n        node->right = decode(s, pos, dashCount + 1);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        if (S.empty()) return nullptr;\\n        auto pos = 0;\\n        return decode(S, pos, 0);\\n    }\\n    \\nprivate:\\n    TreeNode *decode(const std::string &s, int &pos, int dashCount) {\\n        if (pos >= s.size()) return nullptr;\\n        auto curPos = pos;\\n        while (curPos < s.size() && s[curPos] == \\'-\\') ++curPos;\\n        if (curPos - pos != dashCount) return nullptr;\\n        int val = 0;\\n        for(; curPos < s.size() && s[curPos] != \\'-\\'; ++curPos)\\n            val = val * 10 + s[curPos] - \\'0\\';\\n        auto node = new TreeNode(val);\\n        pos = curPos;\\n        node->left = decode(s, pos, dashCount + 1);\\n        node->right = decode(s, pos, dashCount + 1);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425178,
                "title": "java-recursive-dfs-with-queue",
                "content": "Use the similar idea with https://leetcode.com/problems/serialize-and-deserialize-binary-tree/ \\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0) return null;\\n        \\n        Deque<int[]> q = preprocess(S);\\n        \\n        return buildTreeWithDfs(q, 0);\\n    }\\n    \\n    private TreeNode buildTreeWithDfs(Deque<int[]> q, int curDepth) {\\n        if (q.isEmpty() || q.peek()[1] != curDepth) return null;\\n        \\n        TreeNode curNode = new TreeNode(q.poll()[0]);\\n        curNode.left = buildTreeWithDfs(q, curDepth + 1);\\n        curNode.right = buildTreeWithDfs(q, curDepth + 1);\\n        \\n        return curNode;\\n    }\\n    \\n    private Deque<int[]> preprocess(String s) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        \\n        int preNum = 0, depth = 0, i = 0;\\n        boolean sawDigit = false;\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                preNum = preNum * 10 + (c - \\'0\\');\\n                sawDigit = true;\\n            } else if (c == \\'-\\') {\\n                if (sawDigit) {\\n                    q.offer(new int[]{preNum, depth});\\n                    \\n                    // reset\\n                    preNum = 0;\\n                    depth = 0;\\n                    sawDigit = false;\\n                } \\n                depth++;\\n            }\\n            i++;\\n        }\\n        \\n        if (sawDigit) q.offer(new int[]{preNum, depth});\\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0) return null;\\n        \\n        Deque<int[]> q = preprocess(S);\\n        \\n        return buildTreeWithDfs(q, 0);\\n    }\\n    \\n    private TreeNode buildTreeWithDfs(Deque<int[]> q, int curDepth) {\\n        if (q.isEmpty() || q.peek()[1] != curDepth) return null;\\n        \\n        TreeNode curNode = new TreeNode(q.poll()[0]);\\n        curNode.left = buildTreeWithDfs(q, curDepth + 1);\\n        curNode.right = buildTreeWithDfs(q, curDepth + 1);\\n        \\n        return curNode;\\n    }\\n    \\n    private Deque<int[]> preprocess(String s) {\\n        Deque<int[]> q = new ArrayDeque<>();\\n        \\n        int preNum = 0, depth = 0, i = 0;\\n        boolean sawDigit = false;\\n        while (i < s.length()) {\\n            char c = s.charAt(i);\\n            if (c >= \\'0\\' && c <= \\'9\\') {\\n                preNum = preNum * 10 + (c - \\'0\\');\\n                sawDigit = true;\\n            } else if (c == \\'-\\') {\\n                if (sawDigit) {\\n                    q.offer(new int[]{preNum, depth});\\n                    \\n                    // reset\\n                    preNum = 0;\\n                    depth = 0;\\n                    sawDigit = false;\\n                } \\n                depth++;\\n            }\\n            i++;\\n        }\\n        \\n        if (sawDigit) q.offer(new int[]{preNum, depth});\\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420243,
                "title": "python3-with-regex-beats-99-50",
                "content": "Just code this by intuition:\\n```\\nimport re\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        dash_map = {}\\n        dash_cnt = 0\\n        first_num = \"\"\\n        for ch in S:\\n            if ch == \\'-\\': break\\n            first_num += ch\\n        dash_map[0] = TreeNode(int(first_num))\\n        s = re.findall(r\\'(-+)(\\\\d+)\\', S)\\n        for dash, num in s:\\n            dash_num = len(dash)\\n            num = int(num)\\n            n = TreeNode(num)\\n            fa = dash_map[dash_num - 1]\\n            if not fa.left:\\n                fa.left = n\\n            elif not fa.right:\\n                fa.right = n\\n            dash_map[dash_num] = n\\n        return dash_map[0]\\n```\\nRegex is useful in formatting the string.",
                "solutionTags": [],
                "code": "```\\nimport re\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        dash_map = {}\\n        dash_cnt = 0\\n        first_num = \"\"\\n        for ch in S:\\n            if ch == \\'-\\': break\\n            first_num += ch\\n        dash_map[0] = TreeNode(int(first_num))\\n        s = re.findall(r\\'(-+)(\\\\d+)\\', S)\\n        for dash, num in s:\\n            dash_num = len(dash)\\n            num = int(num)\\n            n = TreeNode(num)\\n            fa = dash_map[dash_num - 1]\\n            if not fa.left:\\n                fa.left = n\\n            elif not fa.right:\\n                fa.right = n\\n            dash_map[dash_num] = n\\n        return dash_map[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405663,
                "title": "single-traversal-using-a-stack-python-3",
                "content": "**Idea:**\\n\\n1. Keep traversing the string till you see a single integer, keep counting the number of dashes while you do this.\\n2. Once you have found an integer now start traversing the string till you see a dash. This is useful to read non single digit numbers.\\n3. Once you have encountered a dash after seeing 1 or more integers, it means you have an integer ready to be inserted into your tree. \\n4. Check if root is null and then assign this new int to your root.\\n5. If root is not null:\\n\\t1. Take a stack and initialise it with the root, level of the root and keep repeating the steps below till the stack is empty.\\n\\t\\t1. Pop an element out of the stack.\\n\\t\\t2. if the level of the element popped out of the stack is 1 less than the level of the element to be inserted. Check if the current element has free left and insert or check if the current element has free right and then insert.\\n\\t\\t3. if the level of the element popped is less than the level of the element to be inserted, insert the right child, cur_level+1 and left child, cur_level+1 into the stack if they are not null.\\n\\n**Code**\\n*Note: Uncomment the print statements to better understand what is happening while you run the code.*\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str, levels=None) -> TreeNode:\\n        root = None\\n        n = len(S)\\n        foo = \\'\\'\\n        i = 0\\n        new_level = 0\\n        while i < n:\\n            if S[i] == \\'-\\':\\n                i += 1\\n                new_level += 1\\n                continue\\n            while i < n and S[i] != \\'-\\':\\n                foo += S[i]\\n                i += 1\\n\\n            temp = TreeNode(int(foo))\\n            temp.left = None\\n            temp.right = None\\n            foo = \\'\\'\\n\\n            # print(\"@@@@@@@@@@@@   {}   @@@@@@@@@@@@\".format(temp.val))\\n            if not root:\\n                root = temp\\n            else:\\n                stack = [(root, 0)]\\n                while stack:\\n                    cur = stack.pop()\\n                    cur_level = cur[1]\\n                    cur_node = cur[0]\\n                    # print(cur_level, new_level)\\n                    if cur_level == new_level - 1:\\n                        # print(\"In with {} for {}\".format(cur_node.val, temp.val))\\n                        if not cur_node.left:\\n                            cur_node.left = temp\\n                            break\\n                        elif not cur_node.right:\\n                            cur_node.right = temp\\n                            break\\n                    else:\\n                        # print(\"cur {} temp {}\".format(cur_node.val, temp.val))\\n                        if cur_node.right and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.right.val)\\n                            stack.append((cur_node.right, cur_level+1))\\n                        if (not cur_node.right) and cur_node.left and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.left.val)\\n                            stack.append((cur_node.left, cur_level+1))\\n            new_level = 0\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str, levels=None) -> TreeNode:\\n        root = None\\n        n = len(S)\\n        foo = \\'\\'\\n        i = 0\\n        new_level = 0\\n        while i < n:\\n            if S[i] == \\'-\\':\\n                i += 1\\n                new_level += 1\\n                continue\\n            while i < n and S[i] != \\'-\\':\\n                foo += S[i]\\n                i += 1\\n\\n            temp = TreeNode(int(foo))\\n            temp.left = None\\n            temp.right = None\\n            foo = \\'\\'\\n\\n            # print(\"@@@@@@@@@@@@   {}   @@@@@@@@@@@@\".format(temp.val))\\n            if not root:\\n                root = temp\\n            else:\\n                stack = [(root, 0)]\\n                while stack:\\n                    cur = stack.pop()\\n                    cur_level = cur[1]\\n                    cur_node = cur[0]\\n                    # print(cur_level, new_level)\\n                    if cur_level == new_level - 1:\\n                        # print(\"In with {} for {}\".format(cur_node.val, temp.val))\\n                        if not cur_node.left:\\n                            cur_node.left = temp\\n                            break\\n                        elif not cur_node.right:\\n                            cur_node.right = temp\\n                            break\\n                    else:\\n                        # print(\"cur {} temp {}\".format(cur_node.val, temp.val))\\n                        if cur_node.right and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.right.val)\\n                            stack.append((cur_node.right, cur_level+1))\\n                        if (not cur_node.right) and cur_node.left and cur_level < new_level:\\n                            # print(\"Adding \", cur_node.left.val)\\n                            stack.append((cur_node.left, cur_level+1))\\n            new_level = 0\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 390991,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        i = 0\\n        while i < len(s) and s[i] != \"-\":\\n            i += 1\\n        root = TreeNode(int(s[:i]))\\n        memo, state = {}, {}\\n        memo[0], state[0] = root, 0\\n        while i < len(s):\\n            anchor = i\\n            while i < len(s) and s[i] == \"-\":\\n                i += 1\\n            l = i - anchor\\n            anchor = i\\n            while i < len(s) and s[i] != \"-\":\\n                i += 1\\n            val = int(s[anchor:i])\\n            if state[l - 1] == 0:\\n                memo[l - 1].left = TreeNode(val)\\n                memo[l] = memo[l - 1].left\\n            else:\\n                memo[l - 1].right = TreeNode(val)\\n                memo[l] = memo[l - 1].right\\n            state[l - 1] ^= 1\\n            state[l] = 0\\n        return root",
                "solutionTags": [],
                "code": "class Solution:\\n    def recoverFromPreorder(self, s: str) -> TreeNode:\\n        i = 0\\n        while i < len(s) and s[i] != \"-\":\\n            i += 1\\n        root = TreeNode(int(s[:i]))\\n        memo, state = {}",
                "codeTag": "Java"
            },
            {
                "id": 325057,
                "title": "python-recursive-solution-easy-to-understand",
                "content": "We firstly transform the input array to a node list. There is no doubt that the first node in that list is the root. If the level of the second node is 1 (actually, it must be), it is the left child of the root (guaranteed by problem description). If the level of the third node is 2, it must be the left child of `root.left`, but not the right child of root, since `root.left.left` is the only correct \\'position\\' that the current tree could expand to and has a level of 2.\\n\\n```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        # recover by pre-order\\n        # parse nodes\\' info\\n        flag, i = 0, 0\\n        info = []\\n        while i < len(S):\\n            # collecting dashes\\n            dashes = 0\\n            while S[i] == \\'-\\':\\n                dashes, i = dashes + 1, i + 1\\n            # collecting digits\\n            digits = \\'\\'\\n            while S[i] != \\'-\\':\\n                digits, i = digits + S[i], i + 1\\n            info.append((dashes, digits))\\n\\n        self.has_built = 0      # has built x nodes\\n\\n        def preorder(depth):\\n            if self.has_built >= len(info) or info[self.has_built][0] != depth:\\n                return None\\n            node = TreeNode(info[self.has_built][1])\\n            self.has_built += 1\\n            node.left = preorder(depth+1)\\n            node.right = preorder(depth+1)\\n            return node\\n\\n        return preorder(0)\\n```\\nMaybe you want to ask: why could you guarantee that the node `info[self.has_built]` is the at the place we are visiting given that `info[self.has_built][0] == depth`? It is hard for me to explain it well, but you can image how we traverse a tree in pre-order. Let our node `info[self.has_built]` be `visit_node`, and its level be `L`. Suppose `visit_node` is a child of another node of level `L-1`,  not at the current visiting place (let\\'s denote it with a virtual node `curr_node`). `visit_node` and `curr_node` are on the same level. Then `visit_node` could not be left to `curr_node`, because `visit_node` should be visited before the parent of `curr_node`. Also, `visit_node` could not be right to `curr_node`, because the parent of `visit_node` hasn\\'t been visited. In summary, `visit_node` is equal to `curr_node`.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        # recover by pre-order\\n        # parse nodes\\' info\\n        flag, i = 0, 0\\n        info = []\\n        while i < len(S):\\n            # collecting dashes\\n            dashes = 0\\n            while S[i] == \\'-\\':\\n                dashes, i = dashes + 1, i + 1\\n            # collecting digits\\n            digits = \\'\\'\\n            while S[i] != \\'-\\':\\n                digits, i = digits + S[i], i + 1\\n            info.append((dashes, digits))\\n\\n        self.has_built = 0      # has built x nodes\\n\\n        def preorder(depth):\\n            if self.has_built >= len(info) or info[self.has_built][0] != depth:\\n                return None\\n            node = TreeNode(info[self.has_built][1])\\n            self.has_built += 1\\n            node.left = preorder(depth+1)\\n            node.right = preorder(depth+1)\\n            return node\\n\\n        return preorder(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313731,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        return helper(S,0);\\n    }\\nprivate:\\n    TreeNode* helper(string S, int level) {\\n        if(S.empty())   return NULL;\\n        else    {\\n            S=S.substr(level);  // remove the level count of prefix \\'-\\'\\n            int val=0,k=0;\\n            while(isdigit(S[k]))\\n                val=10*val+S[k++]-\\'0\\';\\n            TreeNode* root=new TreeNode(val);\\n            S=S.substr(k);      // remove k digits\\n            if(!S.empty())  {\\n                int j=S.length()-1-level-1;\\n                string s(level+1,\\'-\\');\\n                while(j>0)  {\\n                    if(isdigit(S[j+level+1]) && S.substr(j,level+1)==s && isdigit(S[j-1]))\\n                        break;  // j is the start location of the right subtree\\n                    else\\n                        --j;\\n                }\\n                if(0==j)\\n                    root->left=helper(S,level+1);\\n                else    {\\n                    root->left=helper(S.substr(0,j),level+1);\\n                    root->right=helper(S.substr(j),level+1);\\n                }\\n            }\\n            return root;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        return helper(S,0);\\n    }\\nprivate:\\n    TreeNode* helper(string S, int level) {\\n        if(S.empty())   return NULL;\\n        else    {\\n            S=S.substr(level);  // remove the level count of prefix \\'-\\'\\n            int val=0,k=0;\\n            while(isdigit(S[k]))\\n                val=10*val+S[k++]-\\'0\\';\\n            TreeNode* root=new TreeNode(val);\\n            S=S.substr(k);      // remove k digits\\n            if(!S.empty())  {\\n                int j=S.length()-1-level-1;\\n                string s(level+1,\\'-\\');\\n                while(j>0)  {\\n                    if(isdigit(S[j+level+1]) && S.substr(j,level+1)==s && isdigit(S[j-1]))\\n                        break;  // j is the start location of the right subtree\\n                    else\\n                        --j;\\n                }\\n                if(0==j)\\n                    root->left=helper(S,level+1);\\n                else    {\\n                    root->left=helper(S.substr(0,j),level+1);\\n                    root->right=helper(S.substr(j),level+1);\\n                }\\n            }\\n            return root;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293181,
                "title": "golang-hashmap-solution-very-simple",
                "content": "```golang\\nfunc recoverFromPreorder(S string) *TreeNode {\\n    sLen := len(S)\\n\\tif sLen <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\n\\tidxLevelMap := make(map[int]*TreeNode)\\n\\n\\ti := 0\\n\\tnumStart := 0\\n\\tnumEnd := 0\\n\\tdepth := 0\\n\\n\\tfor i <= sLen {\\n\\t\\tif i == sLen || S[i] == \\'-\\' {\\n\\t\\t\\tif numEnd > numStart {\\n\\t\\t\\t\\tnum, _ := strconv.Atoi(S[numStart:numEnd])\\n\\t\\t\\t\\tif depth <= 0 {\\n\\t\\t\\t\\t\\troot = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = root\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfatherTreeNode, _ := idxLevelMap[depth-1]\\n\\t\\t\\t\\t\\ttreeNode := &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif fatherTreeNode.Left == nil {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Left = treeNode\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Right = treeNode\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = treeNode\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdepth = 0\\n\\t\\t\\t}\\n\\t\\t\\tdepth++\\n\\t\\t\\tnumStart = i + 1\\n\\t\\t\\tnumEnd = i + 1\\n\\t\\t} else {\\n\\t\\t\\tnumEnd++\\n\\t\\t}\\n\\n\\t\\ti++\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc recoverFromPreorder(S string) *TreeNode {\\n    sLen := len(S)\\n\\tif sLen <= 0 {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tvar root *TreeNode\\n\\n\\tidxLevelMap := make(map[int]*TreeNode)\\n\\n\\ti := 0\\n\\tnumStart := 0\\n\\tnumEnd := 0\\n\\tdepth := 0\\n\\n\\tfor i <= sLen {\\n\\t\\tif i == sLen || S[i] == \\'-\\' {\\n\\t\\t\\tif numEnd > numStart {\\n\\t\\t\\t\\tnum, _ := strconv.Atoi(S[numStart:numEnd])\\n\\t\\t\\t\\tif depth <= 0 {\\n\\t\\t\\t\\t\\troot = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = root\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfatherTreeNode, _ := idxLevelMap[depth-1]\\n\\t\\t\\t\\t\\ttreeNode := &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal:   num,\\n\\t\\t\\t\\t\\t\\tLeft:  nil,\\n\\t\\t\\t\\t\\t\\tRight: nil,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif fatherTreeNode.Left == nil {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Left = treeNode\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfatherTreeNode.Right = treeNode\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tidxLevelMap[depth] = treeNode\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdepth = 0\\n\\t\\t\\t}\\n\\t\\t\\tdepth++\\n\\t\\t\\tnumStart = i + 1\\n\\t\\t\\tnumEnd = i + 1\\n\\t\\t} else {\\n\\t\\t\\tnumEnd++\\n\\t\\t}\\n\\n\\t\\ti++\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285932,
                "title": "c-simple-solution-in-o-1-space-currently-outperforms-everything-else",
                "content": "This algorithm travels down from the root every time it inserts a new node.\\n\\nI thought it would be a fun solution to write, but I did not think it would be fast. To my surprise, it beats 100% of all other submissions in both time and space, at least on LeetCode\\'s current test-cases. Still, I expect solutions that use recursion or a stack would outperform this on much larger inputs.\\n\\n```\\nclass Solution {\\npublic:\\n  TreeNode* recoverFromPreorder(std::string S) {\\n    cppHackery();\\n    s  = std::move(S);\\n    it = s.begin();\\n    while (it != s.end()) {\\n      int depth = parseDepth();\\n      int value = parseValue();\\n      nextNodePtr(depth) = new TreeNode(value);\\n    }\\n    return root;\\n  }\\n  \\nprivate:\\n  std::string           s;\\n  std::string::iterator it;\\n  TreeNode*             root;\\n  \\n  // Just a trick to make this run just the tiniest bit faster.\\n  void cppHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // Get the value for the next node by consuming the input.\\n  int parseValue() {\\n    int result = 0;\\n    for (; it != s.end() && *it != \\'-\\'; ++it)\\n      result = result * 10 + (*it - \\'0\\');\\n    return result;\\n  }\\n  \\n  // Get the depth for the next node by consuming the input.\\n  int parseDepth() {\\n    int result = 0;\\n    for (; *it == \\'-\\'; ++it)\\n      ++result;\\n    return result;    \\n  }\\n  \\n  // Get a reference to the next empty TreeNode* variable at the given depth.\\n  TreeNode*& nextNodePtr(int depth) {\\n    if (depth == 0) return root;\\n    TreeNode* node = root;\\n    while (--depth)\\n      node = node->right ? node->right : node->left;\\n    return node->left ? node->right : node->left;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  TreeNode* recoverFromPreorder(std::string S) {\\n    cppHackery();\\n    s  = std::move(S);\\n    it = s.begin();\\n    while (it != s.end()) {\\n      int depth = parseDepth();\\n      int value = parseValue();\\n      nextNodePtr(depth) = new TreeNode(value);\\n    }\\n    return root;\\n  }\\n  \\nprivate:\\n  std::string           s;\\n  std::string::iterator it;\\n  TreeNode*             root;\\n  \\n  // Just a trick to make this run just the tiniest bit faster.\\n  void cppHackery() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n  }\\n  \\n  // Get the value for the next node by consuming the input.\\n  int parseValue() {\\n    int result = 0;\\n    for (; it != s.end() && *it != \\'-\\'; ++it)\\n      result = result * 10 + (*it - \\'0\\');\\n    return result;\\n  }\\n  \\n  // Get the depth for the next node by consuming the input.\\n  int parseDepth() {\\n    int result = 0;\\n    for (; *it == \\'-\\'; ++it)\\n      ++result;\\n    return result;    \\n  }\\n  \\n  // Get a reference to the next empty TreeNode* variable at the given depth.\\n  TreeNode*& nextNodePtr(int depth) {\\n    if (depth == 0) return root;\\n    TreeNode* node = root;\\n    while (--depth)\\n      node = node->right ? node->right : node->left;\\n    return node->left ? node->right : node->left;\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 284659,
                "title": "beats-100-runtime",
                "content": "```\\nclass Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, new int[]{0}, 0); \\n    }\\n    public TreeNode recover(String s, int[] i, int d){\\n      \\n        if(i[0] >= s.length()) return null;\\n        int cur = i[0], d1 = 0;\\n        while(cur < s.length() && s.charAt(cur) == \\'-\\'){\\n            d1++; cur++;\\n        }\\n        if(d1 != d){\\n            return null;\\n        }\\n        int x = 0;\\n        while(cur < s.length() && Character.isDigit(s.charAt(cur))){\\n            x = x*10 + (s.charAt(cur++) - \\'0\\');\\n        } \\n        i[0] = cur; \\n        TreeNode node = new TreeNode(x);\\n        node.left = recover(s, i, d+1);\\n        node.right = recover(s, i, d+1);\\n        return node;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        return recover(S, new int[]{0}",
                "codeTag": "Java"
            },
            {
                "id": 280321,
                "title": "another-recursive-solution",
                "content": "```\\n vector<int> nodes;\\n \\n // Saves the next node with the same number of dashes for a given node.\\n unordered_map<int, int> next, prev;\\n\\n TreeNode* createTree(int from, int to) {\\n\\n    if (from >= to) return NULL;\\n\\n    TreeNode* tree = new TreeNode(nodes[from]);\\n\\n    // Get the index of the next node with the same number\\n    // of dashes\\n    int mid;\\n    if (next.count(from + 1) && (mid = next[from + 1]) < to) {\\n          tree->left = createTree(from + 1, mid);\\n          tree->right = createTree(mid, to);\\n          return tree;\\n    }\\n    tree->left = createTree(from + 1, to);\\n    return tree;\\n }\\n\\n TreeNode* recoverFromPreorder(string S) {\\n    int n = S.size();\\n    for (int i = 0; i < n;) {\\n       int dashes = 0;\\n       while (i < n && S[i] == \\'-\\') {\\n          dashes++;\\n          i++;\\n       }\\n       int num = 0;\\n       while (i < n && S[i] != \\'-\\') {\\n          num = 10 * num + S[i] - \\'0\\';\\n          i++;\\n       }\\n\\n       int curIdx = nodes.size();\\n       nodes.push_back(num);\\n       // Save the next node with the same number of dashes\\n       if (prev.count(dashes)) {\\n          next[prev[dashes]] = curIdx;\\n       }\\n       prev[dashes] = curIdx;\\n    }\\n    return createTree(0, nodes.size());\\n }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n vector<int> nodes;\\n \\n // Saves the next node with the same number of dashes for a given node.\\n unordered_map<int, int> next, prev;\\n\\n TreeNode* createTree(int from, int to) {\\n\\n    if (from >= to) return NULL;\\n\\n    TreeNode* tree = new TreeNode(nodes[from]);\\n\\n    // Get the index of the next node with the same number\\n    // of dashes\\n    int mid;\\n    if (next.count(from + 1) && (mid = next[from + 1]) < to) {\\n          tree->left = createTree(from + 1, mid);\\n          tree->right = createTree(mid, to);\\n          return tree;\\n    }\\n    tree->left = createTree(from + 1, to);\\n    return tree;\\n }\\n\\n TreeNode* recoverFromPreorder(string S) {\\n    int n = S.size();\\n    for (int i = 0; i < n;) {\\n       int dashes = 0;\\n       while (i < n && S[i] == \\'-\\') {\\n          dashes++;\\n          i++;\\n       }\\n       int num = 0;\\n       while (i < n && S[i] != \\'-\\') {\\n          num = 10 * num + S[i] - \\'0\\';\\n          i++;\\n       }\\n\\n       int curIdx = nodes.size();\\n       nodes.push_back(num);\\n       // Save the next node with the same number of dashes\\n       if (prev.count(dashes)) {\\n          next[prev[dashes]] = curIdx;\\n       }\\n       prev[dashes] = curIdx;\\n    }\\n    return createTree(0, nodes.size());\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 276633,
                "title": "a-easy-understandable-recursive-solution-for-tree-problem",
                "content": "A simple recursive DFS pattern for tree problem is:\\n1. DFS to the left side of node.\\n2. DFS to the right side of node.\\n3. Based on given conditions, organize the way of calling 1 and 2.\\n\\nFor this problem, the key point is to understand in which condition to add left children or right children for each node.\\n\\nThink in a greedy way, for each node, always try to add left child and right child, except two conditions:\\n1. If current node depth (level) is larger than expected depth, it means current node is next new level of its parent, so, it will always be left children.\\n2. If current node depth is less than expected depth it means current node is not current node\\'s children, or even higher ancestor. so it will return `nullptr`. To force the DFS travesal back to previosly DFS call with lower expected depth.\\n\\nAbove two conditions will tell whether a node\\'s left or right children is exist. Thus, the current node depth and expected depth are key parameters to recover the tree.\\n\\nAnother importance note is, for each node, DFS try to find next level node as deeper as possible unless next level node is *nullptr*, thus expected depth will increase by one at each DFS call:\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int index = 0;\\n        return dfs(S, index, 0);\\n    }\\n    \\n    TreeNode* dfs(string& S, int& index, int level) {\\n        if (index >= S.length()) return nullptr;\\n        // get the level for this node\\n        int curLevel = 0;\\n        while (S[index] == \\'-\\') {\\n            index++;\\n            curLevel++;\\n        }\\n        if (curLevel < level) {\\n            index -= curLevel;\\n            return nullptr;\\n        }\\n        \\n        // get the number for this node\\n        int num = S[index++] - \\'0\\';\\n        while (S[index]-\\'0\\' >= 0 && S[index]-\\'9\\' <= 0) {\\n            num = 10 * num + (S[index++] - \\'0\\');\\n        }\\n        \\n        TreeNode* node = new TreeNode(num);\\n        \\n        if (curLevel == level) {\\n            node->left = dfs(S, index, level+1);\\n            node->right = dfs(S, index, level+1);\\n        } else if (curLevel > level) {\\n            node->left = dfs(S, index, curLevel+1);\\n        }\\n        \\n        return node;\\n    }\\n};\\n```\\n\\nNote:\\n1. To support recursive solution, string index should pass as a reference.\\n2. If condtion 2 happens, string index will recover to its original value before current function call.\\n3. Above case introduce performance burden (current 24ms comparing to the best), it could be fine-tuned by add next level in each recursive call to avoid index travesal back.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int index = 0;\\n        return dfs(S, index, 0);\\n    }\\n    \\n    TreeNode* dfs(string& S, int& index, int level) {\\n        if (index >= S.length()) return nullptr;\\n        // get the level for this node\\n        int curLevel = 0;\\n        while (S[index] == \\'-\\') {\\n            index++;\\n            curLevel++;\\n        }\\n        if (curLevel < level) {\\n            index -= curLevel;\\n            return nullptr;\\n        }\\n        \\n        // get the number for this node\\n        int num = S[index++] - \\'0\\';\\n        while (S[index]-\\'0\\' >= 0 && S[index]-\\'9\\' <= 0) {\\n            num = 10 * num + (S[index++] - \\'0\\');\\n        }\\n        \\n        TreeNode* node = new TreeNode(num);\\n        \\n        if (curLevel == level) {\\n            node->left = dfs(S, index, level+1);\\n            node->right = dfs(S, index, level+1);\\n        } else if (curLevel > level) {\\n            node->left = dfs(S, index, curLevel+1);\\n        }\\n        \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274800,
                "title": "java-short-solution",
                "content": "```\\n    String gS;\\n    public TreeNode recoverFromPreorder(String S) {\\n        gS = S;\\n        return helper(0);\\n    }\\n    \\n    TreeNode helper(int d) {\\n        if(gS.length() == 0) return null;\\n        \\n        int level = 0, idx = 0;\\n        while(gS.charAt(idx) == \\'-\\') idx++;\\n        level = idx;\\n        \\n        if(level != d) return null;\\n        \\n        while(idx < gS.length() && Character.isDigit(gS.charAt(idx))) idx++;\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(gS.substring(level, idx)));\\n        gS = gS.substring(idx);\\n        root.left = helper(d+1);\\n        root.right = helper(d+1);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    String gS;\\n    public TreeNode recoverFromPreorder(String S) {\\n        gS = S;\\n        return helper(0);\\n    }\\n    \\n    TreeNode helper(int d) {\\n        if(gS.length() == 0) return null;\\n        \\n        int level = 0, idx = 0;\\n        while(gS.charAt(idx) == \\'-\\') idx++;\\n        level = idx;\\n        \\n        if(level != d) return null;\\n        \\n        while(idx < gS.length() && Character.isDigit(gS.charAt(idx))) idx++;\\n        \\n        TreeNode root = new TreeNode(Integer.parseInt(gS.substring(level, idx)));\\n        gS = gS.substring(idx);\\n        root.left = helper(d+1);\\n        root.right = helper(d+1);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 274784,
                "title": "java-recursive-solution",
                "content": "1. The first number is always root.\\n2. The string after root is always equal to ```n``` dashes, where ```n``` is next level.\\n3. If the right node is null, we can only find one string of ```n``` dashes.\\n```\\nEx: \"1-2--3--4-5--6--7\"\\n\\n\" 1  -  (2--3--4)  -  (5--6--7) \"\\n root  left string  right string\\n \\n1 is always the value of root.\\n\"-\" is always the string after root.\\n```\\n4. Do it recursively.\\n\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(1, S);\\n    }\\n    private TreeNode helper(int level, String S) {\\n        // find root number\\n        int i = 0;\\n        while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        TreeNode node = new TreeNode(new Integer(S.substring(0, i)));\\n        if(i == S.length()) return node;\\n        // find left & right nodes\\n        S = S.substring(i+level);\\n        i = 0;\\n        while(i < S.length()){\\n            int cnt = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') { i++; cnt++; }\\n\\t\\t\\t// right node exists\\n            if(cnt == level) {\\n                node.left = helper(level+1, S.substring(0, i-level));\\n                node.right = helper(level+1, S.substring(i));\\n                return node;\\n            }\\n            while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        }\\n        // only left node\\n        node.left = helper(level+1, S);\\n        return node;\\n    }\\n}\\n```\\nTime complexity: ```O(N)```, N is the length of string.",
                "solutionTags": [],
                "code": "```n```\n```n```\n```n```\n```\\nEx: \"1-2--3--4-5--6--7\"\\n\\n\" 1  -  (2--3--4)  -  (5--6--7) \"\\n root  left string  right string\\n \\n1 is always the value of root.\\n\"-\" is always the string after root.\\n```\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String S) {\\n        return helper(1, S);\\n    }\\n    private TreeNode helper(int level, String S) {\\n        // find root number\\n        int i = 0;\\n        while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        TreeNode node = new TreeNode(new Integer(S.substring(0, i)));\\n        if(i == S.length()) return node;\\n        // find left & right nodes\\n        S = S.substring(i+level);\\n        i = 0;\\n        while(i < S.length()){\\n            int cnt = 0;\\n            while(i < S.length() && S.charAt(i) == \\'-\\') { i++; cnt++; }\\n\\t\\t\\t// right node exists\\n            if(cnt == level) {\\n                node.left = helper(level+1, S.substring(0, i-level));\\n                node.right = helper(level+1, S.substring(i));\\n                return node;\\n            }\\n            while(i < S.length() && S.charAt(i) != \\'-\\') i++;\\n        }\\n        // only left node\\n        node.left = helper(level+1, S);\\n        return node;\\n    }\\n}\\n```\n```O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 274659,
                "title": "python-recursive-solution",
                "content": "The idea here is to recursively recover the tree. First you have to find where the right subtree starts in the string. On that position is a number and its previous element is still a number.\\n\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if S:\\n            nodes = [\"-\" if v == \"\" else v for v in S.split(\"-\")] # split all `-`\\n            root = TreeNode(int(nodes[0]))\\n            if len(nodes) == 1:\\n                return root\\n            elif len(nodes) == 2:\\n                root.left = TreeNode(int(nodes[1]))\\n                return root\\n            else:\\n                for i, v in enumerate(nodes[2: ], 2):\\n                    if nodes[i - 1] != \"-\" and v != \"-\":\\n                        rightPosition = i # found right subtree start position\\n                        break\\n                else: # right subtree does not exist\\n                    rightPosition = len(nodes)\\n\\n                leftTraversal = nodes[1: rightPosition]\\n                rightTraversal = nodes[rightPosition: ]\\n\\n                root.left = self.recoverFromPreorder(\"\".join(leftTraversal)) # recursively construct left subtree\\n                root.right = self.recoverFromPreorder(\"\".join(rightTraversal)) # recursively construct right subtree\\n                return root\\n        else:\\n            return None\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        if S:\\n            nodes = [\"-\" if v == \"\" else v for v in S.split(\"-\")] # split all `-`\\n            root = TreeNode(int(nodes[0]))\\n            if len(nodes) == 1:\\n                return root\\n            elif len(nodes) == 2:\\n                root.left = TreeNode(int(nodes[1]))\\n                return root\\n            else:\\n                for i, v in enumerate(nodes[2: ], 2):\\n                    if nodes[i - 1] != \"-\" and v != \"-\":\\n                        rightPosition = i # found right subtree start position\\n                        break\\n                else: # right subtree does not exist\\n                    rightPosition = len(nodes)\\n\\n                leftTraversal = nodes[1: rightPosition]\\n                rightTraversal = nodes[rightPosition: ]\\n\\n                root.left = self.recoverFromPreorder(\"\".join(leftTraversal)) # recursively construct left subtree\\n                root.right = self.recoverFromPreorder(\"\".join(rightTraversal)) # recursively construct right subtree\\n                return root\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274600,
                "title": "python-solution-with-explanation-simple-logic",
                "content": "for S = \\'1-2--3--4-5--6--7\\'\\nwe define helper() to get the root node constructed by S.\\nso we just split S as three parts by \\'-\\'(current level)\\n`l = [\\'1\\', \\'2--3--4\\', \\'5--6--7\\']`\\nthen, root = TreeNode(l[0]), root.left = helper(l[1]), root.right = helper(l[2])\\n\\nsorry for my mess code\\n```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        def getsplit(S, num):\\n            i = 0\\n            res = []\\n            start = 0\\n            while i < len(S):\\n                if S[i] == \\'-\\':\\n                    j = i\\n                    while j < len(S) and S[j] == \\'-\\': j += 1\\n                    if j-i == num:\\n                        res.append(S[start:i])\\n                        start = j\\n                    i = j -1\\n                i += 1\\n            res.append(S[start:])\\n            return res\\n\\n        def helper(S, num):\\n            if not S: return None\\n            # get root\\n            index = 0\\n            while index < len(S) and S[index] != \\'-\\': index += 1\\n            root = TreeNode(int(S[:index]))\\n            # split S into three parts\\n            l = getsplit(S, num)\\n            # not kid or just have left kid\\n            if len(l) == 1: return root\\n            elif len(l) == 2:\\n                root.left = helper(l[1], num+1)\\n            elif len(l) == 3:\\n                root.left = helper(l[1], num+1)\\n                root.right = helper(l[2], num+1)\\n            return root\\n\\n        return helper(S, 1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def recoverFromPreorder(self, S: str) -> TreeNode:\\n        def getsplit(S, num):\\n            i = 0\\n            res = []\\n            start = 0\\n            while i < len(S):\\n                if S[i] == \\'-\\':\\n                    j = i\\n                    while j < len(S) and S[j] == \\'-\\': j += 1\\n                    if j-i == num:\\n                        res.append(S[start:i])\\n                        start = j\\n                    i = j -1\\n                i += 1\\n            res.append(S[start:])\\n            return res\\n\\n        def helper(S, num):\\n            if not S: return None\\n            # get root\\n            index = 0\\n            while index < len(S) and S[index] != \\'-\\': index += 1\\n            root = TreeNode(int(S[:index]))\\n            # split S into three parts\\n            l = getsplit(S, num)\\n            # not kid or just have left kid\\n            if len(l) == 1: return root\\n            elif len(l) == 2:\\n                root.left = helper(l[1], num+1)\\n            elif len(l) == 3:\\n                root.left = helper(l[1], num+1)\\n                root.right = helper(l[2], num+1)\\n            return root\\n\\n        return helper(S, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274575,
                "title": "java-iterative-stack-solution-o-n",
                "content": "Keep track of track of depth of node by counting number of `-`. Then, pop nodes from stack until we reach current depth. Greedily try appending to either left or right child.\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\n    public TreeNode recoverFromPreorder(String S) {\\n        Deque<TreeNode> deque = new ArrayDeque<>();\\n        int currentDepth = 0;\\n        int i = 0;\\n        while(i < S.length()) {\\n            if (S.charAt(i) != \\'-\\') {\\n                int num = 0;\\n                while(i < S.length() && S.charAt(i) != \\'-\\') {\\n                    num = num * 10 + (S.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                \\n                while(deque.size() > currentDepth) {\\n                    deque.pollLast();\\n                }\\n                TreeNode parent = deque.size() > 0 ? deque.peekLast() : null;\\n                    \\n                TreeNode node = new TreeNode(num);\\n                if (parent != null) {\\n                    if (parent.left == null) parent.left = node;\\n                    else parent.right = node;\\n                }\\n                deque.offerLast(node);\\n                currentDepth = 0;\\n            } else {\\n                i++;\\n                currentDepth++;\\n            }\\n        }\\n        \\n        return deque.size() > 0 ? deque.pollFirst() : null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode recoverFromPreorder(String S) {\\n        Deque<TreeNode> deque = new ArrayDeque<>();\\n        int currentDepth = 0;\\n        int i = 0;\\n        while(i < S.length()) {\\n            if (S.charAt(i) != \\'-\\') {\\n                int num = 0;\\n                while(i < S.length() && S.charAt(i) != \\'-\\') {\\n                    num = num * 10 + (S.charAt(i) - \\'0\\');\\n                    i++;\\n                }\\n                \\n                while(deque.size() > currentDepth) {\\n                    deque.pollLast();\\n                }\\n                TreeNode parent = deque.size() > 0 ? deque.peekLast() : null;\\n                    \\n                TreeNode node = new TreeNode(num);\\n                if (parent != null) {\\n                    if (parent.left == null) parent.left = node;\\n                    else parent.right = node;\\n                }\\n                deque.offerLast(node);\\n                currentDepth = 0;\\n            } else {\\n                i++;\\n                currentDepth++;\\n            }\\n        }\\n        \\n        return deque.size() > 0 ? deque.pollFirst() : null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087547,
                "title": "iterative-vector-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of dashes represent the level at which a node should be at. ALso, for every value like \"--x\", where x is the node value, would mean that not only is x at level 2 (since there are k=2 dashes and levels start at 0) but also the fact that this is a child node of the last node in level 1 (k-1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach utilises a vector to store the levels index wise. Suppose, for the given string \"1-2-3--4--5--6---7\",\\nthe resultant vector should look like:\\n0 {1} ====> 1->(2,3)\\n1 {2 , 3} ====> 2->(4,5) , 3->(6)\\n2 {4 , 5 , 6} ====> 4->(8)\\n4 {8}\\n\\n# Complexity\\n- Time complexity: O(n), n=no of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), n=no of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<vector<TreeNode*>> a;\\n        int x=0; //for storing node value\\n        int i=0;\\n        int k=0; //counts no of dashes\\n        int n=traversal.size();\\n        while(i<n && traversal[i]!=\\'-\\') //first node\\n        {\\n            x=x*10+(traversal[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode *h=new TreeNode(x);\\n        a.push_back({h});\\n        while(i<n)\\n        {\\n            if(traversal[i]==\\'-\\'){\\n                x=0;\\n                k++;\\n            }\\n            else {\\n                x=x*10+(traversal[i]-\\'0\\');\\n                if(i==n-1 || traversal[i+1]==\\'-\\')\\n                {\\n                    int m=a[k-1].size();\\n                    TreeNode* p=new TreeNode(x);\\n                    if(a[k-1][m-1]->left==NULL)\\n                    a[k-1][m-1]->left=p;\\n                    else\\n                    a[k-1][m-1]->right=p;\\n                    if(k>=a.size())\\n                    a.push_back({p});\\n                    else\\n                    a[k].push_back(p);\\n                    k=0;\\n                }\\n            }\\n            i++;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<vector<TreeNode*>> a;\\n        int x=0; //for storing node value\\n        int i=0;\\n        int k=0; //counts no of dashes\\n        int n=traversal.size();\\n        while(i<n && traversal[i]!=\\'-\\') //first node\\n        {\\n            x=x*10+(traversal[i]-\\'0\\');\\n            i++;\\n        }\\n        TreeNode *h=new TreeNode(x);\\n        a.push_back({h});\\n        while(i<n)\\n        {\\n            if(traversal[i]==\\'-\\'){\\n                x=0;\\n                k++;\\n            }\\n            else {\\n                x=x*10+(traversal[i]-\\'0\\');\\n                if(i==n-1 || traversal[i+1]==\\'-\\')\\n                {\\n                    int m=a[k-1].size();\\n                    TreeNode* p=new TreeNode(x);\\n                    if(a[k-1][m-1]->left==NULL)\\n                    a[k-1][m-1]->left=p;\\n                    else\\n                    a[k-1][m-1]->right=p;\\n                    if(k>=a.size())\\n                    a.push_back({p});\\n                    else\\n                    a[k].push_back(p);\\n                    k=0;\\n                }\\n            }\\n            i++;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044848,
                "title": "c-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n    Approach:Using Stack\\n    We will traverse the given input string string.In each iteraton, we will separate node value and its depth for further processing. \\n    We will create new TreeNode for each val.Every time we create a new node, we will store it in a stack in the hope that it may become\\n    a parent of other nodes we will come across in the future.\\n    Before storing the current node in the stack, we need to find the parent of the current node.\\n    Given string is preorder traversal.In preorder , we visit root first and then we process\\n    its children. Therefore, Parent will be one of the nodes already stored in the stack.But which among them will be the parent?\\n    If the depth of a parent is D, the depth of its immediate child is D + 1.Therefore, we will pop the elements from stack till\\n    depth of the element on the top of the  stack is not equal to current depth-1.\\n    Once we find out the parent,next question is whether to attach the current node to left or to the right of parent?\\n    For this we maintain the depth of previous node called as prevDepth.\\n    We need to consider following 3 cases:\\n    i>Current Depth>prev Depth\\n    In preorder traversal after visiting the root node,we go to the left and as we go to the left depth increases by 1.\\n    So, if currDepth>prevDepth then it means that current node is left child of parent.\\n    \\n    ii>Current Depth=Prev Depth\\n    If prevDepth and currDepth are equal ,then it means\\n    that previous node and current node are siblings.Previous node is already attached to its parent as left child.\\n    So, current node is right child of the parent.\\n    \\n    \\n    iii>Current Depth<Prev Depth\\n    current node must be the right child of node on the top of the stack.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) \\n    {\\n        Stack<(TreeNode,int)> st=new Stack<(TreeNode,int)>();\\n        int prevDepth=0,currDepth=0;\\n        TreeNode root=null;\\n        int val=0;\\n        \\n        if(traversal==\"\")\\n        {\\n            return null;\\n        }\\n        \\n        for(int i=0;i<traversal.Length;)\\n        {\\n            currDepth=0;\\n            val=0;\\n            while(traversal[i]==\\'-\\')\\n            {\\n                currDepth++;\\n                i++;\\n            }\\n            while(i<traversal.Length && char.IsDigit(traversal[i]))\\n            {\\n                val=(val*10)+(traversal[i]-48);\\n                i++;\\n            }\\n            Console.WriteLine(val+\":\"+currDepth);\\n            TreeNode node=new TreeNode(val);\\n\\n            if(root==null) \\n            {\\n                root=node;\\n            }\\n            while(st.Count>0 && st.Peek().Item2!=currDepth-1)\\n            {\\n                st.Pop();\\n            }\\n                \\n                if(st.Count>0 && currDepth>prevDepth)\\n                {\\n                    st.Peek().Item1.left=node;\\n                }\\n                else if(st.Count>0 && (currDepth==prevDepth || currDepth<prevDepth))\\n                {\\n                    st.Peek().Item1.right=node;\\n                    st.Pop();\\n                }\\n\\n                st.Push((node,currDepth));\\n                prevDepth=currDepth;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string traversal) \\n    {\\n        Stack<(TreeNode,int)> st=new Stack<(TreeNode,int)>();\\n        int prevDepth=0,currDepth=0;\\n        TreeNode root=null;\\n        int val=0;\\n        \\n        if(traversal==\"\")\\n        {\\n            return null;\\n        }\\n        \\n        for(int i=0;i<traversal.Length;)\\n        {\\n            currDepth=0;\\n            val=0;\\n            while(traversal[i]==\\'-\\')\\n            {\\n                currDepth++;\\n                i++;\\n            }\\n            while(i<traversal.Length && char.IsDigit(traversal[i]))\\n            {\\n                val=(val*10)+(traversal[i]-48);\\n                i++;\\n            }\\n            Console.WriteLine(val+\":\"+currDepth);\\n            TreeNode node=new TreeNode(val);\\n\\n            if(root==null) \\n            {\\n                root=node;\\n            }\\n            while(st.Count>0 && st.Peek().Item2!=currDepth-1)\\n            {\\n                st.Pop();\\n            }\\n                \\n                if(st.Count>0 && currDepth>prevDepth)\\n                {\\n                    st.Peek().Item1.left=node;\\n                }\\n                else if(st.Count>0 && (currDepth==prevDepth || currDepth<prevDepth))\\n                {\\n                    st.Peek().Item1.right=node;\\n                    st.Pop();\\n                }\\n\\n                st.Push((node,currDepth));\\n                prevDepth=currDepth;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040775,
                "title": "solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038041,
                "title": "c-iterative-stack-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int calDepth(string &s, int &i){\\n        int n = s.size();\\n        int cnt = 0;\\n        while(i<n && s[i]==\\'-\\'){\\n            cnt++;\\n            ++i;\\n        }\\n        return cnt;\\n    }\\n    \\n    int calValue(string &s, int &i){\\n        int n = s.size();\\n        int val = 0;\\n        while(i<n && s[i]!=\\'-\\'){\\n            val*=10;\\n            val+=(s[i]-\\'0\\');\\n            ++i;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* solve(string &s, int i){\\n        int n = s.size();\\n        stack<pair<TreeNode*,int>> stk;\\n        TreeNode* root = nullptr;\\n        while(i<n){\\n            int curDepth = calDepth(s, i);\\n            int curVal = calValue(s, i);\\n            while(!stk.empty() && stk.top().second >= curDepth){\\n                stk.pop();\\n            }\\n            TreeNode* node = new TreeNode(curVal);\\n            if(!root) root=node;\\n            else{\\n                if(!stk.top().first->left) stk.top().first->left = node;\\n                else stk.top().first->right = node;\\n            }\\n            stk.push({node, curDepth});\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return solve(traversal, 0);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int calDepth(string &s, int &i){\\n        int n = s.size();\\n        int cnt = 0;\\n        while(i<n && s[i]==\\'-\\'){\\n            cnt++;\\n            ++i;\\n        }\\n        return cnt;\\n    }\\n    \\n    int calValue(string &s, int &i){\\n        int n = s.size();\\n        int val = 0;\\n        while(i<n && s[i]!=\\'-\\'){\\n            val*=10;\\n            val+=(s[i]-\\'0\\');\\n            ++i;\\n        }\\n        return val;\\n    }\\n    \\n    TreeNode* solve(string &s, int i){\\n        int n = s.size();\\n        stack<pair<TreeNode*,int>> stk;\\n        TreeNode* root = nullptr;\\n        while(i<n){\\n            int curDepth = calDepth(s, i);\\n            int curVal = calValue(s, i);\\n            while(!stk.empty() && stk.top().second >= curDepth){\\n                stk.pop();\\n            }\\n            TreeNode* node = new TreeNode(curVal);\\n            if(!root) root=node;\\n            else{\\n                if(!stk.top().first->left) stk.top().first->left = node;\\n                else stk.top().first->right = node;\\n            }\\n            stk.push({node, curDepth});\\n        }\\n        return root;\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return solve(traversal, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976934,
                "title": "inefficient-but-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the nodes are in level one , number of \\'-\\' before the number is 1 & if its in level 2 its -- and so on\\n\\n# Approach\\nStore the levels in HashMap and the parent level is current level-1, in hashmap if there is a node and its left is null assign the node to parent.left else parent.right\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\n)(N)\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String str) {\\n        HashMap<Integer,TreeNode> hm = new HashMap<>();\\n        TreeNode root = null;\\n        int pre = 0;\\n        for(int i=0;i<str.length();){\\n            if(Character.isDigit(str.charAt(i))){\\n                int num = 0;\\n                while(i<str.length() && Character.isDigit(str.charAt(i))){\\n                    num*=10;\\n                    num+=(str.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode node = new TreeNode(num);\\n                hm.put(pre,node);\\n                if(pre==0){\\n                    root = node;\\n                }else{\\n                    TreeNode par = hm.get(pre-1);\\n                    if(par.left == null)\\n                        par.left = node;\\n                    else\\n                        par.right = node;\\n                }\\n            }\\n            if(i<str.length()&&str.charAt(i) == \\'-\\'){\\n                pre = 0;\\n                while(i<str.length() && str.charAt(i) == \\'-\\'){\\n                    pre++;i++;}\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String str) {\\n        HashMap<Integer,TreeNode> hm = new HashMap<>();\\n        TreeNode root = null;\\n        int pre = 0;\\n        for(int i=0;i<str.length();){\\n            if(Character.isDigit(str.charAt(i))){\\n                int num = 0;\\n                while(i<str.length() && Character.isDigit(str.charAt(i))){\\n                    num*=10;\\n                    num+=(str.charAt(i)-\\'0\\');\\n                    i++;\\n                }\\n                TreeNode node = new TreeNode(num);\\n                hm.put(pre,node);\\n                if(pre==0){\\n                    root = node;\\n                }else{\\n                    TreeNode par = hm.get(pre-1);\\n                    if(par.left == null)\\n                        par.left = node;\\n                    else\\n                        par.right = node;\\n                }\\n            }\\n            if(i<str.length()&&str.charAt(i) == \\'-\\'){\\n                pre = 0;\\n                while(i<str.length() && str.charAt(i) == \\'-\\'){\\n                    pre++;i++;}\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967624,
                "title": "intutitive-solution-commented-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int i = 0; // Index for string traversal\\n    \\n    TreeNode* recoverFromPreorder(string &S, int d) {\\n        int nextDigitPos = S.find_first_of(\"1234567890\", i); // This line of code uses the find_first_of function to search for the first occurrence of any character in the string \"1234567890\" (which represents the digits 0 to 9) after the index i in the string S.\\n\\t\\t\\t\\t//Find the index of the first number after index i\\n        \\n        // Check if the number of hyphens between current index i and nextDigitPos is equal to depth d\\n        if (nextDigitPos - i != d)\\n            return NULL; // Return NULL if the condition is not met\\n        \\n        int nextDashPos = S.find(\"-\", nextDigitPos); // This line of code uses the find function to search for the first occurrence of the character \\'-\\' (hyphen) in the string S starting from the index nextDigitPos.\\n\\n        int rootValue = stoi(S.substr(nextDigitPos, nextDashPos - nextDigitPos)); // Extract the root value\\n        \\n        TreeNode* root = new TreeNode(rootValue); // Create the root with the extracted value\\n        i = nextDashPos; // Move the index forward for future recursions\\n        \\n        // Recursively create left and right subtrees with increased depth\\n        root->left = recoverFromPreorder(S, d + 1);\\n        root->right = recoverFromPreorder(S, d + 1);\\n        \\n        return root; // Return the constructed root\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        return recoverFromPreorder(S, 0); // Call the main function with initial depth 0\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int i = 0; // Index for string traversal\\n    \\n    TreeNode* recoverFromPreorder(string &S, int d) {\\n        int nextDigitPos = S.find_first_of(\"1234567890\", i); // This line of code uses the find_first_of function to search for the first occurrence of any character in the string \"1234567890\" (which represents the digits 0 to 9) after the index i in the string S.\\n\\t\\t\\t\\t//Find the index of the first number after index i\\n        \\n        // Check if the number of hyphens between current index i and nextDigitPos is equal to depth d\\n        if (nextDigitPos - i != d)\\n            return NULL; // Return NULL if the condition is not met\\n        \\n        int nextDashPos = S.find(\"-\", nextDigitPos); // This line of code uses the find function to search for the first occurrence of the character \\'-\\' (hyphen) in the string S starting from the index nextDigitPos.\\n\\n        int rootValue = stoi(S.substr(nextDigitPos, nextDashPos - nextDigitPos)); // Extract the root value\\n        \\n        TreeNode* root = new TreeNode(rootValue); // Create the root with the extracted value\\n        i = nextDashPos; // Move the index forward for future recursions\\n        \\n        // Recursively create left and right subtrees with increased depth\\n        root->left = recoverFromPreorder(S, d + 1);\\n        root->right = recoverFromPreorder(S, d + 1);\\n        \\n        return root; // Return the constructed root\\n    }\\n    \\n    TreeNode* recoverFromPreorder(string S) {\\n        return recoverFromPreorder(S, 0); // Call the main function with initial depth 0\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967623,
                "title": "intutitive-solution-commented-easy",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   TreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   TreeNode* recoverFromPreorder(string str) {\\n\\tTreeNode *root=new TreeNode();\\n\\tif(str.size()==0) return root=nullptr;//an empty tree\\n\\tstack<pair<TreeNode * , int>> pending;\\n\\t//first element of pair is for the storing the node and secod pair is for the storing the depth of that node\\n\\tint index=0,nodeVal=0;\\n\\t//find the node val for tree\\n\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\troot=new TreeNode(nodeVal);\\n\\tpending.push(make_pair(root , 0));\\n\\twhile(pending.size() && index<str.size()){\\n\\t\\tint depth=0;\\n\\t\\twhile(index<str.size() && str[index]==\\'-\\') index++ , depth++;\\t//find the depth of next node\\n\\t\\tnodeVal=0;\\n\\t\\t//let\\'s find the node value\\n\\t\\twhile(index<str.size() && str[index]!=\\'-\\') nodeVal=nodeVal*10+str[index++]-\\'0\\';\\n\\tTreeNode * currNode=new TreeNode(nodeVal);\\n\\t//LET\\'S get the parent what i have inserted earlier\\n\\t\\tpair<TreeNode* , int> parent=pending.top();\\n\\t\\t//if the difference between parent and current node is 1 then make curr node as left child of parent\\n\\t\\t//because question has given that If a node has only one child, that child is guaranteed to be the left child.\\n\\t\\tif((depth-parent.second)==1){\\n\\t\\t\\t//make curr node as a left child of the parent\\n\\t\\t\\t(parent.first)->left=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode , depth));\\n\\t\\t}else{\\n\\t\\t\\t//find the parent of current node and append curr node as a right child of that parent\\n\\t\\t\\twhile(pending.size() && (depth - pending.top().second)!=1){\\n\\t\\t\\t\\tpending.pop();\\n\\t\\t\\t}\\n\\t\\t\\t//now our top has suitable parent for the curr node now append the curr node with parent as a right child .....\\n\\t\\t\\t//right child cause of we have been backtracking that\\'s why we assumed that our left subtree completed\\n\\t\\t\\tparent=pending.top();\\n\\t\\t\\t(parent.first)->right=currNode;\\n\\t\\t\\tpending.push(make_pair(currNode  , depth));//append curr node\\n\\t\\t}\\n\\t}\\n\\treturn root;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951964,
                "title": "java-sol-with-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n      return  helper(traversal, 0);\\n    }\\n    public TreeNode helper(String str, int dept){\\n        int d=0;\\n        while(i+d<str.length() && str.charAt(i+d)==\\'-\\'){\\n            d++;\\n        }\\n        if(d!=dept){\\n            return null;\\n        }\\n        int nd=0;\\n        while(i+d+nd< str.length() && str.charAt(i+d+nd)!=\\'-\\'){\\n            nd++;\\n        }\\n        int val= Integer.parseInt(str.substring(i+d, i+d+nd));\\n        i=i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left= helper(str, dept+1);\\n        node.right= helper(str, dept+1);\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int i=0;\\n    public TreeNode recoverFromPreorder(String traversal) {\\n      return  helper(traversal, 0);\\n    }\\n    public TreeNode helper(String str, int dept){\\n        int d=0;\\n        while(i+d<str.length() && str.charAt(i+d)==\\'-\\'){\\n            d++;\\n        }\\n        if(d!=dept){\\n            return null;\\n        }\\n        int nd=0;\\n        while(i+d+nd< str.length() && str.charAt(i+d+nd)!=\\'-\\'){\\n            nd++;\\n        }\\n        int val= Integer.parseInt(str.substring(i+d, i+d+nd));\\n        i=i+d+nd;\\n        TreeNode node = new TreeNode(val);\\n        node.left= helper(str, dept+1);\\n        node.right= helper(str, dept+1);\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903245,
                "title": "python-simple-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def get_left_and_right(self, s, count):\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"-\" and s[i-1].isdigit():\\n                j = i+1\\n                while j < len(s) and s[j] == \"-\":\\n                    j += 1\\n                if j-i == count:\\n                    return s[:i], s[j:]\\n            i += 1\\n        return s[:i], s[i+count:]\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        if not traversal: return None\\n        node_val = \"\"\\n        while traversal and traversal[0].isdigit():\\n            node_val += traversal[0]\\n            traversal = traversal[1:]\\n        node = TreeNode(int(node_val))\\n        dash_count = 0\\n        while traversal and traversal[0] == \"-\":\\n            dash_count += 1\\n            traversal = traversal[1:]\\n        left_t, right_t = self.get_left_and_right(traversal, dash_count)\\n        node.left = self.recoverFromPreorder(left_t)\\n        node.right = self.recoverFromPreorder(right_t)\\n        return node\\n        \\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def get_left_and_right(self, s, count):\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \"-\" and s[i-1].isdigit():\\n                j = i+1\\n                while j < len(s) and s[j] == \"-\":\\n                    j += 1\\n                if j-i == count:\\n                    return s[:i], s[j:]\\n            i += 1\\n        return s[:i], s[i+count:]\\n    \\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        if not traversal: return None\\n        node_val = \"\"\\n        while traversal and traversal[0].isdigit():\\n            node_val += traversal[0]\\n            traversal = traversal[1:]\\n        node = TreeNode(int(node_val))\\n        dash_count = 0\\n        while traversal and traversal[0] == \"-\":\\n            dash_count += 1\\n            traversal = traversal[1:]\\n        left_t, right_t = self.get_left_and_right(traversal, dash_count)\\n        node.left = self.recoverFromPreorder(left_t)\\n        node.right = self.recoverFromPreorder(right_t)\\n        return node\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3879515,
                "title": "beats-89-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        \\n        // TreeNode array[] = new TreeNode[]      , size nhi pta phle se therefore list\\n        // use karni padhegi  ; \\n\\n        if( traversal.length() == 0)\\n        return null ; \\n\\n\\n        List<TreeNode> list = new ArrayList<>() ; \\n         \\n         String temp = \"\" ; \\n\\n          int i = 0 ; \\n\\n         for(  i = 0 ; i < traversal.length(); i++)\\n         {\\n              if( traversal.charAt(i) < \\'0\\' || traversal.charAt(i) > \\'9\\')\\n              {\\n                  break ; \\n              }\\n              else\\n              continue ; \\n         }\\n\\n        \\n         temp = traversal.substring(0 , i) ; \\n\\n\\n         int data = Integer.parseInt(temp) ; \\n\\n         TreeNode root = new TreeNode(data) ; \\n\\n         list.add(root) ; \\n\\n         helper(traversal , i ,  list) ; \\n\\n\\n         return root ; \\n    } \\n    public void helper(String traversal , int index , List<TreeNode> list)\\n    {\\n         if( index >= traversal.length())\\n         return ; \\n\\n        int count = 0 ; \\n\\n        while( index < traversal.length() && traversal.charAt(index) == \\'-\\')\\n        {\\n            count++ ; \\n            index++ ; \\n        }\\n        \\n        int tempIndex = index ; \\n\\n         while( index < traversal.length() && traversal.charAt(index) != \\'-\\')\\n        {\\n            \\n            index++ ; \\n        }\\n\\n\\n        int data = Integer.parseInt(traversal.substring(tempIndex , index)) ; \\n\\n        TreeNode parent = list.get(count-1) ; \\n\\n        TreeNode curr = new TreeNode(data) ; \\n\\n        if( parent.left == null)\\n        {\\n            parent.left = curr ; \\n        }\\n        else\\n        parent.right = curr  ; \\n\\n\\n        if( list.size() > count)\\n        {\\n            list.add(count , curr) ; \\n        }\\n        else\\n        list.add(curr) ; \\n\\n        helper( traversal , index , list) ; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n        \\n        // TreeNode array[] = new TreeNode[]      , size nhi pta phle se therefore list\\n        // use karni padhegi  ; \\n\\n        if( traversal.length() == 0)\\n        return null ; \\n\\n\\n        List<TreeNode> list = new ArrayList<>() ; \\n         \\n         String temp = \"\" ; \\n\\n          int i = 0 ; \\n\\n         for(  i = 0 ; i < traversal.length(); i++)\\n         {\\n              if( traversal.charAt(i) < \\'0\\' || traversal.charAt(i) > \\'9\\')\\n              {\\n                  break ; \\n              }\\n              else\\n              continue ; \\n         }\\n\\n        \\n         temp = traversal.substring(0 , i) ; \\n\\n\\n         int data = Integer.parseInt(temp) ; \\n\\n         TreeNode root = new TreeNode(data) ; \\n\\n         list.add(root) ; \\n\\n         helper(traversal , i ,  list) ; \\n\\n\\n         return root ; \\n    } \\n    public void helper(String traversal , int index , List<TreeNode> list)\\n    {\\n         if( index >= traversal.length())\\n         return ; \\n\\n        int count = 0 ; \\n\\n        while( index < traversal.length() && traversal.charAt(index) == \\'-\\')\\n        {\\n            count++ ; \\n            index++ ; \\n        }\\n        \\n        int tempIndex = index ; \\n\\n         while( index < traversal.length() && traversal.charAt(index) != \\'-\\')\\n        {\\n            \\n            index++ ; \\n        }\\n\\n\\n        int data = Integer.parseInt(traversal.substring(tempIndex , index)) ; \\n\\n        TreeNode parent = list.get(count-1) ; \\n\\n        TreeNode curr = new TreeNode(data) ; \\n\\n        if( parent.left == null)\\n        {\\n            parent.left = curr ; \\n        }\\n        else\\n        parent.right = curr  ; \\n\\n\\n        if( list.size() > count)\\n        {\\n            list.add(count , curr) ; \\n        }\\n        else\\n        list.add(curr) ; \\n\\n        helper( traversal , index , list) ; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874429,
                "title": "stack-beats-99",
                "content": "# Intuition\\nThe problem involves reconstructing a binary tree from a preorder traversal with depth information. Preorder traversal means that you traverse the root node, then the left subtree, and finally the right subtree. The depth information is indicated by the number of dashes before each node value. The key is to use a stack to keep track of the nodes being constructed.\\n\\n# Approach\\nInitialize an empty stack to keep track of nodes being constructed.\\nInitialize an index i to traverse the input trav string.\\nStart a loop that runs while i is within the bounds of the trav string.\\nInside the loop:\\nCount the number of dashes at index i to determine the depth of the current node.\\nRead the node value by extracting consecutive digits from index i and converting them to an integer.\\nCreate a new TreeNode with the extracted value.\\nPop nodes from the stack until the stack size is equal to the calculated depth. This helps to find the parent node of the current node.\\nIf the stack is not empty:\\nCheck if the parent node already has a left child. If it does, set the new node as the right child; otherwise, set it as the left child.\\nPush the new node onto the stack.\\nUpdate index i to move past the processed node value.\\nAfter processing the entire trav string:\\nIf the stack is empty, return NULL since there\\'s no tree to construct.\\nWhile the stack size is greater than 1, pop nodes from the stack until only the root node remains.\\nReturn the root node (the only node left in the stack).\\n\\n# Complexity\\n\\nTime Complexity: The algorithm processes each character of the input string once, and for each character, the stack operations take constant time. Hence, the time complexity is O(n), where n is the length of the input string trav.\\n\\nSpace Complexity: The space used by the stack corresponds to the maximum depth of the tree, which can be at most n/2 in the worst case (for a skewed tree). Therefore, the space complexity is O(n). Additionally, the space used for other variables and objects is negligible compared to the stack space.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> s;\\n        int i = 0;\\n        while(i < trav.size()){\\n            int lev = 0, j = i;\\n            while(j < trav.size() && trav[j] == \\'-\\'){\\n                j++;\\n                lev++;\\n            }\\n            int val = 0;\\n            while(j < trav.size() && trav[j] != \\'-\\'){\\n                val = 10 * val + (trav[j] - \\'0\\');\\n                j++;\\n            }\\n            TreeNode* newnode = new TreeNode(val);\\n            while(s.size() > lev)s.pop();\\n            if(!s.empty()){\\n                if(s.top() -> left)s.top() -> right = newnode;\\n                else s.top() -> left = newnode;\\n            }\\n            s.push(newnode);\\n            i = j;\\n        }\\n        if(s.empty())return NULL;\\n        while(s.size() > 1)s.pop();\\n        return s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872517,
                "title": "recover-the-binary-tree-from-the-given-traversal-solution-faster-than-92-48-memory-100",
                "content": "# Intuition\\nTo solve this problem, I would use a stack to keep track of the parent nodes while traversing the given traversal string\\n\\n# Approach\\nThe depth of each node is determined by the number of dashes before its value. We iterate through the traversal string and for each node, we create a new `TreeNode` object with the corresponding value. If the depth of the current node is equal to the length of the stack, it means the current node is the left child of the last node in the stack. Otherwise, we pop nodes from the stack until we reach the parent of the current node, and set the current node as the right child of the parent. Finally, we return the root of the tree (which is the first element in the stack).\\nSo:\\n\\n1. Initialize an empty stack.\\n2. Iterate through the traversal string character by character:\\n   - Count the number of dashes (\\'-\\') to determine the depth of the current node.\\n   - Extract the numerical value of the node.\\n   - Create a new TreeNode object with the extracted value.\\n   - Check the depth of the current node:\\n     - If the depth is equal to the length of the stack, it means the current node is the left child of the last node in the stack. Set the left child of the last node in the stack to the current node.\\n     - If the depth is less than the length of the stack, it means the current node is the right child of one of the nodes already in the stack. Pop nodes from the stack until we reach the parent of the current node. Set the right child of the parent to the current node.\\n   - Push the current node onto the stack.\\n3. Return the root of the tree (which is the first element in the stack).\\n\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the given traversal string. We iterate through the string once to build the tree.\\n\\n- Space complexity:\\nO(d), where d is the maximum depth of the tree. This is because the stack will contain at most d nodes at any given time.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack = []\\n        i = 0\\n        \\n        while i < len(traversal):\\n            depth = 0\\n            val = \"\"\\n            \\n            while i < len(traversal) and traversal[i] == \"-\":\\n                depth += 1\\n                i += 1\\n            \\n            while i < len(traversal) and traversal[i] != \"-\":\\n                val += traversal[i]\\n                i += 1\\n            \\n            node = TreeNode(int(val))\\n            \\n            if depth == len(stack):\\n                if stack:\\n                    stack[-1].left = node\\n            else:\\n                while len(stack) > depth:\\n                    stack.pop()\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n        \\n        return stack[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        stack = []\\n        i = 0\\n        \\n        while i < len(traversal):\\n            depth = 0\\n            val = \"\"\\n            \\n            while i < len(traversal) and traversal[i] == \"-\":\\n                depth += 1\\n                i += 1\\n            \\n            while i < len(traversal) and traversal[i] != \"-\":\\n                val += traversal[i]\\n                i += 1\\n            \\n            node = TreeNode(int(val))\\n            \\n            if depth == len(stack):\\n                if stack:\\n                    stack[-1].left = node\\n            else:\\n                while len(stack) > depth:\\n                    stack.pop()\\n                stack[-1].right = node\\n            \\n            stack.append(node)\\n        \\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866849,
                "title": "simple-python-solution-beats-92-83-in-run-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(d) where d is the max depth of the tree.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        l=1\\n        traversal=traversal.split(\"-\")\\n        Map={0:TreeNode(int(traversal[0]))}\\n        while l<len(traversal):\\n            count=1\\n            while traversal[l]==\"\" and l<len(traversal):\\n                count+=1\\n                l+=1\\n            newNode=TreeNode(int(traversal[l]))\\n            if Map[count-1].left==None:\\n                Map[count-1].left=newNode\\n            else:\\n                Map[count-1].right=newNode\\n            Map[count]=newNode\\n            l+=1\\n        return Map[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        l=1\\n        traversal=traversal.split(\"-\")\\n        Map={0:TreeNode(int(traversal[0]))}\\n        while l<len(traversal):\\n            count=1\\n            while traversal[l]==\"\" and l<len(traversal):\\n                count+=1\\n                l+=1\\n            newNode=TreeNode(int(traversal[l]))\\n            if Map[count-1].left==None:\\n                Map[count-1].left=newNode\\n            else:\\n                Map[count-1].right=newNode\\n            Map[count]=newNode\\n            l+=1\\n        return Map[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847913,
                "title": "python-solutino-beats-100",
                "content": "# Intuition\\nBrute Force with some optimization\\n\\n# Approach\\nSimply counting the number of dashes and if current number of dashes= prev dash count + 1 then the element will be a left child of the previous element otherwise it will be the right child of the node with Dash count= currrent dash count -1.\\n\\n# Complexity\\n- Time complexity:O(N)\\n- As fetching the element at a key in an unordered map take O(1) time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        level=defaultdict(list)\\n        dash=0\\n        prev=-1\\n        split=traversal.split(\"-\")\\n        print(split)\\n        for item in split:\\n            if item==\"\":\\n                dash+=1\\n                continue\\n            #print(item)\\n            node=TreeNode(item)\\n            level[dash].append(node)\\n            if prev==-1:\\n                root=node\\n            elif prev!=-1 and dash==prev+1:\\n                #print(node.val)\\n                level[prev][-1].left=node\\n            elif prev!=-1 and dash<=prev and dash>0:\\n                \\n                #print(level,dash)\\n                level[dash-1][-1].right=node\\n            #print(prev,dash)\\n            prev=dash\\n            dash=1\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def recoverFromPreorder(self, traversal: str) -> Optional[TreeNode]:\\n        level=defaultdict(list)\\n        dash=0\\n        prev=-1\\n        split=traversal.split(\"-\")\\n        print(split)\\n        for item in split:\\n            if item==\"\":\\n                dash+=1\\n                continue\\n            #print(item)\\n            node=TreeNode(item)\\n            level[dash].append(node)\\n            if prev==-1:\\n                root=node\\n            elif prev!=-1 and dash==prev+1:\\n                #print(node.val)\\n                level[prev][-1].left=node\\n            elif prev!=-1 and dash<=prev and dash>0:\\n                \\n                #print(level,dash)\\n                level[dash-1][-1].right=node\\n            #print(prev,dash)\\n            prev=dash\\n            dash=1\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843396,
                "title": "o-n-using-hashmap-integer-treenode",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(h)\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        \\n        int i = 0;\\n        while (i < traversal.length()) {\\n            int depth = 0;\\n            while (i < traversal.length() && traversal.charAt(i) == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            \\n            int val = 0;\\n            while (i < traversal.length() && Character.isDigit(traversal.charAt(i))) {\\n                val = val * 10 + (traversal.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode node = new TreeNode(val);\\n            hm.put(depth, node);\\n            \\n            if (depth > 0) {\\n                if (hm.get(depth - 1).left == null) {\\n                    hm.get(depth - 1).left = node;\\n                } \\n                else {\\n                    hm.get(depth - 1).right = node;\\n                }\\n            }\\n        }\\n        \\n        return hm.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Map<Integer, TreeNode> hm = new HashMap<>();\\n        \\n        int i = 0;\\n        while (i < traversal.length()) {\\n            int depth = 0;\\n            while (i < traversal.length() && traversal.charAt(i) == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            \\n            int val = 0;\\n            while (i < traversal.length() && Character.isDigit(traversal.charAt(i))) {\\n                val = val * 10 + (traversal.charAt(i) - \\'0\\');\\n                i++;\\n            }\\n            \\n            TreeNode node = new TreeNode(val);\\n            hm.put(depth, node);\\n            \\n            if (depth > 0) {\\n                if (hm.get(depth - 1).left == null) {\\n                    hm.get(depth - 1).left = node;\\n                } \\n                else {\\n                    hm.get(depth - 1).right = node;\\n                }\\n            }\\n        }\\n        \\n        return hm.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811617,
                "title": "dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* dfs(string& s, int& i, int d){\\n        if(i >= s.size()) return nullptr;\\n        int depth =0;\\n        int j = i;\\n        while(s[j]==\\'-\\'){\\n            depth++;\\n            j++;\\n        }\\n        if(depth < d) return nullptr;\\n        i = j;\\n        int val = 0;\\n        while(i<s.size() && s[i]-\\'0\\'>=0 && s[i] -\\'0\\' <= 9){\\n            val = 10*val + s[i]-\\'0\\';\\n            i++;\\n        }\\n        if(depth == d){\\n        TreeNode* root = new TreeNode(val);\\n        root->left = dfs(s, i, depth+1);\\n        root->right = dfs(s, i, depth+1);\\n        return root;\\n        }\\n        return nullptr;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int i=0;\\n        return dfs(traversal, i, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* dfs(string& s, int& i, int d){\\n        if(i >= s.size()) return nullptr;\\n        int depth =0;\\n        int j = i;\\n        while(s[j]==\\'-\\'){\\n            depth++;\\n            j++;\\n        }\\n        if(depth < d) return nullptr;\\n        i = j;\\n        int val = 0;\\n        while(i<s.size() && s[i]-\\'0\\'>=0 && s[i] -\\'0\\' <= 9){\\n            val = 10*val + s[i]-\\'0\\';\\n            i++;\\n        }\\n        if(depth == d){\\n        TreeNode* root = new TreeNode(val);\\n        root->left = dfs(s, i, depth+1);\\n        root->right = dfs(s, i, depth+1);\\n        return root;\\n        }\\n        return nullptr;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int i=0;\\n        return dfs(traversal, i, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798890,
                "title": "c-using-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public TreeNode RecoverFromPreorder(string traversal)\\n    {\\n        var stack = new Stack<TreeNode>();\\n        \\n        for (var i = 0; i < traversal.Length;)\\n        {\\n            int level;\\n            for (level = 0; traversal[i] == \\'-\\'; i++)\\n            {\\n                level++;\\n            }\\n\\n            int value;\\n            for (value = 0; i < traversal.Length && traversal[i] != \\'-\\'; i++)\\n            {\\n                value = value * 10 + (traversal[i] - \\'0\\');\\n            }\\n\\n            while (stack.Count > level)\\n            {\\n                stack.Pop();\\n            }\\n\\n            var node = new TreeNode(value);\\n            if (stack.Any())\\n            {\\n                if (stack.Peek().left == null)\\n                {\\n                    stack.Peek().left = node;\\n                }\\n                else\\n                {\\n                    stack.Peek().right = node;\\n                }\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        return stack.Last();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public TreeNode RecoverFromPreorder(string traversal)\\n    {\\n        var stack = new Stack<TreeNode>();\\n        \\n        for (var i = 0; i < traversal.Length;)\\n        {\\n            int level;\\n            for (level = 0; traversal[i] == \\'-\\'; i++)\\n            {\\n                level++;\\n            }\\n\\n            int value;\\n            for (value = 0; i < traversal.Length && traversal[i] != \\'-\\'; i++)\\n            {\\n                value = value * 10 + (traversal[i] - \\'0\\');\\n            }\\n\\n            while (stack.Count > level)\\n            {\\n                stack.Pop();\\n            }\\n\\n            var node = new TreeNode(value);\\n            if (stack.Any())\\n            {\\n                if (stack.Peek().left == null)\\n                {\\n                    stack.Peek().left = node;\\n                }\\n                else\\n                {\\n                    stack.Peek().right = node;\\n                }\\n            }\\n\\n            stack.Push(node);\\n        }\\n\\n        return stack.Last();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797960,
                "title": "java-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        int count = 0;\\n\\n         for (int i = 0; i < traversal.length(); i++) {\\n             if (traversal.charAt(i) != \\'-\\') {\\n                int j = i + 1;\\n                while (j < traversal.length() && traversal.charAt(j) != \\'-\\') {\\n                     j++;\\n                }\\n                \\n                String s = traversal.substring(i, j);\\n                i = j - 1;\\n\\n\\n                while (!stack.isEmpty() && stack.peek().level >= count) {\\n                    stack.pop();\\n                }\\n\\n                if (stack.isEmpty()) {\\n                    TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                    Node node = new Node(treeNode, count);\\n                    stack.push(node);\\n                    count = 0;\\n                }\\n                else {\\n                    TreeNode top = stack.peek().treeNode;\\n\\n                    if (top.left != null) {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.right = treeNode;\\n                    }\\n                    else {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.left = treeNode;\\n                    }\\n\\n                }\\n                \\n             }\\n             else {\\n                 count++;\\n             }\\n         }\\n\\n         while (stack.size() > 1) stack.pop();\\n\\n         return stack.peek().treeNode;\\n        \\n    }\\n\\n    class Node {\\n        TreeNode treeNode;\\n        int level;\\n\\n        public Node(TreeNode treeNode, int level) {\\n            this.treeNode = treeNode;\\n            this.level = level;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode recoverFromPreorder(String traversal) {\\n\\n        Stack<Node> stack = new Stack<>();\\n        int count = 0;\\n\\n         for (int i = 0; i < traversal.length(); i++) {\\n             if (traversal.charAt(i) != \\'-\\') {\\n                int j = i + 1;\\n                while (j < traversal.length() && traversal.charAt(j) != \\'-\\') {\\n                     j++;\\n                }\\n                \\n                String s = traversal.substring(i, j);\\n                i = j - 1;\\n\\n\\n                while (!stack.isEmpty() && stack.peek().level >= count) {\\n                    stack.pop();\\n                }\\n\\n                if (stack.isEmpty()) {\\n                    TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                    Node node = new Node(treeNode, count);\\n                    stack.push(node);\\n                    count = 0;\\n                }\\n                else {\\n                    TreeNode top = stack.peek().treeNode;\\n\\n                    if (top.left != null) {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.right = treeNode;\\n                    }\\n                    else {\\n                        TreeNode treeNode = new TreeNode(Integer.valueOf(s));\\n                        Node node = new Node(treeNode, count);\\n                        stack.push(node);\\n                        count = 0;\\n                        top.left = treeNode;\\n                    }\\n\\n                }\\n                \\n             }\\n             else {\\n                 count++;\\n             }\\n         }\\n\\n         while (stack.size() > 1) stack.pop();\\n\\n         return stack.peek().treeNode;\\n        \\n    }\\n\\n    class Node {\\n        TreeNode treeNode;\\n        int level;\\n\\n        public Node(TreeNode treeNode, int level) {\\n            this.treeNode = treeNode;\\n            this.level = level;\\n        }\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782895,
                "title": "easy-c-o-n-code-commented-code-no-extra-space-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* func(string &ans, int l, int r) {\\n        if(l>r)     return NULL;    \\n        \\n        int i=l, node=0;   //imputing node val\\n        while (i<=r && ans[i] != \\'-\\') {\\n            node = node*10 + (ans[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        if(i >= r)    return (new TreeNode(node)); //if leaf node\\n        \\n        int dashcnt = 0;    \\n        while(ans[i]== \\'-\\') {  //counting level of left subtree\\n            dashcnt++; i++;\\n        }\\n\\n        int c=0; int nxtidx = i;  //nxtidx point to root node val of left subtree\\n        //checking whether same node has right subtree\\n        while(i<=r && dashcnt != c) { \\n            c=0; i++;\\n            while(ans[i] == \\'-\\') {\\n                c++; i++;\\n            }\\n        }\\n        \\n        // i will point to root node val of right subtree\\n        // i-c-1 will point to last node of left subtree\\n        TreeNode* res = new TreeNode(node);\\n        \\n        res->left = func(ans, nxtidx, i-c-1);  //left subtree\\n        res->right = func(ans, i, r);          //right subtree\\n        \\n        return res;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return func(traversal, 0, traversal.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode* func(string &ans, int l, int r) {\\n        if(l>r)     return NULL;    \\n        \\n        int i=l, node=0;   //imputing node val\\n        while (i<=r && ans[i] != \\'-\\') {\\n            node = node*10 + (ans[i]-\\'0\\');\\n            i++;\\n        }\\n        \\n        if(i >= r)    return (new TreeNode(node)); //if leaf node\\n        \\n        int dashcnt = 0;    \\n        while(ans[i]== \\'-\\') {  //counting level of left subtree\\n            dashcnt++; i++;\\n        }\\n\\n        int c=0; int nxtidx = i;  //nxtidx point to root node val of left subtree\\n        //checking whether same node has right subtree\\n        while(i<=r && dashcnt != c) { \\n            c=0; i++;\\n            while(ans[i] == \\'-\\') {\\n                c++; i++;\\n            }\\n        }\\n        \\n        // i will point to root node val of right subtree\\n        // i-c-1 will point to last node of left subtree\\n        TreeNode* res = new TreeNode(node);\\n        \\n        res->left = func(ans, nxtidx, i-c-1);  //left subtree\\n        res->right = func(ans, i, r);          //right subtree\\n        \\n        return res;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        return func(traversal, 0, traversal.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764985,
                "title": "c-with-comments-100-time-o-n-2-o-n-2",
                "content": "# Approach\\nWe can treat an input string as a \\n{value, {singleDash}, leftNode, {singleDash}, rightNode}\\nSo if we \"split\" input string by a singleDash, we can execute this function for both left and right substrings:\\n![image.png](https://assets.leetcode.com/users/images/c091a12a-e49b-4265-af17-a828bd0bb0fd_1689348256.9800248.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)  \\\\quad|\\\\quad{} \\u03A9(nlog(n))$$\\n- Space complexity: $$O(n^2) \\\\quad|\\\\quad \\u03A9(nlog(n))$$\\n\\nBad for Single child chain tree\\n![image.png](https://assets.leetcode.com/users/images/96cfcdb7-d01a-444b-b1ea-8e459cdcca2e_1689349930.3272674.png)\\n\\nGood for Balanced tree\\n![image.png](https://assets.leetcode.com/users/images/f204ed5f-4292-45d0-9f15-269bf7fe4b50_1689350109.5713055.png)\\n\\n# Code\\n```\\npublic TreeNode RecoverFromPreorder(string traversal) \\n{\\n    var sb = new StringBuilder();\\n    var result = SplitAndFill(traversal);\\n    return result;\\n\\n    TreeNode SplitAndFill(string str)\\n    {\\n        if (str == null) return null;\\n            \\n        var nodeData = Split(str);\\n        return new TreeNode(\\n            nodeData.val,\\n            SplitAndFill(nodeData.left),\\n            SplitAndFill(nodeData.right));\\n    }\\n\\n    (int val, string left, string right) Split(string str)\\n    {\\n        var headValue = 0;\\n        var children = new string[2];\\n            \\n        var i = 0;\\n        byte nestingLevel = 0;\\n            \\n        while (i < str.Length && str[i] != \\'-\\') \\n            headValue = headValue * 10 + (str[i++] - \\'0\\');\\n\\n        for (; ++i < str.Length;)\\n        {\\n            var c = str[i];\\n            if (str[i] == \\'-\\')\\n            {\\n                // our left/right substrings shoud have\\n                // 1 less \"dash nesting level\"\\n                // e.g.   in input \"1-2--3--4\"\\n                // we want to have \"2-3-4\"\\n                //         and not \"-2--3--4\"\\n                if (nestingLevel != 0)\\n                    sb.Append(c);\\n                nestingLevel++;\\n            }\\n            else\\n            {\\n                if (nestingLevel == 1)\\n                {\\n                    // if we face a single dash again, \\n                    // we can set all we collected at this point\\n                    // to the left node, as there can\\'t be\\n                    // another singe dash: the remainer is\\n                    // a right node substring\\n                    children[0] = sb.ToString();\\n                    sb.Clear();\\n                    nestingLevel = 0;\\n                    i--;\\n                }\\n                else\\n                {\\n                    sb.Append(c);\\n                    nestingLevel = 0;\\n                }\\n            }\\n        }\\n            \\n        if (sb.Length > 0)\\n        {\\n            // if our left substring is null\\n            // then the input string had no\\n            // single dashes\\n            // which means this node has only 1 child\\n            // and it cannot be right node by design\\n            i = children[0] == null ? 0 : 1;\\n            children[i] = sb.ToString();\\n        }\\n        sb.Clear();\\n\\n        return (headValue, children[0], children[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic TreeNode RecoverFromPreorder(string traversal) \\n{\\n    var sb = new StringBuilder();\\n    var result = SplitAndFill(traversal);\\n    return result;\\n\\n    TreeNode SplitAndFill(string str)\\n    {\\n        if (str == null) return null;\\n            \\n        var nodeData = Split(str);\\n        return new TreeNode(\\n            nodeData.val,\\n            SplitAndFill(nodeData.left),\\n            SplitAndFill(nodeData.right));\\n    }\\n\\n    (int val, string left, string right) Split(string str)\\n    {\\n        var headValue = 0;\\n        var children = new string[2];\\n            \\n        var i = 0;\\n        byte nestingLevel = 0;\\n            \\n        while (i < str.Length && str[i] != \\'-\\') \\n            headValue = headValue * 10 + (str[i++] - \\'0\\');\\n\\n        for (; ++i < str.Length;)\\n        {\\n            var c = str[i];\\n            if (str[i] == \\'-\\')\\n            {\\n                // our left/right substrings shoud have\\n                // 1 less \"dash nesting level\"\\n                // e.g.   in input \"1-2--3--4\"\\n                // we want to have \"2-3-4\"\\n                //         and not \"-2--3--4\"\\n                if (nestingLevel != 0)\\n                    sb.Append(c);\\n                nestingLevel++;\\n            }\\n            else\\n            {\\n                if (nestingLevel == 1)\\n                {\\n                    // if we face a single dash again, \\n                    // we can set all we collected at this point\\n                    // to the left node, as there can\\'t be\\n                    // another singe dash: the remainer is\\n                    // a right node substring\\n                    children[0] = sb.ToString();\\n                    sb.Clear();\\n                    nestingLevel = 0;\\n                    i--;\\n                }\\n                else\\n                {\\n                    sb.Append(c);\\n                    nestingLevel = 0;\\n                }\\n            }\\n        }\\n            \\n        if (sb.Length > 0)\\n        {\\n            // if our left substring is null\\n            // then the input string had no\\n            // single dashes\\n            // which means this node has only 1 child\\n            // and it cannot be right node by design\\n            i = children[0] == null ? 0 : 1;\\n            children[i] = sb.ToString();\\n        }\\n        sb.Clear();\\n\\n        return (headValue, children[0], children[1]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696355,
                "title": "easy-beats-100-tree-recursive-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<pair<int, int>>& preorder, int& idx, int currDepth) {\\n        if (idx >= preorder.size() || preorder[idx].second != currDepth)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[idx].first);\\n        idx++;\\n\\n        root->left = buildTree(preorder, idx, currDepth + 1);\\n        root->right = buildTree(preorder, idx, currDepth + 1);\\n\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        vector<pair<int, int>> preorder;\\n        int i = 0;\\n        while (i < t.size()) {\\n            int value = 0;\\n            int depth = 0;\\n            while (i < t.size() && t[i] == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            while (i < t.size() && isdigit(t[i])) {\\n                value = value * 10 + (t[i] - \\'0\\');\\n                i++;\\n            }\\n            preorder.push_back({ value, depth });\\n        }\\n        int idx = 0;\\n        TreeNode* root = buildTree(preorder, idx, 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<pair<int, int>>& preorder, int& idx, int currDepth) {\\n        if (idx >= preorder.size() || preorder[idx].second != currDepth)\\n            return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[idx].first);\\n        idx++;\\n\\n        root->left = buildTree(preorder, idx, currDepth + 1);\\n        root->right = buildTree(preorder, idx, currDepth + 1);\\n\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        vector<pair<int, int>> preorder;\\n        int i = 0;\\n        while (i < t.size()) {\\n            int value = 0;\\n            int depth = 0;\\n            while (i < t.size() && t[i] == \\'-\\') {\\n                depth++;\\n                i++;\\n            }\\n            while (i < t.size() && isdigit(t[i])) {\\n                value = value * 10 + (t[i] - \\'0\\');\\n                i++;\\n            }\\n            preorder.push_back({ value, depth });\\n        }\\n        int idx = 0;\\n        TreeNode* root = buildTree(preorder, idx, 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692072,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> st;\\n        int value = 0;\\n        int count = 0;\\n        trav += \\'-\\';\\n        for(auto& ch : trav) {\\n            if (ch == \\'-\\') {\\n                if (value != 0) {\\n                    TreeNode* node = new TreeNode(value);\\n                    while(st.size() > count) {\\n                        st.pop();\\n                    }\\n                    if (!st.empty()) {\\n                        TreeNode*& father = st.top();\\n                        if (!father->left) {\\n                            father->left = node;\\n                        } else {\\n                            father->right = node;\\n                        }\\n                    }\\n                    st.push(node);\\n\\n                    count = 0;\\n                    value = 0;\\n                }\\n                count++;\\n            } else {\\n                value *= 10;\\n                value += ch - \\'0\\';\\n            }\\n        }\\n        while(st.size() > 1) {\\n            st.pop();\\n        }\\n        return st.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string trav) {\\n        stack<TreeNode*> st;\\n        int value = 0;\\n        int count = 0;\\n        trav += \\'-\\';\\n        for(auto& ch : trav) {\\n            if (ch == \\'-\\') {\\n                if (value != 0) {\\n                    TreeNode* node = new TreeNode(value);\\n                    while(st.size() > count) {\\n                        st.pop();\\n                    }\\n                    if (!st.empty()) {\\n                        TreeNode*& father = st.top();\\n                        if (!father->left) {\\n                            father->left = node;\\n                        } else {\\n                            father->right = node;\\n                        }\\n                    }\\n                    st.push(node);\\n\\n                    count = 0;\\n                    value = 0;\\n                }\\n                count++;\\n            } else {\\n                value *= 10;\\n                value += ch - \\'0\\';\\n            }\\n        }\\n        while(st.size() > 1) {\\n            st.pop();\\n        }\\n        return st.top();\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678383,
                "title": "non-recursive-easy-to-understand-c",
                "content": "# Intuition\\nUse a \\'depth-indexed\\' stack to find the parent of the current node.\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  TreeNode* recoverFromPreorder(string traversal) {\\n    int i = 0;  // current position in the string\\n    int n = traversal.size();\\n    // returns the next integer in the traversal\\n    // (advances `i\\' to a dash or the end of the string)\\n    auto nextInt = [&]() {\\n      // bound from [i, min(end of string, dash)]\\n      const char* start = traversal.data() + i;\\n      while ((i < n) && (traversal[i] != \\'-\\')) {\\n        i += 1;\\n      }\\n      const char* stop = traversal.data() + i + 1;\\n      // read the int from the string\\n      int res;\\n      auto[_, ec] = std::from_chars(start, stop, res);\\n      assert(ec == std::errc{});  // MUST SUCCEED!\\n      // return the resulting int\\n      return res;\\n    };\\n    // create the root element\\n    TreeNode* root = new TreeNode(nextInt());\\n    // stack of (node, depth)\\n    stack<pair<TreeNode*, int>> stk;\\n    // starts with root at depth 0\\n    stk.emplace(root, 0);\\n    // while we haven\\'t reached the end of the string...\\n    while (i < n) {\\n      // count the depth of the current node\\n      int depth = 0;\\n      while ((i < n) && (traversal[i] == \\'-\\')) {\\n        depth += 1;\\n        i += 1;\\n      }\\n      // find its parent in the stack (immediate node with depth - 1)\\n      while (!(stk.empty()) && (stk.top().second != (depth - 1))) {\\n        stk.pop();\\n      }\\n      // create the child, and set its position within the parent\\n      TreeNode* parent = stk.top().first;\\n      TreeNode* child = new TreeNode(nextInt());\\n      if (parent->left) {\\n        // the parent\\'s left child has already been created,\\n        // so set this node as its right child\\n        parent->right = child;\\n      } else {\\n        parent->left = child;\\n      }\\n      // add this new node to the stack!\\n      stk.emplace(child, depth);\\n    }\\n    // return the root...\\n    return root;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  TreeNode* recoverFromPreorder(string traversal) {\\n    int i = 0;  // current position in the string\\n    int n = traversal.size();\\n    // returns the next integer in the traversal\\n    // (advances `i\\' to a dash or the end of the string)\\n    auto nextInt = [&]() {\\n      // bound from [i, min(end of string, dash)]\\n      const char* start = traversal.data() + i;\\n      while ((i < n) && (traversal[i] != \\'-\\')) {\\n        i += 1;\\n      }\\n      const char* stop = traversal.data() + i + 1;\\n      // read the int from the string\\n      int res;\\n      auto[_, ec] = std::from_chars(start, stop, res);\\n      assert(ec == std::errc{});  // MUST SUCCEED!\\n      // return the resulting int\\n      return res;\\n    };\\n    // create the root element\\n    TreeNode* root = new TreeNode(nextInt());\\n    // stack of (node, depth)\\n    stack<pair<TreeNode*, int>> stk;\\n    // starts with root at depth 0\\n    stk.emplace(root, 0);\\n    // while we haven\\'t reached the end of the string...\\n    while (i < n) {\\n      // count the depth of the current node\\n      int depth = 0;\\n      while ((i < n) && (traversal[i] == \\'-\\')) {\\n        depth += 1;\\n        i += 1;\\n      }\\n      // find its parent in the stack (immediate node with depth - 1)\\n      while (!(stk.empty()) && (stk.top().second != (depth - 1))) {\\n        stk.pop();\\n      }\\n      // create the child, and set its position within the parent\\n      TreeNode* parent = stk.top().first;\\n      TreeNode* child = new TreeNode(nextInt());\\n      if (parent->left) {\\n        // the parent\\'s left child has already been created,\\n        // so set this node as its right child\\n        parent->right = child;\\n      } else {\\n        parent->left = child;\\n      }\\n      // add this new node to the stack!\\n      stk.emplace(child, depth);\\n    }\\n    // return the root...\\n    return root;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672628,
                "title": "c-recursive-approach-easy-to-understand",
                "content": "# Intuition\\nUse recursion to get left nodes and right nodes.\\n\\n# Approach\\nStore a global pointer `STR` to point to where we have reached in the string. Implement:\\n- `getint()`: returns next integer in `STR` and increase `STR` pass the number)\\n- `getlevel()`: returns the number of dashes nearby in `STR` and increase `STR` pass the dashes.\\n- **`getNode(int nextLevel)`**: this is a *recursive* function. \\n    - First it use `getint()` to find the nearest integer and put it in `val`. \\n    - To find each of the children nodes, first get the level by calling `getlevel()`. \\n    - If it matches `nextLevel`, then we spotted our child node and recursively call `getNode`. Else decrease `STR` to before the dashes.\\n\\n# Complexity\\n- Time complexity: at least $$O(N)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: at least $$O(N)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nchar* STR; // our global ptr\\ntypedef struct TreeNode Node; // shorten name\\n\\n// return a new node\\nNode* newNode(int val) {\\n    Node* res = malloc(sizeof(Node));\\n    res -> val = val; res -> left = NULL; res -> right = NULL;\\n    return res;\\n}\\n\\n// return next int in STR and increase STR\\nint getint() {\\n    int res = 0;\\n    for (; isdigit(*STR); ++STR) {\\n        res = res * 10 + *STR - \\'0\\';\\n    }\\n    return res;\\n}\\n\\n// return the number of dashes in STR and increase STR\\nint getlevel() {\\n    int res = 0;\\n    for (; *STR == \\'-\\'; ++STR, ++res);\\n    return res; \\n}\\n\\n// return the next node in STR, with its child nodes being at nextLevel\\nNode* getNode(int nextLevel) {\\n    Node* res = newNode(getint());\\n    int i = getlevel();\\n    if (i == nextLevel) res->left = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    i = getlevel();\\n    if (i == nextLevel) res->right = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    return res;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * traversal){\\n    STR = traversal;\\n    return getNode(1); \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nchar* STR; // our global ptr\\ntypedef struct TreeNode Node; // shorten name\\n\\n// return a new node\\nNode* newNode(int val) {\\n    Node* res = malloc(sizeof(Node));\\n    res -> val = val; res -> left = NULL; res -> right = NULL;\\n    return res;\\n}\\n\\n// return next int in STR and increase STR\\nint getint() {\\n    int res = 0;\\n    for (; isdigit(*STR); ++STR) {\\n        res = res * 10 + *STR - \\'0\\';\\n    }\\n    return res;\\n}\\n\\n// return the number of dashes in STR and increase STR\\nint getlevel() {\\n    int res = 0;\\n    for (; *STR == \\'-\\'; ++STR, ++res);\\n    return res; \\n}\\n\\n// return the next node in STR, with its child nodes being at nextLevel\\nNode* getNode(int nextLevel) {\\n    Node* res = newNode(getint());\\n    int i = getlevel();\\n    if (i == nextLevel) res->left = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    i = getlevel();\\n    if (i == nextLevel) res->right = getNode(nextLevel + 1);\\n    else STR -= i; // cancel the getlevel()\\n    return res;\\n}\\n\\nstruct TreeNode* recoverFromPreorder(char * traversal){\\n    STR = traversal;\\n    return getNode(1); \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657874,
                "title": "dfs-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDFs+recursion is used to manage the dfs construction whenever countdash of child is 1 greater than countdash of parent it is attached to the left and then right respectively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApplying dfs in each recursion counting the countdash and previouscount dash...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* find(int &start, int pcd, string s) {\\n        int i = start;\\n        int countdash = 0;\\n        if (i >= s.size()-1) return NULL;\\n        while (s[i] == \\'-\\' && i <= s.size() - 1) {\\n            countdash++;\\n            i++;\\n        }\\n        string t = \"\";\\n        while (s[i] != \\'-\\' && i <= s.size() - 1) {\\n            t += s[i];\\n            i++;\\n        }\\n        if (countdash > pcd) {\\n           start = i;\\n            TreeNode* temp = new TreeNode(stoi(t));\\n            temp->left = find(start, countdash, s);\\n            temp->right = find(start, countdash, s);\\n            return temp;\\n        }\\n         else if (countdash <= pcd) {\\n            return NULL;\\n        }\\n        return NULL;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n        int n = s.size();\\n        if (n == 0) return NULL;\\n        if(n==1)\\n        {\\n            TreeNode* head = new TreeNode((s[0])-\\'0\\');\\n            head->left=NULL;\\n            head->right=NULL;\\n            return head;\\n        }\\n        int i = 0;\\n        string temp = \"\";\\n        while (s[i] != \\'-\\') {\\n            temp += s[i];\\n            i++;\\n        }\\n        TreeNode* head = new TreeNode(stoi(temp));\\n        \\n        int start = i;\\n        head->left = find(start, 0, s);\\n        head->right = find(start, 0, s);\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* find(int &start, int pcd, string s) {\\n        int i = start;\\n        int countdash = 0;\\n        if (i >= s.size()-1) return NULL;\\n        while (s[i] == \\'-\\' && i <= s.size() - 1) {\\n            countdash++;\\n            i++;\\n        }\\n        string t = \"\";\\n        while (s[i] != \\'-\\' && i <= s.size() - 1) {\\n            t += s[i];\\n            i++;\\n        }\\n        if (countdash > pcd) {\\n           start = i;\\n            TreeNode* temp = new TreeNode(stoi(t));\\n            temp->left = find(start, countdash, s);\\n            temp->right = find(start, countdash, s);\\n            return temp;\\n        }\\n         else if (countdash <= pcd) {\\n            return NULL;\\n        }\\n        return NULL;\\n    }\\n\\n    TreeNode* recoverFromPreorder(string s) {\\n        int n = s.size();\\n        if (n == 0) return NULL;\\n        if(n==1)\\n        {\\n            TreeNode* head = new TreeNode((s[0])-\\'0\\');\\n            head->left=NULL;\\n            head->right=NULL;\\n            return head;\\n        }\\n        int i = 0;\\n        string temp = \"\";\\n        while (s[i] != \\'-\\') {\\n            temp += s[i];\\n            i++;\\n        }\\n        TreeNode* head = new TreeNode(stoi(temp));\\n        \\n        int start = i;\\n        head->left = find(start, 0, s);\\n        head->right = find(start, 0, s);\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649900,
                "title": "c-simple-recursive-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode *check(string str , int &index , int depth)\\n    {\\n        string temp  = \"\";\\n        int i = index;\\n        while(i < str.size() && str[i]!=\\'-\\')\\n        {\\n            temp+=str[i++];\\n        }\\n        TreeNode *root = new TreeNode(stoi(temp));\\n\\n        //checking depth of next node\\n        index = i;\\n        int dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n\\n        //If depth is not greater than the root depth itself than its the root node we will simply return root\\n        if(dep > depth)\\n        {   \\n            index = i;\\n            root->left = check(str , index , dep);\\n        }\\n        else\\n        {\\n            return root;\\n        }\\n\\n\\n        //If Left Child exist checking possibility of right child\\n        i = index;\\n        dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n        if(dep > depth)\\n        {\\n            index = i;\\n            root->right = check(str , index , dep);\\n        }\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int index = 0;\\n        TreeNode *root = check(traversal , index , 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *check(string str , int &index , int depth)\\n    {\\n        string temp  = \"\";\\n        int i = index;\\n        while(i < str.size() && str[i]!=\\'-\\')\\n        {\\n            temp+=str[i++];\\n        }\\n        TreeNode *root = new TreeNode(stoi(temp));\\n\\n        //checking depth of next node\\n        index = i;\\n        int dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n\\n        //If depth is not greater than the root depth itself than its the root node we will simply return root\\n        if(dep > depth)\\n        {   \\n            index = i;\\n            root->left = check(str , index , dep);\\n        }\\n        else\\n        {\\n            return root;\\n        }\\n\\n\\n        //If Left Child exist checking possibility of right child\\n        i = index;\\n        dep = 0;\\n        while(i<str.size() && str[i]==\\'-\\'){\\n            dep++;\\n            i++;\\n        }\\n        if(dep > depth)\\n        {\\n            index = i;\\n            root->right = check(str , index , dep);\\n        }\\n        return root;\\n    }\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        int index = 0;\\n        TreeNode *root = check(traversal , index , 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640614,
                "title": "simple-o-n-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        int idx =0;\\n        TreeNode* root = createTree(t,idx,-1);\\n        return root;\\n    }\\n\\n    TreeNode* createTree(string t,int &idx,int prev){\\n        if(idx==t.size()) return NULL;\\n        TreeNode * n = new TreeNode();\\n        string num;\\n        int cnt=0;\\n        while(idx<t.size() && t[idx]==\\'-\\'){\\n            cnt++;\\n            idx++;\\n        } \\n        if(cnt<=prev){\\n            idx-=(cnt);\\n            return NULL;\\n        }\\n        while(idx<t.size() && t[idx]>=\\'0\\' && t[idx]<=\\'9\\'){\\n            num.push_back(t[idx++]);\\n        }\\n        n->val = stoi(num);\\n        n->left = createTree(t,idx,cnt);\\n        n->right = createTree(t,idx,cnt);\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string t) {\\n        int idx =0;\\n        TreeNode* root = createTree(t,idx,-1);\\n        return root;\\n    }\\n\\n    TreeNode* createTree(string t,int &idx,int prev){\\n        if(idx==t.size()) return NULL;\\n        TreeNode * n = new TreeNode();\\n        string num;\\n        int cnt=0;\\n        while(idx<t.size() && t[idx]==\\'-\\'){\\n            cnt++;\\n            idx++;\\n        } \\n        if(cnt<=prev){\\n            idx-=(cnt);\\n            return NULL;\\n        }\\n        while(idx<t.size() && t[idx]>=\\'0\\' && t[idx]<=\\'9\\'){\\n            num.push_back(t[idx++]);\\n        }\\n        n->val = stoi(num);\\n        n->left = createTree(t,idx,cnt);\\n        n->right = createTree(t,idx,cnt);\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636552,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findans(string t,int h,int &ind){\\n        string s = \"\";\\n        while(ind<t.size() and t[ind]!=\\'-\\'){s = s + t[ind];ind++;}\\n        TreeNode* node = new TreeNode(stoi(s));\\n        h++;\\n        int x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->left = findans(t,h,ind);\\n        }\\n        x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->right = findans(t,h,ind);\\n        }\\n        return node;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        int ind = 0;\\n        return findans(t,0,ind);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* findans(string t,int h,int &ind){\\n        string s = \"\";\\n        while(ind<t.size() and t[ind]!=\\'-\\'){s = s + t[ind];ind++;}\\n        TreeNode* node = new TreeNode(stoi(s));\\n        h++;\\n        int x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->left = findans(t,h,ind);\\n        }\\n        x = ind;\\n        while(x<t.size() and t[x]==\\'-\\')x++;\\n        if(x!=t.size() and x==ind+h){\\n            ind = x;\\n            node->right = findans(t,h,ind);\\n        }\\n        return node;\\n    }\\n    TreeNode* recoverFromPreorder(string t) {\\n        int ind = 0;\\n        return findans(t,0,ind);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632976,
                "title": "simple-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n     int convertInt(string &temp){\\n        int ans=0;\\n        int sign=1;\\n        for(int i=0;i<temp.size();i++) {\\n            int t = temp[i] - 48;\\n            ans = ans *10 + t;\\n        }\\n        return ans;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>no;\\n        vector<int>dep;\\n\\n        string temp = \"\";\\n        int cnt=0;\\n        for(int i=0;i<traversal.size();i++) {\\n            if(traversal[i] == \\'-\\' && traversal[i-1] != \\'-\\') {\\n                int a = convertInt(temp);\\n                no.push_back(a);\\n                temp=\"\";\\n                cnt++;\\n            }\\n            else if(!i || (i && traversal[i] != \\'-\\' && traversal[i-1]==\\'-\\')) {\\n                temp += traversal[i];\\n                dep.push_back(cnt);\\n                cnt=0;\\n            }\\n            else {\\n                if(traversal[i] == \\'-\\') cnt++;\\n                else temp += traversal[i];\\n            }\\n        }\\n        int a = convertInt(temp);\\n        no.push_back(a);\\n\\n        stack<pair<TreeNode *,int>>st;\\n        TreeNode *root = new TreeNode(no[0]);\\n        st.push({root,dep[0]});\\n\\n        for(int i=1;i<no.size();i++) {\\n            if(dep[i] > st.top().second) {\\n                TreeNode *curr = new TreeNode (no[i]);\\n                st.top().first->left = curr;\\n                st.push({curr,dep[i]});\\n            }\\n            else {\\n                while(dep[i] <= st.top().second) st.pop();\\n                auto it = st.top();\\n                st.pop();\\n                TreeNode *curr = new TreeNode (no[i]);\\n                it.first->right = curr;\\n                st.push({curr,dep[i]});\\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n     int convertInt(string &temp){\\n        int ans=0;\\n        int sign=1;\\n        for(int i=0;i<temp.size();i++) {\\n            int t = temp[i] - 48;\\n            ans = ans *10 + t;\\n        }\\n        return ans;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>no;\\n        vector<int>dep;\\n\\n        string temp = \"\";\\n        int cnt=0;\\n        for(int i=0;i<traversal.size();i++) {\\n            if(traversal[i] == \\'-\\' && traversal[i-1] != \\'-\\') {\\n                int a = convertInt(temp);\\n                no.push_back(a);\\n                temp=\"\";\\n                cnt++;\\n            }\\n            else if(!i || (i && traversal[i] != \\'-\\' && traversal[i-1]==\\'-\\')) {\\n                temp += traversal[i];\\n                dep.push_back(cnt);\\n                cnt=0;\\n            }\\n            else {\\n                if(traversal[i] == \\'-\\') cnt++;\\n                else temp += traversal[i];\\n            }\\n        }\\n        int a = convertInt(temp);\\n        no.push_back(a);\\n\\n        stack<pair<TreeNode *,int>>st;\\n        TreeNode *root = new TreeNode(no[0]);\\n        st.push({root,dep[0]});\\n\\n        for(int i=1;i<no.size();i++) {\\n            if(dep[i] > st.top().second) {\\n                TreeNode *curr = new TreeNode (no[i]);\\n                st.top().first->left = curr;\\n                st.push({curr,dep[i]});\\n            }\\n            else {\\n                while(dep[i] <= st.top().second) st.pop();\\n                auto it = st.top();\\n                st.pop();\\n                TreeNode *curr = new TreeNode (no[i]);\\n                it.first->right = curr;\\n                st.push({curr,dep[i]});\\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619295,
                "title": "98-fastest-iterative-stack-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Have a stack that holds all the nodes\\n- Init stack to hold the root node and have the reference to the root for easy return (you can also pop the stack until size is 1 and return that node)\\n- Create 2 helper methods to parse next depth and val in the string for less confusion\\n- If the depth is one greater then the previous depth, then that node is the left child of the prev node\\n- Otherwise that node is a right child of a parent node. Pop the stack an appropriate amount to get the correct parent node.\\n\\n# Complexity\\n- Time complexity:\\nO(N), where N is number of nodes\\n\\n- Space complexity:\\nO(N), where N is number of nodes\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack<TreeNode*> node_stack;\\n        int i = 0, prevDepth = 0;\\n        TreeNode* root = new TreeNode(getVal(traversal, i));\\n        node_stack.push(root);\\n        while (i < traversal.size()) {\\n            int depth = getDepth(traversal, i);\\n            TreeNode* node = new TreeNode(getVal(traversal, i));\\n            if (depth == prevDepth+1) {\\n                node_stack.top()->left = node;\\n            } else if (depth <= prevDepth) {\\n                int diff = prevDepth-depth;\\n                for (int i = 0; i <= diff; i++) {\\n                    node_stack.pop();\\n                }\\n                node_stack.top()->right = node;\\n            }\\n            prevDepth = depth;\\n            node_stack.push(node);\\n        }\\n        return root;\\n    }\\nprivate:\\n    int getDepth(string& traversal, int& i) {\\n        int depth = 0;\\n        while (traversal[i] == \\'-\\') {\\n            depth++;\\n            i++;\\n        }\\n        return depth;\\n    }\\n    int getVal(string& traversal, int& i) {\\n        int len = 0;\\n        while (traversal[i+len] != \\'-\\' && i+len < traversal.size()) {\\n            len++;\\n        }\\n        int val = stoi(traversal.substr(i, len));\\n        i += len;\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        stack<TreeNode*> node_stack;\\n        int i = 0, prevDepth = 0;\\n        TreeNode* root = new TreeNode(getVal(traversal, i));\\n        node_stack.push(root);\\n        while (i < traversal.size()) {\\n            int depth = getDepth(traversal, i);\\n            TreeNode* node = new TreeNode(getVal(traversal, i));\\n            if (depth == prevDepth+1) {\\n                node_stack.top()->left = node;\\n            } else if (depth <= prevDepth) {\\n                int diff = prevDepth-depth;\\n                for (int i = 0; i <= diff; i++) {\\n                    node_stack.pop();\\n                }\\n                node_stack.top()->right = node;\\n            }\\n            prevDepth = depth;\\n            node_stack.push(node);\\n        }\\n        return root;\\n    }\\nprivate:\\n    int getDepth(string& traversal, int& i) {\\n        int depth = 0;\\n        while (traversal[i] == \\'-\\') {\\n            depth++;\\n            i++;\\n        }\\n        return depth;\\n    }\\n    int getVal(string& traversal, int& i) {\\n        int len = 0;\\n        while (traversal[i+len] != \\'-\\' && i+len < traversal.size()) {\\n            len++;\\n        }\\n        int val = stoi(traversal.substr(i, len));\\n        i += len;\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618870,
                "title": "c-beats-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n        \\n        return RecoverFromPreorder(ref req, ref i, s, 0);\\n    }\\n\\n    TreeNode RecoverFromPreorder(ref int req, ref int i, string s, int level)\\n    {\\n        string val = \"\";\\n        req = 0;\\n        while (i < s.Length && s[i] != \\'-\\')\\n        {\\n            val += s[i];\\n            i++;\\n        }\\n        TreeNode node = new TreeNode(int.Parse(val));\\n        while (i < s.Length && s[i] == \\'-\\')\\n        {\\n            req++;\\n            i++;\\n        }\\n        if (req > level)\\n        {\\n            node.left = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n            if (i < s.Length && req > level)\\n                node.right = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n        \\n        return RecoverFromPreorder(ref req, ref i, s, 0);\\n    }\\n\\n    TreeNode RecoverFromPreorder(ref int req, ref int i, string s, int level)\\n    {\\n        string val = \"\";\\n        req = 0;\\n        while (i < s.Length && s[i] != \\'-\\')\\n        {\\n            val += s[i];\\n            i++;\\n        }\\n        TreeNode node = new TreeNode(int.Parse(val));\\n        while (i < s.Length && s[i] == \\'-\\')\\n        {\\n            req++;\\n            i++;\\n        }\\n        if (req > level)\\n        {\\n            node.left = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n            if (i < s.Length && req > level)\\n                node.right = RecoverFromPreorder(ref req, ref i, s, level + 1);\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618838,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n\\n        TreeNode Solve(int level)\\n        {\\n            string val = \"\";\\n            req = 0;\\n            while (i < s.Length && s[i] != \\'-\\')\\n            {\\n                val += s[i];\\n                i++;\\n            }\\n            TreeNode node = new TreeNode(int.Parse(val));\\n            while (i < s.Length && s[i] == \\'-\\')\\n            {\\n                req++;\\n                i++;\\n            }\\n            if (req > level)\\n            {\\n                node.left = Solve(level + 1);\\n                if (i < s.Length && req > level)\\n                    node.right = Solve(level + 1);\\n            }\\n            return node;\\n        }\\n\\n        return Solve(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode RecoverFromPreorder(string s)\\n    {\\n        int i = 0;\\n        int req = 0;\\n\\n        TreeNode Solve(int level)\\n        {\\n            string val = \"\";\\n            req = 0;\\n            while (i < s.Length && s[i] != \\'-\\')\\n            {\\n                val += s[i];\\n                i++;\\n            }\\n            TreeNode node = new TreeNode(int.Parse(val));\\n            while (i < s.Length && s[i] == \\'-\\')\\n            {\\n                req++;\\n                i++;\\n            }\\n            if (req > level)\\n            {\\n                node.left = Solve(level + 1);\\n                if (i < s.Length && req > level)\\n                    node.right = Solve(level + 1);\\n            }\\n            return node;\\n        }\\n\\n        return Solve(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592334,
                "title": "c-solution-with-easy-to-understand-solution",
                "content": "# Intuition\\nThis is one of the most interesting trees question I have ever solved!\\nIn this question, we are given a string such that it shows the preorder traversal and the depth of each node just before it. So, in order to make things easy, I have created a Traversal array with int data type which stores nodes in such a way that depth of node comes before actual node value. \\nEx: \\n![image.png](https://assets.leetcode.com/users/images/b4820a63-83ba-4d67-ae0f-02899fe1d576_1685781852.941001.png)\\n\\nThe vector is : 0 1 1 2 2 3 2 4 1 5 2 6 2 7\\nThe even indices are depths and odd indices are actual node values.\\nSo, 1 has depth 0, 2 has depth 1, 3 has depth 2 and so on..\\nThis will help us get node value and depth of node in numerical form directly.\\n\\n\\n# Approach\\nNow see this : 0 1 *1* 2 2 3 2 4 *1* 5 2 6 2 7\\nNow, since in preorder, the first node is root, so take out 0 1 (first 2 elements of traversal array).\\nNow see the left and right part of the tree in figure.\\nLeft part is : 1 2 2 3 2 4\\nRight part is : 1 5 2 6 2 7\\n\\nIn the vector, if a depth = currentNodeDepth+1 is repeated twice, it means, both left and right subtree exist.\\nIf currentNodeDepth+1 just comes once, it means just one subtree(left) exists. \\nSo here, you can see that depth = 1 is repeated twice (look at italicized 1s at index = 2 and index = 8).\\nNow, send subsequent part of trees for recursion and build trees.\\n\\nAlso note, that if there are no left and right subtrees, then in that case just make node with the appropriate value and return.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* buildTree(vector<int>& Traversal,int i,int j)\\n    {\\n        \\n        if(i >= Traversal.size())\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(Traversal[i+1]);\\n        int depth = Traversal[i]+1;\\n        int count = 0;\\n        int idx;\\n        for(idx=i+2;idx<=j;idx+=2)\\n        {\\n            if(Traversal[idx] == depth)\\n            count++;\\n            if(count==2)\\n            break;\\n        }\\n        if(count==2)\\n        {\\n            root->left = buildTree(Traversal,i+2,idx-2);\\n            root->right = buildTree(Traversal,idx,j);\\n        }\\n        else if(count == 1)\\n        {\\n            root->left = buildTree(Traversal,i+2,j);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>Traversal;\\n        int i = 0;\\n        while(i<traversal.length() && traversal[i]!=\\'-\\'){\\n            i++;\\n        }\\n        Traversal.push_back(0);\\n        Traversal.push_back(stoi(traversal.substr(0,i)));\\n        int st1 = -1;\\n        int st2 = -1;\\n        int depth = 0;\\n    \\n        for(int idx=i;idx<traversal.length();idx++)\\n        {\\n            if(traversal[idx]!=\\'-\\')\\n            {\\n                if(st2==-1)\\n                {\\n                    st2=idx;\\n                    if(st1!=-1)\\n                    {\\n                        Traversal.push_back(depth);\\n                        depth=0;\\n                        st1=-1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(st1==-1)\\n                {\\n                    st1=idx;\\n                    if(st2!=-1)\\n                    {\\n                        Traversal.push_back(stoi(traversal.substr(st2,idx-st2)));\\n                        st2=-1;\\n                    }\\n                }\\n                depth++;\\n            }\\n        }\\n        if(st2!=-1)\\n        Traversal.push_back(stoi(traversal.substr(st2,traversal.length()-st2)));\\n        \\n        return buildTree(Traversal,0,Traversal.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* buildTree(vector<int>& Traversal,int i,int j)\\n    {\\n        \\n        if(i >= Traversal.size())\\n        {\\n            return NULL;\\n        }\\n        TreeNode* root = new TreeNode(Traversal[i+1]);\\n        int depth = Traversal[i]+1;\\n        int count = 0;\\n        int idx;\\n        for(idx=i+2;idx<=j;idx+=2)\\n        {\\n            if(Traversal[idx] == depth)\\n            count++;\\n            if(count==2)\\n            break;\\n        }\\n        if(count==2)\\n        {\\n            root->left = buildTree(Traversal,i+2,idx-2);\\n            root->right = buildTree(Traversal,idx,j);\\n        }\\n        else if(count == 1)\\n        {\\n            root->left = buildTree(Traversal,i+2,j);\\n        }\\n        return root;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        vector<int>Traversal;\\n        int i = 0;\\n        while(i<traversal.length() && traversal[i]!=\\'-\\'){\\n            i++;\\n        }\\n        Traversal.push_back(0);\\n        Traversal.push_back(stoi(traversal.substr(0,i)));\\n        int st1 = -1;\\n        int st2 = -1;\\n        int depth = 0;\\n    \\n        for(int idx=i;idx<traversal.length();idx++)\\n        {\\n            if(traversal[idx]!=\\'-\\')\\n            {\\n                if(st2==-1)\\n                {\\n                    st2=idx;\\n                    if(st1!=-1)\\n                    {\\n                        Traversal.push_back(depth);\\n                        depth=0;\\n                        st1=-1;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(st1==-1)\\n                {\\n                    st1=idx;\\n                    if(st2!=-1)\\n                    {\\n                        Traversal.push_back(stoi(traversal.substr(st2,idx-st2)));\\n                        st2=-1;\\n                    }\\n                }\\n                depth++;\\n            }\\n        }\\n        if(st2!=-1)\\n        Traversal.push_back(stoi(traversal.substr(st2,traversal.length()-st2)));\\n        \\n        return buildTree(Traversal,0,Traversal.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585008,
                "title": "readable-python-recursive-preorder-construction",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    # recursive preorder construction using dashes to infer linkage\\n    # time: O(n), space: O(n)\\n    def recoverFromPreorder(self, traversal: str) -> TreeNode:\\n        def constructTree() -> TreeNode:\\n            nonlocal index\\n            val, depth = depthMap[index]\\n            root = TreeNode(val)\\n            index += 1\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.left = constructTree()\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.right = constructTree()\\n\\n            return root\\n\\n        def constructDepthMap() -> list:\\n            depthMap = []\\n            i = 0\\n            while i < len(traversal):\\n                depth = 0\\n                while i < len(traversal) and traversal[i] == \\'-\\':\\n                    depth += 1\\n                    i += 1\\n                val = 0\\n                while i < len(traversal) and traversal[i].isdigit():\\n                    val = (val * 10) + int(traversal[i])\\n                    i += 1\\n                depthMap.append((val, depth))\\n            return depthMap\\n\\n        depthMap = constructDepthMap()\\n        index = 0\\n        return constructTree()\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    # recursive preorder construction using dashes to infer linkage\\n    # time: O(n), space: O(n)\\n    def recoverFromPreorder(self, traversal: str) -> TreeNode:\\n        def constructTree() -> TreeNode:\\n            nonlocal index\\n            val, depth = depthMap[index]\\n            root = TreeNode(val)\\n            index += 1\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.left = constructTree()\\n\\n            if index == len(depthMap) or depthMap[index][1] != depth+1:\\n                return root\\n            root.right = constructTree()\\n\\n            return root\\n\\n        def constructDepthMap() -> list:\\n            depthMap = []\\n            i = 0\\n            while i < len(traversal):\\n                depth = 0\\n                while i < len(traversal) and traversal[i] == \\'-\\':\\n                    depth += 1\\n                    i += 1\\n                val = 0\\n                while i < len(traversal) and traversal[i].isdigit():\\n                    val = (val * 10) + int(traversal[i])\\n                    i += 1\\n                depthMap.append((val, depth))\\n            return depthMap\\n\\n        depthMap = constructDepthMap()\\n        index = 0\\n        return constructTree()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581882,
                "title": "dfs-java-tree-traversal-faster-than-94-3ms",
                "content": "# Intuition\\nTraverse the tree and set the children based on the index of the string you are currently traversing.\\n\\n# Approach\\nNot the easiest approach to begin with. 2 helper functions getValue() and getLevel() which calculate the value at the point you are at and level, and also return the index where the next phase of value/level begins. Thus you know that if the current level is where you want to be, then you just mutate the parent by adding a child and run dfs on it making him parent. That\\'s the whore idea.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static TreeNode recoverFromPreorder(String preorder) {\\n        int[] meta = getValue(0, preorder);\\n        TreeNode root = new TreeNode(meta[1]);\\n        dfs(meta[0], preorder, 0, root);\\n        return root;\\n    }\\n\\n    private static int dfs(int i, String preorder, int curLevel, TreeNode parent) {\\n        if (i == preorder.length()) return i;\\n\\n        int[] levelLeft = getLevel(i, preorder);\\n        if (levelLeft[1] == curLevel + 1) {\\n            int[] valueLeft = getValue(levelLeft[0], preorder);\\n            parent.left = new TreeNode(valueLeft[1]);\\n            int k = dfs(valueLeft[0], preorder, curLevel+1, parent.left);\\n            int[] levelRight = getLevel(k, preorder);\\n            if (levelRight[1] == curLevel + 1) {\\n                int[] valueRight = getValue(levelRight[0], preorder);\\n                parent.right = new TreeNode(valueRight[1]);\\n                return dfs(valueRight[0], preorder, curLevel+1, parent.right);\\n            }\\n            return k;\\n        }\\n        return i;\\n    }\\n\\n    private static int[] getLevel(int i, String preorder) {\\n        int level = 0;\\n        while (i < preorder.length() && preorder.charAt(i) == \\'-\\') {\\n            level++;\\n            i++;\\n        }\\n        return new int[]{i, level};\\n    }\\n\\n    private static int[] getValue(int i, String preorder) {\\n        int j = i;\\n        while (j < preorder.length() && preorder.charAt(j) != \\'-\\') {\\n            j++;\\n        }\\n        return new int[]{j, Integer.parseInt(preorder.substring(i, j))};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static TreeNode recoverFromPreorder(String preorder) {\\n        int[] meta = getValue(0, preorder);\\n        TreeNode root = new TreeNode(meta[1]);\\n        dfs(meta[0], preorder, 0, root);\\n        return root;\\n    }\\n\\n    private static int dfs(int i, String preorder, int curLevel, TreeNode parent) {\\n        if (i == preorder.length()) return i;\\n\\n        int[] levelLeft = getLevel(i, preorder);\\n        if (levelLeft[1] == curLevel + 1) {\\n            int[] valueLeft = getValue(levelLeft[0], preorder);\\n            parent.left = new TreeNode(valueLeft[1]);\\n            int k = dfs(valueLeft[0], preorder, curLevel+1, parent.left);\\n            int[] levelRight = getLevel(k, preorder);\\n            if (levelRight[1] == curLevel + 1) {\\n                int[] valueRight = getValue(levelRight[0], preorder);\\n                parent.right = new TreeNode(valueRight[1]);\\n                return dfs(valueRight[0], preorder, curLevel+1, parent.right);\\n            }\\n            return k;\\n        }\\n        return i;\\n    }\\n\\n    private static int[] getLevel(int i, String preorder) {\\n        int level = 0;\\n        while (i < preorder.length() && preorder.charAt(i) == \\'-\\') {\\n            level++;\\n            i++;\\n        }\\n        return new int[]{i, level};\\n    }\\n\\n    private static int[] getValue(int i, String preorder) {\\n        int j = i;\\n        while (j < preorder.length() && preorder.charAt(j) != \\'-\\') {\\n            j++;\\n        }\\n        return new int[]{j, Integer.parseInt(preorder.substring(i, j))};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573853,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int, TreeNode *> mp; // depth -> node;\\n        int i = 0, n = traversal.size();\\n\\n        while(i < n) {\\n            int depth = 0;\\n            while(i < n and traversal[i] == \\'-\\') i++, depth++;\\n\\n            string num;\\n            while(i < n and isdigit(traversal[i])) num += traversal[i++];\\n\\n            TreeNode *node = new TreeNode(stoi(num));\\n            if(depth > 0) {\\n                TreeNode *parent = mp[depth - 1];\\n                if(!parent->left) parent->left = node;\\n                else parent->right = node;\\n            }\\n\\n            mp[depth] = node;\\n        }\\n\\n        return mp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n        unordered_map<int, TreeNode *> mp; // depth -> node;\\n        int i = 0, n = traversal.size();\\n\\n        while(i < n) {\\n            int depth = 0;\\n            while(i < n and traversal[i] == \\'-\\') i++, depth++;\\n\\n            string num;\\n            while(i < n and isdigit(traversal[i])) num += traversal[i++];\\n\\n            TreeNode *node = new TreeNode(stoi(num));\\n            if(depth > 0) {\\n                TreeNode *parent = mp[depth - 1];\\n                if(!parent->left) parent->left = node;\\n                else parent->right = node;\\n            }\\n\\n            mp[depth] = node;\\n        }\\n\\n        return mp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565731,
                "title": "swift-solution-dfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var arrNodesDepth: [(Int, Int)] = []\\n    var tree: TreeNode?\\n    var iteration = 1\\n\\n    func recoverFromPreorder(_ traversal: String) -> TreeNode? {\\n        var depth = 0 \\n        var number: String = \"\"\\n        var endNumber = false\\n\\n        for char in traversal {\\n            if char == \"-\" {\\n                if endNumber {\\n                    arrNodesDepth.append((Int(number)!, depth))\\n                    number = \"\"\\n                    endNumber = false\\n                    depth = 0\\n                }\\n\\n                depth += 1\\n            } else {\\n                number += String(char)\\n                endNumber = true\\n            }\\n        }\\n        arrNodesDepth.append((Int(number)!, depth))\\n\\n        tree = TreeNode(arrNodesDepth[0].0)\\n\\n        dfs(tree, 0)\\n\\n        return tree\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ prevDepth: Int) {\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 > prevDepth {\\n            node?.left = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.left, prevDepth + 1)\\n        }\\n\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 - 1 == prevDepth {\\n            node?.right = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.right, prevDepth + 1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var arrNodesDepth: [(Int, Int)] = []\\n    var tree: TreeNode?\\n    var iteration = 1\\n\\n    func recoverFromPreorder(_ traversal: String) -> TreeNode? {\\n        var depth = 0 \\n        var number: String = \"\"\\n        var endNumber = false\\n\\n        for char in traversal {\\n            if char == \"-\" {\\n                if endNumber {\\n                    arrNodesDepth.append((Int(number)!, depth))\\n                    number = \"\"\\n                    endNumber = false\\n                    depth = 0\\n                }\\n\\n                depth += 1\\n            } else {\\n                number += String(char)\\n                endNumber = true\\n            }\\n        }\\n        arrNodesDepth.append((Int(number)!, depth))\\n\\n        tree = TreeNode(arrNodesDepth[0].0)\\n\\n        dfs(tree, 0)\\n\\n        return tree\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ prevDepth: Int) {\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 > prevDepth {\\n            node?.left = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.left, prevDepth + 1)\\n        }\\n\\n        if iteration == arrNodesDepth.count { return }\\n        if arrNodesDepth[iteration].1 - 1 == prevDepth {\\n            node?.right = TreeNode(arrNodesDepth[iteration].0)\\n            iteration += 1\\n            dfs(node?.right, prevDepth + 1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557806,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    TreeNode *readNode(string &S, int &i) {\\n        int n = 0;\\n        for (; i < S.size() && isdigit(S[i]); ++i) n = 10 * n + S[i] - \\'0\\';\\n        return new TreeNode(n);\\n    }\\n    int readDash(string &S, int &i) {\\n        int cnt = 0;\\n        for (; i < S.size() && S[i] == \\'-\\'; ++i, ++cnt);\\n        return cnt;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int i = 0, N = S.size();\\n        auto root = readNode(S, i);\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while (i < S.size()) {\\n            int dep = readDash(S, i);\\n            auto node = readNode(S, i);\\n            while (dep < s.size()) s.pop();\\n            auto p = s.top();\\n            if (p->left) p->right = node;\\n            else p->left = node;\\n            s.push(node);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```\\n\\n```Java []\\nclass Solution {\\n    private int index;\\n    private char[] chars;\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    private void helper(int level, TreeNode parent) {\\n        int numOfDashes = getNumOfDashes();\\n        \\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            helper(level + 1, newNode);\\n            \\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        index = i;\\n        return count;\\n    }\\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    TreeNode *readNode(string &S, int &i) {\\n        int n = 0;\\n        for (; i < S.size() && isdigit(S[i]); ++i) n = 10 * n + S[i] - \\'0\\';\\n        return new TreeNode(n);\\n    }\\n    int readDash(string &S, int &i) {\\n        int cnt = 0;\\n        for (; i < S.size() && S[i] == \\'-\\'; ++i, ++cnt);\\n        return cnt;\\n    }\\npublic:\\n    TreeNode* recoverFromPreorder(string S) {\\n        int i = 0, N = S.size();\\n        auto root = readNode(S, i);\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while (i < S.size()) {\\n            int dep = readDash(S, i);\\n            auto node = readNode(S, i);\\n            while (dep < s.size()) s.pop();\\n            auto p = s.top();\\n            if (p->left) p->right = node;\\n            else p->left = node;\\n            s.push(node);\\n        }\\n        return root;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution(object):\\n    def recoverFromPreorder(self, S):\\n        vals = [(len(s[1]), int(s[2])) for s in re.findall(\"((-*)(\\\\d+))\", S)][::-1]\\n\\n        def fn(level):\\n            if not vals or level != vals[-1][0]: return None\\n            node = TreeNode(vals.pop()[1])\\n            node.left = fn(level+1)\\n            node.right = fn(level+1)\\n            return node\\n        return fn(0)\\n```\n```Java []\\nclass Solution {\\n    private int index;\\n    private char[] chars;\\n    \\n    public TreeNode recoverFromPreorder(String S) {\\n        if (S == null || S.length() == 0)\\n            return null;\\n        \\n        index = 0;\\n        chars = S.toCharArray();\\n        \\n        TreeNode root = new TreeNode(getNodeVal());\\n        helper(0, root);\\n        return root;\\n    }\\n    private void helper(int level, TreeNode parent) {\\n        int numOfDashes = getNumOfDashes();\\n        \\n        while (numOfDashes == level + 1) {\\n            index += numOfDashes;\\n            TreeNode newNode = new TreeNode(getNodeVal());\\n            \\n            if (parent.left == null)\\n                parent.left = newNode;\\n            else\\n                parent.right = newNode;\\n            \\n            helper(level + 1, newNode);\\n            \\n            numOfDashes = getNumOfDashes();\\n        }\\n    }\\n    private int getNodeVal() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0, i;\\n        for (i = index; i < chars.length && chars[i] != \\'-\\'; i++)\\n            count = count * 10 + (chars[i] - \\'0\\');\\n        \\n        index = i;\\n        return count;\\n    }\\n    private int getNumOfDashes() {\\n        if (index >= chars.length)\\n            return -1;\\n        \\n        int count = 0;\\n        for (int i = index; i < chars.length && chars[i] == \\'-\\'; i++)\\n            count ++;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554851,
                "title": "unordered-map-c-solution",
                "content": "# Intuition \\nalways parent will be read first then child\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\napproach is to use unordered map and store nodes based on depth. connect child nodes with parent node\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n       \\n        int str_length=traversal.length();\\n        if(str_length==0)\\n        {\\n            return nullptr;\\n        }\\n        unordered_map<int,vector<TreeNode*>> mpp;\\n        \\n         int start_no=0;\\n        int curr_depth=0;\\n        int index=0;\\n        while(traversal[index]!=\\'-\\' && index<str_length)\\n            {\\n                index++;\\n            }\\n            int end_no=index;\\n            string s=traversal.substr(start_no,end_no-start_no);\\n            int number= stoi(s);\\n              TreeNode* head=new TreeNode(number);\\n            mpp[curr_depth].push_back(head);\\n       \\n        int i=end_no;\\n        while(i<str_length)\\n        {\\n            curr_depth=0;\\n            while(traversal[i]==\\'-\\' && i<str_length)\\n            {\\n              curr_depth++;\\n              i++;\\n            }\\n            int start_index=i;\\n            while(traversal[i]!=\\'-\\' && i<str_length)\\n            {\\n                i++;\\n            }\\n            int end_index=i;\\n            string s=traversal.substr(start_index,end_index-start_index);\\n            number= stoi(s);\\n        \\n                TreeNode* temp= new TreeNode(number);\\n\\n                 TreeNode* parent=mpp[curr_depth-1].back();\\n                if(parent->left==nullptr)\\n                {\\n                    parent->left=temp;\\n                }\\n                else\\n                {\\n                    parent->right=temp;\\n                }\\n                mpp[curr_depth].push_back(temp);\\n            }\\n\\n        return head;\\n        }\\n\\n        \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string traversal) {\\n       \\n        int str_length=traversal.length();\\n        if(str_length==0)\\n        {\\n            return nullptr;\\n        }\\n        unordered_map<int,vector<TreeNode*>> mpp;\\n        \\n         int start_no=0;\\n        int curr_depth=0;\\n        int index=0;\\n        while(traversal[index]!=\\'-\\' && index<str_length)\\n            {\\n                index++;\\n            }\\n            int end_no=index;\\n            string s=traversal.substr(start_no,end_no-start_no);\\n            int number= stoi(s);\\n              TreeNode* head=new TreeNode(number);\\n            mpp[curr_depth].push_back(head);\\n       \\n        int i=end_no;\\n        while(i<str_length)\\n        {\\n            curr_depth=0;\\n            while(traversal[i]==\\'-\\' && i<str_length)\\n            {\\n              curr_depth++;\\n              i++;\\n            }\\n            int start_index=i;\\n            while(traversal[i]!=\\'-\\' && i<str_length)\\n            {\\n                i++;\\n            }\\n            int end_index=i;\\n            string s=traversal.substr(start_index,end_index-start_index);\\n            number= stoi(s);\\n        \\n                TreeNode* temp= new TreeNode(number);\\n\\n                 TreeNode* parent=mpp[curr_depth-1].back();\\n                if(parent->left==nullptr)\\n                {\\n                    parent->left=temp;\\n                }\\n                else\\n                {\\n                    parent->right=temp;\\n                }\\n                mpp[curr_depth].push_back(temp);\\n            }\\n\\n        return head;\\n        }\\n\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553271,
                "title": "c-stack-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nint readnum(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] != \\'-\\') {\\n        res = res * 10 + s[ind] - \\'0\\';\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\nint readlevel(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] == \\'-\\') {\\n        res++;\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n        int i = 0;\\n        int num = readnum(s, i);\\n        auto head = new TreeNode(num);\\n\\n        stack<TreeNode*> st;\\n        st.push(head);\\n\\n        while (!st.empty()) {\\n            int lev = st.size();\\n            auto cur = st.top(); \\n\\n            if (i == s.size()) break;\\n\\n            int tmp = i;\\n            int lev1 = readlevel(s, i);\\n            if ( lev1 < lev) {\\n                i = tmp;\\n                st.pop();\\n                continue;\\n            }\\n\\n            if (lev == lev1) {\\n                int num1 = readnum(s, i);\\n                if (cur->left == nullptr) {\\n                    cur->left = new TreeNode(num1);\\n                    st.push(cur->left);\\n                } else {\\n                    cur->right = new TreeNode(num1);\\n                    st.push(cur->right);\\n                }\\n\\n                if (i == s.size()) break;\\n            }\\n\\n        }\\n\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nint readnum(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] != \\'-\\') {\\n        res = res * 10 + s[ind] - \\'0\\';\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\nint readlevel(string& s, int& ind) {\\n    int res = 0;\\n    while (ind < s.size() &&  s[ind] == \\'-\\') {\\n        res++;\\n        ++ind;\\n    }\\n    return res;\\n}\\n\\npublic:\\n    TreeNode* recoverFromPreorder(string s) {\\n        \\n        int i = 0;\\n        int num = readnum(s, i);\\n        auto head = new TreeNode(num);\\n\\n        stack<TreeNode*> st;\\n        st.push(head);\\n\\n        while (!st.empty()) {\\n            int lev = st.size();\\n            auto cur = st.top(); \\n\\n            if (i == s.size()) break;\\n\\n            int tmp = i;\\n            int lev1 = readlevel(s, i);\\n            if ( lev1 < lev) {\\n                i = tmp;\\n                st.pop();\\n                continue;\\n            }\\n\\n            if (lev == lev1) {\\n                int num1 = readnum(s, i);\\n                if (cur->left == nullptr) {\\n                    cur->left = new TreeNode(num1);\\n                    st.push(cur->left);\\n                } else {\\n                    cur->right = new TreeNode(num1);\\n                    st.push(cur->right);\\n                }\\n\\n                if (i == s.size()) break;\\n            }\\n\\n        }\\n\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1697214,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            },
            {
                "id": 2061944,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            },
            {
                "id": 1869174,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "2leetcode: Why this one is hard? Why??? Really don\\'t understand how you guys pick the difficulty level, often u mark medium as hard, and vise versa. Don\\'t you think you should base your decision on acceptance rate? like >75% -> easy, 45-74 -> medium, and < 45 - hard or something like that? Seems more reasonable to me than your \\'estimations\\' "
                    },
                    {
                        "username": "KautsIITD",
                        "content": "But there can be questions which are hard to solve but don\\'t have much Edge cases to Fail once implemented, Hence higher success rate while taking sufficient time to implement.."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "agreed, this one seems very doable (haven\\'t tried it yet). I just did 1443, which seems way harder. Maybe have peoplpe vote after they completed it, there are a couple weird ones out there. Although acceptance rate says more about if there are test cases people haven\\'t thought of right?"
                    },
                    {
                        "username": "yzch1128",
                        "content": "I was asked a very similar question during a FAANG on-site interview. But that question was better wrapped and you had to realize it is in fact a preorder sequence of an n-ary tree and then rebuild it, and then do some traversal to implement some other functions required by the interviewer. The interview was only 45mins and you had at most 40mins for the coding, and this question is like the first half of the coding.\\nSo if you are able to understand and code this problem bug free within 20 mins, you should be more than qualify to pass FAANG coding interview.\\nThe question itself is definitely not hard."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Should be under medium to easy category."
                    }
                ]
            }
        ]
    },
    {
        "title": "Average Salary Excluding the Minimum and Maximum Salary",
        "question_content": "<p>You are given an array of <strong>unique</strong> integers <code>salary</code> where <code>salary[i]</code> is the salary of the <code>i<sup>th</sup></code> employee.</p>\n\n<p>Return <em>the average salary of employees excluding the minimum and maximum salary</em>. Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> salary = [4000,3000,1000,2000]\n<strong>Output:</strong> 2500.00000\n<strong>Explanation:</strong> Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> salary = [1000,2000,3000]\n<strong>Output:</strong> 2000.00000\n<strong>Explanation:</strong> Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= salary.length &lt;= 100</code></li>\n\t<li><code>1000 &lt;= salary[i] &lt;= 10<sup>6</sup></code></li>\n\t<li>All the integers of <code>salary</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 708061,
                "title": "c-one-liner",
                "content": "Note the conversion to `double` (`0.` - with a dot - as the initial value for `reduce`).\\n\\nSomehow I missed this in a hurry and got 5 minutes penalty during the contest!!\\n\\n```cpp\\ndouble average(vector<int>& s) {\\n    return (reduce(begin(s), end(s), 0.) - *min_element(begin(s), end(s)) \\n        - *max_element(begin(s), end(s))) / (s.size() - 2);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\ndouble average(vector<int>& s) {\\n    return (reduce(begin(s), end(s), 0.) - *min_element(begin(s), end(s)) \\n        - *max_element(begin(s), end(s))) / (s.size() - 2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708240,
                "title": "java-python-3-2-methods-one-pass-and-short-codes-w-analysis",
                "content": "**One Pass:**\\n\\n```java\\n    public double average(int[] salary) {\\n        double sum = 0d;\\n        int M = Integer.MIN_VALUE, m = Integer.MAX_VALUE;\\n        for (int s : salary) {\\n            m = Math.min(m, s);\\n            M = Math.max(M, s);\\n            sum += s;\\n        }\\n        return (sum - m - M) / (salary.length - 2);\\n    }\\n```\\n```python\\n    def average(self, salary: List[int]) -> float:\\n        m, M, total = math.inf, -math.inf, 0.0\\n        for s in salary:\\n            m, M = min(m, s), max(M, s)\\n            total += s\\n        return (total - m - M) / (len(salary) - 2)\\n```\\n\\n----\\n**Short code:**\\nThe following java code has been improved by **@sydym6**\\n```java\\n\\nimport java.util.IntSummaryStatistics;\\n\\n    public double average(int[] salary) {\\n        IntSummaryStatistics stat = Arrays.stream(salary).summaryStatistics();\\n        return (double)(stat.getSum() - stat.getMax() - stat.getMin()) / (stat.getCount() - 2);\\n    }\\n```\\n\\n\\n```python\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public double average(int[] salary) {\\n        double sum = 0d;\\n        int M = Integer.MIN_VALUE, m = Integer.MAX_VALUE;\\n        for (int s : salary) {\\n            m = Math.min(m, s);\\n            M = Math.max(M, s);\\n            sum += s;\\n        }\\n        return (sum - m - M) / (salary.length - 2);\\n    }\\n```\n```python\\n    def average(self, salary: List[int]) -> float:\\n        m, M, total = math.inf, -math.inf, 0.0\\n        for s in salary:\\n            m, M = min(m, s), max(M, s)\\n            total += s\\n        return (total - m - M) / (len(salary) - 2)\\n```\n```java\\n\\nimport java.util.IntSummaryStatistics;\\n\\n    public double average(int[] salary) {\\n        IntSummaryStatistics stat = Arrays.stream(salary).summaryStatistics();\\n        return (double)(stat.getSum() - stat.getMax() - stat.getMin()) / (stat.getCount() - 2);\\n    }\\n```\n```python\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3472407,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The problem requires finding the average salary of employees excluding the minimum and maximum salary values. To solve this, we need to first sort the array of salaries and then compute the sum of salaries excluding the minimum and maximum values. Finally, we divide this sum by the count of salaries minus two to obtain the average salary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. Sort the array of salaries in ascending order.\\n>2. Compute the sum of salaries by iterating over the sorted array.\\n>3. Compute the sum of salaries excluding the minimum and maximum values (i.e., the first and last elements of the sorted array).\\n>4. Divide the sum of salaries excluding the minimum and maximum values by the count of salaries minus two to obtain the average salary.\\n>5. Return the average salary.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The time complexity of the algorithm is O(nlogn), where n is the length of the input array. This is because sorting the array takes O(nlogn) time, and iterating over the array to compute the sum of salaries takes O(n) time. The division and subtraction operations take constant time, so they do not contribute to the time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n> The space complexity of the algorithm is O(1), because we are only using constant extra space to store the sum of salaries, the minimum and maximum values, and the length of the array.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n```java []\\nclass Solution {\\n    public double average(int[] salary) {\\n        // Sort the salary array in ascending order\\n        Arrays.sort(salary);\\n        \\n        // Compute the sum of all salaries\\n        double sum = 0;\\n        for(int i = 0; i < salary.length; i++) {\\n            sum = sum + salary[i];\\n        }\\n        \\n        // Return the average of salaries excluding the minimum and maximum\\n        // by subtracting the two extreme salaries from the sum and dividing\\n        // by the count of salaries minus two\\n        return (sum - (salary[0] + salary[salary.length - 1])) / (salary.length - 2);\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        double sum = 0;\\n        for (int i = 0; i < salary.size(); i++) {\\n            sum += salary[i];\\n        }\\n        return (sum - salary[0] - salary[salary.size() - 1]) / (salary.size() - 2);\\n    }\\n};\\n\\n```\\n``` python3 []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        sum = 0\\n        for s in salary:\\n            sum += s\\n        return (sum - salary[0] - salary[-1]) / (len(salary) - 2)\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public double average(int[] salary) {\\n        // Sort the salary array in ascending order\\n        Arrays.sort(salary);\\n        \\n        // Compute the sum of all salaries\\n        double sum = 0;\\n        for(int i = 0; i < salary.length; i++) {\\n            sum = sum + salary[i];\\n        }\\n        \\n        // Return the average of salaries excluding the minimum and maximum\\n        // by subtracting the two extreme salaries from the sum and dividing\\n        // by the count of salaries minus two\\n        return (sum - (salary[0] + salary[salary.length - 1])) / (salary.length - 2);\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        double sum = 0;\\n        for (int i = 0; i < salary.size(); i++) {\\n            sum += salary[i];\\n        }\\n        return (sum - salary[0] - salary[salary.size() - 1]) / (salary.size() - 2);\\n    }\\n};\\n\\n```\n``` python3 []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        sum = 0\\n        for s in salary:\\n            sum += s\\n        return (sum - salary[0] - salary[-1]) / (len(salary) - 2)\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878110,
                "title": "easy-to-read-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nGot a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst average = salary => {\\n\\n    let max = Math.max(...salary)\\n    let min = Math.min(...salary)\\n    let sum = salary.reduce((a,b) => a + b)\\n    \\n    sum -= max\\n    sum -= min\\n    \\n    return sum / (salary.length - 2)\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst average = salary => {\\n\\n    let max = Math.max(...salary)\\n    let min = Math.min(...salary)\\n    let sum = salary.reduce((a,b) => a + b)\\n    \\n    sum -= max\\n    sum -= min\\n    \\n    return sum / (salary.length - 2)\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708543,
                "title": "java-simple-one-loop-o-n",
                "content": "```\\n    public double average(int[] salary) {\\n        double sum = 0;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, n = salary.length;\\n        for (int num : salary) {\\n            sum += num;\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        return (sum - min - max) / (n - 2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double average(int[] salary) {\\n        double sum = 0;\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, n = salary.length;\\n        for (int num : salary) {\\n            sum += num;\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n        return (sum - min - max) / (n - 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571392,
                "title": "python-1-liner-beginner-friendly",
                "content": "Upvote if it helped. Thanks\\n\\n```\\ndef average(self, salary: List[int]) -> float:\\n\\treturn ((sum(salary)- max(salary) - min(salary))/ (len(salary)-2) )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef average(self, salary: List[int]) -> float:\\n\\treturn ((sum(salary)- max(salary) - min(salary))/ (len(salary)-2) )\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 708105,
                "title": "clean-python-3-one-pass-o-n",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        s, m, M = 0, float(\\'inf\\'), float(\\'-inf\\')\\n        for num in salary:\\n            s += num\\n            m, M = min(m, num), max(M, num)\\n        return (s - m - M) / (len(salary) - 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        s, m, M = 0, float(\\'inf\\'), float(\\'-inf\\')\\n        for num in salary:\\n            s += num\\n            m, M = min(m, num), max(M, num)\\n        return (s - m - M) / (len(salary) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740874,
                "title": "python-one-liner-o-n",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471661,
                "title": "c-easy-2-methods-100-beat",
                "content": "# Intuition\\nSimply Travers the array and find minimum ans maximum number in array\\nAdd Every element to a temprary varialbe (DATA TYPE MUST BE DOUBLE ) so that it can be in Decimal.\\n\\n# Approach 1\\nFind Minimum and Maximum value in Array\\nFind Sum of whole Array \\nSubtract Minimum and Maximum Value from total sum\\nFind Average with number to elments = n-2\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# code 1\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        double ans =0;\\n        int mn = 1e9 , mx=0;\\n        for(int i =0;i<s.size();i++){\\n            mn = min(mn , s[i]);\\n            mx = max(mx,s[i]);\\n            ans +=s[i];\\n        }\\n        ans = ans - mn - mx;\\n        ans = ans/(s.size()-2);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 2\\nSort the Array\\nFind Sum of whole Array \\nSubtract First and Last element of array from total sum or (you can skip these two element while finding sum)\\nFind Average with number to elments = n-2\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        double ans =0;\\n        int n = s.size();\\n        for(int i=1; i<n-1;i++){\\n            ans +=s[i];\\n        }\\n        ans = ans/(n-2);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        double ans =0;\\n        int mn = 1e9 , mx=0;\\n        for(int i =0;i<s.size();i++){\\n            mn = min(mn , s[i]);\\n            mx = max(mx,s[i]);\\n            ans +=s[i];\\n        }\\n        ans = ans - mn - mx;\\n        ans = ans/(s.size()-2);\\n        return ans;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        double ans =0;\\n        int n = s.size();\\n        for(int i=1; i<n-1;i++){\\n            ans +=s[i];\\n        }\\n        ans = ans/(n-2);\\n        return ans;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471419,
                "title": "easy-solution-of-java-c-100-faster-code-easy-to-understand-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public double average(int[] s) {\\n        int max =0;\\n        int min = 100000000;\\n        double avg=0;\\n\\t\\t// getting max and min salary\\n        for(int i=0;i<s.length;i++)\\n        {\\n            if(s[i]>max)\\n                max=s[i];\\n            if(s[i]<min)\\n                min =s[i];\\n        }\\n         \\n\\t\\t // adding all the salaries\\n\\t\\t \\n        for(int i=0;i<s.length;i++)\\n        {\\n            avg+=s[i];\\n        }\\n        avg = (avg-min-max)/(s.length-2); // finding mean and excluding min and max values. \\n        return avg;\\n        \\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int sum=0;\\n        double avg;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<salary.size()-1;i++){\\n            sum+=salary[i];\\n        }\\n        avg=(double)sum/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] s) {\\n        int max =0;\\n        int min = 100000000;\\n        double avg=0;\\n\\t\\t// getting max and min salary\\n        for(int i=0;i<s.length;i++)\\n        {\\n            if(s[i]>max)\\n                max=s[i];\\n            if(s[i]<min)\\n                min =s[i];\\n        }\\n         \\n\\t\\t // adding all the salaries\\n\\t\\t \\n        for(int i=0;i<s.length;i++)\\n        {\\n            avg+=s[i];\\n        }\\n        avg = (avg-min-max)/(s.length-2); // finding mean and excluding min and max values. \\n        return avg;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int sum=0;\\n        double avg;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<salary.size()-1;i++){\\n            sum+=salary[i];\\n        }\\n        avg=(double)sum/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257406,
                "title": "simple-english-language-code-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minsal=min(salary)\\n        maxsal=max(salary)\\n        salary.pop(salary.index(minsal))\\n        salary.pop(salary.index(maxsal))\\n        sum1=sum(salary)\\n        average=sum1/len(salary)\\n        return float(average)\\n        #please do upvote it will encourage me alot.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minsal=min(salary)\\n        maxsal=max(salary)\\n        salary.pop(salary.index(minsal))\\n        salary.pop(salary.index(maxsal))\\n        sum1=sum(salary)\\n        average=sum1/len(salary)\\n        return float(average)\\n        #please do upvote it will encourage me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471561,
                "title": "java-simple-math-beats-100-6-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public double average(int[] salary) {\\n    int sum = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n    \\n    for (var s : salary) {\\n      sum += s;\\n      min = Math.min(min, s);\\n      max = Math.max(max, s);\\n    }\\n    return (double) (sum - min - max) / (salary.length - 2);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public double average(int[] salary) {\\n    int sum = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n    \\n    for (var s : salary) {\\n      sum += s;\\n      min = Math.min(min, s);\\n      max = Math.max(max, s);\\n    }\\n    return (double) (sum - min - max) / (salary.length - 2);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 709290,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        if(salary.size()==2) return 0;\\n        int mins = INT_MAX;\\n        int maxs = INT_MIN;\\n        double sum = 0;\\n        for(int x: salary){\\n            mins = min(mins,x);\\n            maxs = max(maxs,x);\\n            sum+=(double)x;\\n        }\\n        return (sum - (mins+maxs)) / (salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        if(salary.size()==2) return 0;\\n        int mins = INT_MAX;\\n        int maxs = INT_MIN;\\n        double sum = 0;\\n        for(int x: salary){\\n            mins = min(mins,x);\\n            maxs = max(maxs,x);\\n            sum+=(double)x;\\n        }\\n        return (sum - (mins+maxs)) / (salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272943,
                "title": "naive-solution-in-java-friendly-to-beginners",
                "content": "\\n# Complexity\\n- Time complexity:\\nn (log n)\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sumOfSalaries = 0;\\n        for (int i = 1; i < salary.length - 1; i++) {\\n            sumOfSalaries += salary[i];\\n        }\\n        return sumOfSalaries / (salary.length - 2);\\n    }\\n}\\n```\\n\\nPlease upvote, if you find this useful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sumOfSalaries = 0;\\n        for (int i = 1; i < salary.length - 1; i++) {\\n            sumOfSalaries += salary[i];\\n        }\\n        return sumOfSalaries / (salary.length - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880063,
                "title": "swift-one-liner",
                "content": "**Solution**\\n```\\nclass Solution {\\n    func average(_ salary: [Int]) -> Double {\\n        return Double(salary.reduce(0, +) - (salary.min()! + salary.max()!)) / Double(salary.count - 2)\\n    }\\n}\\n```\\n\\n**What\\'s Happening**\\n- Sum the array by calling ```salary.reduce(0, +)``` and then subtract the min and max values of the array.\\n- You can get the min and max values by calling ```salary.min()!``` and ```salary.max()!```. It\\'s safe to force unwrap these since there is guaranteed to be both a unique min and max value in this problem.\\n- Cast the sum to a double and divide it by the number of items in the array minus two items: ```salary.count - 2``` (it\\'s minus two because we are omitting the min and max values). This right side of the equation must also be cast to a double or the Swift compiler will unleash its fury.\\n- Now you have the result and it just needs to be returned!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func average(_ salary: [Int]) -> Double {\\n        return Double(salary.reduce(0, +) - (salary.min()! + salary.max()!)) / Double(salary.count - 2)\\n    }\\n}\\n```\n```salary.reduce(0, +)```\n```salary.min()!```\n```salary.max()!```\n```salary.count - 2```",
                "codeTag": "Java"
            },
            {
                "id": 3501193,
                "title": "best-solution-by-java-in-runtime-0ms-and-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n         Arrays.sort(salary);\\n        double sum = 0.0;\\n\\n        int i = salary.length - 2;\\n        while (i != 0){\\n            sum += salary[i--];\\n        }\\n\\n        return  sum / (salary.length-2);\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/73af5daa-5d70-491b-83f9-475393f7f820_1683558648.4607437.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n         Arrays.sort(salary);\\n        double sum = 0.0;\\n\\n        int i = salary.length - 2;\\n        while (i != 0){\\n            sum += salary[i--];\\n        }\\n\\n        return  sum / (salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471334,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "The idea is to calculate the total sum $$sum$$, the minimum value $$mi$$ and the maximum value $$mx$$. The average salary of employees excluding the minimum and maximum salary would be $$sum - mi - mx$$. Since we exclude two items, we just need to divide by $$len(salary) - 2$$.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        // calculate the total sum\\n        int sum = accumulate(salary.begin(), salary.end(), 0);\\n        // find the maximum value\\n        int mx = *max_element(salary.begin(), salary.end());\\n        // find the minimum value\\n        int mi = *min_element(salary.begin(), salary.end());\\n\\t\\t// exclude mi & mx and get the avg \\n        return (double) (sum - mx - mi) / (salary.size() - 2);\\n    }\\n};\\n```\\n\\nWe can also sort the input and get mi and mx from the beginning and the end.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n\\t\\t// sort the salary to get the mi & mx from the beginning and the end\\n        sort(salary.begin(), salary.end());\\n        // calculate the total sum\\n        double sum = accumulate(salary.begin(), salary.end(), 0.0);\\n        // remove the minimum value\\n        sum -= salary[0];\\n        // remove the maximum value\\n        sum -= salary[n - 1];\\n\\t\\t// exclude mi & mx and get the avg \\n        return sum / (n - 2);\\n    }\\n};\\n```\\n\\nor we can do it without STL\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n        double sum = 0;\\n        int mi = INT_MAX, mx = INT_MIN;\\n        // calculate sum, mi, mx in a native way\\n        for (auto x : salary) {\\n            sum += x;\\n            if (x < mi) mi = x;\\n            if (x > mx) mx = x;\\n        }\\n        // remove the minimum value\\n        sum -= mi;\\n        // remove the maximum value\\n        sum -= mx;\\n\\t\\t// exclude mi & mx and get the avg \\n        return sum / (n - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        // calculate the total sum\\n        int sum = accumulate(salary.begin(), salary.end(), 0);\\n        // find the maximum value\\n        int mx = *max_element(salary.begin(), salary.end());\\n        // find the minimum value\\n        int mi = *min_element(salary.begin(), salary.end());\\n\\t\\t// exclude mi & mx and get the avg \\n        return (double) (sum - mx - mi) / (salary.size() - 2);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n\\t\\t// sort the salary to get the mi & mx from the beginning and the end\\n        sort(salary.begin(), salary.end());\\n        // calculate the total sum\\n        double sum = accumulate(salary.begin(), salary.end(), 0.0);\\n        // remove the minimum value\\n        sum -= salary[0];\\n        // remove the maximum value\\n        sum -= salary[n - 1];\\n\\t\\t// exclude mi & mx and get the avg \\n        return sum / (n - 2);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n        double sum = 0;\\n        int mi = INT_MAX, mx = INT_MIN;\\n        // calculate sum, mi, mx in a native way\\n        for (auto x : salary) {\\n            sum += x;\\n            if (x < mi) mi = x;\\n            if (x > mx) mx = x;\\n        }\\n        // remove the minimum value\\n        sum -= mi;\\n        // remove the maximum value\\n        sum -= mx;\\n\\t\\t// exclude mi & mx and get the avg \\n        return sum / (n - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723623,
                "title": "c-speed-mem-o-n-o-1-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        \\n        double max = DBL_MIN;\\n        double min = DBL_MAX;\\n        double sum = 0;\\n        \\n        for(int i=0; i < salary.size(); i++){\\n            \\n            sum += salary[i];\\n            \\n            if(salary[i] < min)\\n               min = salary[i];\\n            \\n            if(salary[i] > max)\\n               max = salary[i];\\n            \\n        }\\n        \\n        \\n        sum = sum - min - max;\\n        return sum / (salary.size()-2);\\n           \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        \\n        double max = DBL_MIN;\\n        double min = DBL_MAX;\\n        double sum = 0;\\n        \\n        for(int i=0; i < salary.size(); i++){\\n            \\n            sum += salary[i];\\n            \\n            if(salary[i] < min)\\n               min = salary[i];\\n            \\n            if(salary[i] > max)\\n               max = salary[i];\\n            \\n        }\\n        \\n        \\n        sum = sum - min - max;\\n        return sum / (salary.size()-2);\\n           \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471975,
                "title": "solution-with-proper-approach-for-learning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s a simple problem based on implementation, just think before\\nreaching to hint or solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the Array\\n2. start for loop from 1st index(to ignore minimum value since arrary is sorted) and end to (size-1) to ignore last or maximum value.\\n3. along with a use a counter varable to store the count the number of element which sum is being taken for calculating average.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double ans=0;\\n        int n=salary.size(),count=0;\\n        for(int i=1;i<n-1;i++){\\n            ans+=salary[i];\\n            count++;\\n        }\\n        ans=ans/count;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double ans=0;\\n        int n=salary.size(),count=0;\\n        for(int i=1;i<n-1;i++){\\n            ans+=salary[i];\\n            count++;\\n        }\\n        ans=ans/count;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228260,
                "title": "python3-beats-93-33-simple-beginner-solution",
                "content": "# Please upvote guys if you find the solution helpful.\\uD83E\\uDEF6\\uD83E\\uDEF6\\n\\n![image.png](https://assets.leetcode.com/users/images/5a1742a6-e7a4-4e6c-8fb3-f91d19861c2f_1677318800.0717812.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)\\n        del salary[0]\\n        del salary[len(salary)-1]\\n        return sum(salary)/len(salary)\\n```\\n                         or\\n\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)\\n        return sum(salary[1:-1])/len(salary[1:-1])\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)\\n        del salary[0]\\n        del salary[len(salary)-1]\\n        return sum(salary)/len(salary)\\n```\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)\\n        return sum(salary[1:-1])/len(salary[1:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020806,
                "title": "python3-easy-and-understandable-code",
                "content": "This approach uses slicing techniques and inbuilt functions like sort(), sum() and len()\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        data=salary[1:-1]\\n        return sum(data)/len(data)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        data=salary[1:-1]\\n        return sum(data)/len(data)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747901,
                "title": "0ms-easy-java-solution-faster-than-100",
                "content": "*Java solution with 0ms runtime\\nCode explained in comments along with code*\\n\\n**Code**\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n\\t\\n\\t    // max_salary is the for finding the max salary in the salary arr\\n        // min_salary is the for finding the min sakaey in the salary arr\\n        int min_salary = Integer.MAX_VALUE;\\n        int max_salary = Integer.MIN_VALUE;\\n\\t\\t// salary array length\\n        int len = salary.length;\\n        // The result should be in double thats why sum as double\\n        double sum = 0;\\n        \\n        for(int i:salary){\\n\\t\\t// We compare current salary with our min and max salary,\\n\\t\\t// and if its replaceable then we will replace\\n            min_salary = Math.min(i,min_num);\\n            max_salary = Math.max(i,max_num);\\n\\t\\t\\t\\n         // We keep adding the salary to get the sum\\n\\t\\t\\tsum+=i;\\n        }\\n        // we subtract the max & min from the sum\\n        sum = sum - min_salary - max_salary;\\n        \\n\\t\\t// find average of salary and return \\n\\t\\t// len -  2 is beacuse we have to remove min and max salary so minus 2 in salary array length\\n        return sum / (len - 2);\\n    }\\n}\\n```\\n**If  solution helped you, please upvote it that motivates me **",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n\\t\\n\\t    // max_salary is the for finding the max salary in the salary arr\\n        // min_salary is the for finding the min sakaey in the salary arr\\n        int min_salary = Integer.MAX_VALUE;\\n        int max_salary = Integer.MIN_VALUE;\\n\\t\\t// salary array length\\n        int len = salary.length;\\n        // The result should be in double thats why sum as double\\n        double sum = 0;\\n        \\n        for(int i:salary){\\n\\t\\t// We compare current salary with our min and max salary,\\n\\t\\t// and if its replaceable then we will replace\\n            min_salary = Math.min(i,min_num);\\n            max_salary = Math.max(i,max_num);\\n\\t\\t\\t\\n         // We keep adding the salary to get the sum\\n\\t\\t\\tsum+=i;\\n        }\\n        // we subtract the max & min from the sum\\n        sum = sum - min_salary - max_salary;\\n        \\n\\t\\t// find average of salary and return \\n\\t\\t// len -  2 is beacuse we have to remove min and max salary so minus 2 in salary array length\\n        return sum / (len - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707365,
                "title": "easy-javascript-solution-from-o-n-log-n-to-o-n",
                "content": "**O(n*logn) Solution** :\\ni. we sort the array ( TC : O(n * log n)\\nii. we take the average out going through from the second element to the second last element in the array.\\n```\\nvar average = function(salary) {\\n    salary.sort((a,b) => {\\n        return a-b\\n    })\\n    let total = 0\\n\\tlet n = salary.length\\n    \\n    for(let i = 1; i <= n - 2 ; i++){\\n        total = total + salary[i]\\n    }\\n    return total/(n -2) \\n};\\n```\\n**O(n) Solution** :  Since sorting takes n * log n time , we can find min and max from the salarys and then subtract it from total and find the average\\n```\\nvar average = function(salary) {\\n    let n = salary.length\\n    let max = salary[0] \\n    let min = salary[0]\\n    let total = 0\\n    \\n    for(let i = 0; i <= n - 1 ; i++){\\n        total = total + salary[i]\\n        if(max < salary[i]){\\n            max = salary[i]\\n        }else if( min > salary[i]){\\n            min = salary[i]\\n        }\\n    }\\n    return (total - (min + max)) / (n - 2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar average = function(salary) {\\n    salary.sort((a,b) => {\\n        return a-b\\n    })\\n    let total = 0\\n\\tlet n = salary.length\\n    \\n    for(let i = 1; i <= n - 2 ; i++){\\n        total = total + salary[i]\\n    }\\n    return total/(n -2) \\n};\\n```\n```\\nvar average = function(salary) {\\n    let n = salary.length\\n    let max = salary[0] \\n    let min = salary[0]\\n    let total = 0\\n    \\n    for(let i = 0; i <= n - 1 ; i++){\\n        total = total + salary[i]\\n        if(max < salary[i]){\\n            max = salary[i]\\n        }else if( min > salary[i]){\\n            min = salary[i]\\n        }\\n    }\\n    return (total - (min + max)) / (n - 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811008,
                "title": "simple-python-solution",
                "content": "Here is a simple solution for this problem:\\n\\n\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop(-1)\\n        return sum(salary)*1.0/len(salary)\\n```\\n\\nsort() automatically sorts the list, then I use pop() to remove the first (0) and last (-1) values from the list and multiply the solution by 1.0 to convert it to a float.``",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop(-1)\\n        return sum(salary)*1.0/len(salary)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647951,
                "title": "o-n-100-faster-easy-to-understand-using-single-for-loop",
                "content": "![image](https://assets.leetcode.com/users/images/651b73ea-22f2-4109-b7bb-962510dddaa9_1664655972.5307467.png)\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& arr) {\\n        double n = arr.size();\\n        double maxi = INT_MIN;\\n        double mini = INT_MAX;\\n        double allsum = 0;\\n        for(double i = 0;i<n;i++){\\n            if(arr[i]>maxi) maxi = arr[i];\\n            if(arr[i]<mini) mini = arr[i];\\n            allsum += arr[i];\\n        }\\n        double ans;\\n        ans = (allsum-maxi-mini)/(n-2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& arr) {\\n        double n = arr.size();\\n        double maxi = INT_MIN;\\n        double mini = INT_MAX;\\n        double allsum = 0;\\n        for(double i = 0;i<n;i++){\\n            if(arr[i]>maxi) maxi = arr[i];\\n            if(arr[i]<mini) mini = arr[i];\\n            allsum += arr[i];\\n        }\\n        double ans;\\n        ans = (allsum-maxi-mini)/(n-2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096440,
                "title": "beginner-friendly-solutions-few-lines-of-simple-solution",
                "content": "**Approach : 1**\\nTime Complexity : O(n*logn)\\n\\njava\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double avg = 0;\\n        Arrays.sort(salary);\\n        for(int i=1; i<salary.length-1; i++)    avg += salary[i];\\n        return avg/(salary.length-2);\\n    }\\n}\\n```\\njavascript\\n```\\nvar average = function(salary) {\\n    let avg = 0\\n    salary.sort((a,b) => a-b)\\n    for(let i=1; i<salary.length-1; i++)    avg += salary[i]\\n    return avg/(salary.length-2)\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        salary.sort()\\n        for i in range(1, len(salary)-1):\\n            avg += salary[i]\\n        return float(avg)/float(len(salary)-2)\\n```\\n\\n**Approach : 2**\\nTime Complexity : O(n)\\n\\njava\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double min = salary[0], max = 0, total_salary = 0;\\n        for(int i=0; i<salary.length; i++){\\n            min = Math.min(min, salary[i]);\\n            max = Math.max(max, salary[i]);\\n            total_salary += salary[i];\\n        }\\n        return (total_salary - min - max) / (salary.length-2);\\n    }\\n}\\n```\\njavascript\\n```\\nvar average = function(salary) {\\n    let min = salary[0], max = salary[0], total_salary = 0\\n    for(let i=0; i<salary.length; i++){\\n        min = Math.min(min, salary[i])\\n        max = Math.max(max, salary[i]) \\n        total_salary += salary[i]\\n    }\\n    return (total_salary - min - max) / (salary.length-2)\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        for i in range(len(salary)):\\n            avg += salary[i]\\n        return float(avg - min(salary) - max(salary)) / float(len(salary) - 2)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double avg = 0;\\n        Arrays.sort(salary);\\n        for(int i=1; i<salary.length-1; i++)    avg += salary[i];\\n        return avg/(salary.length-2);\\n    }\\n}\\n```\n```\\nvar average = function(salary) {\\n    let avg = 0\\n    salary.sort((a,b) => a-b)\\n    for(let i=1; i<salary.length-1; i++)    avg += salary[i]\\n    return avg/(salary.length-2)\\n};\\n```\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        salary.sort()\\n        for i in range(1, len(salary)-1):\\n            avg += salary[i]\\n        return float(avg)/float(len(salary)-2)\\n```\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double min = salary[0], max = 0, total_salary = 0;\\n        for(int i=0; i<salary.length; i++){\\n            min = Math.min(min, salary[i]);\\n            max = Math.max(max, salary[i]);\\n            total_salary += salary[i];\\n        }\\n        return (total_salary - min - max) / (salary.length-2);\\n    }\\n}\\n```\n```\\nvar average = function(salary) {\\n    let min = salary[0], max = salary[0], total_salary = 0\\n    for(let i=0; i<salary.length; i++){\\n        min = Math.min(min, salary[i])\\n        max = Math.max(max, salary[i]) \\n        total_salary += salary[i]\\n    }\\n    return (total_salary - min - max) / (salary.length-2)\\n};\\n```\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        for i in range(len(salary)):\\n            avg += salary[i]\\n        return float(avg - min(salary) - max(salary)) / float(len(salary) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708204,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    if(salary.length < 3) return 0\\n    let min = salary[0],max = salary[0],sum=0\\n    \\n    for(let ele of salary){\\n        if(ele > max) max = ele\\n        if(ele < min) min = ele\\n        sum += ele\\n    }\\n    return (sum - max - min)/(salary.length-2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    if(salary.length < 3) return 0\\n    let min = salary[0],max = salary[0],sum=0\\n    \\n    for(let ele of salary){\\n        if(ele > max) max = ele\\n        if(ele < min) min = ele\\n        sum += ele\\n    }\\n    return (sum - max - min)/(salary.length-2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257539,
                "title": "unlimited-logical-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n#please upvote me it would encourage me alot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n#please upvote me it would encourage me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829469,
                "title": "java-o-n-time",
                "content": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        Arrays.sort(salary);\\n        double sum = 0;\\n        for (int i = 1; i < salary.length-1; i++) \\n            sum += salary[i];\\n            \\n        return sum/(salary.length-2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        Arrays.sort(salary);\\n        double sum = 0;\\n        for (int i = 1; i < salary.length-1; i++) \\n            sum += salary[i];\\n            \\n        return sum/(salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473233,
                "title": "day-396-one-liner-100-0ms-python-java-c-explained-approach",
                "content": "\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n##### \\u2022\\tIntuition:\\n##### \\u2022 The asks us to compute the average of an array after removing the minimum and maximum elements. The intuition behind the approach is to first find the minimum and maximum elements of the array, and then compute the sum of the remaining elements. Finally, we can divide the sum by the length of the array minus 2 to get the average.\\n##### \\u2022\\tApproach:\\n##### \\u2022\\tInitialize variables to keep track of the minimum and maximum elements of the array, as well as the sum of all elements and the length of the array.\\n##### \\u2022\\tIterate over the array and update the minimum and maximum variables as necessary. Also, add each element to the sum variable.\\n##### \\u2022\\tSubtract the minimum and maximum values from the sum variable to get the sum of the remaining elements.\\n##### \\u2022\\tDivide the sum by the length of the array minus 2 to get the average.\\n##### \\u2022\\tReturn the average.\\n##### \\u2022\\tThe approach is straightforward and efficient, with a time complexity of O(N) and a space complexity of O(1), where N is the length of the input array.\\n\\n\\n```java []\\npublic double average(int[] s) {\\n    int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE,len=s.length;\\n    double sum=0;\\n    for(int k:s){\\n        min=Math.min(min,k);\\n        max=Math.max(max,k);\\n        sum+=k;\\n    }\\n    sum-=(min+max);\\n    return (sum/(len-2));        \\n}\\n```\\n```c++ []\\ndouble average(vector& s) {\\n  int min_val = INT_MAX, max_val = INT_MIN;\\n  double sum = 0;\\n  for (int k : s) {\\n    min_val = min(min_val, k);\\n    max_val = max(max_val, k);\\n    sum += k;\\n  }\\n  sum -= (min_val + max_val);\\n  return sum / (s.size() - 2);\\n}\\n```\\n```python []\\ndef average(self, s: List[int]) -> float:\\n  min_val, max_val = float(\\'inf\\'), float(\\'-inf\\')\\n  sum_val = 0\\n  for k in s:\\n    min_val = min(min_val, k)\\n    max_val = max(max_val, k)\\n    sum_val += k\\n  sum_val -= (min_val + max_val)\\n  return sum_val / (len(s) - 2)\\n```\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# one liner \\n\\n# Code\\n```java []\\npublic double average(int[] s) {\\n    return  Arrays.stream(s).sorted().skip(1).limit(s.length - 2).average().orElse(0);     \\n}\\n```\\n```c++ []\\ndouble average(vector<int>& s) {\\n        return accumulate(s.begin(), s.end(), 0) - *minmax_element(s.begin(), s.end()).first - *minmax_element(s.begin(), s.end()).second) / (double)(s.size() - 2);\\n    }\\n```\\n```python []\\ndef average(self, s: List[int]) -> float:\\n        return (sum(s) - min(s) - max(s)) / (len(s) - 2)\\n```\\n\\n\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```java []\\npublic double average(int[] s) {\\n    int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE,len=s.length;\\n    double sum=0;\\n    for(int k:s){\\n        min=Math.min(min,k);\\n        max=Math.max(max,k);\\n        sum+=k;\\n    }\\n    sum-=(min+max);\\n    return (sum/(len-2));        \\n}\\n```\n```c++ []\\ndouble average(vector& s) {\\n  int min_val = INT_MAX, max_val = INT_MIN;\\n  double sum = 0;\\n  for (int k : s) {\\n    min_val = min(min_val, k);\\n    max_val = max(max_val, k);\\n    sum += k;\\n  }\\n  sum -= (min_val + max_val);\\n  return sum / (s.size() - 2);\\n}\\n```\n```python []\\ndef average(self, s: List[int]) -> float:\\n  min_val, max_val = float(\\'inf\\'), float(\\'-inf\\')\\n  sum_val = 0\\n  for k in s:\\n    min_val = min(min_val, k)\\n    max_val = max(max_val, k)\\n    sum_val += k\\n  sum_val -= (min_val + max_val)\\n  return sum_val / (len(s) - 2)\\n```\n```java []\\npublic double average(int[] s) {\\n    return  Arrays.stream(s).sorted().skip(1).limit(s.length - 2).average().orElse(0);     \\n}\\n```\n```c++ []\\ndouble average(vector<int>& s) {\\n        return accumulate(s.begin(), s.end(), 0) - *minmax_element(s.begin(), s.end()).first - *minmax_element(s.begin(), s.end()).second) / (double)(s.size() - 2);\\n    }\\n```\n```python []\\ndef average(self, s: List[int]) -> float:\\n        return (sum(s) - min(s) - max(s)) / (len(s) - 2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3472373,
                "title": "c-1-liner-efficient-use-of-stl-functions",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        return (double)((1.0* accumulate(salary.begin(), salary.end(), 0) - *max_element(salary.begin(), salary.end()) - *min_element(salary.begin(), salary.end()))/(salary.size()-2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        return (double)((1.0* accumulate(salary.begin(), salary.end(), 0) - *max_element(salary.begin(), salary.end()) - *min_element(salary.begin(), salary.end()))/(salary.size()-2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938419,
                "title": "simple-js-version-96-faster",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let sort = salary.sort(function(a ,b){return a - b})\\n    sort.shift();\\n    sort.pop();\\n    return salary.reduce((a, b) => a + b, 0) / salary.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let sort = salary.sort(function(a ,b){return a - b})\\n    sort.shift();\\n    sort.pop();\\n    return salary.reduce((a, b) => a + b, 0) / salary.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606613,
                "title": "simple-and-easy-to-understand-python",
                "content": "```\\n    def average(self, salary):\\n        salary.sort()\\n        salary[0], salary[-1] = 0, 0\\n        return float((sum(salary)*1.0) / (len(salary) - 2))\\n```\\n**UpVote :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def average(self, salary):\\n        salary.sort()\\n        salary[0], salary[-1] = 0, 0\\n        return float((sum(salary)*1.0) / (len(salary) - 2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1859761,
                "title": "average-salary-easy-c-solution",
                "content": "**Algorithm**\\n**Step 1:**  sort the given vector\\n**Step 2:** initialize sum to \\'0\\' run a loop from second element to second last element of vector as-first element is minimum and lastelement is maxm (after sorting) which has been excluded and do sum+=salary[i]\\n**Step 3:** return (sum/(salary.size()-2)); //since 2 elements are excluded size will also decrease by two\\n\\n**CODE**\\n\\n\\tclass Solution\\n\\t{\\n\\t\\tpublic:\\n\\t\\tdouble average(vector<int> &salary){\\n\\t\\t\\t\\tsort(salary.begin(), salary.end());\\n\\t\\t\\t\\tdouble sum = 0;\\n\\t\\t\\t\\tfor (int i = 1; i < salary.size() - 1; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum += salary[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (double)(sum / (salary.size() - 2));\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tpublic:\\n\\t\\tdouble average(vector<int> &salary){\\n\\t\\t\\t\\tsort(salary.begin(), salary.end());\\n\\t\\t\\t\\tdouble sum = 0;\\n\\t\\t\\t\\tfor (int i = 1; i < salary.size() - 1; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum += salary[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3471814,
                "title": "using-cpp-stl-built-in-functions",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        long long sum=accumulate(salary.begin(),salary.end(),0LL);\\n        int maxm=*max_element(salary.begin(),salary.end());\\n        int minm=*min_element(salary.begin(),salary.end());\\n        \\n        sum-=(maxm+minm);\\n        return (double)sum/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        long long sum=accumulate(salary.begin(),salary.end(),0LL);\\n        int maxm=*max_element(salary.begin(),salary.end());\\n        int minm=*min_element(salary.begin(),salary.end());\\n        \\n        sum-=(maxm+minm);\\n        return (double)sum/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808268,
                "title": "python-easy-solution-and-understandable-without-for-loops",
                "content": "```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        x=min(salary)\\n        y=max(salary)\\n        summ=sum(salary)\\n        n=len(salary)\\n        return (summ-x-y)/(n-2)",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        x=min(salary)\\n        y=max(salary)\\n        summ=sum(salary)\\n        n=len(salary)\\n        return (summ-x-y)/(n-2)",
                "codeTag": "Java"
            },
            {
                "id": 2213970,
                "title": "python3-one-pass-solution-beats-99-20-of-submissions",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minimum = float(\"inf\")\\n        maximum = float(\"-inf\")\\n        \\n        i = 0\\n        sums = 0\\n        while i<len(salary):\\n            minimum = min(minimum, salary[i])\\n            maximum = max(maximum, salary[i])\\n            sums+=salary[i]\\n            i+=1\\n        \\n        return (sums - (maximum+minimum))/(i-2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minimum = float(\"inf\")\\n        maximum = float(\"-inf\")\\n        \\n        i = 0\\n        sums = 0\\n        while i<len(salary):\\n            minimum = min(minimum, salary[i])\\n            maximum = max(maximum, salary[i])\\n            sums+=salary[i]\\n            i+=1\\n        \\n        return (sums - (maximum+minimum))/(i-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099022,
                "title": "javascript-95-speed",
                "content": "```js\\nlet k = salary.length - 1;\\n    \\n    salary = salary.sort((a, b) => (a > b) ? 1 : -1)\\n    salary = salary.slice(1, k);\\n    let total = salary.reduce((a, b) => a + b, 0);\\n    return total / salary.length;",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nlet k = salary.length - 1;\\n    \\n    salary = salary.sort((a, b) => (a > b) ? 1 : -1)\\n    salary = salary.slice(1, k);\\n    let total = salary.reduce((a, b) => a + b, 0);\\n    return total / salary.length;",
                "codeTag": "Unknown"
            },
            {
                "id": 997370,
                "title": "python3-o-nlogn-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)[1:len(salary)-1]\\n        return sum(salary) / len(salary)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary = sorted(salary)[1:len(salary)-1]\\n        return sum(salary) / len(salary)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750090,
                "title": "javascript-simple",
                "content": "```\\nvar average = function(salary) {\\n    salary.sort((a, b) => a - b);\\n    \\n    // Remove first and last salary\\n    salary.shift();\\n    salary.pop();\\n    \\n    // Get average by summing salaries and dividing by number\\n    return salary.reduce((a, b) => a + b) / salary.length;\\n};\\n```\\n\\nStats:\\nRuntime: 72 ms, faster than 64.69% of JavaScript online submissions for Average Salary Excluding the Minimum and Maximum Salary.\\nMemory Usage: 36.4 MB, less than 100.00% of JavaScript online submissions for Average Salary Excluding the Minimum and Maximum Salary.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar average = function(salary) {\\n    salary.sort((a, b) => a - b);\\n    \\n    // Remove first and last salary\\n    salary.shift();\\n    salary.pop();\\n    \\n    // Get average by summing salaries and dividing by number\\n    return salary.reduce((a, b) => a + b) / salary.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708195,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\ndouble average(vector<int>& salary) {\\n        int sum = 0;\\n        int minSal = INT_MAX, maxSal = INT_MIN;\\n        int n = salary.size();\\n        for(int i =0; i < n; ++i)\\n        {\\n            sum += salary[i];\\n            minSal = min(minSal, salary[i]);\\n            maxSal = max(maxSal, salary[i]);\\n        }\\n        sum -= (minSal + maxSal);\\n        return sum/((n-2)*1.0);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble average(vector<int>& salary) {\\n        int sum = 0;\\n        int minSal = INT_MAX, maxSal = INT_MIN;\\n        int n = salary.size();\\n        for(int i =0; i < n; ++i)\\n        {\\n            sum += salary[i];\\n            minSal = min(minSal, salary[i]);\\n            maxSal = max(maxSal, salary[i]);\\n        }\\n        sum -= (minSal + maxSal);\\n        return sum/((n-2)*1.0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3471623,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        return (sum(salary)-salary[0]-salary[-1])/(len(salary)-2)            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        return (sum(salary)-salary[0]-salary[-1])/(len(salary)-2)            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471312,
                "title": "daily-leetcoding-challenge-may-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3150458,
                "title": "js-crazy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    return salary.sort((a, b) => a - b).slice(1,-1).reduce((a,b) => a + b, 0)/(salary.length - 2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    return salary.sort((a, b) => a - b).slice(1,-1).reduce((a,b) => a + b, 0)/(salary.length - 2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778110,
                "title": "java-easy-fast-and-beauty-100",
                "content": "**Hint:** Get the biggest and the smallest value. Subtract them from the sum value. Get the average value dividing new sum on `n-2`. \\n```java\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE, sum = 0;\\n\\n        for (int i = 0; i < salary.length; i++) {\\n            sum += salary[i];\\n            max = Math.max(max, salary[i]);\\n            min = Math.min(min, salary[i]);\\n        }\\n\\n        return (double) (sum - max - min) / (salary.length - 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE, sum = 0;\\n\\n        for (int i = 0; i < salary.length; i++) {\\n            sum += salary[i];\\n            max = Math.max(max, salary[i]);\\n            min = Math.min(min, salary[i]);\\n        }\\n\\n        return (double) (sum - max - min) / (salary.length - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737985,
                "title": "0ms-easy-c-solution",
                "content": "C++ solution with 0ms runtime\\nCode explained in comments along with code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n\\n        // M is the for finding the max number in the salary list\\n        // N is the for finding the min number in the salary list\\n        int M = INT_MIN, N = INT_MAX, sum = 0;\\n        for (int x:salary) {\\n            \\n            // We compare the current number and see if it can replace\\n            // our current max or min\\n            M = M>x ? M:x;\\n            N = N<x ? N:x;\\n\\n            // We keep adding the elements to get the sum\\n            sum+=x;\\n        }\\n\\n        // we subtract the max & min from the sum and get the average\\n        // Don\\'t forget to typecast double as I\\'ve done here..\\n        // The result should be in double as indicated in the \\n        // function when it was defined. Typecasting the numerator \\n        // alone is sufficient to make the whole result double type\\n        return (double)(sum-M-N)/(salary.size()-2);\\n    }\\n};\\n```\\n\\n*If this solution helped you, please upvote it*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n\\n        // M is the for finding the max number in the salary list\\n        // N is the for finding the min number in the salary list\\n        int M = INT_MIN, N = INT_MAX, sum = 0;\\n        for (int x:salary) {\\n            \\n            // We compare the current number and see if it can replace\\n            // our current max or min\\n            M = M>x ? M:x;\\n            N = N<x ? N:x;\\n\\n            // We keep adding the elements to get the sum\\n            sum+=x;\\n        }\\n\\n        // we subtract the max & min from the sum and get the average\\n        // Don\\'t forget to typecast double as I\\'ve done here..\\n        // The result should be in double as indicated in the \\n        // function when it was defined. Typecasting the numerator \\n        // alone is sufficient to make the whole result double type\\n        return (double)(sum-M-N)/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469059,
                "title": "python-easy-solution",
                "content": "```\\ndef average(self, salary: List[int]) -> float:\\n        salary = sorted(salary) # salary = [1000,2000,3000,4000]\\n        salary_list_without_min_max = salary[1:len(salary)-1] # [2000,3000]\\n        avg = round(sum(salary_list_without_min_max)/len(salary_list_without_min_max),5) # 2500.00000\\n        return avg\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef average(self, salary: List[int]) -> float:\\n        salary = sorted(salary) # salary = [1000,2000,3000,4000]\\n        salary_list_without_min_max = salary[1:len(salary)-1] # [2000,3000]\\n        avg = round(sum(salary_list_without_min_max)/len(salary_list_without_min_max),5) # 2500.00000\\n        return avg\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1945684,
                "title": "c-easy-approach",
                "content": "**Easy approach using sorting**\\n\\nTime:- O(nlogn) \\nSpace:- O(logn)\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        int n = salary.size();\\n        double sum = 0;\\n        double res = 0;\\n\\t\\t\\t\\t\\n        for(auto x: salary){\\n            sum += x;\\n        }\\n        sum = sum - (salary[0] + salary[n-1]);\\n       \\n        res = (sum/(n-2));\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        int n = salary.size();\\n        double sum = 0;\\n        double res = 0;\\n\\t\\t\\t\\t\\n        for(auto x: salary){\\n            sum += x;\\n        }\\n        sum = sum - (salary[0] + salary[n-1]);\\n       \\n        res = (sum/(n-2));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847432,
                "title": "python-4-solutions",
                "content": "They are almost the same, just use different syntaxis. The fastest one is the Solution 1.\\n\\n```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        \\n        # Solution 1\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n    \\n        # Solution 2\\n        salary.sort()\\n        salary = salary[1:-1]\\n        return sum(salary)/len(salary)\\n        \\n        # Solution 3\\n        salary = sorted(salary)[1:-1]\\n        return sum(salary)/len(salary)\\n        \\n        # Solution 4\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```\\n\\nApologies for possibly misleading title. It\\'s not `Python 4` solutions, it\\'s four solutions in Python ;)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        \\n        # Solution 1\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n    \\n        # Solution 2\\n        salary.sort()\\n        salary = salary[1:-1]\\n        return sum(salary)/len(salary)\\n        \\n        # Solution 3\\n        salary = sorted(salary)[1:-1]\\n        return sum(salary)/len(salary)\\n        \\n        # Solution 4\\n        return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513166,
                "title": "c-optimized-easy-to-understnad",
                "content": "calculate sum of all array\\nand than subtarct max and min element from array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int x = 1e7, y = 0;\\n        double sum = 0;\\n        for(auto &i: salary){\\n            if(i<x){\\n                x = i;\\n            }\\n            if(i>y){\\n                y = i;\\n            }\\n            sum += i;\\n        }\\n        sum -= x+y;\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int x = 1e7, y = 0;\\n        double sum = 0;\\n        for(auto &i: salary){\\n            if(i<x){\\n                x = i;\\n            }\\n            if(i>y){\\n                y = i;\\n            }\\n            sum += i;\\n        }\\n        sum -= x+y;\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474105,
                "title": "3-line-code-just-use-predefine-function-beats-100-c",
                "content": "# Intuition and Approach\\nAccumulate function help to get the sum of the elements or a specific part of the vector\\nmax_elemet searches for max value in the vector\\nmin_element searches for min value in the vector \\n\\nwe type-casted the answer in double so that it dont throw any error\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        int ma=*max_element(s.begin(),s.end());\\n        int mi=*min_element(s.begin(),s.end());\\n        int sum = accumulate(s.begin(),s.end(),0ll);\\n\\n        return (double)(sum-ma-mi)/(s.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        int ma=*max_element(s.begin(),s.end());\\n        int mi=*min_element(s.begin(),s.end());\\n        int sum = accumulate(s.begin(),s.end(),0ll);\\n\\n        return (double)(sum-ma-mi)/(s.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472901,
                "title": "super-solution-python3-and-golang",
                "content": "# Python3 Solution\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n```\\n# Golang Solution\\n```\\nfunc average(salary []int) float64 {\\n    sort.Ints(salary)\\n    sum:=0\\n    length:=len(salary)\\n    for _,v :=range salary[1:length-1]{\\n        sum+=v\\n    }\\n    return float64(sum)/float64(length-2) \\n}\\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(max(salary))\\n        salary.remove(min(salary))\\n        return sum(salary)/len(salary)\\n```\n```\\nfunc average(salary []int) float64 {\\n    sort.Ints(salary)\\n    sum:=0\\n    length:=len(salary)\\n    for _,v :=range salary[1:length-1]{\\n        sum+=v\\n    }\\n    return float64(sum)/float64(length-2) \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472688,
                "title": "easy-java-solution-beats-100-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max=0,min=1000000;\\n        double sum=0;\\n        for(int i=0;i<salary.length;i++){\\n       sum+=salary[i];\\n       max = salary[i]>max ? salary[i]:max;\\n       min = salary[i]<min ? salary[i]:min;\\n        }\\n        return(sum-(max+min))/(salary.length-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max=0,min=1000000;\\n        double sum=0;\\n        for(int i=0;i<salary.length;i++){\\n       sum+=salary[i];\\n       max = salary[i]>max ? salary[i]:max;\\n       min = salary[i]<min ? salary[i]:min;\\n        }\\n        return(sum-(max+min))/(salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472687,
                "title": "simple-c-solution-daily-leetcode-solution",
                "content": "# \\uD83D\\uDC95Please upVote if u like \\uD83D\\uDC4D\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double sum=0;double avg=0.00000;\\n        for(int i=1;i<salary.size()-1;i++){\\n            sum+=salary[i];\\n        }\\n        avg=sum/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        s.erase(s.begin());\\n        s.erase(s.begin()+(s.size()-1));\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin(), s.end(), 0))/(double)(s.size());\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        double ans =0;\\n        int mn = 1e9 , mx=0;\\n        for(int i =0;i<s.size();i++){\\n            mn = min(mn , s[i]);\\n            mx = max(mx,s[i]);\\n            ans +=s[i];\\n        }\\n        ans = ans - mn - mx;\\n        ans = ans/(s.size()-2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double sum=0;double avg=0.00000;\\n        for(int i=1;i<salary.size()-1;i++){\\n            sum+=salary[i];\\n        }\\n        avg=sum/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        s.erase(s.begin());\\n        s.erase(s.begin()+(s.size()-1));\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin(), s.end(), 0))/(double)(s.size());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        double ans =0;\\n        int mn = 1e9 , mx=0;\\n        for(int i =0;i<s.size();i++){\\n            mn = min(mn , s[i]);\\n            mx = max(mx,s[i]);\\n            ans +=s[i];\\n        }\\n        ans = ans - mn - mx;\\n        ans = ans/(s.size()-2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324410,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sum=0;\\n        for(int i=1;i<salary.length-1;i++)\\n        {\\n            sum=sum+salary[i];\\n        }\\n        double avg=sum/(salary.length-2);\\n        return avg;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sum=0;\\n        for(int i=1;i<salary.length-1;i++)\\n        {\\n            sum=sum+salary[i];\\n        }\\n        double avg=sum/(salary.length-2);\\n        return avg;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178115,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **sorting of the array**, after that it will be easier to find the average without the higher and the lower number through an **iteration of the array**. \\n\\n**Note:** In Java, we have **different ways to sort an array**, usually the best are `Arrays.sort()` and `Collection.sort()`. When we are working with primitive datatypes like int, `Arrays.sort()` proves to be way more time efficient than `Collections.sort()`\\n \\n**Arrays.sort():** make the sort inside the array.\\n**Collections.sort():** is used mainly to sort list, this means that it make more steps to do the same opeartion.\\n\\n# Complexity\\n- **Time complexity:** $O(n*log(n))$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(n)$\\n- **Memory Beats:** 83.94%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        double avg = 0;\\n\\n        Arrays.sort(salary);\\n\\n        // Average without the higher and lower number\\n        for (int i = 1; i < salary.length - 1; i++)\\n            avg += salary[i];\\n\\n        return avg / (salary.length - 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        double avg = 0;\\n\\n        Arrays.sort(salary);\\n\\n        // Average without the higher and lower number\\n        for (int i = 1; i < salary.length - 1; i++)\\n            avg += salary[i];\\n\\n        return avg / (salary.length - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893999,
                "title": "using-built-in-functions-beats-97-13-runtimes",
                "content": "\\n\\n# Code\\n```\\nfunction average(salary: number[]): number {\\n  \\n    let x: number[] = salary.sort((a, b) => a - b).slice(1, -1);\\n    return x.reduce((a, b) => a + b)/x.length;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction average(salary: number[]): number {\\n  \\n    let x: number[] = salary.sort((a, b) => a - b).slice(1, -1);\\n    return x.reduce((a, b) => a + b)/x.length;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640935,
                "title": "kotlin-simple-solution-2-lines",
                "content": "\\n    fun average(salary: IntArray): Double {\\n        salary.sort()\\n        return salary.copyOfRange(1, salary.size - 1).average()\\n    }\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "\\n    fun average(salary: IntArray): Double {\\n        salary.sort()\\n        return salary.copyOfRange(1, salary.size - 1).average()\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2344821,
                "title": "python-short-simple-one-liner",
                "content": "```\\ndef average(self, salary: List[int]) -> float:\\n\\t# Try to divide the following return statement and get the intuition\\n    return (sum(salary)-(max(salary)+min(salary))) / (len(salary)-2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef average(self, salary: List[int]) -> float:\\n\\t# Try to divide the following return statement and get the intuition\\n    return (sum(salary)-(max(salary)+min(salary))) / (len(salary)-2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2323863,
                "title": "go",
                "content": "My Solution on Github: [link](https://github.com/lostlang/LeetcodeGo)\\n```\\nfunc average(salary []int) float64 {\\n\\tvar maxNum, minNum = salary[0], salary[0]\\n\\tvar sumArr int\\n\\n\\tfor _, val := range salary {\\n\\t\\tsumArr += val\\n\\n\\t\\tif val > maxNum {\\n\\t\\t\\tmaxNum = val\\n\\t\\t}\\n\\n\\t\\tif val < minNum {\\n\\t\\t\\tminNum = val\\n\\t\\t}\\n\\t}\\n\\n\\treturn float64(sumArr-minNum-maxNum) / float64(len(salary)-2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc average(salary []int) float64 {\\n\\tvar maxNum, minNum = salary[0], salary[0]\\n\\tvar sumArr int\\n\\n\\tfor _, val := range salary {\\n\\t\\tsumArr += val\\n\\n\\t\\tif val > maxNum {\\n\\t\\t\\tmaxNum = val\\n\\t\\t}\\n\\n\\t\\tif val < minNum {\\n\\t\\t\\tminNum = val\\n\\t\\t}\\n\\t}\\n\\n\\treturn float64(sumArr-minNum-maxNum) / float64(len(salary)-2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319469,
                "title": "simple-python-solution-with-one-pass-with-o-n-99-faster",
                "content": "# For the better Understanding of Problem statement \\nWe have to find average of the array exluding the minimum and maximum value.\\n**Algorithm**\\n1 . Find the sum of total Array\\n2. Find the minium and maximum elements in the array \\n3. Subtract the minimum and maximum value from the total sum (total_sum)\\n4. Find the length of the Array .(length)\\n5. Since we are excluding the maximum and minimum value from the average so subtract 2 from the length of the Array.(length-2)\\n6. Finally Return the answer by float division of total sum and length (total_sum/length)\\n\\n**Code**\\n**1. 49% Faster**\\n![image](https://assets.leetcode.com/users/images/a2f7d5a2-84e0-4b32-9743-6d2a724f5e60_1658527049.6730294.png)\\n\\n\\t\\t\\n**2. 19 ms 99% faster**\\n![image](https://assets.leetcode.com/users/images/50b86805-0fb1-4a88-aeaf-197d25c06ef2_1658526978.8605394.png)\\n\\n\\n**3. One line Linear**\\n![image](https://assets.leetcode.com/users/images/fad0d60d-c8fa-4dd8-a6c2-8372e9dde4f7_1658526902.8262317.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "# For the better Understanding of Problem statement \\nWe have to find average of the array exluding the minimum and maximum value.\\n**Algorithm**\\n1 . Find the sum of total Array\\n2. Find the minium and maximum elements in the array \\n3. Subtract the minimum and maximum value from the total sum (total_sum)\\n4. Find the length of the Array .(length)\\n5. Since we are excluding the maximum and minimum value from the average so subtract 2 from the length of the Array.(length-2)\\n6. Finally Return the answer by float division of total sum and length (total_sum/length)\\n\\n**Code**\\n**1. 49% Faster**\\n![image](https://assets.leetcode.com/users/images/a2f7d5a2-84e0-4b32-9743-6d2a724f5e60_1658527049.6730294.png)\\n\\n\\t\\t\\n**2. 19 ms 99% faster**\\n![image](https://assets.leetcode.com/users/images/50b86805-0fb1-4a88-aeaf-197d25c06ef2_1658526978.8605394.png)\\n\\n\\n**3. One line Linear**\\n![image](https://assets.leetcode.com/users/images/fad0d60d-c8fa-4dd8-a6c2-8372e9dde4f7_1658526902.8262317.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1915187,
                "title": "beginner-friendly-python-solution",
                "content": "Time Complexity : O(n*logn)\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        salary.sort()\\n        for i in range(1, len(salary)-1):\\n            avg += salary[i]\\n        return float(avg)/float(len(salary)-2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def average(self, salary):\\n        avg = 0\\n        salary.sort()\\n        for i in range(1, len(salary)-1):\\n            avg += salary[i]\\n        return float(avg)/float(len(salary)-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892552,
                "title": "java-o-n-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int total = 0;\\n        for(int s: salary) {\\n            min = Math.min(min, s);\\n            max = Math.max(max, s);\\n            total += s;\\n        }\\n        total -= (min + max);\\n        return total * 1.0 / (salary.length - 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int total = 0;\\n        for(int s: salary) {\\n            min = Math.min(min, s);\\n            max = Math.max(max, s);\\n            total += s;\\n        }\\n        total -= (min + max);\\n        return total * 1.0 / (salary.length - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807717,
                "title": "wrong-answer-in-leetcode",
                "content": "The problem  I am facing is that when i run this code for \"Average Salary Excluding the Minimum and Maximum Salary\" i get wrong answer in LeetCode for the input:\\n\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\n\\nand the expected output is: 41111.11111\\nwhile the code outputs: 41111.00000\\n\\nBut when I run the same code with the same input on my VS-Code it gives me the correct answer of 41111.11111.\\nI don\\'t understand what is going on. Any help will be much appreciated.\\n\\nCode:\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        length=int(0)\\n        length = len(salary)-2\\n        salary.sort()\\n        salary = salary[1:-1]\\n        \\n        return sum(salary)/length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        length=int(0)\\n        length = len(salary)-2\\n        salary.sort()\\n        salary = salary[1:-1]\\n        \\n        return sum(salary)/length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807397,
                "title": "scala-1-line-solution",
                "content": "```\\nobject Solution {\\n    def average(salary: Array[Int]): Double = (salary.sum - salary.min - salary.max).toDouble / (salary.length - 2)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def average(salary: Array[Int]): Double = (salary.sum - salary.min - salary.max).toDouble / (salary.length - 2)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 709701,
                "title": "java-stream-solution",
                "content": "```\\npublic static double average(int[] salary) \\n{\\n\\tdouble sum = Arrays.stream(salary).sum();\\n\\tsum -= Arrays.stream(salary).max().getAsInt();\\n\\tsum -= Arrays.stream(salary).min().getAsInt();\\n\\treturn sum / (salary.length-2);\\n}\\n```\\n\\nIf execution time is important and you want to go through the data only once you can use the summaryStatistics() method like this ([Source](https://stackoverflow.com/questions/1484347/finding-the-max-min-value-in-an-array-of-primitives-using-java))\\n\\n\\n```\\nimport java.util.IntSummaryStatistics;\\n\\npublic static double average(int[] salary) \\n{\\n\\tdouble sum = Arrays.stream(salary).sum();\\n\\tIntSummaryStatistics stat = Arrays.stream(salary).summaryStatistics();\\n\\tsum -= (stat.getMax() + stat.getMin());\\n\\treturn sum / (salary.length-2);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static double average(int[] salary) \\n{\\n\\tdouble sum = Arrays.stream(salary).sum();\\n\\tsum -= Arrays.stream(salary).max().getAsInt();\\n\\tsum -= Arrays.stream(salary).min().getAsInt();\\n\\treturn sum / (salary.length-2);\\n}\\n```\n```\\nimport java.util.IntSummaryStatistics;\\n\\npublic static double average(int[] salary) \\n{\\n\\tdouble sum = Arrays.stream(salary).sum();\\n\\tIntSummaryStatistics stat = Arrays.stream(salary).summaryStatistics();\\n\\tsum -= (stat.getMax() + stat.getMin());\\n\\treturn sum / (salary.length-2);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3505285,
                "title": "java-simple-and-clean-approach-with-explanation-beats-100",
                "content": "# Approach\\n1. At first, we sort the array to arrange the elements in proper ascending order.\\n2. Then if the length of the array is 3, simply return the middle element.\\n3. If the step 2 is not true, then simply add all the elements of the array.\\n4. Subtract first and last element from the sum of all arrays.\\n5. Now, divide the sum from step 4 by length of array - 2 (as we subtracted the first and last element we need to do - 2 from the length to find correct average).\\n6. Simply return step 5 to get the desired output.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        int n = salary.length;\\n        if(n==3){\\n            return salary[1];\\n        }\\n        int c = 0;\\n        for(int i=0; i<n; i++){\\n            c+=salary[i];\\n        }\\n        double d = c-salary[0]-salary[n-1];\\n        double e = d/(salary.length-2);\\n        return e;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        int n = salary.length;\\n        if(n==3){\\n            return salary[1];\\n        }\\n        int c = 0;\\n        for(int i=0; i<n; i++){\\n            c+=salary[i];\\n        }\\n        double d = c-salary[0]-salary[n-1];\\n        double e = d/(salary.length-2);\\n        return e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478361,
                "title": "java-solution-for-average-salary-excluding-maximum-and-minimum-salary-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the given solution is to compute the sum of all salaries excluding the minimum and maximum salary, and then divide that sum by the number of employees minus two to obtain the average salary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo achieve this, we initialize three variables: sum, min, and max. We then iterate through the input array of salaries and update these variables as follows:\\n\\nWe add each salary to the sum.\\nWe update the value of min to the minimum of the current value of min and the current salary.\\nWe update the value of max to the maximum of the current value of max and the current salary.\\nAfter iterating through the array, we subtract the minimum and maximum values from the sum to obtain the sum of all salaries excluding the minimum and maximum values. Finally, we calculate the average of the remaining salaries by dividing the sum by the number of employees minus two.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array, as we iterate through the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as we only use a constant amount of additional space to store the sum, min, and max values\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int s : salary) \\n        {\\n            sum += s;\\n            min = Math.min(min, s);\\n            max = Math.max(max, s);\\n        }\\n        sum -= (min + max);\\n        double average = (double) sum / (salary.length - 2);\\n        return average;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for (int s : salary) \\n        {\\n            sum += s;\\n            min = Math.min(min, s);\\n            max = Math.max(max, s);\\n        }\\n        sum -= (min + max);\\n        double average = (double) sum / (salary.length - 2);\\n        return average;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477332,
                "title": "shortest-way-to-solve-this-problem-beats-100",
                "content": "# What dose the question says\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReturn the average salary of employees excluding the minimum and maximum salary. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The salary array is sorted in ascending order using the Arrays.sort() method.\\n\\n2. The length of the salary array is stored in a variable named n.\\n\\n3. A double variable named sum1 is initialized to 0.\\n\\n4. A for loop is used to iterate over the salary array, starting from the second element and ending at the second-to-last element (i.e., indices 1 to n-2).\\n\\n5. Inside the for loop, the current element of the salary array is added to the sum1 variable.\\n\\n6. After the for loop, the sum1 value is divided by n-2 to calculate the average of the salary array, excluding the first and last elements.\\n\\n7. The calculated average value is stored in a double variable named ans.\\n\\n8. The average value is returned as the output.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n    class Solution {\\n        public double average(int[] salary) {\\n    \\n            int n= salary.length;\\n             Arrays.sort(salary);\\n    \\n            double sum1 = 0;      \\n            for(int i=1; i<n-1;i++){\\n                sum1+=salary[i];\\n        \\n             }\\n            double ans = sum1/(n-2);\\n            return ans; \\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    class Solution {\\n        public double average(int[] salary) {\\n    \\n            int n= salary.length;\\n             Arrays.sort(salary);\\n    \\n            double sum1 = 0;      \\n            for(int i=1; i<n-1;i++){\\n                sum1+=salary[i];\\n        \\n             }\\n            double ans = sum1/(n-2);\\n            return ans; \\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474484,
                "title": "python-easy-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        s=0.0\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop()\\n        for i in salary:\\n            s=s+i\\n        var=s/len(salary)\\n        return var\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def average(self, salary):\\n        s=0.0\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop()\\n        for i in salary:\\n            s=s+i\\n        var=s/len(salary)\\n        return var\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472674,
                "title": "simple-c-solution-daily-leetcode-solution",
                "content": "# \\uD83D\\uDC95Please upVote if u like \\uD83D\\uDC4D\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n# First Solution\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin()+1, s.begin()+(s.size()-1), 0))/(double)(s.size()-2);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Second solution\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        double sum = 0; double avg = 0.00000;\\n        for (int i = 1; i < s.size() - 1; i++) {\\n            sum += s[i];\\n        }\\n        avg = sum / (s.size() - 2);\\n        return avg;\\n    }\\n};\\n```\\n\\n# **Third solution**\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        s.erase(s.begin());\\n        s.erase(s.begin()+(s.size()-1));\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin(), s.end(), 0))/(double)(s.size());\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# \\uD83D\\uDC95 Please upVote if u like \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin()+1, s.begin()+(s.size()-1), 0))/(double)(s.size()-2);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(), s.end());\\n        double sum = 0; double avg = 0.00000;\\n        for (int i = 1; i < s.size() - 1; i++) {\\n            sum += s[i];\\n        }\\n        avg = sum / (s.size() - 2);\\n        return avg;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        s.erase(s.begin());\\n        s.erase(s.begin()+(s.size()-1));\\n        double ans=0.00000;\\n        ans=(double)((double)accumulate(s.begin(), s.end(), 0))/(double)(s.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471997,
                "title": "java-100-faster-2-solutions-step-by-step-explained",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n    \\n        // Initialize variables to keep track of the minimum and maximum salaries\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        \\n        // Initialize a variable to keep track of the sum of all salaries\\n        double sum = 0;\\n        \\n        // Iterate over the array of salaries and update the minimum, maximum, and sum variables\\n        for (int s : salary) {\\n            if (s < min) {\\n                min = s;\\n            }\\n            if (s > max) {\\n                max = s;\\n            }\\n            sum += s;\\n        }\\n        \\n        // Calculate the average by subtracting the minimum and maximum salaries from the sum,\\n        // and dividing by the number of salaries that were used in the calculation\\n        return (sum - min - max) / (salary.length - 2.0);\\n    }\\n}\\n```\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/95ee45ee-dce6-418a-bab8-fb259a3fbb52_1682916687.2012382.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        // Sort the array in ascending order\\n        Arrays.sort(salary);\\n\\n        double sum = 0;\\n\\n        // Calculate the sum of all salaries between the minimum and maximum salaries\\n        // We start at index 1 and end at index length - 2, since we\\'re excluding the minimum and maximum salaries\\n        for(int i = 1; i < salary.length - 1; i++){\\n            sum += salary[i];\\n        }\\n\\n        // Calculate the average by dividing the sum by the number of salaries used in the calculation\\n        return sum / (salary.length - 2.0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n    \\n        // Initialize variables to keep track of the minimum and maximum salaries\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        \\n        // Initialize a variable to keep track of the sum of all salaries\\n        double sum = 0;\\n        \\n        // Iterate over the array of salaries and update the minimum, maximum, and sum variables\\n        for (int s : salary) {\\n            if (s < min) {\\n                min = s;\\n            }\\n            if (s > max) {\\n                max = s;\\n            }\\n            sum += s;\\n        }\\n        \\n        // Calculate the average by subtracting the minimum and maximum salaries from the sum,\\n        // and dividing by the number of salaries that were used in the calculation\\n        return (sum - min - max) / (salary.length - 2.0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        // Sort the array in ascending order\\n        Arrays.sort(salary);\\n\\n        double sum = 0;\\n\\n        // Calculate the sum of all salaries between the minimum and maximum salaries\\n        // We start at index 1 and end at index length - 2, since we\\'re excluding the minimum and maximum salaries\\n        for(int i = 1; i < salary.length - 1; i++){\\n            sum += salary[i];\\n        }\\n\\n        // Calculate the average by dividing the sum by the number of salaries used in the calculation\\n        return sum / (salary.length - 2.0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471347,
                "title": "easy-java-solution-using-iteration-beginner-friendly",
                "content": "# Intuition\\nFind max and min salary value, calculate sum. take Average of all sal except max and min.\\n\\n# Approach\\n1. Tranvers all salary, keep updated sum and min & max found so far.\\n2. Take average without max and min\\n3. Make sure to divide by total number of salary - 2 (for excluding min and max)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double max = 0.0;\\n        double min = Double.MAX_VALUE;\\n        double sum = 0;\\n        int div = salary.length -2;\\n        for(int sal : salary) {\\n            sum += sal;\\n            if (sal < min ) {\\n                min = sal;\\n            }\\n            if (sal > max ) {\\n                max = sal;\\n            }\\n        }\\n\\n        return (sum - min - max)/div;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double max = 0.0;\\n        double min = Double.MAX_VALUE;\\n        double sum = 0;\\n        int div = salary.length -2;\\n        for(int sal : salary) {\\n            sum += sal;\\n            if (sal < min ) {\\n                min = sal;\\n            }\\n            if (sal > max ) {\\n                max = sal;\\n            }\\n        }\\n\\n        return (sum - min - max)/div;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359355,
                "title": "c-1-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans;\\n        int n = salary.size()-2;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<salary.size()-1;i++){\\n          ans+=salary[i];\\n }\\n        ans = ans/n;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans;\\n        int n = salary.size()-2;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<salary.size()-1;i++){\\n          ans+=salary[i];\\n }\\n        ans = ans/n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352658,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        Array.Sort(salary);\\n        int count=0;\\n        double sum = 0;\\n        for (int i = 1; i < salary.Length - 1; i++){\\n            sum = sum + salary[i];\\n            count++;\\n        }\\n\\n        return sum /count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        Array.Sort(salary);\\n        int count=0;\\n        double sum = 0;\\n        for (int i = 1; i < salary.Length - 1; i++){\\n            sum = sum + salary[i];\\n            count++;\\n        }\\n\\n        return sum /count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172206,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n        double ans=0;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<n-1;i++){\\n            ans+=salary[i];\\n        }\\n        return ans/(n-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n = salary.size();\\n        double ans=0;\\n        sort(salary.begin(),salary.end());\\n        for(int i=1;i<n-1;i++){\\n            ans+=salary[i];\\n        }\\n        return ans/(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987145,
                "title": "java-simple-runtime-0-ms-beats-100-memory-39-7-mb-beats-91-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        int minSalary = Integer.MAX_VALUE;\\n        int maxSalary = 0;\\n        \\n        double totalSum = 0;\\n        \\n        for(int num : salary) {\\n        \\ttotalSum += num;\\n        \\tif(minSalary > num)\\n        \\t\\tminSalary = num;\\n        \\tif(maxSalary < num)\\n        \\t\\tmaxSalary = num;\\n        }\\n        \\n        totalSum -= (minSalary + maxSalary);\\n        \\n        int totalSalaries = salary.length-2;\\n        \\n        return totalSum/totalSalaries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        int minSalary = Integer.MAX_VALUE;\\n        int maxSalary = 0;\\n        \\n        double totalSum = 0;\\n        \\n        for(int num : salary) {\\n        \\ttotalSum += num;\\n        \\tif(minSalary > num)\\n        \\t\\tminSalary = num;\\n        \\tif(maxSalary < num)\\n        \\t\\tmaxSalary = num;\\n        }\\n        \\n        totalSum -= (minSalary + maxSalary);\\n        \\n        int totalSalaries = salary.length-2;\\n        \\n        return totalSum/totalSalaries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976551,
                "title": "java-easy-and-clean-solution-runtime-0-ms-beats-100-memory-39-7-mb-beats-96-12",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        int minSalary = Integer.MAX_VALUE;\\n        int maxSalary = 0;\\n        \\n        double totalSum = 0;\\n        \\n        for(int num : salary) {\\n        \\ttotalSum += num;\\n        \\tif(minSalary > num)\\n        \\t\\tminSalary = num;\\n        \\tif(maxSalary < num)\\n        \\t\\tmaxSalary = num;\\n        }\\n        \\n        totalSum -= (minSalary + maxSalary);\\n        \\n        int totalSalaries = salary.length-2;\\n        \\n        return totalSum/totalSalaries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        \\n        int minSalary = Integer.MAX_VALUE;\\n        int maxSalary = 0;\\n        \\n        double totalSum = 0;\\n        \\n        for(int num : salary) {\\n        \\ttotalSum += num;\\n        \\tif(minSalary > num)\\n        \\t\\tminSalary = num;\\n        \\tif(maxSalary < num)\\n        \\t\\tmaxSalary = num;\\n        }\\n        \\n        totalSum -= (minSalary + maxSalary);\\n        \\n        int totalSalaries = salary.length-2;\\n        \\n        return totalSum/totalSalaries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939897,
                "title": "c-solution-2-lines",
                "content": "If we have 0, 1, or 2 elements, our average excluding the max and min will be 0. \\nMultiply result by 1.0 to convert to double!\\n# Code\\n```\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        if (salary.Length <= 2) {\\n            return 0; \\n        }\\n        return 1.0*(salary.Sum() - salary.Max() - salary.Min()) / (salary.Count() - 2); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        if (salary.Length <= 2) {\\n            return 0; \\n        }\\n        return 1.0*(salary.Sum() - salary.Max() - salary.Min()) / (salary.Count() - 2); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830273,
                "title": "fastest-easy-c-solution-100-fast",
                "content": "Here is my C++ Solution 100% fast (0ms runtime) :-\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double dem=0; int mini=INT_MAX; int maxi=0;\\n        for (int i=0; i<salary.size(); i++){\\n            dem+= salary[i];\\n            mini= min(mini,salary[i]); maxi= max(maxi,salary[i]);\\n        }\\n        dem-= (maxi+mini);\\n        dem/= (salary.size()-2);\\n        return dem;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double dem=0; int mini=INT_MAX; int maxi=0;\\n        for (int i=0; i<salary.size(); i++){\\n            dem+= salary[i];\\n            mini= min(mini,salary[i]); maxi= max(maxi,salary[i]);\\n        }\\n        dem-= (maxi+mini);\\n        dem/= (salary.size()-2);\\n        return dem;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617939,
                "title": "java-100-o-n",
                "content": "```\\n\\n```class Solution {\\n    public double average(int[] salary) {\\n        int max = salary[0];\\n        int min = salary[0];\\n        double sum = 0;\\n        for (int i = 0; i < salary.length; i++) {\\n            if (max < salary[i]) {\\n                max = salary[i];\\n\\n            }\\n            if (min > salary[i]) {\\n                min = salary[i];\\n\\n            }\\n            sum += salary[i];\\n\\n        }\\n        \\n        sum = (sum - max - min) / (salary.length - 2);\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2514617,
                "title": "c-faster-than-100",
                "content": "class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n\\t\\n        double n=salary.size();\\n        double sum=0;\\n        double mx=0;\\n        double mn=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n            if(mx<salary[i]){\\n                mx=salary[i];\\n            }\\n            if(mn>salary[i]){\\n                mn=salary[i];\\n            }\\n        }\\n        return double((sum-mn-mx)/(double)(n-2.0));\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n\\t\\n        double n=salary.size();\\n        double sum=0;\\n        double mx=0;\\n        double mn=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n            if(mx<salary[i]){\\n                mx=salary[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2509606,
                "title": "python-1-liner-min-max-sum-len",
                "content": "```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary)-min(salary)-max(salary))/(len(salary)-2)\\n```\\n\\nPlease comment below if you have any further questions and **UPVOTE** if you like it!\\nAll the solutions that I\\'ve been through are archived here: https://github.com/hyeseonko/LeetCode",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary)-min(salary)-max(salary))/(len(salary)-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452687,
                "title": "c-3-line-code-faster-than-100",
                "content": "**Do upvote if helpfull**\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double sum = accumulate(salary.begin()+1,salary.end()-1,0);\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double sum = accumulate(salary.begin()+1,salary.end()-1,0);\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928639,
                "title": "one-liner-c-0ms",
                "content": "```\\ndouble average(vector<int>& s) {\\n        return (double)(accumulate(s.begin(),s.end(),0) - *min_element(s.begin(),s.end()) - *max_element(s.begin(),s.end()))/(double)(s.size() - 2);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ndouble average(vector<int>& s) {\\n        return (double)(accumulate(s.begin(),s.end(),0) - *min_element(s.begin(),s.end()) - *max_element(s.begin(),s.end()))/(double)(s.size() - 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1913260,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double avg=0;\\n        for(int i=1;i<salary.size()-1;i++){\\n            avg+=salary[i];       \\n        }\\n        return (double)avg/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double avg=0;\\n        for(int i=1;i<salary.size()-1;i++){\\n            avg+=salary[i];       \\n        }\\n        return (double)avg/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846906,
                "title": "96-less-memory-usage-with-python",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.pop(salary.index(max(salary)))\\n        salary.pop(salary.index(min(salary)))\\n        return sum(salary)/len(salary)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.pop(salary.index(max(salary)))\\n        salary.pop(salary.index(min(salary)))\\n        return sum(salary)/len(salary)",
                "codeTag": "Java"
            },
            {
                "id": 1809354,
                "title": "using-c-stl-only-0ms-100-faster",
                "content": "```\\n double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double ans=accumulate(salary.begin(),salary.end(),0);\\n        return (ans-salary[0]-salary[salary.size()-1])/(salary.size()-2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double ans=accumulate(salary.begin(),salary.end(),0);\\n        return (ans-salary[0]-salary[salary.size()-1])/(salary.size()-2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1804267,
                "title": "python3-fastest-solution-90",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(min(salary))\\n        salary.remove(max(salary))\\n        return sum(salary)/len(salary)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.remove(min(salary))\\n        salary.remove(max(salary))\\n        return sum(salary)/len(salary)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798359,
                "title": "java-easy-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n\\t\\tint min = salary[0];\\n        int max = salary[0];\\n        int sum = salary[0];\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (salary[i] < min) {\\n                min = salary[i];\\n            } else if (salary[i] > max) {\\n                max = salary[i];\\n            }\\n\\t\\t\\t\\n\\t\\t\\tsum += salary[i];\\n        }\\n        \\n        return (double)(sum - min - max) / (n - 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n\\t\\tint min = salary[0];\\n        int max = salary[0];\\n        int sum = salary[0];\\n\\n        for (int i = 1; i < n; ++i) {\\n            if (salary[i] < min) {\\n                min = salary[i];\\n            } else if (salary[i] > max) {\\n                max = salary[i];\\n            }\\n\\t\\t\\t\\n\\t\\t\\tsum += salary[i];\\n        }\\n        \\n        return (double)(sum - min - max) / (n - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581098,
                "title": "c-100-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        vector<int> v;\\n        v = salary;\\n        sort(v.begin(),v.end());\\n        double sum = 0;\\n        double n = salary.size();\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n        }\\n        sum = sum - (v[0]+v[n-1]);\\n        n-=2;\\n        return sum/n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        vector<int> v;\\n        v = salary;\\n        sort(v.begin(),v.end());\\n        double sum = 0;\\n        double n = salary.size();\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n        }\\n        sum = sum - (v[0]+v[n-1]);\\n        n-=2;\\n        return sum/n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438024,
                "title": "java-1-pass-o-n-o-1",
                "content": "```\\nclass Solution {\\n    public double average(int[] nums) {\\n        int sum=0, min=Integer.MAX_VALUE, max=Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            sum+=num;\\n            if (min>num) min=num;\\n            if (max<num) max=num;\\n        }\\n        sum=sum-min-max;\\n        return (double)sum/(nums.length-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] nums) {\\n        int sum=0, min=Integer.MAX_VALUE, max=Integer.MIN_VALUE;\\n        for (int num: nums) {\\n            sum+=num;\\n            if (min>num) min=num;\\n            if (max<num) max=num;\\n        }\\n        sum=sum-min-max;\\n        return (double)sum/(nums.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806061,
                "title": "c-0ms-simple",
                "content": "```\\ndouble average(int* salary, int salarySize){\\n    int min,max,i, sum;\\n    min=max=sum=salary[0];\\n    for(i=1; i<salarySize; i++){\\n        if(salary[i]>max) max = salary[i];\\n        if(salary[i]<min) min = salary[i];\\n        sum += salary[i];\\n    }\\n    return (sum-max-min)/(salarySize-2.0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ndouble average(int* salary, int salarySize){\\n    int min,max,i, sum;\\n    min=max=sum=salary[0];\\n    for(i=1; i<salarySize; i++){\\n        if(salary[i]>max) max = salary[i];\\n        if(salary[i]<min) min = salary[i];\\n        sum += salary[i];\\n    }\\n    return (sum-max-min)/(salarySize-2.0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763612,
                "title": "python-wrong-expected-outcome",
                "content": "I don\\'t know what is going wrong, it passes everything but this one. I have tried multiple coding solutions, including some that have already been submitted on here. Yet I keep getting this output instead of the expected.\\n\\n**Input:\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput:\\n41111.00000\\nExpected:\\n41111.11111**\\n\\n\\n```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        avg = 0\\n        count = 0\\n        salary.sort()\\n        salary = salary[1:-1]\\n        for nums in salary:\\n            avg = nums + avg\\n            count = count + 1\\n        return  avg/count\\n```\\nI also used this solution too and getting the same result.\\n`        return sum(sorted(salary)[1:-1])/(len(salary)-2)`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        avg = 0\\n        count = 0\\n        salary.sort()\\n        salary = salary[1:-1]\\n        for nums in salary:\\n            avg = nums + avg\\n            count = count + 1\\n        return  avg/count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742501,
                "title": "python-use-heaps-to-find-max-and-min",
                "content": "```\\ndef average(self, salary):        \\n        heapq.heapify(salary) # min heap\\n        heapq.heappop(salary) # pop out min\\n        \\n        salary = [-x for x in salary] # max heap\\n        heapq.heapify(salary)\\n        heapq.heappop(salary) # pop out max\\n        \\n        return -sum(salary)/float(len(salary)) \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef average(self, salary):        \\n        heapq.heapify(salary) # min heap\\n        heapq.heappop(salary) # pop out min\\n        \\n        salary = [-x for x in salary] # max heap\\n        heapq.heapify(salary)\\n        heapq.heappop(salary) # pop out max\\n        \\n        return -sum(salary)/float(len(salary)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 708481,
                "title": "q1-o-n-using-stl-q2-o-root-n-q3-o-n-video-solution-with-code-and-explanation",
                "content": "\\t   double average(vector<int>& salary)\\n\\t\\t{\\n\\t\\t\\tauto p1=minmax_element(salary.begin(),salary.end());\\n\\t\\t\\tdouble sum=accumulate(salary.begin(),salary.end(),0);\\n\\t\\t\\treturn (double)(sum-(*p1.first+*p1.second))/(double)(salary.size()-2);\\n\\t\\t}\\n\\t\\t\\n**jump to 23:17 for the solution to first problem**\\n**jump to 15:34 for second problem**\\nlink:-https://youtu.be/BaMzggUjzb4?t=1",
                "solutionTags": [],
                "code": "\\t   double average(vector<int>& salary)\\n\\t\\t{\\n\\t\\t\\tauto p1=minmax_element(salary.begin(),salary.end());\\n\\t\\t\\tdouble sum=accumulate(salary.begin(),salary.end(),0);\\n\\t\\t\\treturn (double)(sum-(*p1.first+*p1.second))/(double)(salary.size()-2);\\n\\t\\t}\\n\\t\\t\\n**jump to 23:17 for the solution to first problem**\\n**jump to 15:34 for second problem**\\nlink:-https://youtu.be/BaMzggUjzb4?t=1",
                "codeTag": "Unknown"
            },
            {
                "id": 708129,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        ## RC ##\\n        return (sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        ## RC ##\\n        return (sum(salary) - min(salary) - max(salary)) / (len(salary) - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708064,
                "title": "a-few-solutions",
                "content": "**Solution #1:** average the accumulated sum of `A` subtracted by the min/max.\\n\\n* O(N) runtime\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var average = { A: IntArray -> (A.sum() - A.min()!! - A.max()!!) / (A.size - 2.0) }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet average = (A, N = A.length) => (_.sum(A) - Math.min(...A) - Math.max(...A)) / (N - 2);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    average = lambda self, A: (sum(A) - min(A) - max(A)) / (len(A) - 2)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn average(mut A: VI) -> f64 {\\n        (A.iter().sum::<i32>()\\n       - A.iter().min().unwrap()\\n       - A.iter().max().unwrap()) as f64 / (A.len() - 2) as f64\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    double average(VI& A) {\\n        return (accumulate(A.begin(), A.end(), 0.0)\\n              - *min_element(A.begin(), A.end())\\n              - *max_element(A.begin(), A.end())) / (A.size() - 2);\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2:** return the average of all values *except* the first and last values of the *sorted* input array `A`\\n\\n* O(NlogN) runtime\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var average = { A: IntArray -> A.sorted().mapIndexed{ i, x -> if (i in 1..A.size - 2) x else 0 }.sum() / (A.size - 2.0) }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet average = (A, N = A.length) => _.sum(A.sort((a, b) => a - b).filter((_, i) => i && i != N - 1 ? A[i] : 0)) / (N - 2);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    average = lambda self, A: sum(sorted(A)[1:-1]) / (len(A) - 2)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn average(mut A: VI) -> f64 { A.sort(); A.iter().enumerate().map(|(i, x)| if 0 < i && i < A.len() - 1 { *x } else { 0 }).sum::<i32>() as f64 / (A.len() - 2) as f64 }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    double average(VI& A) {\\n        sort(A.begin(), A.end());\\n        return accumulate(A.begin() + 1, A.end() - 1, 0.0) / (A.size() - 2);\\n    }\\n};\\n```\\n\\n---\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var average = { A: IntArray -> (A.sum() - A.min()!! - A.max()!!) / (A.size - 2.0) }\\n}\\n```\n```\\nlet average = (A, N = A.length) => (_.sum(A) - Math.min(...A) - Math.max(...A)) / (N - 2);\\n```\n```\\nclass Solution:\\n    average = lambda self, A: (sum(A) - min(A) - max(A)) / (len(A) - 2)\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn average(mut A: VI) -> f64 {\\n        (A.iter().sum::<i32>()\\n       - A.iter().min().unwrap()\\n       - A.iter().max().unwrap()) as f64 / (A.len() - 2) as f64\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    double average(VI& A) {\\n        return (accumulate(A.begin(), A.end(), 0.0)\\n              - *min_element(A.begin(), A.end())\\n              - *max_element(A.begin(), A.end())) / (A.size() - 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    var average = { A: IntArray -> A.sorted().mapIndexed{ i, x -> if (i in 1..A.size - 2) x else 0 }.sum() / (A.size - 2.0) }\\n}\\n```\n```\\nlet average = (A, N = A.length) => _.sum(A.sort((a, b) => a - b).filter((_, i) => i && i != N - 1 ? A[i] : 0)) / (N - 2);\\n```\n```\\nclass Solution:\\n    average = lambda self, A: sum(sorted(A)[1:-1]) / (len(A) - 2)\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn average(mut A: VI) -> f64 { A.sort(); A.iter().enumerate().map(|(i, x)| if 0 < i && i < A.len() - 1 { *x } else { 0 }).sum::<i32>() as f64 / (A.len() - 2) as f64 }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    double average(VI& A) {\\n        sort(A.begin(), A.end());\\n        return accumulate(A.begin() + 1, A.end() - 1, 0.0) / (A.size() - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883425,
                "title": "easy-solution-100-beats-fully-explained",
                "content": "# Approach\\n**Problem Statement:**\\nGiven an array of unique integers representing employee salaries, you need to calculate the average salary of employees while excluding the minimum and maximum salaries. The output should be within a specified tolerance of 10^-5.\\n\\n**Approach:**\\nThe solution takes a straightforward approach to calculate the average salary while excluding the minimum and maximum values.\\n\\n1. Initialize three variables: `total` (to track the sum of all salaries), `min` (to track the minimum salary), and `max` (to track the maximum salary).\\n\\n2. Iterate through the array of salaries:\\n   - Update `max` if the current salary is greater than the current maximum.\\n   - Update `min` if the current salary is smaller than the current minimum.\\n   - Add the current salary to `total`.\\n\\n3. Calculate the average salary:\\n   - Subtract the minimum and maximum salaries from the `total` sum.\\n   - Divide the adjusted total by the number of employees minus 2 (to exclude the two extreme salaries).\\n   - Convert the result to `double` for decimal precision.\\n\\n4. Return the calculated average as the result.\\n\\n**Logic:**\\n- The solution iterates through the array of salaries to find the minimum, maximum, and total sum.\\n- By excluding the minimum and maximum salaries from the total sum, you get the sum of the middle salaries.\\n- Dividing this sum by the number of employees minus 2 gives you the average salary after excluding the extremes.\\n- The result is converted to a `double` to allow for decimal precision in calculations.\\n\\nThe solution follows a simple, step-by-step process to calculate the average salary while excluding the specified salaries. It effectively utilizes basic arithmetic operations to handle the problem\\'s requirements.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int total = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for (int s : salary) {\\n            if (s > max) max = s;\\n            if (s < min) min = s;\\n            total += s;\\n        }\\n\\n        double res = (double) (total - min - max) / (salary.length - 2);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int total = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n\\n        for (int s : salary) {\\n            if (s > max) max = s;\\n            if (s < min) min = s;\\n            total += s;\\n        }\\n\\n        double res = (double) (total - min - max) / (salary.length - 2);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536143,
                "title": "1491-average-salary-excluding-the-minimum-and-maximum-salary",
                "content": "class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        int n = salary.size();\\n        double sum = 0;\\n        double res = 0;\\n\\t\\t\\t\\t\\n        for(auto x: salary){\\n            sum += x;\\n        }\\n        sum = sum - (salary[0] + salary[n-1]);\\n       \\n        res = (sum/(n-2));\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(), salary.end());\\n        int n = salary.size();\\n        double sum = 0;\\n        double res = 0;\\n\\t\\t\\t\\t\\n        for(auto x: salary){\\n            sum += x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3478295,
                "title": "easy-to-understand-c-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double sum = 0;\\n        double mx = *max_element(salary.begin(), salary.end());\\n        double mn = *min_element(salary.begin(), salary.end());\\n        for(auto it : salary) {\\n            if(it != mx and it != mn) sum += it;\\n        }\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double sum = 0;\\n        double mx = *max_element(salary.begin(), salary.end());\\n        double mn = *min_element(salary.begin(), salary.end());\\n        for(auto it : salary) {\\n            if(it != mx and it != mn) sum += it;\\n        }\\n        return sum/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475125,
                "title": "1may2023-daily-problem-average-salary-excluding-the-minimum-and-maximum-salary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas in example we see we have to return average of the salaries in which we are not including minimum salary and maximum salary.\\nfirst thought came in my mind that we can do this by finding min and max element from  the salsary llist as it is mentsioned that it is given in list form \\nthen apply for loop and comapre if element is not min or max; they get added and a count will apply so that we can track how much time it is iterarted and then divide that count to total sum\\nthat is nothing but simple finding avg formula\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n. i use two inbuilt functions for  finding minum element and maximum element \\n. min() and max()\\n. store these values in two sepate variablels,[although we can compare directly i found thiss way much easier to understable or you can it was just a habitual action]\\n. then a for loop\\n. within the loop an if condition by which we\\'ll count total sum excluding min term and max term of list\\n. and count the number of iterations\\n. then apply formula\\n. and reuturn\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ni guess it is Order od n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ni do use constant space\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        min_salary = min(salary);max_salary = max(salary);count = 0\\n        sum_sal = 0\\n        for i in salary:\\n            if i != min_salary and i != max_salary:\\n                count +=1\\n                sum_sal += i\\n        avg_sal = sum_sal/count\\n        return  avg_sal\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        min_salary = min(salary);max_salary = max(salary);count = 0\\n        sum_sal = 0\\n        for i in salary:\\n            if i != min_salary and i != max_salary:\\n                count +=1\\n                sum_sal += i\\n        avg_sal = sum_sal/count\\n        return  avg_sal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474613,
                "title": "c-python-single-loop-with-100-time-no-sorting",
                "content": "# Intuition\\n\\nBasic problem where you have to **substract** the **max** and the **min** from the **total** and then find the **average** of the **rem**aining **arr**ay **ele**ments.\\n\\nThe main part lies in the approach and how to avoid time and space complexities.\\n\\n  \\n\\n# Approach\\n\\n1. I have demonstrated the code both in **Python** and **C** for **ref**erence.\\n\\n2. As expected, the **co**de in **C is faster** than the **co**de in **Py**thon. \\n\\n3. In $C$, you can **def**ine the **typ**e of the **var**iables **sta**tically and this allows more control over space memory.\\n\\n4. I have used **\\'int\\' variables** for storing the total, max, and min. This is because the **ele**ments are all **int**egers and we **do not** **req**uire float/double for **sto**rage.\\n\\n5. However, since the **ret**urned **val**ue contains decimal places, we will have to **type cast it to double**.\\n\\n6. The approach in $Python$ is straight forward. We find the sum, max, min, and len using inbuilt functions.\\n  \\n\\n# Complexity\\n\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n  \\n\\n# Code\\n\\n```C []\\ndouble average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }\\n    return (double)(total - max - min)/(salarySize - 2);\\n```\\n```Python []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) -min(salary))/(len(salary) - 2)\\n\\n\\n```\\n![Execution Runtime screenshot for code in C](https://assets.leetcode.com/users/images/a242c698-ef06-4519-b758-63714763cf01_1682961908.996705.png)\\n\\n### Please consider upvoting if you liked it or comment if you have an alternative approach! Thank you!\\n",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array"
                ],
                "code": "```C []\\ndouble average(int* salary, int salarySize){\\n\\n    int total = 0;\\n    int max = salary[0];\\n    int min = salary[0];\\n\\n    for(int i = 0; i < salarySize; i++){\\n        total += salary[i];\\n        if(max < salary[i])\\n            max = salary[i];\\n        else if(min > salary[i])\\n            min = salary[i];\\n    }\\n    return (double)(total - max - min)/(salarySize - 2);\\n```\n```Python []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary) - max(salary) -min(salary))/(len(salary) - 2)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474251,
                "title": "optimal-solution-beats-100-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this code is quite simple and straightforward. The method iterates through the array to find the minimum and maximum values and compute the sum of all elements in the array. Then, it subtracts the minimum and maximum values from the total sum and computes the average of the remaining elements.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] arr) {\\n        double res=0;\\n        int min=Integer.MAX_VALUE;\\n        int max=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>max) max=arr[i];\\n            if(arr[i]<min) min=arr[i];\\n            res+=arr[i];\\n        }\\n        res=res-max-min;\\n        int len=arr.length-2;\\n        return res/len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] arr) {\\n        double res=0;\\n        int min=Integer.MAX_VALUE;\\n        int max=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]>max) max=arr[i];\\n            if(arr[i]<min) min=arr[i];\\n            res+=arr[i];\\n        }\\n        res=res-max-min;\\n        int len=arr.length-2;\\n        return res/len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474059,
                "title": "shortest-code-easy-to-understand-c-100-faster-code-beginner-friendly",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\\n        for(int i:salary){\\n            Max = Max < i ? i : Max ;\\n            Min = Min > i ? i : Min ;\\n            sum += i;\\n        }\\n        sum -= (Min + Max);\\n        return sum/(n-2.0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\\n        for(int i:salary){\\n            Max = Max < i ? i : Max ;\\n            Min = Min > i ? i : Min ;\\n            sum += i;\\n        }\\n        sum -= (Min + Max);\\n        return sum/(n-2.0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474050,
                "title": "beats-100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhy It does beat everybody\\'s code because it does not use built-in functions except salary.size() that\\'s why.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int minVal, maxVal, numOfVal = 0;\\n        double totalSum = 0;\\n        minVal = maxVal = salary[0];\\n        \\n        for (int i = 0; i < salary.size(); i++) {\\n            if (minVal > salary[i])\\n                minVal = salary[i];\\n            if (maxVal < salary[i])\\n                maxVal = salary[i];\\n            totalSum += salary[i];\\n            numOfVal++;\\n        }\\n        return (totalSum - (maxVal + minVal)) / (numOfVal - 2);\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/05e4c156-7df6-4470-8d7e-c71fee27f73e_1682952264.4889948.png)\\n\\n# Python\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minVal = maxVal = salary[0]\\n        totalSum = 0\\n        numOfVal = 0\\n        for i in salary:\\n            if i < minVal:\\n                minVal = i\\n            if i > maxVal:\\n                maxVal = i\\n            totalSum += i\\n            numOfVal += 1\\n        totalSum -= (maxVal + minVal)\\n        numOfVal -= 2\\n\\n        return totalSum / numOfVal  \\n```\\n# Please Upvote if you can, thank you\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int minVal, maxVal, numOfVal = 0;\\n        double totalSum = 0;\\n        minVal = maxVal = salary[0];\\n        \\n        for (int i = 0; i < salary.size(); i++) {\\n            if (minVal > salary[i])\\n                minVal = salary[i];\\n            if (maxVal < salary[i])\\n                maxVal = salary[i];\\n            totalSum += salary[i];\\n            numOfVal++;\\n        }\\n        return (totalSum - (maxVal + minVal)) / (numOfVal - 2);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        minVal = maxVal = salary[0]\\n        totalSum = 0\\n        numOfVal = 0\\n        for i in salary:\\n            if i < minVal:\\n                minVal = i\\n            if i > maxVal:\\n                maxVal = i\\n            totalSum += i\\n            numOfVal += 1\\n        totalSum -= (maxVal + minVal)\\n        numOfVal -= 2\\n\\n        return totalSum / numOfVal  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473617,
                "title": "easy-kotlin-easy-for-understanding",
                "content": "# Intuition\\n*Not hard task at all.*\\n\\n# Approach\\nAccording to statement we need to **exclude** min/max of array `salary`, so we need to sort `salary` and count our result from `1` to `salary.size - 1` :)\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog(n) + (n - 2))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun average(salary: IntArray): Double {\\n        Arrays.sort(salary)\\n        var res = 0\\n        for (i in 1 until salary.size-1) {\\n            res+=salary[i]\\n        }\\n        return res.toDouble() / (salary.size - 2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun average(salary: IntArray): Double {\\n        Arrays.sort(salary)\\n        var res = 0\\n        for (i in 1 until salary.size-1) {\\n            res+=salary[i]\\n        }\\n        return res.toDouble() / (salary.size - 2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473230,
                "title": "easy-solution-on-java",
                "content": "Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        int sum=0;\\n        for(int salaries:salary)\\n        {\\n          sum+=salaries;\\n        }\\n        return (double)(sum-salary[0]-salary[salary.length-1])/(double)(salary.length-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        int sum=0;\\n        for(int salaries:salary)\\n        {\\n          sum+=salaries;\\n        }\\n        return (double)(sum-salary[0]-salary[salary.length-1])/(double)(salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473164,
                "title": "beats-100-most-optimized-explained-solution-short-and-clean-code",
                "content": "\\n\\n# Approach\\nThe solution first initializes the min and max variables to the maximum and minimum possible integer values, respectively. Then it iterates through the salary array, updating the min and max variables as necessary, and adding each salary to the sum variable.\\n\\nFinally, the solution computes the average salary by subtracting the minimum and maximum salaries from the sum, dividing by the number of employees minus two (since we\\'re excluding the minimum and maximum salaries), and casting the result to a double.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        for (int s : salary) {\\n            if (s < min) {\\n                min = s;\\n            }\\n            if (s > max) {\\n                max = s;\\n            }\\n            sum += s;\\n        }\\n        return (double) (sum - min - max) / (salary.length - 2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int sum = 0;\\n        for (int s : salary) {\\n            if (s < min) {\\n                min = s;\\n            }\\n            if (s > max) {\\n                max = s;\\n            }\\n            sum += s;\\n        }\\n        return (double) (sum - min - max) / (salary.length - 2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472983,
                "title": "average-salary-solution-in-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        auto x = minmax_element(begin(salary), end(salary));\\n        double sum = std::accumulate(begin(salary), end(salary), 0, [](auto &a, auto &b) {\\n            return a + b;\\n        });\\n        return (sum - *x.first - *x.second) / (salary.size() - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        auto x = minmax_element(begin(salary), end(salary));\\n        double sum = std::accumulate(begin(salary), end(salary), 0, [](auto &a, auto &b) {\\n            return a + b;\\n        });\\n        return (sum - *x.first - *x.second) / (salary.size() - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472829,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDiscover the Maximum and Minimum salaries as well as the total of all salaries, then subtract the Maximum and Minimum salaries from the total.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Find the array\\'s length before traversing it.If the array\\'s length is 0, then return 0\\n\\nStep 2: Consider a variable In order to find the maximum and minimum salaries in the provided salary array, first assign the variables Max and Min to the salary at array index 0 and then take the sum variable and assign that to 0 before iteratively adding each salary to the sum variable.\\n\\nStep 3: After traversing array we have the maximum and minimum salaries from the provided salary array.subtract the Max and Min Salary from the Sum and dividing the sum\\xA0by 2 than return sum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n        if(n == 0) return 0;\\n        int min = salary[0];\\n        int max = salary[0];\\n        double sum = 0L;\\n        for(int i : salary){\\n            min = Math.min(i,min);\\n            max = Math.max(i,max);\\n            sum+=i;\\n        }\\n        sum-=min;\\n        sum-=max;\\n        return sum/(n-2);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n        if(n == 0) return 0;\\n        int min = salary[0];\\n        int max = salary[0];\\n        double sum = 0L;\\n        for(int i : salary){\\n            min = Math.min(i,min);\\n            max = Math.max(i,max);\\n            sum+=i;\\n        }\\n        sum-=min;\\n        sum-=max;\\n        return sum/(n-2);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472701,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max=0,min=1000000;\\n        double sum=0;\\n        for(int i=0;i<salary.length;i++){\\n       sum+=salary[i];\\n        if(salary[i]>max)\\n        max=salary[i];\\n        if(salary[i]<min)\\n        min=salary[i];\\n        }\\n        return(sum-(max+min))/(salary.length-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int max=0,min=1000000;\\n        double sum=0;\\n        for(int i=0;i<salary.length;i++){\\n       sum+=salary[i];\\n        if(salary[i]>max)\\n        max=salary[i];\\n        if(salary[i]<min)\\n        min=salary[i];\\n        }\\n        return(sum-(max+min))/(salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472591,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func average(_ salary: [Int]) -> Double {\\n        var (l, r, sum) = (Int.max, Int.min, 0)\\n        \\n        for s in salary{\\n            sum += s\\n            l = min(l, s)\\n            r = max(r, s)\\n        }\\n\\n        return Double(sum-l-r)/Double(salary.count-2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func average(_ salary: [Int]) -> Double {\\n        var (l, r, sum) = (Int.max, Int.min, 0)\\n        \\n        for s in salary{\\n            sum += s\\n            l = min(l, s)\\n            r = max(r, s)\\n        }\\n\\n        return Double(sum-l-r)/Double(salary.count-2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472410,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        new = sorted(salary)\\n        new.pop(0)\\n        new.pop()\\n        return sum(new)/len(new)\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        new = sorted(salary)\\n        new.pop(0)\\n        new.pop()\\n        return sum(new)/len(new)\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3472071,
                "title": "c-best-4-line-solution-100-faster-0-n-easy-to-understand-comments",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n***calculate the total sum of al element. then subtract minimum and maximum element and return the average***\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        // accumulate the total sum of all elements of the salary vector\\n        double sum = accumulate(salary.begin(), salary.end(), 0);\\n        // finding the minimum element\\n        int mini = *min_element(salary.begin(), salary.end());\\n        // finding the maximum element\\n        int maxi = *max_element(salary.begin(), salary.end());\\n        // subtract the minimum and maximum element from the sum and return the average of remaining element\\n        return (sum - mini - maxi) / (salary.size() - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        // accumulate the total sum of all elements of the salary vector\\n        double sum = accumulate(salary.begin(), salary.end(), 0);\\n        // finding the minimum element\\n        int mini = *min_element(salary.begin(), salary.end());\\n        // finding the maximum element\\n        int maxi = *max_element(salary.begin(), salary.end());\\n        // subtract the minimum and maximum element from the sum and return the average of remaining element\\n        return (sum - mini - maxi) / (salary.size() - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471970,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary)\\n    {\\n        double sum=0;\\n        int min=*min_element(salary.begin(),salary.end());\\n        int max=*max_element(salary.begin(),salary.end());     \\n        int n=salary.size();\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n        }   \\n        sum-=min;\\n        sum-=max;\\n        return sum/(n-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary)\\n    {\\n        double sum=0;\\n        int min=*min_element(salary.begin(),salary.end());\\n        int max=*max_element(salary.begin(),salary.end());     \\n        int n=salary.size();\\n        for(int i=0;i<n;i++){\\n            sum+=salary[i];\\n        }   \\n        sum-=min;\\n        sum-=max;\\n        return sum/(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471910,
                "title": "easiest-c-soln-beats-100-beginner-friendly",
                "content": "#####  Please upvote if it helps.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        double sum = 0;\\n        for(int i = 0; i < salary.size(); i++)\\n        {\\n            sum += salary[i];\\n            mini = min(mini,salary[i]);\\n            maxi = max(maxi,salary[i]);\\n        }\\n        sum = sum-mini-maxi;\\n        sum = sum/(salary.size()-2);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        double sum = 0;\\n        for(int i = 0; i < salary.size(); i++)\\n        {\\n            sum += salary[i];\\n            mini = min(mini,salary[i]);\\n            maxi = max(maxi,salary[i]);\\n        }\\n        sum = sum-mini-maxi;\\n        sum = sum/(salary.size()-2);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471900,
                "title": "simple-for-loop-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust find the avrage \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind minimun and maximum and sum then excluding max and min ;\\nthen find the avrage \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let val=0;\\n    let max= -Infinity;\\n    let min= Infinity;\\n    for(let el of salary){\\n        val+=el;\\n    max<el?max=el:max=max;\\n    min>el?min=el:min=min\\n    }\\n\\n let ans= val-(max+min);\\n ans= ans/(salary.length-2);\\n return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let val=0;\\n    let max= -Infinity;\\n    let min= Infinity;\\n    for(let el of salary){\\n        val+=el;\\n    max<el?max=el:max=max;\\n    min>el?min=el:min=min\\n    }\\n\\n let ans= val-(max+min);\\n ans= ans/(salary.length-2);\\n return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3471857,
                "title": "python-easy-solution-with-3-lines-of-code",
                "content": "\\n\\n# Code:\\n```python []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        # sort the array\\n        salary = sorted(salary)\\n        # remove min and max salary\\n        salary.pop(0)\\n        salary.pop()\\n\\n        return sum(salary)/len(salary)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        # sort the array\\n        salary = sorted(salary)\\n        # remove min and max salary\\n        salary.pop(0)\\n        salary.pop()\\n\\n        return sum(salary)/len(salary)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471844,
                "title": "easy",
                "content": "# Intuition\\nfind min and max\\n\\n# Approach\\nremove min and max then find avg\\n# Complexity\\n- Time complexity:\\no(n)2\\n\\n- Space complexity:\\n# **o(n)**\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n        double ans = 0;\\n        double c  = 0;\\n       for(int val : salary){\\n            min = Math.min(min,val);\\n            max = Math.max(max,val);\\n       } \\n  for(int vall : salary){\\n      if(vall==min || vall == max){\\n          continue;\\n      }else{\\n          System.out.println(vall);\\n          ans += vall;\\n          c++;\\n      }\\n  }\\n  return ans/c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int min = Integer.MAX_VALUE;\\n        int max = 0;\\n        double ans = 0;\\n        double c  = 0;\\n       for(int val : salary){\\n            min = Math.min(min,val);\\n            max = Math.max(max,val);\\n       } \\n  for(int vall : salary){\\n      if(vall==min || vall == max){\\n          continue;\\n      }else{\\n          System.out.println(vall);\\n          ans += vall;\\n          c++;\\n      }\\n  }\\n  return ans/c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471724,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        int n=(int)salary.size();\\n        double ans=accumulate(salary.begin(),salary.end(),0.00);\\n        ans-=(salary.back()+salary.front());\\n        return ans/(n-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        int n=(int)salary.size();\\n        double ans=accumulate(salary.begin(),salary.end(),0.00);\\n        ans-=(salary.back()+salary.front());\\n        return ans/(n-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471683,
                "title": "python3-one-liner-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return sum(sorted(salary)[1:-1])/(len(salary)-2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return sum(sorted(salary)[1:-1])/(len(salary)-2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471511,
                "title": "easy-solution-cpp-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble average(vector<int>& salary) \\n\\t\\t{\\n\\t\\t\\tint mi = INT_MAX;\\n\\t\\t\\tint ma = INT_MIN;\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < salary.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += salary[i];\\n\\t\\t\\t\\tmi = min(mi, salary[i]);\\n\\t\\t\\t\\tma = max(salary[i], ma);\\n\\t\\t\\t}\\n\\n\\t\\t\\tsum = sum - mi - ma;\\n\\n\\t\\t\\tdouble n = salary.size()-2.0;\\n\\n\\t\\t\\treturn (sum/n);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble average(vector<int>& salary) \\n\\t\\t{\\n\\t\\t\\tint mi = INT_MAX;\\n\\t\\t\\tint ma = INT_MIN;\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < salary.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum += salary[i];\\n\\t\\t\\t\\tmi = min(mi, salary[i]);\\n\\t\\t\\t\\tma = max(salary[i], ma);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3471437,
                "title": "c-code-faster-than-100-easy-to-understand",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n------------------------------------------------\\nPLEASE UPVOTE IF YOU LIKE IT....................\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        int n =salary.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 || i==n-1) continue;\\n            sum +=salary[i];\\n        }\\n\\n        double ans=(double)sum/(n-2);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        int n =salary.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==0 || i==n-1) continue;\\n            sum +=salary[i];\\n        }\\n\\n        double ans=(double)sum/(n-2);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471394,
                "title": "best-c-solution-o-nlogn-optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n---> O(nlogn)\\n\\n- Space complexity:\\n---> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) \\n    {\\n         int N = salary.size();\\n        sort(salary.begin(),salary.end());\\n        double t = salary[1];\\n        for (int i = 2; i < N - 1; i++) \\n        {\\n            t += salary[i];\\n        }\\n        return t / (N - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) \\n    {\\n         int N = salary.size();\\n        sort(salary.begin(),salary.end());\\n        double t = salary[1];\\n        for (int i = 2; i < N - 1; i++) \\n        {\\n            t += salary[i];\\n        }\\n        return t / (N - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471384,
                "title": "one-pass-c",
                "content": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double s = 0, mn = 1e9, mx = 0, n = salary.size();\\n        for(int i : salary) {\\n            s += i;\\n            mn = min(mn, (double)i);\\n            mx = max(mx, (double)i);\\n        }\\n        return (s - mx - mn) / (n - 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double s = 0, mn = 1e9, mx = 0, n = salary.size();\\n        for(int i : salary) {\\n            s += i;\\n            mn = min(mn, (double)i);\\n            mx = max(mx, (double)i);\\n        }\\n        return (s - mx - mn) / (n - 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458879,
                "title": "average-salary-excluding-minimum-and-maximum-java-solution-using-sorting",
                "content": "# Intuition\\nWe need to find the average salary of employees in a company, but exclude the minimum and maximum salaries from the calculation. One possible approach is to sort the array of salaries, exclude the minimum and maximum salaries, and then calculate the average of the remaining salaries.\\n\\n# Approach\\nThe solution uses the following approach:\\n1. Sort the given array of salaries in ascending order using the `Arrays.sort()` function.\\n2. Loop through the sorted array using a for-loop from the second index to the second-last index, since we need to exclude the minimum and maximum salaries from the calculation.\\n3. Within the for-loop, add each salary to a variable `res`, which is used to store the sum of all salaries that should be included in the calculation of the average.\\n4. After the for-loop, divide `res` by `(salary.length - 2)` to get the average salary, since we have excluded the minimum and maximum salaries from the calculation.\\n5. Return the calculated average salary as the result.\\n\\n# Complexity\\n- Time complexity: \\nThe time complexity of this solution is O(nlogn) due to the use of the `Arrays.sort()` function, which has a worst-case time complexity of O(nlogn). The for-loop that calculates the sum of salaries has a time complexity of O(n), and the division operation has a constant time complexity of O(1).\\n- Space complexity: \\nThe space complexity of this solution is O(1), as we are only using a constant amount of extra space to store the `res` variable.\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double res = 0;\\n        Arrays.sort(salary);\\n        for(int i = 1; i < salary.length -1; i ++){\\n            res += salary[i];\\n        }\\n        res = res / (salary.length-2);\\n        return res;\\n    }\\n}\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double res = 0;\\n        Arrays.sort(salary);\\n        for(int i = 1; i < salary.length -1; i ++){\\n            res += salary[i];\\n        }\\n        res = res / (salary.length-2);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324409,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\n    public double average(int[] salary) {\\n        double sum=0;\\n        Arrays.sort(salary);\\n        for(int i=1;i<salary.length-1;i++){\\n          sum=sum+salary[i];\\n        }\\n        double ans=sum/(salary.length-2);\\nreturn ans;    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public double average(int[] salary) {\\n        double sum=0;\\n        Arrays.sort(salary);\\n        for(int i=1;i<salary.length-1;i++){\\n          sum=sum+salary[i];\\n        }\\n        double ans=sum/(salary.length-2);\\nreturn ans;    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267839,
                "title": "0ms-simple-easy-java-solution-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double minimum = Double.MAX_VALUE,maximum = Double.MIN_VALUE,total_salary = 0,count = 0;\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] > maximum) maximum = salary[i];\\n            if(salary[i] < minimum) minimum = salary[i];\\n            total_salary += salary[i];\\n            count++;\\n        }\\n        return (total_salary - (minimum + maximum))/(count-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double minimum = Double.MAX_VALUE,maximum = Double.MIN_VALUE,total_salary = 0,count = 0;\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] > maximum) maximum = salary[i];\\n            if(salary[i] < minimum) minimum = salary[i];\\n            total_salary += salary[i];\\n            count++;\\n        }\\n        return (total_salary - (minimum + maximum))/(count-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248684,
                "title": "beginner-friendly-beats-100-easy-to-understand-c-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nFirst, calculate the sum of all the numbers in the loop. Additionally, within the same loop, identify the minimum and maximum salary. Next, subtract the sum of the minimum and maximum values from the total sum. This will give you the sum of the remaining values. To calculate the average, divide this sum by the total number of values minus two.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double avg = 0;\\n        int max = 0, min = INT_MAX;\\n        for(int i = 0; i<salary.size(); i++){\\n            if(salary[i]>=max){\\n                max = salary[i];\\n            }\\n            if(salary[i]<=min){\\n                min = salary[i];\\n            }\\n            avg = avg+salary[i];\\n        }\\n        avg = avg-(max+min);\\n        avg = avg/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double avg = 0;\\n        int max = 0, min = INT_MAX;\\n        for(int i = 0; i<salary.size(); i++){\\n            if(salary[i]>=max){\\n                max = salary[i];\\n            }\\n            if(salary[i]<=min){\\n                min = salary[i];\\n            }\\n            avg = avg+salary[i];\\n        }\\n        avg = avg-(max+min);\\n        avg = avg/(salary.size()-2);\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207129,
                "title": "beginner-friendly-c-100-beats-0ms-runtime",
                "content": "# Intuition\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/8fc01df2-5d63-4704-a6c3-18d973a48a7d_1678369642.84661.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n    int size = salary. size () ;\\n    double ans = 0 ;\\n    sort ( salary . begin () , salary . end () ) ;\\n    salary . erase ( salary .begin () ) ;\\n    salary . pop_back () ;\\n    for ( int i = 0 ; i < size - 2 ; i ++ ){\\n            ans = ans + salary [ i ] ;\\n    }\\n        return ans / (size-2) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n    int size = salary. size () ;\\n    double ans = 0 ;\\n    sort ( salary . begin () , salary . end () ) ;\\n    salary . erase ( salary .begin () ) ;\\n    salary . pop_back () ;\\n    for ( int i = 0 ; i < size - 2 ; i ++ ){\\n            ans = ans + salary [ i ] ;\\n    }\\n        return ans / (size-2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207106,
                "title": "easy-and-simple-with-c-100-beats-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n       int size = salary.size();\\n       int divisor = size - 2;\\n        double minimumSalary = INT_MAX;\\n        double maximumSalary = 0;\\n        for(int i = 0;i<size;i++){\\n           if(salary[i] > maximumSalary){\\n                maximumSalary = salary[i];\\n            }\\n             if(salary[i] < minimumSalary){\\n                minimumSalary = salary[i];\\n            }\\n        }\\n        double gradeToral = maximumSalary + minimumSalary;\\n        double avgSalary = 0;\\n        \\n        for(int i = 0;i<size;i++){\\n          avgSalary += salary[i];\\n        }\\n        avgSalary = (avgSalary - gradeToral) / divisor;\\n        return avgSalary;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n       int size = salary.size();\\n       int divisor = size - 2;\\n        double minimumSalary = INT_MAX;\\n        double maximumSalary = 0;\\n        for(int i = 0;i<size;i++){\\n           if(salary[i] > maximumSalary){\\n                maximumSalary = salary[i];\\n            }\\n             if(salary[i] < minimumSalary){\\n                minimumSalary = salary[i];\\n            }\\n        }\\n        double gradeToral = maximumSalary + minimumSalary;\\n        double avgSalary = 0;\\n        \\n        for(int i = 0;i<size;i++){\\n          avgSalary += salary[i];\\n        }\\n        avgSalary = (avgSalary - gradeToral) / divisor;\\n        return avgSalary;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173178,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    return salary.sort((a, b) => a - b)\\n                .slice(1, salary.length - 1)\\n                .reduce((acc, cur) => acc + cur, 0) / (salary.length - 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    return salary.sort((a, b) => a - b)\\n                .slice(1, salary.length - 1)\\n                .reduce((acc, cur) => acc + cur, 0) / (salary.length - 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135049,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array so the bigger number and smaller number will be on first and last place and run the loop for other numbers.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        double sum=0;\\n        for(int i=1;i<s.size()-1;i++)\\n            sum=sum+double(s[i]);\\n        return sum/double(s.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& s) {\\n        sort(s.begin(),s.end());\\n        double sum=0;\\n        for(int i=1;i<s.size()-1;i++)\\n            sum=sum+double(s[i]);\\n        return sum/double(s.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068401,
                "title": "simple-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        m = max(salary)\\n        mn = min(salary)\\n        salary.remove(m)\\n        salary.remove(mn)\\n        sum = 0\\n        for i in range(len(salary)):\\n            sum = sum+ salary[i]\\n        return sum/len(salary)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        m = max(salary)\\n        mn = min(salary)\\n        salary.remove(m)\\n        salary.remove(mn)\\n        sum = 0\\n        for i in range(len(salary)):\\n            sum = sum+ salary[i]\\n        return sum/len(salary)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062993,
                "title": "c-one-liner-with-100-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        return (double)(accumulate(salary.begin(),salary.end(),0) - *min_element(salary.begin(),salary.end()) - *max_element(salary.begin(),salary.end()))/(salary.size()-2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        return (double)(accumulate(salary.begin(),salary.end(),0) - *min_element(salary.begin(),salary.end()) - *max_element(salary.begin(),salary.end()))/(salary.size()-2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985410,
                "title": "one-pass-c-easy-one-liner-0ms-o-1",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double cnt=0,ans=0;\\n        for(int i=1;i<salary.size()-1;++i){\\n            ans+=salary[i];\\n            cnt++;\\n        }\\n        return ans/cnt;\\n    }\\n};\\n```\\n```\\n//copyed solution by votrubac\\ndouble average(vector<int>& s) {\\n    return (accumulate(begin(s), end(s), 0.) - *min_element(begin(s), end(s)) \\n        - *max_element(begin(s), end(s))) / (s.size() - 2);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double cnt=0,ans=0;\\n        for(int i=1;i<salary.size()-1;++i){\\n            ans+=salary[i];\\n            cnt++;\\n        }\\n        return ans/cnt;\\n    }\\n};\\n```\n```\\n//copyed solution by votrubac\\ndouble average(vector<int>& s) {\\n    return (accumulate(begin(s), end(s), 0.) - *min_element(begin(s), end(s)) \\n        - *max_element(begin(s), end(s))) / (s.size() - 2);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968344,
                "title": "using-sort-function-easiest-approach-to-the-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to sort and remove the first and last element which i have put into work.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size();\\n        double avg,sum=0;\\n        sort(salary.begin(),salary.end()); //sorting the vector \\n        for(int i=1;i<n-1;i++){  //abunduning the first(minimum   element) and the last(maximum element) to find the sum of remaining\\n            sum+=salary[i];\\n        }\\n        avg=sum/(n-2);   //find the average\\n        return avg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size();\\n        double avg,sum=0;\\n        sort(salary.begin(),salary.end()); //sorting the vector \\n        for(int i=1;i<n-1;i++){  //abunduning the first(minimum   element) and the last(maximum element) to find the sum of remaining\\n            sum+=salary[i];\\n        }\\n        avg=sum/(n-2);   //find the average\\n        return avg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938408,
                "title": "hess-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let min = Math.min(...salary)\\n    let max = Math.max(...salary)\\n    salary.splice(salary.indexOf(min) , 1)\\n    salary.splice(salary.indexOf(max) , 1)\\n    return (salary.reduce((total , num) => {return total+num} , 0))/salary.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} salary\\n * @return {number}\\n */\\nvar average = function(salary) {\\n    let min = Math.min(...salary)\\n    let max = Math.max(...salary)\\n    salary.splice(salary.indexOf(min) , 1)\\n    salary.splice(salary.indexOf(max) , 1)\\n    return (salary.reduce((total , num) => {return total+num} , 0))/salary.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2890400,
                "title": "python3",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def average(self,salary):\\n        salary.remove(min(salary))\\n        salary.remove(max(salary))\\n        return sum(salary)/len(salary)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def average(self,salary):\\n        salary.remove(min(salary))\\n        salary.remove(max(salary))\\n        return sum(salary)/len(salary)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886586,
                "title": "ruby-easy-one-liner",
                "content": "```\\n# @param {Integer[]} salary\\n# @return {Float}\\ndef average(salary)\\n  (salary.sum - salary.minmax.sum) / (salary.size - 2).to_f\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} salary\\n# @return {Float}\\ndef average(salary)\\n  (salary.sum - salary.minmax.sum) / (salary.size - 2).to_f\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2836655,
                "title": "java-easy-solution-for-beginners",
                "content": "# Intuition\\nsort the array first and then run a loop from 1 to length-1 and add all values in sum variable then divide sum by array length -2 and covert it into double and return it\\n\\n# Approach\\nsorting\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\n    public double average(int[] s) {\\n        Arrays.sort(s);\\n        int sum=0;\\n        for(int i=1;i<s.length-1;i++)\\n        {\\n            sum=sum+s[i];\\n        }\\n        double db=(double)sum/(s.length-2);\\n    return db;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] s) {\\n        Arrays.sort(s);\\n        int sum=0;\\n        for(int i=1;i<s.length-1;i++)\\n        {\\n            sum=sum+s[i];\\n        }\\n        double db=(double)sum/(s.length-2);\\n    return db;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823549,
                "title": "java-100-o-n-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n         if (salary.length == 0) {\\n            return 0.00;\\n        }\\n        \\n        int min = salary[0];\\n        int max = salary[salary.length - 1];\\n\\n        int totalSum = 0;\\n\\n        for (int i = 0; i < salary.length; i++) {\\n            int curSalary = salary[i];\\n            totalSum += curSalary;\\n            if (curSalary < min) {\\n                min = curSalary;\\n            }\\n            if (curSalary > max) {\\n                max = curSalary;\\n            }\\n        }\\n        totalSum = totalSum - max - min;\\n        return (double) totalSum / (salary.length - 2);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n         if (salary.length == 0) {\\n            return 0.00;\\n        }\\n        \\n        int min = salary[0];\\n        int max = salary[salary.length - 1];\\n\\n        int totalSum = 0;\\n\\n        for (int i = 0; i < salary.length; i++) {\\n            int curSalary = salary[i];\\n            totalSum += curSalary;\\n            if (curSalary < min) {\\n                min = curSalary;\\n            }\\n            if (curSalary > max) {\\n                max = curSalary;\\n            }\\n        }\\n        totalSum = totalSum - max - min;\\n        return (double) totalSum / (salary.length - 2);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822091,
                "title": "c-0ms-and-java-0ms-easy-understandable-solutions",
                "content": "**C++ Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salaries) {\\n        int size = salaries.size()-2;\\n        int max=-1, min=pow(10,6);\\n        double sum=0;\\n        for(int& salary : salaries){\\n            sum+=salary;\\n            if(salary>max) max=salary;\\n            if(salary<min) min=salary;\\n        }\\n        sum -= (min+max);\\n        return sum/size;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\n```\\nclass Solution {\\n    public double average(int[] salaries) {\\n        int size = salaries.length-2;\\n        int max=-1, min=1000000;\\n        double sum=0;\\n        for(int salary : salaries){\\n            sum+=salary;\\n            if(salary>max) max=salary;\\n            if(salary<min) min=salary;\\n        }\\n        sum -= (min+max);\\n        return sum/size;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salaries) {\\n        int size = salaries.size()-2;\\n        int max=-1, min=pow(10,6);\\n        double sum=0;\\n        for(int& salary : salaries){\\n            sum+=salary;\\n            if(salary>max) max=salary;\\n            if(salary<min) min=salary;\\n        }\\n        sum -= (min+max);\\n        return sum/size;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public double average(int[] salaries) {\\n        int size = salaries.length-2;\\n        int max=-1, min=1000000;\\n        double sum=0;\\n        for(int salary : salaries){\\n            sum+=salary;\\n            if(salary>max) max=salary;\\n            if(salary<min) min=salary;\\n        }\\n        sum -= (min+max);\\n        return sum/size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515810,
                "title": "using-loops-easy-to-understand-100ms-solution",
                "content": "## Java | for loop | Easy to Understand\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n        int total = n - 2;\\n        double sum = 0;\\n        double avg = 0;\\n        int min = salary[0];\\n        int max = salary[0];\\n        \\n        for(int i=0;i<salary.length;i++) {\\n    \\t    if(min>salary[i])\\n    \\t    \\tmin=salary[i];\\n    \\t    if(max<salary[i])\\n    \\t    \\tmax=salary[i];\\n    \\t    sum = sum + salary[i];\\n        }\\n        sum = sum - min-max;\\n        avg = sum/total;\\n        return avg;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        int n = salary.length;\\n        int total = n - 2;\\n        double sum = 0;\\n        double avg = 0;\\n        int min = salary[0];\\n        int max = salary[0];\\n        \\n        for(int i=0;i<salary.length;i++) {\\n    \\t    if(min>salary[i])\\n    \\t    \\tmin=salary[i];\\n    \\t    if(max<salary[i])\\n    \\t    \\tmax=salary[i];\\n    \\t    sum = sum + salary[i];\\n        }\\n        sum = sum - min-max;\\n        avg = sum/total;\\n        return avg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479916,
                "title": "0ms-100-faster-easy-java-solution-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double max = Integer.MIN_VALUE;\\n        double min = Integer.MAX_VALUE;\\n        double avg = 0;\\n        for(int i = 0 ; i < salary.length; i ++){\\n            avg += salary[i];\\n            if(max < salary[i]){\\n                max = salary[i];\\n            }\\n            if(min > salary[i]){\\n                min = salary[i];\\n            }\\n        }\\n        avg  = avg - min - max;\\n        return avg/(salary.length - 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        double max = Integer.MIN_VALUE;\\n        double min = Integer.MAX_VALUE;\\n        double avg = 0;\\n        for(int i = 0 ; i < salary.length; i ++){\\n            avg += salary[i];\\n            if(max < salary[i]){\\n                max = salary[i];\\n            }\\n            if(min > salary[i]){\\n                min = salary[i];\\n            }\\n        }\\n        avg  = avg - min - max;\\n        return avg/(salary.length - 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472569,
                "title": "java-solution-using-sorting",
                "content": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sum = 0;\\n        for(int i = 1;i<salary.length-1;i++){\\n            sum += salary[i]; \\n        }\\n        return sum/(salary.length-2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n        Arrays.sort(salary);\\n        double sum = 0;\\n        for(int i = 1;i<salary.length-1;i++){\\n            sum += salary[i]; \\n        }\\n        return sum/(salary.length-2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448790,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public double average(int[] salary) {\\n     \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int n = salary.length;\\n        double sum = 0;\\n        for(int i = 0; i < n ; i++){\\n            if(salary[i]>max){\\n                max = salary[i];   //finding max salary\\n            }\\n            if (salary[i]<min){\\n                min = salary[i];  //finding min salary\\n            }\\n            sum = sum + salary[i];   //sum of salaries             \\n        }\\n        double total = sum - min - max;  \\n        return total/(n-2);   //returning average\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public double average(int[] salary) {\\n     \\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int n = salary.length;\\n        double sum = 0;\\n        for(int i = 0; i < n ; i++){\\n            if(salary[i]>max){\\n                max = salary[i];   //finding max salary\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2446456,
                "title": "runtime-0-ms-faster-than-100-00-online-submissions",
                "content": "```\\n/*** 1491. Average Salary Excluding the Minimum and Maximum Salary - CPP17 ***/\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double temp = salary.size()-2;\\n        double sum = 0;\\n        for(int i=1;i<salary.size()-1;++i){\\n            sum+=salary[i];\\n        }\\n        return sum/temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*** 1491. Average Salary Excluding the Minimum and Maximum Salary - CPP17 ***/\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        sort(salary.begin(),salary.end());\\n        double temp = salary.size()-2;\\n        double sum = 0;\\n        for(int i=1;i<salary.size()-1;++i){\\n            sum+=salary[i];\\n        }\\n        return sum/temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417173,
                "title": "python-2-easy-solutions",
                "content": "# Approach 1:\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop(len(salary)-1)\\n        return float(mean(salary))\\n```\\n# Approach 2:\\n\\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary)-max(salary)-min(salary))/(len(salary)-2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        salary.sort()\\n        salary.pop(0)\\n        salary.pop(len(salary)-1)\\n        return float(mean(salary))\\n```\n```\\nclass Solution:\\n    def average(self, salary: List[int]) -> float:\\n        return (sum(salary)-max(salary)-min(salary))/(len(salary)-2)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1686927,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878659,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878771,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878671,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878673,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1690235,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878742,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878637,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878628,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1575290,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1686927,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878659,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878771,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878671,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878673,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1690235,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878742,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878637,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878628,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1575290,
                "content": [
                    {
                        "username": "Julwy",
                        "content": "Hello everyone. I don\\'t understand the 20th testcase. It expects 41111.11111 but my code returns 41111.00000"
                    },
                    {
                        "username": "Aman_nnn777",
                        "content": "you should take double in place of int or float."
                    },
                    {
                        "username": "kunalborkar2001",
                        "content": "you might be using floor\\n"
                    },
                    {
                        "username": "shivroy851",
                        "content": "you can initialize your sum as doble instead of int "
                    },
                    {
                        "username": "shivroy851",
                        "content": "just initialize your sum with double "
                    },
                    {
                        "username": "naveenreddyg664",
                        "content": "you are doing calculation with integers use double while defining variables"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use double "
                    },
                    {
                        "username": "yashj2112",
                        "content": "use double\\n"
                    },
                    {
                        "username": "SubarnaSaikia",
                        "content": "Use average value as double since function return only double data type."
                    },
                    {
                        "username": "kschaitanya2001",
                        "content": "if you are doing python, instead of using integer division, use float division"
                    },
                    {
                        "username": "user8325lF",
                        "content": "cast your integer sum like: return ((double)sum) / count;"
                    },
                    {
                        "username": "Hept",
                        "content": "You are most likely saving the average value into an int variable instead of a float or double."
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Thanks to the Daily Challenge, I now feel that Monday is easier than Saturday and Sunday."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "10^6 salary? woah I wish I get that kind of job by Leetcoding lol"
                    },
                    {
                        "username": "aryabhatt550",
                        "content": "man really!"
                    },
                    {
                        "username": "saubhik",
                        "content": "I now love only hards..."
                    },
                    {
                        "username": "Interstigation",
                        "content": "Is **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:green\">easy</span>**, **<span style=\"color:#8B8000\">medium</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>**, **<span style=\"color:red\">hard</span>** the pattern for dailies now?"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "[@rajeshsingh505](/rajeshsingh505)  (Says a guy with 1300 rating)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Generally they get harder during the week, during the month and if it is the same topic as the day before. So when the last day of the week is the last day of the month you are gonna get more hards, I suspect the this week we won\\'t get three hards, since it is the first week of the month, but I\\'ve been wrong before... during the weekdays it mostly depends on if it was the same topic as the day before. At least that has been my experience (you can check the topics in the general discussion)"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "I like hard only "
                    },
                    {
                        "username": "imdadulhaque",
                        "content": "1. Find the max\\n2. Find the min\\n3. Initilize total Salary\\n4. Loop Through Salary\\n    a. If Current_Salary doesn\\'t equal to max and min.\\n        i. Salary assign to total\\n5. Return total divided by length of salary and minus 2"
                    },
                    {
                        "username": "Dzenly",
                        "content": "Why you need to compare at each iteration if you could just substract min + max at the end, before dividing."
                    },
                    {
                        "username": "namandt",
                        "content": "you can also traverse the array only one time and get the answer."
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "Was this supposed to be a question ? \\uD83E\\uDD21"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "relax warrior, you\\'ve survived 3 hard ques, It\\'s time to take a break and heal yourself."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Simple O(n) solution and a single pass\\nTip: \\nUse 3 variables to keep track of min, max and sum in the loop. After the loop, subtarct the min and max from the sum to get the average.\\n\\nhttps://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471349/simple-o-n-solution-and-a-single-pass/ "
                    },
                    {
                        "username": "Dzenly",
                        "content": "[@matthewwdaly](/matthewwdaly) \\nIf you called \"Judge\" some time-calculating stuff here I think it is completely unreliable and depends on currenlty server load here."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "This was the code I submitted and it lost out to code that sorts the array first.  I\\'m not asking that an O(n log n) algorithm not pass the judge, especially for an easy problem, but it would be nice if the test cases were large enough that an O(n) algorithm would beat it."
                    },
                    {
                        "username": "ariafrz",
                        "content": "Going from the last three days\\' questions to this one is wild! (Be careful with floating point arithmetic though)."
                    },
                    {
                        "username": "sreyah",
                        "content": "return float(sum(sorted(salary)[1:-1]))/float(len(salary)-2)"
                    },
                    {
                        "username": "karthikperso",
                        "content": "[@gandhikhushal333](/gandhikhushal333) its a slice operator, selects the values from 1 index to -2 index"
                    },
                    {
                        "username": "namandt",
                        "content": "[@contactsanskarcs](/contactsanskarcs) So much about readability bro!"
                    },
                    {
                        "username": "julkar9",
                        "content": "the float() isnt required, the normal division operator returns float by default"
                    },
                    {
                        "username": "aswinkrishnap",
                        "content": "it can easily be done in O(n), dont have to sort"
                    },
                    {
                        "username": "kodzhamanov",
                        "content": "[@gandhikhushal333](/gandhikhushal333) Because she sorts the array, the min and max are on the edges. By doing this she ignores them (-1 takes the last element in the array). But this solution is O(n log n). There are one pass solutions available."
                    },
                    {
                        "username": "gandhikhushal333",
                        "content": "[@contactsanskarcs](/contactsanskarcs) can you explain what does [1,-1] does ?"
                    },
                    {
                        "username": "contactsanskarcs",
                        "content": "[@cloud009](/cloud009) The Solution is best,  you implemented the solution in just a line, that\\'s remarkable. Thank you for you\\'re solution. I learnt a lot from it."
                    },
                    {
                        "username": "cloud009",
                        "content": "They\\'ve solution tab for solution\\'s. Please don\\'t post it in discussion tab."
                    }
                ]
            },
            {
                "id": 1878676,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1878639,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1814369,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 2045365,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 2042383,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1947237,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1898415,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1892276,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1881489,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1879618,
                "content": [
                    {
                        "username": "sushi27",
                        "content": "Back to easy. Thank God giving us mercy \\uD83D\\uDE4F"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "no, you should not sort the array "
                    },
                    {
                        "username": "jethroengutan",
                        "content": "why is it saying \"3 is not a valid value of type integer[]\""
                    },
                    {
                        "username": "Mister_CK",
                        "content": "it means that somewhere it expects that something is an array. But you put a number (3) into it. "
                    },
                    {
                        "username": "tomang03",
                        "content": "Hello, Ive been encountering this runtime error:\n\nTypeError: None is not valid value for the expected return type double\n    raise TypeError(str(ret) + \" is not valid value for the expected return type double\");\nLine 46 in _driver (Solution.py)\n    _driver()\nLine 52 in <module> (Solution.py)\n\nDoes anyone know why? The output is printing the correct answer but somehow I keep getting this mistake"
                    },
                    {
                        "username": "dhruv749",
                        "content": "Sort this array and iterate through the array except first and last element .  sum it . use a count too to keep the count of iteration. put  in the formulae of iteration. return irt."
                    },
                    {
                        "username": "sr_saad",
                        "content": "Why do I need to use double instead of float? (C++)"
                    },
                    {
                        "username": "shivroy851",
                        "content": "may be due to 10^-5 "
                    },
                    {
                        "username": "psionl0",
                        "content": "If all else is equal, I would choose double over float every time. About the only reason for choosing float that I can see would be if you had a large number of float variables (an array or matrix)."
                    },
                    {
                        "username": "sainath81061",
                        "content": " public double Average(int[] salary) {\\n       double sum = 0.0;        \\n        double min  = salary.Min();\\n        double max = salary.Max();\\n        for(int i=0;i<= salary.Length -1;i++){\\n            if(salary[i] != min && salary[i] != max){\\n                sum += salary[i];\\n            }\\n        }\\n        sum = sum / (salary.Length -2 );\\n        return sum; \\n    }"
                    },
                    {
                        "username": "FarawayK",
                        "content": "Hey, How do i Count the length of something? i tried using \"Salary.length\" but it didnt work"
                    },
                    {
                        "username": "VinayakM1",
                        "content": "where\\'s the question lol!"
                    },
                    {
                        "username": "er_tanmay_btech",
                        "content": "Why the double, itself is taking 5 digits after decimal? I thought that is the catch here to have 5 digits after decimal....without that is it a question...?"
                    }
                ]
            },
            {
                "id": 1879571,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879528,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879489,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879345,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879305,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879252,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879209,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879197,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879090,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1879017,
                "content": [
                    {
                        "username": "i_rishu2103",
                        "content": "why is it showing wrong answer to me?? output is 41111.00000 but expected output is 41111.11111. this is the only test case I am not able to pass"
                    },
                    {
                        "username": "LeoMiceli",
                        "content": "I have the same problems:\\npublic class Solution {\\n    public double Average(int[] salary) {\\n        var max_salary = salary.Max();\\n        var min_salary = salary.Min();        \\n        var salary2 = salary.Where(x => x != max_salary && x != min_salary).ToArray();\\n       \\n        double avg = salary2.Sum() / salary2.Length;\\n\\n        return avg;\\n    }\\n}"
                    },
                    {
                        "username": "deepu14d",
                        "content": "Hi I want to ask why keeping a count in loop was a better choice for me instead of using salary.length-2  \\nBecause when I used count then the results were better (0ms) than before (2ms) \\n#Using salary.length-2\\n        double sum = 0.0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n        }\\n        return sum/(salary.length-2);\\n\\n#Using count \\n        double sum = 0.0;\\n        int count = 0;\\n        for(int i=1; i<salary.length-1; i++){\\n            sum = salary[i] + sum;\\n            count++;\\n        }\\n        return sum/count;"
                    },
                    {
                        "username": "olirex99",
                        "content": "        # Initialize variable\\n        max_salary = 1000\\n        min_salary = 10e6\\n        sum = 0\\n\\n        # Find max, min and sum of all salaries\\n        for s in salary:\\n            if s > max_salary:\\n                max_salary = s\\n            elif s < min_salary:\\n                min_salary = s\\n            sum += s\\n        \\n        # Calculate the average\\n        avg_salary = (sum - max_salary - min_salary) / (len(salary) - 2)\\n\\n        return avg_salary\\n\\nWhy is not working?"
                    },
                    {
                        "username": "Pavnesh-Silori",
                        "content": "your min salary is a string and string is defined in quotes;  min_salary = \\'10e6\\'"
                    },
                    {
                        "username": "vetor",
                        "content": "track 3 variables min, max and curr_Sum in one iteration  so no need to rerun and just exclude the value while dividing . best approach "
                    },
                    {
                        "username": "rajat_171",
                        "content": "And here we go......................"
                    },
                    {
                        "username": "dinaev2002",
                        "content": "[8000,9000,2000,3000,6000,1000]\\n\\nHow this suppose to return 4750 instead of 5000?\\nJS 3 case"
                    },
                    {
                        "username": "avnukov",
                        "content": "please add this test cases\\n[4000, 3000, 1000, 2000, 4000]\\n[1000, 3000, 1000, 2000, 4000]"
                    },
                    {
                        "username": "Saini-Manisha",
                        "content": "in the description they have mentioned unique value in the array"
                    },
                    {
                        "username": "AFTHAB123",
                        "content": "illegal start of expression ??"
                    },
                    {
                        "username": "anwendeng",
                        "content": "First of May there is one easy task left, especially something about salary."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3472958/easy-c-solution-beats-100/"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "New day after the storm!"
                    }
                ]
            },
            {
                "id": 1878921,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878819,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878746,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878745,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878741,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878721,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878704,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878669,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1878663,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1875579,
                "content": [
                    {
                        "username": "subhajitghosh_",
                        "content": "I have a simple solution! \n1. Sort the array.\n2. Remove the first and last number.\n3. sum the current array\n4. make a double variable, store the sum/salary.size().\n5. return the result."
                    },
                    {
                        "username": "Krrabs",
                        "content": "No need to sort the array"
                    },
                    {
                        "username": "_dmsh_",
                        "content": "What will the complexity be? Can we make it better, say O(n)?"
                    },
                    {
                        "username": "arghyadas",
                        "content": "After 3 days of continuous hard problems\\nthis is relief"
                    },
                    {
                        "username": "You-Know-Who",
                        "content": "I was checking different solutions from time distribution chart and saw that the solution which used \\'sort\\' function was better than single pass solution so why is O(nlogn) solution faster than O(n) solution for this problem ? "
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "bcoz according to constraints, n is till 100 only\\nIf n would have been bigger, then nlogn would be slower"
                    },
                    {
                        "username": "ozone317",
                        "content": "Why is this even a question."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "what is the meaning of this line ---> Answers within 10-5 of the actual answer will be accepted. ??"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "This means that you dont need to approximate the answer or they need the answer till 5 decimal places"
                    },
                    {
                        "username": "psionl0",
                        "content": "So easy that a sub optimal solution will likely pass. My first instinct was to sort the array then add all the middle elements together.\\n\\nThen I realized that I could just do a running total on the unsorted array keeping track of the min and max values found.\\n\\nThe final line is\\n```\\nreturn (total - (double) min - (double) max) / (double) (salarySize-2);\\n```"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "In C++, inbuild functions like \\'ACCUMULATE\\', \\'*MAX_ELEMENT\\', \\'*MIN_ELEMENT\\' are some really useful functions here. "
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n    double average(vector<int>& v) {\\n        double ans=0;\\n        int max = *max_element(v.begin(), v.end());\\n    int min = *min_element(v.begin(), v.end());\\n// cout<<\\ndouble sum=0;\\n    for(int i=0;i<v.size();i++)\\n    sum+=v[i];\\n    \\n    sum=sum-max-min;\\n    ans=double(sum/(v.size()-2));\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I wonder if the LC staff who are throwing joke problems at us get monthly salary, while we are helping the programming AI training for free."
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "I don\\'t know c++ well, and don\\'t understand, why if I use cout << &ans I have right answer, but if I will not use it or just cout << ans, I will have something negative (I don\\'t initialize ans before specifically), why couting ans before helps to convert it to zero?\\n\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans, min_el, max_el;\\n        cout << &ans;  <----- here\\n        for (int i = 0; i < salary.size(); i++){\\n            ans += salary[i];\\n        }\\n        max_el = *max_element(salary.begin(), salary.end());\\n        min_el = *min_element(salary.begin(), salary.end());\\n        ans = ans - (max_el + min_el);\\n        return ans / (salary.size() - 2);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1866108,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1843310,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1831063,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1829135,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1795443,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1782989,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1773863,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1765066,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1762323,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1762299,
                "content": [
                    {
                        "username": "boogywumpy",
                        "content": "My approach:\\nDefine avgsalary - double\\nDefine variable for salary length\\nSORT the array first\\nUsing for loop to based on salary length to find total salary\\navgsalary = total - salary[0] - salary[n-1]\\nreturn avgsalary(n-2);"
                    },
                    {
                        "username": "leminhnghia6695",
                        "content": "mmmm i\\'m not sure what i do wrong, my vscode return correct number 41111.11111 but for case 20 here it return 41111.00000. Can some one help T_T \\n\\nclass Solution(object):\\n    def average(self, salary):\\n        \"\"\"\\n        :type salary: List[int]\\n        :rtype: float\\n        \"\"\"\\n        total = 0\\n        salary.sort()\\n        salary.pop()\\n        salary.pop(0)\\n        for i in salary:\\n            total += i\\n        return round(total/len(salary),5)"
                    },
                    {
                        "username": "user3423NK",
                        "content": "error in testcase 18\\nvar average = function(salary) {\\n    let sortedSalary = salary.sort()\\n    let firstIndex = sortedSalary[0]\\n    let lastIndex = sortedSalary.slice(-1)\\n    let excludeSalary = Math.pow(10,5)\\n    let averageSalary = [];\\n    sortedSalary.map((item,index)=>{   \\n\\n        if(item <= excludeSalary  && item != firstIndex && item != lastIndex ){\\n            averageSalary.push(item)\\n\\n        }\\n\\n    })\\n\\n  let total =  averageSalary.reduce((a, b) => a + b, 0)\\n  let count = averageSalary.length\\n  console.log(count,total,averageSalary)\\n  let cal = (total / count)\\n  //let round = Math.round(cal)\\n\\n\\nreturn cal\\n    \\n};"
                    },
                    {
                        "username": "Daniilkajest",
                        "content": "guys , im beginner help me and try explain, what i did wrong?\\nIn python:\\nsalary = [4000,3000,2000,1000]\\nmax_salary= max (salary)\\nmin_salary= min(salary)\\nsalary.remove(min_salary)\\nsalary.remove(max_salary)\\nsum_salary_list=sum(salary)\\nsalary_average=sum(salary)/len(salary)\\nprint(salary_average)\\n"
                    },
                    {
                        "username": "baw4ux",
                        "content": "Did you return salary_average? I just ran your code replacing the last print statement with return and it passed all test cases."
                    },
                    {
                        "username": "CH3CH2OH",
                        "content": "I submitted the following code and the answer is wrong, could anyone tell me why??? \\nclass Solution(object):\\n    def average(self, salary):\\n        a=max(salary)\\n        b=min(salary)\\n        salary.remove(a)\\n        salary.remove(b)\\n        i = len(salary)\\n        return sum(salary)/i\\n\\nInput\\nsalary =\\n[48000,59000,99000,13000,78000,45000,31000,17000,39000,37000,93000,77000,33000,28000,4000,54000,67000,6000,1000,11000]\\nOutput\\n41111.00000\\nExpected\\n41111.11111"
                    },
                    {
                        "username": "charonme",
                        "content": "depending on which language you use it\\'s possible your language makes an integer division if both arguments are integers. In that case casting the arguments to a floating point datatype could help"
                    },
                    {
                        "username": "mrmobuu",
                        "content": "can anyone tell me what the error in my code in my 20th test case my code is returning 41111.0000 instead of 41111.11111 .\\nfor(int j = 0 ; j < salary.size() - 1 ; j++){\\n            for(int i = 0 ; i < salary.size() - 1; i++){\\n                if(salary[i] > salary[i+1]){\\n                    swap(salary[i],salary[ i +1 ]);\\n                }\\n            }\\n        }\\n        int sum = 0;\\n        for(int i = 1; i < salary.size() - 1; i++){\\n            sum += salary[i];\\n        }\\n        double avg = sum / (salary.size() - 2);\\n        return avg;\\n    }"
                    },
                    {
                        "username": "silviah1311",
                        "content": "maybe you can try using \\'\\'sum\\'\\' by \\'\\'double\\'\\'?"
                    },
                    {
                        "username": "adityajai243",
                        "content": "try using sort() instead of swap\\n"
                    },
                    {
                        "username": "FiddleSticks-",
                        "content": "Hello.\nI am using a loop to count the sum of the elements of an array.\nThen I divide this sum by the size of the vector.\nIn the case of Input [8000,9000,2000,3000,6000,1000]\nI should get 4750.00000\nbut i get 4833.00000\nTell me where is the mistake? "
                    },
                    {
                        "username": "hoangnguyen12397",
                        "content": "I guess you misunderstand the question. The question requires your algorithm to calculate the average excluding the max and min. But, in your algorithm, you don\\'t exclude these two numbers. Hence, your algorithm works wrong."
                    },
                    {
                        "username": "gpancardo",
                        "content": "Given the list [4000,3000,1000,2000] I calculate 2000.00000 and the expected output is 2500.00000.\\nI removed the first and last elements and then added the other two and divided by two, where did I go wrong?\\nThanks :D"
                    },
                    {
                        "username": "rifuath331",
                        "content": "basically, what you just did is, took the (3000 + 100) / 2.  according to the question you have to eliminate the max and min value of an array. "
                    },
                    {
                        "username": "crossecodes",
                        "content": "if multiple people have the same max salary are they both removed or only one person for max/min"
                    },
                    {
                        "username": "charonme",
                        "content": "description says values are unique"
                    },
                    {
                        "username": "sahilsayyad",
                        "content": "import java.util.Arrays;\\nclass Solution {\\n    public double average(int[] salary) {\\n      \\n      Arrays.sort(salary);\\n\\n      int n = salary.length;\\n      double avarage= (salary[0] + salary[n-1])/2;\\n\\n      return avarage;\\n    }\\n} \\n\\nwhat is problem with do you anyone check"
                    }
                ]
            },
            {
                "id": 1760635,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1756309,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1737121,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1729177,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1726354,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1725438,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1712911,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1710947,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1705149,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            },
            {
                "id": 1686380,
                "content": [
                    {
                        "username": "Smruti1210",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        double avgSal=0;\\n        int n=salary.length,total=0;\\n        Arrays.sort(salary);\\n        for(int i=0;i<n;i++)\\n        {\\n            total = total + salary[i];\\n        }\\n        avgSal = total - salary[0]-salary[n-1];\\n        return avgSal/(n-2);\\n    }\\n}"
                    },
                    {
                        "username": "sunnykmr8",
                        "content": "use Double for sum"
                    },
                    {
                        "username": "Extreme-ly",
                        "content": "[8000,9000,2000,3000,6000,1000]\\nis a testcase,\\nmy program outputs 5000,\\nleetcode says nay,\\nit says 4750"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "class Solution {\\n    public double average(int[] salary) {\\n        int maxSal = salary[0];\\n        int minSal = salary[0];\\n        for(int i=0;i<salary.length;i++){\\n            minSal = Math.min(minSal,salary[i]);\\n            maxSal = Math.max(maxSal,salary[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<salary.length;i++){\\n            if(salary[i]!=minSal && salary[i]!=maxSal){\\n                sum+=salary[i];\\n            }\\n        }\\n        return sum/(double) salary.length - 2;\\n    }\\n}\\n\\nI dont know what is wrong with this code testcases never passes. Someone please help me with this"
                    },
                    {
                        "username": "aneesh_vengeance7",
                        "content": "You can check this as well, quite long but easily understandable\\nclass Solution {\\n    public double average(int[] salary) {\\n        int sum=0;\\n        int count = 0;\\n        int mx = getMax(salary);\\n        int mn = getMin(salary);\\n        for(int i=0; i<salary.length; i++){\\n            if(salary[i] != salary[mx] && salary[i] != salary[mn]){\\n                sum += salary[i];\\n                count += 1;\\n            }\\n        }\\n        return sum/(double)(count);\\n    }\\n    public static int getMax(int[] salary){\\n        int max = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[max] < salary[i]){\\n                max = i;\\n            }\\n        }\\n        return max;\\n    }\\n    public static int getMin(int[] salary){\\n        int min = 0;\\n        for(int i=1; i<salary.length; i++){\\n            if(salary[min] > salary[i]){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\nAlthough optimised solutions are possible for this question "
                    },
                    {
                        "username": "bhaveshrikame0804",
                        "content": "class Solution:\\n    def average(self, salary: List[int]) -> float:\\n        mini=min(salary)\\n        maxi=max(salary)\\n        remaining=sum(salary)-mini-maxi\\n        return remaining/(len(salary)-2)"
                    },
                    {
                        "username": "jithinj77",
                        "content": "1.use a loop to iterate through the salary \\n2.check whether each element is min or max and add each element \\n3. return the total sum - min and max and divide by length of salary\\n\\n"
                    },
                    {
                        "username": "ahjimomo",
                        "content": "## Hint for python3\\npython3 has the functions of `list.sort()`, `len()` and `sum()`\\n\\nMake use of them with slicing! ;) "
                    },
                    {
                        "username": "Abhishek_kumar_kashyap-81",
                        "content": "getting wrong answer on vector of bigger size--\\n\\nclass Solution {\\n\\nprivate:\\n  double solve(vector<int> salary,double& ans){\\n        int len = salary.size();\\n        int min = *min_element(salary.begin(),salary.end());\\n        int max = *max_element(salary.begin(),salary.end());\\n\\n        int sum = 0;\\n        int count = 0;\\n        for(int i=0 ; i<len ; i++){\\n            if(salary[i] != max || salary[i] != min){\\n                sum = sum + salary[i];\\n                count++;\\n            }       \\n        } \\n        \\n         ans = sum/count;\\n         return ans;\\n        \\n    }\\n\\npublic:\\n    double average(vector<int>& salary) {\\n        double ans = 0;\\n        int count=0;\\n        solve(salary,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "vasanthkumark0112",
                        "content": "`class Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int size = salary.size();\\n        double avg = 0;\\n\\n        int max = *salary.begin();\\n        int min = *salary.begin();\\n\\n        for (auto i = salary.begin(); i!= salary.end(); i++)\\n        {\\n            avg+=*i;\\n            if(*i>max) max = *i;\\n            if(*i<min) min = *i;\\n        }\\n\\n        avg = (avg-(max+min))/(size-2);\\n        return avg;\\n\\n    }\\n};`\\nThis is my code.\\n\\nMy solution takes 5 ms while the best solution takes only 0ms.\\n\\nI could not understand why. Can someone help me point what is making this difference?"
                    },
                    {
                        "username": "prashantk01",
                        "content": "may be because of auto keyword, try with int"
                    }
                ]
            }
        ]
    },
    {
        "title": "Incremental Memory Leak",
        "question_content": "<p>You are given two integers <code>memory1</code> and <code>memory2</code> representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second.</p>\n\n<p>At the <code>i<sup>th</sup></code> second (starting from 1), <code>i</code> bits of memory are allocated to the stick with <strong>more available memory</strong> (or from the first memory stick if both have the same available memory). If neither stick has at least <code>i</code> bits of available memory, the program <strong>crashes</strong>.</p>\n\n<p>Return <em>an array containing </em><code>[crashTime, memory1<sub>crash</sub>, memory2<sub>crash</sub>]</code><em>, where </em><code>crashTime</code><em> is the time (in seconds) when the program crashed and </em><code>memory1<sub>crash</sub></code><em> and </em><code>memory2<sub>crash</sub></code><em> are the available bits of memory in the first and second sticks respectively</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> memory1 = 2, memory2 = 2\n<strong>Output:</strong> [3,1,0]\n<strong>Explanation:</strong> The memory is allocated as follows:\n- At the 1<sup>st</sup> second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.\n- At the 2<sup>nd</sup> second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.\n- At the 3<sup>rd</sup> second, the program crashes. The sticks have 1 and 0 bits available respectively.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> memory1 = 8, memory2 = 11\n<strong>Output:</strong> [6,0,4]\n<strong>Explanation:</strong> The memory is allocated as follows:\n- At the 1<sup>st</sup> second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.\n- At the 2<sup>nd</sup> second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.\n- At the 3<sup>rd</sup> second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.\n- At the 4<sup>th</sup> second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.\n- At the 5<sup>th</sup> second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.\n- At the 6<sup>th</sup> second, the program crashes. The sticks have 0 and 4 bits available respectively.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= memory1, memory2 &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1210210,
                "title": "python-o-1-solution",
                "content": "Since I didn\\'t realize during the contest that the simple brute-force passed all the tests - came up with an O(1) solution. Let\\'s assume that the first memory stick is larger than the second one. If it\\'s not the case - we can always re-assign variables. \\n\\nThen we have 2 stages:\\n* Memory is used from the first stick until it becomes smaller than the second one. \\n* Then memory is used sequentially from: 2nd stick, 1st stick, 2nd stick, 1st stick... \\n\\nFor each stage the amount of memory removed is a sum of an arithmetic sequence. With step d=1 for the first stage and d=2 for the second one. So to get the number of steps in each stage we have to solve quadratic equations.\\n```\\nn**2 + i*n = x\\n```\\nThis is done using a helper function:\\n```\\ndef solve_quadratic(i,x):\\n    return floor( (-i + sqrt(i**2+4*x))/2 )\\n```\\n \\nThe full solution is then:\\n\\n```\\n\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        \\n        inverted = False \\n        if memory2>memory1:\\n            memory2, memory1 = memory1, memory2\\n            inverted = True \\n\\n\\t\\t#Compute the number of steps in first stage - 1\\n        i_start = solve_quadratic(1,2*(memory1-memory2))\\n        \\n\\t\\t#Memory1 after the end of first stage is computed using the sum of arithmetic sequence\\n        memory1-= i_start*(i_start+1)//2\\n\\t\\t\\n\\t\\tif memory1 == memory2: #Special case (if we end up with equal numbers after stage - 1 - undo inversion)\\n            inverted = False \\n       \\n        #Compute number of steps in stage - 2\\n        n_end = solve_quadratic((i_start+1), memory2)\\n        \\n\\t\\t#Compute sums of respective arithmetic sequences\\n        i_end_1 = i_start - 1 + 2*n_end\\n        i_end_2 = i_start + 2*n_end\\n        \\n        sum1 = n_end * (i_start+1 + i_end_1)//2\\n        sum2 = n_end * (i_start+2 + i_end_2)//2\\n        \\n\\t\\t#Compute updated memories \\n        memory1-=sum1\\n        memory2-=sum2\\n        \\n        full_cnt=2*n_end+i_start\\n        \\n        if memory1>=i_end_2+1: #If we can still make one removal from the first stick - perform it.\\n            memory1-=(i_end_2+1)\\n            full_cnt+=1\\n            \\n        return [full_cnt+1, memory2, memory1] if inverted else [full_cnt+1, memory1, memory2]\\n            \\n\\t\\t ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nn**2 + i*n = x\\n```\n```\\ndef solve_quadratic(i,x):\\n    return floor( (-i + sqrt(i**2+4*x))/2 )\\n```\n```\\n\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        \\n        inverted = False \\n        if memory2>memory1:\\n            memory2, memory1 = memory1, memory2\\n            inverted = True \\n\\n\\t\\t#Compute the number of steps in first stage - 1\\n        i_start = solve_quadratic(1,2*(memory1-memory2))\\n        \\n\\t\\t#Memory1 after the end of first stage is computed using the sum of arithmetic sequence\\n        memory1-= i_start*(i_start+1)//2\\n\\t\\t\\n\\t\\tif memory1 == memory2: #Special case (if we end up with equal numbers after stage - 1 - undo inversion)\\n            inverted = False \\n       \\n        #Compute number of steps in stage - 2\\n        n_end = solve_quadratic((i_start+1), memory2)\\n        \\n\\t\\t#Compute sums of respective arithmetic sequences\\n        i_end_1 = i_start - 1 + 2*n_end\\n        i_end_2 = i_start + 2*n_end\\n        \\n        sum1 = n_end * (i_start+1 + i_end_1)//2\\n        sum2 = n_end * (i_start+2 + i_end_2)//2\\n        \\n\\t\\t#Compute updated memories \\n        memory1-=sum1\\n        memory2-=sum2\\n        \\n        full_cnt=2*n_end+i_start\\n        \\n        if memory1>=i_end_2+1: #If we can still make one removal from the first stick - perform it.\\n            memory1-=(i_end_2+1)\\n            full_cnt+=1\\n            \\n        return [full_cnt+1, memory2, memory1] if inverted else [full_cnt+1, memory1, memory2]\\n            \\n\\t\\t ```",
                "codeTag": "Java"
            },
            {
                "id": 1210088,
                "title": "java-c-python-solution",
                "content": "**Java**\\n\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(Math.max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        return new int[]{i, memory1, memory2};\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while max(memory1, memory2) >= i:\\n            if memory1 >= memory2:\\n                memory1 -= i\\n            else:\\n                memory2 -= i\\n            i += 1\\n        return [i, memory1, memory2]\\n```\\n\\n```\\nclass Solution:\\n    def memLeak(self, m1: int, m2: int) -> List[int]:\\n        res = [1,m1,m2]\\n        while 1:\\n            if res[2] > res[1]:\\n                mx = 2\\n            else:\\n                mx = 1\\n            if res[0] > res[mx]:\\n                return res\\n            else:\\n                res[mx] -= res[0]\\n            res[0]+=1\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(Math.max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        return new int[]{i, memory1, memory2};\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while max(memory1, memory2) >= i:\\n            if memory1 >= memory2:\\n                memory1 -= i\\n            else:\\n                memory2 -= i\\n            i += 1\\n        return [i, memory1, memory2]\\n```\n```\\nclass Solution:\\n    def memLeak(self, m1: int, m2: int) -> List[int]:\\n        res = [1,m1,m2]\\n        while 1:\\n            if res[2] > res[1]:\\n                mx = 2\\n            else:\\n                mx = 1\\n            if res[0] > res[mx]:\\n                return res\\n            else:\\n                res[mx] -= res[0]\\n            res[0]+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210223,
                "title": "java-python-3-bruteforce-code-w-brief-analysis",
                "content": "```java\\n    public int[] memLeak(int mem1, int mem2) {\\n        int leaking = 1;\\n        while (mem1 >= leaking || mem2 >= leaking) {\\n            if (mem1 < mem2) {\\n                mem2 -= leaking++; \\n            }else {\\n                mem1 -= leaking++;\\n            }\\n        }\\n        return new int[]{leaking, mem1, mem2};\\n    }\\n```\\n\\n```python\\n    def memLeak(self, mem1: int, mem2: int) -> List[int]:\\n        leaking = 1\\n        while mem1 >= leaking or mem2 >= leaking:\\n            if mem1 < mem2:\\n                mem2 -= leaking\\n            else:\\n                mem1 -= leaking\\n            leaking += 1\\n        return [leaking, mem1, mem2]\\n```\\n**Analysis:**\\n`leaking` go from `1` to `2, 3, 4, ...`, sum of which will be `(1 + leaking) * leaking / 2` ~ `O(leaking ^ 2)`. Therefore, \\n\\nTime: `O(sqrt(mem1 + mem2))`, space: `O(1)`. \\n- credit to **@saksham-kapoor** for correction.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] memLeak(int mem1, int mem2) {\\n        int leaking = 1;\\n        while (mem1 >= leaking || mem2 >= leaking) {\\n            if (mem1 < mem2) {\\n                mem2 -= leaking++; \\n            }else {\\n                mem1 -= leaking++;\\n            }\\n        }\\n        return new int[]{leaking, mem1, mem2};\\n    }\\n```\n```python\\n    def memLeak(self, mem1: int, mem2: int) -> List[int]:\\n        leaking = 1\\n        while mem1 >= leaking or mem2 >= leaking:\\n            if mem1 < mem2:\\n                mem2 -= leaking\\n            else:\\n                mem1 -= leaking\\n            leaking += 1\\n        return [leaking, mem1, mem2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1210023,
                "title": "c-easy-solution",
                "content": "```\\nvector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(1){\\n            if(m1 >= m2){\\n                if(m1 >= i)\\n                    m1-=i;\\n                else\\n                    return {i,m1,m2};\\n            }else{\\n                if(m2 >=i)\\n                    m2-=i;\\n                else\\n                    return {i,m1,m2};\\n            }\\n            i++;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(1){\\n            if(m1 >= m2){\\n                if(m1 >= i)\\n                    m1-=i;\\n                else\\n                    return {i,m1,m2};\\n            }else{\\n                if(m2 >=i)\\n                    m2-=i;\\n                else\\n                    return {i,m1,m2};\\n            }\\n            i++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2311113,
                "title": "beats-100-other-solutions",
                "content": "```\\n# Time:  O(1)\\n# Space: O(1)\\n\\n# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/00000000003384ea\\n\\n\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n        def s(a, d, n):\\n            return (2*a + (n-1)*d)*n//2\\n\\n        def f(a, d, x):\\n            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))\\n            if s(a, d, r) > x:  # adjust float accuracy\\n                r -= 1\\n            return r\\n\\n        is_swapped = False\\n        if memory1 < memory2:\\n            memory1, memory2 = memory2, memory1\\n            is_swapped = True\\n        n = f(1, 1, memory1-memory2)\\n        memory1 -= s(1, 1, n)\\n        if memory1 == memory2:\\n            is_swapped = False\\n        l = f(n+1, 2, memory1)\\n        r = f(n+2, 2, memory2)\\n        memory1 -= s(n+1, 2, l)\\n        memory2 -= s(n+2, 2, r)\\n        if is_swapped:\\n            memory1, memory2 = memory2, memory1\\n        return [n+l+r+1, memory1, memory2]\\n```",
                "solutionTags": [],
                "code": "```\\n# Time:  O(1)\\n# Space: O(1)\\n\\n# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/00000000003384ea\\n\\n\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n        def s(a, d, n):\\n            return (2*a + (n-1)*d)*n//2\\n\\n        def f(a, d, x):\\n            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))\\n            if s(a, d, r) > x:  # adjust float accuracy\\n                r -= 1\\n            return r\\n\\n        is_swapped = False\\n        if memory1 < memory2:\\n            memory1, memory2 = memory2, memory1\\n            is_swapped = True\\n        n = f(1, 1, memory1-memory2)\\n        memory1 -= s(1, 1, n)\\n        if memory1 == memory2:\\n            is_swapped = False\\n        l = f(n+1, 2, memory1)\\n        r = f(n+2, 2, memory2)\\n        memory1 -= s(n+1, 2, l)\\n        memory2 -= s(n+2, 2, r)\\n        if is_swapped:\\n            memory1, memory2 = memory2, memory1\\n        return [n+l+r+1, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210083,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        k = 1\\n        while k <= memory1 or k <= memory2: \\n            if memory1 < memory2: memory2 -= k \\n            else: memory1 -= k \\n            k += 1\\n        return [k, memory1, memory2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        k = 1\\n        while k <= memory1 or k <= memory2: \\n            if memory1 < memory2: memory2 -= k \\n            else: memory1 -= k \\n            k += 1\\n        return [k, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1211506,
                "title": "java-easy-simulate-100-faster-100-less-memory",
                "content": "Do upvote if you like the solution, and comment if optimizations of the approach are possible.\\n\\n```\\npublic int[] memLeak(int memory1, int memory2) {\\n        int a[], i = 1;\\n        while(memory1 >= i || memory2 >= i) {\\n            if(memory1 >= memory2)\\n                    memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        a = new int[]{i, memory1, memory2};\\n        return a;\\n    }\\n```\\n\\nThank You!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] memLeak(int memory1, int memory2) {\\n        int a[], i = 1;\\n        while(memory1 >= i || memory2 >= i) {\\n            if(memory1 >= memory2)\\n                    memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        a = new int[]{i, memory1, memory2};\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210903,
                "title": "c-two-solutions-with-math-proof",
                "content": "## Solution 1 -- Simulation:\\n#### (If you can come up with this solution, you can skip the first one and read the second solution.)\\n*Idea:*\\nThis is the most straightforward soultion that one can come up with at the first glance. I guess it can pass the OJ becuase its time is O(sqrt(n)).\\n\\n*Code:*\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int time = 1;\\n        while (max(memory1, memory2) >= time) {\\n            if (memory1 >= memory2) {\\n                memory1 -= time;\\n            } else {\\n                memory2 -= time;\\n            }\\n            ++time;\\n        }\\n        return {time, memory1, memory2};\\n    }\\n};\\n```\\n\\n\\n## Solution 2 -- Math with Explanation:\\n*Idea:*\\nIf we dive deeper into the problem, we would find that actually the whole simulation can be divided into two parts:\\n* Make `memory1` and `memory2` as close as possible, or we would continue consume the one much bigger than the other.\\n\\t\\t e.g. `memory1 = 9` and `memory2 = 1`, it will be [9,1] -> [8,1] -> [6, 1] -> [3, 1] (done.)\\n* From this point on, we would take turns to consume the memories, like `memory1` -> `memory2` -> `memory1` -> `memory2` -> `memory1` -> ... , until the memory is insufficient.\\n\\n*(For simplicity, we use `m1`, `m2` to represent `memory1` and `memory2` respectively.)*\\nBased on this, let\\'s first tackle down the first step: how many steps before we can make the two memories **close**?\\n* what is the length of making them close?\\n  Ans: maximum length should be `abs(m1 - m2)`\\n* We started from 1, and assume we stop at `k` to make `sum(1, k) <= abs(m1 - m2)`. Here, `sum(1, k)` means the value sum from integer 1 to k. And it\\'s easy to get `sum(1, k) = k*(k+1)/2`.\\n  Let `d = abs(m1 - m2)`, and we have `k*(k+1)/2 <= d` => ` k = floor(sqrt(2*d+0.25) - 0.5)`.\\n\\nAfter making the two memory blocks **close**, the next task to tackle down is: How can we get to know the final stages of both memory, and what\\'s the total step?\\n* In order to make it aligned, we would always start that `m1 >= m2`, so if we found `m2 > m1`, just swap the two memory and swap it back before return.\\n* According to our assumption, `m1` is always bigger or equal to `m2`, so we always start from `m1`.\\n  Now we would have to prove that the `m1` and `m2` would take turns to be consumed.\\n  Proof: \\n  ```\\n  Assume starting step = k, and m1 >= m2.\\n  After first consumption, m1-k < m2, then next stage is (m1-k, m2-k-1) and m1 >= m2 => m1-k > m2-k-1.\\n  The third stage is (m1-k-k-2, m2-k-1). Because m1-k < m2 => m1-k-k-2 < m2-k-2 < m2-k-1, so on and so on forth...\\n  ```\\n  (This is not a strict math proof, but we can get a common sense from it.)\\n* The question now becomes: how many steps at most can they take before reaching the stop stage?\\n  Previously, we have taken `k` steps to reach the **close** stage, so the next step length is `k+1`.\\n  For `m1`, because we take turns to consume the memories, so we have `(k+1) + (k+3) + (k+5) + ... + tail1 <= m1`, where `tail1` is the last step length before reaching stop stage.\\n  Similarly, we have `(k+2) + (k+4) + (k+6) + ... + tail2 <= m2`.\\n  Translating them into equations, we have:\\n  ```\\n  (k+1+tail1)*(tail1-k+1)/4 <= m1\\n  (k+2+tail2)*(tail2-k)/4 <= m2\\n  ```\\n  So if we can get `tail1` and `tail2`, we would be very close to the answer. Fortunately, we know `k` and `m1`, `m2`. So it\\'s easy to get that\\n  ```\\n  tail1 = sqrt(4*m1 +(k+1)*(k-1) + 1) -1 = sqrt(4*m1+k*k)-1\\n  tail2 = sqrt(4*m2 + (k+2)*k + 1) - 1 = sqrt(4*m2 + (k+1)*(k+1)) - 1\\n  ```\\n  **Attention**: our stride is `2` for each memory here, so we need to make their parity aligned, or we would make mistakes.\\n\\nAfter all that, we just find the maximum step between `m1` and `m2`. Then, we just get the final answer. Don\\'t forget to swap back the memory if we swapped them earlier.\\n\\nHope that helps ;)\\n\\n*Code:*\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n\\t\\t// first step:\\n\\t\\t// make m1 and m2 close\\n        int d = abs(memory1 - memory2);\\n        int k = sqrt(2L*d+0.25)-0.5;\\n        int total = (long)k*(k+1)/2;\\n        if (memory1 > memory2) {\\n            memory1 -= total;\\n        } else {\\n            memory2 -= total;\\n        }\\n        \\n\\t\\t// swap m1 and m2 if necessary\\n        bool changed = false;\\n        if (memory2 > memory1) {\\n            swap(memory2, memory1);\\n            changed = true;\\n        }\\n\\t\\t\\n\\t\\t// get tail1 and tail2 from our equation\\n        int start = k+1;\\n        int t1 = sqrt(4L*memory1 + (long)start*(start-2) + 1L) - 1.0;\\n        int t2 = sqrt(4L*memory2 + (long)start*start) - 1.0;\\n\\t\\t\\n\\t\\t// checking parity\\n        if ((start&1) ^ (t1&1)) --t1;\\n        if (((start+1)&1) ^ (t2&1)) --t2;\\n\\n\\t\\t// get crash time, as well as the final stage of m1/m2\\n        int time = max(t1, t2)+1;\\n        memory1 -= (long)(start+t1)*(t1-start+2)/4;\\n        memory2 -= (long)(start+t2+1)*(t2-start+1)/4;\\n        \\n\\t\\t// swap m1, m2 if needed\\n        if (changed) {\\n            return {time, memory2, memory1};\\n        }\\n        return {time, memory1, memory2};\\n    }\\n};\\n```\\n\\nTime: O(1)",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int time = 1;\\n        while (max(memory1, memory2) >= time) {\\n            if (memory1 >= memory2) {\\n                memory1 -= time;\\n            } else {\\n                memory2 -= time;\\n            }\\n            ++time;\\n        }\\n        return {time, memory1, memory2};\\n    }\\n};\\n```\n```\\n  Assume starting step = k, and m1 >= m2.\\n  After first consumption, m1-k < m2, then next stage is (m1-k, m2-k-1) and m1 >= m2 => m1-k > m2-k-1.\\n  The third stage is (m1-k-k-2, m2-k-1). Because m1-k < m2 => m1-k-k-2 < m2-k-2 < m2-k-1, so on and so on forth...\\n  ```\n```\\n  (k+1+tail1)*(tail1-k+1)/4 <= m1\\n  (k+2+tail2)*(tail2-k)/4 <= m2\\n  ```\n```\\n  tail1 = sqrt(4*m1 +(k+1)*(k-1) + 1) -1 = sqrt(4*m1+k*k)-1\\n  tail2 = sqrt(4*m2 + (k+2)*k + 1) - 1 = sqrt(4*m2 + (k+1)*(k+1)) - 1\\n  ```\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n\\t\\t// first step:\\n\\t\\t// make m1 and m2 close\\n        int d = abs(memory1 - memory2);\\n        int k = sqrt(2L*d+0.25)-0.5;\\n        int total = (long)k*(k+1)/2;\\n        if (memory1 > memory2) {\\n            memory1 -= total;\\n        } else {\\n            memory2 -= total;\\n        }\\n        \\n\\t\\t// swap m1 and m2 if necessary\\n        bool changed = false;\\n        if (memory2 > memory1) {\\n            swap(memory2, memory1);\\n            changed = true;\\n        }\\n\\t\\t\\n\\t\\t// get tail1 and tail2 from our equation\\n        int start = k+1;\\n        int t1 = sqrt(4L*memory1 + (long)start*(start-2) + 1L) - 1.0;\\n        int t2 = sqrt(4L*memory2 + (long)start*start) - 1.0;\\n\\t\\t\\n\\t\\t// checking parity\\n        if ((start&1) ^ (t1&1)) --t1;\\n        if (((start+1)&1) ^ (t2&1)) --t2;\\n\\n\\t\\t// get crash time, as well as the final stage of m1/m2\\n        int time = max(t1, t2)+1;\\n        memory1 -= (long)(start+t1)*(t1-start+2)/4;\\n        memory2 -= (long)(start+t2+1)*(t2-start+1)/4;\\n        \\n\\t\\t// swap m1, m2 if needed\\n        if (changed) {\\n            return {time, memory2, memory1};\\n        }\\n        return {time, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210581,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(memory1>=i || memory2>=i){\\n            if(memory1>=memory2) memory1-=i++;\\n            else memory2-=i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(memory1>=i || memory2>=i){\\n            if(memory1>=memory2) memory1-=i++;\\n            else memory2-=i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210265,
                "title": "c-simulation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force\\n\\nFor the first `i` seconds, `i * (i - 1) / 2` memory is taken. The process will stop before `i * (i - 1) / 2 >= A + B`. So the time complexity is at most `O(sqrt(A + B))`. Since `A` and `B` are at most `2^31-1 ~= 10^9`, so `sqrt(A + B)` is at most around `10^4.5` which is fine.  \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/incremental-memory-leak/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(A + B))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int A, int B) {\\n        int i = 1;\\n        while (A >= i || B >= i) {\\n            if (A >= B) {\\n                A -= i;\\n            } else {\\n                B -= i;\\n            }\\n            ++i;\\n        }\\n        return {i, A, B};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/incremental-memory-leak/\\n// Author: github.com/lzl124631x\\n// Time: O(sqrt(A + B))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int A, int B) {\\n        int i = 1;\\n        while (A >= i || B >= i) {\\n            if (A >= B) {\\n                A -= i;\\n            } else {\\n                B -= i;\\n            }\\n            ++i;\\n        }\\n        return {i, A, B};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206246,
                "title": "it-can-be-done-in-o-1-3-sqrt-calls-using-math",
                "content": "# Intuition\\nI found a solution that ran in `2ms` in the old UI. For reference the fastest simulation solutions are `>= 4ms`(Java). For some reason in the new UI, submissions will not list the fastest solutions if there are very few of them. \\n\\nIt was a math based solution that I could not make sense of, even after hours of trying. The solver used quite a few maths that I couldnt piece together and binary search. The complexity was loosely speaking $O(log(max\\\\{mem1, mem2\\\\}))$. Their code also had a `println()` statement for debugging. After removing it and testing their code, it ran in `0ms`! \"Amazing\" I thought. But I still could not make sense of the code. Knowing it was possible though, I wanted to try to come up with my own math solution.\\n\\n# Formulas Below\\nThe formulas I used in the code will be at the end.\\n\\n# Approach\\n\\nBefore starting the math, I coded the simulation solution and once it was accepted, I used it as a ruler for running my modified method. I copy-pasted the simulation solution and started creeping math formulas in. \\n\\nMy first idea: Since the program possibly subtracts consecutive integers from one memory stick, I looked for a formula to find the maximum $n$ such that:\\n$$\\\\sum_1^n i \\\\leq k$$ for some $k$. \\n \\nThis resulted in a significant speedup for edge cases where the difference between the capacity in memory sticks is huge. I\\'ll show an example why \\n\\nImagine you have `m1 = 1` and `m2 = 1000`\\nThen the execution will keep subtracting small values from the second one until it reaches a point `m2 <= m1`. In other words it will subtract integers up to some value `n` such that:\\n$$m_2 - \\\\sum_1^n i \\\\leq m_1$$\\n\\nI think this is where the other solution used binary search to find this value $n$. But in any case this seemed hard for me. Instead I opted to find the next best thing. That for me was the above, possibly without the last subtraction. Formally I was looking for the max $n$ such that $$m_2 - \\\\sum_1^n i \\\\geq m_1$$ or by rearranging: \\n\\n$$\\\\sum_1^n i \\\\leq m_2 - m_1\\\\ \\\\ \\\\ (1)$$.\\n\\nNotice that $(1)$ is our initial formula for $k = m_2-m_1$ or $k = |m2 - m1|$ in general. Therefore we can instantly subtract this from the maximum memory stick at the start without any worry. Then it will need at most 1 more subtraction from the max to go to the state `m2 <= m1`. Since we used all the numbers from $1$ to $n$, time advances to $n + 1$.\\n\\nBut after this we don\\'t have any immediate insight in how to replace the heaviest loop in the program. In the naive simulation approach we do something like\\n\\n```Java\\nwhile (mem1 >= time || mem2 >= time) {\\n    if (mem1 >= time && mem1 >= mem2) {\\n        mem1 -= time++;\\n    } else if (mem2 >= time) {\\n        mem2 -= time++;\\n    }\\n}\\n```\\n\\nIf you debug the program at its current state (with the initial diff optimization) you will notice a pattern of execution. Namely, while `mem1 >= time && mem2 >= time` (emphasis on the **&&**) holds, the branch interleaves between the two in each loop. So it picks `mem1` for the $$i, i + 2, i + 4$$ and `mem2` for the $i + 1, i + 3, i + 5$th time (or vice versa). You can semi-confirm this by replacing the `mem1 >= mem2` check with a `turn == 1` or `turn == 0` check, where turn goes from 0 to 1 and back. The program is still accepted (proof enough for me for now).\\n\\nThis is great news. The pattern is fully deterministic. It can be expressed in mathematical terms after some consideration (programming it is a whole other beast though).\\n\\n- Without loss of generality let\\'s assume that $m1 \\\\leq m2$ at this point. \\n  - (Plan) Instead of looping we will attempt to subtract as many odd integers from one of the sticks as we can. We will also subtract as many even integers from the other stick as we can. `time` will advance (Jojo reference?) by the sum of the count of both. And this will be part of the final answer.\\n\\n \\n- Let\\'s also assume that `time` is currently even. If it is not, we can do one iteration by hand and subtract it from the max memory stick. Time will advance and it will be even.\\n\\n- We will now subtract as many even quantities (time, time + 2, time + 4, ..) from the max stick and stop just before it gets negative.\\n- Do the same with odd quantities (time + 1, time + 3, ..) for the min stick.\\n\\n- The final memory quantities in each stick will be our answer.\\n\\n# Complexity\\n- Time complexity: $$O(log(max\\\\{m_1, m_2\\\\}))$$ for 3 `sqrt()` calls\\n\\n- Space complexity: $$O(1)$$ extra space\\n\\n# Code\\n```Java\\nclass Solution {\\n\\n    int time = 1, mem1, mem2;\\n\\n    public int[] memLeak(int _memory1, int _memory2) {\\n\\n        this.mem1 = _memory1;\\n        this.mem2 = _memory2;\\n\\n        // first subtract from the maximum until max - min < time\\n        subFromMaxUntilDiffLessThanTime();\\n        if (time > mem1 && time > mem2) return new int[]{time, mem1, mem2};\\n\\n        // then subtract from each one taking turns each round\\n        int nextTime;\\n        int maxSub, minSub; // will be subtracted from max/min memory respectively\\n\\n        nextTime = maxEvenOrOddICanSubtract(time, Math.max(mem1, mem2));\\n        maxSub = sumEveryOtherNumber(time, time % 2 == 0 ? countEvens(time, nextTime) : countOdds(time, nextTime));\\n\\n        int possibleEndTime = nextTime;\\n\\n        nextTime = maxEvenOrOddICanSubtract(time + 1, Math.min(mem1, mem2));\\n        minSub = sumEveryOtherNumber(time + 1, time % 2 == 0 ? countOdds(time + 1, nextTime) : countEvens(time + 1, nextTime));\\n\\n        time = 1 + Math.max(possibleEndTime, nextTime);\\n\\n        // done\\n        if (mem1 >= mem2) {\\n            mem1 -= maxSub;\\n            mem2 -= minSub;\\n        } else {\\n            mem2 -= maxSub;\\n            mem1 -= minSub;\\n        }\\n\\n        return new int[]{time, mem1, mem2};\\n    }\\n\\n    private void subFromMaxUntilDiffLessThanTime() {\\n        int diff = Math.abs(mem1 - mem2);\\n        if (time <= diff) {\\n            time = findNFast(diff) + 1;\\n            if (mem1 >= mem2) {\\n                mem1 -= (long) time * (time - 1) / 2;\\n            } else {\\n                mem2 -= (long) time * (time - 1) / 2;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Finds the maximum integer n such that 1 + 2 + 3 + ... + n <= k\\n     */\\n    static int findNFast(int k) {\\n        return (int) (Math.sqrt(0.25 + 2L * k) - 0.5);\\n    }\\n\\n\\n    /**\\n     * Returns the max integer n such that: a + (a + 2) + (a + 4) + ... + n <= k\\n     * n always has the same parity as a\\n     */\\n    static int maxEvenOrOddICanSubtract(int a, int k) {\\n        int res = (int) ((Math.sqrt((long) a * (a - 2) + 4L * k + 1)) - 1);\\n        return (res - a % 2) / 2 * 2 + a % 2;\\n    }\\n\\n    /**\\n     * Sums the first count terms of low, low + 2, low + 4...\\n     */\\n    static int sumEveryOtherNumber(int low, int count) {\\n        return count * (count + low - 1);\\n    }\\n\\n    /**\\n     * Counts the number of odd integers in the range [low, high]\\n     * (Solution to 1523. Count Odd Numbers in an Interval Range)\\n     */\\n    static int countOdds(int low, int high) {\\n        return (high + 1) / 2 - low / 2;\\n    }\\n\\n    /**\\n     * Counts the number of even integers in the range [low, high]\\n     */\\n    static int countEvens(int low, int high) {\\n        return countOdds(low + 1, high + 1);\\n    }\\n}\\n```\\n\\n#  Formulas\\n\\n- $$\\\\sum_1^ni = \\\\frac{n(n+1)}{2}\\\\ \\\\ \\\\ \\\\ (2)$$ Sum of first $n$ integers\\n\\n- $$n = \\\\lfloor \\\\frac{\\\\sqrt{8k + 1} - 1}{2} \\\\rfloor$$ max $n$ such that $(2)$ $\\\\leq k$ (positive solution to $(2) = k$ solving for $n$)\\n\\n- $$a \\\\equiv n \\\\pmod 2,\\\\,  \\\\sum_{i = a,\\\\,i\\\\equiv a \\\\pmod 2}^n (i) = \\\\frac{(n -a + 2)(n + a)}{4}\\\\ \\\\ \\\\ \\\\ (4)$$ sum of $a, a+2, .., n$ where $a$ and $n$ have the same parity\\n\\n- $$n = \\\\lfloor \\\\sqrt{a^2 - 2a + 4k + 1}\\\\rfloor - 1$$ is the max $n$ such that $a + (a + 2) + ... + n \\\\leq k$.\\n  - This is derived in a similar manner to the other maximum $n$ that we got for solving $(2) = k$. \\n  - In the code this n is decremented by `1` to enforce the $a \\\\equiv n \\\\pmod 2$ rule only in the case that $a$ is odd and $n$ comes out even. This decrementing does not affect our result since we are supposed to sum odds only (because $a$ is odd). Therefore the trailing even (previous value of $n$) should be ignored anyway. \\n   \\n- $$ s + (s+2) + (s+4) + .. + (s + 2(c - 1)) = c\\\\,(c + s - 1) $$ sum of $c$ terms of an aritmetic progression starting at $s$ with difference $d = 2$",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Simulation"
                ],
                "code": "```Java\\nwhile (mem1 >= time || mem2 >= time) {\\n    if (mem1 >= time && mem1 >= mem2) {\\n        mem1 -= time++;\\n    } else if (mem2 >= time) {\\n        mem2 -= time++;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n\\n    int time = 1, mem1, mem2;\\n\\n    public int[] memLeak(int _memory1, int _memory2) {\\n\\n        this.mem1 = _memory1;\\n        this.mem2 = _memory2;\\n\\n        // first subtract from the maximum until max - min < time\\n        subFromMaxUntilDiffLessThanTime();\\n        if (time > mem1 && time > mem2) return new int[]{time, mem1, mem2};\\n\\n        // then subtract from each one taking turns each round\\n        int nextTime;\\n        int maxSub, minSub; // will be subtracted from max/min memory respectively\\n\\n        nextTime = maxEvenOrOddICanSubtract(time, Math.max(mem1, mem2));\\n        maxSub = sumEveryOtherNumber(time, time % 2 == 0 ? countEvens(time, nextTime) : countOdds(time, nextTime));\\n\\n        int possibleEndTime = nextTime;\\n\\n        nextTime = maxEvenOrOddICanSubtract(time + 1, Math.min(mem1, mem2));\\n        minSub = sumEveryOtherNumber(time + 1, time % 2 == 0 ? countOdds(time + 1, nextTime) : countEvens(time + 1, nextTime));\\n\\n        time = 1 + Math.max(possibleEndTime, nextTime);\\n\\n        // done\\n        if (mem1 >= mem2) {\\n            mem1 -= maxSub;\\n            mem2 -= minSub;\\n        } else {\\n            mem2 -= maxSub;\\n            mem1 -= minSub;\\n        }\\n\\n        return new int[]{time, mem1, mem2};\\n    }\\n\\n    private void subFromMaxUntilDiffLessThanTime() {\\n        int diff = Math.abs(mem1 - mem2);\\n        if (time <= diff) {\\n            time = findNFast(diff) + 1;\\n            if (mem1 >= mem2) {\\n                mem1 -= (long) time * (time - 1) / 2;\\n            } else {\\n                mem2 -= (long) time * (time - 1) / 2;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Finds the maximum integer n such that 1 + 2 + 3 + ... + n <= k\\n     */\\n    static int findNFast(int k) {\\n        return (int) (Math.sqrt(0.25 + 2L * k) - 0.5);\\n    }\\n\\n\\n    /**\\n     * Returns the max integer n such that: a + (a + 2) + (a + 4) + ... + n <= k\\n     * n always has the same parity as a\\n     */\\n    static int maxEvenOrOddICanSubtract(int a, int k) {\\n        int res = (int) ((Math.sqrt((long) a * (a - 2) + 4L * k + 1)) - 1);\\n        return (res - a % 2) / 2 * 2 + a % 2;\\n    }\\n\\n    /**\\n     * Sums the first count terms of low, low + 2, low + 4...\\n     */\\n    static int sumEveryOtherNumber(int low, int count) {\\n        return count * (count + low - 1);\\n    }\\n\\n    /**\\n     * Counts the number of odd integers in the range [low, high]\\n     * (Solution to 1523. Count Odd Numbers in an Interval Range)\\n     */\\n    static int countOdds(int low, int high) {\\n        return (high + 1) / 2 - low / 2;\\n    }\\n\\n    /**\\n     * Counts the number of even integers in the range [low, high]\\n     */\\n    static int countEvens(int low, int high) {\\n        return countOdds(low + 1, high + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221348,
                "title": "simulation-approach",
                "content": "To summarize, simulate the memory leak and return state when crash would occur.\\n\\n```\\n\\nvector<int> memLeak(int memory1, int memory2) {\\n\\n        for (int time = 1;;++time) {        \\n            auto& largest = memory1 >= memory2 ? memory1 : memory2;\\n            if (time > largest) {\\n                return {time, memory1, memory2};\\n            } else {\\n                largest -= time;\\n            }\\n        }\\n        return {};\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "To summarize, simulate the memory leak and return state when crash would occur.\\n\\n```\\n\\nvector<int> memLeak(int memory1, int memory2) {\\n\\n        for (int time = 1;;++time) {        \\n            auto& largest = memory1 >= memory2 ? memory1 : memory2;\\n            if (time > largest) {\\n                return {time, memory1, memory2};\\n            } else {\\n                largest -= time;\\n            }\\n        }\\n        return {};\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1210525,
                "title": "simple-6-lines-c-solution",
                "content": "```\\nvector<int> memLeak(int m1, int m2) {\\n\\tint time = 1;\\n\\twhile (time <= max(m1, m2)) {\\n\\t\\t(m1 >= m2) ? m1 -= time : m2 -= time;\\n\\t\\ttime++;\\n\\t}\\n\\treturn {time, m1, m2};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> memLeak(int m1, int m2) {\\n\\tint time = 1;\\n\\twhile (time <= max(m1, m2)) {\\n\\t\\t(m1 >= m2) ? m1 -= time : m2 -= time;\\n\\t\\ttime++;\\n\\t}\\n\\treturn {time, m1, m2};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915062,
                "title": "this-is-a-simple-thinking-approach-but-increase-my-confidence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int space=1;\\n        vector<int>ans;\\n        while(m1>=space||m2>=space){\\n            if(m1>=m2&&m1>=space){\\n                m1=m1-space;\\n                space++;\\n            }\\n            else{\\n              if(m2>=space){\\n                  m2=m2-space;\\n                  space++;\\n              }\\n            }\\n        }\\n        ans.push_back(space);\\n        ans.push_back(m1);\\n        ans.push_back(m2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int space=1;\\n        vector<int>ans;\\n        while(m1>=space||m2>=space){\\n            if(m1>=m2&&m1>=space){\\n                m1=m1-space;\\n                space++;\\n            }\\n            else{\\n              if(m2>=space){\\n                  m2=m2-space;\\n                  space++;\\n              }\\n            }\\n        }\\n        ans.push_back(space);\\n        ans.push_back(m1);\\n        ans.push_back(m2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800716,
                "title": "javascript-1860-incremental-memory-leak",
                "content": "\\n- 1 - with comments\\n- 2 - without comments\\n- 3 - for loop\\n- 4 - short - 3 conditions checks each time - not optimal\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - with comments\\n```\\nvar memLeak = function (availableMemoryBits1, availableMemoryBits2) {\\n  // after i seconds\\n  //    i bits are taken\\n  //    from  the bigger of the  availableMemoryBits\\n  let i = 1\\n  while (1) {\\n    // i bits are taken from  the bigger of the  availableMemoryBits\\n    if (availableMemoryBits1 >= availableMemoryBits2) {\\n      if (availableMemoryBits1 < i) break //  not enough bits   to take\\n      availableMemoryBits1 -= i; //           take it\\n    } else {\\n      if (availableMemoryBits2 < i) break //  not enough bits   to take\\n      availableMemoryBits2 -= i; //           take it\\n    }\\n    i++\\n  }\\n  return [i, availableMemoryBits1, availableMemoryBits2];\\n};\\n```\\n\\n2 - without comments\\n```\\nvar memLeak = function (bits1, bits2) {\\n  let i = 1\\n  while (1) {\\n    if (bits1 >= bits2) {\\n      if (bits1 < i) break\\n      bits1 -= i;\\n    } else {\\n      if (bits2 < i) break\\n      bits2 -= i;\\n    }\\n    i++\\n  }\\n  return [i, bits1, bits2];\\n};\\n```\\n\\n3 - for loop\\n```\\nvar memLeak = function (b1, b2) {\\n  let i\\n  for (i = 1; ; i++) {\\n    if (b1 >= b2) {\\n      if (b1 < i) break\\n      b1 -= i;\\n    } else {\\n      if (b2 < i) break\\n      b2 -= i;\\n    }\\n  }\\n  return [i, b1, b2];\\n};\\n```\\n\\n4 - short - 3 conditions checks each time, not optimal\\n```\\nvar memLeak = function (b1, b2) {\\n  for (let i = 1; ; i++) {\\n    if (i > b1 && i > b2)\\n      return [i, b1, b2];\\n\\n    if (b1 >= b2)\\n      b1 -= i;\\n    else\\n      b2 -= i;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar memLeak = function (availableMemoryBits1, availableMemoryBits2) {\\n  // after i seconds\\n  //    i bits are taken\\n  //    from  the bigger of the  availableMemoryBits\\n  let i = 1\\n  while (1) {\\n    // i bits are taken from  the bigger of the  availableMemoryBits\\n    if (availableMemoryBits1 >= availableMemoryBits2) {\\n      if (availableMemoryBits1 < i) break //  not enough bits   to take\\n      availableMemoryBits1 -= i; //           take it\\n    } else {\\n      if (availableMemoryBits2 < i) break //  not enough bits   to take\\n      availableMemoryBits2 -= i; //           take it\\n    }\\n    i++\\n  }\\n  return [i, availableMemoryBits1, availableMemoryBits2];\\n};\\n```\n```\\nvar memLeak = function (bits1, bits2) {\\n  let i = 1\\n  while (1) {\\n    if (bits1 >= bits2) {\\n      if (bits1 < i) break\\n      bits1 -= i;\\n    } else {\\n      if (bits2 < i) break\\n      bits2 -= i;\\n    }\\n    i++\\n  }\\n  return [i, bits1, bits2];\\n};\\n```\n```\\nvar memLeak = function (b1, b2) {\\n  let i\\n  for (i = 1; ; i++) {\\n    if (b1 >= b2) {\\n      if (b1 < i) break\\n      b1 -= i;\\n    } else {\\n      if (b2 < i) break\\n      b2 -= i;\\n    }\\n  }\\n  return [i, b1, b2];\\n};\\n```\n```\\nvar memLeak = function (b1, b2) {\\n  for (let i = 1; ; i++) {\\n    if (i > b1 && i > b2)\\n      return [i, b1, b2];\\n\\n    if (b1 >= b2)\\n      b1 -= i;\\n    else\\n      b2 -= i;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2970540,
                "title": "cpp-simulation-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int val1, int val2) {\\n        \\n        int second = 1;\\n\\n        while(true)\\n        {\\n            if(val1 == val2 and (val1 >= second))\\n            {\\n                val1 = val1 - second;\\n                second++;\\n            }\\n            else if(val1 > val2 and (val1 >= second))\\n            {\\n                val1 = val1 - second;\\n                second++;\\n            }\\n            else if(val2 > val1 and (val2 >= second))\\n            {\\n                  val2 = val2 - second;\\n                  second++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return {second,val1,val2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int val1, int val2) {\\n        \\n        int second = 1;\\n\\n        while(true)\\n        {\\n            if(val1 == val2 and (val1 >= second))\\n            {\\n                val1 = val1 - second;\\n                second++;\\n            }\\n            else if(val1 > val2 and (val1 >= second))\\n            {\\n                val1 = val1 - second;\\n                second++;\\n            }\\n            else if(val2 > val1 and (val2 >= second))\\n            {\\n                  val2 = val2 - second;\\n                  second++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return {second,val1,val2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673008,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int count = 1;\\n        while (memory1 - count >= 0 || memory2 - count >= 0) {\\n            int diff1 = memory1 - count, diff2 = memory2 - count;\\n            if (memory1 - count >= 0 && memory2 - count >= 0) {\\n                if (diff2 > diff1) {\\n                    memory2 -= count;\\n                    count++;\\n                    continue;\\n                } else {\\n                    memory1 -= count;\\n                    count++;\\n                    continue;\\n                }\\n            }\\n            if (memory1 - count >= 0) {\\n                memory1 -= count;\\n                count++;\\n            } if (memory2 - count >= 0) {\\n                memory2 -= count;\\n                count++;\\n            }\\n        }\\n        return new int[]{count, memory1, memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int count = 1;\\n        while (memory1 - count >= 0 || memory2 - count >= 0) {\\n            int diff1 = memory1 - count, diff2 = memory2 - count;\\n            if (memory1 - count >= 0 && memory2 - count >= 0) {\\n                if (diff2 > diff1) {\\n                    memory2 -= count;\\n                    count++;\\n                    continue;\\n                } else {\\n                    memory1 -= count;\\n                    count++;\\n                    continue;\\n                }\\n            }\\n            if (memory1 - count >= 0) {\\n                memory1 -= count;\\n                count++;\\n            } if (memory2 - count >= 0) {\\n                memory2 -= count;\\n                count++;\\n            }\\n        }\\n        return new int[]{count, memory1, memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374802,
                "title": "76-faster-easy-to-understand-tc-o-n-m-space-o-1-constant-space",
                "content": "```\\nM_N = 1 //M_N stands for memory_needed\\nwhile M_N <= memory1 or M_N <= memory2: \\n\\tif memory1 >= memory2: //if memory1 >= memory2 => reduce for memory1\\n\\t\\tmemory1 -= M_N\\n\\telif memory1 < memory2:\\n\\t\\tmemory2 -= M_N\\n\\tM_N += 1\\nreturn [M_N,memory1,memory2]\\n```\\nThank You:)\\nif Helpful pease upvote :)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nM_N = 1 //M_N stands for memory_needed\\nwhile M_N <= memory1 or M_N <= memory2: \\n\\tif memory1 >= memory2: //if memory1 >= memory2 => reduce for memory1\\n\\t\\tmemory1 -= M_N\\n\\telif memory1 < memory2:\\n\\t\\tmemory2 -= M_N\\n\\tM_N += 1\\nreturn [M_N,memory1,memory2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124157,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        int c=1;\\n        while(max(memory1,memory2)>=i)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=i;\\n            }\\n            else\\n            {\\n                memory2-=i;\\n            }\\n            c++;\\n            i++;\\n        }\\n        return {c,memory1,memory2};\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        int c=1;\\n        while(max(memory1,memory2)>=i)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=i;\\n            }\\n            else\\n            {\\n                memory2-=i;\\n            }\\n            c++;\\n            i++;\\n        }\\n        return {c,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030031,
                "title": "javascrip-easiest-approach",
                "content": "```\\nvar memLeak = function(memory1, memory2) {\\n    var count=1;\\n    while(true)\\n        {\\n            if(memory1>=memory2 && memory1>=count)\\n                memory1-=count;\\n            else if(memory2>=memory1 && memory2>=count)\\n                memory2-=count\\n            else\\n                return [count, memory1, memory2];\\n            count++;\\n        }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar memLeak = function(memory1, memory2) {\\n    var count=1;\\n    while(true)\\n        {\\n            if(memory1>=memory2 && memory1>=count)\\n                memory1-=count;\\n            else if(memory2>=memory1 && memory2>=count)\\n                memory2-=count\\n            else\\n                return [count, memory1, memory2];\\n            count++;\\n        }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707889,
                "title": "python-3-why-is-my-solution-so-easy-is-it-wrong",
                "content": "It\\'s accepted but why is it so much simpler than the most voted solution? Did I interpret the question wrong?\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        time = 1\\n        while time <= max(memory1,memory2):\\n            if memory2>memory1:\\n                memory2 -= time\\n            else:\\n                memory1 -= time\\n            time+= 1\\n        return [time,memory1,memory2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        time = 1\\n        while time <= max(memory1,memory2):\\n            if memory2>memory1:\\n                memory2 -= time\\n            else:\\n                memory1 -= time\\n            time+= 1\\n        return [time,memory1,memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358081,
                "title": "simulate-the-process-91-speed",
                "content": "Runtime: 256 ms, faster than 91.43%\\nMemory Usage: 14.2 MB, less than 76.10%\\n\\nSubtract the second from the stich with largest memory stick.\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        for sec in range(1, memory1 + memory2 + 2):\\n            if memory1 >= memory2:\\n                if sec <= memory1:\\n                    memory1 -= sec\\n                else:\\n                    return [sec, memory1, memory2]\\n            else:\\n                if sec <= memory2:\\n                    memory2 -= sec\\n                else:\\n                    return [sec, memory1, memory2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        for sec in range(1, memory1 + memory2 + 2):\\n            if memory1 >= memory2:\\n                if sec <= memory1:\\n                    memory1 -= sec\\n                else:\\n                    return [sec, memory1, memory2]\\n            else:\\n                if sec <= memory2:\\n                    memory2 -= sec\\n                else:\\n                    return [sec, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312562,
                "title": "golang-simulation-solution",
                "content": "```go\\nfunc memLeak(memory1 int, memory2 int) []int {\\n\\tfor i := 1;; i++ {\\n\\t\\tif memory1 >= memory2 {\\n\\t\\t\\tif memory1 < i {\\n\\t\\t\\t\\treturn []int{i, memory1, memory2}\\n\\t\\t\\t}\\n\\t\\t\\tmemory1 -= i\\n\\t\\t} else {\\n\\t\\t\\tif memory2 < i {\\n\\t\\t\\t\\treturn []int{i, memory1, memory2}\\n\\t\\t\\t}\\n\\t\\t\\tmemory2 -= i\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc memLeak(memory1 int, memory2 int) []int {\\n\\tfor i := 1;; i++ {\\n\\t\\tif memory1 >= memory2 {\\n\\t\\t\\tif memory1 < i {\\n\\t\\t\\t\\treturn []int{i, memory1, memory2}\\n\\t\\t\\t}\\n\\t\\t\\tmemory1 -= i\\n\\t\\t} else {\\n\\t\\t\\tif memory2 < i {\\n\\t\\t\\t\\treturn []int{i, memory1, memory2}\\n\\t\\t\\t}\\n\\t\\t\\tmemory2 -= i\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266112,
                "title": "those-who-thought-brute-force-wont-work",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(long long int m1, long long int m2) {\\n       long long int tot = m1 + m2 ;\\n        tot*=2;\\n      // N(N+1)/2 CONCEPT  \\n        long long int t = sqrt(tot);\\n       long long  int p = t ;\\n        tot -= t ;\\n      \\n      \\n        t = sqrt(tot);\\n \\n        long long int y = 0 ;\\n        for(long long int  i = 1 ; i<= t ; i++)\\n        {\\n            if(m1 == m2 && m1 >=i && m2 >= i)\\n            {    y++;\\n                m1-=i; continue;\\n            }\\n            if(m1 < m2 && i <= m2)\\n            {y++;\\n                m2 -= i; continue;\\n            }\\n            if(m2 < m1 && i <= m1)\\n            {y++;\\n                m1-= i ;\\n                continue;\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(y+1);\\n        ans.push_back(m1);\\n        ans.push_back(m2);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> memLeak(long long int m1, long long int m2) {\\n       long long int tot = m1 + m2 ;\\n        tot*=2;\\n      // N(N+1)/2 CONCEPT  \\n        long long int t = sqrt(tot);\\n       long long  int p = t ;\\n        tot -= t ;\\n      \\n      \\n        t = sqrt(tot);\\n \\n        long long int y = 0 ;\\n        for(long long int  i = 1 ; i<= t ; i++)\\n        {\\n            if(m1 == m2 && m1 >=i && m2 >= i)\\n            {    y++;\\n                m1-=i; continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1234954,
                "title": "c-brute-forse-solution-simulation",
                "content": "```\\n// Runtime: 4 ms, faster than 92.99% of C++ online submissions for Incremental Memory Leak.\\n// Memory Usage: 5.9 MB, less than 91.60% of C++ online submissions for Incremental Memory Leak.\\nvector<int> memLeak(int memory1, int memory2) {\\n\\tint i = 1;\\n\\twhile (memory1 || memory2) {\\n\\t\\tif (memory1 >= memory2) {\\n\\t\\t\\tif (memory1 >= i)\\n\\t\\t\\t\\tmemory1 -= i;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (memory2 >= i)\\n\\t\\t\\t\\tmemory2 -= i;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn { i, memory1, memory2 };\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 92.99% of C++ online submissions for Incremental Memory Leak.\\n// Memory Usage: 5.9 MB, less than 91.60% of C++ online submissions for Incremental Memory Leak.\\nvector<int> memLeak(int memory1, int memory2) {\\n\\tint i = 1;\\n\\twhile (memory1 || memory2) {\\n\\t\\tif (memory1 >= memory2) {\\n\\t\\t\\tif (memory1 >= i)\\n\\t\\t\\t\\tmemory1 -= i;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif (memory2 >= i)\\n\\t\\t\\t\\tmemory2 -= i;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti++;\\n\\t}\\n\\treturn { i, memory1, memory2 };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220152,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int count=1;\\n        while(memory1>=count||memory2>=count)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=count;\\n            }\\n            else {\\n                memory2-=count;\\n            }\\n            count++;\\n        }\\n        return {count,memory1,memory2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int count=1;\\n        while(memory1>=count||memory2>=count)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=count;\\n            }\\n            else {\\n                memory2-=count;\\n            }\\n            count++;\\n        }\\n        return {count,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215510,
                "title": "c-short-and-crispy-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i;\\n\\t\\t\\n        while(1){\\n            if(i>m1 && i>m2)break;\\n            if(m1>=m2){\\n                m1-=i;\\n                i++;\\n            }\\n            else{\\n                m2-=i;\\n                i++;\\n            }\\n        }\\n        \\n        return {i,m1,m2};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i;\\n\\t\\t\\n        while(1){\\n            if(i>m1 && i>m2)break;\\n            if(m1>=m2){\\n                m1-=i;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1212815,
                "title": "java-with-pq",
                "content": "I could see a follow up on how to handle n memory sticks. \\n\\n```java\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            if(a[0] == b[0]) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n            return Integer.compare(b[0], a[0]);\\n        });\\n        pq.offer(new int[]{memory1, 0});\\n        pq.offer(new int[]{memory2, 1});\\n        int i = 1;\\n        while(pq.peek()[0] >= i) {\\n            int[] mem = pq.poll();\\n            mem[0] -= i++;\\n            pq.offer(mem);\\n        }\\n        res[0] = i;\\n        while(!pq.isEmpty()) {\\n            int[] mem = pq.poll();\\n            res[mem[1] + 1] = mem[0];\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```java\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            if(a[0] == b[0]) {\\n                return Integer.compare(a[1], b[1]);\\n            }\\n            return Integer.compare(b[0], a[0]);\\n        });\\n        pq.offer(new int[]{memory1, 0});\\n        pq.offer(new int[]{memory2, 1});\\n        int i = 1;\\n        while(pq.peek()[0] >= i) {\\n            int[] mem = pq.poll();\\n            mem[0] -= i++;\\n            pq.offer(mem);\\n        }\\n        res[0] = i;\\n        while(!pq.isEmpty()) {\\n            int[] mem = pq.poll();\\n            res[mem[1] + 1] = mem[0];\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1211600,
                "title": "c-solution-with-binary-search-and-arithmetic-progression",
                "content": "See the comments in the code.\\n            \\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        To find the sum of \\'n\\' terms of AP with \\'a\\' as first term and \\'d\\' as difference\\n    */\\n    long long int sumAP(long long int n, long long int a, long long int d){\\n        long long int val = ( (n)*( (2*a) + ((n-1)*d) ) )/2;\\n        return val;\\n    }\\n    \\n    \\n    /*\\n        Search <= value\\n        and return \\'n\\' according to \\'a\\' and \\'d\\'\\n    */\\n    long long int binarySearch(long long int sum, long long int a, long long int d){\\n        long long int s = 0;\\n        long long int e = 65536;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int mid = s+(e-s)/2;\\n            long long int val = sumAP(mid,a,d);\\n            if( val <= sum ){\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    vector<int> memLeak(int memory1, int memory2) {\\n        // find difference between two\\n        long long int diff = max(memory1, memory2) - min(memory1, memory2);\\n        \\n        /*\\n            Untill One is bigger than other, every times that one will get reduced\\n            So we will go from 1,2,3... so on till that difference is reached\\n            Ex- In case of 8 and 11\\n            difference is 3 which can be achieved in 2 steps (1+2)\\n            so, binary search will return 2.\\n        \\n        */\\n        \\n        long long int ans = binarySearch(diff,1,1);\\n        long long int ans2,ans3;\\n        \\n        /*  \\n            Subtract the extra part from bigger one\\n            Ex- In case of 8 and 11\\n            both become 8\\n        */\\n        long long int pip = sumAP(ans,1,1);\\n        if(memory1>memory2){\\n            memory1 = memory1 - pip;\\n        }\\n        else if(memory2>memory1){\\n            memory2 = memory2 - pip;   \\n        }\\n        \\n        /* \\n            Now since both are almost same and the difference(if any) between \\n            them is smaller than next step reduction. So it is guarantee that \\n            now strict alternation will take place.\\n            Ex- In case of 8 and 11\\n            3rd step will remove 3 from first one and left (5,8)\\n            4th step will remove 4 from second one and left (5,4)\\n            and so on\\n            \\n            This means the amount we need to subtract will be \\n            a sum of AP with difference 2\\n        */\\n        long long int a;\\n        if(memory1>=memory2){\\n            ans2 = binarySearch(memory1,ans+1,2);\\n            ans3 = binarySearch(memory2,ans+2,2);\\n            \\n            pip = sumAP(ans2,ans+1,2);\\n            memory1 = memory1 - pip;\\n            \\n            pip = sumAP(ans3,ans+2,2); \\n            memory2 = memory2 - pip;\\n            \\n            // Calculating the last step that we can apply over the memory\\n            ans2 = ans+1 + (ans2-1)*2;  // nth_term = a + (n-1)*d\\n            ans3 = ans+2 + (ans3-1)*2;\\n            \\n            \\n        }\\n        else{\\n            ans3 = binarySearch(memory2,ans+1,2);\\n            ans2 = binarySearch(memory1,ans+2,2); \\n            \\n            pip = sumAP(ans2,ans+2,2);\\n            memory1 = memory1 - pip;\\n            \\n            pip = sumAP(ans3,ans+1,2);\\n            memory2 = memory2 - pip;\\n            \\n            ans2 = ans+2 + (ans2-1)*2;  // nth_term = a + (n-1)*d\\n            ans3 = ans+1 + (ans3-1)*2;\\n        }\\n        \\n        \\n        // find max of both steps\\n        long long int maxi = max(ans2,ans3);\\n        \\n        vector<int> answer;\\n        answer.push_back(maxi+1);\\n        answer.push_back(memory1);\\n        answer.push_back(memory2);\\n        \\n        return answer;    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        To find the sum of \\'n\\' terms of AP with \\'a\\' as first term and \\'d\\' as difference\\n    */\\n    long long int sumAP(long long int n, long long int a, long long int d){\\n        long long int val = ( (n)*( (2*a) + ((n-1)*d) ) )/2;\\n        return val;\\n    }\\n    \\n    \\n    /*\\n        Search <= value\\n        and return \\'n\\' according to \\'a\\' and \\'d\\'\\n    */\\n    long long int binarySearch(long long int sum, long long int a, long long int d){\\n        long long int s = 0;\\n        long long int e = 65536;\\n        long long int ans = -1;\\n        while(s<=e){\\n            long long int mid = s+(e-s)/2;\\n            long long int val = sumAP(mid,a,d);\\n            if( val <= sum ){\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    vector<int> memLeak(int memory1, int memory2) {\\n        // find difference between two\\n        long long int diff = max(memory1, memory2) - min(memory1, memory2);\\n        \\n        /*\\n            Untill One is bigger than other, every times that one will get reduced\\n            So we will go from 1,2,3... so on till that difference is reached\\n            Ex- In case of 8 and 11\\n            difference is 3 which can be achieved in 2 steps (1+2)\\n            so, binary search will return 2.\\n        \\n        */\\n        \\n        long long int ans = binarySearch(diff,1,1);\\n        long long int ans2,ans3;\\n        \\n        /*  \\n            Subtract the extra part from bigger one\\n            Ex- In case of 8 and 11\\n            both become 8\\n        */\\n        long long int pip = sumAP(ans,1,1);\\n        if(memory1>memory2){\\n            memory1 = memory1 - pip;\\n        }\\n        else if(memory2>memory1){\\n            memory2 = memory2 - pip;   \\n        }\\n        \\n        /* \\n            Now since both are almost same and the difference(if any) between \\n            them is smaller than next step reduction. So it is guarantee that \\n            now strict alternation will take place.\\n            Ex- In case of 8 and 11\\n            3rd step will remove 3 from first one and left (5,8)\\n            4th step will remove 4 from second one and left (5,4)\\n            and so on\\n            \\n            This means the amount we need to subtract will be \\n            a sum of AP with difference 2\\n        */\\n        long long int a;\\n        if(memory1>=memory2){\\n            ans2 = binarySearch(memory1,ans+1,2);\\n            ans3 = binarySearch(memory2,ans+2,2);\\n            \\n            pip = sumAP(ans2,ans+1,2);\\n            memory1 = memory1 - pip;\\n            \\n            pip = sumAP(ans3,ans+2,2); \\n            memory2 = memory2 - pip;\\n            \\n            // Calculating the last step that we can apply over the memory\\n            ans2 = ans+1 + (ans2-1)*2;  // nth_term = a + (n-1)*d\\n            ans3 = ans+2 + (ans3-1)*2;\\n            \\n            \\n        }\\n        else{\\n            ans3 = binarySearch(memory2,ans+1,2);\\n            ans2 = binarySearch(memory1,ans+2,2); \\n            \\n            pip = sumAP(ans2,ans+2,2);\\n            memory1 = memory1 - pip;\\n            \\n            pip = sumAP(ans3,ans+1,2);\\n            memory2 = memory2 - pip;\\n            \\n            ans2 = ans+2 + (ans2-1)*2;  // nth_term = a + (n-1)*d\\n            ans3 = ans+1 + (ans3-1)*2;\\n        }\\n        \\n        \\n        // find max of both steps\\n        long long int maxi = max(ans2,ans3);\\n        \\n        vector<int> answer;\\n        answer.push_back(maxi+1);\\n        answer.push_back(memory1);\\n        answer.push_back(memory2);\\n        \\n        return answer;    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210711,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int timer = 1;\\n       \\n        while(memory1 or memory2) {\\n            \\n            int mxm = max(memory1, memory2);\\n            int mnm = min(memory1, memory2);\\n            \\n            if(mxm < timer and mnm < timer ) {\\n                break;\\n            }\\n            \\n            if(mxm == memory1) {\\n                memory1 = memory1 - timer;\\n            }\\n            else if(mxm == memory2) {\\n                memory2 = memory2 - timer;                \\n            }\\n            timer++;\\n        }\\n       \\n        return {timer, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int timer = 1;\\n       \\n        while(memory1 or memory2) {\\n            \\n            int mxm = max(memory1, memory2);\\n            int mnm = min(memory1, memory2);\\n            \\n            if(mxm < timer and mnm < timer ) {\\n                break;\\n            }\\n            \\n            if(mxm == memory1) {\\n                memory1 = memory1 - timer;\\n            }\\n            else if(mxm == memory2) {\\n                memory2 = memory2 - timer;                \\n            }\\n            timer++;\\n        }\\n       \\n        return {timer, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210570,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> memLeak(int memory1, int memory2) {\\n\\t\\t\\tint t = 1;\\n\\t\\t\\twhile(t <= max(memory1, memory2)){\\n\\t\\t\\t\\tif(memory1 >= memory2){\\n\\t\\t\\t\\t\\tmemory1 -= t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tmemory2 -= t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t\\treturn {t, memory1, memory2};\\n\\t\\t}\\n\\t};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> memLeak(int memory1, int memory2) {\\n\\t\\t\\tint t = 1;\\n\\t\\t\\twhile(t <= max(memory1, memory2)){\\n\\t\\t\\t\\tif(memory1 >= memory2){\\n\\t\\t\\t\\t\\tmemory1 -= t;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1210357,
                "title": "c-self-explanatory",
                "content": "```\\n vector<int> memLeak(int m1, int m2) {\\n        \\n        int t=1; \\n        \\n        while(1)\\n        {\\n            if(m1>= m2)\\n            {\\n                if(m1-t <0)\\n                    break;   \\n                else\\n                   m1 = m1-t; \\n            }\\n            \\n            else\\n            {\\n                if(m2-t <0)\\n                    break;   \\n                else\\n                   m2 = m2-t; \\n            }\\n            ++t;\\n        }\\n        return {t , m1 , m2};\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n vector<int> memLeak(int m1, int m2) {\\n        \\n        int t=1; \\n        \\n        while(1)\\n        {\\n            if(m1>= m2)\\n            {\\n                if(m1-t <0)\\n                    break;   \\n                else\\n                   m1 = m1-t; \\n            }\\n            \\n            else\\n            {\\n                if(m2-t <0)\\n                    break;   \\n                else\\n                   m2 = m2-t; \\n            }\\n            ++t;\\n        }\\n        return {t , m1 , m2};\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1210278,
                "title": "6-line-simple-java-code",
                "content": "```\\n  public int[] memLeak(int memory1, int memory2) {\\n    int programMemory = 1; // program needs 1 bit initially\\n\\t\\n    while (programMemory <= Math.max(memory1, memory2)) { // break condition\\n      if (memory1 >= memory2) memory1 -= programMemory;\\n      else memory2 -= programMemory;\\n      programMemory++;\\n    }\\n    \\n\\treturn new int[] {programMemory, memory1, memory2};\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int[] memLeak(int memory1, int memory2) {\\n    int programMemory = 1; // program needs 1 bit initially\\n\\t\\n    while (programMemory <= Math.max(memory1, memory2)) { // break condition\\n      if (memory1 >= memory2) memory1 -= programMemory;\\n      else memory2 -= programMemory;\\n      programMemory++;\\n    }\\n    \\n\\treturn new int[] {programMemory, memory1, memory2};\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210257,
                "title": "c-simulation-based-solution-100-faster",
                "content": "```\\ntypedef long long int64;\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int64 total = (int64)memory1 + memory2;\\n        if(total == 0) {\\n            return {1, 0, 0};\\n        }\\n        for(int i = 1; i <= total; i++) {\\n            if(memory1 < memory2) {\\n                if(memory2 < i) {\\n                    return {i, memory1, memory2};\\n                } else {\\n                    memory2 -= i;\\n                }\\n            } else {\\n                if(memory1 < i) {\\n                    return {i, memory1, memory2};\\n                } else {\\n                    memory1 -= i;\\n                }\\n            }\\n            // cout << \"memory1 = \" << memory1 << \" \" << \" memory2 = \" << memory2 << endl;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long int64;\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int64 total = (int64)memory1 + memory2;\\n        if(total == 0) {\\n            return {1, 0, 0};\\n        }\\n        for(int i = 1; i <= total; i++) {\\n            if(memory1 < memory2) {\\n                if(memory2 < i) {\\n                    return {i, memory1, memory2};\\n                } else {\\n                    memory2 -= i;\\n                }\\n            } else {\\n                if(memory1 < i) {\\n                    return {i, memory1, memory2};\\n                } else {\\n                    memory1 -= i;\\n                }\\n            }\\n            // cout << \"memory1 = \" << memory1 << \" \" << \" memory2 = \" << memory2 << endl;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1210237,
                "title": "java-solution-easy-to-understand",
                "content": "# Readable and easy to understand solution.\\n\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int time = 1;        \\n        while(memory1 >= time || memory2 >= time){\\n            if(memory1 >= memory2){\\n                memory1 -= time;\\n            } else {\\n                memory2 -= time;\\n            }\\n            time++;\\n        }\\n\\n        return new int[]{time, memory1, memory2};\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(\\u221Am + \\u221An)\\n**Space Complexity:** O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int time = 1;        \\n        while(memory1 >= time || memory2 >= time){\\n            if(memory1 >= memory2){\\n                memory1 -= time;\\n            } else {\\n                memory2 -= time;\\n            }\\n            time++;\\n        }\\n\\n        return new int[]{time, memory1, memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210218,
                "title": "easy-with-boilerplate",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        int tmp[] = new int[3];\\n        int i=0;\\n        int len;\\n        if(memory1>memory2)\\n            len=memory1;\\n        else\\n            len =memory2;\\n        \\n        for(i =1;i<=len;i++){\\n            if(i<=memory1 || i<=memory2){\\n               if(memory1==memory2)\\n                memory1=memory1-i;\\n                else if(memory1>memory2)\\n                memory1=memory1-i;\\n                else if(memory2>memory1)\\n                memory2=memory2-i;\\n        }\\n            else\\n                break;\\n        }\\n        int j=0;\\n       \\n         tmp[j] = i;\\n        j++;\\n        tmp[j]=memory1;\\n        j++;\\n        tmp[j]=memory2;\\n        \\n        \\n        return tmp;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        int tmp[] = new int[3];\\n        int i=0;\\n        int len;\\n        if(memory1>memory2)\\n            len=memory1;\\n        else\\n            len =memory2;\\n        \\n        for(i =1;i<=len;i++){\\n            if(i<=memory1 || i<=memory2){\\n               if(memory1==memory2)\\n                memory1=memory1-i;\\n                else if(memory1>memory2)\\n                memory1=memory1-i;\\n                else if(memory2>memory1)\\n                memory2=memory2-i;\\n        }\\n            else\\n                break;\\n        }\\n        int j=0;\\n       \\n         tmp[j] = i;\\n        j++;\\n        tmp[j]=memory1;\\n        j++;\\n        tmp[j]=memory2;\\n        \\n        \\n        return tmp;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210193,
                "title": "simple-solution-using-javascript-4-line-only",
                "content": "``` \\nvar memLeak = function(memory1, memory2) {\\n    let i;\\n    for(i = 1; memory1 >= i || memory2 >= i ; i++){    \\n\\t\\tif(memory1 < memory2){\\n\\t\\t\\tmemory2 -= i;\\n\\t\\t} \\n        else memory1 -= i;\\n    }        \\n    return [i,memory1,memory2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar memLeak = function(memory1, memory2) {\\n    let i;\\n    for(i = 1; memory1 >= i || memory2 >= i ; i++){    \\n\\t\\tif(memory1 < memory2){\\n\\t\\t\\tmemory2 -= i;\\n\\t\\t} \\n        else memory1 -= i;\\n    }        \\n    return [i,memory1,memory2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1210125,
                "title": "0ms-fast-o-1-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(long long m1, long long m2) {\\n        long long i = 0;\\n        \\n        if (m2 > m1) {\\n            i = int(((sqrt(8*(m2-m1) + 1.0) - 1)/2));\\n            m2 -= i*(i+1)/2;\\n        }\\n        else if (m1 > m2) {\\n            i = int(((sqrt(8*(m1-m2) + 1.0) - 1)/2));\\n            m1 -= i*(i+1)/2;\\n        }\\n        \\n        i++;\\n        \\n        if (m2 > m1) {\\n            if (m2 < i)\\n                return vector<int>{static_cast<int>(i), static_cast<int>(m1), static_cast<int>(m2)};\\n            m2 -= i;\\n            i++;\\n        }\\n\\n        int i1, i2;\\n        \\n        if (m1 < i)\\n            i1 = i-1;\\n        else\\n        {\\n            // (i+k1)*(k1+1)\\n            // 0 = k1*k1 + (i+1)*k1 + i-m1\\n            \\n            int k1 = int((sqrt((i+1)*(i+1) - 4*(i-m1) + 0.0) - (i+1))/2);\\n            m1 -= (i+k1)*(k1+1);\\n            i1 = i + 2*k1;\\n        }\\n        \\n        if (m2 < i+1)\\n            i2 = i-1;\\n        else\\n        {\\n            // (i+1+k2)*(k2+1)\\n            // 0 = k2*k2 + (i+2)*k2 + (i+1-m2)\\n        \\n            int k2 = int((sqrt((i+2)*(i+2) - 4*(i+1-m2) + 0.0) - (i+2))/2);\\n            m2 -= (i+1+k2)*(k2+1);\\n            i2 = i+1 + 2*k2;\\n        }\\n        \\n        return vector<int>{static_cast<int>(max(i1, i2)+1), static_cast<int>(m1), static_cast<int>(m2)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(long long m1, long long m2) {\\n        long long i = 0;\\n        \\n        if (m2 > m1) {\\n            i = int(((sqrt(8*(m2-m1) + 1.0) - 1)/2));\\n            m2 -= i*(i+1)/2;\\n        }\\n        else if (m1 > m2) {\\n            i = int(((sqrt(8*(m1-m2) + 1.0) - 1)/2));\\n            m1 -= i*(i+1)/2;\\n        }\\n        \\n        i++;\\n        \\n        if (m2 > m1) {\\n            if (m2 < i)\\n                return vector<int>{static_cast<int>(i), static_cast<int>(m1), static_cast<int>(m2)};\\n            m2 -= i;\\n            i++;\\n        }\\n\\n        int i1, i2;\\n        \\n        if (m1 < i)\\n            i1 = i-1;\\n        else\\n        {\\n            // (i+k1)*(k1+1)\\n            // 0 = k1*k1 + (i+1)*k1 + i-m1\\n            \\n            int k1 = int((sqrt((i+1)*(i+1) - 4*(i-m1) + 0.0) - (i+1))/2);\\n            m1 -= (i+k1)*(k1+1);\\n            i1 = i + 2*k1;\\n        }\\n        \\n        if (m2 < i+1)\\n            i2 = i-1;\\n        else\\n        {\\n            // (i+1+k2)*(k2+1)\\n            // 0 = k2*k2 + (i+2)*k2 + (i+1-m2)\\n        \\n            int k2 = int((sqrt((i+2)*(i+2) - 4*(i+1-m2) + 0.0) - (i+2))/2);\\n            m2 -= (i+1+k2)*(k2+1);\\n            i2 = i+1 + 2*k2;\\n        }\\n        \\n        return vector<int>{static_cast<int>(max(i1, i2)+1), static_cast<int>(m1), static_cast<int>(m2)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210072,
                "title": "python-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        counter = 1\\n        while memory1 >= counter or memory2 >= counter:\\n            if memory1 >= memory2:\\n                memory1 -= counter\\n            else:\\n                memory2 -= counter\\n            counter += 1\\n        return [counter, memory1, memory2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        counter = 1\\n        while memory1 >= counter or memory2 >= counter:\\n            if memory1 >= memory2:\\n                memory1 -= counter\\n            else:\\n                memory2 -= counter\\n            counter += 1\\n        return [counter, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210055,
                "title": "java-o-sqrt-n-time-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        \\n        int a[] ={1,m1,m2};\\n        \\n        if(m1==0 && m2==0)\\n        return a;\\n        \\n        int i=1;\\n        while(i<=a[1] || i<=a[2]){\\n            if(a[1]>a[2] || a[1]==a[2] && a[1]>=i)\\n            a[1]-=i;\\n            else if(a[2]>=i)\\n            a[2]-=i;\\n           \\n            i++; \\n        }\\n        a[0]=i;\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        \\n        int a[] ={1,m1,m2};\\n        \\n        if(m1==0 && m2==0)\\n        return a;\\n        \\n        int i=1;\\n        while(i<=a[1] || i<=a[2]){\\n            if(a[1]>a[2] || a[1]==a[2] && a[1]>=i)\\n            a[1]-=i;\\n            else if(a[2]>=i)\\n            a[2]-=i;\\n           \\n            i++; \\n        }\\n        a[0]=i;\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210048,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun memLeak(x: Int, y: Int): IntArray {\\n        var a = x\\n        var b = y\\n        var i = 0\\n        while (i <= a || i <= b)\\n            if (b <= a)  \\n                a -= i++  // prioritize first over second in case of tie\\n            else\\n                b -= i++\\n        return intArrayOf(i, a, b)\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet memLeak = (a, b, i = 1) => {\\n    while (i <= a || i <= b)\\n        if (b <= a)\\n            a -= i++;  // prioritize first over second in case of tie\\n        else\\n            b -= i++;\\n    return [i, a, b];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def memLeak(self, a: int, b: int) -> List[int]:\\n        i = 1\\n        while i <= a or i <= b:\\n            if b <= a:\\n                a -= i   # prioritize first over second in case of tie\\n            else:\\n                b -= i\\n            i += 1\\n        return [i, a, b]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI memLeak(int a, int b, int i = 0) {\\n        while (i <= a || i <= b)\\n            if (b <= a)\\n                a -= i++; // prioritize first over second in case of tie\\n            else\\n                b -= i++;\\n        return {i, a, b};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun memLeak(x: Int, y: Int): IntArray {\\n        var a = x\\n        var b = y\\n        var i = 0\\n        while (i <= a || i <= b)\\n            if (b <= a)  \\n                a -= i++  // prioritize first over second in case of tie\\n            else\\n                b -= i++\\n        return intArrayOf(i, a, b)\\n    }\\n}\\n```\n```\\nlet memLeak = (a, b, i = 1) => {\\n    while (i <= a || i <= b)\\n        if (b <= a)\\n            a -= i++;  // prioritize first over second in case of tie\\n        else\\n            b -= i++;\\n    return [i, a, b];\\n};\\n```\n```\\nclass Solution:\\n    def memLeak(self, a: int, b: int) -> List[int]:\\n        i = 1\\n        while i <= a or i <= b:\\n            if b <= a:\\n                a -= i   # prioritize first over second in case of tie\\n            else:\\n                b -= i\\n            i += 1\\n        return [i, a, b]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI memLeak(int a, int b, int i = 0) {\\n        while (i <= a || i <= b)\\n            if (b <= a)\\n                a -= i++; // prioritize first over second in case of tie\\n            else\\n                b -= i++;\\n        return {i, a, b};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210037,
                "title": "java-5-liner",
                "content": "```\\npublic int[] memLeak(int memory1, int memory2) {\\n\\tint time = 1;\\n\\tfor(;memory1>=time || memory2>=time;time++)\\n\\t\\tif(memory1<memory2) memory2-=time;\\n\\t\\telse memory1-=time;\\n\\treturn new int[]{time, memory1,memory2};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] memLeak(int memory1, int memory2) {\\n\\tint time = 1;\\n\\tfor(;memory1>=time || memory2>=time;time++)\\n\\t\\tif(memory1<memory2) memory2-=time;\\n\\t\\telse memory1-=time;\\n\\treturn new int[]{time, memory1,memory2};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084735,
                "title": "python3-solution-with-using-simulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        memory_in_use, cur_sec = 0,0\\n\\n        while True:\\n            memory_in_use += 1\\n            cur_sec += 1\\n\\n            if memory1 < memory_in_use and memory2 < memory_in_use: break\\n\\n            if memory1 >= memory2: memory1 -= memory_in_use\\n            else: memory2 -= memory_in_use\\n        \\n        return [cur_sec, memory1, memory2]\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        memory_in_use, cur_sec = 0,0\\n\\n        while True:\\n            memory_in_use += 1\\n            cur_sec += 1\\n\\n            if memory1 < memory_in_use and memory2 < memory_in_use: break\\n\\n            if memory1 >= memory2: memory1 -= memory_in_use\\n            else: memory2 -= memory_in_use\\n        \\n        return [cur_sec, memory1, memory2]\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018414,
                "title": "easy-and-optimal-approach-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(i<=memory1 || i<=memory2){\\n            if(memory1>=memory2)\\n            memory1-=i;\\n            else\\n            memory2-=i;\\n            i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(i<=memory1 || i<=memory2){\\n            if(memory1>=memory2)\\n            memory1-=i;\\n            else\\n            memory2-=i;\\n            i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999755,
                "title": "simple-while-loop-implementation-using-python",
                "content": "# Approach\\nSimple While Loop Implementation using Python\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the \\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        crashTime = 1\\n        memoryAllocation = 1\\n        while max(memory1, memory2) >= memoryAllocation:\\n            if memory1 >= memory2:\\n                memory1-=memoryAllocation\\n            else:\\n                memory2-=memoryAllocation\\n            crashTime+=1\\n            memoryAllocation+=1\\n        return [crashTime, memory1, memory2]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        crashTime = 1\\n        memoryAllocation = 1\\n        while max(memory1, memory2) >= memoryAllocation:\\n            if memory1 >= memory2:\\n                memory1-=memoryAllocation\\n            else:\\n                memory2-=memoryAllocation\\n            crashTime+=1\\n            memoryAllocation+=1\\n        return [crashTime, memory1, memory2]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984575,
                "title": "python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        i = 1\\n        while memory1 >= i or memory2 >= i:\\n            if memory1 >= memory2:\\n                memory1 -= i\\n                i+= 1\\n            else:\\n                memory2 -= i\\n                i+= 1\\n            \\n        return [i, memory1, memory2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        i = 1\\n        while memory1 >= i or memory2 >= i:\\n            if memory1 >= memory2:\\n                memory1 -= i\\n                i+= 1\\n            else:\\n                memory2 -= i\\n                i+= 1\\n            \\n        return [i, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974240,
                "title": "c-time-o-sqrt-m-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Simply reduce from the largest stick when the time goes on.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    1 + 2 + ... + s = s(s + 1)/2 ~= s^2 ~= m + n\\n    where s is the number of steps\\n          m and n are the memory for each stick\\n\\n    number of steps = s = sqrt(m + n)\\n \\n- Space complexity:\\n    O(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MemLeak(int memory1, int memory2) {\\n        int time = 0;\\n\\n        while (true)\\n        {\\n            time++;\\n\\n            if (memory2 > memory1)\\n            {\\n                if (memory2 >= time)\\n                {\\n                    memory2 -= time;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if (memory1 >= time)\\n                {\\n                    memory1 -= time;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return new int[] { time, memory1, memory2 };\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MemLeak(int memory1, int memory2) {\\n        int time = 0;\\n\\n        while (true)\\n        {\\n            time++;\\n\\n            if (memory2 > memory1)\\n            {\\n                if (memory2 >= time)\\n                {\\n                    memory2 -= time;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if (memory1 >= time)\\n                {\\n                    memory1 -= time;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return new int[] { time, memory1, memory2 };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941140,
                "title": "js-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n\\n    if (!memory1 && !memory2) return [1, memory1, memory2]\\n    const sticks = { memory1, memory2, crash: false }\\n\\n    function alocMemory(memo) {\\n        const memoryToAloc = sticks.memory1 >= sticks.memory2 ? sticks.memory1 : sticks.memory2\\n        const memoryName = sticks.memory1 >= sticks.memory2 ? \"memory1\" : \"memory2\"\\n        let newMemory = memoryToAloc - memo\\n        newMemory = newMemory < 0 ? (sticks.crash=true, memoryToAloc) : newMemory,\\n        !sticks.crash ? sticks[memoryName] = newMemory : null\\n        return sticks\\n    }\\n\\n    let memoLimit = memory1 + memory2\\n\\n    for (let i=0; i < memoLimit; i++) {\\n        const bit = i\\n        const newStick = alocMemory(bit)\\n        if (newStick.crash) return [i, newStick.memory1, newStick.memory2]\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n\\n    if (!memory1 && !memory2) return [1, memory1, memory2]\\n    const sticks = { memory1, memory2, crash: false }\\n\\n    function alocMemory(memo) {\\n        const memoryToAloc = sticks.memory1 >= sticks.memory2 ? sticks.memory1 : sticks.memory2\\n        const memoryName = sticks.memory1 >= sticks.memory2 ? \"memory1\" : \"memory2\"\\n        let newMemory = memoryToAloc - memo\\n        newMemory = newMemory < 0 ? (sticks.crash=true, memoryToAloc) : newMemory,\\n        !sticks.crash ? sticks[memoryName] = newMemory : null\\n        return sticks\\n    }\\n\\n    let memoLimit = memory1 + memory2\\n\\n    for (let i=0; i < memoLimit; i++) {\\n        const bit = i\\n        const newStick = alocMemory(bit)\\n        if (newStick.crash) return [i, newStick.memory1, newStick.memory2]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933282,
                "title": "c-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MemLeak(int memory1, int memory2) {\\n        int count = 0;\\n            while (true)\\n            {\\n                if (memory1 < memory2)\\n                {\\n                    if (count > memory2)\\n                    {\\n                        return new int[] { count, memory1, memory2 };\\n                    }\\n                    memory2 -= count;\\n                }\\n                else\\n                {\\n                    if (count > memory1)\\n                    {\\n                        return new int[] { count, memory1, memory2 };\\n                    }\\n                    memory1 -= count;\\n                }\\n\\n                count++;\\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MemLeak(int memory1, int memory2) {\\n        int count = 0;\\n            while (true)\\n            {\\n                if (memory1 < memory2)\\n                {\\n                    if (count > memory2)\\n                    {\\n                        return new int[] { count, memory1, memory2 };\\n                    }\\n                    memory2 -= count;\\n                }\\n                else\\n                {\\n                    if (count > memory1)\\n                    {\\n                        return new int[] { count, memory1, memory2 };\\n                    }\\n                    memory1 -= count;\\n                }\\n\\n                count++;\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911711,
                "title": "raju-s-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\nint sec = 0;\\nint *mem;\\nwhile(memory1 >= 0 && memory2 >= 0)\\n{\\n    mem = memory1 >= memory2 ? &memory1 : &memory2;\\n    if((*mem - sec) < 0)\\n        break;\\n    *mem -= sec;\\n    sec++;\\n}\\nint *arr = malloc(3*sizeof(int));\\narr[0] = sec;\\narr[1] = memory1;\\narr[2] = memory2;\\n*returnSize = 3;\\nreturn arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\nint sec = 0;\\nint *mem;\\nwhile(memory1 >= 0 && memory2 >= 0)\\n{\\n    mem = memory1 >= memory2 ? &memory1 : &memory2;\\n    if((*mem - sec) < 0)\\n        break;\\n    *mem -= sec;\\n    sec++;\\n}\\nint *arr = malloc(3*sizeof(int));\\narr[0] = sec;\\narr[1] = memory1;\\narr[2] = memory2;\\n*returnSize = 3;\\nreturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906158,
                "title": "python-c-one-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe could use recursion while simulating memory leak. \\n\\n# Python\\n```\\nclass Solution:\\n    def memLeak(self, a, b, t=1):\\n        return [t,a,b] if max(a,b)<t else self.memLeak(a-t*(a>=b),b-t*(b>a),t+1)\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int a, int b, int t=1) {\\n        return max(a,b)<t ? vector({t,a,b}) : memLeak(a-t*(a>=b),b-t*(b>a),t+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, a, b, t=1):\\n        return [t,a,b] if max(a,b)<t else self.memLeak(a-t*(a>=b),b-t*(b>a),t+1)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int a, int b, int t=1) {\\n        return max(a,b)<t ? vector({t,a,b}) : memLeak(a-t*(a>=b),b-t*(b>a),t+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886351,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int idx = 1;\\n        while(memory1>=0 && memory2>=0 && Math.max(memory1,memory2)>=idx){\\n            if(memory2>memory1){\\n                while(memory2>memory1){\\n                    if(memory2-idx<0) break;\\n                    memory2-=idx;\\n                    idx++;\\n                }\\n            }else{\\n                while(memory1>=memory2){\\n                    if(memory1-idx<0) break;\\n                    memory1-=idx;\\n                    idx++;\\n                }\\n            }\\n        }\\n\\n        int arr[] = {idx,memory1,memory2};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int idx = 1;\\n        while(memory1>=0 && memory2>=0 && Math.max(memory1,memory2)>=idx){\\n            if(memory2>memory1){\\n                while(memory2>memory1){\\n                    if(memory2-idx<0) break;\\n                    memory2-=idx;\\n                    idx++;\\n                }\\n            }else{\\n                while(memory1>=memory2){\\n                    if(memory1-idx<0) break;\\n                    memory1-=idx;\\n                    idx++;\\n                }\\n            }\\n        }\\n\\n        int arr[] = {idx,memory1,memory2};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886346,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int idx = 1;\\n        while(memory1>=0 && memory2>=0 && Math.max(memory1,memory2)>=idx){\\n            if(memory2>memory1){\\n                while(memory2>memory1){\\n                    if(memory2-idx<0) break;\\n                    memory2-=idx;\\n                    idx++;\\n                }\\n            }else{\\n                while(memory1>=memory2){\\n                    if(memory1-idx<0) break;\\n                    memory1-=idx;\\n                    idx++;\\n                }\\n            }\\n        }\\n\\n        int arr[] = {idx,memory1,memory2};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n\\n        int idx = 1;\\n        while(memory1>=0 && memory2>=0 && Math.max(memory1,memory2)>=idx){\\n            if(memory2>memory1){\\n                while(memory2>memory1){\\n                    if(memory2-idx<0) break;\\n                    memory2-=idx;\\n                    idx++;\\n                }\\n            }else{\\n                while(memory1>=memory2){\\n                    if(memory1-idx<0) break;\\n                    memory1-=idx;\\n                    idx++;\\n                }\\n            }\\n        }\\n\\n        int arr[] = {idx,memory1,memory2};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881637,
                "title": "solution-using-while-loop-only-8-lines",
                "content": "# Intuition\\nWe need to subtract i from the stick which has more memory left and continue this process until there is no memory left in either of the sticks.\\n\\n# Approach\\ninitialise i=1 which denotes the seconds and create a while loop that checks if either memory1 or memory2 has space and if it does subtract that from the memory.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        while max(memory1,memory2)>=i:\\n            if memory1>=memory2:\\n                memory1-=i\\n            else:\\n                memory2-=i\\n            i+=1\\n        return [i,memory1,memory2]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        while max(memory1,memory2)>=i:\\n            if memory1>=memory2:\\n                memory1-=i\\n            else:\\n                memory2-=i\\n            i+=1\\n        return [i,memory1,memory2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869088,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) \\n    {\\n        int val=1;\\n        while(val<=m1 || val<=m2)\\n        {\\n            if (m1<m2) m2-=val;\\n            else m1-=val;\\n            val++;\\n        }\\n        return {val,m1,m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) \\n    {\\n        int val=1;\\n        while(val<=m1 || val<=m2)\\n        {\\n            if (m1<m2) m2-=val;\\n            else m1-=val;\\n            val++;\\n        }\\n        return {val,m1,m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842970,
                "title": "beats-100-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can keep track of the memory required at the ith second and perdorm the operations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSubtract the memory required for virus from memory 1 or memory 2 whichever is greater. if both of the memory cannot feed the virus than the computer will crash\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(sqrt(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(memory1>=i || memory2>=i)\\n        {\\n            if(memory1>=memory2)\\n                memory1-=i;\\n            else\\n                memory2-=i;\\n            i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(memory1>=i || memory2>=i)\\n        {\\n            if(memory1>=memory2)\\n                memory1-=i;\\n            else\\n                memory2-=i;\\n            i++;\\n        }\\n        return {i,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831977,
                "title": "ez-solution-for-beginners-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n  let leakMemo = 1;\\n  let sec = 1;\\n  while(true) {\\n    if(leakMemo > memory1 && leakMemo > memory2) break;\\n    if(memory1 < memory2) {\\n      memory2 -= leakMemo;\\n    } else {\\n      memory1 -= leakMemo;\\n    }\\n    leakMemo++;\\n    sec++;\\n  }\\n\\n  return [sec, memory1, memory2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n  let leakMemo = 1;\\n  let sec = 1;\\n  while(true) {\\n    if(leakMemo > memory1 && leakMemo > memory2) break;\\n    if(memory1 < memory2) {\\n      memory2 -= leakMemo;\\n    } else {\\n      memory1 -= leakMemo;\\n    }\\n    leakMemo++;\\n    sec++;\\n  }\\n\\n  return [sec, memory1, memory2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814711,
                "title": "java-math-o-log-n-beats-100",
                "content": "# Intuition\\nBrute force approach is a direct simulation which takes $\\\\approx O(\\\\sqrt{n})$ time, however by following a math approach we can reduce that to $O(log n)$\\n\\n## Step 1\\n\\nAssuming that one of the memories is larger, then at the start of the simualtion we will keep decreasing it until it becomes equal or less than the other memory. Essentially we will be doing `maxMemory - (1 + 2 + 3 + ... + i)`\\n\\nWe can write this as:\\n1. `minMemory + (1 + 2 + 3 + ... + i) >= maxMemory`\\n2. `(1 + 2 + 3 + ... + i) >= maxMemory - minMemory`\\n3. `(1 + 2 + 3 + ...) >= diff`\\n\\nnote that $(1 + 2 + 3 + ... + i) = \\\\frac{i(i+ 1)}{2}$\\n\\nIt\\'s very easy to show that we can compute the value of i by applying:\\n1. $\\\\frac{i(i+ 1)}{2} \\\\ge diff $\\n2. $i(i+ 1) \\\\ge 2 * diff$\\n3. $i \\\\approx \\\\sqrt{diff * 2}$\\n4. if $i(i + 1) > 2 * diff$, then $i = i - 1$\\n\\n## Step 2\\n\\nNow the simulation continues:\\n1. `maxMemory = maxMemory - i` and `minMemory = minMemory - (i + 1)`\\n2. `maxMemory = maxMemory - (i + 2)` and `minMemory = minMemory - (i + 3)`\\n\\nEssentially we will be doing \\n1. `maxMemory = maxMemory - (i + i + 2 + i + 4 + ...)`\\n2. `minMemory = minMemory - (i + 1 + i + 3 + i + 5 + ...)`\\n\\n### Max Memory\\n\\n1. `maxMemory = maxMemory - (i + i + i + 2 + 4 + 6 + ...)`\\n2. $2 + 4 + 6 + ... + n = n * (n + 1)$\\n3. `maxMemory = maxMemory - (n * i + n * (n + 1))`\\n4. We need to solve $n^2 + (i + 1)n - maxMemory = 0$\\n\\n### Min Memory\\n\\n1. `minMemory = minMemory - (i + i + i + 1 + 3 + 5 + ...)`\\n2. $1 + 3 + 5 + ... + n = n^2$\\n3. `minMemory = minMemory - (n * i + n^2)`\\n4. We need to solve $n^2 + n - minMemory = 0$\\n\\n## Step 3\\n\\nWe solve for both equations and add teh results to i and do one last simulation step!\\n\\n# Approach\\n1. Compute `diff = Math.abs(memory1 - memory2)`\\n2. Solve for $i \\\\approx \\\\sqrt{diff * 2}$\\n3. if $i(i + 1) > 2 * diff$, then $i = i - 1$\\n4. Solve $n_1^2 + (i + 1)n_1 - maxMemory = 0$\\n5. Solve $n_2^2 + n_2 - minmemory = 0$\\n6. $i = i + n_1 + n_2$\\n7. Run simulation for one step.\\n\\n# Complexity\\n- Time complexity: $O(logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long solve(long b, long c) {\\n        return (-b + (long)Math.sqrt(b * b - 4 * c)) / 2;\\n    }\\n\\n    public int[] memLeak(int memory1, int memory2) {\\n        long[] results = new long[]{0, memory1, memory2};\\n\\n        int minIndex = memory1 < memory2 ? 1 : 2;\\n        int maxIndex = memory1 >= memory2 ? 1 : 2;\\n\\n        long i = 1;\\n\\n        /*\\n         * If one of the memories is greater than the other one\\n         * then we subtracting from the maximum until it\\'s less than or equal to the minimum\\n         * max = min + (1 + 2 + 3 + 4 + ...), so we need to solve for (1 + 2 + 3 + 4 + ...)\\n         * max - min = n * (n + 1) / 2\\n         * (max - min) * 2 = n * (n + 1)\\n         * (max - min) * 2 = n^2    (approximately, and our computed n can yield greater result)\\n         * n = (int)sqrt((max - min) * 2)\\n         *\\n         * Note that if n * (n + 1) > (max - min) * 2, then we simply decrement n\\n         * \\n         */\\n        if (memory1 != memory2) {\\n            long diff = results[maxIndex] - results[minIndex];\\n            long n = (int)Math.sqrt(diff * 2);\\n            if (n * (n + 1) / 2 > diff) {\\n                n--;\\n            }\\n\\n            results[maxIndex] = results[maxIndex] - (n * (n + 1) / 2);\\n            i += n;\\n        }\\n\\n        minIndex = results[1] < results[2] ? 1 : 2;\\n        maxIndex = results[1] >= results[2] ? 1 : 2;\\n\\n        results[0] = i;\\n        \\n        /*\\n         * No need to loop\\n         * results[maxIndex] = results[maxIndex] - (i + i + 2 + i + 4 + i + 6) until 0\\n         * (2 + 4 + 6 + 8) = 4 * (5) = (n * (n + 1))\\n         * i * n + (n * (n + 1)) = results[maxIndex]\\n         * Solve n ^ 2 + (i + 1)n - results[maxIndex] = 0\\n         * \\n         * results[minIndex] = results[minIndex] - (i + 1 + i + 3 + i + 5 + i + 7) until 0\\n         * (1 + 3 + 5 + 7) = 4 * 4 = n * n\\n         * i * n + n ^ 2 = results[minIndex]\\n         * Solve n ^ 2 + i * n - results[minIndex] = 0\\n         *\\n         * ax^2 + bx + c = 0\\n         * (-b +- sqrt(b^2 - 4ac)) / 2a\\n         * Since a is 1 for both equations this becomes\\n         * (-b +- sqrt(b^2 - 4c)) / 2\\n         * We only want positive roots so this becomes\\n         * (-b + sqrt(b^2 - 4c)) / 2\\n         */\\n\\n        long nMaxIndex = solve(i + 1, -results[maxIndex]);\\n        long nMinIndex = solve(i, -results[minIndex]);\\n\\n        if ((nMaxIndex * i) + (nMaxIndex * nMaxIndex) > results[minIndex]) {\\n            nMaxIndex--;\\n        }\\n\\n        if ((nMinIndex * (i - 1)) + (nMinIndex * nMinIndex) > results[maxIndex]) {\\n            nMinIndex--;\\n        }\\n\\n        results[minIndex] -= (nMaxIndex * i) + (nMaxIndex * nMaxIndex);\\n        results[maxIndex] -= (nMinIndex * (i - 1)) + (nMinIndex * nMinIndex);\\n        i = i + nMaxIndex + nMinIndex;\\n\\n        if (results[1] >= i || results[2] >= i) {\\n            if (results[1] >= i) {\\n                results[1] -= i;\\n                i++;\\n            }\\n\\n            if (results[2] >= i) {\\n                results[2] -= i;\\n                i++;\\n            }\\n        }\\n\\n        results[0] = i;\\n        return new int[]{(int)results[0], (int)results[1], (int)results[2]};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private long solve(long b, long c) {\\n        return (-b + (long)Math.sqrt(b * b - 4 * c)) / 2;\\n    }\\n\\n    public int[] memLeak(int memory1, int memory2) {\\n        long[] results = new long[]{0, memory1, memory2};\\n\\n        int minIndex = memory1 < memory2 ? 1 : 2;\\n        int maxIndex = memory1 >= memory2 ? 1 : 2;\\n\\n        long i = 1;\\n\\n        /*\\n         * If one of the memories is greater than the other one\\n         * then we subtracting from the maximum until it\\'s less than or equal to the minimum\\n         * max = min + (1 + 2 + 3 + 4 + ...), so we need to solve for (1 + 2 + 3 + 4 + ...)\\n         * max - min = n * (n + 1) / 2\\n         * (max - min) * 2 = n * (n + 1)\\n         * (max - min) * 2 = n^2    (approximately, and our computed n can yield greater result)\\n         * n = (int)sqrt((max - min) * 2)\\n         *\\n         * Note that if n * (n + 1) > (max - min) * 2, then we simply decrement n\\n         * \\n         */\\n        if (memory1 != memory2) {\\n            long diff = results[maxIndex] - results[minIndex];\\n            long n = (int)Math.sqrt(diff * 2);\\n            if (n * (n + 1) / 2 > diff) {\\n                n--;\\n            }\\n\\n            results[maxIndex] = results[maxIndex] - (n * (n + 1) / 2);\\n            i += n;\\n        }\\n\\n        minIndex = results[1] < results[2] ? 1 : 2;\\n        maxIndex = results[1] >= results[2] ? 1 : 2;\\n\\n        results[0] = i;\\n        \\n        /*\\n         * No need to loop\\n         * results[maxIndex] = results[maxIndex] - (i + i + 2 + i + 4 + i + 6) until 0\\n         * (2 + 4 + 6 + 8) = 4 * (5) = (n * (n + 1))\\n         * i * n + (n * (n + 1)) = results[maxIndex]\\n         * Solve n ^ 2 + (i + 1)n - results[maxIndex] = 0\\n         * \\n         * results[minIndex] = results[minIndex] - (i + 1 + i + 3 + i + 5 + i + 7) until 0\\n         * (1 + 3 + 5 + 7) = 4 * 4 = n * n\\n         * i * n + n ^ 2 = results[minIndex]\\n         * Solve n ^ 2 + i * n - results[minIndex] = 0\\n         *\\n         * ax^2 + bx + c = 0\\n         * (-b +- sqrt(b^2 - 4ac)) / 2a\\n         * Since a is 1 for both equations this becomes\\n         * (-b +- sqrt(b^2 - 4c)) / 2\\n         * We only want positive roots so this becomes\\n         * (-b + sqrt(b^2 - 4c)) / 2\\n         */\\n\\n        long nMaxIndex = solve(i + 1, -results[maxIndex]);\\n        long nMinIndex = solve(i, -results[minIndex]);\\n\\n        if ((nMaxIndex * i) + (nMaxIndex * nMaxIndex) > results[minIndex]) {\\n            nMaxIndex--;\\n        }\\n\\n        if ((nMinIndex * (i - 1)) + (nMinIndex * nMinIndex) > results[maxIndex]) {\\n            nMinIndex--;\\n        }\\n\\n        results[minIndex] -= (nMaxIndex * i) + (nMaxIndex * nMaxIndex);\\n        results[maxIndex] -= (nMinIndex * (i - 1)) + (nMinIndex * nMinIndex);\\n        i = i + nMaxIndex + nMinIndex;\\n\\n        if (results[1] >= i || results[2] >= i) {\\n            if (results[1] >= i) {\\n                results[1] -= i;\\n                i++;\\n            }\\n\\n            if (results[2] >= i) {\\n                results[2] -= i;\\n                i++;\\n            }\\n        }\\n\\n        results[0] = i;\\n        return new int[]{(int)results[0], (int)results[1], (int)results[2]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770707,
                "title": "c-simulation-nice-4-lines-solution",
                "content": "# Complexity\\n- Time complexity: $$O(\\\\sqrt{m+n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        for (i = 1; i <= memory1 || i <= memory2; ++i)\\n            max(ref(memory1), ref(memory2)) -= i;\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        for (i = 1; i <= memory1 || i <= memory2; ++i)\\n            max(ref(memory1), ref(memory2)) -= i;\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740021,
                "title": "java-easy-to-understand-readable-code",
                "content": "# Intuition\\nmax memory stick will allocate memory at ith second, if memory is equal, memory1 will come first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo using PriorityQueue to act as maxHeap and using custom comapator to keep memory1 stick on top if memory are equal.\\n\\n# Complexity\\n- Time complexity: O(log(n) * log(2)) log(n) as max memory is decreasing i times every second whicg will require heapify that many times and log(2) as there will be only two nodes\\n\\n- Space complexity:\\nO(1) - constant 2 nodes priorityQueue.\\n\\n# Code\\n```\\nclass MemoryStickComparator implements Comparator<Memory>{\\n    @Override\\n    public int compare(Memory memory1, Memory memory2){\\n        if(memory1.value == memory2.value){\\n            return memory1.name.compareTo(memory2.name);\\n        }\\n        return Integer.compare(memory2.value,memory1.value);\\n    } \\n}\\nclass Memory{\\n    int value;\\n    String name;\\n    public Memory(String name, int value){\\n        this.value = value;\\n        this.name = name;\\n    }\\n}\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        if(memory1 == 0 && memory2 == 0) return new int[]{1,0,0};\\n        Memory memoryObj1 = new Memory(\"memory1\", memory1);\\n        Memory memoryObj2 = new Memory(\"memory2\", memory2);\\n        PriorityQueue<Memory> maxHeap = new PriorityQueue(new MemoryStickComparator());\\n        maxHeap.add(memoryObj1);\\n        maxHeap.add(memoryObj2);\\n        int count = 1;\\n        int[] result = new int[3];\\n        result[0] = -1;\\n        while(!maxHeap.isEmpty()){\\n            Memory memObj = maxHeap.poll();\\n            // System.out.print(memObj.name + \" \" + memObj.value);\\n            // System.out.println();\\n            if(maxHeap.size() < 2 && memObj.value < count){\\n                result[0] = result[0] == -1 ? (memObj.value== 0 ? count+1 : count) : result[0];\\n                if(memObj.name.equals(\"memory1\")){\\n                    result[1] = memObj.value;\\n                }else if(memObj.name.equals(\"memory2\")){\\n                    result[2] = memObj.value;\\n                }\\n            }\\n            memObj.value -= count;\\n            if(memObj.value >= 0 ){\\n                maxHeap.add(memObj);\\n                count++;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MemoryStickComparator implements Comparator<Memory>{\\n    @Override\\n    public int compare(Memory memory1, Memory memory2){\\n        if(memory1.value == memory2.value){\\n            return memory1.name.compareTo(memory2.name);\\n        }\\n        return Integer.compare(memory2.value,memory1.value);\\n    } \\n}\\nclass Memory{\\n    int value;\\n    String name;\\n    public Memory(String name, int value){\\n        this.value = value;\\n        this.name = name;\\n    }\\n}\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        if(memory1 == 0 && memory2 == 0) return new int[]{1,0,0};\\n        Memory memoryObj1 = new Memory(\"memory1\", memory1);\\n        Memory memoryObj2 = new Memory(\"memory2\", memory2);\\n        PriorityQueue<Memory> maxHeap = new PriorityQueue(new MemoryStickComparator());\\n        maxHeap.add(memoryObj1);\\n        maxHeap.add(memoryObj2);\\n        int count = 1;\\n        int[] result = new int[3];\\n        result[0] = -1;\\n        while(!maxHeap.isEmpty()){\\n            Memory memObj = maxHeap.poll();\\n            // System.out.print(memObj.name + \" \" + memObj.value);\\n            // System.out.println();\\n            if(maxHeap.size() < 2 && memObj.value < count){\\n                result[0] = result[0] == -1 ? (memObj.value== 0 ? count+1 : count) : result[0];\\n                if(memObj.name.equals(\"memory1\")){\\n                    result[1] = memObj.value;\\n                }else if(memObj.name.equals(\"memory2\")){\\n                    result[2] = memObj.value;\\n                }\\n            }\\n            memObj.value -= count;\\n            if(memObj.value >= 0 ){\\n                maxHeap.add(memObj);\\n                count++;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739995,
                "title": "java-easy-to-understand-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MemoryStickComparator implements Comparator<Memory>{\\n    @Override\\n    public int compare(Memory memory1, Memory memory2){\\n        if(memory1.value == memory2.value){\\n            return memory1.name.compareTo(memory2.name);\\n        }\\n        return Integer.compare(memory2.value,memory1.value);\\n    } \\n}\\nclass Memory{\\n    int value;\\n    String name;\\n    public Memory(String name, int value){\\n        this.value = value;\\n        this.name = name;\\n    }\\n}\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        if(memory1 == 0 && memory2 == 0) return new int[]{1,0,0};\\n        Memory memoryObj1 = new Memory(\"memory1\", memory1);\\n        Memory memoryObj2 = new Memory(\"memory2\", memory2);\\n        PriorityQueue<Memory> maxHeap = new PriorityQueue(new MemoryStickComparator());\\n        maxHeap.add(memoryObj1);\\n        maxHeap.add(memoryObj2);\\n        int count = 1;\\n        int[] result = new int[3];\\n        result[0] = -1;\\n        while(!maxHeap.isEmpty()){\\n            Memory memObj = maxHeap.poll();\\n            // System.out.print(memObj.name + \" \" + memObj.value);\\n            // System.out.println();\\n            if(maxHeap.size() < 2 && memObj.value < count){\\n                result[0] = result[0] == -1 ? (memObj.value== 0 ? count+1 : count) : result[0];\\n                if(memObj.name.equals(\"memory1\")){\\n                    result[1] = memObj.value;\\n                }else if(memObj.name.equals(\"memory2\")){\\n                    result[2] = memObj.value;\\n                }\\n            }\\n            memObj.value -= count;\\n            if(memObj.value >= 0 ){\\n                maxHeap.add(memObj);\\n                count++;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass MemoryStickComparator implements Comparator<Memory>{\\n    @Override\\n    public int compare(Memory memory1, Memory memory2){\\n        if(memory1.value == memory2.value){\\n            return memory1.name.compareTo(memory2.name);\\n        }\\n        return Integer.compare(memory2.value,memory1.value);\\n    } \\n}\\nclass Memory{\\n    int value;\\n    String name;\\n    public Memory(String name, int value){\\n        this.value = value;\\n        this.name = name;\\n    }\\n}\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        if(memory1 == 0 && memory2 == 0) return new int[]{1,0,0};\\n        Memory memoryObj1 = new Memory(\"memory1\", memory1);\\n        Memory memoryObj2 = new Memory(\"memory2\", memory2);\\n        PriorityQueue<Memory> maxHeap = new PriorityQueue(new MemoryStickComparator());\\n        maxHeap.add(memoryObj1);\\n        maxHeap.add(memoryObj2);\\n        int count = 1;\\n        int[] result = new int[3];\\n        result[0] = -1;\\n        while(!maxHeap.isEmpty()){\\n            Memory memObj = maxHeap.poll();\\n            // System.out.print(memObj.name + \" \" + memObj.value);\\n            // System.out.println();\\n            if(maxHeap.size() < 2 && memObj.value < count){\\n                result[0] = result[0] == -1 ? (memObj.value== 0 ? count+1 : count) : result[0];\\n                if(memObj.name.equals(\"memory1\")){\\n                    result[1] = memObj.value;\\n                }else if(memObj.name.equals(\"memory2\")){\\n                    result[2] = memObj.value;\\n                }\\n            }\\n            memObj.value -= count;\\n            if(memObj.value >= 0 ){\\n                maxHeap.add(memObj);\\n                count++;\\n            }\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719196,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        return memLeak(memory1, memory2, 1);\\n    }\\n\\n    public int[] memLeak(int m1, int m2, int time) {\\n        if (Math.max(m1, m2) - time < 0) {\\n            return new int[] {time, m1, m2};\\n        }\\n\\n        if (m1 >= m2) {\\n            return memLeak(m1 - time, m2, time+1);\\n        }\\n\\n        return memLeak(m1, m2 - time, time+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        return memLeak(memory1, memory2, 1);\\n    }\\n\\n    public int[] memLeak(int m1, int m2, int time) {\\n        if (Math.max(m1, m2) - time < 0) {\\n            return new int[] {time, m1, m2};\\n        }\\n\\n        if (m1 >= m2) {\\n            return memLeak(m1 - time, m2, time+1);\\n        }\\n\\n        return memLeak(m1, m2 - time, time+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687997,
                "title": "easiest-solution-0-space",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        \\n        int cr=1;\\n        int memr=1;\\n        \\n    while(memr<=memory1 || memr<=memory2){\\n        \\n        if(memory1>=memory2){\\n            memory1=memory1-memr;\\n        }else{\\n            memory2=memory2-memr;\\n        }\\n        \\n        memr++;\\n        cr++;\\n \\n    }\\n\\n     return new int[]{cr,memory1,memory2};   \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        \\n        int cr=1;\\n        int memr=1;\\n        \\n    while(memr<=memory1 || memr<=memory2){\\n        \\n        if(memory1>=memory2){\\n            memory1=memory1-memr;\\n        }else{\\n            memory2=memory2-memr;\\n        }\\n        \\n        memr++;\\n        cr++;\\n \\n    }\\n\\n     return new int[]{cr,memory1,memory2};   \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671783,
                "title": "very-easy-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        vector<int>v;int i=1;\\n        while(m1>=0 && m2>=0){\\n           \\n            if(m1>=m2 ){\\n                m1=m1-i;\\n               }\\n            else{\\n              m2=m2-i;\\n              }\\n              i++;\\n           \\n            }\\n            if(m1<0){\\n                i--;\\n                m1=m1+i;\\n                \\n            }\\n            else if(m2<0){\\n                i--; \\n                m2=m2+i;\\n               \\n            }\\n            v.push_back(i);\\n            v.push_back(m1);\\n            v.push_back(m2);\\n            return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        vector<int>v;int i=1;\\n        while(m1>=0 && m2>=0){\\n           \\n            if(m1>=m2 ){\\n                m1=m1-i;\\n               }\\n            else{\\n              m2=m2-i;\\n              }\\n              i++;\\n           \\n            }\\n            if(m1<0){\\n                i--;\\n                m1=m1+i;\\n                \\n            }\\n            else if(m2<0){\\n                i--; \\n                m2=m2+i;\\n               \\n            }\\n            v.push_back(i);\\n            v.push_back(m1);\\n            v.push_back(m2);\\n            return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669716,
                "title": "c-easy-simulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(m1>0 || m2>0)\\n        {\\n            if(m1>m2 && m1-i>=0)\\n            {\\n                m1-=i;\\n            }\\n            else if(m2>m1 && m2-i>=0)\\n            {\\n                m2-=i;\\n            }\\n            else if(m1==m2 && m1-i>=0)\\n            {\\n                m1-=i;\\n            }\\n            else\\n            break;\\n            i++;\\n        }\\n        return {i,m1,m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(m1>0 || m2>0)\\n        {\\n            if(m1>m2 && m1-i>=0)\\n            {\\n                m1-=i;\\n            }\\n            else if(m2>m1 && m2-i>=0)\\n            {\\n                m2-=i;\\n            }\\n            else if(m1==m2 && m1-i>=0)\\n            {\\n                m1-=i;\\n            }\\n            else\\n            break;\\n            i++;\\n        }\\n        return {i,m1,m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615702,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n\\n        time = 0\\n        while True:\\n            time += 1\\n            if memory1 >= memory2:\\n                if memory1 - time < 0:\\n                    return [time,memory1,memory2]\\n                else:\\n                    memory1 -= time\\n            else:\\n                if memory2 - time < 0:\\n                    return [time,memory1,memory2]\\n                else:\\n                    memory2 -= time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n\\n        time = 0\\n        while True:\\n            time += 1\\n            if memory1 >= memory2:\\n                if memory1 - time < 0:\\n                    return [time,memory1,memory2]\\n                else:\\n                    memory1 -= time\\n            else:\\n                if memory2 - time < 0:\\n                    return [time,memory1,memory2]\\n                else:\\n                    memory2 -= time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604939,
                "title": "c-beat-100-o-1-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2){\\n                memory1 -= i;\\n            }\\n            else{\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2){\\n                memory1 -= i;\\n            }\\n            else{\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591644,
                "title": "java-simple-compact-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int leak = 1;\\n        while(memory1 >= leak || memory2 >= leak) {\\n            if(memory1 >= memory2)\\n                memory1 -= leak++;\\n            else\\n                memory2 -= leak++;\\n        }\\n        return new int[] {leak,memory1,memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int leak = 1;\\n        while(memory1 >= leak || memory2 >= leak) {\\n            if(memory1 >= memory2)\\n                memory1 -= leak++;\\n            else\\n                memory2 -= leak++;\\n        }\\n        return new int[] {leak,memory1,memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518374,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        time=1\\n        while True:\\n            if memory2>memory1:\\n                if memory2-time>=0:memory2-=time\\n                else:return [time,memory1,memory2]\\n            else:\\n                if memory1-time>=0:memory1-=time\\n                else:return [time,memory1,memory2]\\n            time+=1\\n            \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        time=1\\n        while True:\\n            if memory2>memory1:\\n                if memory2-time>=0:memory2-=time\\n                else:return [time,memory1,memory2]\\n            else:\\n                if memory1-time>=0:memory1-=time\\n                else:return [time,memory1,memory2]\\n            time+=1\\n            \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511337,
                "title": "java-3-lines",
                "content": "```\\npublic int[] memLeak(int m1, int m2) {\\n\\tint step = 1; \\n\\twhile (m1-step>=0 || m2-step>=0) if (m1>=m2) m1-=step++; else m2-=step++;\\n\\treturn new int[]{step,m1,m2};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] memLeak(int m1, int m2) {\\n\\tint step = 1; \\n\\twhile (m1-step>=0 || m2-step>=0) if (m1>=m2) m1-=step++; else m2-=step++;\\n\\treturn new int[]{step,m1,m2};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494468,
                "title": "solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        vector<int> current_bits;\\n\\n        int bits = 1;\\n\\n        while (bits <= memory1 || bits <= memory2) {\\n            if (memory1 == memory2) {\\n                memory1 -= bits;\\n            }\\n            else {\\n                if (memory1 > memory2) {\\n                    memory1 -= bits;\\n                }\\n                else {\\n                    memory2 -= bits;\\n                }\\n            }\\n            bits++;\\n        }\\n\\n        current_bits.push_back(bits);\\n\\n        current_bits.push_back(memory1);\\n\\n        current_bits.push_back(memory2);\\n\\n        return current_bits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        vector<int> current_bits;\\n\\n        int bits = 1;\\n\\n        while (bits <= memory1 || bits <= memory2) {\\n            if (memory1 == memory2) {\\n                memory1 -= bits;\\n            }\\n            else {\\n                if (memory1 > memory2) {\\n                    memory1 -= bits;\\n                }\\n                else {\\n                    memory2 -= bits;\\n                }\\n            }\\n            bits++;\\n        }\\n\\n        current_bits.push_back(bits);\\n\\n        current_bits.push_back(memory1);\\n\\n        current_bits.push_back(memory2);\\n\\n        return current_bits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474987,
                "title": "c-very-easily-explained-with-comments-exhaustion-break",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> memLeak(int memory1, int memory2) {\\n    int ct=0,i=1;\\n    while(memory1>=1 || memory2>=1)\\n    {\\n\\n    if(memory1<memory2)\\n    {\\n    memory2=memory2-i; \\n    ct++;  // seconds of crash increases with every iteration          \\n    }\\n\\n    else if(memory1>=memory2)\\n    {\\n    memory1=memory1-i; \\n    ct++;  // seconds of crash increases with every iteration\\n    }\\n    \\n    i++; // time elapsed\\n    if(memory1<i && memory2<i)break; // memory gets exhausted here\\n    }\\n    return {ct+1,memory1,memory2};\\n    }                      \\n};\\n        \\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> memLeak(int memory1, int memory2) {\\n    int ct=0,i=1;\\n    while(memory1>=1 || memory2>=1)\\n    {\\n\\n    if(memory1<memory2)\\n    {\\n    memory2=memory2-i; \\n    ct++;  // seconds of crash increases with every iteration          \\n    }\\n\\n    else if(memory1>=memory2)\\n    {\\n    memory1=memory1-i; \\n    ct++;  // seconds of crash increases with every iteration\\n    }\\n    \\n    i++; // time elapsed\\n    if(memory1<i && memory2<i)break; // memory gets exhausted here\\n    }\\n    return {ct+1,memory1,memory2};\\n    }                      \\n};\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433507,
                "title": "java-soln",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        int second = 1;\\n        while(memory1 >= 0 && memory2 >= 0) {\\n            if(memory1 >= memory2) {\\n                // pick first memory if both have same \\n                // available memory\\n                memory1 -= second;\\n                if(memory1 < 0) {\\n                    memory1 += second;\\n                    break;\\n                }\\n            } else {\\n                memory2 -= second;\\n                if(memory2 < 0) {\\n                    memory2 += second;\\n                    break;\\n                }\\n            }\\n            second++;\\n        }\\n        \\n        res[0] = second;\\n        res[1] = memory1;\\n        res[2] = memory2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        int second = 1;\\n        while(memory1 >= 0 && memory2 >= 0) {\\n            if(memory1 >= memory2) {\\n                // pick first memory if both have same \\n                // available memory\\n                memory1 -= second;\\n                if(memory1 < 0) {\\n                    memory1 += second;\\n                    break;\\n                }\\n            } else {\\n                memory2 -= second;\\n                if(memory2 < 0) {\\n                    memory2 += second;\\n                    break;\\n                }\\n            }\\n            second++;\\n        }\\n        \\n        res[0] = second;\\n        res[1] = memory1;\\n        res[2] = memory2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416837,
                "title": "javascript-solution-o-n",
                "content": "# JS (JavaScript) solution. O(n)\\n# Space complexity O(1)\\n# Code\\n```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n    let counter = 0;\\n    \\n    while(true){\\n      counter=counter+1\\n      if(counter > memory1 && counter > memory2) {\\n        break\\n      }\\n      if(memory1 >= memory2){\\n        memory1-=counter;\\n        continue\\n      }\\n      if(memory1 < memory2){\\n        memory2 -=counter;\\n        continue\\n      }\\n      \\n    }\\n    return [ counter,memory1, memory2]\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n    let counter = 0;\\n    \\n    while(true){\\n      counter=counter+1\\n      if(counter > memory1 && counter > memory2) {\\n        break\\n      }\\n      if(memory1 >= memory2){\\n        memory1-=counter;\\n        continue\\n      }\\n      if(memory1 < memory2){\\n        memory2 -=counter;\\n        continue\\n      }\\n      \\n    }\\n    return [ counter,memory1, memory2]\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3355427,
                "title": "js-javascript-solution-o-n",
                "content": "\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n    let start1 = memory1\\n    let start2 = memory2\\n    let step = 1\\n    if (memory1 > memory2){\\n        while (memory1 > memory2){\\n            if (memory1 - step < 0) break\\n            memory1 -= step\\n            step++\\n        }\\n    } else {\\n        while (memory2 > memory1){\\n            if (memory2 - step < 0) break\\n            memory2 -= step\\n            step++\\n        }\\n    }\\n    flag = false\\n    if (memory1 >= memory2){\\n        flag = true\\n    }\\n    while (memory1 >= 0 && memory2 >= 0){\\n        if (flag){\\n            if (memory1 - step < 0) break\\n            memory1 -= step\\n        } else {\\n            if (memory2 - step < 0) break\\n            memory2 -= step\\n        }\\n        flag = !flag\\n        step++\\n            \\n    }\\n    return [step, memory1, memory2]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} memory1\\n * @param {number} memory2\\n * @return {number[]}\\n */\\nvar memLeak = function(memory1, memory2) {\\n    let start1 = memory1\\n    let start2 = memory2\\n    let step = 1\\n    if (memory1 > memory2){\\n        while (memory1 > memory2){\\n            if (memory1 - step < 0) break\\n            memory1 -= step\\n            step++\\n        }\\n    } else {\\n        while (memory2 > memory1){\\n            if (memory2 - step < 0) break\\n            memory2 -= step\\n            step++\\n        }\\n    }\\n    flag = false\\n    if (memory1 >= memory2){\\n        flag = true\\n    }\\n    while (memory1 >= 0 && memory2 >= 0){\\n        if (flag){\\n            if (memory1 - step < 0) break\\n            memory1 -= step\\n        } else {\\n            if (memory2 - step < 0) break\\n            memory2 -= step\\n        }\\n        flag = !flag\\n        step++\\n            \\n    }\\n    return [step, memory1, memory2]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348456,
                "title": "simple-ruby-solution",
                "content": "\\n\\n# Code\\n```\\n# @param {Integer} memory1\\n# @param {Integer} memory2\\n# @return {Integer[]}\\ndef mem_leak(memory1, memory2)\\n  crash_time = 0\\n  app_memory = 1\\n  return [1, memory1, memory2] if app_memory > memory1 + memory2\\n  while true do\\n    crash_time += 1\\n    if memory1 >= memory2 && app_memory <= memory1\\n        memory1 -= app_memory\\n    elsif memory2 >= app_memory\\n        memory2 -=app_memory\\n    else\\n      break\\n    end\\n    app_memory += 1      \\n  end\\n  [crash_time, memory1, memory2]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} memory1\\n# @param {Integer} memory2\\n# @return {Integer[]}\\ndef mem_leak(memory1, memory2)\\n  crash_time = 0\\n  app_memory = 1\\n  return [1, memory1, memory2] if app_memory > memory1 + memory2\\n  while true do\\n    crash_time += 1\\n    if memory1 >= memory2 && app_memory <= memory1\\n        memory1 -= app_memory\\n    elsif memory2 >= app_memory\\n        memory2 -=app_memory\\n    else\\n      break\\n    end\\n    app_memory += 1      \\n  end\\n  [crash_time, memory1, memory2]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3347682,
                "title": "c-and-c",
                "content": "C\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1 ;\\n    while(memory1 >= i || memory2 >= i){\\n        if(memory1 >= memory2)\\n            memory1 -= i ;\\n        else\\n            memory2 -= i ;\\n        i++ ;\\n    }\\n    int* ans = malloc(3 * sizeof(int)) ;\\n    ans[0] = i ;\\n    ans[1] = memory1 ;\\n    ans[2] = memory2 ;\\n    *returnSize = 3 ;\\n    return ans ;\\n}\\n```\\nC++ \\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1 ;\\n        while(memory1 >= i || memory2 >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i ;\\n            else\\n                memory2 -= i ;\\n            i++ ;\\n        }\\n        return {i, memory1, memory2} ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1 ;\\n    while(memory1 >= i || memory2 >= i){\\n        if(memory1 >= memory2)\\n            memory1 -= i ;\\n        else\\n            memory2 -= i ;\\n        i++ ;\\n    }\\n    int* ans = malloc(3 * sizeof(int)) ;\\n    ans[0] = i ;\\n    ans[1] = memory1 ;\\n    ans[2] = memory2 ;\\n    *returnSize = 3 ;\\n    return ans ;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1 ;\\n        while(memory1 >= i || memory2 >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i ;\\n            else\\n                memory2 -= i ;\\n            i++ ;\\n        }\\n        return {i, memory1, memory2} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276493,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func memLeak(_ memory1: Int, _ memory2: Int) -> [Int] {\\n        \\n        var free1 = memory1\\n        var free2 = memory2\\n        var time = 0\\n\\n        while true {\\n            time += 1\\n\\n            if max(free1 - time, free2 - time) < 0 { break }\\n            \\n            if free1 >= free2 { free1 -= time }\\n            else { free2 -= time }\\n        }\\n\\n        return [time, free1, free2]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func memLeak(_ memory1: Int, _ memory2: Int) -> [Int] {\\n        \\n        var free1 = memory1\\n        var free2 = memory2\\n        var time = 0\\n\\n        while true {\\n            time += 1\\n\\n            if max(free1 - time, free2 - time) < 0 { break }\\n            \\n            if free1 >= free2 { free1 -= time }\\n            else { free2 -= time }\\n        }\\n\\n        return [time, free1, free2]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272000,
                "title": "java-solution-easy-solution-100-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(true)\\n        {\\n            \\n            if(memory1<memory2)\\n            {\\n                if(memory2-i>=0)\\n                {\\n                    memory2-=i;\\n                }   \\n                else if(memory1-i>=0)   \\n                {\\n                    memory1-=i;\\n                }       \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if(memory1-i>=0)\\n                {\\n                    memory1-=i;\\n                }   \\n                else if(memory2-i>=0)   \\n                {\\n                    memory2-=i;\\n                }       \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            i++;\\n        }\\n\\n        return new int[]{i,memory1,memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(true)\\n        {\\n            \\n            if(memory1<memory2)\\n            {\\n                if(memory2-i>=0)\\n                {\\n                    memory2-=i;\\n                }   \\n                else if(memory1-i>=0)   \\n                {\\n                    memory1-=i;\\n                }       \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                if(memory1-i>=0)\\n                {\\n                    memory1-=i;\\n                }   \\n                else if(memory2-i>=0)   \\n                {\\n                    memory2-=i;\\n                }       \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            i++;\\n        }\\n\\n        return new int[]{i,memory1,memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170336,
                "title": "c-solution-explained",
                "content": "# Intuition\\n\\nThe first thought that came to my mind was to use a loop to subtract a certain amount of memory from the two given values until one of them becomes negative. \\n\\n# Approach\\n\\nWe can use a while loop to subtract a certain amount of memory from the two given values until one of them becomes negative. The amount that is subtracted from each memory value is equal to the number of iterations that the loop has gone through. The loop stops when either one of the values becomes negative, in which case the other one will be positive and the number of iterations will be the result.  \\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while (memory1 >= i || memory2 >= i) {\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while (memory1 >= i || memory2 >= i) {\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101653,
                "title": "golang-solution-4ms-100",
                "content": "Runtime: 4 ms, faster than 100.00% of Go online submissions for Incremental Memory Leak.\\nMemory Usage: 1.8 MB, less than 100.00% of Go online submissions for Incremental Memory Leak.\\n\\n```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    ans := make([]int, 3)\\n    t := 1\\n    for {\\n        if memory2 > memory1 {\\n            if (memory2 - t < 0) {\\n                break\\n            }\\n            memory2 -= t\\n        } else {\\n            if (memory1 - t < 0) {\\n                break\\n            }          \\n            memory1 -= t\\n        }\\n        t++\\n    }\\n    ans[0] = t\\n    ans[1] = memory1\\n    ans[2] = memory2\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    ans := make([]int, 3)\\n    t := 1\\n    for {\\n        if memory2 > memory1 {\\n            if (memory2 - t < 0) {\\n                break\\n            }\\n            memory2 -= t\\n        } else {\\n            if (memory1 - t < 0) {\\n                break\\n            }          \\n            memory1 -= t\\n        }\\n        t++\\n    }\\n    ans[0] = t\\n    ans[1] = memory1\\n    ans[2] = memory2\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099039,
                "title": "golang-simulation",
                "content": "# Code\\n```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    var i int\\n    for i = 1; i <= memory1 || i <= memory2; i++ {\\n        if memory2 > memory1 {\\n            memory2 -= i\\n        } else {\\n            memory1 -= i\\n        }\\n    }\\n    return []int{i, memory1, memory2}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Simulation"
                ],
                "code": "```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    var i int\\n    for i = 1; i <= memory1 || i <= memory2; i++ {\\n        if memory2 > memory1 {\\n            memory2 -= i\\n        } else {\\n            memory1 -= i\\n        }\\n    }\\n    return []int{i, memory1, memory2}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099016,
                "title": "c-simulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        for(int i = 1; ; i++) {\\n            if(i > memory1 && i > memory2) return {i, memory1, memory2};\\n            if(memory2 > memory1) memory2 -= i;\\n            else memory1 -= i;\\n        }\\n        return {-1, -1, -1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        for(int i = 1; ; i++) {\\n            if(i > memory1 && i > memory2) return {i, memory1, memory2};\\n            if(memory2 > memory1) memory2 -= i;\\n            else memory1 -= i;\\n        }\\n        return {-1, -1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007384,
                "title": "easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(1){\\n            if(i>m1 && i>m2) break;\\n            else if(m1>=m2){\\n                m1=m1-i;\\n            }\\n            else{\\n                m2=m2-i;\\n            }\\n            i++;\\n        }\\n        return {i,m1,m2};\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(1){\\n            if(i>m1 && i>m2) break;\\n            else if(m1>=m2){\\n                m1=m1-i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2974273,
                "title": "java-beats-80",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        boolean crashed = false;\\n        int second = 1;\\n        while (!crashed) {\\n            if (memory1 >= memory2) {\\n                int prevMem = memory1;\\n                memory1 -= second;\\n                if (memory1 < 0) {\\n                    res[0] = second;\\n                    res[1] = prevMem;\\n                    res[2] = memory2;\\n                    crashed = true; \\n                }\\n            } else {\\n                int prevMem = memory2;\\n                memory2 -= second;\\n                if (memory2 < 0) {\\n                    res[0] = second;\\n                    res[1] = memory1;\\n                    res[2] = prevMem;\\n                    crashed = true;\\n                }\\n            }\\n            second++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n        boolean crashed = false;\\n        int second = 1;\\n        while (!crashed) {\\n            if (memory1 >= memory2) {\\n                int prevMem = memory1;\\n                memory1 -= second;\\n                if (memory1 < 0) {\\n                    res[0] = second;\\n                    res[1] = prevMem;\\n                    res[2] = memory2;\\n                    crashed = true; \\n                }\\n            } else {\\n                int prevMem = memory2;\\n                memory2 -= second;\\n                if (memory2 < 0) {\\n                    res[0] = second;\\n                    res[1] = memory1;\\n                    res[2] = prevMem;\\n                    crashed = true;\\n                }\\n            }\\n            second++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970656,
                "title": "python-bruteforce",
                "content": "# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while True:\\n            if memory1 >= memory2:\\n                if i > memory1:\\n                    break\\n                memory1 -= i\\n            else:\\n                if i > memory2:\\n                    break\\n                memory2 -= i\\n            i += 1\\n        return (i, memory1, memory2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while True:\\n            if memory1 >= memory2:\\n                if i > memory1:\\n                    break\\n                memory1 -= i\\n            else:\\n                if i > memory2:\\n                    break\\n                memory2 -= i\\n            i += 1\\n        return (i, memory1, memory2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970554,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int c=1;\\n        while(memory1>=c or memory2>=c)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=c;\\n            }\\n            else \\n            {\\n                memory2-=c;\\n            }\\n            c++;\\n        }\\n        return {c,memory1,memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int c=1;\\n        while(memory1>=c or memory2>=c)\\n        {\\n            if(memory1>=memory2)\\n            {\\n                memory1-=c;\\n            }\\n            else \\n            {\\n                memory2-=c;\\n            }\\n            c++;\\n        }\\n        return {c,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956189,
                "title": "c-easy-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        // Start point of time\\n        int time = 1;\\n        \\n        // Simulate the process\\n        // pick the memory stick with greater memory available\\n        // if it\\'s greater than the stipulated time?\\n        // i.e if the stick has capacity to allocate bits, allocate it.\\n        // else break the loop.\\n        // Increment the time for every iteration.\\n        \\n        while(memory1 >= 0 and memory2 >= 0) {\\n            if(memory1 >= memory2) {\\n                if(memory1 >= time) memory1 -= time;\\n                else break;\\n            } else {\\n                if(memory2 >= time) memory2 -= time;\\n                else break;\\n            }\\n            \\n            time++;\\n        }\\n        \\n        // return the result\\n        return {time, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        // Start point of time\\n        int time = 1;\\n        \\n        // Simulate the process\\n        // pick the memory stick with greater memory available\\n        // if it\\'s greater than the stipulated time?\\n        // i.e if the stick has capacity to allocate bits, allocate it.\\n        // else break the loop.\\n        // Increment the time for every iteration.\\n        \\n        while(memory1 >= 0 and memory2 >= 0) {\\n            if(memory1 >= memory2) {\\n                if(memory1 >= time) memory1 -= time;\\n                else break;\\n            } else {\\n                if(memory2 >= time) memory2 -= time;\\n                else break;\\n            }\\n            \\n            time++;\\n        }\\n        \\n        // return the result\\n        return {time, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928779,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def memLeak(self, memory1, memory2):\\n        total = 1\\n\\n        while total <= memory1 or total <= memory2:\\n            if memory1 >= memory2:\\n                memory1 -= total\\n            else:\\n                memory2 -= total\\n\\n            total += 1\\n\\n        return [total,memory1,memory2]\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1, memory2):\\n        total = 1\\n\\n        while total <= memory1 or total <= memory2:\\n            if memory1 >= memory2:\\n                memory1 -= total\\n            else:\\n                memory2 -= total\\n\\n            total += 1\\n\\n        return [total,memory1,memory2]\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926711,
                "title": "easy-solution-in-rust",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn mem_leak(mut memory1: i32, mut memory2: i32) -> Vec<i32> {\\n        let mut i: i32 = 1;\\n        while memory1 >= i || memory2 >= i {\\n            if memory1 >= memory2 || (memory1 == memory2 && memory1 >= i) {\\n                memory1 -= i;\\n            } else {\\n                if memory2 >= i {\\n                    memory2 -= i;\\n                }\\n            }\\n            i += 1;\\n        }\\n        vec![i, memory1, memory2]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn mem_leak(mut memory1: i32, mut memory2: i32) -> Vec<i32> {\\n        let mut i: i32 = 1;\\n        while memory1 >= i || memory2 >= i {\\n            if memory1 >= memory2 || (memory1 == memory2 && memory1 >= i) {\\n                memory1 -= i;\\n            } else {\\n                if memory2 >= i {\\n                    memory2 -= i;\\n                }\\n            }\\n            i += 1;\\n        }\\n        vec![i, memory1, memory2]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2884604,
                "title": "cpp-fastest-approach",
                "content": "# Intuition\\nJust simulate.\\n\\n# Approach\\nSimulate until memory1 and memory2 are less than t. increment t after every iteration.\\n# Complexity\\n- Time complexity:\\nO(sqrt(n)) as their is sum of series.\\n\\n- Space complexity:\\nNo extra space is required. O(1)\\n\\n# Code\\n```\\nsiclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        vector<int> ans(3);\\n        int t=1;\\n        while(1){\\n            if(memory2>memory1 && memory2>=t){\\n                memory2-=t;\\n                t++;\\n            }\\n            else if(memory1>=memory2 && memory1>=t){\\n                memory1-=t;\\n                t++;\\n            }\\n            else{\\n                ans[0]=t;\\n                ans[1]=memory1;\\n                ans[2]=memory2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nsiclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        vector<int> ans(3);\\n        int t=1;\\n        while(1){\\n            if(memory2>memory1 && memory2>=t){\\n                memory2-=t;\\n                t++;\\n            }\\n            else if(memory1>=memory2 && memory1>=t){\\n                memory1-=t;\\n                t++;\\n            }\\n            else{\\n                ans[0]=t;\\n                ans[1]=memory1;\\n                ans[2]=memory2;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872852,
                "title": "c-easy-to-understand-beats-97",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int crash = 1;\\n        \\n        while(crash <= memory1 || crash <= memory2)\\n        {\\n            if(memory1 > memory2 && memory1 >= crash)\\n                memory1-=crash;\\n            \\n            else if(memory2 > memory1 && memory2 >= crash)\\n                memory2-=crash;\\n            \\n            else if(memory1 ==memory2 && memory1 >= crash)\\n                memory1-=crash;\\n            \\n            crash++;\\n        }\\n        \\n        return {crash,memory1,memory2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int crash = 1;\\n        \\n        while(crash <= memory1 || crash <= memory2)\\n        {\\n            if(memory1 > memory2 && memory1 >= crash)\\n                memory1-=crash;\\n            \\n            else if(memory2 > memory1 && memory2 >= crash)\\n                memory2-=crash;\\n            \\n            else if(memory1 ==memory2 && memory1 >= crash)\\n                memory1-=crash;\\n            \\n            crash++;\\n        }\\n        \\n        return {crash,memory1,memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836000,
                "title": "c-simulation-easy-understanding",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        vector<int>ans;\\n        int i = 1;\\n        bool crash = false;\\n\\n        while(i <= m1 || i <= m2){\\n            if(m1 >= m2){\\n                m1 -= i;\\n            }else{\\n                m2 -= i;\\n            }\\n            i++;\\n        \\n        }\\n        return {i , m1 , m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        vector<int>ans;\\n        int i = 1;\\n        bool crash = false;\\n\\n        while(i <= m1 || i <= m2){\\n            if(m1 >= m2){\\n                m1 -= i;\\n            }else{\\n                m2 -= i;\\n            }\\n            i++;\\n        \\n        }\\n        return {i , m1 , m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814198,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n\\n        int second = 1;\\n        int maxSecond = 0;\\n\\n        while(memory1 >= second || memory2 >= second) {\\n            if(memory1 >= memory2) {\\n                memory1 -= second;\\n            }\\n            else {\\n                memory2 -= second;\\n            }\\n            \\n            second++;\\n            maxSecond = Math.max(maxSecond, second);\\n        }\\n        res[0] = maxSecond;\\n        res[1] = memory1;\\n        res[2] = memory2;\\n\\n        if(memory1 == 0 && memory2 == 0) {\\n            res[0] = 1;\\n            res[1] = 0;\\n            res[2] = 0;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int[] res = new int[3];\\n\\n        int second = 1;\\n        int maxSecond = 0;\\n\\n        while(memory1 >= second || memory2 >= second) {\\n            if(memory1 >= memory2) {\\n                memory1 -= second;\\n            }\\n            else {\\n                memory2 -= second;\\n            }\\n            \\n            second++;\\n            maxSecond = Math.max(maxSecond, second);\\n        }\\n        res[0] = maxSecond;\\n        res[1] = memory1;\\n        res[2] = memory2;\\n\\n        if(memory1 == 0 && memory2 == 0) {\\n            res[0] = 1;\\n            res[1] = 0;\\n            res[2] = 0;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803172,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        k=1\\n        while k<=memory1 or k<=memory2:\\n            if memory1<memory2:\\n                memory2-=k\\n            else:\\n                memory1-=k\\n            k+=1\\n        return [k,memory1,memory2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        k=1\\n        while k<=memory1 or k<=memory2:\\n            if memory1<memory2:\\n                memory2-=k\\n            else:\\n                memory1-=k\\n            k+=1\\n        return [k,memory1,memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780574,
                "title": "c-easy",
                "content": "\\tvector<int> memLeak(int memory1, int memory2) {\\n        int time = 0 , data = 1;\\n        while(true){\\n            time++;\\n            if(memory2 > memory1 && data <= memory2)\\n                memory2 -= data;\\n            \\n            else if(data <= memory1)\\n                memory1 -= data;\\n            \\n            else\\n                return {time , memory1 , memory2};\\n            \\n            data++;\\n        }\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tvector<int> memLeak(int memory1, int memory2) {\\n        int time = 0 , data = 1;\\n        while(true){\\n            time++;\\n            if(memory2 > memory1 && data <= memory2)\\n                memory2 -= data;\\n            \\n            else if(data <= memory1)\\n                memory1 -= data;\\n            \\n            else\\n                return {time , memory1 , memory2};\\n            \\n            data++;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2776669,
                "title": "easy-to-understand-c",
                "content": "```\\nector<int> memLeak(int memory1, int memory2) {\\n        int r = 0;\\n        int i = 1;\\n        // if either of memory has current memory required\\n        while ( i <= memory1 || i <= memory2) {\\n            //if first stick has more or equal memory take it from\\n            // first memory or else take it from second memory\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        vector<int> result = {i, memory1, memory2};\\n        return result;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nector<int> memLeak(int memory1, int memory2) {\\n        int r = 0;\\n        int i = 1;\\n        // if either of memory has current memory required\\n        while ( i <= memory1 || i <= memory2) {\\n            //if first stick has more or equal memory take it from\\n            // first memory or else take it from second memory\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        vector<int> result = {i, memory1, memory2};\\n        return result;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2771872,
                "title": "straightforward-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int second = 1;\\n        \\n        while (memory1 != 0 || memory2 != 0) {\\n            if (memory2 > memory1) {\\n                if (second > memory2)\\n                    return new int[] {second, memory1, memory2};\\n                memory2 -= second;\\n            } else {\\n                if (second > memory1)\\n                    return new int[] {second, memory1, memory2};\\n                memory1 -= second;\\n            }\\n            \\n            second++;\\n        }\\n        \\n        return new int[] {1, 0, 0};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int second = 1;\\n        \\n        while (memory1 != 0 || memory2 != 0) {\\n            if (memory2 > memory1) {\\n                if (second > memory2)\\n                    return new int[] {second, memory1, memory2};\\n                memory2 -= second;\\n            } else {\\n                if (second > memory1)\\n                    return new int[] {second, memory1, memory2};\\n                memory1 -= second;\\n            }\\n            \\n            second++;\\n        }\\n        \\n        return new int[] {1, 0, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725964,
                "title": "very-simple-logic-java",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        \\n        int t = 1;\\n        int r = 1;\\n        \\n        while(r<=m1 || r<=m2){\\n            if(m1>=m2){\\n                m1=m1-r;\\n                r++;\\n            }\\n            else if(m1<m2){\\n                m2=m2-r;\\n                r++;\\n            }\\n            t++;\\n        }\\n        int [] ans = {t, m1, m2};\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        \\n        int t = 1;\\n        int r = 1;\\n        \\n        while(r<=m1 || r<=m2){\\n            if(m1>=m2){\\n                m1=m1-r;\\n                r++;\\n            }\\n            else if(m1<m2){\\n                m2=m2-r;\\n                r++;\\n            }\\n            t++;\\n        }\\n        int [] ans = {t, m1, m2};\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718864,
                "title": "java-very-simple-bruteforce",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int cnt = 1;\\n\\n        while(memory1 >= cnt || memory2 >= cnt) {\\n            if(memory1 >= memory2) {\\n                memory1 -= cnt;\\n            } else {\\n                memory2 -= cnt;\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return new int[]{cnt, memory1, memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int cnt = 1;\\n\\n        while(memory1 >= cnt || memory2 >= cnt) {\\n            if(memory1 >= memory2) {\\n                memory1 -= cnt;\\n            } else {\\n                memory2 -= cnt;\\n            }\\n\\n            cnt++;\\n        }\\n\\n        return new int[]{cnt, memory1, memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703057,
                "title": "python3-simple",
                "content": "\\tclass Solution:\\n\\t\\tdef memLeak(self, memory1: int, memory2: int) -> List[int]:\\n\\n\\t\\t\\tsecond = 0\\n\\t\\t\\twhile True:\\n\\n\\t\\t\\t\\t# Increase second\\n\\t\\t\\t\\tsecond += 1\\n\\n\\t\\t\\t\\tif (memory1 > memory2) and (memory1 >= second):\\n\\t\\t\\t\\t\\tmemory1 -= second\\n\\t\\t\\t\\telif (memory2 > memory1) and (memory2 >= second):\\n\\t\\t\\t\\t\\tmemory2 -= second\\n\\t\\t\\t\\telif (memory2 == memory1) and (memory2 >= second):\\n\\t\\t\\t\\t\\tmemory1 -= second\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn [second, memory1, memory2]\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef memLeak(self, memory1: int, memory2: int) -> List[int]:\\n\\n\\t\\t\\tsecond = 0\\n\\t\\t\\twhile True:\\n\\n\\t\\t\\t\\t# Increase second\\n\\t\\t\\t\\tsecond += 1\\n\\n\\t\\t\\t\\tif (memory1 > memory2) and (memory1 >= second):\\n\\t\\t\\t\\t\\tmemory1 -= second\\n\\t\\t\\t\\telif (memory2 > memory1) and (memory2 >= second):\\n\\t\\t\\t\\t\\tmemory2 -= second\\n\\t\\t\\t\\telif (memory2 == memory1) and (memory2 >= second):\\n\\t\\t\\t\\t\\tmemory1 -= second\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn [second, memory1, memory2]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2696645,
                "title": "c-clean-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int i = 1;\\n        while (memory1 >= i || memory2 >= i) {\\n            \\n            if (memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            \\n            ++i;\\n        }\\n        \\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        \\n        int i = 1;\\n        while (memory1 >= i || memory2 >= i) {\\n            \\n            if (memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            \\n            ++i;\\n        }\\n        \\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687137,
                "title": "c-tip-baddam-khaao-code-likho",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(max(memory1, memory2) >= i){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            else\\n                memory2 -= i;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2671837,
                "title": "java-while-loop-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int arr[] = new int[3];\\n        int i=1,flag=0;\\n        while(i>0){\\n            int max = Math.max(memory1,memory2);\\n            if(max==memory1){\\n                if(i>memory1)\\n                    flag=1;\\n                else\\n                    memory1=memory1-i;\\n            }\\n            else{\\n                if(i>memory2)\\n                    flag=1;\\n                else\\n                    memory2=memory2-i;\\n            }\\n            if(flag==1){\\n                arr[0]=i;\\n                arr[1]=memory1;\\n                arr[2]=memory2;\\n                return arr;\\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int arr[] = new int[3];\\n        int i=1,flag=0;\\n        while(i>0){\\n            int max = Math.max(memory1,memory2);\\n            if(max==memory1){\\n                if(i>memory1)\\n                    flag=1;\\n                else\\n                    memory1=memory1-i;\\n            }\\n            else{\\n                if(i>memory2)\\n                    flag=1;\\n                else\\n                    memory2=memory2-i;\\n            }\\n            if(flag==1){\\n                arr[0]=i;\\n                arr[1]=memory1;\\n                arr[2]=memory2;\\n                return arr;\\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671425,
                "title": "easy-python-while-loop-every-line-commented-i-think-this-might-be-o-logn",
                "content": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        #start i at 1 as per question\\n        i=1\\n        #stop loop if memory left less than i \\n        while memory1 >= i or memory2 >= i:\\n            #if memory2 has the most left\\n            if memory2 > memory1:\\n                #subtract i from memory2\\n                memory2 -= i\\n                #increment i by 1\\n                i+=1\\n                #if this takes memory2 to 0...\\n                if memory2 == 0:\\n                    # break the loop\\n                    break\\n            #else covers if memory1 is greater than or equal to memory2\\n            else:\\n                #do the same thing to memory 1\\n                memory1 -= i\\n                #you know what this does\\n                i+=1\\n                #once again, if we hit 0\\n                if memory1 == 0:\\n                    #get out of the loop\\n                    break\\n        #return this list as per question\\n        return [i, memory1, memory2]\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        #start i at 1 as per question\\n        i=1\\n        #stop loop if memory left less than i \\n        while memory1 >= i or memory2 >= i:\\n            #if memory2 has the most left\\n            if memory2 > memory1:\\n                #subtract i from memory2\\n                memory2 -= i\\n                #increment i by 1\\n                i+=1\\n                #if this takes memory2 to 0...\\n                if memory2 == 0:\\n                    # break the loop\\n                    break\\n            #else covers if memory1 is greater than or equal to memory2\\n            else:\\n                #do the same thing to memory 1\\n                memory1 -= i\\n                #you know what this does\\n                i+=1\\n                #once again, if we hit 0\\n                if memory1 == 0:\\n                    #get out of the loop\\n                    break\\n        #return this list as per question\\n        return [i, memory1, memory2]\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613015,
                "title": "java-optimized-code-with-commented-explanation-easy-simulation",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        int[] ans = new int [3];\\n        int i =1;\\n        \\n        // To check condition if m1 or m2 always remains positive \\n        while(m1-i>=0 || m2-i>=0){  \\n            // If m1>m2 or m1=m2 , available memory goes into memory 1\\n            if(m1-i>=0 && m1>=m2 ) m1-=i;\\n            else m2-=i;\\n            //Increamenting memory with respect to time\\n            i++;\\n        }\\n        // i is nothing but our crashtime\\n        ans[0]=i;\\n        ans[1]=m1;\\n        ans[2]=m2;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        int[] ans = new int [3];\\n        int i =1;\\n        \\n        // To check condition if m1 or m2 always remains positive \\n        while(m1-i>=0 || m2-i>=0){  \\n            // If m1>m2 or m1=m2 , available memory goes into memory 1\\n            if(m1-i>=0 && m1>=m2 ) m1-=i;\\n            else m2-=i;\\n            //Increamenting memory with respect to time\\n            i++;\\n        }\\n        // i is nothing but our crashtime\\n        ans[0]=i;\\n        ans[1]=m1;\\n        ans[2]=m2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611980,
                "title": "easy-fast-basic-loop-based-python-solution",
                "content": "Upvote if you understood the logic :)\\n\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        \\n        while i <= memory1 or i <= memory2:\\n            if memory1 >= memory2:\\n                if i <= memory1:\\n                    memory1 -= i\\n                else:\\n                    break\\n            else:\\n                if i <= memory2:\\n                    memory2 -= i\\n                else:\\n                    break\\n            \\n            i += 1\\n        \\n        return [i, memory1, memory2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        \\n        while i <= memory1 or i <= memory2:\\n            if memory1 >= memory2:\\n                if i <= memory1:\\n                    memory1 -= i\\n                else:\\n                    break\\n            else:\\n                if i <= memory2:\\n                    memory2 -= i\\n                else:\\n                    break\\n            \\n            i += 1\\n        \\n        return [i, memory1, memory2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606745,
                "title": "c-straightforward-clean-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/574dcbf1-090c-4046-ba19-d75f72be5686_1663781438.7687004.png)\\n\\n**T->O(linear) && S->O(3)\\t**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> memLeak(int mem1, int mem2) {\\n\\t\\t\\tvector<int> ans(3);\\n\\t\\t\\tint t=1;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tif(t<=max(mem1,mem2)){\\n\\t\\t\\t\\t\\tif(mem1>=mem2) mem1-=t;\\n\\t\\t\\t\\t\\telse mem2-=t;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t\\tans[0]=t;\\n\\t\\t\\tans[1]=mem1;\\n\\t\\t\\tans[2]=mem2;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> memLeak(int mem1, int mem2) {\\n\\t\\t\\tvector<int> ans(3);\\n\\t\\t\\tint t=1;\\n\\t\\t\\twhile(1){\\n\\t\\t\\t\\tif(t<=max(mem1,mem2)){\\n\\t\\t\\t\\t\\tif(mem1>=mem2) mem1-=t;\\n\\t\\t\\t\\t\\telse mem2-=t;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2597320,
                "title": "simple-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) \\n    {\\n        int count=1;\\n        while(count<=m1 or count<=m2)\\n        {\\n            if(m1>=m2)\\n            {\\n                m1-=count;\\n            }\\n            else\\n            {\\n                m2-=count;\\n            }\\n            count++;\\n        }\\n        return {count,m1,m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) \\n    {\\n        int count=1;\\n        while(count<=m1 or count<=m2)\\n        {\\n            if(m1>=m2)\\n            {\\n                m1-=count;\\n            }\\n            else\\n            {\\n                m2-=count;\\n            }\\n            count++;\\n        }\\n        return {count,m1,m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575016,
                "title": "my-java-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        int i=1;\\n        while(memory1>=i || memory2>=i){\\n            if(memory1>=memory2){\\n                memory1-=i;\\n            }\\n            else{\\n                memory2-=i;\\n            }\\n            i++;\\n        }\\n        int arr[]=new int[3];\\n        arr[0] = i;\\n        arr[1]= memory1;\\n        arr[2]= memory2;\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        \\n        int i=1;\\n        while(memory1>=i || memory2>=i){\\n            if(memory1>=memory2){\\n                memory1-=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2506012,
                "title": "python-simple-solution",
                "content": "```\\ndef memLeak(self, m1: int, m2: int) -> List[int]:\\n\\tk = 1\\n\\twhile(max(m1,m2)>=k):\\n\\t\\tif m1>=m2:\\n\\t\\t\\tm1 -= k\\n\\t\\telse:\\n\\t\\t\\tm2 -= k\\n\\t\\tk += 1\\n\\treturn [k, m1, m2]\\n```",
                "solutionTags": [],
                "code": "```\\ndef memLeak(self, m1: int, m2: int) -> List[int]:\\n\\tk = 1\\n\\twhile(max(m1,m2)>=k):\\n\\t\\tif m1>=m2:\\n\\t\\t\\tm1 -= k\\n\\t\\telse:\\n\\t\\t\\tm2 -= k\\n\\t\\tk += 1\\n\\treturn [k, m1, m2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2504177,
                "title": "java-faster-than-90-users-space-92-5-lines-logic",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        int i=1;\\n        while(m1>=i || m2>=i){\\n            if(m1>=m2)m1-=i;\\n            else if(m2>m1)m2-=i;\\n            else break;\\n            i++;\\n        }\\n        int ans[]={i,m1,m2};\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int m1, int m2) {\\n        int i=1;\\n        while(m1>=i || m2>=i){\\n            if(m1>=m2)m1-=i;\\n            else if(m2>m1)m2-=i;\\n            else break;\\n            i++;\\n        }\\n        int ans[]={i,m1,m2};\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2468146,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        result, memory = [], 1\\n        while True:\\n            if (memory1 >= memory2 and memory > memory1) or (memory2 >= memory1 and memory > memory2):\\n                return [memory,memory1,memory2]\\n            else:\\n                if memory1 >= memory2:\\n                    memory1 -= memory\\n                else:\\n                    memory2 -= memory\\n            memory += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        result, memory = [], 1\\n        while True:\\n            if (memory1 >= memory2 and memory > memory1) or (memory2 >= memory1 and memory > memory2):\\n                return [memory,memory1,memory2]\\n            else:\\n                if memory1 >= memory2:\\n                    memory1 -= memory\\n                else:\\n                    memory2 -= memory\\n            memory += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442272,
                "title": "short-and-simple-java-solution",
                "content": "```\\nclass Solution {\\n  public int[] memLeak(int memory1, int memory2) {\\n    int bits = 1;\\n    while (memory1 - bits >= 0 || memory2 - bits >= 0){\\n      if(memory1 >= memory2)\\n        memory1 -= bits++;\\n      else\\n        memory2 -= bits++;\\n    }\\n    return new int[]{bits, memory1, memory2};\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int[] memLeak(int memory1, int memory2) {\\n    int bits = 1;\\n    while (memory1 - bits >= 0 || memory2 - bits >= 0){\\n      if(memory1 >= memory2)\\n        memory1 -= bits++;\\n      else\\n        memory2 -= bits++;\\n    }\\n    return new int[]{bits, memory1, memory2};\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416457,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int bits = 1;\\n        int m1 = memory1;\\n        int m2 = memory2;\\n        int[] result = new int[3];\\n        while ((m1 - bits >= 0) || (m2 - bits >= 0)) {\\n            if (m1 >= m2) {\\n                m1 -= bits++;\\n            } else {\\n                m2 -= bits++;\\n            }\\n        }\\n        result[0] = bits;\\n        result[1] = m1;\\n        result[2] = m2;\\n        return result;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int bits = 1;\\n        int m1 = memory1;\\n        int m2 = memory2;\\n        int[] result = new int[3];\\n        while ((m1 - bits >= 0) || (m2 - bits >= 0)) {\\n            if (m1 >= m2) {\\n                m1 -= bits++;\\n            } else {\\n                m2 -= bits++;\\n            }\\n        }\\n        result[0] = bits;\\n        result[1] = m1;\\n        result[2] = m2;\\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412667,
                "title": "simple-and-clean-10-line-java-solution-88-faster-5ms-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int arr[] = new int[3];\\n        int i=1;\\n        for(i=1;i<=memory1||i<=memory2;i++){\\n            if(memory1>=memory2) memory1-=i;\\n            else memory2-=i;\\n        }\\n        arr[0]=i;\\n        arr[1]=memory1;\\n        arr[2]=memory2;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int arr[] = new int[3];\\n        int i=1;\\n        for(i=1;i<=memory1||i<=memory2;i++){\\n            if(memory1>=memory2) memory1-=i;\\n            else memory2-=i;\\n        }\\n        arr[0]=i;\\n        arr[1]=memory1;\\n        arr[2]=memory2;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389032,
                "title": "straightforward-simulation-python",
                "content": "```\\ndef memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while True:\\n            if i > memory1 and i > memory2:\\n                break\\n            elif memory1 >= i and memory1 >= memory2:\\n                memory1-=i\\n                i+=1\\n            elif memory1 >= i and memory1 < memory2:\\n                memory2 -=i\\n                i+=1\\n            elif memory1 <i :\\n                memory2 -=i\\n                i+=1\\n\\n        return [i, memory1, memory2]\\n",
                "solutionTags": [],
                "code": "```\\ndef memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i = 1\\n        while True:\\n            if i > memory1 and i > memory2:\\n                break\\n            elif memory1 >= i and memory1 >= memory2:\\n                memory1-=i\\n                i+=1\\n            elif memory1 >= i and memory1 < memory2:\\n                memory2 -=i\\n                i+=1\\n            elif memory1 <i :\\n                memory2 -=i\\n                i+=1\\n\\n        return [i, memory1, memory2]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2340149,
                "title": "c-simple-solution",
                "content": "```\\nvector<int> memLeak(int memory1, int memory2) {\\n        int time = 0;\\n        vector<int> ans = {0, 0, 0};\\n        int i = 0;\\n        while (1) {\\n            int one = memory1;\\n            int two = memory2;\\n            if (i > max(one, two)) {\\n                ans[0] = time;\\n                ans[1] = one;\\n                ans[2] = two;\\n                break;\\n            }\\n            if (one >= two) {\\n                one -= i;\\n            } else {\\n                two -= i;\\n            }\\n            ++i;\\n            ++time;\\n            memory1 = one;\\n            memory2 = two;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> memLeak(int memory1, int memory2) {\\n        int time = 0;\\n        vector<int> ans = {0, 0, 0};\\n        int i = 0;\\n        while (1) {\\n            int one = memory1;\\n            int two = memory2;\\n            if (i > max(one, two)) {\\n                ans[0] = time;\\n                ans[1] = one;\\n                ans[2] = two;\\n                break;\\n            }\\n            if (one >= two) {\\n                one -= i;\\n            } else {\\n                two -= i;\\n            }\\n            ++i;\\n            ++time;\\n            memory1 = one;\\n            memory2 = two;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2321074,
                "title": "java-0ms-binary-search-faster-than-100-less-than-88-57",
                "content": "```\\nclass Solution {\\n    int t;\\n    public int[] memLeak(int memory1, int memory2) {\\n        t = 1;\\n        int max = Math.max(memory1, memory2);\\n        int min = Math.min(memory1, memory2);\\n        int dif = max-min;\\n        // Allocate the bigger memory first\\n        if (dif > 0) dif = allocate(dif, 1);\\n        max = dif+min;\\n        int s = t;\\n        // Allocate two memory together\\n        int rem = allocate(max, 2);\\n        int tot = max-rem+(t-s+1)/2;\\n        if (rem < max) {\\n            int tmp = tot;\\n            tot = min >= tot ? tot : tot-t;\\n            t = min >= tmp ? t+1 : t;\\n        }\\n        if (dif == 0) {\\n            return new int[] { t, rem, min-tot };\\n        } else {\\n            return min == memory2 ? new int[] { t, rem, memory2-tot } : new int[] { t, memory1-tot, rem };\\n        }\\n    }\\n    \\n    // mem -> The size of memory that we try to allocate\\n    // step -> each time, we add one \"step\" to occupy the memory\\n    // t (in the filed) -> the start time\\n    // return the remaining memory and also update t (time)\\n    // EX: mem = 11, step = 1, t = 1 -> return 1 and update t to 5 (1+2+3+4=10, return 11-10 and upate t to 5)\\n    // EX: mem = 67, step = 2, t = 20 -> return 1 and update t to 25 (20+22+24=66, return 67-66 and update t to 25)\\n    private int allocate(int mem, int step) {\\n        if (mem < t) return mem;\\n        int minh = 1;\\n        int maxh = mem/t+1;\\n        while (maxh > minh+1) {\\n            int h = (minh+maxh)/2;\\n            long sum = (long) t+t+step*(h-1);\\n            sum *= h;\\n            sum /= 2;\\n            if (sum <= mem) minh = h;\\n            else maxh = h;\\n        }\\n        long sum = (long) t+t+step*(minh-1);\\n        sum *= minh;\\n        sum /= 2;\\n        t += (minh-1)*step+1;\\n        return mem-(int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int t;\\n    public int[] memLeak(int memory1, int memory2) {\\n        t = 1;\\n        int max = Math.max(memory1, memory2);\\n        int min = Math.min(memory1, memory2);\\n        int dif = max-min;\\n        // Allocate the bigger memory first\\n        if (dif > 0) dif = allocate(dif, 1);\\n        max = dif+min;\\n        int s = t;\\n        // Allocate two memory together\\n        int rem = allocate(max, 2);\\n        int tot = max-rem+(t-s+1)/2;\\n        if (rem < max) {\\n            int tmp = tot;\\n            tot = min >= tot ? tot : tot-t;\\n            t = min >= tmp ? t+1 : t;\\n        }\\n        if (dif == 0) {\\n            return new int[] { t, rem, min-tot };\\n        } else {\\n            return min == memory2 ? new int[] { t, rem, memory2-tot } : new int[] { t, memory1-tot, rem };\\n        }\\n    }\\n    \\n    // mem -> The size of memory that we try to allocate\\n    // step -> each time, we add one \"step\" to occupy the memory\\n    // t (in the filed) -> the start time\\n    // return the remaining memory and also update t (time)\\n    // EX: mem = 11, step = 1, t = 1 -> return 1 and update t to 5 (1+2+3+4=10, return 11-10 and upate t to 5)\\n    // EX: mem = 67, step = 2, t = 20 -> return 1 and update t to 25 (20+22+24=66, return 67-66 and update t to 25)\\n    private int allocate(int mem, int step) {\\n        if (mem < t) return mem;\\n        int minh = 1;\\n        int maxh = mem/t+1;\\n        while (maxh > minh+1) {\\n            int h = (minh+maxh)/2;\\n            long sum = (long) t+t+step*(h-1);\\n            sum *= h;\\n            sum /= 2;\\n            if (sum <= mem) minh = h;\\n            else maxh = h;\\n        }\\n        long sum = (long) t+t+step*(minh-1);\\n        sum *= minh;\\n        sum /= 2;\\n        t += (minh-1)*step+1;\\n        return mem-(int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217578,
                "title": "python-simple-easy-solution",
                "content": "**\\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F Up Vote If You Like My Answers \\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F**\\n\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        while True:\\n            if memory1>=memory2 and memory1-i>-1:\\n                memory1-=i\\n            elif memory2>memory1 and memory2-i>-1:\\n                memory2-=i\\n            else:\\n                return [i,memory1,memory2]\\n            i+=1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        while True:\\n            if memory1>=memory2 and memory1-i>-1:\\n                memory1-=i\\n            elif memory2>memory1 and memory2-i>-1:\\n                memory2-=i\\n            else:\\n                return [i,memory1,memory2]\\n            i+=1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190011,
                "title": "c-concise-solution-6-lines",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int t = 1;\\n        for (; t <= m1 || t <= m2; ++t) {\\n            if (m2 > m1) m2 -= t;\\n            else if (m1 >= m2) m1 -= t;\\n        }\\n        return {t, m1, m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int t = 1;\\n        for (; t <= m1 || t <= m2; ++t) {\\n            if (m2 > m1) m2 -= t;\\n            else if (m1 >= m2) m1 -= t;\\n        }\\n        return {t, m1, m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144445,
                "title": "c-explanation-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;  //initializing seconds = bits memory as mentioned in question\\n        while(i <= memory1 || i <= memory2){ //if there is space for i bits in any of the memory device\\n            \\n            if(memory1 == memory2){ //if both memory is equal then consuming i bits in memory stick1\\n                //memory1\\n                memory1 = memory1 - i;\\n            }\\n            else if(memory1 > memory2){ //if memory stick1 is larger\\n                //memory1\\n                memory1 = memory1 - i;\\n            }\\n            else if(memory1 < memory2){ //if memory stick2 is larger\\n                //memory2\\n                memory2 = memory2 - i;\\n            } \\n            i++; //increasing seconds\\n            \\n        }\\n        return {i,memory1,memory2}; //returning crash time and both stick memory\\n    }\\n};\\n```\\n\\n***Please Upvote If You Have Understood The Explaination*** \\uD83D\\uDE01",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;  //initializing seconds = bits memory as mentioned in question\\n        while(i <= memory1 || i <= memory2){ //if there is space for i bits in any of the memory device\\n            \\n            if(memory1 == memory2){ //if both memory is equal then consuming i bits in memory stick1\\n                //memory1\\n                memory1 = memory1 - i;\\n            }\\n            else if(memory1 > memory2){ //if memory stick1 is larger\\n                //memory1\\n                memory1 = memory1 - i;\\n            }\\n            else if(memory1 < memory2){ //if memory stick2 is larger\\n                //memory2\\n                memory2 = memory2 - i;\\n            } \\n            i++; //increasing seconds\\n            \\n        }\\n        return {i,memory1,memory2}; //returning crash time and both stick memory\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136686,
                "title": "scala-solution",
                "content": "```\\n\\n  def memLeak(memory1: Int, memory2: Int): Array[Int] = {\\n    def help(m1: Int, m2: Int, i: Int): Array[Int] = {\\n      if(m1 < i && m2 < i) return Array(i, m1, m2)\\n      m1 >= m2 match {\\n        case true => help(m1 - i, m2, i + 1)\\n        case _ => help(m1, m2 - i, i + 1)\\n      }\\n    }\\n    help(memory1, memory2, 1)\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def memLeak(memory1: Int, memory2: Int): Array[Int] = {\\n    def help(m1: Int, m2: Int, i: Int): Array[Int] = {\\n      if(m1 < i && m2 < i) return Array(i, m1, m2)\\n      m1 >= m2 match {\\n        case true => help(m1 - i, m2, i + 1)\\n        case _ => help(m1, m2 - i, i + 1)\\n      }\\n    }\\n    help(memory1, memory2, 1)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2134026,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def memLeak(self, a: int, b: int) -> List[int]:\\n        i=1\\n        while True:\\n            if i>max(a,b):\\n                return [i,a,b]\\n            if a>=b:\\n                a-=i\\n            else:\\n                b-=i\\n            i+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def memLeak(self, a: int, b: int) -> List[int]:\\n        i=1\\n        while True:\\n            if i>max(a,b):\\n                return [i,a,b]\\n            if a>=b:\\n                a-=i\\n            else:\\n                b-=i\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048589,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        PriorityQueue<Wrapper> maxHeap = new PriorityQueue<Wrapper>((a, b) -> {\\n            return a.mem == b.mem ? a.seq - b.seq : b.mem - a.mem;\\n        });\\n           \\n        maxHeap.offer(new Wrapper(memory1, 0));\\n        maxHeap.offer(new Wrapper(memory2, 1));\\n        int counter = 1;\\n        int [] result = new int[3];\\n        \\n        while(maxHeap.size () > 1) {\\n            if(maxHeap.peek().mem < counter) {\\n                break;\\n            }\\n            Wrapper wrap = maxHeap.poll();\\n            maxHeap.offer(new Wrapper(wrap.mem - counter, wrap.seq));\\n            counter++;\\n        }\\n        \\n        Wrapper first = maxHeap.poll(), second = maxHeap.poll();\\n        return (first.seq < second.seq) ? \\n            new int[]{counter, first.mem, second.mem} : new int[]{counter, second.mem, first.mem};\\n    }\\n    \\n    private class Wrapper {\\n        int mem;\\n        int seq;\\n        \\n        Wrapper(int mem, int seq) {\\n            this.mem = mem;\\n            this.seq = seq;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        PriorityQueue<Wrapper> maxHeap = new PriorityQueue<Wrapper>((a, b) -> {\\n            return a.mem == b.mem ? a.seq - b.seq : b.mem - a.mem;\\n        });\\n           \\n        maxHeap.offer(new Wrapper(memory1, 0));\\n        maxHeap.offer(new Wrapper(memory2, 1));\\n        int counter = 1;\\n        int [] result = new int[3];\\n        \\n        while(maxHeap.size () > 1) {\\n            if(maxHeap.peek().mem < counter) {\\n                break;\\n            }\\n            Wrapper wrap = maxHeap.poll();\\n            maxHeap.offer(new Wrapper(wrap.mem - counter, wrap.seq));\\n            counter++;\\n        }\\n        \\n        Wrapper first = maxHeap.poll(), second = maxHeap.poll();\\n        return (first.seq < second.seq) ? \\n            new int[]{counter, first.mem, second.mem} : new int[]{counter, second.mem, first.mem};\\n    }\\n    \\n    private class Wrapper {\\n        int mem;\\n        int seq;\\n        \\n        Wrapper(int mem, int seq) {\\n            this.mem = mem;\\n            this.seq = seq;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961590,
                "title": "c-100-effecient-solution",
                "content": "< -----   Just simulate the process ------ >\\n\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> memLeak(int a, int b) {\\n        int mem = 1;\\n        \\n        while(true){\\n            if(max(a, b) < mem)break;\\n            \\n            if(a >= b)a -= mem;\\n            else b -= mem;\\n            \\n            mem++;\\n            \\n        }\\n        \\n        return {mem, a, b};\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<int> memLeak(int a, int b) {\\n        int mem = 1;\\n        \\n        while(true){\\n            if(max(a, b) < mem)break;\\n            \\n            if(a >= b)a -= mem;\\n            else b -= mem;\\n            \\n            mem++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1917467,
                "title": "java-iterative-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int time = 1;\\n        while(true) {\\n            if(memory1 >= memory2 && memory1 >= time) {\\n                memory1 -= time++;\\n            } else if(memory2 > memory1 && memory2 >= time) {\\n                memory2 -= time++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return new int[]{time, memory1, memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int time = 1;\\n        while(true) {\\n            if(memory1 >= memory2 && memory1 >= time) {\\n                memory1 -= time++;\\n            } else if(memory2 > memory1 && memory2 >= time) {\\n                memory2 -= time++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return new int[]{time, memory1, memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914234,
                "title": "o-log-max-m1-m2-linear-complexity-in-the-size-of-the-input-12ms",
                "content": "lets say n = max(m1,m2)\\nfirst note that the trivial simulation code runs in sqrt(n) time. \\nwhy?\\nbecause we do something like 1 + 2 + 3 +.. until the sum is larger than n.\\nhow much iterations is it?\\nrecall Gauss formula for arythmetic progression : sum = (a1 + an) * n / 2 = S, in our case (1 + num_iter) * num_iter / 2 = S --> (-1 + sqrt(1 + 8n)) / 2 --> num_iter is O(sqrt(n)).\\nanother thing to note is that the input is just a number n (not an array of size n), the number n is represented by the binary input of size B =  log(n) , therefore the complexity of the trivial simulation solution is O(sqrt(2^B)) which is exponential in the size of the input.\\n\\nBut we dont really need to do the simulation!\\nWe can use the above Gauss formula to calculate everything.\\nassume m1 > m2.\\n\\nstep 1:\\nfirst we check after how much seconds m1 will become smaller or equal to m2 using Gauss formula for arythmetic progression with delta 1.\\nstep 2:\\nnow we check after how much seconds m1 and m2 will be exhausted using using Gauss formula for arythmetic progression with delta 2.\\nnote that here every time we allocate from different stick, hence the delta is 2.\\n\\nfor step 1 and step 2 we need to apply the function sqrt() some consant amount of time. The function sqrt(n) can be implemented (I hope it indeed is) in O(log(n))\\nso  time complexity is O(log(n)), if we return back to the observation that n is represented by O(log(n)) bytes then we get that our complexity is linear in the size of the input.\\n\\nHere is the VERY ugly working code I wrote. (too late in the evening for elegancy)\\n\\n```\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m1, m2 = memory1, memory2\\n        timeUntilPassing = int(math.ceil((-1 + math.sqrt(1 + 8*abs(m1 - m2))) / 2))\\n        if (m1 >= m2):\\n            m1 -= (((1 + timeUntilPassing) * timeUntilPassing) / 2)\\n        else:\\n            m2 -= (((1 + timeUntilPassing) * timeUntilPassing) / 2)\\n        \\n        if m1 < 0:    \\n            return [timeUntilPassing, m1 + timeUntilPassing, m2]\\n        if m2 < 0:\\n            return [timeUntilPassing, m1, m2 + timeUntilPassing]\\n        \\n        (firstAllocationFromM2, firstAllocationFromM1)= (timeUntilPassing + 1, timeUntilPassing + 2) if (m2 > m1) else (timeUntilPassing + 2, timeUntilPassing + 1)\\n        numberAllocationsUntilM2NegativeFloat = ((1-firstAllocationFromM2 + math.sqrt((firstAllocationFromM2 - 1)**2 + 4 * m2 )) / 2)\\n        numberAllocationsUntilM2NegativeInt = int(math.ceil(numberAllocationsUntilM2NegativeFloat))\\n        if numberAllocationsUntilM2NegativeInt == numberAllocationsUntilM2NegativeFloat:\\n            numberAllocationsUntilM2NegativeInt += 1\\n            \\n        numberAllocationsUntilM1NegativeFloat = ((1-firstAllocationFromM1 + math.sqrt((firstAllocationFromM1 - 1)**2 + 4 * m1 )) / 2)\\n        numberAllocationsUntilM1NegativeInt = int(math.ceil(numberAllocationsUntilM1NegativeFloat))\\n        if numberAllocationsUntilM1NegativeInt == numberAllocationsUntilM1NegativeFloat:\\n            numberAllocationsUntilM1NegativeInt += 1    \\n        \\n        m1 -= (((firstAllocationFromM1 + firstAllocationFromM1 + 2 * (numberAllocationsUntilM1NegativeInt - 2)) * (numberAllocationsUntilM1NegativeInt - 1)) / 2)\\n        m2 -= (((firstAllocationFromM2 + firstAllocationFromM2 + 2 * (numberAllocationsUntilM2NegativeInt - 2)) * (numberAllocationsUntilM2NegativeInt - 1)) / 2)\\n            \\n        return [timeUntilPassing + numberAllocationsUntilM2NegativeInt +  numberAllocationsUntilM1NegativeInt - 1, m1, m2]\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def memLeak(self, memory1, memory2):\\n        \"\"\"\\n        :type memory1: int\\n        :type memory2: int\\n        :rtype: List[int]\\n        \"\"\"\\n        m1, m2 = memory1, memory2\\n        timeUntilPassing = int(math.ceil((-1 + math.sqrt(1 + 8*abs(m1 - m2))) / 2))\\n        if (m1 >= m2):\\n            m1 -= (((1 + timeUntilPassing) * timeUntilPassing) / 2)\\n        else:\\n            m2 -= (((1 + timeUntilPassing) * timeUntilPassing) / 2)\\n        \\n        if m1 < 0:    \\n            return [timeUntilPassing, m1 + timeUntilPassing, m2]\\n        if m2 < 0:\\n            return [timeUntilPassing, m1, m2 + timeUntilPassing]\\n        \\n        (firstAllocationFromM2, firstAllocationFromM1)= (timeUntilPassing + 1, timeUntilPassing + 2) if (m2 > m1) else (timeUntilPassing + 2, timeUntilPassing + 1)\\n        numberAllocationsUntilM2NegativeFloat = ((1-firstAllocationFromM2 + math.sqrt((firstAllocationFromM2 - 1)**2 + 4 * m2 )) / 2)\\n        numberAllocationsUntilM2NegativeInt = int(math.ceil(numberAllocationsUntilM2NegativeFloat))\\n        if numberAllocationsUntilM2NegativeInt == numberAllocationsUntilM2NegativeFloat:\\n            numberAllocationsUntilM2NegativeInt += 1\\n            \\n        numberAllocationsUntilM1NegativeFloat = ((1-firstAllocationFromM1 + math.sqrt((firstAllocationFromM1 - 1)**2 + 4 * m1 )) / 2)\\n        numberAllocationsUntilM1NegativeInt = int(math.ceil(numberAllocationsUntilM1NegativeFloat))\\n        if numberAllocationsUntilM1NegativeInt == numberAllocationsUntilM1NegativeFloat:\\n            numberAllocationsUntilM1NegativeInt += 1    \\n        \\n        m1 -= (((firstAllocationFromM1 + firstAllocationFromM1 + 2 * (numberAllocationsUntilM1NegativeInt - 2)) * (numberAllocationsUntilM1NegativeInt - 1)) / 2)\\n        m2 -= (((firstAllocationFromM2 + firstAllocationFromM2 + 2 * (numberAllocationsUntilM2NegativeInt - 2)) * (numberAllocationsUntilM2NegativeInt - 1)) / 2)\\n            \\n        return [timeUntilPassing + numberAllocationsUntilM2NegativeInt +  numberAllocationsUntilM1NegativeInt - 1, m1, m2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904772,
                "title": "javascript-solution-simulation",
                "content": "```\\n\\nvar memLeak = function(memory1, memory2) {\\n    let sec = 1;\\n    \\n    while (true) {\\n        if (memory1 < sec && memory2 < sec) {\\n            return [sec, memory1, memory2];\\n        }\\n        \\n        if (memory1 >= memory2) {\\n            memory1 -= sec;\\n        }\\n        else {\\n            memory2 -= sec;\\n        }\\n        \\n        sec++;\\n    }\\n    \\n    return;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```\\n\\nvar memLeak = function(memory1, memory2) {\\n    let sec = 1;\\n    \\n    while (true) {\\n        if (memory1 < sec && memory2 < sec) {\\n            return [sec, memory1, memory2];\\n        }\\n        \\n        if (memory1 >= memory2) {\\n            memory1 -= sec;\\n        }\\n        else {\\n            memory2 -= sec;\\n        }\\n        \\n        sec++;\\n    }\\n    \\n    return;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1895757,
                "title": "c-very-easy-solution-very-short-comments",
                "content": "Bruteforce simulating the allocation until the crash will happen:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int time = 1; // time == memory_request, so only keep track of the time\\n        while (1) {\\n            // Figure out which memory to use\\n            int* bigger = (memory2 > memory1) ? &memory2 : &memory1;\\n            \\n            // If the allocation request is too much for the biggest memory, then crash\\n            if (*bigger < time) return {time, memory1, memory2};\\n            \\n            // Subtract the requested memory size (which is the same as the time)\\n            *bigger = *bigger - time;                \\n\\n            // Increment the time and the new request for more memory\\n            time++;\\n        }        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int time = 1; // time == memory_request, so only keep track of the time\\n        while (1) {\\n            // Figure out which memory to use\\n            int* bigger = (memory2 > memory1) ? &memory2 : &memory1;\\n            \\n            // If the allocation request is too much for the biggest memory, then crash\\n            if (*bigger < time) return {time, memory1, memory2};\\n            \\n            // Subtract the requested memory size (which is the same as the time)\\n            *bigger = *bigger - time;                \\n\\n            // Increment the time and the new request for more memory\\n            time++;\\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879335,
                "title": "c-priorityqueue-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        priority_queue<pair<int,int>> pq ; pq.push({memory1,1}) ; pq.push({memory2,0}) ;\\n        \\n        for(int i = 1 ; ; ++i){\\n            int Maxi = pq.top().first ;\\n            int number = pq.top().second ;\\n            pq.pop() ;\\n            if(Maxi < i){\\n                //crash \\n                int secondMaxi = pq.top().first ;pq.pop() ;\\n                return {i,number==1?Maxi:secondMaxi,number==0?Maxi:secondMaxi} ;\\n            }\\n            Maxi -= i ;\\n            pq.push({Maxi,number}) ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        priority_queue<pair<int,int>> pq ; pq.push({memory1,1}) ; pq.push({memory2,0}) ;\\n        \\n        for(int i = 1 ; ; ++i){\\n            int Maxi = pq.top().first ;\\n            int number = pq.top().second ;\\n            pq.pop() ;\\n            if(Maxi < i){\\n                //crash \\n                int secondMaxi = pq.top().first ;pq.pop() ;\\n                return {i,number==1?Maxi:secondMaxi,number==0?Maxi:secondMaxi} ;\\n            }\\n            Maxi -= i ;\\n            pq.push({Maxi,number}) ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869619,
                "title": "elixir-simple-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @spec mem_leak(memory1 :: integer, memory2 :: integer) :: [integer]\\n  def mem_leak(memory1, memory2) do\\n    mem_leak(1, memory1, memory2)\\n  end\\n\\n  def mem_leak(i, memory1, memory2) do\\n    cond do\\n      i > memory1 and i > memory2 -> [i, memory1, memory2]\\n      memory1 >= memory2 -> mem_leak(i + 1, memory1 - i, memory2)\\n      true -> mem_leak(i + 1, memory1, memory2 - i)\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```elixir\\ndefmodule Solution do\\n  @spec mem_leak(memory1 :: integer, memory2 :: integer) :: [integer]\\n  def mem_leak(memory1, memory2) do\\n    mem_leak(1, memory1, memory2)\\n  end\\n\\n  def mem_leak(i, memory1, memory2) do\\n    cond do\\n      i > memory1 and i > memory2 -> [i, memory1, memory2]\\n      memory1 >= memory2 -> mem_leak(i + 1, memory1 - i, memory2)\\n      true -> mem_leak(i + 1, memory1, memory2 - i)\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1835398,
                "title": "java-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while (Math.max(memory1, memory2) >= i) {\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return new int[]{i, memory1, memory2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while (Math.max(memory1, memory2) >= i) {\\n            if (memory1 >= memory2) {\\n                memory1 -= i;\\n            } else {\\n                memory2 -= i;\\n            }\\n            i++;\\n        }\\n        return new int[]{i, memory1, memory2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830046,
                "title": "why-is-this-problem-marked-as-medium-in-leetcode",
                "content": "This was really easy to solve",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1827316,
                "title": "easy-sol-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        vector<int>v(3);\\n        while(m1-i>=0 || m2-i>=0){\\n            if(m1>=m2){\\n                m1-=i;\\n            }else{\\n                m2-=i;\\n            }\\n            i++;\\n        }\\n        v[0]=i;v[1]=m1;v[2]=m2;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        vector<int>v(3);\\n        while(m1-i>=0 || m2-i>=0){\\n            if(m1>=m2){\\n                m1-=i;\\n            }else{\\n                m2-=i;\\n            }\\n            i++;\\n        }\\n        v[0]=i;v[1]=m1;v[2]=m2;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809161,
                "title": "c-10-lines",
                "content": "```\\n vector<int> memLeak(int memory1, int memory2) {       \\n        int t = 1;\\n        while (memory1 >= t || memory2 >= t) {            \\n            if (memory1 >= memory2) {\\n                memory1 -= t;\\n            } else {\\n                memory2 -= t;\\n            }\\n            ++t;                              \\n        }        \\n        return {t, memory1, memory2};\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<int> memLeak(int memory1, int memory2) {       \\n        int t = 1;\\n        while (memory1 >= t || memory2 >= t) {            \\n            if (memory1 >= memory2) {\\n                memory1 -= t;\\n            } else {\\n                memory2 -= t;\\n            }\\n            ++t;                              \\n        }        \\n        return {t, memory1, memory2};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1798085,
                "title": "easy-solution-in-java",
                "content": "class Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(true)\\n        {\\n            if(memory2>memory1)\\n            {\\n                if(memory2>=i)\\n                {\\n                memory2=memory2-i;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else\\n            {\\n                 if(memory1>=i)\\n                {\\n                memory1=memory1-i;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        int arr[]=new int[3];\\n        arr[0]=i;\\n        arr[1]=memory1;\\n        arr[2]=memory2;\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] memLeak(int memory1, int memory2) {\\n        int i=1;\\n        while(true)\\n        {\\n            if(memory2>memory1)\\n            {\\n                if(memory2>=i)\\n                {\\n                memory2=memory2-i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1793062,
                "title": "easy-c-solution",
                "content": "```\\nvector<int> memLeak(int memory1, int memory2)\\n{\\n    int stick1 = 0, stick2 = 0, timer = 0, currentMemoryNeeded = 1;\\n    while (true)\\n    {\\n        timer++;\\n\\n        if (memory1 >= memory2)\\n        {\\n            if (currentMemoryNeeded > memory1)\\n                break;\\n            else\\n            {\\n                stick1 = stick1 + currentMemoryNeeded;\\n                memory1 = memory1 - currentMemoryNeeded;\\n                currentMemoryNeeded++;\\n            }\\n        }\\n        else\\n        {\\n            if (currentMemoryNeeded > memory2)\\n                break;\\n            else\\n            {\\n                stick2 = stick2 + currentMemoryNeeded;\\n                memory2 = memory2 - currentMemoryNeeded;\\n                currentMemoryNeeded++;\\n            }\\n        }\\n    }\\n\\n    vector<int> ans(3, 0);\\n    ans[0] = timer;\\n    ans[1] = memory1;\\n    ans[2] = memory2;\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> memLeak(int memory1, int memory2)\\n{\\n    int stick1 = 0, stick2 = 0, timer = 0, currentMemoryNeeded = 1;\\n    while (true)\\n    {\\n        timer++;\\n\\n        if (memory1 >= memory2)\\n        {\\n            if (currentMemoryNeeded > memory1)\\n                break;\\n            else\\n            {\\n                stick1 = stick1 + currentMemoryNeeded;\\n                memory1 = memory1 - currentMemoryNeeded;\\n                currentMemoryNeeded++;\\n            }\\n        }\\n        else\\n        {\\n            if (currentMemoryNeeded > memory2)\\n                break;\\n            else\\n            {\\n                stick2 = stick2 + currentMemoryNeeded;\\n                memory2 = memory2 - currentMemoryNeeded;\\n                currentMemoryNeeded++;\\n            }\\n        }\\n    }\\n\\n    vector<int> ans(3, 0);\\n    ans[0] = timer;\\n    ans[1] = memory1;\\n    ans[2] = memory2;\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779368,
                "title": "c-short-easy-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(i<=m1 || i<=m2){\\n            if(m1>=m2)m1-=i;\\n            else m2-=i;\\n            i++;\\n        }\\n        return {i,m1,m2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(i<=m1 || i<=m2){\\n            if(m1>=m2)m1-=i;\\n            else m2-=i;\\n            i++;\\n        }\\n        return {i,m1,m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738326,
                "title": "javascript-w-map-memoization",
                "content": "```\\nvar memLeak = function(memory1, memory2) {\\n  let memorySticks = new Map()\\n  memorySticks.set(\\'firstStick\\',memory1)\\n  memorySticks.set(\\'secondStick\\',memory2)\\n  let time = 0\\n  \\n  while (memorySticks.size) {\\n    time++\\n    let firstStick = memorySticks.get(\\'firstStick\\')\\n    let secondStick = memorySticks.get(\\'secondStick\\')\\n    // console.log({ memorySticks, firstStick, secondStick, time})\\n    if (firstStick >= secondStick) {\\n      if (time <= firstStick) {\\n        memorySticks.set(\\'firstStick\\', firstStick-time)\\n      } else {\\n        return [time,firstStick,secondStick]\\n      }\\n    } else if (firstStick < secondStick) {\\n      if (time <= secondStick) {\\n        memorySticks.set(\\'secondStick\\', secondStick - time)\\n      } else {\\n        return [time,firstStick,secondStick]\\n      }\\n    }\\n    \\n  }\\n    \\n  };\\n  ```",
                "solutionTags": [],
                "code": "```\\nvar memLeak = function(memory1, memory2) {\\n  let memorySticks = new Map()\\n  memorySticks.set(\\'firstStick\\',memory1)\\n  memorySticks.set(\\'secondStick\\',memory2)\\n  let time = 0\\n  \\n  while (memorySticks.size) {\\n    time++\\n    let firstStick = memorySticks.get(\\'firstStick\\')\\n    let secondStick = memorySticks.get(\\'secondStick\\')\\n    // console.log({ memorySticks, firstStick, secondStick, time})\\n    if (firstStick >= secondStick) {\\n      if (time <= firstStick) {\\n        memorySticks.set(\\'firstStick\\', firstStick-time)\\n      } else {\\n        return [time,firstStick,secondStick]\\n      }\\n    } else if (firstStick < secondStick) {\\n      if (time <= secondStick) {\\n        memorySticks.set(\\'secondStick\\', secondStick - time)\\n      } else {\\n        return [time,firstStick,secondStick]\\n      }\\n    }\\n    \\n  }\\n    \\n  };\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1728526,
                "title": "c-solution-runtime-4-ms-memory-usage-5-8-mb",
                "content": "The fun thing is that everytime I submit the same code again, the runtime and memory usage is always different.\\nAnyway, simple solution.\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1;\\n    // int total = memory1 + memory2;\\n    *returnSize = 3;\\n    int * returnArray = malloc(sizeof(int) * *returnSize);\\n    \\n    while(memory1 >= i || memory2 >= i){\\n        if(memory2 > memory1){\\n            memory2 -= i;\\n        }\\n        else{\\n            memory1 -= i;\\n        }\\n        // total -= i;\\n        i++;\\n        // printf(\"i : %d m1 : %d m2 : %d total : %d\\\\n\",i,memory1,memory2,total);\\n    }\\n    \\n    returnArray[0] = i;\\n    returnArray[1] = memory1;\\n    returnArray[2] = memory2;\\n    return returnArray;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* memLeak(int memory1, int memory2, int* returnSize){\\n    int i = 1;\\n    // int total = memory1 + memory2;\\n    *returnSize = 3;\\n    int * returnArray = malloc(sizeof(int) * *returnSize);\\n    \\n    while(memory1 >= i || memory2 >= i){\\n        if(memory2 > memory1){\\n            memory2 -= i;\\n        }\\n        else{\\n            memory1 -= i;\\n        }\\n        // total -= i;\\n        i++;\\n        // printf(\"i : %d m1 : %d m2 : %d total : %d\\\\n\",i,memory1,memory2,total);\\n    }\\n    \\n    returnArray[0] = i;\\n    returnArray[1] = memory1;\\n    returnArray[2] = memory2;\\n    return returnArray;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714507,
                "title": "everybody-is-wrong-and-somehow-right",
                "content": "everybody comes to algorithm with decreasing largest left \"memory\", but nobody explains why this is optimal... seems nobody has a clue - just lucky guessing, I guess :)\\nbesides other solutions will produce the same \"seconds to crash\", but leaving different, from \"accepted\", numbers on \"sticks\" - let me guess one more time - the problem is ill-defined and/or ill-judged :)",
                "solutionTags": [],
                "code": "everybody comes to algorithm with decreasing largest left \"memory\", but nobody explains why this is optimal... seems nobody has a clue - just lucky guessing, I guess :)\\nbesides other solutions will produce the same \"seconds to crash\", but leaving different, from \"accepted\", numbers on \"sticks\" - let me guess one more time - the problem is ill-defined and/or ill-judged :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1656371,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        turn=1 if memory1>=memory2 else 2\\n        while memory1>=0 and memory2>=0:\\n            if turn==1: \\n                if memory1-i<0: return [i,memory1,memory2]\\n                memory1-=i\\n            else: \\n                if memory2-i<0: return [i,memory1,memory2]\\n                memory2-=i\\n            turn=1 if memory1>=memory2 else 2\\n            i+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        i=1\\n        turn=1 if memory1>=memory2 else 2\\n        while memory1>=0 and memory2>=0:\\n            if turn==1: \\n                if memory1-i<0: return [i,memory1,memory2]\\n                memory1-=i\\n            else: \\n                if memory2-i<0: return [i,memory1,memory2]\\n                memory2-=i\\n            turn=1 if memory1>=memory2 else 2\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644581,
                "title": "c-simulation",
                "content": "```\\n\\tpublic int[] MemLeak(int memory1, int memory2) {\\n        int seconds = 1;\\n        while (Math.Max(memory1, memory2) >= seconds) {\\n            if (memory1 >= memory2) \\n                memory1 -= seconds;\\n            else \\n                memory2 -= seconds;\\n            seconds++;\\n        }\\n        return new int[3]{seconds, memory1, memory2};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[] MemLeak(int memory1, int memory2) {\\n        int seconds = 1;\\n        while (Math.Max(memory1, memory2) >= seconds) {\\n            if (memory1 >= memory2) \\n                memory1 -= seconds;\\n            else \\n                memory2 -= seconds;\\n            seconds++;\\n        }\\n        return new int[3]{seconds, memory1, memory2};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611768,
                "title": "python-very-easy-to-understand",
                "content": "If either memory 1 or memory 2 exist, subtract the count from the one thats larger. If the one thats larger is greater than the count(time/bits) then that  means its a crash. so return the values. Edge case is when both are null. you return 1,0,0\\n```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        count = 0\\n        while memory1 or memory2:\\n            count +=1\\n            if memory1 >= memory2:\\n                if memory1-count >= 0:\\n                    memory1 -= count\\n                else:\\n                    return [count, memory1, memory2] \\n            else:\\n                if memory2-count >= 0:\\n                    memory2 -= count\\n                else:\\n                    return [count, memory1, memory2] \\n        return [1,0,0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def memLeak(self, memory1: int, memory2: int) -> List[int]:\\n        count = 0\\n        while memory1 or memory2:\\n            count +=1\\n            if memory1 >= memory2:\\n                if memory1-count >= 0:\\n                    memory1 -= count\\n                else:\\n                    return [count, memory1, memory2] \\n            else:\\n                if memory2-count >= 0:\\n                    memory2 -= count\\n                else:\\n                    return [count, memory1, memory2] \\n        return [1,0,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600981,
                "title": "c-simulating-the-process",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i;\\n        for(i=1; i<=memory1 || i<=memory2; i++) {\\n            if(memory1 >= memory2) memory1 -= i;\\n            else memory2 -= i;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int memory1, int memory2) {\\n        int i;\\n        for(i=1; i<=memory1 || i<=memory2; i++) {\\n            if(memory1 >= memory2) memory1 -= i;\\n            else memory2 -= i;\\n        }\\n        return {i, memory1, memory2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592916,
                "title": "c-best-solution-shortest-solution",
                "content": "```\\nvector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(i <= memory1 || i <= memory2){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            \\n            else\\n                memory2 -= i;\\n            \\n            i++;  \\n        }\\n        \\n        vector<int>res(3,-1);\\n        res[0] = i,res[1] = memory1,res[2] = memory2;\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> memLeak(int memory1, int memory2) {\\n        int i = 1;\\n        while(i <= memory1 || i <= memory2){\\n            if(memory1 >= memory2)\\n                memory1 -= i;\\n            \\n            else\\n                memory2 -= i;\\n            \\n            i++;  \\n        }\\n        \\n        vector<int>res(3,-1);\\n        res[0] = i,res[1] = memory1,res[2] = memory2;\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581387,
                "title": "go-simulation-0ms",
                "content": "```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    i := 1\\n    for {\\n        if memory1 < memory2 {\\n            // pick memory2\\n            if i > memory2 {\\n                break\\n            }\\n            memory2 -= i\\n        } else {\\n            // pick memory1\\n            if i > memory1 {\\n                break\\n            } \\n            memory1 -= i\\n        }\\n        i++\\n    } \\n    return []int{i, memory1, memory2}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc memLeak(memory1 int, memory2 int) []int {\\n    i := 1\\n    for {\\n        if memory1 < memory2 {\\n            // pick memory2\\n            if i > memory2 {\\n                break\\n            }\\n            memory2 -= i\\n        } else {\\n            // pick memory1\\n            if i > memory1 {\\n                break\\n            } \\n            memory1 -= i\\n        }\\n        i++\\n    } \\n    return []int{i, memory1, memory2}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570502,
                "title": "c-solution",
                "content": "Simple Solution:\\nTIME: O(N), one pass\\nSpace: O(1), no extra space used\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(i) {\\n            if (m1 == m2) {\\n                m1 -= i;\\n            }\\n            else if (m1 > m2) {\\n                m1 -= i;\\n            }\\n            else {\\n                m2 -= i;\\n            }\\n            if (m1 < 0 || m2 < 0) {\\n                return {i, m1<0? m1+i : m1, m2<0? m2+i : m2};\\n            }\\n            i++;\\n        }\\n        \\n        return {0, m1, m2};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> memLeak(int m1, int m2) {\\n        int i=1;\\n        while(i) {\\n            if (m1 == m2) {\\n                m1 -= i;\\n            }\\n            else if (m1 > m2) {\\n                m1 -= i;\\n            }\\n            else {\\n                m2 -= i;\\n            }\\n            if (m1 < 0 || m2 < 0) {\\n                return {i, m1<0? m1+i : m1, m2<0? m2+i : m2};\\n            }\\n            i++;\\n        }\\n        \\n        return {0, m1, m2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528557,
                "title": "typescript-solution",
                "content": "```\\nfunction memLeak(memory1: number, memory2: number): number[] {\\n    let i = 1;\\n    const crashInfo = [\\n        1,\\n        memory1,\\n        memory2,\\n    ];\\n    let isCrash = false;\\n    \\n    while (!isCrash) {\\n        if (crashInfo[1] - i >= 0  || crashInfo[2] - i >= 0) {\\n            crashInfo[0] = i;\\n            if (crashInfo[1] >= crashInfo[2]) {\\n                crashInfo[1] = crashInfo[1] - i;\\n            } else {\\n                crashInfo[2] = crashInfo[2] - i;\\n            }\\n        } else {\\n            crashInfo[0] = i;\\n            isCrash = true;\\n        }\\n\\n        i++;\\n    }\\n\\n    return crashInfo;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction memLeak(memory1: number, memory2: number): number[] {\\n    let i = 1;\\n    const crashInfo = [\\n        1,\\n        memory1,\\n        memory2,\\n    ];\\n    let isCrash = false;\\n    \\n    while (!isCrash) {\\n        if (crashInfo[1] - i >= 0  || crashInfo[2] - i >= 0) {\\n            crashInfo[0] = i;\\n            if (crashInfo[1] >= crashInfo[2]) {\\n                crashInfo[1] = crashInfo[1] - i;\\n            } else {\\n                crashInfo[2] = crashInfo[2] - i;\\n            }\\n        } else {\\n            crashInfo[0] = i;\\n            isCrash = true;\\n        }\\n\\n        i++;\\n    }\\n\\n    return crashInfo;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568568,
                "content": [
                    {
                        "username": "IamVaibhave53",
                        "content": "Is there anything better than O(n)?"
                    },
                    {
                        "username": "abductcows",
                        "content": "https://leetcode.com/problems/incremental-memory-leak/solutions/3206246/it-can-be-done-in-o-1-2sqrt-calls-using-math/"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "how is this a medium"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "Should be in Easy"
                    }
                ]
            },
            {
                "id": 1725860,
                "content": [
                    {
                        "username": "IamVaibhave53",
                        "content": "Is there anything better than O(n)?"
                    },
                    {
                        "username": "abductcows",
                        "content": "https://leetcode.com/problems/incremental-memory-leak/solutions/3206246/it-can-be-done-in-o-1-2sqrt-calls-using-math/"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "how is this a medium"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "Should be in Easy"
                    }
                ]
            },
            {
                "id": 1760140,
                "content": [
                    {
                        "username": "IamVaibhave53",
                        "content": "Is there anything better than O(n)?"
                    },
                    {
                        "username": "abductcows",
                        "content": "https://leetcode.com/problems/incremental-memory-leak/solutions/3206246/it-can-be-done-in-o-1-2sqrt-calls-using-math/"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "how is this a medium"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "Should be in Easy"
                    }
                ]
            }
        ]
    }
]