[
    {
        "title": "Max Consecutive Ones",
        "question_content": "Given a binary array nums, return the maximum number of consecutive 1's in the array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\nExample 2:\n\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\tnums[i] is either 0 or 1.",
        "solutions": [
            {
                "id": 96693,
                "title": "java-4-lines-concise-solution-with-explanation",
                "content": "\\n```\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxHere = 0, max = 0;\\n        for (int n : nums)\\n            max = Math.max(max, maxHere = n == 0 ? 0 : maxHere + 1);\\n        return max; \\n    } \\n```\\n\\nThe idea is to reset ```maxHere``` to 0 if we see 0, otherwise increase ```maxHere``` by 1\\nThe max of all ```maxHere``` is the solution\\n\\n```\\n110111\\n^ maxHere = 1\\n\\n110111\\n.^ maxHere = 2\\n\\n110111\\n..^ maxHere = 0\\n\\n110111\\n...^ maxHere = 1\\n\\n110111\\n....^ maxHere = 2\\n\\n110111\\n.....^ maxHere = 3\\n```\\n\\nWe can also solve this problem by setting ```k = 0``` of [Max Consecutive Ones II](https://discuss.leetcode.com/topic/75445/java-clean-solution-easily-extensible-to-flipping-k-zero-and-follow-up-handled)",
                "solutionTags": [],
                "code": "```\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxHere = 0, max = 0;\\n        for (int n : nums)\\n            max = Math.max(max, maxHere = n == 0 ? 0 : maxHere + 1);\\n        return max; \\n    } \\n```\n```maxHere```\n```maxHere```\n```maxHere```\n```\\n110111\\n^ maxHere = 1\\n\\n110111\\n.^ maxHere = 2\\n\\n110111\\n..^ maxHere = 0\\n\\n110111\\n...^ maxHere = 1\\n\\n110111\\n....^ maxHere = 2\\n\\n110111\\n.....^ maxHere = 3\\n```\n```k = 0```",
                "codeTag": "Unknown"
            },
            {
                "id": 96715,
                "title": "easy-java-solution",
                "content": "This is a really easy problem. No explanation :)\\n```\\npublic class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int result = 0;\\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n        \\tcount++;\\n        \\tresult = Math.max(count, result);\\n            }\\n            else count = 0;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int result = 0;\\n        int count = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 1) {\\n        \\tcount++;\\n        \\tresult = Math.max(count, result);\\n            }\\n            else count = 0;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96712,
                "title": "simple-python",
                "content": "\\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        cnt = 0\\n        ans = 0\\n        for num in nums:\\n            if num == 1:\\n                cnt += 1\\n                ans = max(ans, cnt)\\n            else:\\n                cnt = 0\\n        return ans\\n```\\n\\n\\nFYI: pomodoro timer helps to obtain higher time ROI:  [e-tomato.online](http://e-tomato.online)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        cnt = 0\\n        ans = 0\\n        for num in nums:\\n            if num == 1:\\n                cnt += 1\\n                ans = max(ans, cnt)\\n            else:\\n                cnt = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96742,
                "title": "simple-c-code",
                "content": "```\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max_cnt = 0, cnt = 0;\\n        for (auto n : nums) {\\n            if (n == 1) max_cnt = max(++cnt, max_cnt);\\n            else cnt = 0;\\n        }\\n        return max_cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max_cnt = 0, cnt = 0;\\n        for (auto n : nums) {\\n            if (n == 1) max_cnt = max(++cnt, max_cnt);\\n            else cnt = 0;\\n        }\\n        return max_cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96807,
                "title": "concise-java-solution-without-if",
                "content": "```\\npublic class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxSum = 0, sum = 0;\\n        for (int n : nums) {\\n            sum *= n;\\n            sum += n;\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxSum = 0, sum = 0;\\n        for (int n : nums) {\\n            sum *= n;\\n            sum += n;\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96700,
                "title": "simple-c-solution-with-easy-explanation",
                "content": "Use the fact that multiplication with 0 resets everything..\\n\\n```\\nint findMaxConsecutiveOnes(int* nums, int numsSize) {\\n int max = 0;\\n int sum = 0;\\n for (int i=0; i<numsSize; i++)\\n {\\n     sum = (sum+nums[i])*nums[i];\\n     if(max<sum){max=sum;}\\n }\\nreturn max;\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint findMaxConsecutiveOnes(int* nums, int numsSize) {\\n int max = 0;\\n int sum = 0;\\n for (int i=0; i<numsSize; i++)\\n {\\n     sum = (sum+nums[i])*nums[i];\\n     if(max<sum){max=sum;}\\n }\\nreturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96722,
                "title": "one-liners-python-ruby",
                "content": "**Ruby**\\n\\nTurning the array into a string so I get a nice split function.\\n```\\ndef find_max_consecutive_ones(nums)\\n  nums.join.split(\\'0\\').map(&:size).max || 0\\nend\\n```\\nOr:\\n```\\ndef find_max_consecutive_ones(nums)\\n  nums.chunk_while(&:equal?).map(&:sum).max\\nend\\n```\\n**Python**\\n```\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    return max(sum(g) for _, g in groupby(nums))\\n```",
                "solutionTags": [],
                "code": "```\\ndef find_max_consecutive_ones(nums)\\n  nums.join.split(\\'0\\').map(&:size).max || 0\\nend\\n```\n```\\ndef find_max_consecutive_ones(nums)\\n  nums.chunk_while(&:equal?).map(&:sum).max\\nend\\n```\n```\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    return max(sum(g) for _, g in groupby(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 307378,
                "title": "simple-python-solution-time-o-n-space-o-1",
                "content": "Traverse the array, keep a count of 1\\'s and update the new max count of consecutive 1\\'s when you encounter any other element other than 1.\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        \\n        count = maxCount = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                count += 1\\n            else:\\n                maxCount = max(count, maxCount)\\n                count = 0\\n                \\n        return max(count, maxCount)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        \\n        count = maxCount = 0\\n        \\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                count += 1\\n            else:\\n                maxCount = max(count, maxCount)\\n                count = 0\\n                \\n        return max(count, maxCount)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96728,
                "title": "a-few-short-javascript-solutions",
                "content": "The standard traversal:\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0, curr = 0;\\n    for (let k of nums) {\\n        max = Math.max(max, curr += k);\\n        if (!k) curr = 0;\\n    }\\n    return max;\\n};\\n```\\nSome one-liners:\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return nums.join('').split('0').reduce((max, ones) => Math.max(max, ones.length), 0);\\n};\\n```\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return Math.max(...nums.join('').split('0').map(ones => ones.length));\\n};\\n```\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return Math.max(...(nums.join('').match(/1+/g) || ['']).map(ones => ones.length));\\n};\\n```\\nFinally a O(n\\xb2) solution if you're looking for TLE:\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let str = nums.join(''), max = nums.length + 1;\\n    while (!~str.indexOf('1'.repeat(--max)) && max);\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0, curr = 0;\\n    for (let k of nums) {\\n        max = Math.max(max, curr += k);\\n        if (!k) curr = 0;\\n    }\\n    return max;\\n};\\n```\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return nums.join('').split('0').reduce((max, ones) => Math.max(max, ones.length), 0);\\n};\\n```\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return Math.max(...nums.join('').split('0').map(ones => ones.length));\\n};\\n```\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    return Math.max(...(nums.join('').match(/1+/g) || ['']).map(ones => ones.length));\\n};\\n```\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let str = nums.join(''), max = nums.length + 1;\\n    while (!~str.indexOf('1'.repeat(--max)) && max);\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507990,
                "title": "java-tc-o-n-sc-o-1-easy-concise-solution",
                "content": "```java\\n/**\\n * Maintain current count and maximum count so far.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array\\n */\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int curCount = 0;\\n        int maxCount = 0;\\n\\n        for (int n : nums) {\\n            if (n == 1) {\\n                curCount++;\\n                maxCount = Math.max(maxCount, curCount);\\n            } else {\\n                curCount = 0;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Max Consecutive Ones question on LeetCode:\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Maintain current count and maximum count so far.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array\\n */\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int curCount = 0;\\n        int maxCount = 0;\\n\\n        for (int n : nums) {\\n            if (n == 1) {\\n                curCount++;\\n                maxCount = Math.max(maxCount, curCount);\\n            } else {\\n                curCount = 0;\\n            }\\n        }\\n\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453972,
                "title": "max-consecutive-ones-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i, count=0, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                count++;\\n                if(count>max)\\n                {\\n                    max = count;\\n                }\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/156f2a0d-f889-4af0-8979-f8d3d96b8ee5_1682612653.9251022.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i, count=0, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                count++;\\n                if(count>max)\\n                {\\n                    max = count;\\n                }\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067437,
                "title": "clever-python-solution",
                "content": "if `consecutive == 1`, `consecutive*n+n == consecutive+1`\\nif `consecutive == 0`, `consecutive*n+n = 0`.\\n\\n```python\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        consecutive = result = 0\\n        for n in nums:\\n            consecutive = consecutive*n+n\\n            result = max(result, consecutive)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        consecutive = result = 0\\n        for n in nums:\\n            consecutive = consecutive*n+n\\n            result = max(result, consecutive)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2787693,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0, max = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] ==1) {\\n                count++;\\n            } else {\\n                max = Math.max(count, max);\\n                count = 0;\\n            }\\n        }\\n        \\n        return Math.max(count, max);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0, max = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            if (nums[i] ==1) {\\n                count++;\\n            } else {\\n                max = Math.max(count, max);\\n                count = 0;\\n            }\\n        }\\n        \\n        return Math.max(count, max);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151661,
                "title": "python-4-line-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        for i in range(1, len(nums)):\\n            if nums[i]:\\n                nums[i] += nums[i - 1]\\n        return max(nums)\\n```\\ntransform the input, like\\n[0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], to\\n[0, 1, 2, 3, 0, 1, 2, 0, 0, 1, 2, 3, 4], and the max element would be the result.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        for i in range(1, len(nums)):\\n            if nums[i]:\\n                nums[i] += nums[i - 1]\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476453,
                "title": "python-count-consecutive-numbers-clean-concise",
                "content": "**Idea**\\n- Just iterate elements in `nums`, and keep `cnt` to count the frequency of consecutive numbers.\\n```python\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        ans, cnt, lastNum = 0, 0, -1\\n        for num in nums:\\n            if lastNum != num:\\n                lastNum = num\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                \\n            if num == 1:\\n                ans = max(ans, cnt)\\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        ans, cnt, lastNum = 0, 0, -1\\n        for num in nums:\\n            if lastNum != num:\\n                lastNum = num\\n                cnt = 1\\n            else:\\n                cnt += 1\\n                \\n            if num == 1:\\n                ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476152,
                "title": "python-short-sliding-window-explained",
                "content": "Just iterate over array and keep counting ones, until we reached zero, then set it to zero. We can look at this as sliding window approach also.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        cur_max, gl_max = 0, 0\\n        for i in nums:\\n            if i == 1:\\n                cur_max += 1\\n                gl_max = max(gl_max, cur_max)\\n            else:\\n                cur_max = 0    \\n        return gl_max\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        cur_max, gl_max = 0, 0\\n        for i in nums:\\n            if i == 1:\\n                cur_max += 1\\n                gl_max = max(gl_max, cur_max)\\n            else:\\n                cur_max = 0    \\n        return gl_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221888,
                "title": "three-line-solution",
                "content": "**Do upvote! If you like it!**\\nIf you need explanation, comment down below I will clear your doubts asap!\\n```\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]==0 ? nums[i]=0 : nums[i]+=nums[i-1];\\n        return *max_element(nums.begin(),nums.end());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        for(int i=1;i<nums.size();i++)\\n            nums[i]==0 ? nums[i]=0 : nums[i]+=nums[i-1];\\n        return *max_element(nums.begin(),nums.end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711867,
                "title": "python-one-liner-simple",
                "content": "Steps:\\n1) Converting the array into string\\n2) seperating the string by \\'0\\'\\n3) creates a list of 1 sequences\\n4) which are mapped by len\\n5) which creates an array with the length of each sequence\\n6) Max acquires the largest sequence number and returns it\\n```\\ndef findMaxConsecutiveOnes2(self, nums):\\n\\treturn max(list(map(len, (\"\".join(list(map(str, nums)))).split(\\'0\\'))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findMaxConsecutiveOnes2(self, nums):\\n\\treturn max(list(map(len, (\"\".join(list(map(str, nums)))).split(\\'0\\'))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1011637,
                "title": "simple-and-easy-if-else-solution-faster-than-99-91",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c1,c2=0,0\\n        for i in nums:\\n            if i==1:\\n                c1+=1\\n            elif i==0:\\n                c1=0\\n            if c1>c2:\\n                c2=c1\\n        return c2\\n```\\nIf you have doubts, please ask in comments!!!\\nIf you like it, please **UPVOTE**\\nHappy Coding :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c1,c2=0,0\\n        for i in nums:\\n            if i==1:\\n                c1+=1\\n            elif i==0:\\n                c1=0\\n            if c1>c2:\\n                c2=c1\\n        return c2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699990,
                "title": "easiest-fastest-100-faster-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int c=0,mx=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                c=0;\\n            }\\n            else \\n            {\\n                c++;\\n            }\\n            mx=Math.max(mx,c);\\n        }\\n        return mx;\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int c=0,mx=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                c=0;\\n            }\\n            else \\n            {\\n                c++;\\n            }\\n            mx=Math.max(mx,c);\\n        }\\n        return mx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790890,
                "title": "simple-easy-to-understand-approach",
                "content": "# Intuition\\nTo find the maximum count of ones in a sequence, we store the count of ones and compare it with the current maximum. If the count is greater than the current maximum, we update the maximum count. However, if we encounter a zero in the sequence, we reset the count to zero and continue counting ones.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,maxi=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=1) count=0;\\n            else {\\n                count++;\\n                maxi=max(count,maxi);\\n            }\\n            \\n        }\\n            return maxi;\\n    }\\n};\\n\\n\\n**Please Upvote**\\u2B06\\uFE0F\\uD83D\\uDE43\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,maxi=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=1) count=0;\\n            else {\\n                count++;\\n                maxi=max(count,maxi);\\n            }\\n            \\n        }\\n            return maxi;\\n    }\\n};\\n\\n\\n**Please Upvote**\\u2B06\\uFE0F\\uD83D\\uDE43\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399041,
                "title": "my-simple-javascript-solution",
                "content": "I prefer simplicity and readability over one-liners. Do you suggest any better solution that\\'s worth checking?\\n\\n```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n  \\n    for (let i = 0; i < nums.length; i++) {\\n      // Reset current max if value at current index is zero, increment otherwise.\\n      current = (nums[i] === 0) ? 0 : current + 1;\\n      \\n      // Store current max to max, if current iteration found max consecutive 1s.\\n      max = (current > max) ? current: max;\\n    }\\n  \\n    return max;\\n};\\n```\\n\\nHappy coding!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n  \\n    for (let i = 0; i < nums.length; i++) {\\n      // Reset current max if value at current index is zero, increment otherwise.\\n      current = (nums[i] === 0) ? 0 : current + 1;\\n      \\n      // Store current max to max, if current iteration found max consecutive 1s.\\n      max = (current > max) ? current: max;\\n    }\\n  \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1219781,
                "title": "two-approaches-cpp-beats-99-6",
                "content": "Note the performance difference between the two. The reason is that nasty increment operator\\n\\nApp-1: Beats 5%\\n*Runtime: 84 ms\\nMemory Usage: 36.2 MB*\\n\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int mx=0, cnt=0;\\n        \\n        for (auto i:nums) {\\n            if(i==1) cnt++;\\n            else {\\n                mx = max(mx,cnt);\\n                cnt=0;\\n            }\\n        }\\n        mx = max(mx,cnt);\\n        return mx;\\n    }\\n\\n\\nApp-2 : Beats 99.6%\\n*Runtime: 20 ms\\nMemory Usage: 36.2 MB,*\\n\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int pos = 0, mx=0, n=nums.size();\\n        \\n        for (auto i=0;i<n;i++) {\\n            if(nums[i]==0) {\\n                mx = max(mx, i-pos);\\n                pos = i+1;\\n            }\\n        }\\n        mx = max(mx, n-pos);\\n        return mx;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Note the performance difference between the two. The reason is that nasty increment operator\\n\\nApp-1: Beats 5%\\n*Runtime: 84 ms\\nMemory Usage: 36.2 MB*\\n\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int mx=0, cnt=0;\\n        \\n        for (auto i:nums) {\\n            if(i==1) cnt++;\\n            else {\\n                mx = max(mx,cnt);\\n                cnt=0;\\n            }\\n        }\\n        mx = max(mx,cnt);\\n        return mx;\\n    }\\n\\n\\nApp-2 : Beats 99.6%\\n*Runtime: 20 ms\\nMemory Usage: 36.2 MB,*\\n\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int pos = 0, mx=0, n=nums.size();\\n        \\n        for (auto i=0;i<n;i++) {\\n            if(nums[i]==0) {\\n                mx = max(mx, i-pos);\\n                pos = i+1;\\n            }\\n        }\\n        mx = max(mx, n-pos);\\n        return mx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1122189,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) \\n    {\\n        int count=0,max=0;\\n      for (int i=0; i<nums.length; i++)\\n      {\\n          if(nums[i]==1)\\n          {    \\n              count++;\\n          }\\n          else\\n          {\\n              max=Math.max(max,count);\\n              count=0;\\n          }\\n     }\\n         return Math.max(count,max); //to get all test cases i.e(when nums[]=[1]\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) \\n    {\\n        int count=0,max=0;\\n      for (int i=0; i<nums.length; i++)\\n      {\\n          if(nums[i]==1)\\n          {    \\n              count++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 630971,
                "title": "java-sliding-window",
                "content": "What I did was set up my sliding window where the end pointer iterates over the length of the array, and the start pointer starts at the beginning of the array. Whenever I am still on a `1`, I update `max`, and once I hit a `0`, I move the start of the window to the element after the current end. This is because we know that the current end is `0`, so we move the start to the next element that could be a `1`, which is the one after the current end.\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int start = 0;\\n        int max = 0;\\n        for (int end = 0; end < nums.length; end++) {\\n            if (nums[end] == 1) {\\n                max = Math.max(max, end-start+1);\\n            } else {\\n                start = end+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int start = 0;\\n        int max = 0;\\n        for (int end = 0; end < nums.length; end++) {\\n            if (nums[end] == 1) {\\n                max = Math.max(max, end-start+1);\\n            } else {\\n                start = end+1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331420,
                "title": "easy-solution-java-python-arrays",
                "content": "# Java\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int len = 0;\\n        for(int i:nums){\\n            if(i == 1) {\\n                len++;\\n            }\\n            else {\\n                res.add(len);\\n                len = 0;\\n            }\\n        }\\n        res.add(len);\\n        return Collections.max(res);\\n    }\\n}\\n```\\n# Python \\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = []\\n        l = 0\\n        for i in nums:\\n            if i == 1:\\n                l += 1\\n            else:\\n                res.append(l)\\n                l = 0\\n        res.append(l)\\n        return max(res)\\n```\\nDo upvote if you like the Solution :)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int len = 0;\\n        for(int i:nums){\\n            if(i == 1) {\\n                len++;\\n            }\\n            else {\\n                res.add(len);\\n                len = 0;\\n            }\\n        }\\n        res.add(len);\\n        return Collections.max(res);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = []\\n        l = 0\\n        for i in nums:\\n            if i == 1:\\n                l += 1\\n            else:\\n                res.append(l)\\n                l = 0\\n        res.append(l)\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483221,
                "title": "c-simple-and-short-solution-with-explanation",
                "content": "**Idea:**\\nWe iterate through `nums` and count ones.\\nIf we see a 1, increment `ones`.\\nIf we see a 0, we put in `mx` the maximum between the previous `mx` and the length of consecutive ones we saw now.\\nReturn `max(mx, ones)` because the last ones weren\\'t compared to `mx` yet.\\n\\n**Time complexity:** O(n)\\n**Space complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ones = 0, mx = 0;\\n        for (auto num : nums) {\\n            if (num == 0) {\\n                mx = max(mx, ones);\\n                ones = 0;\\n            }\\n            else ones++;\\n        }\\n        return max(mx, ones);\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ones = 0, mx = 0;\\n        for (auto num : nums) {\\n            if (num == 0) {\\n                mx = max(mx, ones);\\n                ones = 0;\\n            }\\n            else ones++;\\n        }\\n        return max(mx, ones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305318,
                "title": "java-sliding-window-with-new-perspective-100-s-t",
                "content": "**Please upvote if this make sense to you. Thanks!**\\n```\\npublic int findMaxConsecutiveOnes(int[] nums) {\\n        int i=0,j=0;\\n        int max = Integer.MIN_VALUE;\\n        for(j=0; j<nums.length; j++)\\n        {\\n            if(nums[j] == 0)\\n            {\\n                max= Math.max(max, j-i);\\n                i=j+1;\\n            }\\n        }\\n        max= Math.max(max, j-i);\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int findMaxConsecutiveOnes(int[] nums) {\\n        int i=0,j=0;\\n        int max = Integer.MIN_VALUE;\\n        for(j=0; j<nums.length; j++)\\n        {\\n            if(nums[j] == 0)\\n            {\\n                max= Math.max(max, j-i);\\n                i=j+1;\\n            }\\n        }\\n        max= Math.max(max, j-i);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191256,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc findMaxConsecutiveOnes(nums []int) int {\\n    res, curr := 0, 0\\n    \\n    for _, n := range nums {\\n        curr = curr * n + n\\n        if curr > res { res = curr }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMaxConsecutiveOnes(nums []int) int {\\n    res, curr := 0, 0\\n    \\n    for _, n := range nums {\\n        curr = curr * n + n\\n        if curr > res { res = curr }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1478360,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int findMaxConsecutiveOnes(vector<int> &nums) \\n    {\\n        int size = 0;\\n        int max_size = 0;\\n        for(int num : nums)\\n        {\\n            if(num == 0)\\n            {\\n                max_size = max(max_size , size);\\n                size = 0; // reseting size to 0\\n            }\\n            else\\n                size++;\\n        }\\n        return max(max_size , size);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int findMaxConsecutiveOnes(vector<int> &nums) \\n    {\\n        int size = 0;\\n        int max_size = 0;\\n        for(int num : nums)\\n        {\\n            if(num == 0)\\n            {\\n                max_size = max(max_size , size);\\n                size = 0; // reseting size to 0\\n            }\\n            else\\n                size++;\\n        }\\n        return max(max_size , size);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476352,
                "title": "python-easy-to-easiest-solution",
                "content": "# Solution 1\\n**idea**\\n* there will be 2 variables **ans** and **sm**\\n* **sm** to store current length of consecutive 1s , which keep on increasing untill gets 0. \\xA0 \\n* If get 0 then store current max in **ans** and reset **sm** to 0\\n\\n**Complexity**\\n* Time Complexity :- `O(n)`\\n* Space Complexity :- `O(1)`\\n\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        ans = sm = 0\\n        nums.append(0)\\n        for v in nums:\\n            if v==1: sm+=1\\n            else:\\n                ans = max(ans, sm)\\n                sm = 0\\n \\xA0 \\xA0 \\xA0 \\xA0return ans\\n```\\n\\n# Solution 2 One Liner\\n\\n**Idea**\\n* convert whole array to string of 1 & 0 <eg> `\"1011100110\"`\\n* Then Split the string from \\'0\\' , we will get the array of all consecutive 1s <eg> `[\"1\", \"111\", \"11\"]`\\n* Finally we return the maximum Length of consecutive 1s\\n\\n**Complexity**\\nTime Complexity :- `O(n)`\\nSpace Complexity :- `O(n)`\\n\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return max(map(len, \\'\\'.join(map(str, nums)).split(\\'0\\')))\\n```\\n \\xA0\\n*Please upvote if you like the solution and comment if have any queries*\\n \\xA0\\n \\xA0",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        ans = sm = 0\\n        nums.append(0)\\n        for v in nums:\\n            if v==1: sm+=1\\n            else:\\n                ans = max(ans, sm)\\n                sm = 0\\n \\xA0 \\xA0 \\xA0 \\xA0return ans\\n```\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return max(map(len, \\'\\'.join(map(str, nums)).split(\\'0\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950356,
                "title": "c-solution",
                "content": "Here is my solution in C++: \\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int m = 0, c = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            c = (nums[i] == 0) ? 0 : c+1;\\n            m = max(m,c);\\n        }\\n        return m;\\n    }\\n};\\n```\\n\\nIn this problem, we deploy the sliding window strategy to solve the problem. Here\\'s the main idea: \\n* Scanning left to right, we keep increasing the size of our window until we encounter a 0. \\n* If we find a 0, we know that we have to start the next window after it since no valid subarray can span across a 0. \\n* And for each valid subarray, we return the one with the max size.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int m = 0, c = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            c = (nums[i] == 0) ? 0 : c+1;\\n            m = max(m,c);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 869941,
                "title": "javascript",
                "content": "```\\nconst findMaxConsecutiveOnes = (nums) =>{\\n    let count = 0;\\n    let max = 0;\\n    nums.forEach(value => {\\n        if(value === 1) {\\n            count++;\\n            // if the current count of 1\\'s exceeds the current max count, make max === the current count as it exceeds the last max\\n            if(count > max) max = count;\\n        }else{\\n            count = 0;\\n        }\\n    });\\n    return max;\\n};\\n/*\\nTime: O(N)\\nSpace: O(1)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nconst findMaxConsecutiveOnes = (nums) =>{\\n    let count = 0;\\n    let max = 0;\\n    nums.forEach(value => {\\n        if(value === 1) {\\n            count++;\\n            // if the current count of 1\\'s exceeds the current max count, make max === the current count as it exceeds the last max\\n            if(count > max) max = count;\\n        }else{\\n            count = 0;\\n        }\\n    });\\n    return max;\\n};\\n/*\\nTime: O(N)\\nSpace: O(1)\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530121,
                "title": "a-few-solutions",
                "content": "**Functional Solutions:** split the coalesced input array `A` string on `0` to find and return the maximum length of contiguous `1`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var findMaxConsecutiveOnes = { A: IntArray -> A.joinToString(\"\").split(\"0\").map{ it.length }.max() }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findMaxConsecutiveOnes = A => Math.max(...A.join(\\'\\').split(\\'0\\').map(s => s.length));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, A: List[int]) -> int:\\n        return max(len(s) for s in \\'\\'.join(str(x) for x in A).split(\\'0\\'))\\n```\\n\\n---\\n\\n**Procedural Solution:** iteratively find the maximum length of contiguous `1` via a linear scan of each integer `x` in the input array `A`.\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findMaxConsecutiveOnes(VI& A, int size = 0, int best = 0) {\\n        for (auto x: A)\\n            if (x)\\n                best = max(best, ++size);\\n            else\\n                size = 0;\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var findMaxConsecutiveOnes = { A: IntArray -> A.joinToString(\"\").split(\"0\").map{ it.length }.max() }\\n}\\n```\n```\\nlet findMaxConsecutiveOnes = A => Math.max(...A.join(\\'\\').split(\\'0\\').map(s => s.length));\\n```\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, A: List[int]) -> int:\\n        return max(len(s) for s in \\'\\'.join(str(x) for x in A).split(\\'0\\'))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findMaxConsecutiveOnes(VI& A, int size = 0, int best = 0) {\\n        for (auto x: A)\\n            if (x)\\n                best = max(best, ++size);\\n            else\\n                size = 0;\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941022,
                "title": "5-lines-of-code-with-explaination",
                "content": "# Article: Finding Maximum Consecutive Ones - C++ Solution Explained\\n\\nIdentifying the maximum number of consecutive ones in an array is a common problem in programming, often encountered in scenarios involving binary data or sequence analysis. In this article, we\\'ll explore a C++ solution that efficiently solves the problem of finding the maximum number of consecutive ones in an array. We\\'ll dissect the code step by step, discussing its approach and the logic behind it.\\n\\n## The Problem\\n\\nGiven an array of binary values (0s and 1s), the task is to determine the maximum number of consecutive ones in the array.\\n\\n## The Solution\\n\\nThe provided C++ solution employs a simple loop to traverse the array while keeping track of the current count of consecutive ones and the maximum count encountered. Let\\'s dive into the code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxx = 0; // Maximum consecutive ones encountered\\n        int count = 0; // Current count of consecutive ones\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                count++;\\n                if (count > maxx) {\\n                    maxx = count;\\n                }\\n            } else {\\n                count = 0; // Reset count for consecutive ones\\n            }\\n        }\\n        \\n        return maxx; // Return the maximum count\\n    }\\n};\\n```\\n\\n## How It Works\\n\\n1. We initialize two variables: `maxx` to store the maximum number of consecutive ones encountered and `count` to track the current count of consecutive ones.\\n\\n2. We use a `for` loop to traverse the array of binary values.\\n\\n3. If the current element is 1, we increment the `count` variable to represent the current streak of consecutive ones.\\n\\n4. We also check if the `count` has exceeded the current maximum (`maxx`). If it has, we update `maxx` to the new maximum count.\\n\\n5. If the current element is 0, it breaks the streak of consecutive ones. In this case, we reset the `count` to 0.\\n\\n6. Once the loop is complete, the `maxx` variable holds the maximum number of consecutive ones in the array.\\n\\n## Complexity Analysis\\n\\nThe solution iterates through the entire array once, performing constant-time operations for each element. Therefore, the time complexity is **O(n)**, where **n** is the number of elements in the array. The space complexity is **O(1)**, as the solution only uses a constant amount of extra space for variables.\\n\\n## Conclusion\\n\\nThe provided C++ solution effectively solves the problem of finding the maximum number of consecutive ones in a binary array. By keeping track of the current count and updating the maximum count when needed, the solution provides a simple yet efficient solution.\\n\\nThis problem-solving approach showcases how a careful analysis of data patterns can lead to elegant solutions. It also underscores the importance of efficient algorithms, as even seemingly straightforward problems can be optimized to achieve better performance.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxx = 0; // Maximum consecutive ones encountered\\n        int count = 0; // Current count of consecutive ones\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                count++;\\n                if (count > maxx) {\\n                    maxx = count;\\n                }\\n            } else {\\n                count = 0; // Reset count for consecutive ones\\n            }\\n        }\\n        \\n        return maxx; // Return the maximum count\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301647,
                "title": "easy-c-solution-beginner-friendly-easy-explaination",
                "content": "1)  For approching this question, we can use Sliding Window, we have to ouput the maximum size of the window with the maximum no of 1\\'s.\\n2)  So, we take i which specifies the starting of a window and j which we will use to iterate through the window\\n3)  Whenever we encounter a 0, we do not want it, so we move our i to j+1 and calculate the maximum size of      window\\n4)  We calculate the window size by using j-i+1\\n\\nPlease upvote if you liked the explaination :)\\n\\n\\n\\n\\n        \\n        int i=0, j=0, maxcount=0;\\n        int n = nums.size();\\n        while(j<n){\\n            \\n            if(nums[j] == 0){\\n                i = j+1;\\n            }\\n            \\n            maxcount = max(maxcount, j-i+1);\\n            j++;\\n        }\\n       return maxcount; \\n    \\n\\n\\n**Time Complexity** - O(n)\\n**Space Complexit**y - O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "1)  For approching this question, we can use Sliding Window, we have to ouput the maximum size of the window with the maximum no of 1\\'s.\\n2)  So, we take i which specifies the starting of a window and j which we will use to iterate through the window\\n3)  Whenever we encounter a 0, we do not want it, so we move our i to j+1 and calculate the maximum size of      window\\n4)  We calculate the window size by using j-i+1\\n\\nPlease upvote if you liked the explaination :)\\n\\n\\n\\n\\n        \\n        int i=0, j=0, maxcount=0;\\n        int n = nums.size();\\n        while(j<n){\\n            \\n            if(nums[j] == 0){\\n                i = j+1;\\n            }\\n            \\n            maxcount = max(maxcount, j-i+1);\\n            j++;\\n        }\\n       return maxcount; \\n    \\n\\n\\n**Time Complexity** - O(n)\\n**Space Complexit**y - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 3282841,
                "title": "485-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two variables max_count and count to 0.\\n2. Iterate through each element in the nums list.\\n3. If the current element is 1, increment the count variable by 1.\\n4. If the current element is 0, update the max_count variable to be the maximum value between max_count and count, and reset count to 0.\\n5. After the loop ends, update the max_count variable one more time to be the maximum value between max_count and count.\\n6. Return max_count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    max_count = 0\\n    count = 0\\n    for num in nums:\\n        if num == 1:\\n            count += 1\\n        else:\\n            max_count = max(max_count, count)\\n            count = 0\\n            \\n    return max(max_count, count)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n  def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n    max_count = 0\\n    count = 0\\n    for num in nums:\\n        if num == 1:\\n            count += 1\\n        else:\\n            max_count = max(max_count, count)\\n            count = 0\\n            \\n    return max(max_count, count)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154863,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == 1 && i == nums.length - 1){\\n                count++;\\n                if(count > max){\\n                    max = count;\\n                }\\n            }\\n            else if(nums[i] == 1 && nums[i+1] == 0){\\n                count++;\\n                if(count > max){\\n                    max = count;\\n                }\\n                count = 0;\\n            }\\n            else if(nums[i] == 1 ){\\n                count++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i = 0; i<nums.length ; i++){\\n            if(nums[i] == 1 && i == nums.length - 1){\\n                count++;\\n                if(count > max){\\n                    max = count;\\n                }\\n            }\\n            else if(nums[i] == 1 && nums[i+1] == 0){\\n                count++;\\n                if(count > max){\\n                    max = count;\\n                }\\n                count = 0;\\n            }\\n            else if(nums[i] == 1 ){\\n                count++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678689,
                "title": "easy-to-understand-optimized-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,maximum=0;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] == 1 ? c++ : c = 0;\\n            maximum=max(c,maximum);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,maximum=0;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] == 1 ? c++ : c = 0;\\n            maximum=max(c,maximum);\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551654,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\tmax_ones = 0\\n\\tcurr_ones = 0\\n\\n\\tfor n in nums:\\n\\t\\tif n == 1:\\n\\t\\t\\tcurr_ones += 1\\n\\t\\t\\tmax_ones = max(max_ones, curr_ones)\\n\\n\\t\\telse:\\n\\t\\t\\tcurr_ones = 0\\n\\n\\treturn max_ones\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\tmax_ones = 0\\n\\tcurr_ones = 0\\n\\n\\tfor n in nums:\\n\\t\\tif n == 1:\\n\\t\\t\\tcurr_ones += 1\\n\\t\\t\\tmax_ones = max(max_ones, curr_ones)\\n\\n\\t\\telse:\\n\\t\\t\\tcurr_ones = 0\\n\\n\\treturn max_ones\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1476204,
                "title": "max-consecutive-ones-very-easy-no-need-but-still-c-python-java",
                "content": "Doesn\\'t need much explaination, it is a very easy problem\\n\\n* The idea is to reset `cnt` to `0` if we see `0`, \\n* Otherwise increase `cnt` by `1`\\n* The max of all `cnt` is the answer\\n\\n**Solution**\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max_cnt = 0, cnt = 0;\\n        for (auto i : nums) {\\n            if(i == 1)\\n            { \\n                cnt++ ; \\n                max_cnt = max(cnt, max_cnt) ;\\n            }\\n            else\\n            {\\n                cnt = 0 ;\\n            }\\n        }\\n        return max_cnt ;\\n\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        max_cnt = 0\\n        for i in nums:\\n            if i == 1:\\n                cnt += 1\\n                max_cnt = max(max_cnt, cnt)\\n            else:\\n                cnt = 0\\n        return max_cnt\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max_cnt = 0 ;\\n        int cnt = 0 ;\\n        for (int i = 0; i < nums.length; i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                cnt++;\\n                max_cnt = Math.max(cnt, max_cnt);\\n            }\\n            else\\n            {\\n                cnt = 0 ;\\n            }\\n        }\\n        return max_cnt ;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max_cnt = 0, cnt = 0;\\n        for (auto i : nums) {\\n            if(i == 1)\\n            { \\n                cnt++ ; \\n                max_cnt = max(cnt, max_cnt) ;\\n            }\\n            else\\n            {\\n                cnt = 0 ;\\n            }\\n        }\\n        return max_cnt ;\\n\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        max_cnt = 0\\n        for i in nums:\\n            if i == 1:\\n                cnt += 1\\n                max_cnt = max(max_cnt, cnt)\\n            else:\\n                cnt = 0\\n        return max_cnt\\n```\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max_cnt = 0 ;\\n        int cnt = 0 ;\\n        for (int i = 0; i < nums.length; i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                cnt++;\\n                max_cnt = Math.max(cnt, max_cnt);\\n            }\\n            else\\n            {\\n                cnt = 0 ;\\n            }\\n        }\\n        return max_cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812419,
                "title": "straightforward-rust-solution",
                "content": "```\\npub fn find_max_consecutive_ones(nums: Vec<i32>) -> i32 {\\n    nums.split(|n| *n == 0)\\n        .map(|i| i.len())\\n        .max().unwrap() as i32\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npub fn find_max_consecutive_ones(nums: Vec<i32>) -> i32 {\\n    nums.split(|n| *n == 0)\\n        .map(|i| i.len())\\n        .max().unwrap() as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133081,
                "title": "go-100",
                "content": "```go\\nfunc findMaxConsecutiveOnes(a []int) int {\\n    best, crt := 0, 0\\n    for _, v := range a {\\n        if crt+v > best {\\n            best = crt+v\\n        }\\n        crt = (crt+v)*v\\n    }\\n    return best\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc findMaxConsecutiveOnes(a []int) int {\\n    best, crt := 0, 0\\n    for _, v := range a {\\n        if crt+v > best {\\n            best = crt+v\\n        }\\n        crt = (crt+v)*v\\n    }\\n    return best\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96672,
                "title": "javascript-solution",
                "content": "    var str = nums.join(\"\").split(\"0\").map(function(value){\\n        return value.length;\\n    });\\n    return Math.max.apply(null, str);",
                "solutionTags": [],
                "code": "    var str = nums.join(\"\").split(\"0\").map(function(value){\\n        return value.length;\\n    });\\n    return Math.max.apply(null, str);",
                "codeTag": "Unknown"
            },
            {
                "id": 96810,
                "title": "c-one-pass-no-strings-just-iterate-array-greedy-super-simple",
                "content": "I don't think I've seen a simpler problem on this whole site.\\n\\n```\\n    public int FindMaxConsecutiveOnes(int[] nums) \\n    {\\n        int max = 0;\\n        int curr = 0;\\n        foreach (int x in nums)\\n        {\\n            curr = x == 0 ? 0 : curr + 1;\\n            max = curr > max ? curr : max;\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int FindMaxConsecutiveOnes(int[] nums) \\n    {\\n        int max = 0;\\n        int curr = 0;\\n        foreach (int x in nums)\\n        {\\n            curr = x == 0 ? 0 : curr + 1;\\n            max = curr > max ? curr : max;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96746,
                "title": "java-straightforward-o-n-solution",
                "content": "Also viewable [here](https://github.com/fishercoder1534/Leetcode/blob/master/leetcode-algorithms/src/main/java/com/stevesun/solutions/MaxConsecutiveOnes.java).\\n\\n```\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxOnes = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int newOnes = 0;\\n            while (i < nums.length && nums[i] == 1){\\n                newOnes++;\\n                i++;\\n            }\\n            maxOnes = Math.max(maxOnes, newOnes);\\n        }\\n        return maxOnes;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxOnes = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            int newOnes = 0;\\n            while (i < nums.length && nums[i] == 1){\\n                newOnes++;\\n                i++;\\n            }\\n            maxOnes = Math.max(maxOnes, newOnes);\\n        }\\n        return maxOnes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3541929,
                "title": "just-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: const\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max, temp_max, check;\\n        max = temp_max = check = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                check = 1;\\n                temp_max++;\\n            } else { \\n                check = 0;\\n                temp_max = 0;\\n            }\\n            if (temp_max > max) max = temp_max;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max, temp_max, check;\\n        max = temp_max = check = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) {\\n                check = 1;\\n                temp_max++;\\n            } else { \\n                check = 0;\\n                temp_max = 0;\\n            }\\n            if (temp_max > max) max = temp_max;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516770,
                "title": "single-pass-c-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we were to keep track of the maximum length of continouosly occuring 1\\'s and assign to it the maximum of currently occuring 1\\'s and itself, we would get the desired result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare `maxLen` and initialize it as 0. Iterate through the array and whenever a 1 is encountered, declare a variable `len` that keeps track of consecutively occuring 1\\'s. \\n\\nIn order to keep track of the consecutively occuring 1\\'s, increment `len` as long as `nums[i]` is equal to 1. Once the first new 0 is encountered (or iterator goes out of bounds), assign the maximum value of `maxLen` and `len` to the former.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i=0;\\n        int maxLen=0;\\n        int n=nums.size();\\n\\n        while(i<n){\\n            if(nums[i]==1){\\n                int len=0;\\n                while(i<n&&nums[i]==1){\\n                    len++;\\n                    i++;\\n                }\\n                maxLen=max(maxLen, len);\\n            }\\n            else i++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i=0;\\n        int maxLen=0;\\n        int n=nums.size();\\n\\n        while(i<n){\\n            if(nums[i]==1){\\n                int len=0;\\n                while(i<n&&nums[i]==1){\\n                    len++;\\n                    i++;\\n                }\\n                maxLen=max(maxLen, len);\\n            }\\n            else i++;\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489514,
                "title": "easiest-approach-ever",
                "content": "# Intuition\\nSimple Dart solution without using any inbuilt functions\\n# Approach\\nItrate through elements and set a flag to find longest count and update it whenever longer found.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\n  int findMaxConsecutiveOnes(List<int> nums) {\\n      int count=0,flag=0;\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]==1){\\n              count++;\\n              if(count>flag){\\n                  flag=count;\\n              }\\n          }else{\\n              count=0;\\n          }\\n      }\\n      return flag;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int findMaxConsecutiveOnes(List<int> nums) {\\n      int count=0,flag=0;\\n      for(int i=0;i<nums.length;i++){\\n          if(nums[i]==1){\\n              count++;\\n              if(count>flag){\\n                  flag=count;\\n              }\\n          }else{\\n              count=0;\\n          }\\n      }\\n      return flag;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408227,
                "title": "simple-and-straightforward-java-solution",
                "content": "Here\\'s the code. It is pretty much straightforward. It ain\\'t much, but it\\'s honest work.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1){\\n                count++;\\n                if(i != nums.length - 1) continue;\\n            }\\n            if(count > max) max = count;\\n            count = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1){\\n                count++;\\n                if(i != nums.length - 1) continue;\\n            }\\n            if(count > max) max = count;\\n            count = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311264,
                "title": "easy-to-understand-python-solution",
                "content": "##### **Final Code:**\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count, max_ones = 0, 0\\n        for num in nums:\\n            if num != 1:\\n                count = 0\\n            else:\\n                count += 1\\n            max_ones = max(count, max_ones)\\n        return max_ones\\n```\\n\\n##### **Steps:**\\n* **Step1:**\\nFor this question we can make use of 2 counter variables,\\n```count, max_ones = 0, 0```\\n\\n\\t* **count:** This will keep track of 1\\'s until it encounters a 0\\n\\t* **max_ones:** This will keep track of maximum consecutive 1\\'s\\n\\n* **Step2:**\\nWe can use a for loop to iterate over each element in nums and look for **1\\'s**,\\nWith each **1** we find in nums we increment the value of count by 1,\\nand if at any point we encounter a **0** we reset the counter back to 0.\\n```\\n        for num in nums:\\n            if num != 1:\\n                count = 0\\n            else:\\n                count += 1\\n```\\n\\n* **Step3:**\\nAt the end of each iteration we can compare **max_ones** with **count** and let\\nmax_counts have the highest count-value as our count will be set to 0 everytime it sees a 0.\\n```max_ones = max(count, max_ones)```\\n\\n* **Step4:**\\nFinally we can return our max_ones\\n``` return max_ones```\\n\\n\\n**I hope that you\\'ve found this useful.\\nIf so, consider leaving an upvote \\uD83D\\uDE01**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count, max_ones = 0, 0\\n        for num in nums:\\n            if num != 1:\\n                count = 0\\n            else:\\n                count += 1\\n            max_ones = max(count, max_ones)\\n        return max_ones\\n```\n```count, max_ones = 0, 0```\n```\\n        for num in nums:\\n            if num != 1:\\n                count = 0\\n            else:\\n                count += 1\\n```\n```max_ones = max(count, max_ones)```\n``` return max_ones```",
                "codeTag": "Java"
            },
            {
                "id": 2022806,
                "title": "typescript-solution-easy-to-understand",
                "content": "```\\nfunction findMaxConsecutiveOnes(nums: number[]): number {\\n    \\n    let count = 0;\\n    let max   = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            count++;\\n        } else {\\n            if (count > max) {\\n                max = count;\\n            }\\n            count = 0; \\n        }\\n    }\\n    \\n    return Math.max(count, max);\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findMaxConsecutiveOnes(nums: number[]): number {\\n    \\n    let count = 0;\\n    let max   = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            count++;\\n        } else {\\n            if (count > max) {\\n                max = count;\\n            }\\n            count = 0; \\n        }\\n    }\\n    \\n    return Math.max(count, max);\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1830944,
                "title": "easiest-javascript-solution",
                "content": "```\\nvar findMaxConsecutiveOnes = function(nums) {\\n          let count = 0;\\n          const n = nums.length;\\n \\n    let result = 0;\\n \\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] == 0)\\n            count = 0;\\n \\n        else {\\n            count++;\\n            result = Math.max(result, count);\\n        }\\n    }\\n \\n    return result;\\n}    \\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar findMaxConsecutiveOnes = function(nums) {\\n          let count = 0;\\n          const n = nums.length;\\n \\n    let result = 0;\\n \\n    for (let i = 0; i < n; i++) {\\n        if (nums[i] == 0)\\n            count = 0;\\n \\n        else {\\n            count++;\\n            result = Math.max(result, count);\\n        }\\n    }\\n \\n    return result;\\n}    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709443,
                "title": "easiest-java-solution",
                "content": "```\\npublic int findMaxConsecutiveOnes(int[] ar) {\\n\\n    int count = 0;\\n    int max =0;\\n    for(int i=0;i<ar.length;i++)\\n    {\\n        if(ar[i]==1)\\n        {\\n            count++;\\n            if(max<count)  // we will check if count surpass previous max value and update it\\n            {\\n                max=count;\\n            }\\n        }\\n        else\\n        {\\n            count=0;\\n        }\\n    }\\n    return max;\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int findMaxConsecutiveOnes(int[] ar) {\\n\\n    int count = 0;\\n    int max =0;\\n    for(int i=0;i<ar.length;i++)\\n    {\\n        if(ar[i]==1)\\n        {\\n            count++;\\n            if(max<count)  // we will check if count surpass previous max value and update it\\n            {\\n                max=count;\\n            }\\n        }\\n        else\\n        {\\n            count=0;\\n        }\\n    }\\n    return max;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1178373,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        count = 0\\n        \\n        for num in nums:\\n            if num == 1:\\n                count += 1\\n                res = max(res, count)\\n            else:\\n                count = 0\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        count = 0\\n        \\n        for num in nums:\\n            if num == 1:\\n                count += 1\\n                res = max(res, count)\\n            else:\\n                count = 0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96674,
                "title": "python-solution",
                "content": "\\n\\n    def findMaxConsecutiveOnes(self, nums):\\n\\n        num_str = ''.join(map(str,nums))\\n        num_list = num_str.split('0')\\n        \\n        return len(max(num_list))",
                "solutionTags": [],
                "code": "\\n\\n    def findMaxConsecutiveOnes(self, nums):\\n\\n        num_str = ''.join(map(str,nums))\\n        num_list = num_str.split('0')\\n        \\n        return len(max(num_list))",
                "codeTag": "Python3"
            },
            {
                "id": 96730,
                "title": "c-solution-with-o-n",
                "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max=0,cur=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                max=max>++cur?max:cur;\\n            }\\n            else cur=0;\\n        }\\n        return max;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int max=0,cur=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]&1)\\n            {\\n                max=max>++cur?max:cur;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 96690,
                "title": "a-python-solution",
                "content": "    def findMaxConsecutiveOnes(self, nums):\\n        n = 0\\n        maxn = 0\\n        for i,v in enumerate(nums):\\n            if v == 1:\\n                n += 1\\n            else:\\n                maxn = max(maxn, n)\\n                n = 0\\n        maxn = max(maxn, n)\\n        return maxn",
                "solutionTags": [],
                "code": "    def findMaxConsecutiveOnes(self, nums):\\n        n = 0\\n        maxn = 0\\n        for i,v in enumerate(nums):\\n            if v == 1:\\n                n += 1\\n            else:\\n                maxn = max(maxn, n)\\n                n = 0\\n        maxn = max(maxn, n)\\n        return maxn",
                "codeTag": "Python3"
            },
            {
                "id": 4026094,
                "title": "java-simple-and-easy-ans-optimised-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n We maintain a variable count that keeps a track of the number of consecutive 1\\u2019s while traversing the array. The other variable max_count maintains the maximum number of 1\\u2019s, in other words, it maintains the answer.\\n\\nWe start traversing from the beginning of the array. Since we can encounter either a 1 or 0 there can be two situations:-\\n\\n1)  If  the value at the current index is equal to 1 we increase the value of count by one. After updating  the count variable if it becomes more than the max_count  update the max_count.\\n2) If the value at the current index is equal to zero we make the variable count as 0 since there are no more consecutive ones.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)  -> because no extra space is used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0;\\n        int max=0;\\n     for(int i = 0 ;i<nums.length;i++){\\n         if(nums[i] == 1){\\n             count++;\\n         }\\n         else{\\n             count  = 0;\\n         }\\n     max = Math.max(max,count);   \\n     }\\n    return max;\\n    }\\n}\\n```\\n\\n![one-piece-3-231072.png](https://assets.leetcode.com/users/images/15f93ff1-f139-4557-bd80-8589eefe70d3_1694335808.3418236.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0;\\n        int max=0;\\n     for(int i = 0 ;i<nums.length;i++){\\n         if(nums[i] == 1){\\n             count++;\\n         }\\n         else{\\n             count  = 0;\\n         }\\n     max = Math.max(max,count);   \\n     }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684786,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxi=0;\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               ones++;\\n               maxi=max(maxi,ones);\\n           }else{\\n               ones=0;\\n           }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxi=0;\\n        int ones=0;\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]==1){\\n               ones++;\\n               maxi=max(maxi,ones);\\n           }else{\\n               ones=0;\\n           }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680296,
                "title": "java-easiest-5-liner",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n       int sum = 0, maxSum = 0;\\n       for(int n : nums) {\\n           sum += n;\\n           sum *= n;\\n           maxSum = Math.max(maxSum, sum); \\n       } \\n       return maxSum;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n       int sum = 0, maxSum = 0;\\n       for(int n : nums) {\\n           sum += n;\\n           sum *= n;\\n           maxSum = Math.max(maxSum, sum); \\n       } \\n       return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408193,
                "title": "o-n-time-java-solution-100",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n      int res =0;\\n      int count=0;\\n      for(int i=0; i<nums.length; i++)  {\\n          if(nums[i]==1){\\n              count++;\\n          }\\n          else{\\n              res = Math.max(res, count);\\n              count =0;\\n          }\\n      }\\n\\n      return Math.max(res, count);\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n      int res =0;\\n      int count=0;\\n      for(int i=0; i<nums.length; i++)  {\\n          if(nums[i]==1){\\n              count++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3380715,
                "title": "short-and-clean-code-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  int findMaxConsecutiveOnes(vector<int> &nums)\\n  {\\n    int maxi = 0;\\n    int cnt = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n      if (nums[i] == 1)\\n      {\\n        cnt++;\\n        maxi = max(maxi, cnt);\\n      }\\n      else\\n        cnt = 0;\\n    }\\n    return maxi;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int findMaxConsecutiveOnes(vector<int> &nums)\\n  {\\n    int maxi = 0;\\n    int cnt = 0;\\n    for (int i = 0; i < nums.size(); i++)\\n    {\\n      if (nums[i] == 1)\\n      {\\n        cnt++;\\n        maxi = max(maxi, cnt);\\n      }\\n      else\\n        cnt = 0;\\n    }\\n    return maxi;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335346,
                "title": "python-one-liner",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return len(max(\\'\\'.join(list(map(str,nums))).split(\"0\")))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return len(max(\\'\\'.join(list(map(str,nums))).split(\"0\")))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105658,
                "title": "java-and-python-simple-fast-and-easy-solution",
                "content": "Please Upvote if understood \\n\\n**Java **\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0 ;\\n        int max = 0;\\n        for(int elem : nums){\\n            if(elem ==0){\\n                count = 0;\\n            }else{\\n                count++;\\n                max = Math.max(count ,max);\\n            }\\n        }\\n        return max ;\\n    }\\n\\n**Python**\\n****\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count = 0 ; maxi = 0 ;\\n        for x in nums:\\n            if x ==0:\\n                count = 0 ;\\n            else :\\n                count+=1;\\n                maxi = max(count ,maxi);\\n        return maxi;",
                "solutionTags": [
                    "Array"
                ],
                "code": "Please Upvote if understood \\n\\n**Java **\\n\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0 ;\\n        int max = 0;\\n        for(int elem : nums){\\n            if(elem ==0){\\n                count = 0;\\n            }else{\\n                count++;\\n                max = Math.max(count ,max);\\n            }\\n        }\\n        return max ;\\n    }\\n\\n**Python**\\n****\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count = 0 ; maxi = 0 ;\\n        for x in nums:\\n            if x ==0:\\n                count = 0 ;\\n            else :\\n                count+=1;\\n                maxi = max(count ,maxi);\\n        return maxi;",
                "codeTag": "Python3"
            },
            {
                "id": 3073212,
                "title": "best-solution",
                "content": "# Approach\\nCreate a variable Count and intialize with 0. Traverse the whole array and when we encounter 1, then increment the Count by 1. Otherwise, set the Count to 0. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count = 0, ans = INT_MIN;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) \\n                count++;\\n            else \\n                count = 0;\\n            ans = max (ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count = 0, ans = INT_MIN;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 1) \\n                count++;\\n            else \\n                count = 0;\\n            ans = max (ans, count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967202,
                "title": "c-solution-98-84-time-22-96-space-used-reset-counter-in-this-problem",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums);\\n};\\n/***************************************************************/\\nint Solution::findMaxConsecutiveOnes(vector<int>& nums) {\\n    int size=nums.size(), count=0, maxCount=0, i;\\n    for (i = 0; i < size; ++i) {\\n        if (nums[i] == 1) {\\n            ++count;        \\n        } else {\\n            count = 0;\\n        }\\n        if (count > maxCount) {\\n            maxCount = count;\\n        }\\n    }\\n    return maxCount;\\n}\\n/***************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums);\\n};\\n/***************************************************************/\\nint Solution::findMaxConsecutiveOnes(vector<int>& nums) {\\n    int size=nums.size(), count=0, maxCount=0, i;\\n    for (i = 0; i < size; ++i) {\\n        if (nums[i] == 1) {\\n            ++count;        \\n        } else {\\n            count = 0;\\n        }\\n        if (count > maxCount) {\\n            maxCount = count;\\n        }\\n    }\\n    return maxCount;\\n}\\n/***************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856630,
                "title": "c-beats-84-4-easy-solution",
                "content": "```\\npublic class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int res = 0;\\n            int temp = 0;\\n\\n            for(int i =0; i< nums.Length; i++)\\n            {\\n                if (nums[i] == 0)\\n                {\\n                    res = Math.Max(res, temp);\\n                    temp = 0;\\n                }\\n                else temp++;\\n            }\\n\\n            return Math.Max(res, temp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int res = 0;\\n            int temp = 0;\\n\\n            for(int i =0; i< nums.Length; i++)\\n            {\\n                if (nums[i] == 0)\\n                {\\n                    res = Math.Max(res, temp);\\n                    temp = 0;\\n                }\\n                else temp++;\\n            }\\n\\n            return Math.Max(res, temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854073,
                "title": "easy-to-understand-c-and-c",
                "content": "# Intuition\\nEasy to think\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans=0,maxx=0;\\n        for(auto x:nums){\\n            if(x==1){\\n                ans++;\\n            }\\n            else{\\n                maxx=max(maxx,ans);\\n                ans=0;\\n            }\\n        }\\n        maxx=max(maxx,ans);\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans=0,maxx=0;\\n        for(auto x:nums){\\n            if(x==1){\\n                ans++;\\n            }\\n            else{\\n                maxx=max(maxx,ans);\\n                ans=0;\\n            }\\n        }\\n        maxx=max(maxx,ans);\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834888,
                "title": "simple-understandable-java-solution-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) { \\n        int initial = 0;\\n        int final = 0; \\n        for(int i=0; i<nums.length; i++){    \\n            if(nums[i]==1){\\n                initial++;    \\n            }else{\\n                if(final<initial){\\n                    final = initial;\\n                }\\n                initial = 0;\\n            }\\n        }\\n        if(final>initial)return final;\\n        else return initial; \\n    }\\n}\\n```\\n\\n**If you like the solution please upvote it and If any doubts ask in the comments section, I will respond to it**\\n\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) { \\n        int initial = 0;\\n        int final = 0; \\n        for(int i=0; i<nums.length; i++){    \\n            if(nums[i]==1){\\n                initial++;    \\n            }else{\\n                if(final<initial){\\n                    final = initial;\\n                }\\n                initial = 0;\\n            }\\n        }\\n        if(final>initial)return final;\\n        else return initial; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778930,
                "title": "easy-cpp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int res=0;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n                curr++;\\n            else\\n            {\\n                res = max(res,curr);\\n                curr = 0;\\n            }\\n        }\\n        res = max(res,curr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int res=0;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n                curr++;\\n            else\\n            {\\n                res = max(res,curr);\\n                curr = 0;\\n            }\\n        }\\n        res = max(res,curr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679720,
                "title": "c-basic-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count =0,maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            maxi=max(count,maxi);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count =0,maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2664623,
                "title": "swift-solution-easy-understanding",
                "content": "```\\n    func findMaxConsecutiveOnes(_ nums: [Int]) -> Int {\\n        var count: Int = 0\\n        var maxValue: Int = 0\\n        for num in nums {\\n            if (num == 1) {\\n                count = count+1\\n                maxValue = max(maxValue, count)\\n            } else {\\n                count = 0\\n            }\\n        }\\n        return maxValue\\n    }\\n```\\n**Do upvote if you understood the solution**",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func findMaxConsecutiveOnes(_ nums: [Int]) -> Int {\\n        var count: Int = 0\\n        var maxValue: Int = 0\\n        for num in nums {\\n            if (num == 1) {\\n                count = count+1\\n                maxValue = max(maxValue, count)\\n            } else {\\n                count = 0\\n            }\\n        }\\n        return maxValue\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2615379,
                "title": "easy-and-simple-c-solution-explained",
                "content": "**Please upvote, if you found it helpful!\\nIt helps a lot.**\\n\\nIn this problem, it is given that the array (or vector) is a binary array, i.e. it has only \\'1\\'s and \\'0\\'s as its elements. \\nHere we are using a **count** variable that will store the **count of consecutive \\'1\\'s** in the array, and **max_count** variable that stores the **maximum count of consecutive \\'1\\'s**.\\nHere we are using a for loop, to traverse the entire array, and checking whether any \\'0\\' is present or not. \\nIf the element is **not 0** (i.e it is 1), we\\'ll **increment the value of count**, and we\\'ll keep incrementing it until a zero occurs.\\nSince, **if a zero occurs,** it means that our **continuity of consecutive \\'1\\'s has been broken**. So, we\\'ll stop incrementing the count value, and **compare** the current value of count and max_count and **update the max_count**.\\nNow, we\\'ll re-initialize the count variable to store the new count of consecutive \\'1s\\'.\\n\\n***So, now folks, one might ask that why we are again comparing count and max_count at the end, while returning, when we have already did it in the loop itself.***\\nAnd to justify that, lemme give you a simple example:\\n```\\nnums = [1,1,1,1,1,1]\\nNote: Here there are no 0\\'s, so our count won\\'t be compared with max_count, and thus, our answer would be 0 instead of 6 if we don\\'t compare it again.\\n\\nYou could also consider the following:\\nnums = [0,1,1,0,1,1,1]\\nIn this as well, after the second 0, our value of count will be 3 but our max_count will be 2, so we have to compare it again.\\n```\\n\\nNow, finally, here\\'s the full C++ implementation.\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        int max_count = INT_MIN;\\n        for(auto x:nums){\\n            if(x==0)\\n            {\\n                max_count = max(max_count,count);\\n                count=0;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return  max(max_count,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nnums = [1,1,1,1,1,1]\\nNote: Here there are no 0\\'s, so our count won\\'t be compared with max_count, and thus, our answer would be 0 instead of 6 if we don\\'t compare it again.\\n\\nYou could also consider the following:\\nnums = [0,1,1,0,1,1,1]\\nIn this as well, after the second 0, our value of count will be 3 but our max_count will be 2, so we have to compare it again.\\n```\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        int max_count = INT_MIN;\\n        for(auto x:nums){\\n            if(x==0)\\n            {\\n                max_count = max(max_count,count);\\n                count=0;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return  max(max_count,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593850,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Array***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int i = 0;\\n        \\n        int max_count = 0;\\n        \\n        while(i < n)\\n        {\\n            // count no. of consecutive ones\\n            \\n            int count = 0;\\n            \\n            while(i < n && nums[i])\\n            {\\n                count++;\\n                \\n                i++;\\n            }\\n            \\n            // update maxi\\n            \\n            max_count = max(max_count, count);\\n            \\n            i++;\\n        }\\n        \\n        return max_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int i = 0;\\n        \\n        int max_count = 0;\\n        \\n        while(i < n)\\n        {\\n            // count no. of consecutive ones\\n            \\n            int count = 0;\\n            \\n            while(i < n && nums[i])\\n            {\\n                count++;\\n                \\n                i++;\\n            }\\n            \\n            // update maxi\\n            \\n            max_count = max(max_count, count);\\n            \\n            i++;\\n        }\\n        \\n        return max_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469271,
                "title": "python-beats-99-62",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        cnt = 0\\n        \\n        for i in nums:\\n            if i:\\n                cnt += 1\\n            else:\\n                res = max(res, cnt)\\n                cnt = 0\\n\\n        return max(cnt, res)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        cnt = 0\\n        \\n        for i in nums:\\n            if i:\\n                cnt += 1\\n            else:\\n                res = max(res, cnt)\\n                cnt = 0\\n\\n        return max(cnt, res)",
                "codeTag": "Java"
            },
            {
                "id": 2177951,
                "title": "python3-o-n-o-1-runtime-359ms-91-92-memory-14-3mb-78-65",
                "content": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 359ms 91.92% ; Memory: 14.3mb 78.65%\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count = 0\\n        maxCount = 0\\n\\n        for idx, num in enumerate(nums):\\n            if num == 1:\\n                count += 1\\n            if num == 0 or idx == len(nums) - 1:\\n                maxCount = max(maxCount, count)\\n                count = 0\\n\\n        return maxCount\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 359ms 91.92% ; Memory: 14.3mb 78.65%\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        count = 0\\n        maxCount = 0\\n\\n        for idx, num in enumerate(nums):\\n            if num == 1:\\n                count += 1\\n            if num == 0 or idx == len(nums) - 1:\\n                maxCount = max(maxCount, count)\\n                count = 0\\n\\n        return maxCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629089,
                "title": "max-consecutive-ones-with-java-100",
                "content": "class Solution {\\n\\n    public int findMaxConsecutiveOnes(int[] ch) {\\n        int max = 0;\\n        int temp = 0;\\n\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch.length == 1) {\\n                return ch[i];\\n            }\\n            if (ch[i] == 1) {\\n                temp++;\\n                max = Math.max(max, temp);\\n            } else temp = 0;\\n        }\\n        return max;\\n    }\\n}\\n\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int findMaxConsecutiveOnes(int[] ch) {\\n        int max = 0;\\n        int temp = 0;\\n\\n        for (int i = 0; i < ch.length; i++) {\\n            if (ch.length == 1) {\\n                return ch[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1574470,
                "title": "simple-for-loop-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Since we do a single pass over the array, time complexity is O(N).\\nSpace Complexity - Since we aren\\'t using any external space, space complexity is O(1).\\nExplanation - We loop over the array and store the current number of consecutive ones in the variable currOnes. The value of currOnes becomes 0 as soon as we encounter a zero in the array, as it means that the there are no more consecutive ones. We store the maximum value of count in the variable maxOnes to find the maximum number of consecutive ones.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int currOnes = 0, maxOnes = 0;\\n        for(auto num : nums){\\n            if(num) currOnes++;\\n            else currOnes = 0;\\n            maxOnes = max(maxOnes, currOnes);\\n        }\\n        return maxOnes;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int currOnes = 0, maxOnes = 0;\\n        for(auto num : nums){\\n            if(num) currOnes++;\\n            else currOnes = 0;\\n            maxOnes = max(maxOnes, currOnes);\\n        }\\n        return maxOnes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240222,
                "title": "easiest-c-solution-with-just-a-loop-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        // Declaring 2 variable to keep track of number of consecutive numbers and final answer\\n        int add = 0, ans =0;\\n        // Iterating whole nums array\\n        for(int i =0; i < nums.size(); i++){\\n            // Checking if there exists a 1, then increament add by 1\\n            if (nums[i] == 1){\\n                add++;\\n            }\\n            // If the element is not 1 then initialize add with 0\\n            else{\\n                add = 0;\\n            }\\n            // Update the final answer variable with highest number of consecutive 1\\'s\\n            ans = max(ans, add);\\n        }\\n        // Return final answer\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote the solution if this helps you understand better!**\\n\\n**Have fun coding!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        // Declaring 2 variable to keep track of number of consecutive numbers and final answer\\n        int add = 0, ans =0;\\n        // Iterating whole nums array\\n        for(int i =0; i < nums.size(); i++){\\n            // Checking if there exists a 1, then increament add by 1\\n            if (nums[i] == 1){\\n                add++;\\n            }\\n            // If the element is not 1 then initialize add with 0\\n            else{\\n                add = 0;\\n            }\\n            // Update the final answer variable with highest number of consecutive 1\\'s\\n            ans = max(ans, add);\\n        }\\n        // Return final answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994812,
                "title": "java-without-if-else",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for (int num : nums) {\\n            count += num;\\n            max = Math.max(count, max);\\n            count *= num;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for (int num : nums) {\\n            count += num;\\n            max = Math.max(count, max);\\n            count *= num;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049170,
                "title": "simple-solution-in-c-with-explaination",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n      int n=nums.size();\\n      int cnt=0;\\n//store the maximum count if 1\\n      int maxi=0;\\n      for(int i=0;i<n;i++){\\n//check the condition if element contain 1 then cnt increment by 1\\n       if(nums[i]==1){\\n           ++cnt;\\n       }\\n       else{\\n           cnt=0;\\n       }\\n//compare if the cnt is  greater then maxi the maxi is equal to the cnt\\n        maxi=max(maxi,cnt);\\n      }\\n//return the maximum count of the 1\\n      return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n      int n=nums.size();\\n      int cnt=0;\\n//store the maximum count if 1\\n      int maxi=0;\\n      for(int i=0;i<n;i++){\\n//check the condition if element contain 1 then cnt increment by 1\\n       if(nums[i]==1){\\n           ++cnt;\\n       }\\n       else{\\n           cnt=0;\\n       }\\n//compare if the cnt is  greater then maxi the maxi is equal to the cnt\\n        maxi=max(maxi,cnt);\\n      }\\n//return the maximum count of the 1\\n      return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924288,
                "title": "beginner-friendly-approach-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I thought that i will count till i encounter a zero. As soon as I encounter a zero i will reset the counter and start counting 1\\'s once again. Then i realized that the last consecutive 1\\'s may not be the maximum. So after that I introduced the max variable. After that I realized that the last count may or may not be stored in max variable and also the last count might be greater than max variable. So i added the ternary operator in the return line.\\n\\n# Approach\\nWe will traverse the array and keep counting the 1\\'s present. As soon as we encounter a 0 we will reset the counter. But before that we need to keep it stored somewhere as we need the return the max of the consecutive 1\\'s. So the max variable checks whether the current count is more than the previous counts before the counter is resetted. If yes, it stores within itself. Finally before returning wee need to check whether max is greater or c is and then accordingly return the greater one.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int i, c = 0, max = 0;\\n        for(i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1)\\n                c++;\\n            else {\\n                if(max < c)\\n                    max = c;\\n                c = 0;\\n            }\\n        }\\n        return (max>c)? max: c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int i, c = 0, max = 0;\\n        for(i = 0; i < nums.length; i++) {\\n            if(nums[i] == 1)\\n                c++;\\n            else {\\n                if(max < c)\\n                    max = c;\\n                c = 0;\\n            }\\n        }\\n        return (max>c)? max: c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760573,
                "title": "easy-python-solution-with-step-by-step-explanation-and-o-n-time-complexity",
                "content": "# Approach\\n **Step 1**: Create a variable \\'count\\' which stores the number of consecutive one\\'s.\\n\\n\\n```python []\\ncount=0\\n```\\n**Step 2**: Create a list to get the maximum number of consecutive one\\'s.\\n```python []\\nmaxi=[]\\n```\\n\\n**Step 3**: Iterate through the \\'nums\\' list, if nums[x] was equal to 1 then increment the count value.\\n```python[]\\nfor x in range(len(nums)):\\n        if nums[x]==1:\\n            count+=1\\n```\\n\\n**Step 4**: If nums[x] was equal to 0, then append the count value to the list \\'maxi\\' to store the consecutive number of one\\'s and then set the value of count to 0. Only then the counting of 1\\'s will be starting again.\\n```python[]\\nelse:\\n    maxi.append(count)\\n    count=0\\n```\\n\\n**Step 5**: Once the loop has been executed, append the value of count to the list \\'maxi\\'.\\n```python[]\\nmaxi.append(count)\\n```\\n\\n**Step 6**: To get the maximum of no.of consecutive 1\\'s, get the maximum number from the list \\'maxi\\' which will be the result of the problem.\\n```python[]\\nreturn max(maxi)\\n```\\n\\n# Time Complexity\\nO(n)\\n# Code\\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        count=0\\n        maxi = []\\n\\n        for x in range(len(nums)):\\n            if nums[x]==1:\\n                count+=1\\n            else:\\n                maxi.append(count)\\n                count=0\\n\\n        maxi.append(count)\\n        return(max(maxi))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python []\\ncount=0\\n```\n```python []\\nmaxi=[]\\n```\n```python[]\\nfor x in range(len(nums)):\\n        if nums[x]==1:\\n            count+=1\\n```\n```python[]\\nelse:\\n    maxi.append(count)\\n    count=0\\n```\n```python[]\\nmaxi.append(count)\\n```\n```python[]\\nreturn max(maxi)\\n```\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        count=0\\n        maxi = []\\n\\n        for x in range(len(nums)):\\n            if nums[x]==1:\\n                count+=1\\n            else:\\n                maxi.append(count)\\n                count=0\\n\\n        maxi.append(count)\\n        return(max(maxi))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672647,
                "title": "485-max-consecutive-ones-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int sum = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 1){\\n                count++;\\n                if(count>sum){\\n                    sum = count;\\n                }\\n            }\\n            else if(nums[i] == 0){\\n                count = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int sum = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 1){\\n                count++;\\n                if(count>sum){\\n                    sum = count;\\n                }\\n            }\\n            else if(nums[i] == 0){\\n                count = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641097,
                "title": "easy-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n       int count = 0;\\n       int j  = 0;\\n       for(int i = 0; i < nums.size(); i++){\\n           if(nums[i]==1){\\n               j++;\\n           }\\n           else{\\n               count = max(count,j);\\n               cout<<count<<\" \"<<j<<endl;\\n               j = 0;\\n           }\\n       } \\n       count = max(count,j);\\n       return count;\\n    }\\n};\\n```\\nUPVOTE :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n       int count = 0;\\n       int j  = 0;\\n       for(int i = 0; i < nums.size(); i++){\\n           if(nums[i]==1){\\n               j++;\\n           }\\n           else{\\n               count = max(count,j);\\n               cout<<count<<\" \"<<j<<endl;\\n               j = 0;\\n           }\\n       } \\n       count = max(count,j);\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558951,
                "title": "beginners-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max=0;\\n        int count=0;\\n        for(int a: nums){\\n            if(a==1){\\n                count++;\\n            }\\n            if(a==0) count=0;\\n            max= Math.max(max,count);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max=0;\\n        int count=0;\\n        for(int a: nums){\\n            if(a==1){\\n                count++;\\n            }\\n            if(a==0) count=0;\\n            max= Math.max(max,count);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369782,
                "title": "best-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        int max=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                if(count>max){\\n                    max=count;\\n                }\\n                count=0;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n        }\\n        return max;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        int max=-1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                if(count>max){\\n                    max=count;\\n                }\\n                count=0;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n        }\\n        return max;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322177,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c = 0\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                c += 1\\n            else:\\n                a.append(c)\\n                c = 0\\n        a.append(c)\\n        return max(a)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c = 0\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i] == 1:\\n                c += 1\\n            else:\\n                a.append(c)\\n                c = 0\\n        a.append(c)\\n        return max(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285757,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n     \\n    int count=0;\\n    int ans=0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]==1)\\n        {\\n            count++;\\n            ans=max(count,ans);\\n        }\\n        else\\n            count=0;\\n    }\\n    return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n     \\n    int count=0;\\n    int ans=0;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]==1)\\n        {\\n            count++;\\n            ans=max(count,ans);\\n        }\\n        else\\n            count=0;\\n    }\\n    return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154507,
                "title": "simple-java-solution-using-two-pointers",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            int j= i;\\n            while(j<n && nums[j]==1){\\n                j++;\\n            }\\n            ans = Math.max(ans, j-i+1);\\n            i=j;\\n        }\\n        return ans-1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n\\n        for(int i=0;i<n;i++){\\n            int j= i;\\n            while(j<n && nums[j]==1){\\n                j++;\\n            }\\n            ans = Math.max(ans, j-i+1);\\n            i=j;\\n        }\\n        return ans-1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075437,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return max(sum(g) for _, g in groupby(nums))\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/31950073-0e54-4c9d-8e31-0c5508ced332_1674191360.5856655.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        return max(sum(g) for _, g in groupby(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904784,
                "title": "c-easy-o-n-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Linear search , counting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& vec) {\\n        int count = 0;\\n        int ans = 0;\\n        for(auto i : vec) {\\n            if(i == 1) count++;\\n            else {\\n                count = 0;\\n            }\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& vec) {\\n        int count = 0;\\n        int ans = 0;\\n        for(auto i : vec) {\\n            if(i == 1) count++;\\n            else {\\n                count = 0;\\n            }\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871830,
                "title": "java-solution-o-n-98-faster",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] arr) {\\n        int counter=0;\\n        int currone=0;\\n        for(int i:arr){\\n            if(i==0){\\n                currone=Math.max(currone,counter);\\n                counter=0;\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        currone=Math.max(currone,counter);\\n        return currone;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] arr) {\\n        int counter=0;\\n        int currone=0;\\n        for(int i:arr){\\n            if(i==0){\\n                currone=Math.max(currone,counter);\\n                counter=0;\\n            }\\n            else{\\n                counter++;\\n            }\\n        }\\n        currone=Math.max(currone,counter);\\n        return currone;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767953,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = []\\n        s=0\\n        nums.append(0)\\n        for i in range(0,len(nums)):\\n            if nums[i] == 1:\\n                s+=1\\n            else:\\n                res.append(s)\\n                s=0\\n        return max(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = []\\n        s=0\\n        nums.append(0)\\n        for i in range(0,len(nums)):\\n            if nums[i] == 1:\\n                s+=1\\n            else:\\n                res.append(s)\\n                s=0\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219606,
                "title": "python-explanation-provided",
                "content": "**Pre-Planning:**\\n\\tA) To start, I knew I needed to have a counter for this problem. \\n\\tB) Next, I thought I would need to initalize a loop in order to go through the whole array\\n\\tC) Next, I thought I should have a comparison to see if the next array element is a 0 or 1\\n\\tD) Lastly, I figured that if the number is 1, I would need to increment the counter, but also check if the current count is greater than the overall max count. From here, I realized I will need to add a second counter in order to store the maximum count. Check the \"How I could of made this better\" section to see a better way of going about this\\n\\tE) Lastly, I knew if the count was zero, I would need to reset the counter\\n\\t\\n**Explanation:**\\n\\tA) Using my preplanning, I started by initalizing a counter, and a max counter I discovered in step D of my preplanning\\n\\tB) From here, I started my for loop that went to the end of the array\\n\\tC) Next, I used an if statement to check if the current element the loop is on if a 1 or 0. \\n\\tD) For if the current element is a 1, I incremented the counter by 1. Next, I figured I would need to check if the counter is greater than the max counter count. If true, I would overwrite the max counter with the current counters count. Please check the \"How I could of made this better\"/ Better Code section to see a better way of writing my code.\\n\\tE) For if the current element is a 0, I reset the count back down to zero, and moved onto the next array\\'s element.\\n\\n**Code:**\\n\\n\\tclass Solution(object):\\n\\t\\tdef findMaxConsecutiveOnes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tcount = 0\\n\\t\\t\\tmaxCount = 0\\n\\t\\t\\tfor x in range(0,len(nums)):\\n\\t\\t\\t\\tif nums[x] == 1:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count > maxCount:\\n\\t\\t\\t\\t\\t\\tmaxCount = count\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:          \\n\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\treturn maxCount\\n\\t\\t\\n----\\n\\n**How I Could Of Made This Better:**\\n\\tA) One way I discovered how to make this code better is by rewriting the for loop. Making a simple \"For x in nums:\" will cut down on the time it takes to write the code. Next, I found replace the if statement that checks if the counter is greater than the max counter. There is a max function that can be used that takes less runtime to compute which value is greater. Please view below to see how to implement this into the previous code provided.\\n\\n**Better Code:**\\n\\t\\n\\tclass Solution(object):\\n\\t\\tdef findMaxConsecutiveOnes(self, nums):\\n\\t\\t\"\"\"\\n\\t\\t:type nums: List[int]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tmaxCount, count = 0, 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num == 1:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tmaxCount = max(count, maxCount)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 0\\n\\t\\treturn maxCount\\n\\t\\t\\n----\\n**Thank You For Reading**\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Pre-Planning:**\\n\\tA) To start, I knew I needed to have a counter for this problem. \\n\\tB) Next, I thought I would need to initalize a loop in order to go through the whole array\\n\\tC) Next, I thought I should have a comparison to see if the next array element is a 0 or 1\\n\\tD) Lastly, I figured that if the number is 1, I would need to increment the counter, but also check if the current count is greater than the overall max count. From here, I realized I will need to add a second counter in order to store the maximum count. Check the \"How I could of made this better\" section to see a better way of going about this\\n\\tE) Lastly, I knew if the count was zero, I would need to reset the counter\\n\\t\\n**Explanation:**\\n\\tA) Using my preplanning, I started by initalizing a counter, and a max counter I discovered in step D of my preplanning\\n\\tB) From here, I started my for loop that went to the end of the array\\n\\tC) Next, I used an if statement to check if the current element the loop is on if a 1 or 0. \\n\\tD) For if the current element is a 1, I incremented the counter by 1. Next, I figured I would need to check if the counter is greater than the max counter count. If true, I would overwrite the max counter with the current counters count. Please check the \"How I could of made this better\"/ Better Code section to see a better way of writing my code.\\n\\tE) For if the current element is a 0, I reset the count back down to zero, and moved onto the next array\\'s element.\\n\\n**Code:**\\n\\n\\tclass Solution(object):\\n\\t\\tdef findMaxConsecutiveOnes(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tcount = 0\\n\\t\\t\\tmaxCount = 0\\n\\t\\t\\tfor x in range(0,len(nums)):\\n\\t\\t\\t\\tif nums[x] == 1:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\tif count > maxCount:\\n\\t\\t\\t\\t\\t\\tmaxCount = count\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\telse:          \\n\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\treturn maxCount\\n\\t\\t\\n----\\n\\n**How I Could Of Made This Better:**\\n\\tA) One way I discovered how to make this code better is by rewriting the for loop. Making a simple \"For x in nums:\" will cut down on the time it takes to write the code. Next, I found replace the if statement that checks if the counter is greater than the max counter. There is a max function that can be used that takes less runtime to compute which value is greater. Please view below to see how to implement this into the previous code provided.\\n\\n**Better Code:**\\n\\t\\n\\tclass Solution(object):\\n\\t\\tdef findMaxConsecutiveOnes(self, nums):\\n\\t\\t\"\"\"\\n\\t\\t:type nums: List[int]\\n\\t\\t:rtype: int\\n\\t\\t\"\"\"\\n\\t\\tmaxCount, count = 0, 0\\n\\t\\tfor num in nums:\\n\\t\\t\\tif num == 1:\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tmaxCount = max(count, maxCount)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount = 0\\n\\t\\treturn maxCount\\n\\t\\t\\n----\\n**Thank You For Reading**\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2044556,
                "title": "fastest-and-simplest-approach-in-c-and-java-o-n",
                "content": "**Code in C**\\n```\\nint findMaxConsecutiveOnes(int* nums, int numsSize){\\n    int max = 0;\\n    int count = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] == 0) count = 0;\\n        else if(nums[i] == 1) count++;\\n        if(count > max) max = count;\\n    }\\n    return max;\\n}\\n```\\n\\n**Code in Java**\\n```\\npublic int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 0) count = 0;\\n            else if(nums[i] == 1) count++;\\n            if(count > max) max = count;\\n        }\\n        return max;\\n    }\\n```\\n\\n**Please upvote if you liked the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nint findMaxConsecutiveOnes(int* nums, int numsSize){\\n    int max = 0;\\n    int count = 0;\\n    for(int i=0; i<numsSize; i++){\\n        if(nums[i] == 0) count = 0;\\n        else if(nums[i] == 1) count++;\\n        if(count > max) max = count;\\n    }\\n    return max;\\n}\\n```\n```\\npublic int findMaxConsecutiveOnes(int[] nums) {\\n        int max = 0;\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == 0) count = 0;\\n            else if(nums[i] == 1) count++;\\n            if(count > max) max = count;\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028572,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        tmp = 0\\n        \\n        for num in nums:\\n            if num == 0:\\n                tmp = 0\\n            else:\\n                tmp += 1\\n                res = max(res, tmp)\\n        \\n        return res\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = 0\\n        tmp = 0\\n        \\n        for num in nums:\\n            if num == 0:\\n                tmp = 0\\n            else:\\n                tmp += 1\\n                res = max(res, tmp)\\n        \\n        return res\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501904,
                "title": "c-solution-97-fast-using-simple-for-loop",
                "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums)\\n    {\\n        int maximum = 0,greed = 0;\\n        for(int i =0;i < nums.size();i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                greed++;\\n                if(maximum < greed)\\n                {\\n                    maximum = greed;\\n                }\\n            }\\n            else\\n            {\\n               greed = 0; \\n            }\\n        }\\n        return maximum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums)\\n    {\\n        int maximum = 0,greed = 0;\\n        for(int i =0;i < nums.size();i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                greed++;\\n                if(maximum < greed)\\n                {\\n                    maximum = greed;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1477080,
                "title": "c-o-n-concise-solution",
                "content": "```\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int res=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]==1?count++:count=0;\\n            res=max(res, count);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int res=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]==1?count++:count=0;\\n            res=max(res, count);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1476374,
                "title": "c-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c = 0, res = INT_MIN;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i] == 1)\\n                c++;\\n            if(nums[i] == 0) {\\n                res = max(c, res);\\n                c = 0;\\n            }\\n        }\\n        res = max(c, res); // if last element is 1 corresp. to last window of 1s, that c is being updated in res here\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c = 0, res = INT_MIN;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i] == 1)\\n                c++;\\n            if(nums[i] == 0) {\\n                res = max(c, res);\\n                c = 0;\\n            }\\n        }\\n        res = max(c, res); // if last element is 1 corresp. to last window of 1s, that c is being updated in res here\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476237,
                "title": "c-o-n-time-complexity-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int total = 0;\\n        int res = 0;\\n        \\n        for(auto n : nums) {\\n            if(n) {\\n                total++;\\n                res = max(res, total);\\n            } else {\\n                total = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int total = 0;\\n        int res = 0;\\n        \\n        for(auto n : nums) {\\n            if(n) {\\n                total++;\\n                res = max(res, total);\\n            } else {\\n                total = 0;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476161,
                "title": "c-5-line-solution-with-easy-explanation",
                "content": "\\n```\\nint findMaxConsecutiveOnes(int* nums, int numsSize){\\n    int longest_len=0, streak_len=0, i;\\n    for(i=0; i<numsSize; i++){\\n        longest_len = streak_len > longest_len ? streak_len : longest_len ;\\n        streak_len=(streak_len+1)*nums[i]; }\\n    return( streak_len > longest_len ? streak_len : longest_len );\\n}\\n```\\n.\\nTime Complexity : **O(n)**\\n.\\nApproach : Window search with multiplication for reset.\\n.\\nWhile iterating through each element, **longest_len** is updated to see if the new streak is the highest. And **streak_len** is incremented once to account for another 1 in the streak. **Streak_len** is then multiplied by **num[i]**, so that **streak_len** will be reset to zero if **num[i]** is 0 and left unchanged if **num[i]** is 1.\\n.\\nFinally, since each updation of **longest_len** happens before incrementing **streak_len** in the loop, the updation check will have to be done one last time before returning.\\n.\\nFeel free to ask any questions and to suggest improvements. If you found it cool, ***please upvote***.",
                "solutionTags": [],
                "code": "```\\nint findMaxConsecutiveOnes(int* nums, int numsSize){\\n    int longest_len=0, streak_len=0, i;\\n    for(i=0; i<numsSize; i++){\\n        longest_len = streak_len > longest_len ? streak_len : longest_len ;\\n        streak_len=(streak_len+1)*nums[i]; }\\n    return( streak_len > longest_len ? streak_len : longest_len );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416244,
                "title": "no-if-else-python-solution",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        highest = 0\\n        \\n        current = 0\\n        for n in nums:\\n            current = (current + n) * n\\n            highest = max(current, highest)\\n            \\n        return highest\\n```\\n\\nif n is 1, add 1 to current and multiply it by 1 \\nif n is 0, add 0 to current and zero it out\\nmax is evaluated on every iteration for O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        highest = 0\\n        \\n        current = 0\\n        for n in nums:\\n            current = (current + n) * n\\n            highest = max(current, highest)\\n            \\n        return highest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357715,
                "title": "easy-solution-linear-time-o-n-c",
                "content": "int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                curr = 0;\\n            }\\n            else{\\n                curr++;\\n                res = max(curr,res);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int curr=0;\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                curr = 0;\\n            }\\n            else{\\n                curr++;\\n                res = max(curr,res);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1323677,
                "title": "easy-4-line-code-java-simple",
                "content": "```\\n        int max=0 ,current_ones =0; \\n        for(int n : nums)\\n            max=Math.max(max,current_ones =n ==0 ? 0 : current_ones+1);\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int max=0 ,current_ones =0; \\n        for(int n : nums)\\n            max=Math.max(max,current_ones =n ==0 ? 0 : current_ones+1);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280357,
                "title": "c-single-loop-solution",
                "content": "Time complexity:O(n)\\nSpace complexity:O(1)\\n```\\nclass Solution {\\npublic:\\n    int count=0,res=0;\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```\\nif you like the solution,upvote it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0,res=0;\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                count=0;\\n            }\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084054,
                "title": "simple-python-solution-using-strings",
                "content": "```\\nclass Solution:\\n\\tdef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = \"\"\\n        for i in nums:\\n            res=res+str(i)\\n        l = res.split(\\'0\\')\\n        return len(max(l))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n\\tdef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res = \"\"\\n        for i in nums:\\n            res=res+str(i)\\n        l = res.split(\\'0\\')\\n        return len(max(l))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983244,
                "title": "python-o-n-time-o-1-space-solution-using-sliding-window-with-explanation",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_length = 0\\n        window_start = 0\\n        window_end = 0\\n        \\n        for window_end in range(len(nums)):\\n            if nums[window_end] == 0:\\n                window_start = window_end + 1\\n            else:\\n                current_length = window_end - window_start + 1\\n                max_length = current_length if current_length > max_length else max_length\\n        return max_length\\n```\\n\\n##### **Explanation:** \\n**Keyword** \\u2013 Max Consecutive. So, we can use sliding window technique here. \\n**Strategy:** \\n\\u2022\\tStart iterating through the array from the beginning. \\n\\u2022\\tKeep track of a window of 1\\u2019s, keep track of the starting index and ending index of the window. Initially, both starts from index 0, and window_end will grow in every iteration of the for loop. **Reset window_start whenever the sequence of 1\\u2019s is broken.** \\n\\u2022\\tKeep track of the maximum window length in every iteration. \\n\\u2022\\tFinally, when we are done looping through the array, return max_length. \\n\\n![image](https://assets.leetcode.com/users/images/a4480fe1-505d-4f92-9999-ceec8b52ca83_1608730056.670201.png)\\n\\n![image](https://assets.leetcode.com/users/images/07a4d09a-8c07-439b-bf04-d23fa9d3bb43_1608730069.8977163.png)\\n\\n**Time** \\u2013 O(n), as we are traversing through the elements of the array only once.\\n**Space** \\u2013 O(1), because no secondary storage is needed to solve this problem.  \\n\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_length = 0\\n        window_start = 0\\n        window_end = 0\\n        \\n        for window_end in range(len(nums)):\\n            if nums[window_end] == 0:\\n                window_start = window_end + 1\\n            else:\\n                current_length = window_end - window_start + 1\\n                max_length = current_length if current_length > max_length else max_length\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514993,
                "title": "easy-javascript-solution-60ms-time-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n  let count = 0;\\n  let maxLen = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) count++;\\n    if (nums[i + 1] !== 1 && count > maxLen) maxLen = count;\\n    if (nums[i] === 0) count = 0;\\n  }\\n  \\n  return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n  let count = 0;\\n  let maxLen = 0;\\n  \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 1) count++;\\n    if (nums[i + 1] !== 1 && count > maxLen) maxLen = count;\\n    if (nums[i] === 0) count = 0;\\n  }\\n  \\n  return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497511,
                "title": "javascript-using-reduce",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n  let counter = 0;\\n  return nums.reduce((acc, cur) => {\\n    counter = cur ? counter + 1 : 0;\\n    return Math.max(acc, counter);\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n  let counter = 0;\\n  return nums.reduce((acc, cur) => {\\n    counter = cur ? counter + 1 : 0;\\n    return Math.max(acc, counter);\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480009,
                "title": "python-o-n-sol-based-on-counter-of-consecutive-ones-85-with-explanation",
                "content": "Python O( n ) sol. based on counter of consecutive ones.\\n\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        \\n        \\n        max_ones_length = 0\\n        cur_ones_length = 0\\n        \\n        for x in nums:\\n            \\n            if x == 1:\\n                # current number is one\\n                \\n                # increase consecutive ones length by 1\\n                cur_ones_length += 1\\n                \\n            else:\\n                \\n                # update max consecutive ones length\\n                max_ones_length = max( max_ones_length, cur_ones_length )\\n\\n                # current number is zero\\n                cur_ones_length = 0            \\n        \\n        return max( max_ones_length, cur_ones_length )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        \\n        \\n        max_ones_length = 0\\n        cur_ones_length = 0\\n        \\n        for x in nums:\\n            \\n            if x == 1:\\n                # current number is one\\n                \\n                # increase consecutive ones length by 1\\n                cur_ones_length += 1\\n                \\n            else:\\n                \\n                # update max consecutive ones length\\n                max_ones_length = max( max_ones_length, cur_ones_length )\\n\\n                # current number is zero\\n                cur_ones_length = 0            \\n        \\n        return max( max_ones_length, cur_ones_length )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191395,
                "title": "javascript",
                "content": "```\nvar findMaxConsecutiveOnes = function(nums) {\n    let result = 0;\n    let current = 0;\n    for(let n of nums) {\n        if(n == 0) {\n            result = Math.max(result, current);\n            current = 0;\n        } else {\n            current++;\n        }\n    }\n    return Math.max(result,current);\n};\n```",
                "solutionTags": [],
                "code": "```\nvar findMaxConsecutiveOnes = function(nums) {\n    let result = 0;\n    let current = 0;\n    for(let n of nums) {\n        if(n == 0) {\n            result = Math.max(result, current);\n            current = 0;\n        } else {\n            current++;\n        }\n    }\n    return Math.max(result,current);\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96709,
                "title": "two-pointer-solution",
                "content": "Use slow pointer ```s``` to go through all the ```0```s, \\nand use fast pointer ```f``` to go through all the ```1```s ,\\ncheck the max length each time when ```f``` reach a ```0```.\\n```\\npublic class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int max=0, s=0, f=0, n=nums.Length;\\n        \\n        while(f<n){\\n            //move s to 1\\n            while(s<n && nums[s]==0) s++;\\n            f=s;\\n            //move f = 0\\n            while(f<n && nums[f]==1) f++;\\n            \\n            //calculate and reset s\\n            max=Math.Max(max, f-s);\\n            s=f;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```s```\n```0```\n```f```\n```1```\n```f```\n```0```\n```\\npublic class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int max=0, s=0, f=0, n=nums.Length;\\n        \\n        while(f<n){\\n            //move s to 1\\n            while(s<n && nums[s]==0) s++;\\n            f=s;\\n            //move f = 0\\n            while(f<n && nums[f]==1) f++;\\n            \\n            //calculate and reset s\\n            max=Math.Max(max, f-s);\\n            s=f;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96758,
                "title": "c-solution-ac",
                "content": "C# Solution\\n'''\\npublic class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0;\\n        int currentCount = 0;\\n    \\n        foreach(int num in nums)\\n        {\\n        \\tif(num == 1)\\n        \\t{\\n        \\t\\tcurrentCount ++;\\n        \\t\\tif(currentCount > maxCount)\\n        \\t\\t{\\n        \\t\\t\\tmaxCount = currentCount;\\n        \\t\\t}\\n        \\t}\\n        \\telse\\n        \\t{\\n        \\t\\tcurrentCount = 0;\\n        \\t}\\n        }\\n    \\n    return maxCount;\\n    }\\n}\\n'''",
                "solutionTags": [],
                "code": "class Solution {\\n    public int FindMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0;\\n        int currentCount = 0;\\n    \\n        foreach(int num in nums)\\n        {\\n        \\tif(num == 1)\\n        \\t{\\n        \\t\\tcurrentCount ++;\\n        \\t\\tif(currentCount > maxCount)\\n        \\t\\t{\\n        \\t\\t\\tmaxCount = currentCount;\\n        \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 96825,
                "title": "concise-c-solution",
                "content": "```class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (nums[i]){\\n                if (++count > max) max = count;\\n            }\\n            else count = 0;\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < nums.size(); ++i){\\n            if (nums[i]){\\n                if (++count > max) max = count;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4014814,
                "title": "basic-c-code-o-n-solution-with-explanation",
                "content": "# Intuition\\nWe can find the maximum consecutive ones in the given binary array by iterating through it and keeping track of the current consecutive ones count and the maximum count seen so far.\\n\\n# Approach\\n1. Initialize `count_max` and `count_now` to 0 to store the maximum consecutive ones count and the current consecutive ones count, respectively.\\n2. Iterate through the input `nums`:\\n   - If the current element is 1, increment `count_now`.\\n   - If the current element is 0, reset `count_now` to 0.\\n   - Update `count_max` if `count_now` is greater.\\n3. After iterating through the entire array, `count_max` will hold the maximum consecutive ones count.\\n4. Return `count_max` as the result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - We traverse the input array once.\\n- Space complexity: $$O(1)$$ - We use a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count_max=0;\\n        int count_now=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count_now+=1;\\n            }\\n            else{\\n                count_now=0;\\n            }\\n            if(count_max<count_now){\\n                count_max=count_now;\\n            }\\n        }\\n        return count_max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count_max=0;\\n        int count_now=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count_now+=1;\\n            }\\n            else{\\n                count_now=0;\\n            }\\n            if(count_max<count_now){\\n                count_max=count_now;\\n            }\\n        }\\n        return count_max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997636,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0; // Initialize the maximum consecutive ones count.\\n        int currentCount = 0; // Initialize the current consecutive ones count.\\n\\n        for (int num : nums) {\\n            if (num == 1) {\\n                // If the current number is 1, increment the current consecutive ones count.\\n                currentCount++;\\n            } else {\\n                // If the current number is not 1, update the maximum count if needed and reset the current count.\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n            }\\n        }\\n\\n        // After the loop, update the maximum count one more time (in case the sequence ends with consecutive ones).\\n        maxCount = Math.max(maxCount, currentCount);\\n\\n        return maxCount;\\n    }\\n}\\n//Here\\'s how the corrected code works:\\n\\n//It initializes two variables, maxCount and currentCount, to keep track of the maximum consecutive ones count and the current consecutive ones count, respectively.\\n\\n//It iterates through the elements of the input array nums.\\n\\n//If the current element is 1, it increments currentCount.\\n\\n//If the current element is not 1 (i.e., 0), it updates maxCount with the maximum value between maxCount and currentCount and resets currentCount to 0.\\n\\n//After the loop, it updates maxCount one more time to ensure the correct count in case the sequence ends with consecutive ones.\\n\\n//Finally, it returns maxCount as the maximum consecutive ones count in the array.\\n\\n//This code should correctly find the maximum consecutive ones in the input array nums.\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0; // Initialize the maximum consecutive ones count.\\n        int currentCount = 0; // Initialize the current consecutive ones count.\\n\\n        for (int num : nums) {\\n            if (num == 1) {\\n                // If the current number is 1, increment the current consecutive ones count.\\n                currentCount++;\\n            } else {\\n                // If the current number is not 1, update the maximum count if needed and reset the current count.\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n            }\\n        }\\n\\n        // After the loop, update the maximum count one more time (in case the sequence ends with consecutive ones).\\n        maxCount = Math.max(maxCount, currentCount);\\n\\n        return maxCount;\\n    }\\n}\\n//Here\\'s how the corrected code works:\\n\\n//It initializes two variables, maxCount and currentCount, to keep track of the maximum consecutive ones count and the current consecutive ones count, respectively.\\n\\n//It iterates through the elements of the input array nums.\\n\\n//If the current element is 1, it increments currentCount.\\n\\n//If the current element is not 1 (i.e., 0), it updates maxCount with the maximum value between maxCount and currentCount and resets currentCount to 0.\\n\\n//After the loop, it updates maxCount one more time to ensure the correct count in case the sequence ends with consecutive ones.\\n\\n//Finally, it returns maxCount as the maximum consecutive ones count in the array.\\n\\n//This code should correctly find the maximum consecutive ones in the input array nums.\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961532,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,res=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count+=1;\\n            }\\n            else{\\n                res=max(res,count);\\n                count=0;\\n            }\\n        }\\n        res=max(res,count);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,res=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count+=1;\\n            }\\n            else{\\n                res=max(res,count);\\n                count=0;\\n            }\\n        }\\n        res=max(res,count);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804075,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n# Approach\\n- To find the maximum count of ones in a sequence, we store the count of ones and compare it with the current maximum. If the count is greater than the current maximum, we update the maximum count. However, if we encounter a zero in the sequence, we reset the count to zero and continue counting ones.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        \\n        int count =0;\\n        int freq = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                count =0;\\n            }\\n            freq = max(count,freq);\\n        }\\n        return freq;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        \\n        int count =0;\\n        int freq = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else{\\n                count =0;\\n            }\\n            freq = max(count,freq);\\n        }\\n        return freq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760645,
                "title": "easy-solution-in-python-with-clear-explanation",
                "content": "# Intuition\\nHere we can just convert the whole list into the string and use split funtion by 0 so we ge the 1\\'s alone separated and store the maximum length of the 1\\'s in our answer and return it.\\n# Approach\\n**Step 1 :** Using `map` function convert the whole `list` into `string`.\\n\\n```python []\\nkk = \\'\\'.join(map(str, nums))\\n```\\n\\n**Step 2 :** Using split function split the string by 0 so where ever we get 0 it get splited so the consicutive 1\\'s alone will be stored in the list `ll` and initialize the `max_len = 0` so that each time we iterate the list `ll` we store the maximum length of the element and `return max_length` after the complete iteration.\\n\\n```python []\\nll = kk.split(\\'0\\')\\n        max_len = 0\\n        for i in ll:\\n            if len(i) > max_len:\\n                max_len = len(i)\\n        return(max_len)\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        kk = \\'\\'.join(map(str, nums))\\n\\n        ll = kk.split(\\'0\\')\\n        max_len = 0\\n        for i in ll:\\n            if len(i) > max_len:\\n                max_len = len(i)\\n        return(max_len)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```python []\\nkk = \\'\\'.join(map(str, nums))\\n```\n```python []\\nll = kk.split(\\'0\\')\\n        max_len = 0\\n        for i in ll:\\n            if len(i) > max_len:\\n                max_len = len(i)\\n        return(max_len)\\n```\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        kk = \\'\\'.join(map(str, nums))\\n\\n        ll = kk.split(\\'0\\')\\n        max_len = 0\\n        for i in ll:\\n            if len(i) > max_len:\\n                max_len = len(i)\\n        return(max_len)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717749,
                "title": "max-consecutive-ones-easy-python-code-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_ones = 0\\n        count = 0\\n        for num in nums:\\n            if num == 1:\\n                count = count + 1 # Increment the current count when one is encountered\\n                max_ones = max(max_ones,count) # Update the count of maximum consecutive ones\\n            # If 0 is encountered, Reset the current count to 0\\n            else:\\n                count = 0\\n        return max_ones\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_ones = 0\\n        count = 0\\n        for num in nums:\\n            if num == 1:\\n                count = count + 1 # Increment the current count when one is encountered\\n                max_ones = max(max_ones,count) # Update the count of maximum consecutive ones\\n            # If 0 is encountered, Reset the current count to 0\\n            else:\\n                count = 0\\n        return max_ones\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661280,
                "title": "easy-solution-javascript",
                "content": "# Approach\\n    Initialize two variables, maxCount and count, to keep track of the maximum consecutive ones and the current consecutive ones count, respectively. \\n\\n    Iterate over each element of the input array nums using a for loop.\\n    For each element, check if it is equal to 1.\\n\\n    If the element is 1, increment the count variable to track the consecutive ones count.\\n\\n    Update the maxCount variable by taking the maximum between the current maxCount and the count variable. This ensures that maxCount always holds the maximum consecutive ones count encountered so far.\\n\\n    If the element is not 1, reset the count variable to 0 since the consecutive sequence of ones is broken.\\n\\n    After iterating over all the elements, return the maxCount, which represents the maximum consecutive ones count in the input array.\\n\\n# Complexity\\n- Time complexity : O(n)\\n\\n\\n- Space complexity : O(1)\\n\\n\\n# Code\\n```\\n\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let maxCount = 0;\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            count++;\\n            maxCount = Math.max(maxCount, count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n    return maxCount;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let maxCount = 0;\\n    let count = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            count++;\\n            maxCount = Math.max(maxCount, count);\\n        } else {\\n            count = 0;\\n        }\\n    }\\n    return maxCount;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657465,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n            else ans=0;\\n            res=max(res,ans); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        int res=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n            else ans=0;\\n            res=max(res,ans); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558611,
                "title": "python-1-line-code-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\npurpose of each part of the code\\n[str(i) for i in nums]  : gives a list of char\\n\\n\"\".join()               : makes a str from list of char\\n\\n.split(\"0\")             : splits the given string into a list of strs(containg 1\\'s) by breaking it at 0\\n\\nlen(i) for i in : gives a list which contains the length of each the strs\\n\\nmax()     : gives us the highest length in the list\\n                \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\n\\n        return max([len(i) for i in (\\'\\'.join([str(i) for i in nums])).split(\"0\")])\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\n\\n        return max([len(i) for i in (\\'\\'.join([str(i) for i in nums])).split(\"0\")])\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506796,
                "title": "efficient-javascript-solution",
                "content": "# Intuition\\nThe problem is straightforward. We have to find the maximum number of consecutive 1\\'s in a binary array. To do this, we can iterate through the array, keeping track of the current streak of 1\\'s and the maximum streak of 1\\'s we\\'ve seen so far.\\n\\n# Approach\\nWe can solve this problem using a single pass through the array. We\\'ll maintain two variables: one for the current streak of 1\\'s (current) and one for the maximum streak of 1\\'s we\\'ve seen so far (max).\\n\\nAs we iterate through the array, if we encounter a 1, we increment current. If we encounter a 0, we reset current to 0. After each step, we compare current to max, and if current is greater, we update max.\\n\\nAt the end of the iteration, max will hold the length of the longest streak of 1\\'s in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            current += 1;\\n        } else {\\n            current = 0;\\n        }\\n\\n        if (current > max) {\\n            max = current;\\n        } \\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMaxConsecutiveOnes = function(nums) {\\n    let max = 0;\\n    let current = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 1) {\\n            current += 1;\\n        } else {\\n            current = 0;\\n        }\\n\\n        if (current > max) {\\n            max = current;\\n        } \\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3487840,
                "title": "beating-90-79-python-simplest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/04b95b39-4cdb-4029-8cad-3cde85a43cc7_1683268134.9841359.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        res, x = 0, 0\\n        for i in nums:\\n            if i: x+=1\\n            else:\\n                res = max(x,res)\\n                x=0\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        nums.append(0)\\n        res, x = 0, 0\\n        for i in nums:\\n            if i: x+=1\\n            else:\\n                res = max(x,res)\\n                x=0\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463482,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxOne=0;\\n        int ch=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                ch++;\\n                maxOne=Math.max(maxOne,ch);\\n                \\n               \\n            }\\n            else if(nums[i]==0)\\n            {\\n                ch=0;\\n            }\\n        }\\n        return maxOne;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxOne=0;\\n        int ch=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                ch++;\\n                maxOne=Math.max(maxOne,ch);\\n                \\n               \\n            }\\n            else if(nums[i]==0)\\n            {\\n                ch=0;\\n            }\\n        }\\n        return maxOne;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373549,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans=0, count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]!=1)\\n            {   ans = max(ans, count); \\n                count=0;\\n            }\\n            else\\n                count++;\\n        }\\n        return max(ans, count);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_consecutive = 0\\n        current_consecutive = 0\\n        for elem in nums:\\n            if elem == 0:\\n                current_consecutive = 0\\n            else:\\n                current_consecutive += 1\\n                if current_consecutive > max_consecutive:\\n                    max_consecutive = current_consecutive\\n        return max_consecutive\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max =0;\\n        int count =0;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                max=Math.max(count,max);\\n                count =0;\\n                continue;\\n            }\\n            count+=1;\\n        }\\n        return Math.max(count,max);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans=0, count=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]!=1)\\n            {   ans = max(ans, count); \\n                count=0;\\n            }\\n            else\\n                count++;\\n        }\\n        return max(ans, count);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        max_consecutive = 0\\n        current_consecutive = 0\\n        for elem in nums:\\n            if elem == 0:\\n                current_consecutive = 0\\n            else:\\n                current_consecutive += 1\\n                if current_consecutive > max_consecutive:\\n                    max_consecutive = current_consecutive\\n        return max_consecutive\\n```\n```Java []\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int max =0;\\n        int count =0;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                max=Math.max(count,max);\\n                count =0;\\n                continue;\\n            }\\n            count+=1;\\n        }\\n        return Math.max(count,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251765,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        \\n        int count = 0 , num=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else\\n            count = 0;\\n            if(count>num)\\n            num=count;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        \\n        int count = 0 , num=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n            else\\n            count = 0;\\n            if(count>num)\\n            num=count;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230737,
                "title": "java-array-best-solution-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int n=nums.length;\\n        int cout=0,max=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n               cout++;\\n               if(cout>max){\\n               max=cout;\\n               }\\n            }\\n            else{\\n                cout=0;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int n=nums.length;\\n        int cout=0,max=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n               cout++;\\n               if(cout>max){\\n               max=cout;\\n               }\\n            }\\n            else{\\n                cout=0;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3208227,
                "title": "most-easy-solution-2ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903920,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0;\\n        int max=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]==1 ){\\n                    \\n                    c+=1;\\n                }\\n                else{\\n                    if(max<c){\\n                        max=c;\\n                    }\\n                    c=0;\\n\\n                }\\n        }\\n        if(c>max){\\n            return c;\\n        }\\n    return max; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0;\\n        int max=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]==1 ){\\n                    \\n                    c+=1;\\n                }\\n                else{\\n                    if(max<c){\\n                        max=c;\\n                    }\\n                    c=0;\\n\\n                }\\n        }\\n        if(c>max){\\n            return c;\\n        }\\n    return max; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835405,
                "title": "java-o-n-3ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (max < count) {\\n                    max = count;\\n                }\\n                count = 0;\\n            }\\n            else count++;\\n        }\\n        if (max < count) {\\n            max = count;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count = 0, max = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                if (max < count) {\\n                    max = count;\\n                }\\n                count = 0;\\n            }\\n            else count++;\\n        }\\n        if (max < count) {\\n            max = count;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763285,
                "title": "simple-python-solution-dp-solution",
                "content": "```\\n1st solution\\n\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res, cur = 0, 0\\n        \\n        for n in nums:  \\n\\t\\t\\t# we multiply cur by n to reset cur in case n is equal to 0\\n            cur = cur * n + n\\n            res = max(cur, res)\\n        \\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\n\\n```\\n2nd solution\\n\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * (n + 1)\\n        \\n        for i in range(n):\\n            dp[i+1] = dp[i] + 1 if nums[i] else 0\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "solutionTags": [],
                "code": "```\\n1st solution\\n\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        res, cur = 0, 0\\n        \\n        for n in nums:  \\n\\t\\t\\t# we multiply cur by n to reset cur in case n is equal to 0\\n            cur = cur * n + n\\n            res = max(cur, res)\\n        \\n        return res\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\n```\\n2nd solution\\n\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * (n + 1)\\n        \\n        for i in range(n):\\n            dp[i+1] = dp[i] + 1 if nums[i] else 0\\n        \\n        return max(dp)\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745335,
                "title": "c-code",
                "content": "**approch **\\ntraverse every element of given binar array so time complexity will be O(n).\\ncheck if element of array is equal to 1 continue the process and increment count until it is 1.as you will get array element equal to 0 reset the  count . before reseting store the count take the maximum of all count.`class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,max1=0;\\n    \\n            for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1 )\\n            {\\n                count++;\\n                max1=max(count,max1);\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n        }\\n        cout<<max1<<endl;\\n        return max1;\\n    }\\n};`",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,max1=0;\\n    \\n            for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1 )\\n            {\\n                count++;\\n                max1=max(count,max1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2715815,
                "title": "python-simple-solution-in-o-n",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c=m=0\\n        for i in nums:\\n            if i==1:\\n                c+=1\\n                m=max(m,c)\\n            else:\\n                c=0\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        c=m=0\\n        for i in nums:\\n            if i==1:\\n                c+=1\\n                m=max(m,c)\\n            else:\\n                c=0\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669388,
                "title": "c-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count =0,maxi=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                count++;\\n                maxi=max(maxi,count);\\n            }\\n            else\\n            {\\n                count=0;\\n            }\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count =0,maxi=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                count++;\\n                maxi=max(maxi,count);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2664607,
                "title": "c-easy-solution-97",
                "content": "```\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxValue = 0;\\n        int count = 0;\\n        // int n = nums.size();\\n        for(auto i: nums){\\n            if (i == 1) maxValue = max(maxValue, ++count);\\n            else count = 0;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     if (nums[i] == 1) {\\n        //         count++;\\n        //         maxValue = max(maxValue, count);\\n        //     } else {\\n        //         count = 0;\\n        //     }\\n        // }\\n        return maxValue;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int maxValue = 0;\\n        int count = 0;\\n        // int n = nums.size();\\n        for(auto i: nums){\\n            if (i == 1) maxValue = max(maxValue, ++count);\\n            else count = 0;\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     if (nums[i] == 1) {\\n        //         count++;\\n        //         maxValue = max(maxValue, count);\\n        //     } else {\\n        //         count = 0;\\n        //     }\\n        // }\\n        return maxValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658757,
                "title": "java-easy-solution-sliding-windows-two-pointer-0-ms-solution",
                "content": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int n=nums.length;\\n        int cur,max=0,i=0,j=0;\\n        while(i<n)\\n        {\\n            while(i<n && nums[i]!=1)\\n                i++;\\n            j=i;\\n            while(j<n && nums[j]==1)\\n                j++;\\n            cur=j-i;\\n            max=Math.max(cur,max);\\n            i=j;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int n=nums.length;\\n        int cur,max=0,i=0,j=0;\\n        while(i<n)\\n        {\\n            while(i<n && nums[i]!=1)\\n                i++;\\n            j=i;\\n            while(j<n && nums[j]==1)\\n                j++;\\n            cur=j-i;\\n            max=Math.max(cur,max);\\n            i=j;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606990,
                "title": "python-simplest-approach-179-ms-by-if-else-only",
                "content": "\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tans=0\\n\\t\\t\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t\\t\\tif i==1:\\n\\t\\t\\t\\t\\t\\t\\ta+=1\\n\\t\\t\\t\\t\\t\\telif i==0:\\n\\t\\t\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\t\\tans=max(ans,a)\\n\\t\\t\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tans=0\\n\\t\\t\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t\\t\\tif i==1:\\n\\t\\t\\t\\t\\t\\t\\ta+=1\\n\\t\\t\\t\\t\\t\\telif i==0:\\n\\t\\t\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\t\\tans=max(ans,a)\\n\\t\\t\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2601931,
                "title": "java-faster-2ms-runtime-easy-and-elegant-solution",
                "content": "```\\nint k = 0;\\nfor (int i = 0; i <= nums.length - 1; i++) {\\n\\tif (nums[i] == 1){\\n\\t\\tk++;\\n\\t\\tif (i == nums.length-1&&k>nums[0])\\n\\t\\t\\treturn k;\\n\\t} else if (k > nums[0]) {\\n\\t\\tnums[0] = k;\\n\\t\\tk =0;\\n\\t} else k = 0;\\n}\\nreturn nums[0];\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint k = 0;\\nfor (int i = 0; i <= nums.length - 1; i++) {\\n\\tif (nums[i] == 1){\\n\\t\\tk++;\\n\\t\\tif (i == nums.length-1&&k>nums[0])\\n\\t\\t\\treturn k;\\n\\t} else if (k > nums[0]) {\\n\\t\\tnums[0] = k;\\n\\t\\tk =0;\\n\\t} else k = 0;\\n}\\nreturn nums[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599944,
                "title": "java-tc-o-n-sc-o-1-simple-one-loop-pass-clean-code",
                "content": "Upvote if the solution helped :) For all my optimised solutions, Click || -->[Here](https://github.com/abhideepghosh/Leetcode-Solutions)<-- ||\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        \\n        int maxCount = 0;\\n        int count = 0;\\n\\n        for(int num : nums){\\n            if(num == 1){\\n                count++;\\n                maxCount = Math.max(count, maxCount);\\n            }else{\\n                count = 0;\\n            }\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        \\n        int maxCount = 0;\\n        int count = 0;\\n\\n        for(int num : nums){\\n            if(num == 1){\\n                count++;\\n                maxCount = Math.max(count, maxCount);\\n            }else{\\n                count = 0;\\n            }\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577523,
                "title": "rust-fold",
                "content": "```\\nimpl Solution {\\n    pub fn find_max_consecutive_ones(nums: Vec<i32>) -> i32 {\\n        let mut cnt = 0;\\n        nums.iter()\\n            .fold(0, |acc, a| {\\n                if *a == 1 {cnt += 1} else {cnt = 0}\\n                acc.max(cnt)\\n            })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_max_consecutive_ones(nums: Vec<i32>) -> i32 {\\n        let mut cnt = 0;\\n        nums.iter()\\n            .fold(0, |acc, a| {\\n                if *a == 1 {cnt += 1} else {cnt = 0}\\n                acc.max(cnt)\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2543573,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        maxi,count = 0,0\\n        for num in nums:\\n            if(num):\\n                count+=1\\n            else:\\n                count =0\\n            maxi = max(maxi,count)\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\\n        maxi,count = 0,0\\n        for num in nums:\\n            if(num):\\n                count+=1\\n            else:\\n                count =0\\n            maxi = max(maxi,count)\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522780,
                "title": "javascript-1-line-solution",
                "content": "\\n1. \\n```    return Math.max(...nums.join(\\'\\').split(0).map(x=>x.length));```\\n\\nOR\\n2.\\n```  return Math.max(...Array.from(nums.join(\\'\\').matchAll(/[1]*/g)).map(c=>c[0].length))```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```    return Math.max(...nums.join(\\'\\').split(0).map(x=>x.length));```\n```  return Math.max(...Array.from(nums.join(\\'\\').matchAll(/[1]*/g)).map(c=>c[0].length))```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488171,
                "title": "python-max-consecutive-ones-easy",
                "content": "\\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        countList = []\\n        index = 0\\n        count = 0\\n        target = 1\\n        while index < len(nums):\\n            if nums[index] == target:\\n                count += 1\\n            if nums[index] != target or index == len(nums) - 1:\\n                countList.append(count)\\n                count = 0\\n            index += 1\\n\\n        return max(countList)\\n",
                "solutionTags": [],
                "code": "\\n```\\nclass Solution(object):\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        countList = []\\n        index = 0\\n        count = 0\\n        target = 1\\n        while index < len(nums):\\n            if nums[index] == target:\\n                count += 1\\n            if nums[index] != target or index == len(nums) - 1:\\n                countList.append(count)\\n                count = 0\\n            index += 1\\n\\n        return max(countList)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2483750,
                "title": "java-solution-very-easy",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0, count = 0;\\n        \\n        for (int n : nums) {\\n            if (n == 1) count++;\\n            else count = 0;\\n\\t\\t\\tmaxCount = Math.max(count, maxCount);\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int maxCount = 0, count = 0;\\n        \\n        for (int n : nums) {\\n            if (n == 1) count++;\\n            else count = 0;\\n\\t\\t\\tmaxCount = Math.max(count, maxCount);\\n        }\\n        \\n        return maxCount;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465290,
                "title": "c-easy-2-solutions",
                "content": "```\\n// solution 1\\nint ans  = 0;\\n        int max = INT_MIN;\\n        \\n        for ( int i = 0; i < nums.size(); i ++) {\\n             if (nums[i] == 1) {\\n                 ans ++;\\n             }\\n            else {\\n                ans = 0;\\n            }\\n            if(ans > max) {\\n                 max = ans;\\n           }\\n        }\\n        \\n        return max;\\n\\t\\t\\n\\t\\t// solution 2 \\n\\t\\t\\n\\t\\t  int ans  = 0;\\n          vector<int> arr;\\n        \\n         for ( int i = 0; i < nums.size(); i ++) {\\n             if (nums[i] == 1) {\\n                 ans ++;\\n             }\\n             else {\\n                 arr.push_back(ans);\\n                 ans = 0;\\n             }\\n         }\\n        \\n         arr.push_back(ans);\\n         int max = INT_MIN;\\n        \\n         for(int i = 0; i < arr.size(); i++) {\\n             if(arr[i]>max) {\\n                 max = arr[i];\\n             }\\n         }\\n        \\n         return max;\\n",
                "solutionTags": [],
                "code": "```\\n// solution 1\\nint ans  = 0;\\n        int max = INT_MIN;\\n        \\n        for ( int i = 0; i < nums.size(); i ++) {\\n             if (nums[i] == 1) {\\n                 ans ++;\\n             }\\n            else {\\n                ans = 0;\\n            }\\n            if(ans > max) {\\n                 max = ans;\\n           }\\n        }\\n        \\n        return max;\\n\\t\\t\\n\\t\\t// solution 2 \\n\\t\\t\\n\\t\\t  int ans  = 0;\\n          vector<int> arr;\\n        \\n         for ( int i = 0; i < nums.size(); i ++) {\\n             if (nums[i] == 1) {\\n                 ans ++;\\n             }\\n             else {\\n                 arr.push_back(ans);\\n                 ans = 0;\\n             }\\n         }\\n        \\n         arr.push_back(ans);\\n         int max = INT_MIN;\\n        \\n         for(int i = 0; i < arr.size(); i++) {\\n             if(arr[i]>max) {\\n                 max = arr[i];\\n             }\\n         }\\n        \\n         return max;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2465280,
                "title": "java-2ms-beats-95-simple-and-easy-solution",
                "content": "```\\nint max = 0;int ans = 0;//first we take 2 variables so that we can compare the values ;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){//for loop for iterating over nums;\\n            \\n            if(nums[i] == 1){\\n                max++ ;//max+1 if found 1;\\n                }else{\\n                    if(max> ans){\\n                      ans = max ;//if found 0 then store the max in the ans ;\\n                    }\\n                    max = 0 ; //make max again 0 so that we can store values for further 1s;\\n                }\\n            }\\n        return Math.max(max , ans) ;//return the max value from max and ans ;",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nint max = 0;int ans = 0;//first we take 2 variables so that we can compare the values ;\\n        \\n        for(int i = 0 ; i < nums.length ; i++){//for loop for iterating over nums;\\n            \\n            if(nums[i] == 1){\\n                max++ ;//max+1 if found 1;\\n                }else{\\n                    if(max> ans){\\n                      ans = max ;//if found 0 then store the max in the ans ;\\n                    }\\n                    max = 0 ; //make max again 0 so that we can store values for further 1s;\\n                }\\n            }\\n        return Math.max(max , ans) ;//return the max value from max and ans ;",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1568422,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1575490,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1573785,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1653994,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1571875,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2077496,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2045233,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2034282,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1976233,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1933495,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1568422,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1575490,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1573785,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1653994,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1571875,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2077496,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2045233,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 2034282,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1976233,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1933495,
                "content": [
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/e8275842-3315-4eab-bd1a-f49ea4bcbe1d_1597766871.9150448.png)\\n\\n![image](https://assets.leetcode.com/users/images/8b725ef1-0904-4877-914f-f675d261a9eb_1597766878.5207863.png)\\n"
                    },
                    {
                        "username": "venkateshjacke",
                        "content": "\\'\\'\\'\\n  return len(max(\"\".join(map(str,nums)).split(\"0\")))\\n  \\'\\'\\'"
                    },
                    {
                        "username": "sohamkulkarni",
                        "content": "what\\'s the use of learning DSA then!"
                    },
                    {
                        "username": "yanjqu",
                        "content": "This question becomes quite solvable once we start thinking about it in the sliding window alogrithm sense, that is, with two pointers begin and end.\\n\\nHere, both begin and end can start with 0, and we keep sliding the end to the right if the number pointed to by end pointer is always 1, once we reach a 0 by the end pointer, we immediately stop, record the current length (end - begin), and resume the traversal of the list with new begin and end set at one more than the end position we stopped at."
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "we can solve it using kadane\\'s algorithm as well; provided that you need current_sum to set 0 when nums[i]=0; \\n\\nint findMaxConsecutiveOnes(vector<int>& nums) {\\n        int current_sum = 0;\\n\\n        int maxsum = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                current_sum=0;\\n            }\\n            current_sum= max(current_sum + nums[i],nums[i]);\\n            maxsum=max(maxsum,current_sum);\\n        }\\n        return maxsum;\\n    }"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "Good solution, thank you for sharing, but why do you need `current_sum= max(current_sum + nums[i],nums[i])` here? It could be applied with `current_sum += nums[i]`."
                    },
                    {
                        "username": "agedboy",
                        "content": "My C solution was beat by 90%, I was sad, so I copied and submitted the fastest one from the distribution graph, but it was beat by 100%... now I am happy.\n\nTo Leetcode: small test input + light weight algorithm make wrong speed judgement."
                    },
                    {
                        "username": "user5882HN",
                        "content": "HELLO GUYZ I DON\\'T KNOW WHY ISN\\'T THIS WORKING BUT ACCORDING TO LOGIC IT MUST WORK,HERE IS THE CODE(WHATEVER THE 1\\'s BE THE OUPUT IS SHOWING ONLY 2 CAN U FIND OUT WHY)?:\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0;\\n        vector<int> result;\\n        for(auto it=nums.begin(); it!=nums.end(); it++){\\n            if(*(it)==1){\\n                count++;\\n            }\\n            else{\\n                result.emplace_back(count);\\n                count=0;\\n            }\\n        }\\n    \\n    return *max_element(result.begin(),result.end());\\n    }\\n};"
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "is something wrong with my code ? its in java . \\nit failed for 21st  case (expected output is 2840 , mine is coming 3323 ) . the code seems to be right when i did tracing . help\\n public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int maxcount=0;\\n        for(int j=0;j<nums.length;j++){\\n            if(nums[j]==1)\\n            {\\n                count++;\\n                if(j==(nums.length-1))\\n                {\\n                //   if(count>maxcount)\\n                //   {\\n                // maxcount=count;   \\n                //   }  \\n                 maxcount = Math.max(maxcount,count);\\n                }\\n                continue;\\n            }\\n            if(count>maxcount)\\n            {\\n                maxcount=count;\\n                count=0;\\n            }\\n        }\\n        return maxcount;\\n    }\\n\\ni have maintained 2 variables count and maxcount i count the consecutive ones then change the maxcount (when the element in array is 0) only if my count is gretaer than maxcount and change the value of count back to 0 \\n\\n"
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "keep incresing counter, once encouter 0, save the counter to some variable , lets say temp, then reset  the counter, do same time and next time when encounter any 0, compare the counter to the temp. if counter >temp , update the temp with new value present in counter. do this until complete traverse in array"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "My intuition was to solve this question with sliding window like 1493. Longest Subarray of 1's After Deleting One Element (below is my solution for it)\n\n Can the code template be somehow modified to solve the question of max consecutive ones?\n\n```\n    int longestSubarray(vector<int>& nums){\n        int l=0, r=0, n=nums.size(), count0=0, ans=0;\n\n        for(  ; r<n; r++){\n            if(nums[r]==0) count0++;\n            for( ; count0>1; l++){ \n                if (nums[l]==0) count0--;\n            }\n            ans = max (ans, r-l+1);\n        }\n        return ans-1;\n    }\n```"
                    },
                    {
                        "username": "amitsingh9790",
                        "content": "class Solution { \\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int i,max=0,count=0;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums.at(i)==1)\\n            {\\n                count++;\\n                if(max < count)\\n                    max=count;\\n            }\\n            else \\n                count=0;\\n        }\\n        return max;\\n    }\\n};"
                    },
                    {
                        "username": "Ash2k3",
                        "content": "We can think it as like to maintain two variables, one variable keeps track of current streak and other one maxOneSoFar. Current streak will be 0 if num[i] = 0."
                    }
                ]
            },
            {
                "id": 1931248,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865729,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1793335,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760376,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749933,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1748850,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1742291,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1733928,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1723132,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1722371,
                "content": [
                    {
                        "username": "andresstawski",
                        "content": "is there something wrong with my code? it gave wrong answer on case 21. It feels like a very straight forward problem to solve :/\\n\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int ans = 0, compare = 0;\\n        int n = nums.size();\\n\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 1) compare++;\\n            \\n            if(nums[i] == 0 || i == n - 1) \\n            {\\n                if(compare > ans) {\\n                    ans = compare;\\n                    compare = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "user5117S",
                        "content": "  if(nums[i]==0 || i== n-1){\\n               if(count > temp){\\n                 temp = count;\\n                 count = 0;\\n               }\\n               count =0;\\n            }\\n\\nif 0 occurs we have to reset counter even if this count>temp  fails. hope this is helpful."
                    },
                    {
                        "username": "Hazzy_18",
                        "content": "same is happening with me \\'"
                    },
                    {
                        "username": "Semi_Colon_",
                        "content": "Same\\n"
                    },
                    {
                        "username": "BhupendraMaurya",
                        "content": "same here\\n"
                    },
                    {
                        "username": "boomeraintsmoker",
                        "content": "class Solution {\\npublic:\\n        int findMaxConsecutiveOnes(vector<int>& v) {\\n                vector<int> counter;\\n                int result = 0;\\n                for(int i = 0; i < v.size(); i++) {\\n                        int unit_counter = 0;\\n                        while(v[i] != 0 && i < v.size()) {\\n                                unit_counter++;\\n                                i++;\\n                        }\\n                        counter.push_back(unit_counter);\\n                }\\n                sort(counter.rbegin(), counter.rend());\\n\\t            result = counter[0];\\n                return result;\\n        }\\n};\\n\\nwhy i caught heap overflow on leetcode\\n\\ntest : 1 1 0 1"
                    },
                    {
                        "username": "grey7",
                        "content": "same\\n"
                    },
                    {
                        "username": "_ashutosh_pandey_",
                        "content": "EASY SOLUTION C++\\nclass Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int c=0,ans=0;\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==1){\\n                c++;\\n                ans=max(ans,c);\\n            }\\n            else{\\n                c=0;\\n                ans=max(ans,c);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/485_max_Consecutive_1.cpp"
                    },
                    {
                        "username": "riteshpandey18",
                        "content": "Steps to solve this question- :\\nStep 1 - Initialize two variables:\\n             maxsum to store the maximum number of consecutive 1s found so far\\n             current_sum to store the current number of consecutive 1s\\nStep 2 - Iterate through the array with a for loop:\\n            For each element in the array:\\n                 If the element is 0, set current_sum to 0.\\n                 Otherwise, update current_sum by adding the element to it.\\n                 Set current_sum to the maximum of itself and the element.\\n                 Update maxsum to the maximum of itself and current_sum.\\nStep 3 -Return maxsum as the result.\\n\\nIf you understand the problem please upvote. "
                    },
                    {
                        "username": "unanything",
                        "content": "You could use first two elements of the input array to store current and max. No additional variables needed. "
                    },
                    {
                        "username": "keshav1534",
                        "content": "This the solution for Max Consecutive Ones in PYTHON:\\nclass Solution:\\n    def findMaxConsecutiveOnes(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        MAX=0\\n        temp=0\\n        for n in range(len(nums)):\\n            if nums[n]==1:\\n                temp+=1\\n            else:\\n                temp=0\\n            if temp>MAX:\\n                MAX=temp\\n        return MAX\\nlst = input()\\nArray=Solution()\\nmax=Array.findMaxConsecutiveOnes(lst)\\nprint(max)\\n\\nThis program is working fine in my system but somehow failing on Leetcode.\\n\\nPlease let me know the mistake I\\'m making"
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "It shows run time error and i don\\'t get correct output.\\nBut in devc++ i get exactly correct output.\\nWhy it happen?\\n#include<bits/stdc++.h>\\nusing namespace std;\\nint getmax1s(int arr[],int n)\\n{\\n\\tint i,count=0,result;\\n\\tfor(i=0;i<n;i++)\\n\\t{\\n\\t\\tif(arr[i]!=0)\\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tresult=max(result,count);\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcount=0;\\n\\t\\t\\t//result=max(result,count);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\nint main()\\n{\\n\\tint arr[]={1,0,1,1,0,1};\\n\\tint n=sizeof(arr)/sizeof(arr[0]);\\n\\tcout<<getmax1s(arr,n);\\n}"
                    },
                    {
                        "username": "ranjankumar15au2",
                        "content": "initialize int result=INT_MIN and remove the main function leetcode compiler will take care of it"
                    },
                    {
                        "username": "parth23p",
                        "content": "return max(result,count)"
                    },
                    {
                        "username": "parth23p",
                        "content": "Beats 96%\n\nint findMaxConsecutiveOnes(vector<int>& nums) {\n        int maxi=INT_MIN,count=0;\n\n        for(int i=0;i<nums.size();i++){\n\n            if(nums[i]==1)\n            {\n                count++;\n            }\n            else if(nums[i]==0)\n            {\n                maxi=max(count,maxi);\n                count=0;\n            }\n        }\n        return max(maxi,count);\n    }"
                    },
                    {
                        "username": "prabha57",
                        "content": "Solution in JAVA with 1ms runtime\\n `class Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int prev_con = 0, pres_con = 0;\\n        for(int i =0 ;i<nums.length;i++) {\\n            if(nums[i]==1) {\\n                pres_con+=1;\\n            } else {\\n                if(pres_con>prev_con) {\\n                  prev_con = pres_con;  \\n                }\\n                pres_con = 0;\\n            }\\n        }\\n        return pres_con>prev_con?pres_con:prev_con;\\n    }\\n}`"
                    },
                    {
                        "username": "krishna6371",
                        "content": "class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int count=0,count1=0,l=0;\\n     for(int i=0;i<nums.size();i++){\\n         l=0;\\n         if(nums[i]==1){\\n         count++;\\n        l=l+count;\\n     } \\n     if(l>count1)\\n     count1=l;\\n     if(nums[i]==0)\\n     count=0;\\n     \\n    }\\n    return count1;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]