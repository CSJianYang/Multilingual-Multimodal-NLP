[
    {
        "title": "Remove Nodes From Linked List",
        "question_content": "You are given the head of a linked list.\nRemove every node which has a node with a greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\n&nbsp;\nExample 1:\n\nInput: head = [5,2,13,3,8]\nOutput: [13,8]\nExplanation: The nodes that should be removed are 5, 2 and 3.\n- Node 13 is to the right of node 5.\n- Node 13 is to the right of node 2.\n- Node 8 is to the right of node 3.\n\nExample 2:\n\nInput: head = [1,1,1,1]\nOutput: [1,1,1,1]\nExplanation: Every node has value 1, so no nodes are removed.\n\n&nbsp;\nConstraints:\n\n\tThe number of the nodes in the given list is in the range [1, 105].\n\t1 <= Node.val <= 105",
        "solutions": [
            {
                "id": 2852139,
                "title": "java-c-python-3-line-recursion-solution",
                "content": "# **Explanation**\\nRecursively call `removeNodes` to handle the tail first.\\nThen `head.next` node should have the biggest value.\\nCompare `head.val` and `head.next.val`,\\nif `head.val < head.next.val`,\\nshould remove the current node,\\nreturn `head.next`,\\notherwise we return `head`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        if (head == null) return null;\\n        head.next = removeNodes(head.next);\\n        return head.next != null && head.val < head.next.val ? head.next : head;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    ListNode* removeNodes(ListNode* head) {\\n        if (!head) return NULL;\\n        head->next = removeNodes(head->next);\\n        return head->next && head->val < head->next->val ?  head->next : head;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def removeNodes(self, head):\\n        if not head: return None\\n        head.next = self.removeNodes(head.next)\\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        return head\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public ListNode removeNodes(ListNode head) {\\n        if (head == null) return null;\\n        head.next = removeNodes(head.next);\\n        return head.next != null && head.val < head.next.val ? head.next : head;\\n    }\\n```\n```cpp\\n    ListNode* removeNodes(ListNode* head) {\\n        if (!head) return NULL;\\n        head->next = removeNodes(head->next);\\n        return head->next && head->val < head->next->val ?  head->next : head;\\n    }\\n```\n```py\\n    def removeNodes(self, head):\\n        if not head: return None\\n        head.next = self.removeNodes(head.next)\\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2851962,
                "title": "reverse-list-vs-stack",
                "content": "## Reverse List\\nThe reverse operation is based on [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/). \\n\\nWe reverse the list, and \"eat\" next elements if value is smaller. Then, we reverve the list again.\\n\\n**C++**\\n```cpp\\nListNode* reverseList(ListNode* head) {\\n    ListNode *cur = head, *prev = nullptr;\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev, cur);\\n    }\\n    return prev;\\n}\\nListNode* removeNodes(ListNode* head) {\\n    head = reverseList(head);\\n    for (auto p = head; p != nullptr && p->next != nullptr; ) {\\n        if (p->val > p->next->val)\\n            p->next = p->next->next;\\n        else\\n            p = p->next;\\n    }\\n    return reverseList(head);\\n}\\n```\\n## Stack\\nWe maintain non-increasing stack of nodes. While the next value is larger, we pop nodes from the stack.\\n    \\nThen, we connect top-of-stack node to the next node, and push the next node to the stack.\\n\\n**C++**\\n```cpp\\nListNode* removeNodes(ListNode* head) {\\n    ListNode tmp(INT_MAX);\\n    vector<ListNode*> st{ &tmp };\\n    for (auto p = head; p != nullptr; p = p->next) {\\n        while (st.back()->val < p->val) \\n            st.pop_back();\\n        st.back()->next = p;\\n        st.push_back(p);\\n    }\\n    return tmp.next;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nListNode* reverseList(ListNode* head) {\\n    ListNode *cur = head, *prev = nullptr;\\n    while (cur != nullptr) {\\n        swap(cur->next, prev);\\n        swap(prev, cur);\\n    }\\n    return prev;\\n}\\nListNode* removeNodes(ListNode* head) {\\n    head = reverseList(head);\\n    for (auto p = head; p != nullptr && p->next != nullptr; ) {\\n        if (p->val > p->next->val)\\n            p->next = p->next->next;\\n        else\\n            p = p->next;\\n    }\\n    return reverseList(head);\\n}\\n```\n```cpp\\nListNode* removeNodes(ListNode* head) {\\n    ListNode tmp(INT_MAX);\\n    vector<ListNode*> st{ &tmp };\\n    for (auto p = head; p != nullptr; p = p->next) {\\n        while (st.back()->val < p->val) \\n            st.pop_back();\\n        st.back()->next = p;\\n        st.push_back(p);\\n    }\\n    return tmp.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852102,
                "title": "python-c-o-n-using-monostack-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs *monotonic stack* to filter out nodes that don\\'t satisfy the condition in the problem. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** When pulling next node from the list, we have to check whether its value is greater than for any of the previous ones. It can be done by first checking the last node, then the last before last and so on. For the last nodes to be available for comparison, we maintain a stack. The nodes that break the condition in the problem are removed. This effectively makes this stack a *monotonic stack*, thus, ensuring that we stop comparing nodes when the condition for the current node and top node (on the stack) is restored.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(inf)\\n        stack = [dummy]\\n        \\n        while head:\\n            while stack and head.val > stack[-1].val:\\n                stack.pop()\\n            stack[-1].next = head\\n            stack.append(head)\\n            head = head.next\\n        \\n        return dummy.next\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(INT_MAX);\\n        vector<ListNode*> stack = {dummy};\\n        \\n        while (head)\\n        {\\n            while (!stack.empty() && head->val > stack.back()->val)\\n                stack.pop_back();\\n            stack.back()->next = head;\\n            stack.push_back(head);\\n            head = head->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(inf)\\n        stack = [dummy]\\n        \\n        while head:\\n            while stack and head.val > stack[-1].val:\\n                stack.pop()\\n            stack[-1].next = head\\n            stack.append(head)\\n            head = head.next\\n        \\n        return dummy.next\\n```\n```\\nclass Solution \\n{\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(INT_MAX);\\n        vector<ListNode*> stack = {dummy};\\n        \\n        while (head)\\n        {\\n            while (!stack.empty() && head->val > stack.back()->val)\\n                stack.pop_back();\\n            stack.back()->next = head;\\n            stack.push_back(head);\\n            head = head->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851978,
                "title": "java-python-3-3-codes-recursive-iterative-space-o-n-and-extra-space-o-1",
                "content": "**Method 1: Recursive**\\n\\nDuring recursion to the end of the list, check if the value of current node less than that of the next one; If yes, return next node and ignore current one.\\n\\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        if (head != null) {\\n            head.next = removeNodes(head.next);\\n            if (head.next != null && head.val < head.next.val) {\\n                return head.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head:\\n            head.next = self.removeNodes(head.next)\\n            if head.next and head.val < head.next.val:\\n                return head.next\\n        return head\\n```\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n` is the # of nodes.\\n\\n\\n----\\n\\n**Method 2: non-increasing Stack**\\n\\n1. Keep popping out the stack top node that is smaller than current one.\\n2. Connect all nodes remaining in the stack and return the stack  bottom node.\\n\\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        Deque<ListNode> stk = new ArrayDeque<>();\\n        while (head != null) {\\n            while (!stk.isEmpty() && stk.peek().val < head.val) {\\n                stk.pop();\\n            }\\n            stk.push(head);\\n            head = head.next;\\n        }\\n        while (stk.size() > 1) {\\n            ListNode n = stk.pop();\\n            stk.peek().next = n;\\n        }\\n        return stk.peek();\\n    }\\n```\\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        stk = []\\n        while head:\\n            while stk and stk[-1].val < head.val:\\n                stk.pop()\\n            stk.append(head)\\n            head = head.next\\n        while len(stk) > 1:\\n            node = stk.pop()\\n            stk[-1].next = node\\n        return stk[-1]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n` is the # of nodes.\\n\\n----\\n\\n**Method 3: Extra space O(1), reverse and remove decreasing nodes.**\\n\\n\\n1. Reverse the list;\\n2. Traverse the list and compute the running maximum, remove any decreasing nodes.\\n3. Reverse the list once again to resore the order.\\n\\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode tail = reverse(head), cur = tail;\\n        int mx = cur.val;\\n        while (cur.next != null) {\\n            if (cur.next.val < mx) {\\n                cur.next = cur.next.next;\\n            }else {\\n                cur = cur.next;\\n                mx = cur.val;\\n            }\\n        }\\n        return reverse(tail);\\n    }\\n    private ListNode reverse(ListNode n) {\\n        ListNode tail = null;\\n        while (n != null) {\\n            ListNode next = n.next;\\n            n.next = tail;\\n            tail = n;\\n            n = next;\\n        }\\n        return tail;\\n    }\\n```\\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def reverse(n: ListNode) -> ListNode:\\n            tail = None\\n            while n:\\n                nxt = n.next\\n                n.next = tail\\n                tail = n\\n                n = nxt\\n            return tail\\n\\n        cur = tail = reverse(head)\\n        mx = cur.val\\n        while cur.next:\\n            if cur.next.val < mx:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n                mx = cur.val\\n        return reverse(tail)\\n```\\n\\n**Analysis:**\\n\\nHaving used the given input list, strictly speaking, the space cost is the whole given list `O(n)`, or `O(1)` extra space.\\n\\nTime: `O(n)`,  extra space: `O(1)`, where `n` is the # of nodes.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public ListNode removeNodes(ListNode head) {\\n        if (head != null) {\\n            head.next = removeNodes(head.next);\\n            if (head.next != null && head.val < head.next.val) {\\n                return head.next;\\n            }\\n        }\\n        return head;\\n    }\\n```\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head:\\n            head.next = self.removeNodes(head.next)\\n            if head.next and head.val < head.next.val:\\n                return head.next\\n        return head\\n```\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        Deque<ListNode> stk = new ArrayDeque<>();\\n        while (head != null) {\\n            while (!stk.isEmpty() && stk.peek().val < head.val) {\\n                stk.pop();\\n            }\\n            stk.push(head);\\n            head = head.next;\\n        }\\n        while (stk.size() > 1) {\\n            ListNode n = stk.pop();\\n            stk.peek().next = n;\\n        }\\n        return stk.peek();\\n    }\\n```\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        stk = []\\n        while head:\\n            while stk and stk[-1].val < head.val:\\n                stk.pop()\\n            stk.append(head)\\n            head = head.next\\n        while len(stk) > 1:\\n            node = stk.pop()\\n            stk[-1].next = node\\n        return stk[-1]\\n```\n```java\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode tail = reverse(head), cur = tail;\\n        int mx = cur.val;\\n        while (cur.next != null) {\\n            if (cur.next.val < mx) {\\n                cur.next = cur.next.next;\\n            }else {\\n                cur = cur.next;\\n                mx = cur.val;\\n            }\\n        }\\n        return reverse(tail);\\n    }\\n    private ListNode reverse(ListNode n) {\\n        ListNode tail = null;\\n        while (n != null) {\\n            ListNode next = n.next;\\n            n.next = tail;\\n            tail = n;\\n            n = next;\\n        }\\n        return tail;\\n    }\\n```\n```python\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def reverse(n: ListNode) -> ListNode:\\n            tail = None\\n            while n:\\n                nxt = n.next\\n                n.next = tail\\n                tail = n\\n                n = nxt\\n            return tail\\n\\n        cur = tail = reverse(head)\\n        mx = cur.val\\n        while cur.next:\\n            if cur.next.val < mx:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n                mx = cur.val\\n        return reverse(tail)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2852183,
                "title": "c-simple-traversal-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* nextN = removeNodes(head->next);\\n        if(nextN->val > head->val) {\\n            return nextN;\\n        }\\n        head->next = nextN;\\n        return head;\\n    }\\n    \\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL) {\\n            return head;\\n        }\\n        ListNode* nextN = removeNodes(head->next);\\n        if(nextN->val > head->val) {\\n            return nextN;\\n        }\\n        head->next = nextN;\\n        return head;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852518,
                "title": "reversing-the-linkedlist",
                "content": "\\n**reversing the linkedlist**\\n**then making a list with the running max**\\n**then again reversing the list**\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        ListNode dummy1=dummy;\\n        ListNode get_rev=reverse(head);\\n        ListNode curr=get_rev;\\n        int max=0;\\n        while(curr!=null){\\n            max=Math.max(max,curr.val);\\n           \\n            if(max==curr.val){\\n                ListNode temp=new ListNode(max);\\n                dummy.next=temp;\\n                dummy=dummy.next;\\n            }\\n            curr=curr.next;\\n        }\\n    \\n        return reverse(dummy1.next);\\n    }\\n    //reversing the linkedlist\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        ListNode dummy1=dummy;\\n        ListNode get_rev=reverse(head);\\n        ListNode curr=get_rev;\\n        int max=0;\\n        while(curr!=null){\\n            max=Math.max(max,curr.val);\\n           \\n            if(max==curr.val){\\n                ListNode temp=new ListNode(max);\\n                dummy.next=temp;\\n                dummy=dummy.next;\\n            }\\n            curr=curr.next;\\n        }\\n    \\n        return reverse(dummy1.next);\\n    }\\n    //reversing the linkedlist\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852006,
                "title": "very-simple-c-soltuion",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nSimply keep adding elements from back of the queue,\\nWhile doing so, remove all the nodes from back when the back is smaller then the new node value\\nOnce added all element to deque, then pop from front and form the linked list again.\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* ptr = head;\\n        deque<ListNode*> s;\\n        while(ptr != NULL){\\n            if(!s.empty()) {\\n                while(!s.empty() && s.back()->val < ptr->val) s.pop_back(); \\n            }\\n            s.push_back(ptr);\\n            ptr = ptr->next;\\n        }\\n        if(s.empty() ) return NULL;\\n        head = s.front(); ptr = s.front(); s.pop_front();\\n        while(!s.empty()){\\n            ptr->next = s.front();\\n            ptr = ptr->next;\\n            s.pop_front();\\n        }\\n        ptr->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSimply keep adding elements from back of the queue,\\nWhile doing so, remove all the nodes from back when the back is smaller then the new node value\\nOnce added all element to deque, then pop from front and form the linked list again.\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head->next == NULL) return head;\\n        ListNode* ptr = head;\\n        deque<ListNode*> s;\\n        while(ptr != NULL){\\n            if(!s.empty()) {\\n                while(!s.empty() && s.back()->val < ptr->val) s.pop_back(); \\n            }\\n            s.push_back(ptr);\\n            ptr = ptr->next;\\n        }\\n        if(s.empty() ) return NULL;\\n        head = s.front(); ptr = s.front(); s.pop_front();\\n        while(!s.empty()){\\n            ptr->next = s.front();\\n            ptr = ptr->next;\\n            s.pop_front();\\n        }\\n        ptr->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851935,
                "title": "recursion",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head and head->next){\\n            ListNode* newHead = removeNodes(head->next);\\n            if(newHead->val > head->val)return newHead;\\n            head->next = newHead;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head and head->next){\\n            ListNode* newHead = removeNodes(head->next);\\n            if(newHead->val > head->val)return newHead;\\n            head->next = newHead;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852158,
                "title": "c-one-pass-easy",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- usin --> \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* node=head,*finalAns=head;\\n        \\n        st.push(node);\\n        node = node->next;\\n        \\n        while(node!=NULL){\\n            \\n            while(node && st.size() && st.top()->val < node->val){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                finalAns = node;\\n            }\\n            else{\\n                st.top()->next = node;\\n            }\\n            st.push(node);\\n            node=node->next;\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* node=head,*finalAns=head;\\n        \\n        st.push(node);\\n        node = node->next;\\n        \\n        while(node!=NULL){\\n            \\n            while(node && st.size() && st.top()->val < node->val){\\n                st.pop();\\n            }\\n            \\n            if(st.size() == 0){\\n                finalAns = node;\\n            }\\n            else{\\n                st.top()->next = node;\\n            }\\n            st.push(node);\\n            node=node->next;\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852118,
                "title": "recursion-vs-iteration-constant-space-intuition",
                "content": "# Intuition:\\n We can only remove a node if we know the largest value on its right side.\\n Removal can only be done in linear time if we try traversal from right to left.\\n    \\n # This give us two Intuitions:\\n  + We have to record maximum in a variable.\\n  + We will either choose Postorder Recursion or Iterative solution.\\n\\nTime - O(n)\\nSpace - O(1)\\n\\n**Method 1**\\nWe will use postorder Recursion for removal of a node & will do elimination from right to left.\\n# C++\\n     int maxi = 0;\\n     ListNode* removeNodes(ListNode* head) {\\n        if(head == nullptr) return head;\\n        head->next = removeNodes(head->next);\\n        if(head->val < maxi) return head->next;\\n        maxi = max(maxi, head->val);\\n        return head;\\n\\t}\\n\\t\\n**Method 2**\\n We will reverse the linked & follow the same procedure as above but in iterative way.\\n \\n # Java\\n     public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n        ListNode prev = head, ptr = head.next;\\n        int maxi = head.val;\\n        for(; ptr != null; ptr = ptr.next){\\n            if(ptr.val >= maxi){\\n                maxi = Math.max(maxi, ptr.val);\\n                prev.next = ptr;\\n                prev = ptr;\\n            }\\n        }\\n        prev.next = null;\\n        head = reverse(head);\\n        return head;\\n      }\\n    \\n     ListNode reverse(ListNode head){\\n        ListNode curr = head, prev = null;\\n        while(curr != null){\\n            var nx = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nx;\\n        }\\n        return prev;\\n      }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# Intuition:\\n We can only remove a node if we know the largest value on its right side.\\n Removal can only be done in linear time if we try traversal from right to left.\\n    \\n # This give us two Intuitions:\\n  + We have to record maximum in a variable.\\n  + We will either choose Postorder Recursion or Iterative solution.\\n\\nTime - O(n)\\nSpace - O(1)\\n\\n**Method 1**\\nWe will use postorder Recursion for removal of a node & will do elimination from right to left.\\n# C++\\n     int maxi = 0;\\n     ListNode* removeNodes(ListNode* head) {\\n        if(head == nullptr) return head;\\n        head->next = removeNodes(head->next);\\n        if(head->val < maxi) return head->next;\\n        maxi = max(maxi, head->val);\\n        return head;\\n\\t}\\n\\t\\n**Method 2**\\n We will reverse the linked & follow the same procedure as above but in iterative way.\\n \\n # Java\\n     public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n        ListNode prev = head, ptr = head.next;\\n        int maxi = head.val;\\n        for(; ptr != null; ptr = ptr.next){\\n            if(ptr.val >= maxi){\\n                maxi = Math.max(maxi, ptr.val);\\n                prev.next = ptr;\\n                prev = ptr;\\n            }\\n        }\\n        prev.next = null;\\n        head = reverse(head);\\n        return head;\\n      }\\n    \\n     ListNode reverse(ListNode head){\\n        ListNode curr = head, prev = null;\\n        while(curr != null){\\n            var nx = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nx;\\n        }\\n        return prev;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 2852072,
                "title": "c-stack-detailed-explanation",
                "content": "**Approach**- VARIATION OF NGE[Next Greater Element]\\npreq: https://leetcode.com/problems/next-greater-element-i/\\n\\nIf we already know for the ith element is there anyone in right who is greater we can left that element and make the LinkedList with remaining elements.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        //make LL of NGE of values -1\\n        stack<int> st;          //monotonic stack (increasing)\\n        \\n        //count total nodes\\n        int n= 0;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            n++;\\n            curr = curr->next;\\n        }\\n        \\n        vector<int> NGE(n, -1);\\n        \\n        //to make NGE make a array of LL\\n        vector<int> nums(n);\\n        curr = head;\\n        int i= 0;\\n        while(curr != NULL){\\n            nums[i++] = curr->val;\\n            curr = curr->next;\\n        }\\n        \\n        //make NGE\\n        for(i=n-1; i>=0; i--){\\n            // cout<<nums[i]<<endl;\\n            while(!st.empty() && st.top()<= nums[i])\\n                st.pop();\\n            \\n            if(!st.empty())\\n                NGE[i] = st.top();\\n            st.push(nums[i]);\\n            // cout<<NGE[i]<<endl;\\n        }\\n        \\n        \\n        //make LL of NGE of -1\\n        ListNode* dummy = new ListNode(0);\\n        curr = dummy;\\n        for(int i=0; i<n; i++){\\n            if(NGE[i]==-1){\\n                ListNode* tmp = new ListNode(nums[i]);\\n                dummy->next = tmp;\\n                dummy = dummy->next;\\n            }\\n                \\n        }\\n        return curr->next;\\n    }\\n};\\n```\\n\\nCheck out my youtube channel for related content\\nhttps://www.youtube.com/@ignition548/featured",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        //make LL of NGE of values -1\\n        stack<int> st;          //monotonic stack (increasing)\\n        \\n        //count total nodes\\n        int n= 0;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            n++;\\n            curr = curr->next;\\n        }\\n        \\n        vector<int> NGE(n, -1);\\n        \\n        //to make NGE make a array of LL\\n        vector<int> nums(n);\\n        curr = head;\\n        int i= 0;\\n        while(curr != NULL){\\n            nums[i++] = curr->val;\\n            curr = curr->next;\\n        }\\n        \\n        //make NGE\\n        for(i=n-1; i>=0; i--){\\n            // cout<<nums[i]<<endl;\\n            while(!st.empty() && st.top()<= nums[i])\\n                st.pop();\\n            \\n            if(!st.empty())\\n                NGE[i] = st.top();\\n            st.push(nums[i]);\\n            // cout<<NGE[i]<<endl;\\n        }\\n        \\n        \\n        //make LL of NGE of -1\\n        ListNode* dummy = new ListNode(0);\\n        curr = dummy;\\n        for(int i=0; i<n; i++){\\n            if(NGE[i]==-1){\\n                ListNode* tmp = new ListNode(nums[i]);\\n                dummy->next = tmp;\\n                dummy = dummy->next;\\n            }\\n                \\n        }\\n        return curr->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2858248,
                "title": "c-recursion-4-line-code-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        ListNode * newnode = removeNodes(head -> next);\\n        if(newnode -> val > head->val) return newnode;\\n        \\n        head-> next = newnode;\\n        \\n        return head;\\n        \\n    }\\n};\\n\\n\\n# upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        ListNode * newnode = removeNodes(head -> next);\\n        if(newnode -> val > head->val) return newnode;\\n        \\n        head-> next = newnode;\\n        \\n        return head;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2852123,
                "title": "stack-based-soln-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe idea here is to process the list from right to left, so that if we encounter a smaller element after a larger element ,we will skip it. I used a stack to implement it :-\\n -> If our current element is greater than top of stack , we will take it , else we will leave that element (because a greater element exists at the right).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n     //*** storing all the nodes to process from right to left \\n        vector<ListNode*> vec; \\n        ListNode* temp = head;;\\n        while(temp){\\n            vec.push_back(temp);\\n            temp = temp->next;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        \\n        \\n        stack<ListNode*> st;  ///**** creating an increasing stack with max at top\\n        for(ListNode* l:vec){\\n            \\n            if(st.size()==0){\\n                st.push(l);\\n                continue;\\n            }\\n            if(l->val>=st.top()->val){\\n                st.push(l);\\n            }\\n        }\\n        \\n                 //****   creating list to return\\n        if(st.size()==0)return NULL;\\n                                 \\n        ListNode*root = st.top();\\n        ListNode* tail = st.top();\\n        st.pop();\\n        while(st.size()){\\n            ListNode* l = st.top();\\n            st.pop();\\n            tail -> next = l;\\n            tail = tail->next;   \\n        }\\n        tail->next = NULL;  //** end the list \\n        \\n        \\n        return root;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n     //*** storing all the nodes to process from right to left \\n        vector<ListNode*> vec; \\n        ListNode* temp = head;;\\n        while(temp){\\n            vec.push_back(temp);\\n            temp = temp->next;\\n        }\\n        reverse(vec.begin(),vec.end());\\n        \\n        \\n        stack<ListNode*> st;  ///**** creating an increasing stack with max at top\\n        for(ListNode* l:vec){\\n            \\n            if(st.size()==0){\\n                st.push(l);\\n                continue;\\n            }\\n            if(l->val>=st.top()->val){\\n                st.push(l);\\n            }\\n        }\\n        \\n                 //****   creating list to return\\n        if(st.size()==0)return NULL;\\n                                 \\n        ListNode*root = st.top();\\n        ListNode* tail = st.top();\\n        st.pop();\\n        while(st.size()){\\n            ListNode* l = st.top();\\n            st.pop();\\n            tail -> next = l;\\n            tail = tail->next;   \\n        }\\n        tail->next = NULL;  //** end the list \\n        \\n        \\n        return root;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2851993,
                "title": "python-recursion-stack-video-solution",
                "content": "Both the recursive and stack solution are covered in [video solution](https://youtu.be/BIU7MkszsNg).\\n\\n\\n \\n# Stack solution\\n\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack = []                                          # We have to keep a Monotonic Decreasing Stack\\n        \\n\\t\\tcur = head        \\n\\t\\twhile cur:                                         \\n            while stack and cur.val > stack[-1].val:        #  Loop over List and check if current elem is greater than stack[-1]\\n                stack.pop()                                 # If it is greater, then we remove that elem from stack.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n            stack.append(cur)                               # At the end, we will add the current elem to the stack\\n            cur = cur.next                                  # Go to next elem in the List\\n\\t\\t\\t\\n            \\n        dummy = ListNode()                                  # Always a good idea to keep dummy head for LinkedList delete.\\n        cur = dummy\\n        \\n        for node in stack:                                  # Go through each element in stack\\n            cur.next = node                                 # We add it to our new LinkedList\\n            cur = cur.next                                  # Update the current pointer of our LinkList\\n            \\n        return dummy.next                                   # Finally, we can return new head (dummy.next)\\n```\\n\\t\\t\\n# Recursive Solution\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        head.next = self.removeNodes(head.next)\\n        \\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        \\n        return head\\n```\\n\\n\\nIf this solution was helpful, please upvote, like the video and subscribe the channel.\\n\\nCheers. \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack = []                                          # We have to keep a Monotonic Decreasing Stack\\n        \\n\\t\\tcur = head        \\n\\t\\twhile cur:                                         \\n            while stack and cur.val > stack[-1].val:        #  Loop over List and check if current elem is greater than stack[-1]\\n                stack.pop()                                 # If it is greater, then we remove that elem from stack.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n            stack.append(cur)                               # At the end, we will add the current elem to the stack\\n            cur = cur.next                                  # Go to next elem in the List\\n\\t\\t\\t\\n            \\n        dummy = ListNode()                                  # Always a good idea to keep dummy head for LinkedList delete.\\n        cur = dummy\\n        \\n        for node in stack:                                  # Go through each element in stack\\n            cur.next = node                                 # We add it to our new LinkedList\\n            cur = cur.next                                  # Update the current pointer of our LinkList\\n            \\n        return dummy.next                                   # Finally, we can return new head (dummy.next)\\n```\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        head.next = self.removeNodes(head.next)\\n        \\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852103,
                "title": "stack-solution-o-n-c",
                "content": "# Intuition\\nLets divide the problem in two sub-part:\\n1) Finding the elements strictly greater to the right \\n2) Making new list of the found elements.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSteps:\\n\\'\\'\\'\\'First Part\\'\\'\\'\\'\\n\\t1) Push the head element on to the stack.\\n\\t2) Traverse the linked list. \\n\\t3) Compare the stack\\'s top element with current element in the list. If top element is smaller than current element in the list, pop it, go to step 3) again.\\n\\t4) Push current element of the list on the stack and go to step 2) for the next iteration.\\n\\'\\'\\'\\'Second Part\\'\\'\\'\\'\\n\\t5) Create a new ListNode pointer, say \\'nh\\' pointing to the nullptr.\\n\\t6) Pop element from the stack, and create ListNode (\\'nn\\') with that value and next pointer pointing to our \\'nh\\' pointer.\\n\\t7) Set \\'nh\\' = \\'nn\\' and go to step 5) while stack is not empty.\\n\\t8) Now, we can return \\'nh\\' pointer.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) Stack Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> s;\\n        s.push(head->val);\\n        ListNode* trvlr = head->next;\\n        while(trvlr){\\n            while(!s.empty() && s.top() < trvlr->val) s.pop();\\n            s.push(trvlr->val);\\n            trvlr = trvlr->next;\\n        }\\n        \\n        ListNode* nh = nullptr;\\n        while(!s.empty()){\\n            ListNode* nn = new ListNode();\\n            nn->val = s.top();\\n            nn->next = nh;\\n            nh = nn;\\n            s.pop();\\n        }\\n        \\n        return nh;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> s;\\n        s.push(head->val);\\n        ListNode* trvlr = head->next;\\n        while(trvlr){\\n            while(!s.empty() && s.top() < trvlr->val) s.pop();\\n            s.push(trvlr->val);\\n            trvlr = trvlr->next;\\n        }\\n        \\n        ListNode* nh = nullptr;\\n        while(!s.empty()){\\n            ListNode* nn = new ListNode();\\n            nn->val = s.top();\\n            nn->next = nh;\\n            nh = nn;\\n            s.pop();\\n        }\\n        \\n        return nh;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852606,
                "title": "java-reversing-100-faster",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head =  reverse(head);\\n        ListNode curr = head;\\n\\n        while (curr.next != null){\\n            if (curr.next.val >= curr.val){\\n                curr = curr.next;\\n            }\\n            else curr.next = curr.next.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head =  reverse(head);\\n        ListNode curr = head;\\n\\n        while (curr.next != null){\\n            if (curr.next.val >= curr.val){\\n                curr = curr.next;\\n            }\\n            else curr.next = curr.next.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n\\n        while (head != null) {\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851951,
                "title": "python-dfs-easy-unserstanding-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\npython | dfs | easy unserstanding | clean code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return head\\n        nextNode = self.removeNodes(head.next)\\n        if head.val < nextNode.val:\\n            return nextNode\\n        else:\\n            head.next = nextNode \\n            return head\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return head\\n        nextNode = self.removeNodes(head.next)\\n        if head.val < nextNode.val:\\n            return nextNode\\n        else:\\n            head.next = nextNode \\n            return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231655,
                "title": "c-o-n-space-100-fast-remove-nodes-from-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will reverse the LL.\\nWhile iterating we will keep track of the max value till the iteration and compare the current value with that of max value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* p=NULL;\\n        ListNode* c=head;\\n        ListNode* n=NULL;\\n        // Reversing the Linked List\\n        while(c)\\n        {\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n        }    \\n        // Now p becomes the new head of the reversed Linked List\\n        ListNode* t=p->next;\\n        // Max node contains the node which has the max value till those nodes which are travesed\\n        ListNode* max=p;\\n        while(t)\\n        {\\n            //checking if there is max valued node is present\\n            if(max->val>t->val)\\n                max->next=t->next;\\n            else\\n                max=t;\\n            t=t->next;\\n        }\\n\\n        // Now again reversing the Linked List so that the order remains same\\n        ListNode* cc=p;\\n        ListNode* pp=NULL;\\n        ListNode* nn=NULL;\\n        while(cc)\\n        {\\n            nn=cc->next;\\n            cc->next=pp;\\n            pp=cc;\\n            cc=nn;\\n        }\\n        //Since the pp is the new head of the modified original LL, we return that node;\\n        return pp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* p=NULL;\\n        ListNode* c=head;\\n        ListNode* n=NULL;\\n        // Reversing the Linked List\\n        while(c)\\n        {\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n        }    \\n        // Now p becomes the new head of the reversed Linked List\\n        ListNode* t=p->next;\\n        // Max node contains the node which has the max value till those nodes which are travesed\\n        ListNode* max=p;\\n        while(t)\\n        {\\n            //checking if there is max valued node is present\\n            if(max->val>t->val)\\n                max->next=t->next;\\n            else\\n                max=t;\\n            t=t->next;\\n        }\\n\\n        // Now again reversing the Linked List so that the order remains same\\n        ListNode* cc=p;\\n        ListNode* pp=NULL;\\n        ListNode* nn=NULL;\\n        while(cc)\\n        {\\n            nn=cc->next;\\n            cc->next=pp;\\n            pp=cc;\\n            cc=nn;\\n        }\\n        //Since the pp is the new head of the modified original LL, we return that node;\\n        return pp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872203,
                "title": "simple-solution-using-stack-and-creating-a-new-linkedlist-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode * reverse(ListNode *head){\\n        ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        ListNode* nxt = head->next;\\n        while(curr!=NULL){\\n            curr->next = prev ;\\n            prev = curr;\\n            curr = nxt;\\n            if(nxt!=NULL) nxt = nxt->next;\\n            \\n        }\\n        return prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> st;\\n        while(head!=NULL){\\n            st.push(head->val);\\n            head = head->next;\\n        }\\n        ListNode *newHead = new ListNode(st.top());\\n        st.pop();\\n        ListNode *temp = newHead;\\n        \\n        while(!st.empty()){\\n            if(st.top()>=temp->val){\\n                ListNode* node = new ListNode(st.top());\\n                temp->next = node;\\n                temp = temp->next;\\n                st.pop();\\n            }\\n            else\\n                st.pop();\\n        }\\n        return reverse(newHead);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode * reverse(ListNode *head){\\n        ListNode *curr = head;\\n        ListNode *prev = NULL;\\n        ListNode* nxt = head->next;\\n        while(curr!=NULL){\\n            curr->next = prev ;\\n            prev = curr;\\n            curr = nxt;\\n            if(nxt!=NULL) nxt = nxt->next;\\n            \\n        }\\n        return prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> st;\\n        while(head!=NULL){\\n            st.push(head->val);\\n            head = head->next;\\n        }\\n        ListNode *newHead = new ListNode(st.top());\\n        st.pop();\\n        ListNode *temp = newHead;\\n        \\n        while(!st.empty()){\\n            if(st.top()>=temp->val){\\n                ListNode* node = new ListNode(st.top());\\n                temp->next = node;\\n                temp = temp->next;\\n                st.pop();\\n            }\\n            else\\n                st.pop();\\n        }\\n        return reverse(newHead);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853345,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function(head) {\\n    \\n    if(!head) return null\\n    \\n    head.next = removeNodes(head.next)\\n    \\n    if(head.next && head.val < head.next.val) return head.next\\n    \\n    return head\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function(head) {\\n    \\n    if(!head) return null\\n    \\n    head.next = removeNodes(head.next)\\n    \\n    if(head.next && head.val < head.next.val) return head.next\\n    \\n    return head\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852095,
                "title": "c-java-python3-stack",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e728a9f475e5742bea7cf67ac2d1a98ab99fb206) for solutions of weekly 321. \\n\\n**Intuition**\\nThis is a typical application of stack. Here, we can use a stack to collect the nodes. When pushing a node onto the stack, we pop those whose values are smaller than the current one. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *dummy = new ListNode(INT_MAX); \\n        stack<ListNode*> stk; stk.push(dummy); \\n        for (ListNode* node = head; node; node = node->next) {\\n            while (stk.top()->val < node->val) stk.pop(); \\n            stk.top()->next = node; \\n            stk.push(node); \\n        }\\n        return dummy->next; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MAX_VALUE); \\n        Stack<ListNode> stk = new Stack<ListNode>(); stk.push(dummy); \\n        for (ListNode node = head; node != null; node = node.next) {\\n            while (stk.peek().val < node.val) stk.pop(); \\n            stk.peek().next = node; \\n            stk.push(node); \\n        }\\n        return dummy.next; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(inf)\\n        stack = [dummy]\\n        node = head\\n        while node: \\n            while stack[-1].val < node.val: stack.pop()\\n            stack[-1].next = node\\n            stack.append(node)\\n            node = node.next \\n        return dummy.next \\n```\\t\\t\\n**Complexity**\\nTime O(N)\\nSpace O(N)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *dummy = new ListNode(INT_MAX); \\n        stack<ListNode*> stk; stk.push(dummy); \\n        for (ListNode* node = head; node; node = node->next) {\\n            while (stk.top()->val < node->val) stk.pop(); \\n            stk.top()->next = node; \\n            stk.push(node); \\n        }\\n        return dummy->next; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy = new ListNode(Integer.MAX_VALUE); \\n        Stack<ListNode> stk = new Stack<ListNode>(); stk.push(dummy); \\n        for (ListNode node = head; node != null; node = node.next) {\\n            while (stk.peek().val < node.val) stk.pop(); \\n            stk.peek().next = node; \\n            stk.push(node); \\n        }\\n        return dummy.next; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(inf)\\n        stack = [dummy]\\n        node = head\\n        while node: \\n            while stack[-1].val < node.val: stack.pop()\\n            stack[-1].next = node\\n            stack.append(node)\\n            node = node.next \\n        return dummy.next \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555472,
                "title": "stack-c-lis",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> s;\\n        ListNode* p = head;\\n        while(p != NULL){\\n            while(!s.empty() && s.back()<p->val){\\n                s.pop_back();\\n            }\\n            s.push_back(p->val);\\n            // for(auto &i: s)cout<<i<<\" \";\\n            // cout<<endl;\\n            p = p->next;\\n        }\\n        ListNode* q = head;\\n        p = head;\\n        for(auto &i: s){\\n            p->val = i;\\n            q = p;\\n            p = p->next;\\n        }\\n        q->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> s;\\n        ListNode* p = head;\\n        while(p != NULL){\\n            while(!s.empty() && s.back()<p->val){\\n                s.pop_back();\\n            }\\n            s.push_back(p->val);\\n            // for(auto &i: s)cout<<i<<\" \";\\n            // cout<<endl;\\n            p = p->next;\\n        }\\n        ListNode* q = head;\\n        p = head;\\n        for(auto &i: s){\\n            p->val = i;\\n            q = p;\\n            p = p->next;\\n        }\\n        q->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2955783,
                "title": "c-easy-recursive-approach-beats-97-in-time",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        int val = head->val;\\n        ListNode* newNode = removeNodes(head->next);\\n        if(newNode->val <= val){\\n            head->next = newNode;\\n            return head;\\n        }else{\\n            return newNode;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        int val = head->val;\\n        ListNode* newNode = removeNodes(head->next);\\n        if(newNode->val <= val){\\n            head->next = newNode;\\n            return head;\\n        }else{\\n            return newNode;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883988,
                "title": "4-lines-recursion",
                "content": "# Intuition\\nFor each node find the next node using recursion and now check which should be returned the current node of the next using the given condition.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf the it\\'s the last node return it.\\nCompute the next node for the head.\\nIf the next node val is greater than the current node value then return the next node\\nelse return the current node.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next == null) return head;\\n        head.next = removeNodes(head.next);\\n        if(head.next.val > head.val) return head.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next == null) return head;\\n        head.next = removeNodes(head.next);\\n        if(head.next.val > head.val) return head.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852376,
                "title": "stack-based-solution",
                "content": "Its better to compare the value by not reversing the linkedlist and deleting each element better to keep inserting into a stack. Comparing the values while popping and comparing the elements.\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr = head;\\n        Stack<ListNode> stack = new Stack();\\n\\t\\t\\n\\t\\t\\uD835\\uDC68\\uD835\\uDC85\\uD835\\uDC85\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC8D \\uD835\\uDC95\\uD835\\uDC89\\uD835\\uDC86 \\uD835\\uDC86\\uD835\\uDC8D\\uD835\\uDC86\\uD835\\uDC8E\\uD835\\uDC86\\uD835\\uDC8F\\uD835\\uDC95\\uD835\\uDC94 \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC8D\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC8C\\uD835\\uDC86\\uD835\\uDC85\\uD835\\uDC8D\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC95 \\uD835\\uDC95\\uD835\\uDC90 \\uD835\\uDC94\\uD835\\uDC95\\uD835\\uDC82\\uD835\\uDC84\\uD835\\uDC8C\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        \\n\\t\\t\\uD835\\uDC84\\uD835\\uDC90\\uD835\\uDC8E\\uD835\\uDC91\\uD835\\uDC82\\uD835\\uDC93\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC95\\uD835\\uDC89\\uD835\\uDC86 \\uD835\\uDC97\\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC96\\uD835\\uDC86 \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC91\\uD835\\uDC86\\uD835\\uDC86\\uD835\\uDC8C \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC94\\uD835\\uDC95\\uD835\\uDC82\\uD835\\uDC84\\uD835\\uDC8C \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC84\\uD835\\uDC96\\uD835\\uDC93\\uD835\\uDC93\\uD835\\uDC86\\uD835\\uDC8F\\uD835\\uDC95 \\uD835\\uDC8F\\uD835\\uDC90\\uD835\\uDC85\\uD835\\uDC86 \\uD835\\uDC97\\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC96\\uD835\\uDC86\\n        while(!stack.isEmpty()){\\n            if(curr == null || stack.peek().val >= curr.val){\\n                stack.peek().next = curr;\\n                curr = stack.peek();\\n            }\\n            stack.pop();\\n        }\\n        return curr;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr = head;\\n        Stack<ListNode> stack = new Stack();\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            if(curr == null || stack.peek().val >= curr.val){\\n                stack.peek().next = curr;\\n                curr = stack.peek();\\n            }\\n            stack.pop();\\n        }\\n        return curr;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr = head;\\n        Stack<ListNode> stack = new Stack();\\n\\t\\t\\n\\t\\t\\uD835\\uDC68\\uD835\\uDC85\\uD835\\uDC85\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC8D \\uD835\\uDC95\\uD835\\uDC89\\uD835\\uDC86 \\uD835\\uDC86\\uD835\\uDC8D\\uD835\\uDC86\\uD835\\uDC8E\\uD835\\uDC86\\uD835\\uDC8F\\uD835\\uDC95\\uD835\\uDC94 \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC8D\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC8C\\uD835\\uDC86\\uD835\\uDC85\\uD835\\uDC8D\\uD835\\uDC8A\\uD835\\uDC94\\uD835\\uDC95 \\uD835\\uDC95\\uD835\\uDC90 \\uD835\\uDC94\\uD835\\uDC95\\uD835\\uDC82\\uD835\\uDC84\\uD835\\uDC8C\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        \\n\\t\\t\\uD835\\uDC84\\uD835\\uDC90\\uD835\\uDC8E\\uD835\\uDC91\\uD835\\uDC82\\uD835\\uDC93\\uD835\\uDC8A\\uD835\\uDC8F\\uD835\\uDC88 \\uD835\\uDC95\\uD835\\uDC89\\uD835\\uDC86 \\uD835\\uDC97\\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC96\\uD835\\uDC86 \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC91\\uD835\\uDC86\\uD835\\uDC86\\uD835\\uDC8C \\uD835\\uDC90\\uD835\\uDC87 \\uD835\\uDC94\\uD835\\uDC95\\uD835\\uDC82\\uD835\\uDC84\\uD835\\uDC8C \\uD835\\uDC98\\uD835\\uDC8A\\uD835\\uDC95\\uD835\\uDC89 \\uD835\\uDC84\\uD835\\uDC96\\uD835\\uDC93\\uD835\\uDC93\\uD835\\uDC86\\uD835\\uDC8F\\uD835\\uDC95 \\uD835\\uDC8F\\uD835\\uDC90\\uD835\\uDC85\\uD835\\uDC86 \\uD835\\uDC97\\uD835\\uDC82\\uD835\\uDC8D\\uD835\\uDC96\\uD835\\uDC86\\n        while(!stack.isEmpty()){\\n            if(curr == null || stack.peek().val >= curr.val){\\n                stack.peek().next = curr;\\n                curr = stack.peek();\\n            }\\n            stack.pop();\\n        }\\n        return curr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr = head;\\n        Stack<ListNode> stack = new Stack();\\n        while(curr != null){\\n            stack.push(curr);\\n            curr = curr.next;\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            if(curr == null || stack.peek().val >= curr.val){\\n                stack.peek().next = curr;\\n                curr = stack.peek();\\n            }\\n            stack.pop();\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688937,
                "title": "recursive-solution-in-o-n-time-and-space-complexity",
                "content": "# Intuition\\n We have to iterate through last that\\'s why I use recursion here\\n\\n# Approach\\n**step1->** Go to last node \\n\\n**step2->** now at returning update maximum value from last\\n\\n**step3->** if find any node less than maximum value remove that node\\n        from the linked list\\n\\n# Complexity\\n- Time complexity:\\n **O**(n)\\n\\n- Space complexity:\\n **O**(n)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    ListNode* solve(ListNode *p){\\n#        // Step1-> Base Case\\n        if(!p){\\n            return NULL;\\n        }\\n        p->next = solve(p->next);\\n\\n#        // Step2-> Update max value\\n        mx = max(mx,p->val);\\n\\n#        // Step3-> Remove node if its value is smaller than max\\n        if(p->val<mx){\\n            ListNode *temp = p->next;\\n            p->next = NULL;\\n            return temp;\\n        }\\n        return p;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *p = head;\\n        head = solve(p);\\n        return head;\\n    }\\n};\\n// Please upvote if you find it helpful\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mx = 0;\\n    ListNode* solve(ListNode *p){\\n#        // Step1-> Base Case\\n        if(!p){\\n            return NULL;\\n        }\\n        p->next = solve(p->next);\\n\\n#        // Step2-> Update max value\\n        mx = max(mx,p->val);\\n\\n#        // Step3-> Remove node if its value is smaller than max\\n        if(p->val<mx){\\n            ListNode *temp = p->next;\\n            p->next = NULL;\\n            return temp;\\n        }\\n        return p;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *p = head;\\n        head = solve(p);\\n        return head;\\n    }\\n};\\n// Please upvote if you find it helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596815,
                "title": "java-simple-program-to-remove-nodes-from-linked-list",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, reverse the given list using the reverse method. This method iterates over the list and changes the next pointer of each node to point to the previous node. It returns the new head of the reversed list.\\n- Then, create a temporary pointer to the head of the reversed list and initialize two variables: largest and prev. Largest will store the maximum value seen so far in the list, and prev will store the previous node of the current node.\\n- Loop over the reversed list using the temp pointer. For each node, get its next node and compare its value with largest. If the value is greater than or equal to largest, update largest and prev to be the current node and its value. Otherwise, remove the current node from the list by setting its next pointer to null and connecting prev\\'s next pointer to the next node.\\n- Finally, reverse the list again using the reverse method and return the new head of the modified list.\\n\\n**please upvote**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n        ListNode temp = head;\\n        int largest = Integer.MIN_VALUE;\\n        ListNode next = null;\\n        ListNode prev = null;\\n        while(temp != null){\\n            next = temp.next;\\n            if(temp.val >= largest){\\n                largest = temp.val;\\n                prev = temp;\\n            }else{\\n                temp.next = null;\\n                prev.next = next;\\n            }\\n            temp = next; \\n        }\\n        return reverse(head);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        ListNode current = head;\\n        ListNode next = null;\\n        while(current != null){\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n        ListNode temp = head;\\n        int largest = Integer.MIN_VALUE;\\n        ListNode next = null;\\n        ListNode prev = null;\\n        while(temp != null){\\n            next = temp.next;\\n            if(temp.val >= largest){\\n                largest = temp.val;\\n                prev = temp;\\n            }else{\\n                temp.next = null;\\n                prev.next = next;\\n            }\\n            temp = next; \\n        }\\n        return reverse(head);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        ListNode current = head;\\n        ListNode next = null;\\n        while(current != null){\\n            next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386147,
                "title": "easy-cpp-solution-stack-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intution would be to devlop an algo which will give me greater elements/nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code implements a function called removeNodes that takes a singly-linked list represented by its head node as input and removes all nodes that have a value greater than the maximum value encountered so far while iterating through the list. The function then returns a new linked list with the remaining nodes in the same order as the original list.\\n\\nThe algorithm works as follows:\\n\\nFirst, it disables synchronization between the standard streams in C++ using ios_base::sync_with_stdio(false) to speed up input/output operations.\\nThen, it initializes a stack called st to store the maximum values encountered so far in decreasing order.\\nIt then iterates through the linked list using a while loop that continues until head becomes NULL (i.e., the end of the list is reached).\\nInside the loop, it checks if st is not empty and if the value of the current node head is greater than the top element in st. If so, it pops the top element of st until the top element is greater than or equal to the value of head.\\nIt then pushes the value of head onto st.\\nAfter the loop completes, it initializes a new ListNode called temp to NULL.\\nThen, it starts another while loop that continues until st becomes empty.\\nInside the loop, it creates a new ListNode with the value of the top element of st and sets its next pointer to head.\\nIt then sets head to the new node temp and pops the top element of st.\\nFinally, it returns the new head node head.\\nOverall, the time complexity of this algorithm is O(n), where n is the number of nodes in the linked list, as it iterates through the list once and performs constant-time operations (pushing and popping from the stack) for each node. The space complexity is also O(n), as it uses a stack to store up to n maximum values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm iterates through the list once, and for each node, it performs a constant-time operation (pushing and popping from the stack). Therefore, the total time complexity is proportional to the size of the input, which is the number of nodes in the linked list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm uses a stack to store up to n maximum values. In the worst case, all nodes in the list are in decreasing order, and therefore all nodes will be pushed onto the stack. Thus, the space required by the stack is proportional to the size of the input, which is the number of nodes in the linked list. In addition, the algorithm creates a new ListNode object for each element in the stack, which also contributes to the space complexity. However, since the number of ListNode objects created is proportional to the number of nodes in the stack, and the stack size is proportional to the number of nodes in the linked list, the overall space complexity is O(n).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        stack<int>st;\\n        while(head){\\n            while(st.size()>0 && head->val>st.top()){\\n                st.pop();\\n            }\\n            st.push(head->val);\\n            head=head->next;\\n        }\\n        ListNode* temp=NULL;\\n        while(st.size()>0){\\n            temp=new ListNode(st.top());\\n            temp->next=head;\\n            head=temp;\\n            st.pop();\\n        }\\n        return head;\\n// ****PLEASE UPVOTE******\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        stack<int>st;\\n        while(head){\\n            while(st.size()>0 && head->val>st.top()){\\n                st.pop();\\n            }\\n            st.push(head->val);\\n            head=head->next;\\n        }\\n        ListNode* temp=NULL;\\n        while(st.size()>0){\\n            temp=new ListNode(st.top());\\n            temp->next=head;\\n            head=temp;\\n            st.pop();\\n        }\\n        return head;\\n// ****PLEASE UPVOTE******\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342658,
                "title": "easy-c-solution-beats-93-65-by-reversing-linkedlist",
                "content": "# Intuition\\n- By Reversing The List.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Two Pointers Game.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: -->> O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: -->> O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        if(!head -> next) return head;\\n        \\n        ListNode* head1 = reverse(head);\\n\\n        ListNode* curr = head1;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n\\n            while(forward != NULL) \\n            {\\n                if(curr->val > forward->val) forward = forward -> next;\\n                else break;\\n            }\\n\\n            curr -> next = forward;\\n            curr = curr -> next;\\n        }\\n\\n        return head = reverse(head1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    ListNode* reverse(ListNode* head)\\n    {\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n\\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        if(!head -> next) return head;\\n        \\n        ListNode* head1 = reverse(head);\\n\\n        ListNode* curr = head1;\\n        ListNode* forward = NULL;\\n\\n        while(curr)\\n        {\\n            forward = curr -> next;\\n\\n            while(forward != NULL) \\n            {\\n                if(curr->val > forward->val) forward = forward -> next;\\n                else break;\\n            }\\n\\n            curr -> next = forward;\\n            curr = curr -> next;\\n        }\\n\\n        return head = reverse(head1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254730,
                "title": "stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> v;\\n        ListNode* p = head,*q;\\n        while(p){\\n            while(!v.empty()&&v.back()<p->val)v.pop_back();\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        p = head;\\n        int i = 0, n = v.size();\\n        while(i<n){\\n            p->val = v[i++];\\n            v.pop_back();\\n            q = p;\\n            p = p->next;\\n        }\\n        q->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> v;\\n        ListNode* p = head,*q;\\n        while(p){\\n            while(!v.empty()&&v.back()<p->val)v.pop_back();\\n            v.push_back(p->val);\\n            p = p->next;\\n        }\\n        p = head;\\n        int i = 0, n = v.size();\\n        while(i<n){\\n            p->val = v[i++];\\n            v.pop_back();\\n            q = p;\\n            p = p->next;\\n        }\\n        q->next = NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913873,
                "title": "simple-detailed-explanation-c-clean-code",
                "content": "# Intuition\\nIt is very much apparent that since we need a non increasing sequence we need to use a monotonic stack (in which we check the elments at top and pop them out if they are lesser than current element in hand). Example: if stack has elements [5, 2, 3] and element in hand is 4 then 4 will pop out 3 which is lesser, then it will pop out 2 which is lesser. It then competes with 5 which is larger hence it stops and just pushes itself. So the final state of stack is [5,4].\\n\\n# Approach\\n- Using a monotonic stack is simple, but at the end  we are left with a non-increasing sequence from bottom to top (exmpl: [5, 4, 1]). Our linked list starts from the base of stack and then moves towards top i.e 5-> .... ->4 .... ->1. But stack will give us these elements in reverse order only i.e from top to bottom.\\n- Since stack will give elements in reverse order, we can use recursion in the following way: pop the top (i.e 1), and then use recursion to get linked list for remaining stack (i.e 5->4).then attach top element in hand(1) to the tail of recieved list and form list 5->4->1.\\n- This is a nice way and expected one, since Leetcode mentions recursion in related topics to this question.\\n- However, there is another way to avoid recursion (and associated function call overhead). This is by using a deque instead of stack. We use deque just like a stack and push/pop at the back, and then at the end when we recieve the full sequence , then we can start popping from the front of the list. This is like a stack that also gives us ability to pop from bottom. Via this way, we can avoid recursive function calls and use only iteration.\\n-  Also, we should utilize already made nodes from linked list and not just create new ones from values in stack/deque. This means we need one more iteration, but is more desired in practical scenario (or interview) where satellite data of a node in linked list is large;\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since we iterate over list atleast once.\\n\\n- Space complexity:\\n$$O(n)$$     | Average case complexity would be much less, but in worst case, when all given values are non-decreasing, stack will contain whole list at end so $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        deque<int> s;\\n\\n        while(temp != NULL)\\n        {\\n            while(!s.empty() && s.back() < temp->val)\\n                s.pop_back();\\n            s.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        ListNode* newHead = NULL;\\n        ListNode* tail = NULL;\\n\\n        //stack(or deque) is now ready - now begin forming new list\\n        while(temp != NULL)\\n        {\\n            if(temp->val == s.front())\\n            {\\n                if(!newHead)\\n                    newHead = tail = temp;\\n                else\\n                    {\\n                        tail->next = temp;\\n                        tail = temp;        // very imp that tail->next is not set to \\n                                            //NULL, it allows iteration at end of while loop\\n                    }\\n                s.pop_front();\\n            }\\n            temp = temp->next;\\n        }\\n        //tail->next = NULL;    // even this is not needed as last element will always have \\n                                //next as NULL since last element of linked list will always be in final list\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Queue",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        deque<int> s;\\n\\n        while(temp != NULL)\\n        {\\n            while(!s.empty() && s.back() < temp->val)\\n                s.pop_back();\\n            s.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n\\n        temp = head;\\n        ListNode* newHead = NULL;\\n        ListNode* tail = NULL;\\n\\n        //stack(or deque) is now ready - now begin forming new list\\n        while(temp != NULL)\\n        {\\n            if(temp->val == s.front())\\n            {\\n                if(!newHead)\\n                    newHead = tail = temp;\\n                else\\n                    {\\n                        tail->next = temp;\\n                        tail = temp;        // very imp that tail->next is not set to \\n                                            //NULL, it allows iteration at end of while loop\\n                    }\\n                s.pop_front();\\n            }\\n            temp = temp->next;\\n        }\\n        //tail->next = NULL;    // even this is not needed as last element will always have \\n                                //next as NULL since last element of linked list will always be in final list\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852559,
                "title": "simple-c-solution-without-using-vector-array-simple-recursion-o-n",
                "content": "simple brute force solution without using array/vector\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        return fun(head,nullptr);\\n    }\\n    ListNode* fun(ListNode* head,ListNode* prev){\\n        if(head->next==nullptr){\\n            return head;\\n        }\\n        ListNode* x = fun(head->next,head);\\n        if(head->val < x->val){\\n            if(prev)prev->next = x;\\n            return x;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        return fun(head,nullptr);\\n    }\\n    ListNode* fun(ListNode* head,ListNode* prev){\\n        if(head->next==nullptr){\\n            return head;\\n        }\\n        ListNode* x = fun(head->next,head);\\n        if(head->val < x->val){\\n            if(prev)prev->next = x;\\n            return x;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852409,
                "title": "js-simple-solution-stack",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function (head) {\\n  const stack = [];\\n  while (head) {\\n    while (stack.length && head.val > stack[stack.length - 1]) {\\n      stack.pop();\\n    }\\n    stack.push(head.val);\\n    head = head.next;\\n  }\\n  while (stack.length) {\\n    head = new ListNode(stack.pop(), head);\\n  }\\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function (head) {\\n  const stack = [];\\n  while (head) {\\n    while (stack.length && head.val > stack[stack.length - 1]) {\\n      stack.pop();\\n    }\\n    stack.push(head.val);\\n    head = head.next;\\n  }\\n  while (stack.length) {\\n    head = new ListNode(stack.pop(), head);\\n  }\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983950,
                "title": "java-solution-o-n-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        int max = prev.val;\\n        ListNode res = new ListNode();\\n        ListNode r = res.next;\\n        while(prev != null) {\\n            if(prev.val >= max) {\\n                max = Integer.max(max, prev.val);\\n                ListNode newNode = new ListNode(prev.val);\\n                res.next = newNode;\\n                newNode.next = r;\\n                r = newNode;\\n            }\\n            prev = prev.next;\\n        }\\n        return res.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        int max = prev.val;\\n        ListNode res = new ListNode();\\n        ListNode r = res.next;\\n        while(prev != null) {\\n            if(prev.val >= max) {\\n                max = Integer.max(max, prev.val);\\n                ListNode newNode = new ListNode(prev.val);\\n                res.next = newNode;\\n                newNode.next = r;\\n                r = newNode;\\n            }\\n            prev = prev.next;\\n        }\\n        return res.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879730,
                "title": "with-stack-without-stack-space-o-1-and-recursive-solutions-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Solution 1 \\nclass Solution {\\npublic:\\n    // Function to reverse the LL and return the new head \\n    ListNode* reverse(ListNode* head){\\n        ListNode *prev = NULL, *forward = NULL;\\n        while(head != NULL){\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n\\n    // Function to find the next greater element using stack and \\n    // put node val = 0 for elements with greater element in their left\\n    void prevGreaterElement(ListNode* &head){\\n        ListNode *curr = head;\\n        stack<int> s;\\n        s.push(0);\\n        while(curr != NULL){\\n            if(curr->val >= s.top())\\n                s.push(curr->val);\\n            else\\n                curr->val = 0;\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        // This problem asks us to remove the nodes with greater elements in their right\\n        // since we will need to traverse from right to left and we cannot do that \\n        // in a singly LL, we have reversed the LL and now we move from left to right \\n        ListNode *newHead = reverse(head);\\n        \\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = newHead;\\n\\n        // Find the greater element to the node\\'s left and put node->val = 0\\n        // for elements with greater eleemnt to their left\\n        prevGreaterElement(newHead);\\n\\n        ListNode *curr = newHead, *prev = dummy;\\n        // Remove the nodes with node->val = 0 since they have greater element to their left\\n        while(curr != NULL){\\n            if(curr->val == 0){\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n\\n        // Reverse the LL and return the head to get the final answer\\n        return reverse(newHead);\\n    }\\n};\\n\\n// Solution 2 \\n// We can simply replace the stack by just maintaining an int variable\\nvoid prevGreaterElement(ListNode* &head){\\n    ListNode *curr = head;\\n    int mx = 0;\\n    while(curr != NULL){\\n        if(curr->val >= mx)\\n            mx = curr->val;\\n          else\\n            curr->val = 0;\\n        curr = curr->next;\\n    }\\n}\\n\\n// Solution 3\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        ListNode *newNode = removeNodes(head->next);\\n\\n        if(newNode->val > head->val)\\n            return newNode;\\n\\n        head->next = newNode;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Recursion",
                    "Monotonic Stack"
                ],
                "code": "```\\n// Solution 1 \\nclass Solution {\\npublic:\\n    // Function to reverse the LL and return the new head \\n    ListNode* reverse(ListNode* head){\\n        ListNode *prev = NULL, *forward = NULL;\\n        while(head != NULL){\\n            forward = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = forward;\\n        }\\n        return prev;\\n    }\\n\\n    // Function to find the next greater element using stack and \\n    // put node val = 0 for elements with greater element in their left\\n    void prevGreaterElement(ListNode* &head){\\n        ListNode *curr = head;\\n        stack<int> s;\\n        s.push(0);\\n        while(curr != NULL){\\n            if(curr->val >= s.top())\\n                s.push(curr->val);\\n            else\\n                curr->val = 0;\\n            curr = curr->next;\\n        }\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        // This problem asks us to remove the nodes with greater elements in their right\\n        // since we will need to traverse from right to left and we cannot do that \\n        // in a singly LL, we have reversed the LL and now we move from left to right \\n        ListNode *newHead = reverse(head);\\n        \\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = newHead;\\n\\n        // Find the greater element to the node\\'s left and put node->val = 0\\n        // for elements with greater eleemnt to their left\\n        prevGreaterElement(newHead);\\n\\n        ListNode *curr = newHead, *prev = dummy;\\n        // Remove the nodes with node->val = 0 since they have greater element to their left\\n        while(curr != NULL){\\n            if(curr->val == 0){\\n                prev->next = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n            }\\n            curr = curr->next;\\n        }\\n\\n        // Reverse the LL and return the head to get the final answer\\n        return reverse(newHead);\\n    }\\n};\\n\\n// Solution 2 \\n// We can simply replace the stack by just maintaining an int variable\\nvoid prevGreaterElement(ListNode* &head){\\n    ListNode *curr = head;\\n    int mx = 0;\\n    while(curr != NULL){\\n        if(curr->val >= mx)\\n            mx = curr->val;\\n          else\\n            curr->val = 0;\\n        curr = curr->next;\\n    }\\n}\\n\\n// Solution 3\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n\\n        ListNode *newNode = removeNodes(head->next);\\n\\n        if(newNode->val > head->val)\\n            return newNode;\\n\\n        head->next = newNode;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764208,
                "title": "both-recursive-and-iterative-solution-c-easy-to-understand",
                "content": "\\n\\n# ***RECURSIVE SOLUTION***\\n\\n    class Solution {\\n    public:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode* p=removeNodes(head->next);\\n        head->next=p;\\n        if(head->val<head->next->val){\\n            return head->next;\\n        }\\n        return head;\\n       }\\n    };\\n\\t\\n\\t\\n# ***ITERATIVE SOLUTION***\\n\\n    class Solution {\\n    public:\\n    \\n    \\n    ListNode* reverse(ListNode* head){\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode* p=reverse(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return p;\\n    }\\n    \\n    ListNode* removeNodes(ListNode* head) {\\n        head=reverse(head);\\n        ListNode* p=head;\\n        while(p!=NULL and p->next!=NULL){\\n            if(p->val>p->next->val){\\n                p->next=p->next->next;\\n            }\\n            else{\\n                p=p->next;\\n            }\\n        }\\n        return reverse(head);\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3742746,
                "title": "java-easy-100-solution",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n\\n        ListNode max = head, curr = head.next;\\n\\n        while(curr != null) {\\n            if(max.val > curr.val)\\n                max.next = curr.next;\\n            else\\n                max = curr;\\n\\n            curr = curr.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while(head != null) {\\n            ListNode tmp = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = tmp;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head = reverse(head);\\n\\n        ListNode max = head, curr = head.next;\\n\\n        while(curr != null) {\\n            if(max.val > curr.val)\\n                max.next = curr.next;\\n            else\\n                max = curr;\\n\\n            curr = curr.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n\\n    private ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n\\n        while(head != null) {\\n            ListNode tmp = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = tmp;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624301,
                "title": "java-o-n-solution-reverse-list",
                "content": "# Approach\\n- Reverse the original list.\\n- Keep track of the max while traversing the list.\\n- If current node\\'s value is lesser than max then skip the node.\\n- Reverse the list again.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode newHead = reverseList(head);\\n        ListNode prev = null;\\n        ListNode curr = newHead;\\n\\n        int max = 0;\\n        while(curr != null) {\\n            if(curr.val > max) {\\n                max = curr.val;\\n            }\\n\\n            if(curr.val < max) {\\n                prev.next = curr.next;\\n            } else {\\n                prev = curr;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        return reverseList(newHead);\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode newHead = reverseList(head);\\n        ListNode prev = null;\\n        ListNode curr = newHead;\\n\\n        int max = 0;\\n        while(curr != null) {\\n            if(curr.val > max) {\\n                max = curr.val;\\n            }\\n\\n            if(curr.val < max) {\\n                prev.next = curr.next;\\n            } else {\\n                prev = curr;\\n            }\\n            curr = curr.next;\\n        }\\n\\n        return reverseList(newHead);\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        while(curr != null) {\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509514,
                "title": "easy-c-solution-using-stack-vector",
                "content": "# Intuition\\nStack question\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1)Create a stack\\n2)Traverse the LL and store it in stack only if s.top()>root->val.\\n3)Create a vector and store all element in vector and pop all element from stack.\\n4)Reverse the vector as stack will give reverse elements.\\n5)Use a for loop to create a LL and return root\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* root=NULL;\\n        root=head;\\n        stack<int>s;\\n        while(root)\\n        {\\n            while(!s.empty() && s.top()<root->val)\\n            {\\n                s.pop();\\n            }\\n            s.push(root->val);\\n            root=root->next;\\n        }\\n        \\n        if(s.empty()) return NULL;\\n\\n        vector<int>arr;\\n        while(!s.empty())\\n        {\\n            arr.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(begin(arr),end(arr));\\n        int n =arr.size();\\n        root=head;\\n        for(int i =0;i<n;++i)\\n        {\\n            root->val=arr[i];\\n            if(i!=n-1) \\n            root=root->next;\\n        }\\n        root->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* root=NULL;\\n        root=head;\\n        stack<int>s;\\n        while(root)\\n        {\\n            while(!s.empty() && s.top()<root->val)\\n            {\\n                s.pop();\\n            }\\n            s.push(root->val);\\n            root=root->next;\\n        }\\n        \\n        if(s.empty()) return NULL;\\n\\n        vector<int>arr;\\n        while(!s.empty())\\n        {\\n            arr.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(begin(arr),end(arr));\\n        int n =arr.size();\\n        root=head;\\n        for(int i =0;i<n;++i)\\n        {\\n            root->val=arr[i];\\n            if(i!=n-1) \\n            root=root->next;\\n        }\\n        root->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189382,
                "title": "c-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int i=0;\\n    ListNode* removeNodes(ListNode* head) {\\n        if(i==0 && head->next!=NULL && head->next->next==NULL){\\n           if(head->val<head->next->val)\\n            head=head->next;\\n            return head;\\n        }\\n       i++;\\n        if(head->next->next==NULL){\\n            return head;\\n        }\\n        removeNodes(head->next);\\n        if(head->next->val<head->next->next->val){\\n            head->next=head->next->next;\\n        }\\n        if(head->val<head->next->val){\\n            head=head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int i=0;\\n    ListNode* removeNodes(ListNode* head) {\\n        if(i==0 && head->next!=NULL && head->next->next==NULL){\\n           if(head->val<head->next->val)\\n            head=head->next;\\n            return head;\\n        }\\n       i++;\\n        if(head->next->next==NULL){\\n            return head;\\n        }\\n        removeNodes(head->next);\\n        if(head->next->val<head->next->next->val){\\n            head->next=head->next->next;\\n        }\\n        if(head->val<head->next->val){\\n            head=head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121684,
                "title": "iterative-approach-in-java-time-o-n-space-o-1",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Reverse linked List\\n2. Keep track of largest element.\\n3. Traverse linkedlist and If current element is less than largest element remove that element.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ $$n = length(linked list)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$  no extra space is used \\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    public ListNode reverse(ListNode head)\\n    {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        ListNode next=null;\\n\\n        while(cur!=null)\\n        {\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;\\n    }\\n\\n    public ListNode removeNodes(ListNode head) {\\n\\n\\n        //1.reverse linked List\\n        head=reverse(head);\\n\\n        //2.keep track of largest element.\\n        int max=head.val;\\n\\n        //3.Traverse linkedlist and If current element is less than largest element remove that element.\\n        ListNode iter=head.next;\\n        ListNode prev=head;\\n        while(iter!=null)\\n        {\\n            if(iter.val<max)//delete node \\n            {\\n                prev.next=iter.next;\\n            }\\n            else//update max value\\n            {\\n                max=iter.val;\\n                prev=iter;\\n            }\\n            iter=iter.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    public ListNode reverse(ListNode head)\\n    {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        ListNode next=null;\\n\\n        while(cur!=null)\\n        {\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;\\n    }\\n\\n    public ListNode removeNodes(ListNode head) {\\n\\n\\n        //1.reverse linked List\\n        head=reverse(head);\\n\\n        //2.keep track of largest element.\\n        int max=head.val;\\n\\n        //3.Traverse linkedlist and If current element is less than largest element remove that element.\\n        ListNode iter=head.next;\\n        ListNode prev=head;\\n        while(iter!=null)\\n        {\\n            if(iter.val<max)//delete node \\n            {\\n                prev.next=iter.next;\\n            }\\n            else//update max value\\n            {\\n                max=iter.val;\\n                prev=iter;\\n            }\\n            iter=iter.next;\\n        }\\n\\n        return reverse(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084502,
                "title": "95-runtime-java-no-additional-data-structure-required",
                "content": "# Intuition\\nMy first intution was it would\\'ve been easier if the list was reversed. And then we could just continuosly remove nodes which are lesser than current node.\\n\\n# Approach\\n1. reverse list.\\n2. for current node remove nodes further to it, which have value less than the current node.\\n3. reverse list -> return the answer.\\n\\n# Complexity\\n- Time complexity:\\nReverse O(n)\\nRemoval O(n)\\nReverse again O(n) , hence O(n).\\n\\n- Space complexity:\\nUsed 1 extra linkedlist to store result. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode newHead = reverse(head);\\n        //System.out.println(newHead.val);\\n        ListNode newHeadNext = newHead.next;\\n\\n        ListNode trimmedList = new ListNode(newHead.val);\\n        ListNode trimmedListPtr = trimmedList;\\n\\n        while(newHeadNext!=null){\\n            while(newHeadNext !=null && newHeadNext.val < newHead.val){\\n                //System.out.println(\"val:\"+newHeadNext.val +\" less than \"+newHead.val);\\n                newHeadNext = newHeadNext.next;\\n            }\\n            if(newHeadNext!=null){\\n                trimmedListPtr.next = new ListNode(newHeadNext.val);\\n                trimmedListPtr = trimmedListPtr.next;\\n                //System.out.println(\"adding val:\"+trimmedListPtr.val);\\n                newHead = newHeadNext;\\n                newHeadNext = newHeadNext.next;\\n            }\\n        }\\n\\n        //print(trimmedList);\\n\\n        ListNode result = reverse(trimmedList);\\n\\n        return result;\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        while(head!=null){\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n\\n    public void print(ListNode head){\\n        while(head!=null){\\n            System.out.print(head.val+\" \");\\n            head = head.next;\\n        }\\n    }\\n}\\n```\\n\\nPlease suggest for any improvements, thank you!\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode newHead = reverse(head);\\n        //System.out.println(newHead.val);\\n        ListNode newHeadNext = newHead.next;\\n\\n        ListNode trimmedList = new ListNode(newHead.val);\\n        ListNode trimmedListPtr = trimmedList;\\n\\n        while(newHeadNext!=null){\\n            while(newHeadNext !=null && newHeadNext.val < newHead.val){\\n                //System.out.println(\"val:\"+newHeadNext.val +\" less than \"+newHead.val);\\n                newHeadNext = newHeadNext.next;\\n            }\\n            if(newHeadNext!=null){\\n                trimmedListPtr.next = new ListNode(newHeadNext.val);\\n                trimmedListPtr = trimmedListPtr.next;\\n                //System.out.println(\"adding val:\"+trimmedListPtr.val);\\n                newHead = newHeadNext;\\n                newHeadNext = newHeadNext.next;\\n            }\\n        }\\n\\n        //print(trimmedList);\\n\\n        ListNode result = reverse(trimmedList);\\n\\n        return result;\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n        ListNode prev = null;\\n        while(head!=null){\\n            ListNode next = head.next;\\n            head.next = prev;\\n            prev = head;\\n            head = next;\\n        }\\n        return prev;\\n    }\\n\\n    public void print(ListNode head){\\n        while(head!=null){\\n            System.out.print(head.val+\" \");\\n            head = head.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061747,
                "title": "easy-solution-using-stack-beats-others-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head->next==NULL)return head;\\n        ListNode* curr=head;\\n        stack<ListNode*>st;\\n        st.push(curr);\\n        curr=curr->next;\\n        while(curr!=NULL){\\n            if(!st.empty() && curr->val>st.top()->val){\\n                while(!st.empty() && curr->val>st.top()->val){\\n                    ListNode* temp=st.top();\\n                    st.pop();\\n                    delete temp;\\n                }\\n                if(st.empty()){\\n                    st.push(curr);\\n                    head=curr;\\n                }\\n                else{\\n                    st.top()->next=curr;\\n                    st.push(curr);\\n                }\\n            }\\n            else{\\n                st.push(curr);\\n            }\\n            curr=curr->next;\\n\\n            \\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head->next==NULL)return head;\\n        ListNode* curr=head;\\n        stack<ListNode*>st;\\n        st.push(curr);\\n        curr=curr->next;\\n        while(curr!=NULL){\\n            if(!st.empty() && curr->val>st.top()->val){\\n                while(!st.empty() && curr->val>st.top()->val){\\n                    ListNode* temp=st.top();\\n                    st.pop();\\n                    delete temp;\\n                }\\n                if(st.empty()){\\n                    st.push(curr);\\n                    head=curr;\\n                }\\n                else{\\n                    st.top()->next=curr;\\n                    st.push(curr);\\n                }\\n            }\\n            else{\\n                st.push(curr);\\n            }\\n            curr=curr->next;\\n\\n            \\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012406,
                "title": "simple-compact-and-recursive",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def removeNode (head):\\n            if (head == None):\\n                return None\\n            head.next = removeNode(head.next);\\n            return head.next if (head.next != None and head.val < head.next.val) else head;\\n        return removeNode(head)  \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def removeNode (head):\\n            if (head == None):\\n                return None\\n            head.next = removeNode(head.next);\\n            return head.next if (head.next != None and head.val < head.next.val) else head;\\n        return removeNode(head)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003415,
                "title": "c-easy-understandable-solution",
                "content": "\\n\\n# Approach\\n        reverse the node because we cannot access elements from end of list(as we did in array)\\n      delete if maxi>curr val\\n      if delete prev->next=prev->next->next else update prev\\n      updation of prev means that this element has been passed !!!\\n\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n- Space complexity:\\no(1)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n       ListNode* curr=head;\\n        ListNode * prev=NULL;\\n        ListNode * next1=NULL;\\n        while(curr != NULL){\\n        next1=curr->next;\\n       curr->next=prev;\\n       prev=curr;\\n       curr=next1;\\n        }\\n        return prev ;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n      head=reverse(head);\\n      ListNode* curr=head;\\n      ListNode* prev=NULL;\\n      int maxi=head->val;\\n      while(curr != NULL){\\n      maxi=max(maxi,curr->val);\\n      if(maxi > curr->val){\\n          prev->next=prev->next->next;\\n      }\\n          else \\n          prev = curr;\\n          \\n          curr=curr->next;\\n      }\\n     return reverse(head);\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverse(ListNode* head) {\\n       ListNode* curr=head;\\n        ListNode * prev=NULL;\\n        ListNode * next1=NULL;\\n        while(curr != NULL){\\n        next1=curr->next;\\n       curr->next=prev;\\n       prev=curr;\\n       curr=next1;\\n        }\\n        return prev ;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n      head=reverse(head);\\n      ListNode* curr=head;\\n      ListNode* prev=NULL;\\n      int maxi=head->val;\\n      while(curr != NULL){\\n      maxi=max(maxi,curr->val);\\n      if(maxi > curr->val){\\n          prev->next=prev->next->next;\\n      }\\n          else \\n          prev = curr;\\n          \\n          curr=curr->next;\\n      }\\n     return reverse(head);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2977906,
                "title": "using-stack-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        stack <ListNode*> stk;\\n        auto curr=head;\\n\\n        head =new ListNode(INT_MAX, head);\\n        stk.push(head);\\n        while(curr)\\n        {\\n            while(stk.top()->val <curr->val)\\n            {\\n                stk.pop();\\n            }\\n\\n            stk.top()->next= curr;\\n            stk.push(curr);\\n            curr = curr->next;\\n        }\\n\\n        return head->next;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        stack <ListNode*> stk;\\n        auto curr=head;\\n\\n        head =new ListNode(INT_MAX, head);\\n        stk.push(head);\\n        while(curr)\\n        {\\n            while(stk.top()->val <curr->val)\\n            {\\n                stk.pop();\\n            }\\n\\n            stk.top()->next= curr;\\n            stk.push(curr);\\n            curr = curr->next;\\n        }\\n\\n        return head->next;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942796,
                "title": "easy-java-solution-using-stack-with-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a stack to backtrack and remove all the node having smaller value for the current node. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Check if the node is null or node.next is null-->in this case return head.\\n2.push the head node to the stack and take ListNode current=head.next;\\n3.Iterate until current!=null.\\n4.Every iteration check stack.peek() and remove all possible smaller nodes.\\n5.if stack became empty due to the remove operation make the current node as head and push it to the stack.\\n6.if stack is not empty then make current node as the next node of stack.peek().\\n7.lastly don\\'t forget to update the current node to the next node.\\nYou are done.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null || head.next==null)return head;\\n        Stack<ListNode>stack=new Stack<>();\\n        stack.push(head);\\n        ListNode current=head.next;\\n        while(current!=null){\\n            ListNode next=current.next;\\n            while(!stack.isEmpty() && stack.peek().val<current.val)stack.pop();\\n            if(stack.isEmpty())head=current;\\n            else stack.peek().next=current;\\n            stack.push(current);\\n            current=next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null || head.next==null)return head;\\n        Stack<ListNode>stack=new Stack<>();\\n        stack.push(head);\\n        ListNode current=head.next;\\n        while(current!=null){\\n            ListNode next=current.next;\\n            while(!stack.isEmpty() && stack.peek().val<current.val)stack.pop();\\n            if(stack.isEmpty())head=current;\\n            else stack.peek().next=current;\\n            stack.push(current);\\n            current=next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939186,
                "title": "c-simple-stack-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n       stack<int> st;\\n       ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n           while(st.size()>0 and temp->val>st.top())\\n                st.pop();\\n            st.push(temp->val);\\n            temp=temp->next;\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        ListNode* head1=new ListNode(-1);\\n        ListNode* temp1=head1;\\n        for(int x:ans)\\n        {\\n            ListNode* x1=new ListNode(x);\\n            temp1->next=x1;\\n            temp1=temp1->next;\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n       stack<int> st;\\n       ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n           while(st.size()>0 and temp->val>st.top())\\n                st.pop();\\n            st.push(temp->val);\\n            temp=temp->next;\\n        }\\n        vector<int> ans;\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        ListNode* head1=new ListNode(-1);\\n        ListNode* temp1=head1;\\n        for(int x:ans)\\n        {\\n            ListNode* x1=new ListNode(x);\\n            temp1->next=x1;\\n            temp1=temp1->next;\\n        }\\n        return head1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909619,
                "title": "c-beats-87-simple-stack-operations",
                "content": "# Intuition\\nKnowing how to get next greater element using stack.\\n\\n# Approach\\nUsing push and pop operatoin to get next greater element.Finally createing a Linked-List with the remaining elments in the stack which are in order.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tListNode* removeNodes(ListNode* head) {\\n\\t\\tListNode* ptr=head;\\n\\t\\tstack<int>s;\\n\\n\\t\\twhile(ptr){\\n\\t\\t\\tif(s.empty()){\\n\\t\\t\\t\\ts.push(ptr->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(!s.empty() && s.top()<ptr->val){\\n\\t\\t\\t\\t\\twhile(!s.empty() && s.top()<ptr->val){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts.push(ptr->val);\\n\\t\\t\\t}\\n\\t\\t\\tptr=ptr->next;\\n\\t\\t}\\n        \\n        // Basically creating a new LL.\\n\\t\\tListNode *root = NULL;\\n\\t\\twhile(!s.empty()){\\n\\t\\t\\tListNode* temp = new ListNode;\\n\\t\\t    temp->val= s.top();\\n\\t\\t    temp->next = root;\\n\\t\\t    root = temp;\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tListNode* removeNodes(ListNode* head) {\\n\\t\\tListNode* ptr=head;\\n\\t\\tstack<int>s;\\n\\n\\t\\twhile(ptr){\\n\\t\\t\\tif(s.empty()){\\n\\t\\t\\t\\ts.push(ptr->val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(!s.empty() && s.top()<ptr->val){\\n\\t\\t\\t\\t\\twhile(!s.empty() && s.top()<ptr->val){\\n\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ts.push(ptr->val);\\n\\t\\t\\t}\\n\\t\\t\\tptr=ptr->next;\\n\\t\\t}\\n        \\n        // Basically creating a new LL.\\n\\t\\tListNode *root = NULL;\\n\\t\\twhile(!s.empty()){\\n\\t\\t\\tListNode* temp = new ListNode;\\n\\t\\t    temp->val= s.top();\\n\\t\\t    temp->next = root;\\n\\t\\t    root = temp;\\n\\t\\t\\ts.pop();\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893137,
                "title": "java-stack-remove-nodes-from-linked-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n       \\n        if(head.next==null)return head;\\n        int maxval=Integer.MAX_VALUE;\\n        ListNode newnode=new ListNode(maxval);\\n        Stack<ListNode> stack=new Stack<ListNode>();\\n        stack.push(newnode);\\n        while(head!=null)\\n        {\\n            while(stack.peek().val<head.val)stack.pop();\\n            stack.peek().next=head;\\n            stack.push(head);\\n            head=head.next;\\n        }\\n        return newnode.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n       \\n        if(head.next==null)return head;\\n        int maxval=Integer.MAX_VALUE;\\n        ListNode newnode=new ListNode(maxval);\\n        Stack<ListNode> stack=new Stack<ListNode>();\\n        stack.push(newnode);\\n        while(head!=null)\\n        {\\n            while(stack.peek().val<head.val)stack.pop();\\n            stack.peek().next=head;\\n            stack.push(head);\\n            head=head.next;\\n        }\\n        return newnode.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890780,
                "title": "easy-and-simple-c-solution-stack-linked-list",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a stack using the linked list such that every element on the right of it in linked list that is top of it in the stack is strictly lesser than or equal to the previous on one.\\n\\nAfter creating of stack, Just convert the stack to linked link.\\n\\nThe code accompanied is itself self explanatory..\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> stk;\\n        while (head){\\n            while (!stk.empty() && stk.top()< head->val){\\n                stk.pop();\\n            }\\n            stk.push(head->val);\\n            head= head->next;\\n        }\\n        if (stk.empty())return NULL;\\n        ListNode* nxt_node= new ListNode(stk.top());\\n        ListNode* new_head= new ListNode(stk.top());\\n        stk.pop();\\n        while (!stk.empty()){\\n            new_head= new ListNode(stk.top());\\n            new_head->next= nxt_node;\\n            nxt_node= new_head;\\n            stk.pop();\\n        }\\n        return new_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int> stk;\\n        while (head){\\n            while (!stk.empty() && stk.top()< head->val){\\n                stk.pop();\\n            }\\n            stk.push(head->val);\\n            head= head->next;\\n        }\\n        if (stk.empty())return NULL;\\n        ListNode* nxt_node= new ListNode(stk.top());\\n        ListNode* new_head= new ListNode(stk.top());\\n        stk.pop();\\n        while (!stk.empty()){\\n            new_head= new ListNode(stk.top());\\n            new_head->next= nxt_node;\\n            nxt_node= new_head;\\n            stk.pop();\\n        }\\n        return new_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883374,
                "title": "pop-the-smaller",
                "content": "# Intuition\\nWhile iterating over the linked list\\nUse monotonic stack to store nodes and pop those whose `val` is less the than the currents.\\nAs the end join the nodes in the stack to create the resultant linked list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterate the linked list and add nodes in the monotonic stack after poping nodes till it\\'s empty or top value is greater than or equal to the node value. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        while(head != nullptr) {\\n            while(!st.empty() && st.top()->val < head->val)\\n                st.pop();\\n            st.push(head);\\n            head = head->next;\\n        }\\n        while(!st.empty()) {\\n            st.top()->next = head;\\n            head = st.top();\\n            st.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        while(head != nullptr) {\\n            while(!st.empty() && st.top()->val < head->val)\\n                st.pop();\\n            st.push(head);\\n            head = head->next;\\n        }\\n        while(!st.empty()) {\\n            st.top()->next = head;\\n            head = st.top();\\n            st.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870124,
                "title": "cpp-solution-using-next-greater-element-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- CPP solution solution using next greater element concept -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n) -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void tra(ListNode* h, vector<int> &v)\\n    {\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h = h->next;\\n        }\\n    }\\n    void nge(vector<int> &v, vector<int> &v1)\\n    {\\n        stack<int> s;\\n        int n = v.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!s.empty() && v[s.top()]<v[i])\\n            {\\n                v1[s.top()] = v[i];\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        vector<int> v;\\n        tra(head, v);\\n        vector<int> v1(v.size(), -1);\\n        nge(v, v1);\\n        vector<int> v2;\\n        for(int i=0; i<v.size(); i++) if(v1[i]==-1) v2.push_back(v[i]);\\n        \\n        ListNode* ans=NULL;\\n        if(v2.size()==0) return ans;\\n        \\n        \\n        ListNode* temp = new ListNode(v2[0]);\\n        ans = temp;\\n        for(int i=1; i<v2.size(); i++)\\n        {\\n            ListNode* n1 = new ListNode(v2[i]);\\n            temp->next = n1;\\n            temp = temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void tra(ListNode* h, vector<int> &v)\\n    {\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h = h->next;\\n        }\\n    }\\n    void nge(vector<int> &v, vector<int> &v1)\\n    {\\n        stack<int> s;\\n        int n = v.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            while(!s.empty() && v[s.top()]<v[i])\\n            {\\n                v1[s.top()] = v[i];\\n                s.pop();\\n            }\\n            s.push(i);\\n        }\\n    }\\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        vector<int> v;\\n        tra(head, v);\\n        vector<int> v1(v.size(), -1);\\n        nge(v, v1);\\n        vector<int> v2;\\n        for(int i=0; i<v.size(); i++) if(v1[i]==-1) v2.push_back(v[i]);\\n        \\n        ListNode* ans=NULL;\\n        if(v2.size()==0) return ans;\\n        \\n        \\n        ListNode* temp = new ListNode(v2[0]);\\n        ans = temp;\\n        for(int i=1; i<v2.size(); i++)\\n        {\\n            ListNode* n1 = new ListNode(v2[i]);\\n            temp->next = n1;\\n            temp = temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860816,
                "title": "linkedlist",
                "content": "public ListNode removeNodes(ListNode head) {\\n      if(head.next==null)return head;\\n        ListNode node=removeNodes(head.next);\\n        if(node.val>head.val)return node;\\n        head.next=node;\\n            return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public ListNode removeNodes(ListNode head) {\\n      if(head.next==null)return head;\\n        ListNode node=removeNodes(head.next);\\n        if(node.val>head.val)return node;\\n        head.next=node;\\n            return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2857808,
                "title": "java-reverse-linked-list-concept",
                "content": "First reverse the lisit so that you can traverse and remove the nodes having value less than the preceeding node. \\nThen Reverse the list once again to reach the desired conditions mentioned in the questions.\\nThere you go with the solution. \\nIt gave 100 times faster in first GO.\\n\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next==null)\\n            return head;\\n        // reverse concept\\n        head = reverse(head);\\n        ListNode temp = head;\\n        while(temp.next!=null){\\n            if(temp.val>temp.next.val){\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return reverse(head);\\n    }\\n    ListNode reverse(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            ListNode after = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = after;\\n        }\\n        head.next = null;\\n        head = prev;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next==null)\\n            return head;\\n        // reverse concept\\n        head = reverse(head);\\n        ListNode temp = head;\\n        while(temp.next!=null){\\n            if(temp.val>temp.next.val){\\n                temp.next = temp.next.next;\\n            }\\n            else\\n                temp = temp.next;\\n        }\\n        return reverse(head);\\n    }\\n    ListNode reverse(ListNode head)\\n    {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while(curr!=null){\\n            ListNode after = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = after;\\n        }\\n        head.next = null;\\n        head = prev;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856283,
                "title": "c-simple-stack-implementation-linkedlist",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*>st;\\n        ListNode* temp=head;\\n        while(temp)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(temp);\\n                head=temp;\\n            }\\n            else if(st.top()->val <temp->val)\\n            {\\n                while(!st.empty() && st.top()->val <temp->val)\\n                    st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(temp);\\n                    head=temp;\\n                }\\n                else\\n                {\\n                    st.top()->next=temp;\\n                    st.push(temp);\\n                }\\n            }\\n            else if(st.top()->val >= temp->val)\\n            {\\n                st.top()->next=temp;\\n                st.push(temp);\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*>st;\\n        ListNode* temp=head;\\n        while(temp)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(temp);\\n                head=temp;\\n            }\\n            else if(st.top()->val <temp->val)\\n            {\\n                while(!st.empty() && st.top()->val <temp->val)\\n                    st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(temp);\\n                    head=temp;\\n                }\\n                else\\n                {\\n                    st.top()->next=temp;\\n                    st.push(temp);\\n                }\\n            }\\n            else if(st.top()->val >= temp->val)\\n            {\\n                st.top()->next=temp;\\n                st.push(temp);\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855402,
                "title": "java-easy-and-faster-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverseList(head);\\n        int max=head.val;\\n        ListNode nn=new ListNode(max);\\n        ListNode h1=nn;\\n        ListNode temp=head.next;\\n        while(temp!=null){\\n            if(temp.val>=max){\\n                max=temp.val;\\n                nn.next=new ListNode(max);\\n                nn=nn.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return reverseList(h1);\\n    }\\n    \\n    //reversing the list at the beginning and in the end\\n    public ListNode reverseList(ListNode head) {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        while(cur!=null){\\n            ListNode temp=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverseList(head);\\n        int max=head.val;\\n        ListNode nn=new ListNode(max);\\n        ListNode h1=nn;\\n        ListNode temp=head.next;\\n        while(temp!=null){\\n            if(temp.val>=max){\\n                max=temp.val;\\n                nn.next=new ListNode(max);\\n                nn=nn.next;\\n            }\\n            temp=temp.next;\\n        }\\n        return reverseList(h1);\\n    }\\n    \\n    //reversing the list at the beginning and in the end\\n    public ListNode reverseList(ListNode head) {\\n        ListNode cur=head;\\n        ListNode prev=null;\\n        while(cur!=null){\\n            ListNode temp=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853975,
                "title": "c-easy-to-understand-beginner-friendly",
                "content": "Approach:- In this we have to something with preprocessing of the elements and we also know that we can iterate only in the forward direction in the linked list, so it was very clear that we have to use some extra data structure to solve the problem, So in the below problem i have used vector to store the elements of the linked list and then do processing on it.\\n\\n***Note:- It is recommended to understand the below approach with pen and paper and on different test cases***\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* tmp=head;\\n        //Using vector to store all the elements\\n        // of the linked list\\n        vector<int> ds;\\n        int len=0;\\n        //Calculating the length of the linked list\\n        //and storing elements\\n        while(tmp!=NULL){\\n            ds.push_back(tmp->val);\\n            tmp=tmp->next;\\n            len++;\\n        }\\n        //If length is 1 then nothing can be deleted so return the head\\n        if(len==1) return head;\\n        \\n        //Now reverse the vector as we want to find\\n        //the greater element going towards right, so reversing\\n        //it will help to preprocess that.\\n        reverse(ds.begin(),ds.end());\\n        int n=ds.size();\\n        \\n        //maxi vector will store the maximum till then, otherwise\\n        //if element is equal then store it\\n        vector<int> maxi;\\n        maxi.push_back(ds[0]);\\n        for(int i=1;i<ds.size();i++){\\n            if(ds[i]>maxi[maxi.size()-1]){\\n                maxi.push_back(ds[i]);\\n            }\\n            else if(ds[i]==maxi[maxi.size()-1]){\\n                maxi.push_back(ds[i]);\\n            }\\n        }\\n        n=maxi.size();\\n        //Now creating linked list only for the \\n        //elements that are greater\\n        ListNode* dummyNode=new ListNode(-1);\\n        ListNode* res=dummyNode;\\n        res->next=new ListNode(maxi[n-1]);\\n        res=res->next;\\n        //we will start from the reverse because we want the\\n        //elements from left to right and the preprocessed elements\\n        //will be from right to left\\n        for(int i=n-2;i>=0;i--){\\n            res->next=new ListNode(maxi[i]);\\n            res=res->next;\\n        }\\n        //Returning the linked list\\n        return dummyNode->next;\\n    }\\n};\\n```\\n***Pls upvote if you find this useful :)***\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* tmp=head;\\n        //Using vector to store all the elements\\n        // of the linked list\\n        vector<int> ds;\\n        int len=0;\\n        //Calculating the length of the linked list\\n        //and storing elements\\n        while(tmp!=NULL){\\n            ds.push_back(tmp->val);\\n            tmp=tmp->next;\\n            len++;\\n        }\\n        //If length is 1 then nothing can be deleted so return the head\\n        if(len==1) return head;\\n        \\n        //Now reverse the vector as we want to find\\n        //the greater element going towards right, so reversing\\n        //it will help to preprocess that.\\n        reverse(ds.begin(),ds.end());\\n        int n=ds.size();\\n        \\n        //maxi vector will store the maximum till then, otherwise\\n        //if element is equal then store it\\n        vector<int> maxi;\\n        maxi.push_back(ds[0]);\\n        for(int i=1;i<ds.size();i++){\\n            if(ds[i]>maxi[maxi.size()-1]){\\n                maxi.push_back(ds[i]);\\n            }\\n            else if(ds[i]==maxi[maxi.size()-1]){\\n                maxi.push_back(ds[i]);\\n            }\\n        }\\n        n=maxi.size();\\n        //Now creating linked list only for the \\n        //elements that are greater\\n        ListNode* dummyNode=new ListNode(-1);\\n        ListNode* res=dummyNode;\\n        res->next=new ListNode(maxi[n-1]);\\n        res=res->next;\\n        //we will start from the reverse because we want the\\n        //elements from left to right and the preprocessed elements\\n        //will be from right to left\\n        for(int i=n-2;i>=0;i--){\\n            res->next=new ListNode(maxi[i]);\\n            res=res->next;\\n        }\\n        //Returning the linked list\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853160,
                "title": "java-recursive-beats-68",
                "content": "###### *The goal is to return a linked list with non-increasing values. We are processing linked list recursively from right to left. At each step, if the value of the curr (head) node is >= to the value of the root node of the resulting linked list, we add the curr(head) node in start of the resulting linked list.*\\n\\n\\n```java []\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next==null){\\n            return head;\\n        }\\n        ListNode root = removeNodes(head.next);\\n        if(root.val<=head.val){\\n            head.next=root;\\n            root=head;\\n        }\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next==null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2852894,
                "title": "using-stack-next-greater-element-easy-understanding-for-a-noob-like-me",
                "content": "First we can find the next greater element for each node and if it does\\'nt exist we\\'ll mark it as -1.\\nThen for the nodes having a next greater element we\\'\\' will apply node deletion.\\nFind the commented code below.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n     ListNode* removeNodes(ListNode* head) {\\n         \\n        ListNode* temp= head;\\n        stack<int> st;\\n        vector<int> s;\\n        \\n\\t\\t//Pushing the node values in an array to find next greater element\\n         while(temp){\\n             s.push_back(temp->val);\\n             temp=temp->next;\\n         }\\n         \\n         //Finding the next greater element and storing it in s\\n         for(int i=s.size()-1;i>-1;--i){\\n             \\n             int te=s[i];\\n            while(st.size()>0 && st.top()<=te) st.pop();\\n             \\n             if(st.size()==0) s[i]=-1;\\n             else s[i]=st.top();\\n             \\n             st.push(te); \\n         }\\n          \\n     //new node which will be before the node to be deleted\\n        temp=new ListNode(0);\\n        temp->next= head;\\n        head=temp;\\n        int i=0;\\n         \\n        while(i<s.size()){\\n       \\n             if(s[i]!=-1){\\n                 //Since there exists a greater element, we\\'ll remove the element\\n                 temp->next= temp->next->next;\\n             }else{\\n                  //-1 means there is no greater element, Hence we\\'ll just move the pointer forward\\n                 temp = temp->next;\\n             } \\n             ++i;\\n         }\\n         \\n        \\n         return head->next;\\n    }\\n    \\n};\\n```\\nTime Complexity: ``` O(n)```\\nSpace Complexity: ```O(2*n)```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     ListNode* removeNodes(ListNode* head) {\\n         \\n        ListNode* temp= head;\\n        stack<int> st;\\n        vector<int> s;\\n        \\n\\t\\t//Pushing the node values in an array to find next greater element\\n         while(temp){\\n             s.push_back(temp->val);\\n             temp=temp->next;\\n         }\\n         \\n         //Finding the next greater element and storing it in s\\n         for(int i=s.size()-1;i>-1;--i){\\n             \\n             int te=s[i];\\n            while(st.size()>0 && st.top()<=te) st.pop();\\n             \\n             if(st.size()==0) s[i]=-1;\\n             else s[i]=st.top();\\n             \\n             st.push(te); \\n         }\\n          \\n     //new node which will be before the node to be deleted\\n        temp=new ListNode(0);\\n        temp->next= head;\\n        head=temp;\\n        int i=0;\\n         \\n        while(i<s.size()){\\n       \\n             if(s[i]!=-1){\\n                 //Since there exists a greater element, we\\'ll remove the element\\n                 temp->next= temp->next->next;\\n             }else{\\n                  //-1 means there is no greater element, Hence we\\'ll just move the pointer forward\\n                 temp = temp->next;\\n             } \\n             ++i;\\n         }\\n         \\n        \\n         return head->next;\\n    }\\n    \\n};\\n```\n``` O(n)```\n```O(2*n)```",
                "codeTag": "Java"
            },
            {
                "id": 2852572,
                "title": "clean-simple-and-elegant",
                "content": "# Intuition\\nI observed that the output will be a Linked List that\\'s sorted in decreasing order. I also observed that the last node will always be present inside the linked list, as there is no element greater than it towards its right.\\n\\n# Approach\\nRecursively reach the last node, set it as head. Then traverse backwards while returning back from your recursive calls. Compare previous node(curr) with our new head. If previous node (curr)\\'s value is lesser than head, remove it, else make it the new head.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void helper(ListNode* prev, ListNode* curr, ListNode* &head){\\n        if(!curr->next){\\n            head = curr;\\n            return;\\n        }\\n        \\n        helper(curr, curr->next, head);\\n        \\n        if(curr->val < head->val){\\n            if(prev) prev->next = curr->next;\\n            curr->next = nullptr;\\n        }\\n        else{\\n            head = curr;\\n        }\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        helper(prev, curr, head);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void helper(ListNode* prev, ListNode* curr, ListNode* &head){\\n        if(!curr->next){\\n            head = curr;\\n            return;\\n        }\\n        \\n        helper(curr, curr->next, head);\\n        \\n        if(curr->val < head->val){\\n            if(prev) prev->next = curr->next;\\n            curr->next = nullptr;\\n        }\\n        else{\\n            head = curr;\\n        }\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        helper(prev, curr, head);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852305,
                "title": "java-simple-and-easy-iterative",
                "content": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n       ListNode resHead = head;\\n        ListNode cur = head.next;\\n        int last = resHead.val;\\n        while (cur != null) {\\n            if (last >= cur.val) {\\n                last = cur.val;\\n                cur = cur.next;\\n                continue;\\n            }\\n            if (cur.val > resHead.val)\\n                resHead = cur;\\n            else {\\n                ListNode res = resHead;\\n                while (res != null && res.next.val >= cur.val)\\n                    res = res.next;\\n\\n                res.next = cur;\\n                res = res.next;\\n            }\\n            last = cur.val;\\n            cur = cur.next;\\n        }\\n        return resHead; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n       ListNode resHead = head;\\n        ListNode cur = head.next;\\n        int last = resHead.val;\\n        while (cur != null) {\\n            if (last >= cur.val) {\\n                last = cur.val;\\n                cur = cur.next;\\n                continue;\\n            }\\n            if (cur.val > resHead.val)\\n                resHead = cur;\\n            else {\\n                ListNode res = resHead;\\n                while (res != null && res.next.val >= cur.val)\\n                    res = res.next;\\n\\n                res.next = cur;\\n                res = res.next;\\n            }\\n            last = cur.val;\\n            cur = cur.next;\\n        }\\n        return resHead; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852176,
                "title": "easy-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS | Inplace Modification\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def dfs(pre):\\n            cur = pre.next\\n            if not cur.next:\\n                return cur.val\\n            cur_max = dfs(cur) \\n            if cur_max > cur.val:\\n                pre.next = cur.next\\n            return max(cur_max, cur.val)\\n        new_head = ListNode()\\n        new_head.next = head\\n        dfs(new_head)\\n        return new_head.next\\n                \\n        \\n ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def dfs(pre):\\n            cur = pre.next\\n            if not cur.next:\\n                return cur.val\\n            cur_max = dfs(cur) \\n            if cur_max > cur.val:\\n                pre.next = cur.next\\n            return max(cur_max, cur.val)\\n        new_head = ListNode()\\n        new_head.next = head\\n        dfs(new_head)\\n        return new_head.next\\n                \\n        \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2852094,
                "title": "python-stack-approach-o-n-time-and-space",
                "content": "# Approach\\nStack approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        stack = []\\n        dummy = headNew = ListNode(None, head)\\n        curr = head\\n        while curr:\\n            while stack and stack[-1].val < curr.val:\\n                stack.pop()\\n            stack.append(curr)\\n            curr = curr.next\\n            \\n        for node in stack:\\n            headNew.next = node\\n            headNew = headNew.next\\n            \\n        return dummy.next\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        stack = []\\n        dummy = headNew = ListNode(None, head)\\n        curr = head\\n        while curr:\\n            while stack and stack[-1].val < curr.val:\\n                stack.pop()\\n            stack.append(curr)\\n            curr = curr.next\\n            \\n        for node in stack:\\n            headNew.next = node\\n            headNew = headNew.next\\n            \\n        return dummy.next\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852031,
                "title": "monotonic-stack-single-traversal-with-best-solution",
                "content": "```\\n // We are using Stack to store the nodes in increasing order and at every step we just removing the nodes which are smaller than the current node\\n//         this concept is of stack question increasing element on right in array\\n        Stack<ListNode>st=new Stack<>();\\n        if(head==null || head.next==null)return head;\\n        ListNode temp=new ListNode(Integer.MAX_VALUE),i=head;\\n        st.push(temp);\\n        while(i!=null){\\n            while(st.peek().val<i.val)st.pop();\\n            st.peek().next=i;\\n            st.push(i);\\n            i=i.next;\\n        }\\n        return temp.next;",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n // We are using Stack to store the nodes in increasing order and at every step we just removing the nodes which are smaller than the current node\\n//         this concept is of stack question increasing element on right in array\\n        Stack<ListNode>st=new Stack<>();\\n        if(head==null || head.next==null)return head;\\n        ListNode temp=new ListNode(Integer.MAX_VALUE),i=head;\\n        st.push(temp);\\n        while(i!=null){\\n            while(st.peek().val<i.val)st.pop();\\n            st.peek().next=i;\\n            st.push(i);\\n            i=i.next;\\n        }\\n        return temp.next;",
                "codeTag": "Unknown"
            },
            {
                "id": 2852019,
                "title": "easy-monotonic-stack-o-n-solution",
                "content": "```java\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> s = new Stack<>();\\n        ListNode node = head;\\n        while (node != null) {\\n            while (!s.isEmpty() && s.peek() < node.val) {\\n                s.pop();\\n            } \\n            s.push(node.val);\\n            node = node.next;\\n        }\\n        \\n        ListNode ans = new ListNode();\\n        ListNode temp = ans;\\n        for (int n : s) {\\n            temp.next = new ListNode(n);\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> s = new Stack<>();\\n        ListNode node = head;\\n        while (node != null) {\\n            while (!s.isEmpty() && s.peek() < node.val) {\\n                s.pop();\\n            } \\n            s.push(node.val);\\n            node = node.next;\\n        }\\n        \\n        ListNode ans = new ListNode();\\n        ListNode temp = ans;\\n        for (int n : s) {\\n            temp.next = new ListNode(n);\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852003,
                "title": "java-5-lines-easy-solution",
                "content": "```\\npublic ListNode removeNodes(ListNode head) {\\n        if(head.next==null && head.next==null) return head;\\n        ListNode node=removeNodes(head.next);\\n        if(node.val>head.val) return node;\\n        head.next=node;\\n        return head;\\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\npublic ListNode removeNodes(ListNode head) {\\n        if(head.next==null && head.next==null) return head;\\n        ListNode node=removeNodes(head.next);\\n        if(node.val>head.val) return node;\\n        head.next=node;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2852001,
                "title": "c-stacks-linked-list-easy-understanding",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\t/**\\n\\t * Definition for singly-linked list.\\n\\t * struct ListNode {\\n\\t *     int val;\\n\\t *     ListNode *next;\\n\\t *     ListNode() : val(0), next(nullptr) {}\\n\\t *     ListNode(int x) : val(x), next(nullptr) {}\\n\\t *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid insert(ListNode** root, int item)\\n\\t\\t{\\n\\t\\t\\tListNode* temp = new ListNode;\\n\\t\\t\\ttemp->val= item;\\n\\t\\t\\ttemp->next = *root;\\n\\t\\t\\t*root = temp;\\n\\t\\t}\\n\\t\\tListNode* removeNodes(ListNode* head) {\\n\\t\\t\\tListNode* rt=head;\\n\\t\\t\\tstack<int>s;\\n\\t\\t\\twhile(rt){\\n\\t\\t\\t\\tif(s.empty()){\\n\\t\\t\\t\\t\\ts.push(rt->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(!s.empty() && s.top()<rt->val){\\n\\t\\t\\t\\t\\t\\twhile(!s.empty() && s.top()<rt->val){\\n\\t\\t\\t\\t\\t\\t\\ts.pop();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts.push(rt->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trt=rt->next;\\n\\t\\t\\t}\\n\\t\\t\\tListNode *root = NULL;\\n\\t\\t\\twhile(!s.empty()){\\n\\t\\t\\t\\tinsert(&root, s.top());\\n\\t\\t\\t\\ts.pop();\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid insert(ListNode** root, int item)\\n\\t\\t{\\n\\t\\t\\tListNode* temp = new ListNode;\\n\\t\\t\\ttemp->val= item;\\n\\t\\t\\ttemp->next = *root;\\n\\t\\t\\t*root = temp;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2851990,
                "title": "scala-mono-stack-functional-programming",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\\n *   var next: ListNode = _next\\n *   var x: Int = _x\\n * }\\n */\\nobject Solution {\\n    def removeNodes(head: ListNode): ListNode = {\\n        def helper(list: ListNode, stack: List[Int]): List[Int] = list match {\\n            case null => stack\\n            case node => {\\n                val (left, right) = stack.span(_ < node.x)\\n                helper(node.next, (node.x)::right)\\n            }\\n        }\\n        \\n        helper(head, List[Int]()).foldLeft(null.asInstanceOf[ListNode])((h, n) => new ListNode(n, h))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * class ListNode(_x: Int = 0, _next: ListNode = null) {\\n *   var next: ListNode = _next\\n *   var x: Int = _x\\n * }\\n */\\nobject Solution {\\n    def removeNodes(head: ListNode): ListNode = {\\n        def helper(list: ListNode, stack: List[Int]): List[Int] = list match {\\n            case null => stack\\n            case node => {\\n                val (left, right) = stack.span(_ < node.x)\\n                helper(node.next, (node.x)::right)\\n            }\\n        }\\n        \\n        helper(head, List[Int]()).foldLeft(null.asInstanceOf[ListNode])((h, n) => new ListNode(n, h))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851981,
                "title": "easy-recursive-approach-with-o-1-extra-space-stack-approach",
                "content": "```\\nclass Solution {\\n    int greatestSoFar;\\n    public ListNode removeNodes(ListNode head) {\\n        greatestSoFar = 0;\\n        return recur(head);\\n    }\\n    \\n    private ListNode recur(ListNode head){\\n        if(head == null){\\n            return null;\\n        }\\n        head.next = recur(head.next);\\n        if(head.val < greatestSoFar){\\n            greatestSoFar = Math.max(greatestSoFar, head.val);\\n            return head.next;\\n        }else{\\n            greatestSoFar = Math.max(greatestSoFar, head.val);\\n            return head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int greatestSoFar;\\n    public ListNode removeNodes(ListNode head) {\\n        greatestSoFar = 0;\\n        return recur(head);\\n    }\\n    \\n    private ListNode recur(ListNode head){\\n        if(head == null){\\n            return null;\\n        }\\n        head.next = recur(head.next);\\n        if(head.val < greatestSoFar){\\n            greatestSoFar = Math.max(greatestSoFar, head.val);\\n            return head.next;\\n        }else{\\n            greatestSoFar = Math.max(greatestSoFar, head.val);\\n            return head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047376,
                "title": "easy-java-c-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition \\nReversing list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReverse list to do all operations and return after reversing it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode reverseList(ListNode head) {\\n        ListNode current=null;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=current;\\n            current=head;\\n            head=next;\\n        }\\n        return current;\\n    }\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverseList(head);\\n        ListNode temp=head;\\n        int maxi=temp.val;\\n        while(temp.next!=null){\\n            if(maxi>temp.next.val){\\n                ListNode ptr=temp.next;\\n                temp.next=ptr.next;\\n            }\\n            else{\\n                maxi=temp.next.val;\\n                temp=temp.next;\\n            }\\n        }\\n        head=reverseList(head);\\n\\n        return head;\\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* current=NULL;\\n        while(head!=NULL){\\n            ListNode* next=head->next;\\n            head->next=current;\\n            current=head;\\n            head=next;\\n        }\\n        return current;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        head=reverseList(head);\\n        ListNode* temp=head;\\n        int maxi=temp->val;\\n        while(temp->next){\\n            if(maxi>temp->next->val){\\n                ListNode* ptr=temp->next;\\n                temp->next=ptr->next;\\n            }\\n            else{\\n                maxi=temp->next->val;\\n                temp=temp->next;\\n            }\\n        }\\n        head=reverseList(head);\\n\\n        return head;\\n    }\\n};\\n```\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode reverseList(ListNode head) {\\n        ListNode current=null;\\n        while(head!=null){\\n            ListNode next=head.next;\\n            head.next=current;\\n            current=head;\\n            head=next;\\n        }\\n        return current;\\n    }\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverseList(head);\\n        ListNode temp=head;\\n        int maxi=temp.val;\\n        while(temp.next!=null){\\n            if(maxi>temp.next.val){\\n                ListNode ptr=temp.next;\\n                temp.next=ptr.next;\\n            }\\n            else{\\n                maxi=temp.next.val;\\n                temp=temp.next;\\n            }\\n        }\\n        head=reverseList(head);\\n\\n        return head;\\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* current=NULL;\\n        while(head!=NULL){\\n            ListNode* next=head->next;\\n            head->next=current;\\n            current=head;\\n            head=next;\\n        }\\n        return current;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        head=reverseList(head);\\n        ListNode* temp=head;\\n        int maxi=temp->val;\\n        while(temp->next){\\n            if(maxi>temp->next->val){\\n                ListNode* ptr=temp->next;\\n                temp->next=ptr->next;\\n            }\\n            else{\\n                maxi=temp->next->val;\\n                temp=temp->next;\\n            }\\n        }\\n        head=reverseList(head);\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983946,
                "title": "java-solution-using-stack-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> stack = new Stack();\\n        ListNode rev = reverse(head);\\n        while(rev != null) {\\n            if(stack.isEmpty() || (!stack.isEmpty() && rev.val >= stack.peek())) {\\n                stack.push(rev.val);\\n            }\\n            rev = rev.next;\\n        }\\n        ListNode res = new ListNode();\\n        ListNode r = res;\\n        while(!stack.isEmpty()) {\\n            r.next = new ListNode(stack.pop());\\n            r = r.next;\\n        }\\n        return res.next;\\n    }\\n\\n    ListNode reverse(ListNode head) {\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack",
                    "Recursion",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> stack = new Stack();\\n        ListNode rev = reverse(head);\\n        while(rev != null) {\\n            if(stack.isEmpty() || (!stack.isEmpty() && rev.val >= stack.peek())) {\\n                stack.push(rev.val);\\n            }\\n            rev = rev.next;\\n        }\\n        ListNode res = new ListNode();\\n        ListNode r = res;\\n        while(!stack.isEmpty()) {\\n            r.next = new ListNode(stack.pop());\\n            r = r.next;\\n        }\\n        return res.next;\\n    }\\n\\n    ListNode reverse(ListNode head) {\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next;\\n        while(curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909688,
                "title": "faster-than-99-15-reverse-twice-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*nxt=NULL;\\n        while(head){\\n            nxt=head->next;\\n            head->next=prev;\\n            prev=head;\\n            head=nxt;\\n        }return prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverse(head);int x=head->val;\\n        ListNode* tmp=new ListNode(0),*prev=tmp;\\n        while(head!=NULL){\\n            while(head!=NULL && head->val<x){head=head->next;}\\n            if(head==NULL){tmp->next=NULL;break;}\\n            x=head->val;\\n            tmp->next=head;tmp=tmp->next;head=head->next;\\n        }\\n        return reverse(prev->next);}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    ListNode* reverse(ListNode* head){\\n        ListNode* prev=NULL,*nxt=NULL;\\n        while(head){\\n            nxt=head->next;\\n            head->next=prev;\\n            prev=head;\\n            head=nxt;\\n        }return prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverse(head);int x=head->val;\\n        ListNode* tmp=new ListNode(0),*prev=tmp;\\n        while(head!=NULL){\\n            while(head!=NULL && head->val<x){head=head->next;}\\n            if(head==NULL){tmp->next=NULL;break;}\\n            x=head->val;\\n            tmp->next=head;tmp=tmp->next;head=head->next;\\n        }\\n        return reverse(prev->next);}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850555,
                "title": "go-multiple-clean-solutions-in-go-golang-with-images-170ms-100",
                "content": "Hello Gophers!\\n\\n![atemp1.png](https://assets.leetcode.com/users/images/d15c6ca4-f3be-4887-8831-85ce94fac473_1690859698.3274145.png)\\n\\n1. Solution 1: Stack (`O(n)` space complexity)\\n2. Solution 2: Two Pointers  (`O(1)` space complexity)\\n3. Solution 3: Recursion  (`O(n)` space complexity)\\n\\nThey all have `O(n)` time complexity.  \\nSolution 2 is the best (fastest and least space).\\n\\n# Solution 1: Stack\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\nFor a better space complexity, see [Solution 2](#solution-2)\\n\\n```go\\n// Time: O(n) + O(n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc removeNodes(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Space: O(n)\\n    var stack []*ListNode\\n    var current = head\\n\\n    // Time: O(n)\\n    for current != nil {\\n        for len(stack) > 0 && current.Val > stack[len(stack)-1].Val {\\n            stack = stack[:len(stack)-1]\\n        }\\n\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    var newHead *ListNode\\n\\n    // Time: O(n/x) = O(n)\\n    for i := len(stack) - 1; i >= 0; i-- {\\n        stack[i].Next = newHead\\n        newHead = stack[i]\\n    }\\n\\n    return newHead\\n}\\n```\\n\\nWith a custom data structure (same complexity):\\n\\n```go\\nfunc removeNodes(head *ListNode) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tstack := NewStack()\\n\\tcurrent := head\\n\\n\\tfor current != nil {\\n\\t\\tfor !stack.IsEmpty() && current.Val > stack.listNodes[stack.Size()-1].Val {\\n\\t\\t\\tstack.Pop()\\n\\t\\t}\\n\\n\\t\\tstack.Push(current)\\n\\t\\tcurrent = current.Next\\n\\t}\\n\\n\\tvar newHead *ListNode\\n\\tfor !stack.IsEmpty() {\\n\\t\\tstack.listNodes[stack.Size()-1].Next = newHead\\n\\t\\tnewHead = stack.Pop()\\n\\t}\\n\\n\\treturn newHead\\n}\\n\\ntype Stack struct {\\n\\tlistNodes []*ListNode\\n}\\n\\nfunc NewStack() *Stack {\\n\\treturn &Stack{}\\n}\\n\\nfunc (s *Stack) Push(node *ListNode) {\\n\\ts.listNodes = append(s.listNodes, node)\\n}\\n\\nfunc (s *Stack) Pop() *ListNode {\\n\\tif s.IsEmpty() {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tindex := len(s.listNodes) - 1\\n\\tnode := s.listNodes[index]\\n\\ts.listNodes = s.listNodes[:index]\\n\\treturn node\\n}\\n\\nfunc (s *Stack) IsEmpty() bool {\\n\\treturn len(s.listNodes) == 0\\n}\\n\\nfunc (s *Stack) Size() int {\\n\\treturn len(s.listNodes)\\n}\\n```\\n\\n# Solution 2: Two Pointers\\n\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n## Code\\n\\n```go\\n// Time: O(n) + O(n) + O(n) = O(3n) = O(n)\\n// Space: O(1)\\nfunc removeNodes(head *ListNode) *ListNode {\\n    // Time: O(n)\\n    head = reverse(head)\\n\\n    currMax := 0\\n\\n    // Time: O(n)\\n    var prev, curr *ListNode = nil, head\\n    for curr != nil {\\n        if curr.Val < currMax {\\n            if prev != nil {\\n               prev.Next = curr.Next\\n            }\\n        } else {\\n            prev = curr\\n            currMax = curr.Val\\n        }\\n        curr = curr.Next\\n    }\\n\\n    // Time: O(n)\\n    return reverse(head)\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc reverse(head *ListNode) *ListNode {\\n    var prev, curr *ListNode = nil, head\\n    for curr != nil {\\n        prev, curr, curr.Next = curr, curr.Next, prev\\n    }\\n    return prev\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```\\n\\n## Explanation\\n\\nLet\\'s say we have this linked list:\\n\\n![atemp2.png](https://assets.leetcode.com/users/images/633458ec-014a-4bc8-8b47-9b427dd06d04_1690859734.7275305.png)\\n\\nWe want to reverse it (time: `O(n)`):\\n\\n![atemp3.png](https://assets.leetcode.com/users/images/a4ad38f0-a069-43f7-822a-c5825fc6935d_1690859762.9758904.png)\\n\\nAnd we use two pointers to iterate on it. If the current node (`curr`) value (`curr.Val`) is bigger than the \"current maximum (`currMax`), we change this \"current maximum\" and if it\\'s not, we \"remove it\" by pointing the next \"last/previous node that we wanted to keep\" (`prev`) to the current next:\\n\\n![atemp4.png](https://assets.leetcode.com/users/images/dc31ad50-2aac-411a-b25a-6129075762fa_1690859897.3057694.png)\\n\\n![atemp5.png](https://assets.leetcode.com/users/images/e0f38d50-6c0f-4bb2-a11e-8b60721f61ee_1690859906.3919477.png)\\n\\n![atemp6.png](https://assets.leetcode.com/users/images/81d2244e-ff4f-434b-87bd-8bec527a71b4_1690859913.6157868.png)\\n\\n![atemp7.png](https://assets.leetcode.com/users/images/206fd16f-366a-431e-8164-7361880b6e22_1690859923.5896885.png)\\n\\n![atemp8.png](https://assets.leetcode.com/users/images/ed116217-5f34-4552-91fd-d8e06bdee845_1690859935.3285203.png)\\n\\n![atemp9.png](https://assets.leetcode.com/users/images/c1a010b1-3c1d-4533-90f4-735e600c92e5_1690859942.7719297.png)\\n\\n![atemp10.png](https://assets.leetcode.com/users/images/b6996e5b-3ecc-461c-a2c9-e1e047175168_1690859957.3825395.png)\\n\\nThis iteration also take us `O(n)` in time complexity.\\n\\nTHis gives us our final linked list:\\n\\n![atemp11.png](https://assets.leetcode.com/users/images/5c17a34c-c285-4c33-9834-6d731ede69fd_1690859971.8801754.png)\\n\\nThat we reverse a last time (`O(n)`):\\n\\n![atemp12.png](https://assets.leetcode.com/users/images/88be098a-6f61-4ff3-b5ba-4448d778bcd6_1690860031.6109622.png)\\n\\n# Solution 3: Recursion\\n\\nTime: `O(n)`\\nSpace: `O(n)` (recursion call stack)\\n\\n```go\\nfunc removeNodes(head *ListNode) *ListNode {\\n    if head.Next == nil {\\n        return head\\n    }\\n\\n    head.Next = removeNodes(head.Next)\\n    if head.Val < head.Next.Val {\\n        return head.Next\\n    }\\n    \\n    return head\\n}\\n```\\n\\nI hope it helped! =)\\n\\n## Note\\n\\nIn the problem description:\\n\\n> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\\n\\n[1,1,1,1] returns [1,1,1,1], but shouldnt it return [1] because 1 is not strictly greater than 1 ???\\n\\nIf I\\'m right, simply change `if curr.Val < currMax` to `if curr.Val <= currMax`",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```go\\n// Time: O(n) + O(n) = O(2n) = O(n)\\n// Space: O(n)\\nfunc removeNodes(head *ListNode) *ListNode {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Space: O(n)\\n    var stack []*ListNode\\n    var current = head\\n\\n    // Time: O(n)\\n    for current != nil {\\n        for len(stack) > 0 && current.Val > stack[len(stack)-1].Val {\\n            stack = stack[:len(stack)-1]\\n        }\\n\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    var newHead *ListNode\\n\\n    // Time: O(n/x) = O(n)\\n    for i := len(stack) - 1; i >= 0; i-- {\\n        stack[i].Next = newHead\\n        newHead = stack[i]\\n    }\\n\\n    return newHead\\n}\\n```\n```go\\nfunc removeNodes(head *ListNode) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tstack := NewStack()\\n\\tcurrent := head\\n\\n\\tfor current != nil {\\n\\t\\tfor !stack.IsEmpty() && current.Val > stack.listNodes[stack.Size()-1].Val {\\n\\t\\t\\tstack.Pop()\\n\\t\\t}\\n\\n\\t\\tstack.Push(current)\\n\\t\\tcurrent = current.Next\\n\\t}\\n\\n\\tvar newHead *ListNode\\n\\tfor !stack.IsEmpty() {\\n\\t\\tstack.listNodes[stack.Size()-1].Next = newHead\\n\\t\\tnewHead = stack.Pop()\\n\\t}\\n\\n\\treturn newHead\\n}\\n\\ntype Stack struct {\\n\\tlistNodes []*ListNode\\n}\\n\\nfunc NewStack() *Stack {\\n\\treturn &Stack{}\\n}\\n\\nfunc (s *Stack) Push(node *ListNode) {\\n\\ts.listNodes = append(s.listNodes, node)\\n}\\n\\nfunc (s *Stack) Pop() *ListNode {\\n\\tif s.IsEmpty() {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tindex := len(s.listNodes) - 1\\n\\tnode := s.listNodes[index]\\n\\ts.listNodes = s.listNodes[:index]\\n\\treturn node\\n}\\n\\nfunc (s *Stack) IsEmpty() bool {\\n\\treturn len(s.listNodes) == 0\\n}\\n\\nfunc (s *Stack) Size() int {\\n\\treturn len(s.listNodes)\\n}\\n```\n```go\\n// Time: O(n) + O(n) + O(n) = O(3n) = O(n)\\n// Space: O(1)\\nfunc removeNodes(head *ListNode) *ListNode {\\n    // Time: O(n)\\n    head = reverse(head)\\n\\n    currMax := 0\\n\\n    // Time: O(n)\\n    var prev, curr *ListNode = nil, head\\n    for curr != nil {\\n        if curr.Val < currMax {\\n            if prev != nil {\\n               prev.Next = curr.Next\\n            }\\n        } else {\\n            prev = curr\\n            currMax = curr.Val\\n        }\\n        curr = curr.Next\\n    }\\n\\n    // Time: O(n)\\n    return reverse(head)\\n}\\n\\n// Time: O(n)\\n// Space: O(1)\\nfunc reverse(head *ListNode) *ListNode {\\n    var prev, curr *ListNode = nil, head\\n    for curr != nil {\\n        prev, curr, curr.Next = curr, curr.Next, prev\\n    }\\n    return prev\\n}\\n\\n// Time: O(1)\\n// Space: O(1)\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```\n```go\\nfunc removeNodes(head *ListNode) *ListNode {\\n    if head.Next == nil {\\n        return head\\n    }\\n\\n    head.Next = removeNodes(head.Next)\\n    if head.Val < head.Next.Val {\\n        return head.Next\\n    }\\n    \\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767021,
                "title": "c-java-easy-to-understand-with-intuition-approach-intution",
                "content": "**Intuition:**\\n\\n```\\n-> We are given a singly-linked list.\\n-> We need to remove nodes from the list that have a value smaller than any of the previous nodes so what comes to mind?  \\nwe can store the maximum value till now and then compare but this is not array like we could get the last element index \\nso instead what we can do is we can just reverse it and then perform the required operations on our LL.\\n```\\n\\n**Approach:**\\n\\n```\\n-> Reverse the linked list to simplify the removal process.\\n-> Traverse the reversed list and keep track of the maximum value encountered so far.\\n-> If a node\\'s value is smaller than the maximum value, remove the node from the list by updating the next pointer of the previous node.\\n-> If a node\\'s value is greater than or equal to the maximum value, update the maximum value and move to the next node.\\n-> After traversing the list, reverse it again to restore the original order.\\n-> Return the modified list.\\n-> By reversing the list and then traversing it, we can easily remove the nodes \\nthat don\\'t meet the required condition, and then restore the original order of the list\\n```\\n\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* prev = nullptr;\\n        \\n        while (head) {\\n            ListNode* curr = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = curr;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* removeNodes(ListNode* head) {\\n        // Reverse the linked list\\n        head = reverse(head);\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        \\n        int maxi = INT_MIN; \\n        // Initialize the maximum value\\n        \\n        while (temp) {\\n            if (temp->val < maxi) {\\n                // Remove the node\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            } else {\\n                // Update the maximum value and move to the next node\\n                maxi = max(maxi, temp->val);\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        // Reverse the linked list again to restore the original order\\n        head = reverse(head);\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\n```\\nclass Solution {\\n    // Function to reverse a linked list\\n    public ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null) {\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    public ListNode removeNodes(ListNode head) {\\n        // Reverse the linked list\\n        head = reverse(head);\\n        \\n        ListNode temp = head;\\n        ListNode prev = head;\\n        \\n        int maxi = Integer.MIN_VALUE; // Initialize the maximum value\\n        \\n        while (temp != null) {\\n            if (temp.val < maxi) {\\n                // Remove the node\\n                prev.next = temp.next;\\n                temp = temp.next;\\n            } else {\\n                // Update the maximum value and move to the next node\\n                maxi = Math.max(maxi, temp.val);\\n                prev = temp;\\n                temp = temp.next;\\n            }\\n        }\\n        \\n        // Reverse the linked list again to restore the original order\\n        head = reverse(head);\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n\\n\\n**Oh, you don\\'t like my solution? Well, the angry cat does** \\n\\n**Angry cat says: UPVOTE this SOLUTION or face my WRATH! \\uD83D\\uDC3E\\uD83D\\uDC3E\\uD83D\\uDE3E!**\\n\\n\\n![image](https://assets.leetcode.com/users/images/93b8d272-5151-42a3-a022-085606b3d570_1689832903.890941.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n-> We are given a singly-linked list.\\n-> We need to remove nodes from the list that have a value smaller than any of the previous nodes so what comes to mind?  \\nwe can store the maximum value till now and then compare but this is not array like we could get the last element index \\nso instead what we can do is we can just reverse it and then perform the required operations on our LL.\\n```\n```\\n-> Reverse the linked list to simplify the removal process.\\n-> Traverse the reversed list and keep track of the maximum value encountered so far.\\n-> If a node\\'s value is smaller than the maximum value, remove the node from the list by updating the next pointer of the previous node.\\n-> If a node\\'s value is greater than or equal to the maximum value, update the maximum value and move to the next node.\\n-> After traversing the list, reverse it again to restore the original order.\\n-> Return the modified list.\\n-> By reversing the list and then traversing it, we can easily remove the nodes \\nthat don\\'t meet the required condition, and then restore the original order of the list\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // Function to reverse a linked list\\n    ListNode* reverse(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* prev = nullptr;\\n        \\n        while (head) {\\n            ListNode* curr = head->next;\\n            head->next = prev;\\n            prev = head;\\n            head = curr;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* removeNodes(ListNode* head) {\\n        // Reverse the linked list\\n        head = reverse(head);\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = head;\\n        \\n        int maxi = INT_MIN; \\n        // Initialize the maximum value\\n        \\n        while (temp) {\\n            if (temp->val < maxi) {\\n                // Remove the node\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            } else {\\n                // Update the maximum value and move to the next node\\n                maxi = max(maxi, temp->val);\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        // Reverse the linked list again to restore the original order\\n        head = reverse(head);\\n        \\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    // Function to reverse a linked list\\n    public ListNode reverse(ListNode head) {\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null) {\\n            ListNode nextNode = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    public ListNode removeNodes(ListNode head) {\\n        // Reverse the linked list\\n        head = reverse(head);\\n        \\n        ListNode temp = head;\\n        ListNode prev = head;\\n        \\n        int maxi = Integer.MIN_VALUE; // Initialize the maximum value\\n        \\n        while (temp != null) {\\n            if (temp.val < maxi) {\\n                // Remove the node\\n                prev.next = temp.next;\\n                temp = temp.next;\\n            } else {\\n                // Update the maximum value and move to the next node\\n                maxi = Math.max(maxi, temp.val);\\n                prev = temp;\\n                temp = temp.next;\\n            }\\n        }\\n        \\n        // Reverse the linked list again to restore the original order\\n        head = reverse(head);\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746945,
                "title": "simple-c-solution-o-n-easiest-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNode(ListNode* head){\\n        ListNode* cur = head;\\n        ListNode* prev = NULL;\\n        int mx = INT_MIN;\\n        \\n        while(cur!=NULL){\\n            // store the maximum value till now\\n            mx = max(mx,cur->val);\\n            int cur_val = cur->val;\\n            // deleting the node\\n            if(cur_val<mx){\\n                // not moving prev pointer further because there\\n                // might be chance that next value is smaller than\\n                // maximum value\\n                prev->next = cur->next;\\n            }\\n            else{\\n                // cur_val is greater than or equal which satisfies \\n                // given condition so we are moving prev pointer\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n    // reversing the list\\n    ListNode* reverseList(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur!=NULL){\\n            ListNode* forward = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* ptr = head;\\n        // step 1 - reverse the list makes easy to compare the right element\\n        // step 2 - remove the node which is greater\\n        // step 3 - after removing the nodes reverse it again\\n        // to obtain the original list\\n        return reverseList(removeNode(reverseList(ptr)));\\n    }\\n};\\n```\\n## Please upvote if you like the solution\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNode(ListNode* head){\\n        ListNode* cur = head;\\n        ListNode* prev = NULL;\\n        int mx = INT_MIN;\\n        \\n        while(cur!=NULL){\\n            // store the maximum value till now\\n            mx = max(mx,cur->val);\\n            int cur_val = cur->val;\\n            // deleting the node\\n            if(cur_val<mx){\\n                // not moving prev pointer further because there\\n                // might be chance that next value is smaller than\\n                // maximum value\\n                prev->next = cur->next;\\n            }\\n            else{\\n                // cur_val is greater than or equal which satisfies \\n                // given condition so we are moving prev pointer\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n    // reversing the list\\n    ListNode* reverseList(ListNode* head){\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        while(cur!=NULL){\\n            ListNode* forward = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = forward;\\n        }\\n        return prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* ptr = head;\\n        // step 1 - reverse the list makes easy to compare the right element\\n        // step 2 - remove the node which is greater\\n        // step 3 - after removing the nodes reverse it again\\n        // to obtain the original list\\n        return reverseList(removeNode(reverseList(ptr)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718195,
                "title": "explained-solution-using-stack",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we have to remove the min nodes occuring before node having greater value.\\n\\n1. First reverse the list.\\nAfter above step we can only keep gretaer elements i.e. push the head value in stack and compare the next nodes value with top of stack by pushing the node value in stack which is greater than top and do nothing for smaller values. \\n\\n2. Repeat above step untill list ends.\\n\\n# **Here LIFO property of stack comes in use as we reversed the list so answer will be reversed so using stack we need not to worry about this.**\\n\\n3. Now we remove the top element from stack and make it a head of our answer. Now untill stacks gets empty keep making new node from popped value and connect them with previous node.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next == null) return head;\\n\\n        head = reverseList(head);\\n        ListNode currNode = head.next;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(head.val);\\n\\n        while(currNode != null){\\n            if(st.peek() <= currNode.val){\\n                st.push(currNode.val);\\n            }\\n            currNode = currNode.next;\\n        }\\n\\n        head = new ListNode(st.pop());\\n        currNode = head;\\n\\n        while(!st.isEmpty()){\\n            ListNode newNode = new ListNode(st.pop());\\n            currNode.next = newNode;\\n            currNode = newNode;\\n        }\\n\\n        return head;\\n\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prevNode = null;\\n        ListNode currNode = head;\\n        ListNode nextNode = null;\\n        \\n        while(currNode != null){\\n            nextNode = currNode.next;\\n            currNode.next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n        }\\n        return prevNode;\\n    }\\n}\\n```\\n\\n# **Please Upvote**",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head.next == null) return head;\\n\\n        head = reverseList(head);\\n        ListNode currNode = head.next;\\n        Stack<Integer> st = new Stack<>();\\n        st.push(head.val);\\n\\n        while(currNode != null){\\n            if(st.peek() <= currNode.val){\\n                st.push(currNode.val);\\n            }\\n            currNode = currNode.next;\\n        }\\n\\n        head = new ListNode(st.pop());\\n        currNode = head;\\n\\n        while(!st.isEmpty()){\\n            ListNode newNode = new ListNode(st.pop());\\n            currNode.next = newNode;\\n            currNode = newNode;\\n        }\\n\\n        return head;\\n\\n    }\\n\\n    private ListNode reverseList(ListNode head) {\\n        ListNode prevNode = null;\\n        ListNode currNode = head;\\n        ListNode nextNode = null;\\n        \\n        while(currNode != null){\\n            nextNode = currNode.next;\\n            currNode.next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n        }\\n        return prevNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670527,
                "title": "easy-c-using-deque-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        deque<ListNode*> s;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            while(!s.empty() && s.back()->val<temp->val){\\n                // cout<< s.back()->val<<\" \"<<temp->val<<\"\\\\n\";\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                s.back()->next  = temp;\\n            }\\n            s.push_back(temp);\\n            temp = temp->next;\\n        }\\n        return s.front();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        deque<ListNode*> s;\\n        ListNode* temp = head;\\n        while(temp!=NULL){\\n            while(!s.empty() && s.back()->val<temp->val){\\n                // cout<< s.back()->val<<\" \"<<temp->val<<\"\\\\n\";\\n                s.pop_back();\\n            }\\n            if(!s.empty()){\\n                s.back()->next  = temp;\\n            }\\n            s.push_back(temp);\\n            temp = temp->next;\\n        }\\n        return s.front();\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3551944,
                "title": "java-solution-brute-force-to-optimized-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)+O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n //BRUTE FORCE\\n// class Solution {\\n//     public ListNode removeNodes(ListNode head) {\\n//         ListNode dummy = new ListNode(0);\\n//         ListNode curr = dummy;\\n//         while(head != null){\\n//             ListNode temp = head;\\n//             int max = head.val;\\n//             while(temp!=null){\\n//                 max=Math.max(max,temp.val);\\n//                 if(max!=head.val) break;\\n//                 temp=temp.next;\\n//             }\\n\\n//             if(max==head.val){\\n//                 ListNode temp1 = new ListNode(head.val);\\n//                 curr.next = temp1;\\n//                 curr = curr.next;\\n\\n//             }\\n//             head=head.next;\\n            \\n//         }\\n//         curr.next=null;\\n//         return dummy.next  ;\\n//     }\\n// }\\n\\n\\n\\n//Optimized \\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> s = new Stack<>();\\n        ListNode reverse = rev(head);\\n        while(reverse!=null){\\n\\n            if(s.isEmpty() || (!s.isEmpty() && reverse.val>=s.peek())){\\n                s.push(reverse.val);\\n            }\\n            \\n\\n            reverse=reverse.next;\\n        }\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        while(!s.isEmpty()){\\n            ListNode temp1 = new ListNode(s.pop());\\n            curr.next = temp1;\\n            curr = curr.next;\\n\\n        }\\n        return dummy.next;\\n\\n        \\n    }\\n    public ListNode rev(ListNode head){\\n        ListNode forward=null;\\n        ListNode perv=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            forward=curr.next;\\n            curr.next=perv;\\n            perv=curr;\\n            curr=forward;\\n        }\\n        return perv;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n //BRUTE FORCE\\n// class Solution {\\n//     public ListNode removeNodes(ListNode head) {\\n//         ListNode dummy = new ListNode(0);\\n//         ListNode curr = dummy;\\n//         while(head != null){\\n//             ListNode temp = head;\\n//             int max = head.val;\\n//             while(temp!=null){\\n//                 max=Math.max(max,temp.val);\\n//                 if(max!=head.val) break;\\n//                 temp=temp.next;\\n//             }\\n\\n//             if(max==head.val){\\n//                 ListNode temp1 = new ListNode(head.val);\\n//                 curr.next = temp1;\\n//                 curr = curr.next;\\n\\n//             }\\n//             head=head.next;\\n            \\n//         }\\n//         curr.next=null;\\n//         return dummy.next  ;\\n//     }\\n// }\\n\\n\\n\\n//Optimized \\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer> s = new Stack<>();\\n        ListNode reverse = rev(head);\\n        while(reverse!=null){\\n\\n            if(s.isEmpty() || (!s.isEmpty() && reverse.val>=s.peek())){\\n                s.push(reverse.val);\\n            }\\n            \\n\\n            reverse=reverse.next;\\n        }\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        while(!s.isEmpty()){\\n            ListNode temp1 = new ListNode(s.pop());\\n            curr.next = temp1;\\n            curr = curr.next;\\n\\n        }\\n        return dummy.next;\\n\\n        \\n    }\\n    public ListNode rev(ListNode head){\\n        ListNode forward=null;\\n        ListNode perv=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            forward=curr.next;\\n            curr.next=perv;\\n            perv=curr;\\n            curr=forward;\\n        }\\n        return perv;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548621,
                "title": "100-faster-solution-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    var head1 : ListNode ? = null\\n    fun removeNodes(head: ListNode?): ListNode? {\\n\\n        var stack = Stack<Int>()    \\n        var curr = head\\n         while (curr != null) {\\n            while (!stack.isEmpty() && curr.`val` > stack.peek()) {\\n                stack.pop()\\n            }\\n            stack.push(curr.`val`)\\n            curr = curr.next\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            addNode(ListNode(stack.pop()))\\n        }\\n\\n       \\n        return head1\\n    }\\n    fun addNode(node:ListNode?){\\n if (head1 == null) {\\n            head1 = node\\n        } else {\\n            node?.next = head1\\n            head1 = node\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    var head1 : ListNode ? = null\\n    fun removeNodes(head: ListNode?): ListNode? {\\n\\n        var stack = Stack<Int>()    \\n        var curr = head\\n         while (curr != null) {\\n            while (!stack.isEmpty() && curr.`val` > stack.peek()) {\\n                stack.pop()\\n            }\\n            stack.push(curr.`val`)\\n            curr = curr.next\\n        }\\n\\n        while (!stack.isEmpty()) {\\n            addNode(ListNode(stack.pop()))\\n        }\\n\\n       \\n        return head1\\n    }\\n    fun addNode(node:ListNode?){\\n if (head1 == null) {\\n            head1 = node\\n        } else {\\n            node?.next = head1\\n            head1 = node\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546543,
                "title": "faster-than-97-15-o-1-space-complexity-0-n-time-complexity-python-iterative-reverse",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis exercise could be solved in **O(n) time complexity** and **O(1) space complexity** by **reversing** the linked list **2 times**\\n\\n# Approach\\nI have a variable called `maximum` which will contain the value of the highest node encountered, initialized at `-math.inf`\\n\\nI start by reversing the linked list. Then our new head is the tail of the original list. Now I will parkour the list and each time I found a node with a value higher (or equal) than the `maximum`, I will link this value with the previous node containing the previous `maximum`.\\n\\nBy this, we are sure that each value is followed by another greater (or equal) than the previous one\\n\\nAt the end I return the reversed list of this and we have our original list with values decreasing\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head : ListNode) -> ListNode:\\n        current = head\\n        prev = None\\n        while (current):\\n            old_next = current.next\\n            current.next = prev\\n            prev = current\\n            current = old_next\\n        return prev\\n\\n    def removeNodes(self, head: ListNode) -> ListNode:\\n        head = self.reverseList(head)\\n        maximum = -math.inf\\n        current = head\\n        prev = None\\n\\n        while (current):\\n            tmp_next = current.next\\n            if current.val >= maximum:\\n                maximum = current.val\\n                if (prev):\\n                    prev.next = current\\n                    current.next = None\\n                else:\\n                    head.next = None\\n                prev = current\\n            current = tmp_next\\n        return self.reverseList(head)\\n```\\n\\nHehehe Thank You\\n\\nPlease Upvote (if you liked or if 1 != 0)",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseList(self, head : ListNode) -> ListNode:\\n        current = head\\n        prev = None\\n        while (current):\\n            old_next = current.next\\n            current.next = prev\\n            prev = current\\n            current = old_next\\n        return prev\\n\\n    def removeNodes(self, head: ListNode) -> ListNode:\\n        head = self.reverseList(head)\\n        maximum = -math.inf\\n        current = head\\n        prev = None\\n\\n        while (current):\\n            tmp_next = current.next\\n            if current.val >= maximum:\\n                maximum = current.val\\n                if (prev):\\n                    prev.next = current\\n                    current.next = None\\n                else:\\n                    head.next = None\\n                prev = current\\n            current = tmp_next\\n        return self.reverseList(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400387,
                "title": "easy-code-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* forward=NULL;\\n\\n        while(curr!=NULL)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n\\n        stack<int>st;\\n        ListNode* temp=prev;\\n        st.push(temp->val);\\n        temp=temp->next;\\n\\n        while(temp!=NULL)\\n        {\\n            if(st.top()<=temp->val){\\n                st.push(temp->val);\\n                temp=temp->next;\\n            }\\n            else\\n            {\\n                temp=temp->next;\\n            }\\n        }\\n\\n        ListNode* tem= new ListNode(st.top());\\n        ListNode* ans=tem;\\n        st.pop();\\n\\n        while(!st.empty())\\n        {\\n            ListNode* templ= new ListNode(st.top());\\n            tem->next=templ;\\n            tem=tem->next;\\n            tem->next=NULL;\\n            st.pop();\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        ListNode* forward=NULL;\\n\\n        while(curr!=NULL)\\n        {\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n\\n        stack<int>st;\\n        ListNode* temp=prev;\\n        st.push(temp->val);\\n        temp=temp->next;\\n\\n        while(temp!=NULL)\\n        {\\n            if(st.top()<=temp->val){\\n                st.push(temp->val);\\n                temp=temp->next;\\n            }\\n            else\\n            {\\n                temp=temp->next;\\n            }\\n        }\\n\\n        ListNode* tem= new ListNode(st.top());\\n        ListNode* ans=tem;\\n        st.pop();\\n\\n        while(!st.empty())\\n        {\\n            ListNode* templ= new ListNode(st.top());\\n            tem->next=templ;\\n            tem=tem->next;\\n            tem->next=NULL;\\n            st.pop();\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394076,
                "title": "2487-remove-nodes-from-linked-list-java",
                "content": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverse(head);\\n        ListNode cur=head,next=head;\\n        int max=head.val;\\n        while(cur!=null)\\n        {\\n            max=Math.max(max,cur.val);\\n           if(max>cur.val)\\n             next.next=next.next.next;\\n           else\\n             next =cur;\\n           cur=cur.next;\\n        }\\n        head=reverse(head);\\n        return head;\\n    }\\n    public ListNode reverse (ListNode head)\\n    {\\n        ListNode prev=null,cur=head,next=null;\\n        while(cur!=null)\\n        {\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        head=reverse(head);\\n        ListNode cur=head,next=head;\\n        int max=head.val;\\n        while(cur!=null)\\n        {\\n            max=Math.max(max,cur.val);\\n           if(max>cur.val)\\n             next.next=next.next.next;\\n           else\\n             next =cur;\\n           cur=cur.next;\\n        }\\n        head=reverse(head);\\n        return head;\\n    }\\n    public ListNode reverse (ListNode head)\\n    {\\n        ListNode prev=null,cur=head,next=null;\\n        while(cur!=null)\\n        {\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n        }\\n        return prev;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391185,
                "title": "stack-solution-no-reversing-of-linked-list-simple-and-consise-o-n",
                "content": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer>st=new Stack<>();\\n        while(head!=null){\\n            if(st.size()==0){\\n                st.add(head.val);\\n            }\\n            else{\\n                int curr=head.val;\\n                while(st.size()>0 && st.peek()<curr){\\n                    st.pop();\\n                }\\n                st.add(curr);\\n            }\\n            head=head.next;\\n        }\\n        ListNode prev = null;\\n        ListNode curr = null;\\n        while(st.size() > 0) {\\n            curr = new ListNode(st.pop());\\n            curr.next = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<Integer>st=new Stack<>();\\n        while(head!=null){\\n            if(st.size()==0){\\n                st.add(head.val);\\n            }\\n            else{\\n                int curr=head.val;\\n                while(st.size()>0 && st.peek()<curr){\\n                    st.pop();\\n                }\\n                st.add(curr);\\n            }\\n            head=head.next;\\n        }\\n        ListNode prev = null;\\n        ListNode curr = null;\\n        while(st.size() > 0) {\\n            curr = new ListNode(st.pop());\\n            curr.next = prev;\\n            prev = curr;\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369757,
                "title": "c-stack-faster-easy-to-understand",
                "content": "* ***Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        // traverse over the list and delete the nodes\\n        \\n        stack<ListNode*> st;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr)\\n        {\\n            // delete all the nodes which satisfy the condition\\n            \\n            while(st.empty() == false && curr -> val > st.top() -> val)\\n            {\\n                st.pop();\\n            }\\n            \\n            // push the curr node into the stack\\n          \\n            st.push(curr);\\n                \\n            curr = curr -> next;\\n        }\\n        \\n        // create new list after deletion\\n        \\n        ListNode* tail = NULL;\\n        \\n        ListNode* new_head = NULL;\\n        \\n        while(st.empty() == false)\\n        {\\n            if(st.size() == 1)\\n            {\\n                new_head = st.top();\\n            }\\n            \\n            st.top() -> next = tail;\\n            \\n            tail = st.top();\\n            \\n            st.pop();\\n        }\\n        \\n        return new_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        // traverse over the list and delete the nodes\\n        \\n        stack<ListNode*> st;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr)\\n        {\\n            // delete all the nodes which satisfy the condition\\n            \\n            while(st.empty() == false && curr -> val > st.top() -> val)\\n            {\\n                st.pop();\\n            }\\n            \\n            // push the curr node into the stack\\n          \\n            st.push(curr);\\n                \\n            curr = curr -> next;\\n        }\\n        \\n        // create new list after deletion\\n        \\n        ListNode* tail = NULL;\\n        \\n        ListNode* new_head = NULL;\\n        \\n        while(st.empty() == false)\\n        {\\n            if(st.size() == 1)\\n            {\\n                new_head = st.top();\\n            }\\n            \\n            st.top() -> next = tail;\\n            \\n            tail = st.top();\\n            \\n            st.pop();\\n        }\\n        \\n        return new_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341167,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        dummy=ListNode()\\n        tail=dummy\\n        nums=[]\\n        while head:\\n            nums.append(head.val)\\n            head=head.next\\n        max_so_far = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < max_so_far:\\n                nums.pop(i)\\n            else:\\n                max_so_far = nums[i]\\n        for i in nums:\\n            tail.next=ListNode(i)\\n            tail=tail.next\\n        return dummy.next\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n        dummy=ListNode()\\n        tail=dummy\\n        nums=[]\\n        while head:\\n            nums.append(head.val)\\n            head=head.next\\n        max_so_far = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < max_so_far:\\n                nums.pop(i)\\n            else:\\n                max_so_far = nums[i]\\n        for i in nums:\\n            tail.next=ListNode(i)\\n            tail=tail.next\\n        return dummy.next\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237206,
                "title": "1-liner-beats-93-33-easy-recursion-c",
                "content": "# Intuition\\n## Using  Recursion Stack as monotonic Stack.\\n\\n# Approach\\n- Bottom Up approach.\\n- Traverse till last node of List through recursion(see code).\\n- If its value is less than previous node(which we will campare in last waiting recursion function) we will return node.\\n- Else we will return next node.\\n\\n# Complexity\\n- Time complexity :  **O(n)** \\n  -Traversing to each **N** node so **O(N)** Time Complexity.\\n\\n- Space complexity: **Recursion Stack**  ==== **O(n)** only\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        head->next=removeNodes(head->next);\\n        return head->val >= head->next->val ? head : head->next ;\\n    }\\n};\\n```\\n# Thanks for the Upvote...\\uD83D\\uDE07",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        head->next=removeNodes(head->next);\\n        return head->val >= head->next->val ? head : head->next ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220548,
                "title": "by-reversing-the-list-c-easy",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL,*curr=head,*nxt=NULL;\\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return head=prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverseList(head);\\n        int max = head->val;\\n        ListNode *p = head;\\n        while(p->next != NULL)\\n        {\\n            if(p->next->val < p->val)\\n            {\\n                p->next = p->next->next;\\n            }\\n            else\\n            {\\n                p = p->next;\\n            }\\n        }\\n        head = reverseList(head);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL,*curr=head,*nxt=NULL;\\n        while(curr)\\n        {\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return head=prev;\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverseList(head);\\n        int max = head->val;\\n        ListNode *p = head;\\n        while(p->next != NULL)\\n        {\\n            if(p->next->val < p->val)\\n            {\\n                p->next = p->next->next;\\n            }\\n            else\\n            {\\n                p = p->next;\\n            }\\n        }\\n        head = reverseList(head);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210621,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveNodes(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n\\n        var temp = RemoveNodes(head.next);\\n        if(head.val >= temp.val) {\\n            head.next = temp;\\n            return head;\\n        }\\n\\n        return temp;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveNodes(ListNode head) {\\n        if(head.next == null)\\n            return head;\\n\\n        var temp = RemoveNodes(head.next);\\n        if(head.val >= temp.val) {\\n            head.next = temp;\\n            return head;\\n        }\\n\\n        return temp;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191713,
                "title": "python-solution-beats-99-9-reverse-list",
                "content": "# Approach\\n1) Reverse the linked list. This becomes an easy comparison as now a node should be deleted if there is a node on the left side with a strictly greater value.\\n\\n2) Rereverse the list.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n\\n        prev = None\\n        curr = head\\n\\n        while(curr):\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n\\n        curr = prev\\n\\n        while(curr and curr.next):\\n            if curr.val > curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        curr = prev\\n        prev = None\\n        while(curr):\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n\\n        return prev\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        \"\"\"\\n        :type head: Optional[ListNode]\\n        :rtype: Optional[ListNode]\\n        \"\"\"\\n\\n        prev = None\\n        curr = head\\n\\n        while(curr):\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n\\n        curr = prev\\n\\n        while(curr and curr.next):\\n            if curr.val > curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n\\n        curr = prev\\n        prev = None\\n        while(curr):\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n\\n        return prev\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170279,
                "title": "java-solution-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ArrayList<Integer> stack = new ArrayList<>();\\n\\n        while(head != null){\\n            while(stack.size() != 0 && stack.get(stack.size()-1) < head.val)\\n                stack.remove(stack.size()-1);\\n            \\n            stack.add(head.val);\\n\\n            head = head.next;\\n        }\\n\\n        ListNode result = new ListNode(stack.get(0));\\n        ListNode result2 = result;\\n\\n        for(int i = 1; i < stack.size(); i++){\\n            result.next = new ListNode(stack.get(i));\\n            result = result.next;\\n        }\\n\\n        return result2;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ArrayList<Integer> stack = new ArrayList<>();\\n\\n        while(head != null){\\n            while(stack.size() != 0 && stack.get(stack.size()-1) < head.val)\\n                stack.remove(stack.size()-1);\\n            \\n            stack.add(head.val);\\n\\n            head = head.next;\\n        }\\n\\n        ListNode result = new ListNode(stack.get(0));\\n        ListNode result2 = result;\\n\\n        for(int i = 1; i < stack.size(); i++){\\n            result.next = new ListNode(stack.get(i));\\n            result = result.next;\\n        }\\n\\n        return result2;\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136738,
                "title": "python-recursive-code-beats-90-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return None\\n        head.next = self.removeNodes(head.next)\\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return None\\n        head.next = self.removeNodes(head.next)\\n        if head.next and head.val < head.next.val:\\n            return head.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127356,
                "title": "c-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n     ListNode* head2 = head;\\n     ListNode* dummyHead = NULL;\\n     stack<ListNode*> st;\\n      \\n      while(head != NULL){\\n        if(st.empty()){\\n          st.push(head);\\n          head = head->next;\\n          continue;\\n        }\\n        \\n        if(!st.empty() && st.top()->val >= head->val){\\n          st.push(head);\\n          head = head->next;\\n        }else{\\n          st.pop();\\n        }\\n      }\\n      \\n      while(!st.empty()){\\n         st.top()->next = dummyHead;\\n         dummyHead = st.top();\\n         st.pop();\\n      }\\n      \\n      \\n        return dummyHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n     ListNode* head2 = head;\\n     ListNode* dummyHead = NULL;\\n     stack<ListNode*> st;\\n      \\n      while(head != NULL){\\n        if(st.empty()){\\n          st.push(head);\\n          head = head->next;\\n          continue;\\n        }\\n        \\n        if(!st.empty() && st.top()->val >= head->val){\\n          st.push(head);\\n          head = head->next;\\n        }else{\\n          st.pop();\\n        }\\n      }\\n      \\n      while(!st.empty()){\\n         st.top()->next = dummyHead;\\n         dummyHead = st.top();\\n         st.pop();\\n      }\\n      \\n      \\n        return dummyHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090267,
                "title": "c-solution-using-priority-queue-min-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it is not mentioned in the question to solve in-place, we can generate new Linked List. Also we can use Min-Heap to keep track of minimum element in the linked list traversed so far. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will traverse the Linked list and keep pushing their integer values to the min heap. And whenever we push any element we will pop all those elements which are less than the current element.\\nAfter this Process we can generate required linked list from the min_heap. Since the elements are pushed in reverse direction we will take care of this while generating the linked list.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        priority_queue<int,vector<int>,greater<int>> pq;//min_heap\\n        while(head!=NULL){\\n            //pop smaller elements\\n            while(!pq.empty() and pq.top()<head->val){\\n                pq.pop();\\n            }\\n            // push current element\\n            pq.push(head->val);\\n            head=head->next;\\n        }\\n\\n        #define ln ListNode\\n        ln* h2=nullptr;\\n\\n        //generate new linked list from min heap\\n        while(!pq.empty()){\\n            ln* t= new ln(pq.top());\\n            t->next=h2;\\n            h2=t;\\n            pq.pop();\\n        }\\n    return  h2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        priority_queue<int,vector<int>,greater<int>> pq;//min_heap\\n        while(head!=NULL){\\n            //pop smaller elements\\n            while(!pq.empty() and pq.top()<head->val){\\n                pq.pop();\\n            }\\n            // push current element\\n            pq.push(head->val);\\n            head=head->next;\\n        }\\n\\n        #define ln ListNode\\n        ln* h2=nullptr;\\n\\n        //generate new linked list from min heap\\n        while(!pq.empty()){\\n            ln* t= new ln(pq.top());\\n            t->next=h2;\\n            h2=t;\\n            pq.pop();\\n        }\\n    return  h2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086629,
                "title": "c-beats-100-iterative-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We cannot access elements from the end of the linked list \\nSo we have to reverse the list first \\n3. Then we compare the values stored in the nodes. \\n4. Delete if maxi > curr -> val \\nUpdate the next pointers \\n5. If no deletion \\nUpdate prev \\n6. Update curr in the end to continue iterations \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *reverse (ListNode *&head)\\n    {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head ; \\n        }\\n        ListNode *curr = head ; \\n        ListNode *prev = NULL ;\\n        ListNode *forward = NULL; \\n        while (curr != NULL)\\n        {\\n            forward = curr -> next ;  \\n            curr -> next = prev ; \\n            prev = curr ;\\n            curr = forward ; \\n        } \\n        return prev ;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverse(head) ; \\n        ListNode *prev = NULL ;\\n        ListNode *curr = head ; \\n        int maxi  = head -> val ;\\n        \\n        while (curr != NULL)\\n        {\\n            // updating maxi \\n            maxi = max (maxi , curr -> val);\\n            if(maxi > curr -> val)\\n            {\\n                prev -> next  = curr -> next ; \\n            }\\n            else\\n            {\\n                prev = curr ; \\n            }\\n            curr = curr -> next ; \\n        }\\n        // reversing list again to return it to its original form before returning\\n        head = reverse(head) ;\\n        return head ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *reverse (ListNode *&head)\\n    {\\n        if(head == NULL || head -> next == NULL)\\n        {\\n            return head ; \\n        }\\n        ListNode *curr = head ; \\n        ListNode *prev = NULL ;\\n        ListNode *forward = NULL; \\n        while (curr != NULL)\\n        {\\n            forward = curr -> next ;  \\n            curr -> next = prev ; \\n            prev = curr ;\\n            curr = forward ; \\n        } \\n        return prev ;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverse(head) ; \\n        ListNode *prev = NULL ;\\n        ListNode *curr = head ; \\n        int maxi  = head -> val ;\\n        \\n        while (curr != NULL)\\n        {\\n            // updating maxi \\n            maxi = max (maxi , curr -> val);\\n            if(maxi > curr -> val)\\n            {\\n                prev -> next  = curr -> next ; \\n            }\\n            else\\n            {\\n                prev = curr ; \\n            }\\n            curr = curr -> next ; \\n        }\\n        // reversing list again to return it to its original form before returning\\n        head = reverse(head) ;\\n        return head ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072224,
                "title": "java-solution-easy",
                "content": "# Approach\\n* Traverse the linked list and store it in an arraylist\\n* create a max variable and traverse the list from last, and check the max. \\n* max elements will be stored on another list.\\n* return the head.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public ListNode removeNodes(ListNode head) \\n    {\\n        ListNode temp = head ;\\n        List<ListNode> li = new ArrayList<ListNode>();\\n        List<ListNode> li2 = new ArrayList<ListNode>();\\n        while( temp != null )       // Traverse the list.\\n        {\\n            li.add(temp);           // Add to List.\\n            temp = temp.next ;\\n        }\\n        int max = li.get(li.size() - 1).val ;   // last element\\n        for(int i = li.size() - 1 ;  i >= 0 ; i--)\\n        {\\n            int val = li.get(i).val ;\\n            if( max <= val )        // if greater than or equal to max\\n            {\\n                max = val ;\\n                li2.add(li.get(i)) ;       // Add to List.\\n            }\\n        }\\n\\n        head = li2.get(li2.size()-1) ;\\n        ListNode t = null ; \\n        for(int i = li2.size() -1  ; i >= 1 ; i-- )    // Traverse \\n        {                                      //list in reverse order\\n            t = li2.get(i) ;    \\n            t.next = li2.get(i-1) ;\\n        }\\n        return head ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public ListNode removeNodes(ListNode head) \\n    {\\n        ListNode temp = head ;\\n        List<ListNode> li = new ArrayList<ListNode>();\\n        List<ListNode> li2 = new ArrayList<ListNode>();\\n        while( temp != null )       // Traverse the list.\\n        {\\n            li.add(temp);           // Add to List.\\n            temp = temp.next ;\\n        }\\n        int max = li.get(li.size() - 1).val ;   // last element\\n        for(int i = li.size() - 1 ;  i >= 0 ; i--)\\n        {\\n            int val = li.get(i).val ;\\n            if( max <= val )        // if greater than or equal to max\\n            {\\n                max = val ;\\n                li2.add(li.get(i)) ;       // Add to List.\\n            }\\n        }\\n\\n        head = li2.get(li2.size()-1) ;\\n        ListNode t = null ; \\n        for(int i = li2.size() -1  ; i >= 1 ; i-- )    // Traverse \\n        {                                      //list in reverse order\\n            t = li2.get(i) ;    \\n            t.next = li2.get(i-1) ;\\n        }\\n        return head ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029718,
                "title": "c-beginner-friendly-solutions-two-solutions-monotonic-dequeue-recursion",
                "content": "##### Monotonic dequeue\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(N)`\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        deque<ListNode*> dq;\\n\\n        while(head) {\\n            while(!dq.empty() && dq.back() -> val < head -> val) dq.pop_back();\\n            dq.push_back(head);\\n            head = head -> next;\\n        }\\n\\n        ListNode *answer = dq.front(); dq.pop_front();\\n        ListNode *curr = answer;\\n        \\n        while(!dq.empty()) {\\n            curr -> next = dq.front();\\n            curr = curr -> next;\\n            dq.pop_front();\\n        }\\n        curr -> next = nullptr;\\n\\n        return answer;\\n    }\\n};\\n\\n````\\n\\n\\n##### Recursion \\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(N)`, Recursive stack space\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(!head) return head;\\n\\n        head -> next = removeNodes(head -> next);\\n\\n        return head -> next && head -> val < head -> next -> val ? head -> next : head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        deque<ListNode*> dq;\\n\\n        while(head) {\\n            while(!dq.empty() && dq.back() -> val < head -> val) dq.pop_back();\\n            dq.push_back(head);\\n            head = head -> next;\\n        }\\n\\n        ListNode *answer = dq.front(); dq.pop_front();\\n        ListNode *curr = answer;\\n        \\n        while(!dq.empty()) {\\n            curr -> next = dq.front();\\n            curr = curr -> next;\\n            dq.pop_front();\\n        }\\n        curr -> next = nullptr;\\n\\n        return answer;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(!head) return head;\\n\\n        head -> next = removeNodes(head -> next);\\n\\n        return head -> next && head -> val < head -> next -> val ? head -> next : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942143,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nint depth(struct ListNode* head){\\n    int d = 0;\\n    struct ListNode* tmp = head;\\n    while(tmp){\\n        d++;\\n        tmp = tmp->next;\\n    }\\n    return d;\\n}\\nstruct ListNode* removeNodes(struct ListNode* head){\\n    int n = depth(head);\\n    struct ListNode** arr = malloc(n * sizeof(struct ListNode*));\\n    struct ListNode* tmp = head;\\n    int i = 0;\\n    while(tmp){\\n        arr[i] = tmp;\\n        i++;\\n        tmp = tmp->next;\\n    }\\n    bool* rm = calloc(n, sizeof(bool));\\n    int max = arr[n-1]->val;\\n    for(int i = n-2; i >=0; i--){\\n        if(arr[i]->val < max)\\n            rm[i] = true;\\n        else if(arr[i]->val > max)\\n            max = arr[i]->val;\\n    }\\n    struct ListNode* ans ;\\n    for(int i = 0; i < n; i++){\\n        if(rm[i] == false){\\n            ans = arr[i];\\n            tmp = ans;\\n            for(int j = i+1; j < n; j++){\\n                if(rm[j] == false){\\n                    tmp->next = arr[j];\\n                    tmp = tmp->next;\\n                }\\n            }\\n            tmp->next = NULL;\\n            break;\\n        }\\n    }\\n    free(arr);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nint depth(struct ListNode* head){\\n    int d = 0;\\n    struct ListNode* tmp = head;\\n    while(tmp){\\n        d++;\\n        tmp = tmp->next;\\n    }\\n    return d;\\n}\\nstruct ListNode* removeNodes(struct ListNode* head){\\n    int n = depth(head);\\n    struct ListNode** arr = malloc(n * sizeof(struct ListNode*));\\n    struct ListNode* tmp = head;\\n    int i = 0;\\n    while(tmp){\\n        arr[i] = tmp;\\n        i++;\\n        tmp = tmp->next;\\n    }\\n    bool* rm = calloc(n, sizeof(bool));\\n    int max = arr[n-1]->val;\\n    for(int i = n-2; i >=0; i--){\\n        if(arr[i]->val < max)\\n            rm[i] = true;\\n        else if(arr[i]->val > max)\\n            max = arr[i]->val;\\n    }\\n    struct ListNode* ans ;\\n    for(int i = 0; i < n; i++){\\n        if(rm[i] == false){\\n            ans = arr[i];\\n            tmp = ans;\\n            for(int j = i+1; j < n; j++){\\n                if(rm[j] == false){\\n                    tmp->next = arr[j];\\n                    tmp = tmp->next;\\n                }\\n            }\\n            tmp->next = NULL;\\n            break;\\n        }\\n    }\\n    free(arr);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2931021,
                "title": "simple-recursion-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the largest value next to current node. If the value is strictly greater than current then we remove the current node else the current node become the largest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are creating monotonic stack using recursion.\\n\\nWe use recursion for finding the solution for smaller linked list \\ni.e. head->next \\nfrom the result of recursion we find the largest right node from head. \\nhere we have two conditions:\\n1. if head is smaller than the result then return result.\\n2. if head is greater then head->next = result  and return head.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null || head.next==null)return head;\\n        ListNode rec=removeNodes(head.next);\\n        if(rec.val>head.val)return rec;\\n        head.next=rec;\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null || head.next==null)return head;\\n        ListNode rec=removeNodes(head.next);\\n        if(rec.val>head.val)return rec;\\n        head.next=rec;\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922262,
                "title": "python-easy-solution-linked-list-arrays",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        arr = []\\n        currMax = -99999\\n        while head:\\n            # print(arr)\\n            if len(arr) == 0:\\n                currMax = head.val\\n                arr.append(head.val)\\n            else:\\n                if head.val > currMax:\\n                    currMax = head.val\\n                    arr = [head.val]\\n                \\n                else:\\n                    if head.val > arr[-1]:\\n                        for i in range(len(arr)-1, -1, -1):\\n                            if head.val > arr[i]:\\n                                arr.pop()\\n                            else:\\n                                break\\n                    arr.append(head.val)\\n            head = head.next\\n        # print(arr)\\n        d = n = ListNode()\\n        for i in arr:\\n            n.next = ListNode(i)\\n            n = n.next\\n        return d.next\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        arr = []\\n        currMax = -99999\\n        while head:\\n            # print(arr)\\n            if len(arr) == 0:\\n                currMax = head.val\\n                arr.append(head.val)\\n            else:\\n                if head.val > currMax:\\n                    currMax = head.val\\n                    arr = [head.val]\\n                \\n                else:\\n                    if head.val > arr[-1]:\\n                        for i in range(len(arr)-1, -1, -1):\\n                            if head.val > arr[i]:\\n                                arr.pop()\\n                            else:\\n                                break\\n                    arr.append(head.val)\\n            head = head.next\\n        # print(arr)\\n        d = n = ListNode()\\n        for i in arr:\\n            n.next = ListNode(i)\\n            n = n.next\\n        return d.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910255,
                "title": "java-o-n-93-faster-solution",
                "content": "# Complexity\\n- Time complexity: O(3N) => O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode cur = head;\\n        List<ListNode> list = new ArrayList<>();\\n        while (cur != null) {\\n            list.add(cur);\\n            cur = cur.next;\\n        }\\n        int max = 0;\\n        int[] arr = new int[list.size()];\\n        //finding max from the end to include values into result\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            if (max <= list.get(i).val) {\\n                arr[i] = 1;\\n                max = list.get(i).val;\\n            }\\n        }\\n        boolean headSet = false;\\n        cur = head;\\n        //adding nodes to the result\\n        for (int i = 0; i < list.size(); i++) {\\n            if (arr[i] == 1) {\\n                if (!headSet) {\\n                    headSet = true;\\n                    head = list.get(i);\\n                    cur = head;\\n                } else {\\n                    cur.next = list.get(i);\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        cur.next = null;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode cur = head;\\n        List<ListNode> list = new ArrayList<>();\\n        while (cur != null) {\\n            list.add(cur);\\n            cur = cur.next;\\n        }\\n        int max = 0;\\n        int[] arr = new int[list.size()];\\n        //finding max from the end to include values into result\\n        for (int i = list.size() - 1; i >= 0; i--) {\\n            if (max <= list.get(i).val) {\\n                arr[i] = 1;\\n                max = list.get(i).val;\\n            }\\n        }\\n        boolean headSet = false;\\n        cur = head;\\n        //adding nodes to the result\\n        for (int i = 0; i < list.size(); i++) {\\n            if (arr[i] == 1) {\\n                if (!headSet) {\\n                    headSet = true;\\n                    head = list.get(i);\\n                    cur = head;\\n                } else {\\n                    cur.next = list.get(i);\\n                    cur = cur.next;\\n                }\\n            }\\n        }\\n        cur.next = null;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888423,
                "title": "o-n-recursive-python3-solution-explained",
                "content": "# Approach\\nWe recursively go till the end of the linked-list. While backtracking we keep track of the max till now and if node.val is smaller then we delete current node and further backtrack. If our current node is greater we return its value as the greatest till here without deleting the node.\\nWe can also call the approach as a post-order dfs traversal approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n); i guess for the recursion stack.\\nO(1); otherwise idk lol.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            max_right = dfs(node.next)\\n            if max_right > node.val:\\n                node.val = node.next.val\\n                node.next = node.next.next\\n                return max_right\\n            else:\\n                return node.val\\n        node = head\\n        dfs(node)\\n        return head\\n```\\n\\n# Happy Coding.....",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def dfs(node):\\n            if not node:\\n                return 0\\n            max_right = dfs(node.next)\\n            if max_right > node.val:\\n                node.val = node.next.val\\n                node.next = node.next.next\\n                return max_right\\n            else:\\n                return node.val\\n        node = head\\n        dfs(node)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886065,
                "title": "easily-explained-stack-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a number in the list is greater then the previous element in the list,we need to remove that element and then check for more numbers before that(if there exists any number less then the current).\\nThis can be easily acheived by mantaining a decreasing monotonic stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n1. We use a stack to store the nodes that we have seen so far.\\n2. We traverse the list and keep pushing nodes into the stack until we find a node that has a value greater than the top of the stack.\\n3. Once we find such a node, we pop all the nodes from the stack that have a value greater than the current node\\u2019s value.\\n4. We push the current node into the stack.\\n5. We repeat steps 2-4 until we reach the end of the list.\\n6. We start popping nodes from the stack and connect them to the previous node until the stack is empty.\\n7. The last node that we pop and connect would be the head of our new list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* curr;\\n        ListNode* prev=NULL;\\n        if(head==NULL){\\n            return head;\\n        }\\n        while(head){\\n            while(head!=NULL&&!st.empty()&&head->val>(st.top()->val)){\\n                //free(st.top());\\n                st.pop();\\n            }\\n            st.push(head);\\n            head=head->next;\\n        }\\n        while(!st.empty()){\\n           // st.pop();\\n           // temp=st.top();\\n            curr=st.top();\\n            curr->next=prev;\\n            prev=curr;\\n            st.pop();\\n            \\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode* curr;\\n        ListNode* prev=NULL;\\n        if(head==NULL){\\n            return head;\\n        }\\n        while(head){\\n            while(head!=NULL&&!st.empty()&&head->val>(st.top()->val)){\\n                //free(st.top());\\n                st.pop();\\n            }\\n            st.push(head);\\n            head=head->next;\\n        }\\n        while(!st.empty()){\\n           // st.pop();\\n           // temp=st.top();\\n            curr=st.top();\\n            curr->next=prev;\\n            prev=curr;\\n            st.pop();\\n            \\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883926,
                "title": "easy-understanding-tc-o-n-sc-o-1",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep 1:-Iterate on nodes in reversed order.\\nstep2 :- When iterating in reversed order, save the maximum value that was passed before.\\nstep3:- return modified list in reversed order\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//Approch:- \\n//step 1:-Iterate on nodes in reversed order.\\n//step2 :- When iterating in reversed order, save the maximum value that was passed before.\\n//step3:- return modified list in reversed order\\n\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        \\n        ListNode tail = reverse(head);\\n        ListNode curr = tail;\\n        int max = curr.val;\\n\\n        while(curr.next != null ){\\n            if(curr.next.val < max){\\n                curr.next = curr.next.next;\\n            }\\n            else{\\n                curr = curr.next;\\n                max = curr.val;\\n            }\\n        }\\n\\n        return reverse(tail);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n\\n        ListNode prev = null;\\n        ListNode curr =head;\\n\\n        while(curr!= null){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n\\n            prev = curr;\\n            curr= next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n//Approch:- \\n//step 1:-Iterate on nodes in reversed order.\\n//step2 :- When iterating in reversed order, save the maximum value that was passed before.\\n//step3:- return modified list in reversed order\\n\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        \\n        ListNode tail = reverse(head);\\n        ListNode curr = tail;\\n        int max = curr.val;\\n\\n        while(curr.next != null ){\\n            if(curr.next.val < max){\\n                curr.next = curr.next.next;\\n            }\\n            else{\\n                curr = curr.next;\\n                max = curr.val;\\n            }\\n        }\\n\\n        return reverse(tail);\\n    }\\n\\n    public ListNode reverse(ListNode head){\\n\\n        ListNode prev = null;\\n        ListNode curr =head;\\n\\n        while(curr!= null){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n\\n            prev = curr;\\n            curr= next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882583,
                "title": "easy-c-solution-using-stack-traversing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n# public:\\n    ListNode* removeNodes(ListNode* head) {\\n       stack<int>s;\\n       ListNode *temp=head;\\n       while(temp!=NULL){\\n           int x=temp->val;\\n           if(s.empty()){\\n               s.push(x);\\n           }\\n           else if(s.top()>=x){\\n               \\n               s.push(x);\\n           }\\n           else{\\n               while(!s.empty() && s.top()<x){\\n                   s.pop();\\n               }\\n               s.push(x);\\n                \\n               \\n           }\\n           temp=temp->next;\\n       }\\n        ListNode *newnode=new ListNode(-1);\\n        ListNode *dummy=newnode;\\n        ListNode *ans=newnode;\\n        while(!s.empty()){\\n            ListNode *New=new ListNode(s.top());\\n            s.pop();\\n            dummy->next=New;\\n            dummy=New;\\n        }\\n        head=ans->next;\\n        // ListNode *prev=NULL;\\n\\n         ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n        while(current!=NULL){\\n            next = current->next;\\n            // Reverse current node\\'s pointer\\n            current->next = prev;\\n            // Move pointers one position ahead.\\n            prev = current;\\n            current = next;\\n            \\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n# public:\\n    ListNode* removeNodes(ListNode* head) {\\n       stack<int>s;\\n       ListNode *temp=head;\\n       while(temp!=NULL){\\n           int x=temp->val;\\n           if(s.empty()){\\n               s.push(x);\\n           }\\n           else if(s.top()>=x){\\n               \\n               s.push(x);\\n           }\\n           else{\\n               while(!s.empty() && s.top()<x){\\n                   s.pop();\\n               }\\n               s.push(x);\\n                \\n               \\n           }\\n           temp=temp->next;\\n       }\\n        ListNode *newnode=new ListNode(-1);\\n        ListNode *dummy=newnode;\\n        ListNode *ans=newnode;\\n        while(!s.empty()){\\n            ListNode *New=new ListNode(s.top());\\n            s.pop();\\n            dummy->next=New;\\n            dummy=New;\\n        }\\n        head=ans->next;\\n        // ListNode *prev=NULL;\\n\\n         ListNode* current = head;\\n        ListNode *prev = NULL, *next = NULL;\\n        while(current!=NULL){\\n            next = current->next;\\n            // Reverse current node\\'s pointer\\n            current->next = prev;\\n            // Move pointers one position ahead.\\n            prev = current;\\n            current = next;\\n            \\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2870563,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/0e52b1d1-1bf8-4d3f-8a40-01b68d076606_1670002033.8602407.png)\\n",
                "solutionTags": [
                    "Linked List",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/0e52b1d1-1bf8-4d3f-8a40-01b68d076606_1670002033.8602407.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2862080,
                "title": "go-clean-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc removeNodes(head *ListNode) *ListNode {\\n    stack := make([]*ListNode, 0)\\n\\n    for head != nil {\\n        for len(stack) != 0 {\\n            top := stack[len(stack) - 1]\\n            if top.Val < head.Val {\\n                stack = stack[:len(stack) - 1]\\n            } else {\\n                break\\n            }\\n        }\\n        stack = append(stack, head)\\n        head = head.Next\\n    }\\n\\n    for i:=0; i<len(stack) - 1; i++ {\\n        stack[i].Next = stack[i + 1]\\n    }\\n\\n    return stack[0]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc removeNodes(head *ListNode) *ListNode {\\n    stack := make([]*ListNode, 0)\\n\\n    for head != nil {\\n        for len(stack) != 0 {\\n            top := stack[len(stack) - 1]\\n            if top.Val < head.Val {\\n                stack = stack[:len(stack) - 1]\\n            } else {\\n                break\\n            }\\n        }\\n        stack = append(stack, head)\\n        head = head.Next\\n    }\\n\\n    for i:=0; i<len(stack) - 1; i++ {\\n        stack[i].Next = stack[i + 1]\\n    }\\n\\n    return stack[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859901,
                "title": "python3-o-n-beats-72-64",
                "content": "\\t\\tdef reverse_list(cur):\\n            prev = None\\n            while cur:\\n                temp = cur.next\\n                cur.next = prev\\n                prev = cur  \\n                cur = temp\\n            return prev\\n\\t\\tdummy = ListNode(None)\\n        res = dummy\\n        head = reverse_list(head)\\n        max_val = -float(\\'inf\\')\\n        while head:\\n            if head.val >= max_val:\\n                dummy.next = ListNode(head.val)\\n                dummy = dummy.next\\n                max_val = head.val\\n            head = head.next\\n        return reverse_list(res.next)\\n\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "\\t\\tdef reverse_list(cur):\\n            prev = None\\n            while cur:\\n                temp = cur.next\\n                cur.next = prev\\n                prev = cur  \\n                cur = temp\\n            return prev\\n\\t\\tdummy = ListNode(None)\\n        res = dummy\\n        head = reverse_list(head)\\n        max_val = -float(\\'inf\\')\\n        while head:\\n            if head.val >= max_val:\\n                dummy.next = ListNode(head.val)\\n                dummy = dummy.next\\n                max_val = head.val\\n            head = head.next\\n        return reverse_list(res.next)\\n\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 2856064,
                "title": "java-priorityqueue-hashset-with-comments",
                "content": "```\\npublic ListNode removeNodes(ListNode head) {\\n// using queue to remove existing smaller elements (left)\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        ListNode node = head;\\n        int i = 0;\\n        while(node != null) {\\n            if(!queue.isEmpty()) {\\n                int compareTo = queue.peek()[1];\\n                while(!queue.isEmpty() && compareTo < node.val) {\\n                    queue.remove();\\n                     if(!queue.isEmpty()) {\\n                            compareTo = queue.peek()[1];\\n                     }\\n                }\\n            }\\n            queue.add(new int[]{i++, node.val});\\n            node = node.next;\\n        }\\n        int n = i;\\n        //Using hashset to keep valid index\\n        Set<Integer> keep = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            keep.add(queue.remove()[0]);\\n        }\\n\\n// iterating over list and creating new linkedlist with valid index\\n        ListNode newHead = null;\\n        ListNode newNode = null;\\n        for(int x = 0; x < n; x++) {\\n            if(keep.contains(x)) {\\n                if(newHead == null) {\\n                    newNode = head;\\n                    newHead = newNode;\\n                } else {\\n                    newNode.next = head;\\n                    newNode = newNode.next;\\n                }\\n            } \\n            head = head.next;\\n        }\\n       return newHead;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic ListNode removeNodes(ListNode head) {\\n// using queue to remove existing smaller elements (left)\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        ListNode node = head;\\n        int i = 0;\\n        while(node != null) {\\n            if(!queue.isEmpty()) {\\n                int compareTo = queue.peek()[1];\\n                while(!queue.isEmpty() && compareTo < node.val) {\\n                    queue.remove();\\n                     if(!queue.isEmpty()) {\\n                            compareTo = queue.peek()[1];\\n                     }\\n                }\\n            }\\n            queue.add(new int[]{i++, node.val});\\n            node = node.next;\\n        }\\n        int n = i;\\n        //Using hashset to keep valid index\\n        Set<Integer> keep = new HashSet<>();\\n        while(!queue.isEmpty()) {\\n            keep.add(queue.remove()[0]);\\n        }\\n\\n// iterating over list and creating new linkedlist with valid index\\n        ListNode newHead = null;\\n        ListNode newNode = null;\\n        for(int x = 0; x < n; x++) {\\n            if(keep.contains(x)) {\\n                if(newHead == null) {\\n                    newNode = head;\\n                    newHead = newNode;\\n                } else {\\n                    newNode.next = head;\\n                    newNode = newNode.next;\\n                }\\n            } \\n            head = head.next;\\n        }\\n       return newHead;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2854175,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int>stk;\\n        ListNode *temp=head;\\n        vector<int>v;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        for(int i=v.size()-1;i>=0;i--){\\n            if(stk.empty()){\\n                stk.push(v[i]);\\n            }else if(!stk.empty() && stk.top()<=v[i]){\\n                stk.push(v[i]);\\n            }\\n        }\\n        v.clear();\\n        while(!stk.empty()){\\n            v.push_back(stk.top());\\n            stk.pop();\\n        }\\n        ListNode *ans=new ListNode(0);\\n        temp=ans;\\n        for(int i=0;i<v.size();i++){\\n            temp->next=new ListNode(v[i]);\\n            temp=temp->next;\\n        }\\n        return ans->next;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<int>stk;\\n        ListNode *temp=head;\\n        vector<int>v;\\n        while(temp){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2853330,
                "title": "c-simple-linked-list-solution-iterative-solution",
                "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* tmp)\\n    {\\n         ListNode *prev=NULL,*nxt=tmp;\\n         while(tmp)\\n          {\\n            nxt=tmp->next;\\n            tmp->next=prev;\\n            prev=tmp;\\n            tmp=nxt;\\n          }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* tmp=head;\\n        ListNode* node = new ListNode(0);\\n        ListNode* ans=node;\\n        \\n        tmp=reverse(tmp);\\n        int mx=tmp->val;\\n        while(tmp)\\n        {\\n           mx=max(mx,tmp->val);\\n            \\n            if(tmp->val>=mx)\\n            {\\n               ListNode* n=new ListNode(tmp->val);\\n               node->next=n;\\n                node=node->next;\\n            }\\n            tmp=tmp->next;\\n        }\\n\\n       tmp=reverse(ans->next);\\n        return tmp;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverse(ListNode* tmp)\\n    {\\n         ListNode *prev=NULL,*nxt=tmp;\\n         while(tmp)\\n          {\\n            nxt=tmp->next;\\n            tmp->next=prev;\\n            prev=tmp;\\n            tmp=nxt;\\n          }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* removeNodes(ListNode* head) \\n    {\\n        ListNode* tmp=head;\\n        ListNode* node = new ListNode(0);\\n        ListNode* ans=node;\\n        \\n        tmp=reverse(tmp);\\n        int mx=tmp->val;\\n        while(tmp)\\n        {\\n           mx=max(mx,tmp->val);\\n            \\n            if(tmp->val>=mx)\\n            {\\n               ListNode* n=new ListNode(tmp->val);\\n               node->next=n;\\n                node=node->next;\\n            }\\n            tmp=tmp->next;\\n        }\\n\\n       tmp=reverse(ans->next);\\n        return tmp;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853312,
                "title": "c-simple-logic-using-vectors",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        ListNode* node=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        \\n        vector<int>vec;\\n        \\n        while(node!=NULL){\\n            vec.push_back(node->val);\\n            node=node->next;\\n        }\\n        \\n        int n=vec.size();\\n        int maxi=INT_MIN;\\n        vector<int>tmp(n,false);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(vec[i] < maxi)\\n                tmp[i]=true;\\n            maxi=max(maxi,vec[i]);\\n        }\\n         dummy->next=head;\\n        for(int i=0;i<n;i++){\\n            if(tmp[i]==false){\\n                ListNode* newNode=new ListNode(vec[i]);\\n                head->next=newNode;\\n                head=head->next;\\n            }\\n            \\n        } \\n        return dummy->next->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        \\n        ListNode* node=head;\\n        ListNode* dummy=new ListNode();\\n        dummy->next=head;\\n        \\n        vector<int>vec;\\n        \\n        while(node!=NULL){\\n            vec.push_back(node->val);\\n            node=node->next;\\n        }\\n        \\n        int n=vec.size();\\n        int maxi=INT_MIN;\\n        vector<int>tmp(n,false);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(vec[i] < maxi)\\n                tmp[i]=true;\\n            maxi=max(maxi,vec[i]);\\n        }\\n         dummy->next=head;\\n        for(int i=0;i<n;i++){\\n            if(tmp[i]==false){\\n                ListNode* newNode=new ListNode(vec[i]);\\n                head->next=newNode;\\n                head=head->next;\\n            }\\n            \\n        } \\n        return dummy->next->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852581,
                "title": "python-solution-using-stack",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n            \\n        stack = []\\n        res = [-1]*len(arr)\\n        \\n        for i in range(len(arr)-1, -1, -1):\\n\\n            while stack and stack[-1] <= arr[i]:\\n                stack.pop()\\n            if stack:\\n                res[i] = stack[-1]\\n                \\n            stack.append(arr[i])\\n            \\n        dummy = ListNode(None)\\n        current = dummy\\n        # print(res)\\n        for i in range(len(res)):\\n            if res[i] == -1:\\n                node = ListNode(arr[i])\\n                current.next = node\\n                current = current.next\\n        return dummy.next\\n        \\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        arr = []\\n        \\n        while head:\\n            arr.append(head.val)\\n            head = head.next\\n            \\n        stack = []\\n        res = [-1]*len(arr)\\n        \\n        for i in range(len(arr)-1, -1, -1):\\n\\n            while stack and stack[-1] <= arr[i]:\\n                stack.pop()\\n            if stack:\\n                res[i] = stack[-1]\\n                \\n            stack.append(arr[i])\\n            \\n        dummy = ListNode(None)\\n        current = dummy\\n        # print(res)\\n        for i in range(len(res)):\\n            if res[i] == -1:\\n                node = ListNode(arr[i])\\n                current.next = node\\n                current = current.next\\n        return dummy.next\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852467,
                "title": "2487-remove-nodes-from-linked-list-java",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode nextNode = removeNodes(head.next);\\n        if(nextNode.val > head.val){\\n            return nextNode;\\n        }\\n        head.next = nextNode;\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode nextNode = removeNodes(head.next);\\n        if(nextNode.val > head.val){\\n            return nextNode;\\n        }\\n        head.next = nextNode;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852354,
                "title": "java-monotonic-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null) return head;\\n        Stack<ListNode> stk=new Stack<>();\\n        ListNode ptr=head;\\n        while(ptr!=null)\\n        {\\n            if(!stk.isEmpty() && stk.peek().val<ptr.val)\\n            {\\n                ListNode temp=stk.pop();\\n                if(stk.isEmpty())\\n                {\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    stk.peek().next=temp.next;\\n                }   \\n            }\\n            else\\n            {\\n                stk.push(ptr);\\n                ptr=ptr.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        if(head==null) return head;\\n        Stack<ListNode> stk=new Stack<>();\\n        ListNode ptr=head;\\n        while(ptr!=null)\\n        {\\n            if(!stk.isEmpty() && stk.peek().val<ptr.val)\\n            {\\n                ListNode temp=stk.pop();\\n                if(stk.isEmpty())\\n                {\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    stk.peek().next=temp.next;\\n                }   \\n            }\\n            else\\n            {\\n                stk.push(ptr);\\n                ptr=ptr.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852252,
                "title": "stack-solution-o-n",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Similar Problem\\n\\nhttps://leetcode.com/problems/next-greater-element-i/\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        \\n        Stack<ListNode> stack = new Stack<>();\\n        \\n        ListNode node = head;\\n        \\n        while(node != null){\\n            \\n            while(!stack.isEmpty() && stack.peek().val < node.val){\\n                stack.pop();\\n            }\\n            \\n            if(!stack.isEmpty()){\\n                stack.peek().next = node;\\n            }\\n            \\n            stack.push(node);\\n            \\n            node = node.next;\\n        }\\n        \\n        head = null;\\n        \\n        while(!stack.isEmpty()){\\n            head = stack.pop();\\n        }\\n        \\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        \\n        Stack<ListNode> stack = new Stack<>();\\n        \\n        ListNode node = head;\\n        \\n        while(node != null){\\n            \\n            while(!stack.isEmpty() && stack.peek().val < node.val){\\n                stack.pop();\\n            }\\n            \\n            if(!stack.isEmpty()){\\n                stack.peek().next = node;\\n            }\\n            \\n            stack.push(node);\\n            \\n            node = node.next;\\n        }\\n        \\n        head = null;\\n        \\n        while(!stack.isEmpty()){\\n            head = stack.pop();\\n        }\\n        \\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852054,
                "title": "javascript-reverse-tc-o-n-sc-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function(head) {\\n    let cur = reverse(head);\\n    let max = -Infinity;\\n    let ans = null;\\n    let ansCur = null;\\n    \\n    while (cur) {\\n        if (cur.val >= max) {\\n            max = cur.val;\\n            if (!ans) {\\n                ans = cur;\\n                ansCur = cur;\\n            } else {\\n                ansCur.next = cur;\\n                ansCur = ansCur.next;\\n            }\\n        }\\n        cur = cur.next;\\n    }\\n    ansCur.next = null;\\n    \\n    return reverse(ans);\\n};\\n\\nfunction reverse(head) {\\n    let prev = null;\\n    let cur = head;\\n    \\n    while (cur) {\\n        let next = cur.next;    \\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    \\n    return prev;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeNodes = function(head) {\\n    let cur = reverse(head);\\n    let max = -Infinity;\\n    let ans = null;\\n    let ansCur = null;\\n    \\n    while (cur) {\\n        if (cur.val >= max) {\\n            max = cur.val;\\n            if (!ans) {\\n                ans = cur;\\n                ansCur = cur;\\n            } else {\\n                ansCur.next = cur;\\n                ansCur = ansCur.next;\\n            }\\n        }\\n        cur = cur.next;\\n    }\\n    ansCur.next = null;\\n    \\n    return reverse(ans);\\n};\\n\\nfunction reverse(head) {\\n    let prev = null;\\n    let cur = head;\\n    \\n    while (cur) {\\n        let next = cur.next;    \\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n    }\\n    \\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2852047,
                "title": "java-easy-soltuion",
                "content": "```\\nclass Solution {\\n    public Integer[] nextGreaterElements(Integer[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        Integer ans[] = new Integer[nums.length];\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (st.size() > 0 && st.peek() <= nums[i]) {\\n                st.pop();\\n            }\\n\\n            ans[i] = st.size() == 0 ? -1 : st.peek();\\n            st.push(nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public ListNode removeNodes(ListNode head) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        ListNode temp=head;\\n        \\n        while(temp!=null){\\n            list.add(temp.val);\\n            temp=temp.next;\\n        }\\n        \\n        Integer[] arr = new Integer[list.size()];\\n        for(int i=0;i<list.size();i++){\\n            arr[i]=list.get(i);\\n        }\\n        arr = nextGreaterElements(arr);\\n        \\n        //remove nodes\\n        ListNode res = new ListNode(-1);\\n        ListNode ans = res;\\n        \\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==-1){\\n                ListNode node = new ListNode(list.get(i));\\n                ans.next=node;\\n                ans=ans.next;\\n            }\\n        }\\n        return res.next==null ? head : res.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Integer[] nextGreaterElements(Integer[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        Integer ans[] = new Integer[nums.length];\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (st.size() > 0 && st.peek() <= nums[i]) {\\n                st.pop();\\n            }\\n\\n            ans[i] = st.size() == 0 ? -1 : st.peek();\\n            st.push(nums[i]);\\n        }\\n\\n        return ans;\\n    }\\n    \\n    public ListNode removeNodes(ListNode head) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        ListNode temp=head;\\n        \\n        while(temp!=null){\\n            list.add(temp.val);\\n            temp=temp.next;\\n        }\\n        \\n        Integer[] arr = new Integer[list.size()];\\n        for(int i=0;i<list.size();i++){\\n            arr[i]=list.get(i);\\n        }\\n        arr = nextGreaterElements(arr);\\n        \\n        //remove nodes\\n        ListNode res = new ListNode(-1);\\n        ListNode ans = res;\\n        \\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==-1){\\n                ListNode node = new ListNode(list.get(i));\\n                ans.next=node;\\n                ans=ans.next;\\n            }\\n        }\\n        return res.next==null ? head : res.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852013,
                "title": "c-stack-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> arr;\\n        ListNode *p=head,*q=nullptr;\\n        while(p){\\n            arr.push_back(p->val); // store linklist in array\\n            p=p->next;\\n        }\\n        stack<pair<int,int>> st; \\n        for(int i=arr.size()-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({arr[i],1}); // for last element there is no greater element to right of it\\n            }else{\\n                if(st.top().first>arr[i]){ // if there is greater element to right then in pair put -1 with max till element\\n                    st.push({st.top().first,-1});\\n                }else{\\n                    st.push({arr[i],1}); // if current is max till now then put it with 1\\n                }\\n            }\\n        }\\n        p=head;\\n        // which ever has 1 means it has no greater element to right\\n        while(st.size()){\\n            if(st.top().second==1){\\n                p->val = st.top().first;\\n                q=p; // q stores previous pointer\\n                p=p->next;\\n            }\\n            st.pop();\\n        }\\n        q->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> arr;\\n        ListNode *p=head,*q=nullptr;\\n        while(p){\\n            arr.push_back(p->val); // store linklist in array\\n            p=p->next;\\n        }\\n        stack<pair<int,int>> st; \\n        for(int i=arr.size()-1;i>=0;i--){\\n            if(st.empty()){\\n                st.push({arr[i],1}); // for last element there is no greater element to right of it\\n            }else{\\n                if(st.top().first>arr[i]){ // if there is greater element to right then in pair put -1 with max till element\\n                    st.push({st.top().first,-1});\\n                }else{\\n                    st.push({arr[i],1}); // if current is max till now then put it with 1\\n                }\\n            }\\n        }\\n        p=head;\\n        // which ever has 1 means it has no greater element to right\\n        while(st.size()){\\n            if(st.top().second==1){\\n                p->val = st.top().first;\\n                q=p; // q stores previous pointer\\n                p=p->next;\\n            }\\n            st.pop();\\n        }\\n        q->next = nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851955,
                "title": "c-o-n-time-one-pass-with-recursion",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    ListNode* solve(ListNode* head){\\n        //base\\n        if(head->next==NULL){\\n            maxi = max(head->val, maxi);\\n            return head;\\n        }\\n        \\n        //hypo\\n        head->next = solve(head->next);\\n        //lets see if the head can make it to the final list or not\\n        if(head->val<maxi){\\n            // head->next = NULL;\\n            maxi = max(maxi, head->next->val);\\n            return head->next;\\n        }\\n        maxi = max(maxi, head->val);\\n        return head;\\n        \\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        return solve(head);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi = INT_MIN;\\n    ListNode* solve(ListNode* head){\\n        //base\\n        if(head->next==NULL){\\n            maxi = max(head->val, maxi);\\n            return head;\\n        }\\n        \\n        //hypo\\n        head->next = solve(head->next);\\n        //lets see if the head can make it to the final list or not\\n        if(head->val<maxi){\\n            // head->next = NULL;\\n            maxi = max(maxi, head->next->val);\\n            return head->next;\\n        }\\n        maxi = max(maxi, head->val);\\n        return head;\\n        \\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        return solve(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851953,
                "title": "c-100-monotonic-stack-easy",
                "content": "**Explanation**  - Push LL nodes in a monotonic stack. Update *next ptrs on the fly\\n\\n### C++  \\n---\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack <ListNode*> stk;\\n        auto curr = head;\\n        head = new ListNode(INT_MAX, head);\\n        stk.push(head);\\n        while(curr){\\n            while(stk.top()->val<curr->val)\\n                stk.pop();\\n            stk.top()->next = curr;\\n            stk.push(curr);\\n            curr = curr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```\\n\\n**Thanks for reading my contest solution.**\\n[Read More of my Solutions Here...](https://github.com/Suvraneel/LeetCode)",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack <ListNode*> stk;\\n        auto curr = head;\\n        head = new ListNode(INT_MAX, head);\\n        stk.push(head);\\n        while(curr){\\n            while(stk.top()->val<curr->val)\\n                stk.pop();\\n            stk.top()->next = curr;\\n            stk.push(curr);\\n            curr = curr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099840,
                "title": "recursion-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Recursively reach till end of list.\\n2. Once we reach end we compare elements,\\n3. if head->val < head->next then return head->next for next iterations.\\n4. else if head->val > head->next then return head itself ,\\n5. By doing the above two comparisons in line 3 & 4 we are returning the node which contains the maximum value on right side.\\n6. So once our recursion is done we will be having a list of all values removed and only values will be remaining wich are greater to the right side.\\n\\nI know its is a little confusing , but just use pen and paper with a test case and you will have your answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* recur(ListNode* head){\\n        if(head == NULL){\\n            return head;\\n        }\\n        head->next = recur(head->next);\\n        return head->next!=NULL && head->next->val > head->val ? head->next : head ;\\n\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        return recur(head);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* recur(ListNode* head){\\n        if(head == NULL){\\n            return head;\\n        }\\n        head->next = recur(head->next);\\n        return head->next!=NULL && head->next->val > head->val ? head->next : head ;\\n\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        return recur(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099287,
                "title": "simple-as-f-stack-approach",
                "content": "# Intuition\\nThink of stack approach. Use pen & paper and follow the below approach using a test case, and you will understand it.\\n\\n# Approach\\n1. Keep on adding elements in the stack from starting of the list.\\n2. Also while adding check if the current element is greater then the top element of stack or not.\\n3. If current element is greater then top element then keep on popping the stack elements untill the stack becomes empty or you found a element greater then the current element.\\n4. Follow this process untill all elements of lists are traveresed.\\n5. Once you have your stack , its in reverse oreder also its in a form of stack so,\\n6. keep on popping elements from stack and adding it to a new linked list.\\n7. once stack is empty , reverse this list and you have your answer, now return this list.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) ---> as we are creating a new list also.\\n\\n# Code\\n```\\n#include<stack>\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverseList(ListNode* head){\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *forw ;\\n        while(curr != NULL){\\n            forw = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *temp = head;\\n        stack<int> s;\\n        s.push(-1);\\n        //traversing the list.\\n        while(temp!=NULL){\\n            if(temp->val > s.top()){\\n                while(!s.empty() && temp->val > s.top() ){\\n                    s.pop();\\n                }\\n                s.push(temp->val);\\n            }\\n            else{\\n                s.push(temp->val);\\n            }\\n            temp = temp->next;\\n        }\\n        //creating a list of stack elements\\n        ListNode *ans = new ListNode(-1);\\n        ListNode *curr = ans;\\n        while(!s.empty()){\\n            curr->next = new ListNode(s.top());\\n            curr = curr->next;\\n            s.pop();\\n        }\\n        return reverseList(ans->next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<stack>\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    ListNode* reverseList(ListNode* head){\\n        ListNode *prev = NULL;\\n        ListNode *curr = head;\\n        ListNode *forw ;\\n        while(curr != NULL){\\n            forw = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n        return prev;\\n    }\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *temp = head;\\n        stack<int> s;\\n        s.push(-1);\\n        //traversing the list.\\n        while(temp!=NULL){\\n            if(temp->val > s.top()){\\n                while(!s.empty() && temp->val > s.top() ){\\n                    s.pop();\\n                }\\n                s.push(temp->val);\\n            }\\n            else{\\n                s.push(temp->val);\\n            }\\n            temp = temp->next;\\n        }\\n        //creating a list of stack elements\\n        ListNode *ans = new ListNode(-1);\\n        ListNode *curr = ans;\\n        while(!s.empty()){\\n            curr->next = new ListNode(s.top());\\n            curr = curr->next;\\n            s.pop();\\n        }\\n        return reverseList(ans->next);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4089525,
                "title": "python3-solved-using-unordered-set-montonic-stack-2-pointer-in-place-modifying",
                "content": "# Intuition\\nBasically, the problem is mainly concerned about checking to see if every node has a \"next-larger\" node value. This should ring-a-bell that this problem could potentially be solved utilizing a monotonic stack DS. \\n\\n# Approach\\nIdea is to do two linear passes. First linear pass is to register all positions in linked list input that must be deleted utilizing the monotonic stack, checking to see if for every current node you iterate upon, it could potentially serve as \"next-larger\" node w/ respect to any of the preceding nodes (for node pos=> I used 0-indexing starting from head; but it doesn\\'t matter; just be consistent). Then, for 2nd pass, I utilized prev, and cur, and for every current node I check if I should delete (referred by \"cur\"), I simply have to do O(1) membership check operation upon unordered set. If I must delete cur referred node, I can just make sure the prev => cur link is updated properly before I shift prev pointer to whever cur node is if the current node shouldn\\'t be deleted. In this way, I am modifying the L.L input in-place without having to utilize extra memory creating another L.L instance. Lastly, I utilized a dummy Node to refer to head, because this makes it easy for me to check for nodes to be deleted starting directly from \"head\" node. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        #Basically, this problem is all about finding the \"next larger\" node w/ respect to\\n        #every current node if it exists! For this, we can utilize monotonic decreasing stack to help us! \\n\\n        #In stack, we will store for each node, its position and its node value as \\n        #tuple => (pos, node_value)\\n        stack = [] \\n        mustDelete = set() \\n        #first linear traversal of nodes => to find positions of nodes that should get deleted! \\n        cur = head \\n        #we\\'ll assume head node is pos 0, next node from head is pos1, and so on...\\n        pos = 0 \\n        #as long as cur refers to non-null node... \\n        while cur:\\n            #Get current node value! \\n            curVal = cur.val \\n            #this means top element of stack has next larger! \\n            while(stack and stack[-1][1] < curVal): \\n                stackTop = stack.pop() \\n                #add top element of stack\\'s node pos to must delete set!\\n                mustDelete.add(stackTop[0])\\n            #before we move on, we must push to top of stack! \\n            stack.append((pos, curVal))\\n            #also, next node is at 1 higher position! \\n            pos += 1 \\n            #also update cur node ref to next node! \\n            cur = cur.next \\n        \\n        #now, with the set of node pos. we must skip over and \"delete\", we have to modify L.L input\\n        #accordingly! \\n\\n        #I can do this with simple 2 ptr: prev and next! \\n        #Also, to make our lives easier, I will allocate a dummy node initially pointing to head node! \\n\\n        dummyNode = ListNode()\\n        dummyNode.next = head \\n        #initialize two pointers! \\n        prev, cur = dummyNode, head \\n        #initial pos is 0 cause cur points to head node initially! \\n        curPos = 0 \\n        #as long as we still have non-null node to check to see if we should delete it or not, keep proceeding\\n        #and modifying our pass-by-ref L.L input! \\n\\n        while cur: \\n            #check if current node corresponding pos is in the deleted set! \\n            #if it is, we delete it by simply shifting cur node to next and re-update prev node\\'s next link! \\n            if curPos in mustDelete:\\n                cur = cur.next \\n                prev.next = cur \\n            #now, if we don\\'t need to delete current node, then we keep the link btw prev and cur nodes! \\n            #we simply have to bring prev to where-ever current node is referring to and check next non-null\\n            #node if it exists! \\n            else:\\n                prev = cur \\n                cur = cur.next \\n            curPos += 1 \\n        \\n        #at the end, all the links should be updated so all nodes that needed to be deleted will be deleted! \\n        return dummyNode.next \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Monotonic Stack"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        #Basically, this problem is all about finding the \"next larger\" node w/ respect to\\n        #every current node if it exists! For this, we can utilize monotonic decreasing stack to help us! \\n\\n        #In stack, we will store for each node, its position and its node value as \\n        #tuple => (pos, node_value)\\n        stack = [] \\n        mustDelete = set() \\n        #first linear traversal of nodes => to find positions of nodes that should get deleted! \\n        cur = head \\n        #we\\'ll assume head node is pos 0, next node from head is pos1, and so on...\\n        pos = 0 \\n        #as long as cur refers to non-null node... \\n        while cur:\\n            #Get current node value! \\n            curVal = cur.val \\n            #this means top element of stack has next larger! \\n            while(stack and stack[-1][1] < curVal): \\n                stackTop = stack.pop() \\n                #add top element of stack\\'s node pos to must delete set!\\n                mustDelete.add(stackTop[0])\\n            #before we move on, we must push to top of stack! \\n            stack.append((pos, curVal))\\n            #also, next node is at 1 higher position! \\n            pos += 1 \\n            #also update cur node ref to next node! \\n            cur = cur.next \\n        \\n        #now, with the set of node pos. we must skip over and \"delete\", we have to modify L.L input\\n        #accordingly! \\n\\n        #I can do this with simple 2 ptr: prev and next! \\n        #Also, to make our lives easier, I will allocate a dummy node initially pointing to head node! \\n\\n        dummyNode = ListNode()\\n        dummyNode.next = head \\n        #initialize two pointers! \\n        prev, cur = dummyNode, head \\n        #initial pos is 0 cause cur points to head node initially! \\n        curPos = 0 \\n        #as long as we still have non-null node to check to see if we should delete it or not, keep proceeding\\n        #and modifying our pass-by-ref L.L input! \\n\\n        while cur: \\n            #check if current node corresponding pos is in the deleted set! \\n            #if it is, we delete it by simply shifting cur node to next and re-update prev node\\'s next link! \\n            if curPos in mustDelete:\\n                cur = cur.next \\n                prev.next = cur \\n            #now, if we don\\'t need to delete current node, then we keep the link btw prev and cur nodes! \\n            #we simply have to bring prev to where-ever current node is referring to and check next non-null\\n            #node if it exists! \\n            else:\\n                prev = cur \\n                cur = cur.next \\n            curPos += 1 \\n        \\n        #at the end, all the links should be updated so all nodes that needed to be deleted will be deleted! \\n        return dummyNode.next \\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084816,
                "title": "using-monotonic-stack",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<ListNode> stack = new Stack<ListNode>();\\n        while(head != null){\\n            while(!stack.isEmpty() && stack.peek().val < head.val){\\n                stack.pop();\\n            }\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null; \\n            stack.push(temp);\\n        }\\n\\n        ListNode result = new ListNode(0);\\n        while(!stack.isEmpty()){\\n            ListNode temp = stack.pop();\\n            temp.next = result.next;\\n            result.next = temp;\\n        }\\n\\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        Stack<ListNode> stack = new Stack<ListNode>();\\n        while(head != null){\\n            while(!stack.isEmpty() && stack.peek().val < head.val){\\n                stack.pop();\\n            }\\n            ListNode temp = head;\\n            head = head.next;\\n            temp.next = null; \\n            stack.push(temp);\\n        }\\n\\n        ListNode result = new ListNode(0);\\n        while(!stack.isEmpty()){\\n            ListNode temp = stack.pop();\\n            temp.next = result.next;\\n            result.next = temp;\\n        }\\n\\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082510,
                "title": "c-recursive-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursive method to get the required list after element i. And combine i or not  as the return value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* node = reform(head);\\n        return node->next;\\n    }\\n\\n    ListNode* reform(ListNode* head) {\\n        // cout << \"Reform Start\" << endl;\\n        // print(head);\\n        if (head->next == nullptr) {\\n            // The lastone, return itself\\n            // ListNode node = (ListNode){head->val, head};\\n            // cout << ((&node)->next) << endl;\\n            // print((&node)->next);\\n            // return &node;\\n            ListNode* node = (ListNode*)malloc(sizeof(ListNode));\\n            node->val = head->val;\\n            node->next = head;\\n            return node;\\n        } else {\\n            ListNode* node = reform(head->next);\\n            if (head->val >= node->val) {\\n                // This node is not smaller than the following list, add this node to the front of the list\\n                // cout << \"HIT HERE\" << endl;\\n                head->next = node->next;\\n                node->val = head->val;\\n                node->next = head;\\n            }\\n            // Else, just return the node\\n            // cout << \"Reform Over\" << endl;\\n            // cout << (node->next) << endl;\\n            // print(node->next);\\n            return node;\\n        }\\n    }\\n\\n    void print(ListNode* head) {\\n        ListNode* now = head;\\n        while (now != nullptr) {\\n            cout << now->val << \"-\";\\n            now = now->next;\\n        }\\n        cout << \"\" << endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* node = reform(head);\\n        return node->next;\\n    }\\n\\n    ListNode* reform(ListNode* head) {\\n        // cout << \"Reform Start\" << endl;\\n        // print(head);\\n        if (head->next == nullptr) {\\n            // The lastone, return itself\\n            // ListNode node = (ListNode){head->val, head};\\n            // cout << ((&node)->next) << endl;\\n            // print((&node)->next);\\n            // return &node;\\n            ListNode* node = (ListNode*)malloc(sizeof(ListNode));\\n            node->val = head->val;\\n            node->next = head;\\n            return node;\\n        } else {\\n            ListNode* node = reform(head->next);\\n            if (head->val >= node->val) {\\n                // This node is not smaller than the following list, add this node to the front of the list\\n                // cout << \"HIT HERE\" << endl;\\n                head->next = node->next;\\n                node->val = head->val;\\n                node->next = head;\\n            }\\n            // Else, just return the node\\n            // cout << \"Reform Over\" << endl;\\n            // cout << (node->next) << endl;\\n            // print(node->next);\\n            return node;\\n        }\\n    }\\n\\n    void print(ListNode* head) {\\n        ListNode* now = head;\\n        while (now != nullptr) {\\n            cout << now->val << \"-\";\\n            now = now->next;\\n        }\\n        cout << \"\" << endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4082261,
                "title": "easy-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n     ListNode curr=head;\\n     int n=0;\\n     while(curr!=null){\\n         n++;\\n         curr=curr.next;\\n     }\\n     int a[]=new int [n];\\n     curr=head;\\n     int i=0,max=0;\\n     while(curr!=null){\\n         a[i++]=curr.val;\\n         curr=curr.next;\\n     }\\n     int right[]=new int [n];\\n     for(int j=n-1;j>=0;j--){\\n         right[j]=Math.max(max,a[j]);\\n         max=Math.max(max,a[j]);\\n     }\\n     ListNode dummy=null;\\n     ListNode curr1=null;\\n     for(int k=0;k<n;k++){\\n         if(a[k]>=right[k]){\\n             ListNode newnode=new ListNode(a[k]);\\n             if(curr1==null){\\n                 curr1=newnode;\\n                 dummy=curr1;\\n             }\\n             else{\\n                 curr1.next=newnode;\\n                 curr1=newnode;\\n             }\\n         }\\n     }\\nreturn dummy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n     ListNode curr=head;\\n     int n=0;\\n     while(curr!=null){\\n         n++;\\n         curr=curr.next;\\n     }\\n     int a[]=new int [n];\\n     curr=head;\\n     int i=0,max=0;\\n     while(curr!=null){\\n         a[i++]=curr.val;\\n         curr=curr.next;\\n     }\\n     int right[]=new int [n];\\n     for(int j=n-1;j>=0;j--){\\n         right[j]=Math.max(max,a[j]);\\n         max=Math.max(max,a[j]);\\n     }\\n     ListNode dummy=null;\\n     ListNode curr1=null;\\n     for(int k=0;k<n;k++){\\n         if(a[k]>=right[k]){\\n             ListNode newnode=new ListNode(a[k]);\\n             if(curr1==null){\\n                 curr1=newnode;\\n                 dummy=curr1;\\n             }\\n             else{\\n                 curr1.next=newnode;\\n                 curr1=newnode;\\n             }\\n         }\\n     }\\nreturn dummy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081686,
                "title": "beats-100-time-simple-code-with-o-n-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition was brute force which obviously was O(n2)\\nbut while coding out brute force i observed we are only keeping \\nlast element and its subsequent greater element, and then ots subsequent greter element, and so on.\\n\\n(I always try to not do linked list questions with recursion. Recursion uses a recursive stack which in then is taking up O(N) space. If i cannot do a problem in O(1) space. Then only explore, recursion, stacks, maps, vectors(arrays)).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach was basic.\\n 1) Inplace reversal.\\n 2) Make two pointers,\\n     One to travel the reversed linked list,\\n     Second to not include the smaller than last element.\\n 3) Reverse back the Second pointer which is the desired response and      return.\\n    Note:  I am only making new Nodes which then just alters connections   or next addresses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(3N) == O(N) as we travel the list thrice. One to reverse, second to compare and third to reverse again.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseLL(ListNode* head) {\\n        ListNode* forward = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        // Reverse the linked list.\\n        ios:: sync_with_stdio(false);\\n\\t\\tcin.tie(nullptr);\\n\\t\\tcout.tie(nullptr);\\n\\n        ListNode* rev = reverseLL(head);\\n\\n        ListNode* curr = rev;\\n        ListNode* maxNode = curr;\\n\\n        while(curr != nullptr) {\\n            if(curr->val >= maxNode->val){\\n                maxNode = curr;\\n            }else{\\n                maxNode->next = curr->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        return reverseLL(rev);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseLL(ListNode* head) {\\n        ListNode* forward = nullptr;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        while (curr != nullptr) {\\n            forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        // Reverse the linked list.\\n        ios:: sync_with_stdio(false);\\n\\t\\tcin.tie(nullptr);\\n\\t\\tcout.tie(nullptr);\\n\\n        ListNode* rev = reverseLL(head);\\n\\n        ListNode* curr = rev;\\n        ListNode* maxNode = curr;\\n\\n        while(curr != nullptr) {\\n            if(curr->val >= maxNode->val){\\n                maxNode = curr;\\n            }else{\\n                maxNode->next = curr->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        return reverseLL(rev);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4075560,
                "title": "very-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> req(vector<int>&v)\\n{\\n    int n=v.size();\\n    if(n==0)\\n        return v;\\n    vector<int>v1;\\n    int lg=v[n-1];\\n    v1.push_back(lg);\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        if(v[i]>=lg)\\n        {\\n            v1.push_back(v[i]);\\n            lg=v[i];\\n        }\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return v1;\\n}\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        vector<int> v;\\n        while(temp != NULL){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        vector<int> a = req(v);\\n        /*\\n        for(int i = 0;i<v.size();i++){\\n            int c = 0;\\n            for(int j = i+1;j<v.size();j++){\\n                if(v[i]<v[j]){\\n                    c = 1;\\n                    break;\\n                }\\n            }\\n            if(c == 0){\\n                a.push_back(v[i]);\\n            }\\n        }\\n        */\\n        ListNode* tem = new ListNode(a[0]);\\n        ListNode* ans = tem;\\n        for(int i = 1;i<a.size();i++){\\n            ListNode* t = new ListNode(a[i]);\\n            tem->next = t;\\n            tem = tem->next;\\n            //tem->next = NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> req(vector<int>&v)\\n{\\n    int n=v.size();\\n    if(n==0)\\n        return v;\\n    vector<int>v1;\\n    int lg=v[n-1];\\n    v1.push_back(lg);\\n    for(int i=n-2;i>=0;i--)\\n    {\\n        if(v[i]>=lg)\\n        {\\n            v1.push_back(v[i]);\\n            lg=v[i];\\n        }\\n    }\\n    reverse(v1.begin(),v1.end());\\n    return v1;\\n}\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* temp = head;\\n        vector<int> v;\\n        while(temp != NULL){\\n            v.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        vector<int> a = req(v);\\n        /*\\n        for(int i = 0;i<v.size();i++){\\n            int c = 0;\\n            for(int j = i+1;j<v.size();j++){\\n                if(v[i]<v[j]){\\n                    c = 1;\\n                    break;\\n                }\\n            }\\n            if(c == 0){\\n                a.push_back(v[i]);\\n            }\\n        }\\n        */\\n        ListNode* tem = new ListNode(a[0]);\\n        ListNode* ans = tem;\\n        for(int i = 1;i<a.size();i++){\\n            ListNode* t = new ListNode(a[i]);\\n            tem->next = t;\\n            tem = tem->next;\\n            //tem->next = NULL;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075314,
                "title": "easy-c-with-o-nlogn-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n      vector<int>v;\\n       ListNode* temp=head;\\n       ListNode* var=new ListNode(0);\\n       ListNode* cur=var;\\n       while(temp!=NULL)\\n       {\\n         while(1){\\n          if(v.empty())\\n          {\\n            v.push_back(temp->val);\\n            break;\\n          }\\n          else if(v.back()<temp->val)\\n          {\\n            v.pop_back();\\n          }\\n          else if(v.back()>=temp->val)\\n          {\\n            v.push_back(temp->val);\\n            break;\\n          }\\n         }\\n         temp=temp->next;\\n       }\\n       for(int i=0;i<v.size();i++)\\n       {\\n         cur->next=new ListNode(v[i]);\\n         cur=cur->next;\\n       }\\n       return var->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n      vector<int>v;\\n       ListNode* temp=head;\\n       ListNode* var=new ListNode(0);\\n       ListNode* cur=var;\\n       while(temp!=NULL)\\n       {\\n         while(1){\\n          if(v.empty())\\n          {\\n            v.push_back(temp->val);\\n            break;\\n          }\\n          else if(v.back()<temp->val)\\n          {\\n            v.pop_back();\\n          }\\n          else if(v.back()>=temp->val)\\n          {\\n            v.push_back(temp->val);\\n            break;\\n          }\\n         }\\n         temp=temp->next;\\n       }\\n       for(int i=0;i<v.size();i++)\\n       {\\n         cur->next=new ListNode(v[i]);\\n         cur=cur->next;\\n       }\\n       return var->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069520,
                "title": "c-simple-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode * findNewHead(ListNode* prev, ListNode* curr){\\n        if(curr == NULL)\\n            return prev;\\n        ListNode* newNode = findNewHead(curr,curr->next);\\n        if(prev != NULL){\\n            if(prev->val >= newNode->val){\\n                prev->next = newNode;\\n                return prev;\\n            }\\n            else{\\n                return newNode;\\n            }\\n        }else{\\n            return newNode;\\n        }\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *newHead = findNewHead(NULL,head);\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode * findNewHead(ListNode* prev, ListNode* curr){\\n        if(curr == NULL)\\n            return prev;\\n        ListNode* newNode = findNewHead(curr,curr->next);\\n        if(prev != NULL){\\n            if(prev->val >= newNode->val){\\n                prev->next = newNode;\\n                return prev;\\n            }\\n            else{\\n                return newNode;\\n            }\\n        }else{\\n            return newNode;\\n        }\\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *newHead = findNewHead(NULL,head);\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063584,
                "title": "python-stack-o-n-time-simple-solution",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org=[]\\n        a=b=ListNode(0)\\n        itr=head\\n        while itr:\\n            org+=[itr.val]\\n            itr=itr.next\\n        org=org[::-1]\\n        stack=[]\\n        for i in org:\\n            if not stack or i>=stack[-1]:\\n                stack.append(i)\\n        for i in stack[::-1]:\\n            a.next=ListNode(i)\\n            a=a.next\\n        return b.next\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        org=[]\\n        a=b=ListNode(0)\\n        itr=head\\n        while itr:\\n            org+=[itr.val]\\n            itr=itr.next\\n        org=org[::-1]\\n        stack=[]\\n        for i in org:\\n            if not stack or i>=stack[-1]:\\n                stack.append(i)\\n        for i in stack[::-1]:\\n            a.next=ListNode(i)\\n            a=a.next\\n        return b.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056966,
                "title": "simple-solution-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr=head;\\n        int n=0;\\n        while(curr!=null){\\n            n++;\\n            curr=curr.next;\\n        }\\n        int a[]=new int[n];\\n        curr=head;\\n        int i=0,max=0;\\n        while(curr!=null){\\na[i++]=curr.val;\\ncurr=curr.next;\\n        }\\n        int right[]=new int[n];\\n        \\n        for(int j=n-1;j>=0;j--){\\nright[j]=Math.max(max,a[j]);\\nmax=Math.max(max,a[j]);\\n        }\\n        ListNode dummy=null;\\n        ListNode curr1=null;\\n        for(int j=0;j<n;j++){\\n               if(a[j]>=right[j]){\\n              ListNode newnode=new ListNode(a[j]);\\n              if(curr1==null){\\n                  \\n                  curr1=newnode;\\n                  dummy=curr1;\\n              }\\n              else{\\n                  curr1.next=newnode;\\n                  curr1=newnode;\\n              }\\n               }\\n        }\\n        return dummy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode curr=head;\\n        int n=0;\\n        while(curr!=null){\\n            n++;\\n            curr=curr.next;\\n        }\\n        int a[]=new int[n];\\n        curr=head;\\n        int i=0,max=0;\\n        while(curr!=null){\\na[i++]=curr.val;\\ncurr=curr.next;\\n        }\\n        int right[]=new int[n];\\n        \\n        for(int j=n-1;j>=0;j--){\\nright[j]=Math.max(max,a[j]);\\nmax=Math.max(max,a[j]);\\n        }\\n        ListNode dummy=null;\\n        ListNode curr1=null;\\n        for(int j=0;j<n;j++){\\n               if(a[j]>=right[j]){\\n              ListNode newnode=new ListNode(a[j]);\\n              if(curr1==null){\\n                  \\n                  curr1=newnode;\\n                  dummy=curr1;\\n              }\\n              else{\\n                  curr1.next=newnode;\\n                  curr1=newnode;\\n              }\\n               }\\n        }\\n        return dummy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053532,
                "title": "java-solution",
                "content": "# Intuition\\n- Reverse the LL\\n- Eliminate the nodes\\n- Again reverse LL\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        ListNode dummy1=dummy;\\n        ListNode get_rev=reverse(head);\\n        ListNode curr=get_rev;\\n        int max=0;\\n        while(curr!=null){\\n            max=Math.max(max,curr.val);\\n           \\n            if(max==curr.val){\\n                ListNode temp=new ListNode(max);\\n                dummy.next=temp;\\n                dummy=dummy.next;\\n            }\\n            curr=curr.next;\\n        }\\n    \\n        return reverse(dummy1.next);\\n    }\\n    //reversing the linkedlist\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n        ListNode dummy=new ListNode(-1);\\n        ListNode dummy1=dummy;\\n        ListNode get_rev=reverse(head);\\n        ListNode curr=get_rev;\\n        int max=0;\\n        while(curr!=null){\\n            max=Math.max(max,curr.val);\\n           \\n            if(max==curr.val){\\n                ListNode temp=new ListNode(max);\\n                dummy.next=temp;\\n                dummy=dummy.next;\\n            }\\n            curr=curr.next;\\n        }\\n    \\n        return reverse(dummy1.next);\\n    }\\n    //reversing the linkedlist\\n    public ListNode reverse(ListNode head){\\n        ListNode prev=null;\\n        ListNode curr=head;\\n        while(curr!=null){\\n            ListNode next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050482,
                "title": "monotonic-stack-o-n-o-n",
                "content": "# Intuition\\nIf for an element x, a next greater element exists then x needs to be removed. NGE is solved through Monotonic decreasing stack.\\n\\n# Approach\\nMaintain Monotonic stack. If you pop something from the stack, remove its corresponding node from LL. Removal needs to store prev pointer. The prev pointer has to be updated for the next iteration based on whether we found something to pop or not.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack = []\\n        dummy = ListNode()\\n        dummy.next = head\\n        prev = dummy\\n        curr = head\\n        while curr:\\n            found = False\\n            while stack and stack[-1].next.val < curr.val:\\n                prev_smaller = stack.pop()\\n                found = True\\n            if found:\\n                prev_smaller.next = curr\\n                stack.append(prev_smaller)\\n                prev = curr\\n                curr = curr.next\\n            else:\\n                stack.append(prev)\\n                prev = curr\\n                curr = curr.next\\n        return dummy.next\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        stack = []\\n        dummy = ListNode()\\n        dummy.next = head\\n        prev = dummy\\n        curr = head\\n        while curr:\\n            found = False\\n            while stack and stack[-1].next.val < curr.val:\\n                prev_smaller = stack.pop()\\n                found = True\\n            if found:\\n                prev_smaller.next = curr\\n                stack.append(prev_smaller)\\n                prev = curr\\n                curr = curr.next\\n            else:\\n                stack.append(prev)\\n                prev = curr\\n                curr = curr.next\\n        return dummy.next\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050356,
                "title": "turn-ll-into-doubly-linked-list-o-1-space-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        p1 = head\\n        prev = None\\n        # turn LL into DLL\\n        while p1:\\n            p1.prev = prev\\n            prev = p1\\n            p1 = p1.next\\n        \\n        # max_v will be tail val\\n        max_v = prev.val\\n        # set curr to be one node from tail as we\\'ll never delete tail\\n        curr = prev.prev\\n        \\n        # iterate backwards through list, on each node check if needs to be deleted\\n        while curr.prev:\\n            if curr.val < max_v:\\n                curr.prev.next = curr.next\\n                nxt = curr.prev\\n                curr.prev = None\\n                curr = nxt\\n            else:\\n                max_v = curr.val\\n                curr = curr.prev\\n\\n        # edge case, we need to delete the last node\\n        if curr.val < max_v:\\n            return curr.next\\n        \\n        return curr\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        p1 = head\\n        prev = None\\n        # turn LL into DLL\\n        while p1:\\n            p1.prev = prev\\n            prev = p1\\n            p1 = p1.next\\n        \\n        # max_v will be tail val\\n        max_v = prev.val\\n        # set curr to be one node from tail as we\\'ll never delete tail\\n        curr = prev.prev\\n        \\n        # iterate backwards through list, on each node check if needs to be deleted\\n        while curr.prev:\\n            if curr.val < max_v:\\n                curr.prev.next = curr.next\\n                nxt = curr.prev\\n                curr.prev = None\\n                curr = nxt\\n            else:\\n                max_v = curr.val\\n                curr = curr.prev\\n\\n        # edge case, we need to delete the last node\\n        if curr.val < max_v:\\n            return curr.next\\n        \\n        return curr\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047562,
                "title": "write-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode reverseList(ListNode head) {\\n        ListNode current=head;\\n        ListNode prev=null;\\n        ListNode next=null;\\n        while(current!=null){\\n   next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n    public ListNode removeNodes(ListNode head) {\\n        head= reverseList(head);\\n        ListNode temp=head;\\n        int max=temp.val;\\n        while(temp.next!=null){\\n            if(max>temp.next.val){\\n                ListNode pre=temp.next;\\n                temp.next=pre.next;\\n            }\\n            else{\\n                max=temp.next.val;\\n                temp=temp.next;\\n                \\n            }\\n\\n        }\\n         head= reverseList(head);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode reverseList(ListNode head) {\\n        ListNode current=head;\\n        ListNode prev=null;\\n        ListNode next=null;\\n        while(current!=null){\\n   next = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = next;\\n        }\\n        head = prev;\\n        return head;\\n    }\\n    public ListNode removeNodes(ListNode head) {\\n        head= reverseList(head);\\n        ListNode temp=head;\\n        int max=temp.val;\\n        while(temp.next!=null){\\n            if(max>temp.next.val){\\n                ListNode pre=temp.next;\\n                temp.next=pre.next;\\n            }\\n            else{\\n                max=temp.next.val;\\n                temp=temp.next;\\n                \\n            }\\n\\n        }\\n         head= reverseList(head);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047363,
                "title": "c-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL,*curr=head,*nxt=NULL;\\n            while(curr)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n        return head=prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverseList(head);\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val > temp->next->val) {\\n                temp->next = temp->next->next;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        head = reverseList(head);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode *prev=NULL,*curr=head,*nxt=NULL;\\n            while(curr)\\n            {\\n                nxt=curr->next;\\n                curr->next=prev;\\n                prev=curr;\\n                curr=nxt;\\n            }\\n        return head=prev;\\n    }\\n\\n    ListNode* removeNodes(ListNode* head) {\\n        head = reverseList(head);\\n        ListNode *temp = head;\\n        while(temp->next) {\\n            if(temp->val > temp->next->val) {\\n                temp->next = temp->next->next;\\n            }\\n            else {\\n                temp = temp->next;\\n            }\\n        }\\n        head = reverseList(head);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046057,
                "title": "using-stack-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> arr;\\n        ListNode *p=head,*q=nullptr;\\n        while(p){\\n            arr.push_back(p->val); // store linklist in array\\n            p=p->next;\\n        }\\n       stack<int> st;\\n       st.push(arr[arr.size()-1]);\\n       for(int i=arr.size()-2;i>=0;i--){\\n           if(st.top()<=arr[i]){\\n               st.push(arr[i]);\\n           }\\n       }\\n       p=head;\\n       while(st.size()){\\n           p->val=st.top();\\n          q=p;\\n           p=p->next;\\n           st.pop();\\n       }\\n       q->next=nullptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        vector<int> arr;\\n        ListNode *p=head,*q=nullptr;\\n        while(p){\\n            arr.push_back(p->val); // store linklist in array\\n            p=p->next;\\n        }\\n       stack<int> st;\\n       st.push(arr[arr.size()-1]);\\n       for(int i=arr.size()-2;i>=0;i--){\\n           if(st.top()<=arr[i]){\\n               st.push(arr[i]);\\n           }\\n       }\\n       p=head;\\n       while(st.size()){\\n           p->val=st.top();\\n          q=p;\\n           p=p->next;\\n           st.pop();\\n       }\\n       q->next=nullptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044319,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        \\n        N = len(lst)\\n        rightMax = -1\\n        cleaned = []\\n        for i in range(N-1, -1, -1):\\n            if lst[i] >= rightMax:\\n                cleaned.append(lst[i])\\n            rightMax = max(rightMax, lst[i]) \\n\\n        N = len(cleaned)\\n        root = ListNode(cleaned[N-1])\\n        tmp = root\\n        for i in range(N-2, -1, -1):\\n            nxt = ListNode(cleaned[i])\\n            tmp.next = nxt\\n            tmp = nxt\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst = []\\n        while head != None:\\n            lst.append(head.val)\\n            head = head.next\\n        \\n        N = len(lst)\\n        rightMax = -1\\n        cleaned = []\\n        for i in range(N-1, -1, -1):\\n            if lst[i] >= rightMax:\\n                cleaned.append(lst[i])\\n            rightMax = max(rightMax, lst[i]) \\n\\n        N = len(cleaned)\\n        root = ListNode(cleaned[N-1])\\n        tmp = root\\n        for i in range(N-2, -1, -1):\\n            nxt = ListNode(cleaned[i])\\n            tmp.next = nxt\\n            tmp = nxt\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043515,
                "title": "easy-solution-in-python-beats-96-users-in-python",
                "content": "Approach: iterate form last node , because if we iterate from first to last we cant delete wanted elements accurately so its better to do from last to first by comparing larger elements \\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        prev = None\\n        curr = head\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n        head = prev\\n        curr = head\\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        prev = None\\n        current = head\\n        while current:\\n            next_node = current.next\\n            current.next = prev\\n            prev = current\\n            current = next_node\\n        head = prev\\n        return head\\n",
                "solutionTags": [],
                "code": "Approach: iterate form last node , because if we iterate from first to last we cant delete wanted elements accurately so its better to do from last to first by comparing larger elements \\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeNodes(self, head):\\n        prev = None\\n        curr = head\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n        head = prev\\n        curr = head\\n        while curr.next:\\n            if curr.val > curr.next.val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        prev = None\\n        current = head\\n        while current:\\n            next_node = current.next\\n            current.next = prev\\n            prev = current\\n            current = next_node\\n        head = prev\\n        return head\\n",
                "codeTag": "Java"
            },
            {
                "id": 4043121,
                "title": "c-simple-solution-easy-to-understand-anurag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* Reverse(ListNode* &head){\\n    ListNode* prev=NULL;\\n    ListNode* cur=head;\\n    ListNode* forw=NULL;\\n    while(cur){\\n        forw=cur->next;\\n        cur->next=prev;\\n        prev=cur;\\n        cur=forw;\\n    }\\n    return prev;\\n}\\nvoid Remove(ListNode* &c,ListNode* &n){\\n    if(c->next==NULL){\\n        return ;\\n    }\\n    if(c->val>n->val){\\n        c->next=n->next;\\n        n=n->next;\\n        Remove(c,n);\\n    }\\n    c=n;\\n    if(n==NULL){\\n        return ;\\n    }\\n    n=n->next;\\n    Remove(c,n);\\n}\\nListNode* removeNodes(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return head;\\n    }\\n        ListNode* ans=Reverse(head);\\n        ListNode* c=ans;\\n        ListNode* n=ans->next;\\n        Remove(c,n);\\n        ListNode* cans=Reverse(ans);\\n        return cans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* Reverse(ListNode* &head){\\n    ListNode* prev=NULL;\\n    ListNode* cur=head;\\n    ListNode* forw=NULL;\\n    while(cur){\\n        forw=cur->next;\\n        cur->next=prev;\\n        prev=cur;\\n        cur=forw;\\n    }\\n    return prev;\\n}\\nvoid Remove(ListNode* &c,ListNode* &n){\\n    if(c->next==NULL){\\n        return ;\\n    }\\n    if(c->val>n->val){\\n        c->next=n->next;\\n        n=n->next;\\n        Remove(c,n);\\n    }\\n    c=n;\\n    if(n==NULL){\\n        return ;\\n    }\\n    n=n->next;\\n    Remove(c,n);\\n}\\nListNode* removeNodes(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return head;\\n    }\\n        ListNode* ans=Reverse(head);\\n        ListNode* c=ans;\\n        ListNode* n=ans->next;\\n        Remove(c,n);\\n        ListNode* cans=Reverse(ans);\\n        return cans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043119,
                "title": "c-simple-solution-easy-to-understand-anurag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* Reverse(ListNode* &head){\\n    ListNode* prev=NULL;\\n    ListNode* cur=head;\\n    ListNode* forw=NULL;\\n    while(cur){\\n        forw=cur->next;\\n        cur->next=prev;\\n        prev=cur;\\n        cur=forw;\\n    }\\n    return prev;\\n}\\nvoid Remove(ListNode* &c,ListNode* &n){\\n    if(c->next==NULL){\\n        return ;\\n    }\\n    if(c->val>n->val){\\n        c->next=n->next;\\n        n=n->next;\\n        Remove(c,n);\\n    }\\n    c=n;\\n    if(n==NULL){\\n        return ;\\n    }\\n    n=n->next;\\n    Remove(c,n);\\n}\\nListNode* removeNodes(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return head;\\n    }\\n        ListNode* ans=Reverse(head);\\n        ListNode* c=ans;\\n        ListNode* n=ans->next;\\n        Remove(c,n);\\n        ListNode* cans=Reverse(ans);\\n        return cans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nListNode* Reverse(ListNode* &head){\\n    ListNode* prev=NULL;\\n    ListNode* cur=head;\\n    ListNode* forw=NULL;\\n    while(cur){\\n        forw=cur->next;\\n        cur->next=prev;\\n        prev=cur;\\n        cur=forw;\\n    }\\n    return prev;\\n}\\nvoid Remove(ListNode* &c,ListNode* &n){\\n    if(c->next==NULL){\\n        return ;\\n    }\\n    if(c->val>n->val){\\n        c->next=n->next;\\n        n=n->next;\\n        Remove(c,n);\\n    }\\n    c=n;\\n    if(n==NULL){\\n        return ;\\n    }\\n    n=n->next;\\n    Remove(c,n);\\n}\\nListNode* removeNodes(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return head;\\n    }\\n        ListNode* ans=Reverse(head);\\n        ListNode* c=ans;\\n        ListNode* n=ans->next;\\n        Remove(c,n);\\n        ListNode* cans=Reverse(ans);\\n        return cans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040973,
                "title": "easy-stack-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) \\n    {\\n     Stack<ListNode> st=new Stack<>();\\n        ListNode temp=head;\\n        while(temp!=null)\\n        {\\n            while(!st.isEmpty() && st.peek().val<temp.val)\\n            {\\n                st.pop();\\n            }\\n            st.push(temp);\\n            temp=temp.next;\\n        }\\n        ListNode dummy=null;\\n        while(!st.isEmpty())\\n        {\\n            temp=st.pop();\\n            temp.next=dummy;\\n            dummy=temp;\\n        }\\n        return dummy;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) \\n    {\\n     Stack<ListNode> st=new Stack<>();\\n        ListNode temp=head;\\n        while(temp!=null)\\n        {\\n            while(!st.isEmpty() && st.peek().val<temp.val)\\n            {\\n                st.pop();\\n            }\\n            st.push(temp);\\n            temp=temp.next;\\n        }\\n        ListNode dummy=null;\\n        while(!st.isEmpty())\\n        {\\n            temp=st.pop();\\n            temp.next=dummy;\\n            dummy=temp;\\n        }\\n        return dummy;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040666,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* p=head,*q=NULL;\\n        vector<int>data;\\n        while(p!=NULL)\\n        {\\n            data.push_back(p->val);\\n            p=p->next;\\n        }\\n\\n        \\n        stack<pair<int,int>>st;\\n        for(int i=data.size()-1;i>=0;i--)\\n        {\\n            if(st.empty())\\n            {\\n                st.push({data[i],1});\\n            }\\n            else\\n            {\\n                if(st.top().first>data[i])\\n            {\\n                st.push({st.top().first,-1});\\n            }\\n            else\\n            {\\n                st.push({data[i],1});\\n            }\\n            }\\n        }\\n        p=head;\\n\\n        while(st.size())\\n        {\\n            if(st.top().second==1)\\n            {\\n                p->val=st.top().first;\\n                q=p;\\n                p=p->next;\\n            }\\n            st.pop();\\n        }\\n        q->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* p=head,*q=NULL;\\n        vector<int>data;\\n        while(p!=NULL)\\n        {\\n            data.push_back(p->val);\\n            p=p->next;\\n        }\\n\\n        \\n        stack<pair<int,int>>st;\\n        for(int i=data.size()-1;i>=0;i--)\\n        {\\n            if(st.empty())\\n            {\\n                st.push({data[i],1});\\n            }\\n            else\\n            {\\n                if(st.top().first>data[i])\\n            {\\n                st.push({st.top().first,-1});\\n            }\\n            else\\n            {\\n                st.push({data[i],1});\\n            }\\n            }\\n        }\\n        p=head;\\n\\n        while(st.size())\\n        {\\n            if(st.top().second==1)\\n            {\\n                p->val=st.top().first;\\n                q=p;\\n                p=p->next;\\n            }\\n            st.pop();\\n        }\\n        q->next=NULL;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040122,
                "title": "stack-approach-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep pushing the values to a **Stack** Data Structure, if you find the value of current node is greater than the top value of stack, in that case pop out the elements till the current value is less than or equal to the top->val.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSteps - \\n1. Keep a stack of ListNode* type;\\n2. Traverse the Linked List and for each node check if it\\'s value is greater than the value of stack\\'s top->val.\\n3. If yes then keep popping out values from stack till the current value is less than or equal to the top->val.\\n4. To generate the final LinkedList, create a ListNode* variable current = NULL and then start assigning the top->next = current.\\n5. Change the value of current to top value and then pop the top Node.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode *temp = head;\\n        \\n        while(temp){\\n            \\n            while(!st.empty() && temp->val > st.top()->val)\\n                st.pop();\\n\\n            st.push(temp);\\n            temp= temp->next;\\n        }\\n\\n        ListNode * cur = NULL;\\n        while(!st.empty()){\\n            temp = st.top();\\n            temp->next = cur;\\n            cur = temp;\\n            st.pop();\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        stack<ListNode*> st;\\n        ListNode *temp = head;\\n        \\n        while(temp){\\n            \\n            while(!st.empty() && temp->val > st.top()->val)\\n                st.pop();\\n\\n            st.push(temp);\\n            temp= temp->next;\\n        }\\n\\n        ListNode * cur = NULL;\\n        while(!st.empty()){\\n            temp = st.top();\\n            temp->next = cur;\\n            cur = temp;\\n            st.pop();\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040066,
                "title": "java-explained-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n      ListNode curr = head;\\n      ListNode prev = null;\\n    \\n      // Reverse the LInked List\\n      while(curr != null) {\\n        ListNode temp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = temp;\\n      }\\n\\n      // Create a new Linked List \\n      ListNode dummy = new ListNode(0);\\n\\n      // Create an array or DS which stores the max element\\n      ArrayList<Integer> maxVal = new ArrayList<>();\\n      \\n      // Populate the DS to store the max element\\n      int max = 0;\\n      while(prev != null) {\\n        if(prev.val >= max) {\\n          max = prev.val;\\n          maxVal.add(max);\\n        }\\n        prev = prev.next;\\n      }\\n\\n      // Insert the max element in new Linked List\\n      ListNode ptr = dummy;\\n      for(int i = maxVal.size() - 1; i >= 0; i--) {\\n        ptr.next = new ListNode(maxVal.get(i));\\n        ptr = ptr.next;\\n      }\\n\\n      // Return the next of new Linked list\\n      return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeNodes(ListNode head) {\\n      ListNode curr = head;\\n      ListNode prev = null;\\n    \\n      // Reverse the LInked List\\n      while(curr != null) {\\n        ListNode temp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = temp;\\n      }\\n\\n      // Create a new Linked List \\n      ListNode dummy = new ListNode(0);\\n\\n      // Create an array or DS which stores the max element\\n      ArrayList<Integer> maxVal = new ArrayList<>();\\n      \\n      // Populate the DS to store the max element\\n      int max = 0;\\n      while(prev != null) {\\n        if(prev.val >= max) {\\n          max = prev.val;\\n          maxVal.add(max);\\n        }\\n        prev = prev.next;\\n      }\\n\\n      // Insert the max element in new Linked List\\n      ListNode ptr = dummy;\\n      for(int i = maxVal.size() - 1; i >= 0; i--) {\\n        ptr.next = new ListNode(maxVal.get(i));\\n        ptr = ptr.next;\\n      }\\n\\n      // Return the next of new Linked list\\n      return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036811,
                "title": "easy-c-explained",
                "content": "# Intuition:\\nThe goal of this code appears to be to remove nodes from a singly-linked list such that only nodes with the maximum value and their immediate successors are retained in the resulting list. To achieve this, the code reverses the given list, identifies the maximum values in it, and creates a new list containing only those maximum values and their immediate successors in the original order.\\n\\n# Approach:\\n1. Create a vector `carry` to store the maximum values encountered during the reverse traversal of the linked list.\\n2. Initialize `maxx` to 0. `maxx` will keep track of the current maximum value during traversal.\\n3. Define a recursive function `reverse_traverse` that takes a pointer to the current node `head`.\\n   - If `head` is null (indicating the end of the list), return.\\n   - Otherwise, call `reverse_traverse` recursively on the next node.\\n   - Check if the value of the current node `head->val` is greater than or equal to `maxx`.\\n     - If yes, update `maxx` to the current value `head->val` and add it to the `carry` vector.\\n4. Call `reverse_traverse` on the input `head` to populate the `carry` vector with maximum values.\\n5. Reverse the `carry` vector to restore the original order of maximum values.\\n6. Create a new ListNode `h1` as a dummy node for the result list.\\n7. Initialize a temporary pointer `temp` to `h1`.\\n8. Iterate through the `carry` vector:\\n   - Create a new ListNode for each value in `carry`.\\n   - Set the value of the new ListNode to the value from `carry`.\\n   - Update `temp` to point to the newly created node.\\n9. Return the next node of `h1`, which is the head of the resulting list.\\n\\n# Space Complexity:\\n- The space complexity of this solution is O(N), where N is the number of nodes in the linked list.\\n- The `carry` vector is used to store the maximum values and has a space complexity of O(N). Additionally, a new ListNode is created for each maximum value, contributing to the overall space complexity.\\n\\n# Time Complexity:\\n- The time complexity is O(N), where N is the number of nodes in the linked list.\\n- The code performs a reverse traversal of the linked list to identify maximum values, which takes O(N) time.\\n- Reversing the `carry` vector and creating a new list of maximum values also take O(N) time.\\n- Overall, the time complexity is dominated by the reverse traversal and the creation of the result list, making it O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> carry;\\n    int maxx=0;\\n\\n    void reverse_traverse(ListNode* head)\\n    {\\n        if(head==NULL)return;\\n        reverse_traverse(head->next);\\n        if(head->val>= maxx)\\n        {maxx=max(maxx,head->val);\\n        carry.emplace_back(maxx);\\n        }\\n        \\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        reverse_traverse( head);\\n        reverse(carry.begin(),carry.end());\\n        ListNode* h1= new ListNode();\\n        ListNode* temp=h1;\\n        for(auto it:carry)\\n        { \\n            temp->next=new ListNode();\\n            temp=temp->next;\\n            temp->val=it;\\n        }\\n        return h1->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> carry;\\n    int maxx=0;\\n\\n    void reverse_traverse(ListNode* head)\\n    {\\n        if(head==NULL)return;\\n        reverse_traverse(head->next);\\n        if(head->val>= maxx)\\n        {maxx=max(maxx,head->val);\\n        carry.emplace_back(maxx);\\n        }\\n        \\n    }\\n    ListNode* removeNodes(ListNode* head) {\\n        reverse_traverse( head);\\n        reverse(carry.begin(),carry.end());\\n        ListNode* h1= new ListNode();\\n        ListNode* temp=h1;\\n        for(auto it:carry)\\n        { \\n            temp->next=new ListNode();\\n            temp=temp->next;\\n            temp->val=it;\\n        }\\n        return h1->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036398,
                "title": "easy-implementation-by-using-a-stack-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverse(struct ListNode *head)\\n{\\n    struct ListNode *current=head,*pre=NULL,*save;\\n    while(current!=NULL)\\n    {\\n        save=current->next;\\n        current->next=pre;\\n        pre=current;\\n        current=save;\\n    }\\n    return pre;\\n}\\nstruct ListNode* removeNodes(struct ListNode* head){\\n    int a[100001],top=0;\\n    struct ListNode *rev=reverse(head);\\n    struct ListNode *t=rev->next;\\n    a[top]=rev->val;\\n    while(t!=NULL)\\n    {\\n        if(a[top]<=t->val)\\n        {\\n            a[++top]=t->val;\\n        }\\n        t=t->next;\\n    }\\n    struct ListNode *new,*first=NULL,*pre;\\n    while(top>-1)\\n    {\\n        new=(struct ListNode*)malloc(sizeof(struct ListNode));\\n        new->val=a[top--];\\n        new->next=NULL;\\n        if(first==NULL)\\n        {\\n            first=pre=new;\\n        }\\n        else\\n        {\\n            pre->next=new;\\n            pre=new;\\n        }\\n    }\\n    return first;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverse(struct ListNode *head)\\n{\\n    struct ListNode *current=head,*pre=NULL,*save;\\n    while(current!=NULL)\\n    {\\n        save=current->next;\\n        current->next=pre;\\n        pre=current;\\n        current=save;\\n    }\\n    return pre;\\n}\\nstruct ListNode* removeNodes(struct ListNode* head){\\n    int a[100001],top=0;\\n    struct ListNode *rev=reverse(head);\\n    struct ListNode *t=rev->next;\\n    a[top]=rev->val;\\n    while(t!=NULL)\\n    {\\n        if(a[top]<=t->val)\\n        {\\n            a[++top]=t->val;\\n        }\\n        t=t->next;\\n    }\\n    struct ListNode *new,*first=NULL,*pre;\\n    while(top>-1)\\n    {\\n        new=(struct ListNode*)malloc(sizeof(struct ListNode));\\n        new->val=a[top--];\\n        new->next=NULL;\\n        if(first==NULL)\\n        {\\n            first=pre=new;\\n        }\\n        else\\n        {\\n            pre->next=new;\\n            pre=new;\\n        }\\n    }\\n    return first;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033521,
                "title": "using-recursion-trust-recursion-s-power",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        ListNode*chotaHead=removeNodes(head->next);\\n        if(chotaHead->val > head->val){\\n            return chotaHead; //dusra khud hi remove ho jaega,,need to trust recursion\\n        }\\n        head->next = chotaHead;\\n        return head;\\n        //ye chotaHead sarii nodes ko process krke hi milegaa\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNodes(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        ListNode*chotaHead=removeNodes(head->next);\\n        if(chotaHead->val > head->val){\\n            return chotaHead; //dusra khud hi remove ho jaega,,need to trust recursion\\n        }\\n        head->next = chotaHead;\\n        return head;\\n        //ye chotaHead sarii nodes ko process krke hi milegaa\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1750334,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1697836,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1995204,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1942890,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1901157,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1798578,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2056216,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2052178,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2035637,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2034955,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1750334,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1697836,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1995204,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1942890,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1901157,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 1798578,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2056216,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2052178,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2035637,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            },
            {
                "id": 2034955,
                "content": [
                    {
                        "username": "novice00051",
                        "content": "I don\\'t understand the question even after reading it so many times,  an someone please explain it to me?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "In other words remove minimum no of nodes until the list becomes decreasing."
                    },
                    {
                        "username": "AJordanek",
                        "content": "Let\\'s say you are in a node. If further in the list there is a node with higher value, you need to remove the you are currently in. Otherwise you don\\'t remove it. The task is to change a list into a list without nodes, that follows that condition."
                    },
                    {
                        "username": "rohit-1311",
                        "content": "### Easy steps using a DEQUE\\n- Simply keep adding elements from back of the queue,\\n- While doing so, remove all the nodes from back when the back is smaller then the new node value\\n- Once added all element to deque, then pop from front and form the linked list again.\\n\\n```\\n        temp=head\\n        deque<ListNode*> dq \\n        while   temp!=NULL\\n            if  !dq.empty \\n                while  !dq.empty  &&   dq.back ->val  <   temp->val  \\n                    dq.pop_back\\n            \\n            dq.push_back(temp)\\n            temp=temp->next\\n        \\n      Now, form the linked list from the nodes remained in the deque\\n\\n\\n```"
                    },
                    {
                        "username": "user1889GX",
                        "content": "I was facing issue after implementing using deque and failing with output limit exceed . But i found the issue i have done some printing  using cout after commenting it worked"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "[@espadandy](/espadandy) But wont that consume more time considering we will have to reverse the linkedlist formed using normal queue?"
                    },
                    {
                        "username": "espadandy",
                        "content": "Very great hint. A regular queue (or forward_list) in C++ could also work. "
                    },
                    {
                        "username": "krex0r",
                        "content": "> Remove every node which has a node with a strictly greater value anywhere to the right side of it.\n\n`1 -> 1 -> 1 -> 1` (`[1,1,1,1]`) returns `[1,1,1,1]`, but shouldnt it return `[1]` because **1 is not strictly greater than 1** ???"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "My code works in O(n^2) time but it is showing time limit exceeded. Are we supposed to do it in O(n) linear time then ?"
                    },
                    {
                        "username": "DeepSng",
                        "content": "Check the constraints, range of number of nodes is [1,10^5] that\\'s why O(N^2) gives TLE"
                    },
                    {
                        "username": "amanm_2003",
                        "content": "yes\\n"
                    },
                    {
                        "username": "smit_02",
                        "content": "This question need more example "
                    },
                    {
                        "username": "CodeHunter27",
                        "content": "Easy steps Using Stack :\\n   1. if stack is empty then add value\\n   2. If stack have some value the pop the element if top of stack is greater or equal to the current value\\n\\nHere is an example , try this in linked list\\n   \\n `l=[5,2,13,3,8]\\nstack=[]\\nfor i in l:\\n    if stack:\\n        while(len(stack)!=0 and stack[len(stack)-1]<i):\\n            stack.pop(len(stack)-1)\\n        stack.append(i)\\n    else:\\n        stack.append(i)\\nprint(stack)`\\n  "
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "had to came up with the nge approach, elmt having nge as -1, will form a new linkedlist, had to use a arraylist, stack and a new linkedlist, totally fucked up the space and time, since used O(n), 3 times"
                    },
                    {
                        "username": "District_12",
                        "content": "Is it ok to solve it using O(3n) memory?"
                    },
                    {
                        "username": "satyampratap007",
                        "content": "Kindly explain why this code is giving TLE for larger inputs. Although 30 of 32 test cases passed.\\nCODE:\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode* curr = head;\\n        while(curr->next)\\n        {\\n            ListNode* n = curr->next;\\n            if(curr->val < n->val)\\n            {\\n                curr->val = n->val;\\n                curr->next = n->next;\\n                curr = head;\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "ArijitGhosh007",
                        "content": "Why my code is not submitting ? can anyone help me ? \\n\\n    ListNode* removeNodes(ListNode* head) {\\n        ListNode *curr = head;\\n        while(curr->next) {\\n            if(curr->val < curr->next->val) {\\n                curr->val = curr->next->val;\\n                ListNode *temp = curr->next;\\n                curr->next = temp->next;\\n                delete temp;\\n                curr = head;\\n            }\\n            else curr = curr->next;\\n        }\\n        return head;\\n    }"
                    }
                ]
            }
        ]
    }
]