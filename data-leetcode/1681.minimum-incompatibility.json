[
    {
        "title": "Concatenation of Consecutive Binary Numbers",
        "question_content": "Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 1\nExplanation: \"1\" in binary corresponds to the decimal value 1. \n\nExample 2:\n\nInput: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\nAfter concatenating them, we have \"11011\", which corresponds to the decimal value 27.\n\nExample 3:\n\nInput: n = 12\nOutput: 505379714\nExplanation: The concatenation results in \"1101110010111011110001001101010111100\".\nThe decimal value of that is 118505380540.\nAfter modulo 109 + 7, the result is 505379714.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105",
        "solutions": [
            {
                "id": 2612407,
                "title": "c-diagram-related-problems",
                "content": "![image](https://assets.leetcode.com/users/images/6822f124-b599-40a1-96d6-5e6111ee2ca9_1663902113.3584025.png)\\n\\n![image](https://assets.leetcode.com/users/images/c3eecab6-bc21-49e9-b535-fc455f96fe8e_1663903076.2444859.png)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**EDIT 1**\\n**Optimization** in `numberOfBits` function\\n```cpp\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\\n\\n**EDIT 2**\\nAnother way of **calculating length of binary number** suggested by @CoolBud\\n```cpp\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\\n\\n**EDIT 3**\\nAnother way of **calculating length of binary number** suggested by @Sopindm\\n```cpp\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\\n\\n**Binary Representation Related Problems**\\n[1. Add Binary ](https://leetcode.com/problems/add-binary/)\\n[2. Add Two Numbers ](https://leetcode.com/problems/add-two-numbers/)\\n[3. Counting Bits ](https://leetcode.com/problems/counting-bits/)\\n[4. Binary Watch ](https://leetcode.com/problems/binary-watch/)\\n[5. Reverse Bits ](https://leetcode.com/problems/reverse-bits/)\\n[6. Binary Number with Alternating Bits ](https://leetcode.com/problems/binary-number-with-alternating-bits/)\\n[7. Hamming Distance ](https://leetcode.com/problems/hamming-distance/)\\n[8. Prime Number of Set Bits in Binary Representation ](https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\n```cpp\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\n```cpp\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612207,
                "title": "java-explained-in-detail-fast-o-n-solution-bit-manipulation-math",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n**Java (Bit Manipulation) - Clean Code**\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n\\n**Java (Bit Manipulation) - With Explanation**\\n\\n```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n// where N is n.\\nclass Solution {\\n\\n    // Approach:\\n    // Using bit manipulation as described below.\\n    // A bit of description for the bitwise operations used, if you are not familiar.\\n    // 1. & - Bitwise AND operation:\\n    //    0 & 0 = 0,\\n    //    1 & 0 = 0,\\n    //    1 & 1 = 1.\\n    //    Example : 1101 & 1010 = 1000\\n    //\\n    // 2. << - Shift Left operation, by n position:\\n    //    Example:\\n    //    11 (3) << 2 (n position) = 1100 (14)\\n    //\\n\\n    public int concatenatedBinary(int n) {\\n\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n\\n        // This records the number of binaryDigits we need to shift left.\\n        int binaryDigits = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n\\n            // If i is a power of 2, we add one additional binaryDigits to shift.\\n            // Example:\\n            // i = 8 (1000), i-1 = 7 (111)\\n            // i & (i-1) = 1000 & 111 = 0\\n            // So we know we have increased the binaryDigits from 3 (in 111) to 4 (in 1000).\\n            if ((i & (i - 1)) == 0) {\\n                binaryDigits++;\\n            }\\n\\n            // With the updated binaryDigits, we now can concatenate i to the result.\\n            // Each time get the remainder of the result % modulo.\\n            // Example:\\n            // i = 2\\n            // result = 1 (1) << 2 (n position) + 10 (2) = 100 (4) + 10 (2) = 110 (6).\\n            // i = 3\\n            // result = 110 (6) << 2 (n position) + 11 (3) = 11000 (24) + 11 (3) = 11011 (27).\\n            //\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n\\n**Java (Math) - With Explanation**\\n```\\nclass Solution {\\n    \\n    // Approach:\\n    // We concatenate by shifting position of result with division and multiplication, then add the number.\\n    // As there are a lot of repetitions in shifting of positions, it is much less efficient than using bit manipulation.\\n    \\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // For each i, we shift left the position of result with * 2,\\n            // while shifting right the position of i with / 2.\\n            int temp = i;\\n            while (temp > 0) {\\n                temp /= 2;\\n                result *= 2;\\n            }\\n            // Add the i to the result and get the remainder of modulo.\\n            result = (result + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\n```\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n// where N is n.\\nclass Solution {\\n\\n    // Approach:\\n    // Using bit manipulation as described below.\\n    // A bit of description for the bitwise operations used, if you are not familiar.\\n    // 1. & - Bitwise AND operation:\\n    //    0 & 0 = 0,\\n    //    1 & 0 = 0,\\n    //    1 & 1 = 1.\\n    //    Example : 1101 & 1010 = 1000\\n    //\\n    // 2. << - Shift Left operation, by n position:\\n    //    Example:\\n    //    11 (3) << 2 (n position) = 1100 (14)\\n    //\\n\\n    public int concatenatedBinary(int n) {\\n\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n\\n        // This records the number of binaryDigits we need to shift left.\\n        int binaryDigits = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n\\n            // If i is a power of 2, we add one additional binaryDigits to shift.\\n            // Example:\\n            // i = 8 (1000), i-1 = 7 (111)\\n            // i & (i-1) = 1000 & 111 = 0\\n            // So we know we have increased the binaryDigits from 3 (in 111) to 4 (in 1000).\\n            if ((i & (i - 1)) == 0) {\\n                binaryDigits++;\\n            }\\n\\n            // With the updated binaryDigits, we now can concatenate i to the result.\\n            // Each time get the remainder of the result % modulo.\\n            // Example:\\n            // i = 2\\n            // result = 1 (1) << 2 (n position) + 10 (2) = 100 (4) + 10 (2) = 110 (6).\\n            // i = 3\\n            // result = 110 (6) << 2 (n position) + 11 (3) = 11000 (24) + 11 (3) = 11011 (27).\\n            //\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    // Approach:\\n    // We concatenate by shifting position of result with division and multiplication, then add the number.\\n    // As there are a lot of repetitions in shifting of positions, it is much less efficient than using bit manipulation.\\n    \\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // For each i, we shift left the position of result with * 2,\\n            // while shifting right the position of i with / 2.\\n            int temp = i;\\n            while (temp > 0) {\\n                temp /= 2;\\n                result *= 2;\\n            }\\n            // Add the i to the result and get the remainder of modulo.\\n            result = (result + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961446,
                "title": "detailed-thought-process-with-steps-example-o-n-time-java-8-1-liner",
                "content": "```\\nn = 3\\n1 - 1\\n2 - 10\\n3 - 11\\n\\n123 -> 11011 --> \\n\\n(1 * 2^4) + (1 * 2 ^3 + 0 * 2 ^ 2) + (1 * 2^1 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 * 2 ^2 + 0 * 2 ^ 2) + (2 * 2^0 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 + 0) * 2 ^2  + (2 + 1)* 2^0\\n\\n(1)* 2^4 + (2) * 2 ^2  + (3)* 2^0\\n\\n((1)* 2^4 + (2) * 2 ^2)  + (3)* 2^0\\n\\n((1)* 2^2 + (2)) * 2 ^2)  + (3)* 2^0\\n\\n(4 + 2) * 2^2 + 3\\n\\n24 + 3 \\n\\n27\\n\\n```\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum = (sum * (int)Math.pow(2, Integer.toBinaryString(i).length()) + i) % MOD; // sum = ((sum << Integer.toBinaryString(i).length()) + i) % MOD;\\n\\n        return (int)sum;\\n    }\\n}\\n```\\n\\n****************\\n\\n**Bitwise O(n) Time**\\n\\n```\\nclass Solution {\\n    // TC - O(n)\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        int length = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if((i & (i - 1)) == 0)\\n                length++;\\n            sum = ((sum << length) | i) % MOD;\\n        }\\n        \\n        return (int) sum;\\n    }\\n}\\n```\\n\\n****************\\n\\nJava-8: 1 Liner using Long.range and reduce\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n}\\n```\\n\\n\\nIf you like solution - **upvote**.",
                "solutionTags": [],
                "code": "```\\nn = 3\\n1 - 1\\n2 - 10\\n3 - 11\\n\\n123 -> 11011 --> \\n\\n(1 * 2^4) + (1 * 2 ^3 + 0 * 2 ^ 2) + (1 * 2^1 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 * 2 ^2 + 0 * 2 ^ 2) + (2 * 2^0 + 1 * 2^0)\\n\\n(1 * 2^4) + (2 + 0) * 2 ^2  + (2 + 1)* 2^0\\n\\n(1)* 2^4 + (2) * 2 ^2  + (3)* 2^0\\n\\n((1)* 2^4 + (2) * 2 ^2)  + (3)* 2^0\\n\\n((1)* 2^2 + (2)) * 2 ^2)  + (3)* 2^0\\n\\n(4 + 2) * 2^2 + 3\\n\\n24 + 3 \\n\\n27\\n\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        for (int i = 1; i <= n; i++)\\n            sum = (sum * (int)Math.pow(2, Integer.toBinaryString(i).length()) + i) % MOD; // sum = ((sum << Integer.toBinaryString(i).length()) + i) % MOD;\\n\\n        return (int)sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // TC - O(n)\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1_000_000_007;\\n        long sum = 0;\\n        int length = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            if((i & (i - 1)) == 0)\\n                length++;\\n            sum = ((sum << length) | i) % MOD;\\n        }\\n        \\n        return (int) sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037323,
                "title": "python-o-n-and-o-log-2-n-fast-and-short-explained",
                "content": "One way to solve this problem in competition is just create very long binary string and then find result of division by `10**9 + 7` and it will work fine. However in interview setup it is not the best idea and I prefer more honest way. Let us look at first several `n` to see how it works:\\n`1`\\n`110`\\n`11011`\\n`11011100`\\n\\nLet us try to find answer to `n`, using information about `n-1`. `110` = `1 * 100 + 10` (all in binary representation), `11011 = 110 * 100 + 11`, `11011100 = 11011 * 1000 + 100` and so on. We can see that on each step we need to multiply number by **lenght** of new number and add new number (and use `%M`) and that is all!\\n\\n**Complexity**: time complexity is `O(n)`, space is `O(1)`.\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(n):\\n            ans = (ans * (1 << (len(bin(x+1)) - 2)) + x+1) % M\\n        return ans \\n```\\n\\n**Further thoughts** When you found `O(n)` solution, you should ask a question, can you do better? Here I had very strong intuition that you can do it faster and I came up with `O(log^2 n)` solution. Then I checked discussions and there is in fact at least two solutions with this complexity: one uses idea of geometrical progressions: idea behind is the following: we can see that in binary representation of desired number there will be `O(log n)` sequences of ones with equal gaps for each of `O(log n)` lengths of numbers. You can find this solution in discussion, I will code my own version if I have time. Another solution using matrix multiplications and I was very impressed to see it.\\n\\n### Faster solution with O(log^2 n) complexity\\n\\nIt is easier to chose some `n` and go into details about this `n`. Let us choose `n = 54` and discuss how my algorithm works:\\n\\nFunction `bin_pow` will return powers of `2`, which sum to given number, for example `bin_pow(37) = [1, 4, 32]`, because `1 + 4 + 32 = 37`.\\n\\nNow, we have `n = 54`, and we have:\\n1. `1` number with length `1`: just `1`\\n2. `2` numbers with length `2`: `10, 11`\\n3. `4` numbers with length `3`: `100, 101, 110, 111`.\\n4. `8` numbers with length `4`: `1000, ..., 1111`\\n5. `16` numbers with length `5`: `10000, ..., 11111`.\\nNow, we have 23 more numbers and we keep to split them into groups:\\n6. `16` numbers with lenght `6`, which **start with** `10....`, that is `100000, 100001, ... 101111`. Why we choose `16` of them? Because it is the biggest group we can take such that this group is full: given start we have all possible endings.\\n7. `4` numbers with length `6`, which **start with** `1100`, that is `110000, 110001, 110010, 110011`\\n8. `2` numbers with length `6`, which **start with** `11010`, that is `110100` and `110101`.\\n9. `1` number with length `6`: `110110`, which is equal to `54`, our last number.\\n\\nWe will keep lenghts of our groups in list `B`, so we have:\\n`B = [1, 2, 4, 8, 16, 16, 4, 2, 1`]\\n\\nWe will keep length of numbers in each group in list `C`, so we have:\\n`C = [1, 2, 3, 4, 5, 6, 6, 6, 6]`\\n\\nSo far we have the following picture:\\n\\n`[1][10 11][100 101 110 111] ...   [110000, 110001, 110010, 110011], [110100, 110101], [110110]`\\n\\nWe will keep starting places of each group in list `D`, in our case we have:\\n`D = [266, 262, 250, 218, 138, 42, 18, 6, 0]`.\\nLet us look from the end: last group we do not need to multiply by anything, previous group has `1` number with length `6`, so we need to multiply it by `2^6`. Next we have `2*6 + 1*6` shift, `4*6 + 2*6 + 1*6`, `16*6 + 4*6 + 2*6 + 1*6`, `16*5 + 16*6 + 4*6 + 2*6 + 1*6` and so on: it can be done efficiently, using `accumulate` function in python.\\n\\nFinal step is to iterate over our groups and evaluate number modulo `10**9 + 7` in each group:\\n\\nLet us look at group `[110000, 110001, 110010, 110011]` for better underastnding. This group will be somewhere in the middle of number, like `...[110000, 110001, 110010, 110011]...` and we need to understand what impact it has on our number, we need several values:\\n1. Place, where this group is located, for this we use `D` list, `d` for given group.\\n2. Lenth of elements in each group, for this we use `C` list, `c` for given group.\\n3. Number of elements in our group, for this we use `B` list, `b` for given group.\\n4. Also we need to now, from which element we start, in our case it is `110000`, we can evaluate it as `a - b + 1`, where `a` is corresponding element in `accumulate(B)`: here we have `accumulate(B) = [1, 3, 7, 15, 31, 47, 51, 53, 54]` and `51-4 + 1 = 48` is current number we start with, `a` for given group\\n\\nFinally, we need to do some mathematics: we need to evaluate sum:\\n`[(a-b+1) * 2^(b*c) + (a-b+2)*2^(b*(c-1)) + ... +  (a-b + c-1) * 2^(b*1) + (a-b + c) * 2^(b*0)]*2^d`.\\n\\nThis formula can be written in closed form! It is almost like sum of geometrical progression, but in fact, sum of several of them which lead us to closed form solution. We also need to work using modular arithmetic, so we use powerful `pow` python function. In my notation `t1 = [2^(bc) - 1] % MOD` and `t2 = [1/(2^c - 1)] % MOD`. Here we use Fermat\\'s little theorem to evaluate inverse number in modular arithmetic. \\n\\n**Complexity**: time complexity of evaluating `B, C, D` lists is just `O(log n)`. However when we work with `pow` function, complexity to evaluate sum in each group will be also `O(log n)`, which leasd to `O(log^2 n)` time complexity. Space complexity is `O(log n)`.\\n\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        def bin_pow(num): return [1<<i for i, b in enumerate(bin(num)[:1:-1]) if b == \"1\"]\\n        ans, MOD, q = 0, 10**9 + 7, len(bin(n)) - 3\\n\\n        B = bin_pow((1<<q) - 1) + bin_pow(n - (1<<q) + 1)[::-1]\\n        C = list(range(1, q+1)) + [q+1]*(len(B) - q)\\n        D = list(accumulate(i*j for i,j in zip(B[::-1], C[::-1])))[::-1][1:] + [0]\\n        \\n        for a, b, c, d in zip(accumulate(B), B, C, D):\\n            t1 = pow(2, b*c, MOD) - 1\\n            t2 = pow(pow(2, c, MOD)-1, MOD - 2, MOD)\\n            ans += t2*((a-b+1+t2)*t1-b)*pow(2, d, MOD)\\n\\n        return ans % MOD\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(n):\\n            ans = (ans * (1 << (len(bin(x+1)) - 2)) + x+1) % M\\n        return ans \\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        def bin_pow(num): return [1<<i for i, b in enumerate(bin(num)[:1:-1]) if b == \"1\"]\\n        ans, MOD, q = 0, 10**9 + 7, len(bin(n)) - 3\\n\\n        B = bin_pow((1<<q) - 1) + bin_pow(n - (1<<q) + 1)[::-1]\\n        C = list(range(1, q+1)) + [q+1]*(len(B) - q)\\n        D = list(accumulate(i*j for i,j in zip(B[::-1], C[::-1])))[::-1][1:] + [0]\\n        \\n        for a, b, c, d in zip(accumulate(B), B, C, D):\\n            t1 = pow(2, b*c, MOD) - 1\\n            t2 = pow(pow(2, c, MOD)-1, MOD - 2, MOD)\\n            ans += t2*((a-b+1+t2)*t1-b)*pow(2, d, MOD)\\n\\n        return ans % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612371,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n---\\n\\n**Approach 1: Bit Manipulation**\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1e9 + 7, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n\\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    public int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1000000007, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\\n\\n**Python**\\n\\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    # the idea is to use bit manipulation to set the current number based on the previous number\\n    # for example, \\n    # n = 1, ans = 0b1\\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    # so now we can see a pattern here\\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    def concatenatedBinary(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        # `l` is the bit length to be shifted\\n        l, ans = 0, 0\\n        for i in range(1, n + 1):\\n            # i & (i - 1) means removing the rightmost set bit\\n            # e.g. 100100 -> 100000\\n            #      000001 -> 000000\\n            #      000000 -> 000000\\n            # after removal, if it is 0, then it means it is power of 2\\n            # as all power of 2 only contains 1 set bit\\n            # if it is power of 2, we increase the bit length `l`\\n            if i & (i - 1) == 0:\\n                l += 1\\n            # (ans << l) means shifting the orginal answer `l` bits to th left\\n            # (x | i) means  using OR operation to set the bit\\n            # e.g. 0001 << 3 = 0001000\\n            # e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M\\n        return ans\\n```\\n\\n**Go**\\n\\n```go\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\n// the idea is to use bit manipulation to set the current number based on the previous number\\n// for example, \\n// n = 1, ans = 0b1\\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n// so now we can see a pattern here\\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \\n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\nfunc concatenatedBinary(n int) int {\\n    // `l` is the bit length to be shifted\\n    ans, l, M := 0, 0, 1_000_000_007\\n    for i := 1; i <= n; i++ {\\n        // i & (i - 1) means removing the rightmost set bit\\n        // e.g. 100100 -> 100000\\n        //      000001 -> 000000\\n        //      000000 -> 000000\\n        // after removal, if it is 0, then it means it is power of 2\\n        // as all power of 2 only contains 1 set bit\\n        // if it is power of 2, we increase the bit length `l`\\n        if (i & (i - 1) == 0) {\\n            l += 1\\n        }\\n        // (ans << l) means shifting the orginal answer `l` bits to th left\\n        // (x | i) means  using OR operation to set the bit\\n        // e.g. 0001 << 3 = 0001000\\n        // e.g. 0001000 | 0001111 = 0001111\\n        ans = ((ans << l) | i) % M\\n    }   \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\npublic:\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1e9 + 7, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\nclass Solution {\\n    // the idea is to use bit manipulation to set the current number based on the previous number\\n    // for example, \\n    // n = 1, ans = 0b1\\n    // n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    // i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    // n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    // i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    // n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    // i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    // so now we can see a pattern here\\n    // we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    // how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    public int concatenatedBinary(int n) {\\n        // `l` is the bit length to be shifted\\n        int M = 1000000007, l = 0;\\n        // use long here as it potentially could overflow for int\\n        long ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            // i & (i - 1) means removing the rightmost set bit\\n            // e.g. 100100 -> 100000\\n            //      000001 -> 000000\\n            //      000000 -> 000000\\n            // after removal, if it is 0, then it means it is power of 2\\n            // as all power of 2 only contains 1 set bit\\n            // if it is power of 2, we increase the bit length `l`\\n            if ((i & (i - 1)) == 0) l += 1;\\n            // (ans << l) means shifting the orginal answer `l` bits to th left\\n            // (x | i) means  using OR operation to set the bit\\n            // e.g. 0001 << 3 = 0001000\\n            // e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\n```py\\n# Time Complexity: O(N)\\n# Space Complexity: O(1)\\nclass Solution:\\n    # the idea is to use bit manipulation to set the current number based on the previous number\\n    # for example, \\n    # n = 1, ans = 0b1\\n    # n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n    # i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n    # n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n    # i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n    # n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n    # i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n    # so now we can see a pattern here\\n    # we need to shift `l` bits of the previous ans to the left and add the current `i` \\n    # how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\n    def concatenatedBinary(self, n: int) -> int:\\n        M = 10 ** 9 + 7\\n        # `l` is the bit length to be shifted\\n        l, ans = 0, 0\\n        for i in range(1, n + 1):\\n            # i & (i - 1) means removing the rightmost set bit\\n            # e.g. 100100 -> 100000\\n            #      000001 -> 000000\\n            #      000000 -> 000000\\n            # after removal, if it is 0, then it means it is power of 2\\n            # as all power of 2 only contains 1 set bit\\n            # if it is power of 2, we increase the bit length `l`\\n            if i & (i - 1) == 0:\\n                l += 1\\n            # (ans << l) means shifting the orginal answer `l` bits to th left\\n            # (x | i) means  using OR operation to set the bit\\n            # e.g. 0001 << 3 = 0001000\\n            # e.g. 0001000 | 0001111 = 0001111\\n            ans = ((ans << l) | i) % M\\n        return ans\\n```\n```go\\n// Time Complexity: O(N)\\n// Space Complexity: O(1)\\n\\n// the idea is to use bit manipulation to set the current number based on the previous number\\n// for example, \\n// n = 1, ans = 0b1\\n// n = 2 (10), we need to shift 2 bits of the previous ans to the left and add `n`\\n// i.e. 1 -> 100 (shift 2 bits to the left) -> 110 (set `10`). ans = 0b110\\n// n = 3 (11), we need to shift 2 bits of the previous ans to the left and add `n` \\n// i.e 110 -> 11000 (shift 2 bits to the left) -> 11011 (set `11`). ans = 0b11011\\n// n = 4 (100), we need to shift 3 bits of the previous ans to the left and add `n`\\n// i.e. 11011 -> 11011000 (shift 3 bits to the left) -> 11011100 (set `100). ans = 0b11011100\\n// so now we can see a pattern here\\n// we need to shift `l` bits of the previous ans to the left and add the current `i` \\n// how to know `l`? it is not difficult to see `x` only increases when we meet power of 2\\nfunc concatenatedBinary(n int) int {\\n    // `l` is the bit length to be shifted\\n    ans, l, M := 0, 0, 1_000_000_007\\n    for i := 1; i <= n; i++ {\\n        // i & (i - 1) means removing the rightmost set bit\\n        // e.g. 100100 -> 100000\\n        //      000001 -> 000000\\n        //      000000 -> 000000\\n        // after removal, if it is 0, then it means it is power of 2\\n        // as all power of 2 only contains 1 set bit\\n        // if it is power of 2, we increase the bit length `l`\\n        if (i & (i - 1) == 0) {\\n            l += 1\\n        }\\n        // (ans << l) means shifting the orginal answer `l` bits to th left\\n        // (x | i) means  using OR operation to set the bit\\n        // e.g. 0001 << 3 = 0001000\\n        // e.g. 0001000 | 0001111 = 0001111\\n        ans = ((ans << l) | i) % M\\n    }   \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961350,
                "title": "c-o-n-time-iterative",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. \\n\\nLet `f(n)` be the answer. `sum_len(a, b) = sum( len(i) | a <= i <= b)` and `len(i)` is the number of bits in `i`.\\n\\nFor example: `len(1) = 1`, `len(3) = 2`, `len(6) = 3`. `sum_len(1,4) = len(1) + len(2) + len(3) + len(4) = 1 + 2 + 2 + 3 = 8`.\\n\\nSo we have\\n\\n```plaintext\\nf(n)   = (1 << sum_len(2, n))   + (2 << sum_len(3, n))   + ... + ((n - 1) << sum_len(n, n)) + (n << 0)\\n\\n// Example: f(4) = 11011100 = (1 << (2+2+3)) + (2 << (2+3)) + (3 << 3) + (4 << 0)\\n\\nf(n-1) = (1 << sum_len(2, n-1)) + (2 << sum_len(3, n-1)) + ... + ((n - 1) << 0)\\n\\nf(n) = (f(n-1) << len(n)) + n\\n```\\n\\nSince `f(0) = 0`, we can iteratively build `f(n)`.\\n\\n```plaintext\\nf(0) = 0\\nf(1) = 1     = (f(0) << 1) + 1  // len(1) = 1\\nf(2) = 110   = (f(1) << 2) + 2  // len(2) = 2\\nf(3) = 11011 = (f(2) << 2) + 3  // len(3) = 2\\n...\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1, ++len);\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2.\\n\\nWe spent `O(logN)` time for calculating the `len`. We can reduce it to `O(1)` with the help of `__builtin_clz` which returns the number of leading zeros for a number, so `len = 32 - __builtin_clz(i)`. (Thanks 0xFFFFFFFF)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) ans = ((ans << (32 - __builtin_clz(i))) % mod + i) % mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nOr, with the observation that the `len` only increment when the `i` is a power of `2`, we can increment `len` only when `i` has a single bit `1`. We can check this via `(i & (i - 1)) == 0`. (Thanks @LVL99)\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if ((i & (i - 1)) == 0) ++len;\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```plaintext\\nf(n)   = (1 << sum_len(2, n))   + (2 << sum_len(3, n))   + ... + ((n - 1) << sum_len(n, n)) + (n << 0)\\n\\n// Example: f(4) = 11011100 = (1 << (2+2+3)) + (2 << (2+3)) + (3 << 3) + (4 << 0)\\n\\nf(n-1) = (1 << sum_len(2, n-1)) + (2 << sum_len(3, n-1)) + ... + ((n - 1) << 0)\\n\\nf(n) = (f(n-1) << len(n)) + n\\n```\n```plaintext\\nf(0) = 0\\nf(1) = 1     = (f(0) << 1) + 1  // len(1) = 1\\nf(2) = 110   = (f(1) << 2) + 2  // len(2) = 2\\nf(3) = 11011 = (f(2) << 2) + 3  // len(3) = 2\\n...\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1, ++len);\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7;\\n        for (int i = 1; i <= n; ++i) ans = ((ans << (32 - __builtin_clz(i))) % mod + i) % mod;\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if ((i & (i - 1)) == 0) ++len;\\n            ans = ((ans << len) % mod + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037355,
                "title": "c-super-simple-short-and-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long res = 0, mod = 1e9+7, len_of_curr = 0;\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\n\\t\\t\\t// the len increases every time we reach a number which is a power of two.\\n            if ((i & (i-1)) == 0)\\n                len_of_curr++;\\n\\t\\t\\t\\t\\n            res = (res << len_of_curr) % mod;\\n            res += i % mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long res = 0, mod = 1e9+7, len_of_curr = 0;\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t\\n\\t\\t\\t// the len increases every time we reach a number which is a power of two.\\n            if ((i & (i-1)) == 0)\\n                len_of_curr++;\\n\\t\\t\\t\\t\\n            res = (res << len_of_curr) % mod;\\n            res += i % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612211,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=yMwSJfpSYEo\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            \\n            if ((i & (i - 1)) == 0) length++;\\n            ans = ((ans << length) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, mod = 1e9+7, length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            \\n            if ((i & (i - 1)) == 0) length++;\\n            ans = ((ans << length) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963549,
                "title": "python-log-n-2-approach",
                "content": "![image](https://assets.leetcode.com/users/images/6dba8f5e-8013-4afc-a829-719065047032_1607360527.7108207.png)\\n\\nO(logn) level to iterate \\nin each level calculating result of power for O(logn)\\n\\n```\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def multiply(X, Y):\\n            return [[sum(a*b for a,b in zip(X_row,Y_col)) % 1000000007 for Y_col in zip(*Y)] for X_row in X]\\n        \\n        ans, acc, level = [[1], [2], [1]], 1, 1\\n        while acc < n:\\n            M = 2 ** (level + 1)\\n\\t\\t\\t\\n\\t\\t\\t# number of matrix production in this level\\n            x = take = min(n, M - 1) - acc\\n            \\n\\t\\t\\tmat = [[M, 1, 0], [0, 1, 1], [0, 0, 1]]\\n\\t\\t\\t\\n\\t\\t\\t# for example\\n\\t\\t\\t# num^13 = num * num^4 * num^8\\n\\t\\t\\t# num^6 = num^2 * num^4\\n            while x > 0:\\n                if x & 1: ans = multiply(mat, ans)\\n                mat, x = multiply(mat, mat), x >> 1\\n            \\n\\t\\t\\tacc, level = acc + take, level + 1\\n        \\n        return ans[0][0]\\n```\\n\\ncredit to @ckclark",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        def multiply(X, Y):\\n            return [[sum(a*b for a,b in zip(X_row,Y_col)) % 1000000007 for Y_col in zip(*Y)] for X_row in X]\\n        \\n        ans, acc, level = [[1], [2], [1]], 1, 1\\n        while acc < n:\\n            M = 2 ** (level + 1)\\n\\t\\t\\t\\n\\t\\t\\t# number of matrix production in this level\\n            x = take = min(n, M - 1) - acc\\n            \\n\\t\\t\\tmat = [[M, 1, 0], [0, 1, 1], [0, 0, 1]]\\n\\t\\t\\t\\n\\t\\t\\t# for example\\n\\t\\t\\t# num^13 = num * num^4 * num^8\\n\\t\\t\\t# num^6 = num^2 * num^4\\n            while x > 0:\\n                if x & 1: ans = multiply(mat, ans)\\n                mat, x = multiply(mat, mat), x >> 1\\n            \\n\\t\\t\\tacc, level = acc + take, level + 1\\n        \\n        return ans[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961525,
                "title": "c-beginner-friendly-easy-understanding",
                "content": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        string s=decimalToBinary(n);\\n        return binaryToDecimal(s);\\n    }\\n\\t\\n\\tstring decimalToBinary(int n) { \\n         string str=\"\";\\n        for(int i=n;i>=1;--i){\\n            int no=i;\\n            while(no){\\n                str+=(no%2)+\\'0\\';\\n                no/=2;\\n            }\\n        }\\n        return str;\\n    } \\n    \\n    int binaryToDecimal(string n){\\n        long long ans=0,powe=1;\\n        for(int j=0;j<n.size();++j){\\n                long long now=(n[j]-\\'0\\')*(powe);\\n                powe*=2;\\n                powe%=mod;\\n                ans+=now;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        string s=decimalToBinary(n);\\n        return binaryToDecimal(s);\\n    }\\n\\t\\n\\tstring decimalToBinary(int n) { \\n         string str=\"\";\\n        for(int i=n;i>=1;--i){\\n            int no=i;\\n            while(no){\\n                str+=(no%2)+\\'0\\';\\n                no/=2;\\n            }\\n        }\\n        return str;\\n    } \\n    \\n    int binaryToDecimal(string n){\\n        long long ans=0,powe=1;\\n        for(int j=0;j<n.size();++j){\\n                long long now=(n[j]-\\'0\\')*(powe);\\n                powe*=2;\\n                powe%=mod;\\n                ans+=now;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612403,
                "title": "c-bit-manipulation-appraoch",
                "content": "**If you like it, please give a star, to my [Github](https://github.com/champmaniac/LeetCode) Repository and upvote this post.**\\n\\n**Intuition:**\\nThe answer is the **sum** of the binary representations of the numbers from `1 to n`. The binary representation of a number is the sum of the **powers** of `2` that make up the number. The powers of `2` are the same as the **binary** representation of the number.\\n\\n**Approach:**\\n* Iterate through the numbers from `1 to n` and add the `binary` representation of `each` number to the `answer`.\\n* `ans` `= ans<<`(`number of bits in the binary representation of the current number`) + `binary representation of the current number.`\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int mod = 1e9 + 7;\\n        long long ans = 0;\\n        int len = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) {\\n                len++;\\n            }\\n            ans = ((ans << len) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n**Time Complexity:** **O(n)**, where `n`: input number\\n**Space Complexity:** **O(1)**\\n****\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int mod = 1e9 + 7;\\n        long long ans = 0;\\n        int len = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) {\\n                len++;\\n            }\\n            ans = ((ans << len) + i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037348,
                "title": "python-3-bit-manipulation-4-solutions-1-line-o-n-44ms",
                "content": "# Straightforward solution\\n- Iteratively shift sum to the left by counter bit length and add the counter.\\n- Iteratively get modulo 10\\\\*\\\\*9+7 to avoid slow big int operations.\\n- Time complexity is O(n), space complexity is O(1).\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        s = 0\\n        for i in range(1, n+1):\\n            s = (s << i.bit_length() | i) % 1000000007\\n            \\n        return s\\n```\\n# Functional approach\\nThe same algorithm in 1 line.\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda s, i: (s << i.bit_length() | i) % 1000000007, range(1, n+1))\\n```\\n# Lazy memoization\\n- Since task for small ```n``` is a subtask for big ```n``` we can cache all ```n``` to avoid duplicated calculations.\\n- Time complexity is O(n), space complexity is O(n).\\n```\\nclass Solution:\\n    mem = [0]\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        for i in range(len(Solution.mem), n+1):\\n            Solution.mem.append((Solution.mem[-1] << i.bit_length() | i) % 1000000007)\\n        \\n        return Solution.mem[n]\\n```\\n# Greedy memoization, 44ms\\n- Since we know n <= 10\\\\*\\\\*5 we can precalculate all ```n```.\\n- Time complexity is O(1) and initialization O(n), space complexity is O(n)\\n```\\nclass Solution:\\n    mem = list(accumulate(range(100001), lambda s, i: (s << i.bit_length() | i) % 1000000007))\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        return Solution.mem[n]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        s = 0\\n        for i in range(1, n+1):\\n            s = (s << i.bit_length() | i) % 1000000007\\n            \\n        return s\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda s, i: (s << i.bit_length() | i) % 1000000007, range(1, n+1))\\n```\n```n```\n```n```\n```n```\n```\\nclass Solution:\\n    mem = [0]\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        for i in range(len(Solution.mem), n+1):\\n            Solution.mem.append((Solution.mem[-1] << i.bit_length() | i) % 1000000007)\\n        \\n        return Solution.mem[n]\\n```\n```n```\n```\\nclass Solution:\\n    mem = list(accumulate(range(100001), lambda s, i: (s << i.bit_length() | i) % 1000000007))\\n        \\n    def concatenatedBinary(self, n: int) -> int:\\n        return Solution.mem[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612781,
                "title": "python-easiest-solution-brute-force-beats-95",
                "content": "Things I learnt which might benefit everyone :\\n* The `bin()` function in python returns the binary value **prefixed with 0b**, for our solution we use the `format()` to get rid of those prefixes.\\n* To convert a binary to an integer equivalent, which can actually be done using `int()` , by passing in 2 as the second parameter\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        string = \"\"\\n        for i in range(1,n+1):\\n            string+=format(i,\"b\")\\n        return int(string,2)%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        string = \"\"\\n        for i in range(1,n+1):\\n            string+=format(i,\"b\")\\n        return int(string,2)%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037347,
                "title": "java-bit-manipulation-without-any-library-function-o-n-time-o-1-space",
                "content": "\\n```\\n\\tpublic int concatenatedBinary(int n) {\\n        int digits = 0, MOD = 1000000007;\\n        long result = 0;\\n        for(int i = 1; i <= n; i++){\\n\\t\\t\\t/* if \"i\" is a power of 2, then we have one additional digit in\\n\\t\\t\\t   its the binary equivalent compared to that of i-1 */\\n            if((i & (i - 1)) == 0) digits++; \\n            result = ((result << digits) + i) % MOD;\\n        }\\n        \\n        return (int) result;\\n    }",
                "solutionTags": [],
                "code": "\\n```\\n\\tpublic int concatenatedBinary(int n) {\\n        int digits = 0, MOD = 1000000007;\\n        long result = 0;\\n        for(int i = 1; i <= n; i++){\\n\\t\\t\\t/* if \"i\" is a power of 2, then we have one additional digit in\\n\\t\\t\\t   its the binary equivalent compared to that of i-1 */\\n            if((i & (i - 1)) == 0) digits++; \\n            result = ((result << digits) + i) % MOD;\\n        }\\n        \\n        return (int) result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 961352,
                "title": "python-clean-solution-using-lowbit-o-n-o-1",
                "content": "**Idea**\\n\\nWe simply go through every number from `1` to `n`  and update `ans`. The idea is somewhat similar to rolling hash.\\n\\nIn Python, `bin()` comes in handy. The `bin()` method converts and returns the binary equivalent string of a given integer. For example, `bin(3)` returns `0b11`.\\n\\nIf we are not using `bin()`, we can update the length of the binary representation, `l`, whenever we see `x & -x == x`. The idea of `x & -x` comes from Fenwick Tree, which gives us the low bit of `x`. And this condition checks if `x` is something like `100...0`.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(1)`\\n\\n</br>\\n\\n**Python**\\n\\nusing lowbit (`x & -x`):\\n\\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, l, MOD = 0, 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            if x & (-x) == x: l += 1\\n            ans = (ans * (1 << l) + x) % MOD\\n        return ans \\n```\\n\\nusing `bin()`:\\n\\n\\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            ans = (ans * (1 << (len(bin(x)) - 2)) + x) % MOD\\n        return ans \\n```\\n",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, l, MOD = 0, 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            if x & (-x) == x: l += 1\\n            ans = (ans * (1 << l) + x) % MOD\\n        return ans \\n```\n```Python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans, MOD = 0, 10 ** 9 + 7\\n        for x in range(1, n + 1):\\n            ans = (ans * (1 << (len(bin(x)) - 2)) + x) % MOD\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612330,
                "title": "java-simple-using-log-function",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            // length of number in binary form\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            // length of number in binary form\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612315,
                "title": "java-single-line-solution-90-faster-code-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int modulo = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%modulo)+i)%modulo;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int modulo = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%modulo)+i)%modulo;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038088,
                "title": "c-4-solutions-compared-and-explained-80-time-100-space",
                "content": "So, for the first one I wanted to give me the extra challenge of not using `long` (more on that later) and so I decided to count from `1` to `n`, get the bits right and religiously add one bit at a time.\\n\\nTo do so I declared a sole support variable `res` in the main scope of the function, and a few more in our main loop:\\n* `i` will be our main pointer, going from `1` to `n`, as mentioned;\\n* `j` will take the value of `i` and copy it, just to be disassembled, bit by bit;\\n* `bits` is going to be our storage for the bits of each number initially stored in `j` - given the maximum input size, we are fine with just `17` bits;\\n* `pos` is the pointer we will use to work on `bits`, initially set to `0` (first cell).\\n\\nNow, in our main loop we will:\\n* assign the value of `i` to `j`, as mentioned;\\n* extract all the bits and store them in `bits`, with the added convenience of storing them in reverse order;\\n* we will then reverse all the bits in `bits` into `res`, resetting `pos` to `0` again and at each step updating `res` to be double its previous value modulo `1000000007`, plus the current bit.\\n\\nOnce done, we can return `res` :)\\n\\nThe code, running at around 30% time, with significantly low memory consumption (arrays, what would we do without them?):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res = (res * 2) % 1000000007 + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNow, can we do better?\\n\\nBut of course, starting with removing the modulo operation, which is notoriously rather expensive, and changing the solution to this (bumped up to 40%):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res <<= 1;\\n                res = (res > 1000000007 ? res - 1000000007 : res) + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do even better? Sure.\\n\\nI admit I did not want to go there not to add extra complexity, but we really do not need to store the bit in `bits` if we \"read\" them from the left, so here is some further optimisation\\n\\nTo do so, we will add an extra support variable, `hasSeenBit`, and in our main loop we will change things a bit and have `j` be our binary pointer (is that even a term? Well, let\\'s pretend it is), being initialised to `1 << bitLmt`, with `bitLmt` expressing the maximum amount of bits we will ever need - for example for `n == 20`, `bitLmt` will be set to `5` (`20` is `10100` in binary representation).\\n\\nWe will, in each loop:\\n* reset `j` to be `1 << bitLmt` and `hasSeenBit` to be `false`;\\n* we will then extract each bit with `bool(i & j)`, which in our previous example will give us `1`, `0`, `1`, `0` and `0`, as expected;\\n* update `hasSeenBit`, so that it will be and stay `true` as soon as the first bit is found;\\n* once a bit has been found, update `res` with the logic discussed above.\\n\\nThe code, which bumped with this change alone to almost 60%:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        bool hasSeenBit;\\n        for (int i = 1, j, bit, bitLmt = ceil(log2(n)); i <= n; i++) {\\n            // preparing for a new loop\\n            j = 1 << 17;\\n            hasSeenBit = false;\\n            // extracting the bits\\n            while (j) {\\n                // getting the next bit, from the left\\n                bit = bool(i & j);\\n                // updating hasSeenBit\\n                hasSeenBit |= bit;\\n                // updating res, only after we have found at least a bit\\n                if (hasSeenBit) {\\n                    res <<= 1;\\n                    res = (res > 1000000007 ? res - 1000000007 : res) + bit;\\n                }\\n                j >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd finally the last \"cheap\" one - computing the length in bits of each number, shifting `res` (a `long`, not to risk overflows) by that amount and applying the same logic with modulo and, this time, the whole number in one go.\\n\\nThe last part in particular - not having to split the number into single bits, had the time jump over 80%:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        long res = 0;\\n        for (int i = 1, j, bitLen; i <= n; i++) {\\n            j = i;\\n            bitLen = 0;\\n            // computing the length in bits of i\\n            while (j) {\\n                bitLen++;\\n                j >>= 1;\\n            }\\n            // shifting res by bitLen bits\\n            res = (res << bitLen) % 1000000007 + i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res = (res * 2) % 1000000007 + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        for (int i = 1, j, bits[17], pos = 0; i <= n; i++) {\\n            j = i;\\n            // extracting the bits\\n            while (j) {\\n                bits[pos++] = j % 2;\\n                j >>= 1;\\n            }\\n            // applying the bits\\n            while (pos) {\\n                res <<= 1;\\n                res = (res > 1000000007 ? res - 1000000007 : res) + bits[--pos];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        int res = 0;\\n        bool hasSeenBit;\\n        for (int i = 1, j, bit, bitLmt = ceil(log2(n)); i <= n; i++) {\\n            // preparing for a new loop\\n            j = 1 << 17;\\n            hasSeenBit = false;\\n            // extracting the bits\\n            while (j) {\\n                // getting the next bit, from the left\\n                bit = bool(i & j);\\n                // updating hasSeenBit\\n                hasSeenBit |= bit;\\n                // updating res, only after we have found at least a bit\\n                if (hasSeenBit) {\\n                    res <<= 1;\\n                    res = (res > 1000000007 ? res - 1000000007 : res) + bit;\\n                }\\n                j >>= 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        // support variables\\n        long res = 0;\\n        for (int i = 1, j, bitLen; i <= n; i++) {\\n            j = i;\\n            bitLen = 0;\\n            // computing the length in bits of i\\n            while (j) {\\n                bitLen++;\\n                j >>= 1;\\n            }\\n            // shifting res by bitLen bits\\n            res = (res << bitLen) % 1000000007 + i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037372,
                "title": "javascript-short-4-liner-simple-solution",
                "content": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let num = 0;\\n    \\n    for(let i = 1; i <= n; i++) {\\n        //OR num *= (1 << i.toString(2).length)\\n        num *= (2 ** i.toString(2).length) \\n        num += i;\\n        num %= (10 ** 9 + 7)\\n    }\\n    return num;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let num = 0;\\n    \\n    for(let i = 1; i <= n; i++) {\\n        //OR num *= (1 << i.toString(2).length)\\n        num *= (2 ** i.toString(2).length) \\n        num += i;\\n        num %= (10 ** 9 + 7)\\n    }\\n    return num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961570,
                "title": "c-truly-o-n-solution-4-lines",
                "content": "f(n) = f(n-1) * m(n) + n\\n\\nm(1)=2\\nm(2)=4\\nm(3)=4\\nm(4)=8\\n....\\nm(n) increases only when (n & n - 1) == 0\\n\\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (i == m) // or ((i & i - 1) == 0)\\n                m <<= 1;\\n            res = (res * m + i) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n\\n\\nShorter version\\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n            res = (res * (i == m ? m <<= 1 : m) + i) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            if (i == m) // or ((i & i - 1) == 0)\\n                m <<= 1;\\n            res = (res * m + i) % mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int ConcatenatedBinary(int n)\\n    {\\n        long m = 1, res = 0, mod = (long)Math.Pow(10, 9) + 7;\\n        for (int i = 1; i <= n; i++)\\n            res = (res * (i == m ? m <<= 1 : m) + i) % mod;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037649,
                "title": "python-o-n-o-log-n-2-follow-up-with-explanation",
                "content": "## **O(n) Solution**\\n### Idea\\nGo from 1 to `n`. For each `i`, shift the answer left for the length of the binary of `i`, plus `i` and mod `p=10**9+7`.\\n\\nOptimizations include: \\n1) Maintain the length of current `i` with `cur_ibit` and use `next_bit` to detect when to increase. I bet this would be faster than calling `int.bit_length()` on every `i`.\\n2) Use `ans |= i` instead of `ans += i` as the last bits that fit `i` will always be zeros.\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\\n\\n#### Complexity\\n- O(n) time. Going over through `1..n`. \\n- O(1) space. Only a few extra variables.\\n\\n#### Submission stats\\nRuntime: 972 ms (beats 94.60 %)\\nMemory Usage: 14.1 MB (beats 84.51 %)\\n\\n## **O((log n)^2) Solution**\\nWe can achieve better time complexity with some math -- more specifically, matrix multiplication. \\n \\n #### Idea\\n When processing with `i`, the accumulation of `ans` goes as `ans = (ans << i.bit_length()) + i`. If we use a vector of `v[i] = [ans[i], i+1, 1]`, we can write this process as matrix operation `v[i+1] = M_B @ v[i]`: \\n![image](https://assets.leetcode.com/users/images/6c747977-4e3a-41f7-8eb5-b5ea77450547_1611760024.7572007.png),\\nwhere `B = 1 << i.bit_length()` and it is the same for all `2^k <= i < 2^(k+1)`.\\n\\nThe good thing now is that we can fast compute the accumulative effect of those `2^k <= i < 2^(k+1)` (`2^k` of them) that share the same `B` using matrix power ![image](https://assets.leetcode.com/users/images/c220dfd3-54a4-4336-a7d2-f70a3ad71238_1611760413.3877525.png), which takes O(k) time (see `matpowv()`).\\n\\nNow for a given `n`. Say `n = 25`. We start with `v[0] = [0, 1, 1]`. Then we do this matrix power thing for `i` in `[1, 2)`, `[2, 4)`, `[4, 8)`, `[8, 16)`, `[16, 26)`. That is, we calculate ![image](https://assets.leetcode.com/users/images/ab09df56-2b5c-4495-bb37-0a0bac920f29_1611760793.1534994.png) for `B, k = 2, 0`; `4, 1`; `8, 2`; `16, 3`; `32, 4`. In code, we do not explicitly keep `k` but instead use `min(bit, n - bit)` to get the power term. The final answer is `v[25][0]`.\\n\\nOptimizations:\\n1) Same as before, use `bit` to keep track of the most significant bit instead of calculate it every time.\\n2) Collapse matrices into the vector (`matpowv()`) every time to reduce the number of multiplication and additions from 3^3 (matrix multiplies matrix, `matmul()`) to 3^2 (matrix multiplies vector, `mv()`).\\n\\n\\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```\\n\\n### Complexity\\n- O((log n)^2) time. O(log n) for going up bit by bit from 1 to n. For each bit, O(log bit) ~ O(log n) for calculating the matrix pow. The size of matrices are irrelavent of n and are always 3x3 and thus the time complexity for matmul is O(1).\\n- O(1) space. The matrices involved take up O(1) space (irrelavent of n). \\n\\n### Submission stats\\nRuntime: 292 ms (beats 97.66 %)\\nMemory Usage: 14.3 MB (beats 53.67 %)\\n\\n---\\nIf you find this helpful, please **upvote**! Thank you!!! :-)\\n\\nAcknowledgement: The idea of the matrix solution comes from [@rbx](https://leetcode.com/rbx)\\'s [post](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/963549/python-(log(n))-2-approach).",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037629,
                "title": "concatenation-of-consecutive-binary-numbers-python-o-n-o-log-n-2-follow-up-with-explanation",
                "content": "## **O(n) Solution**\\n### Idea\\nGo from 1 to `n`. For each `i`, shift the answer left for the length of the binary of `i`, plus `i` and mod `p=10**9+7`.\\n\\nOptimizations include: \\n1) Maintain the length of current `i` with `cur_ibit` and use `next_bit` to detect when to increase. I bet this would be faster than calling `int.bit_length()` on every `i`.\\n2) Use `ans |= i` instead of `ans += i` as the last bits that fit `i` will always be zeros.\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\\n\\n#### Complexity\\n- O(n) time. Going over through `1..n`. \\n- O(1) space. Only a few extra variables.\\n\\n#### Submission stats\\nRuntime: 972 ms (beats 94.60 %)\\nMemory Usage: 14.1 MB (beats 84.51 %)\\n\\n## **O((log n)^2) Solution**\\nWe can achieve better time complexity with some math -- more specifically, matrix multiplication. \\n \\n #### Idea\\n When processing with `i`, the accumulation of `ans` goes as `ans = (ans << i.bit_length()) + i`. If we use a vector of `v[i] = [ans[i], i+1, 1]`, we can write this process as matrix operation `v[i+1] = M_B @ v[i]`: \\n![image](https://assets.leetcode.com/users/images/6c747977-4e3a-41f7-8eb5-b5ea77450547_1611760024.7572007.png),\\nwhere `B = 1 << i.bit_length()` and it is the same for all `2^k <= i < 2^(k+1)`.\\n\\nThe good thing now is that we can fast compute the accumulative effect of those `2^k <= i < 2^(k+1)` (`2^k` of them) that share the same `B` using matrix power ![image](https://assets.leetcode.com/users/images/c220dfd3-54a4-4336-a7d2-f70a3ad71238_1611760413.3877525.png), which takes O(k) time (see `matpowv()`).\\n\\nNow for a given `n`. Say `n = 25`. We start with `v[0] = [0, 1, 1]`. Then we do this matrix power thing for `i` in `[1, 2)`, `[2, 4)`, `[4, 8)`, `[8, 16)`, `[16, 26)`. That is, we calculate ![image](https://assets.leetcode.com/users/images/ab09df56-2b5c-4495-bb37-0a0bac920f29_1611760793.1534994.png) for `B, k = 2, 0`; `4, 1`; `8, 2`; `16, 3`; `32, 4`. In code, we do not explicitly keep `k` but instead use `min(bit, n - bit)` to get the power term. The final answer is `v[25][0]`.\\n\\nOptimizations:\\n1) Same as before, use `bit` to keep track of the most significant bit instead of calculate it every time.\\n2) Collapse matrices into the vector (`matpowv()`) every time to reduce the number of multiplication and additions from 3^3 (matrix multiplies matrix, `matmul()`) to 3^2 (matrix multiplies vector, `mv()`).\\n\\n\\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```\\n\\n### Complexity\\n- O((log n)^2) time. O(log n) for going up bit by bit from 1 to n. For each bit, O(log bit) ~ O(log n) for calculating the matrix pow. The size of matrices are irrelavent of n and are always 3x3 and thus the time complexity for matmul is O(1).\\n- O(1) space. The matrices involved take up O(1) space (irrelavent of n). \\n\\n### Submission stats\\nRuntime: 292 ms (beats 97.66 %)\\nMemory Usage: 14.3 MB (beats 53.67 %)\\n\\n---\\nIf you find this helpful, please **upvote**! Thank you!!! :-)\\n\\nAcknowledgement: The idea of the matrix solution comes from [@rbx](https://leetcode.com/rbx)\\'s [post](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/963549/python-(log(n))-2-approach).",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        ans = 0\\n        next_bit = 1\\n        cur_ibit = 0\\n        for i in range(1, n+1):\\n            if i >= next_bit:\\n                next_bit <<= 1\\n                cur_ibit += 1\\n            ans <<= cur_ibit\\n            ans |= i\\n            ans %= p\\n        return ans\\n```\n```python\\ndef matmul(X, Y, p):\\n    return [[sum(a * b for a, b in zip(X_row, Y_col)) % p for Y_col in zip(*Y)] for X_row in X]\\n\\ndef mv(X, v, p):\\n    return [sum(a * b for a, b in zip(X_row, v)) % p for X_row in X]\\n\\ndef matpowv(X, n, v, p):\\n    while n > 0:\\n        if n & 1: v = mv(X, v, p)\\n        X, n = matmul(X, X, p), n >> 1\\n    return v\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int, p: int = 10 ** 9 + 7) -> int:\\n        n += 1\\n        v = [0, 1, 1]\\n        bit = 1\\n        while bit < n:\\n            M = bit << 1\\n            mat = [\\n                [M, 1, 0],\\n                [0, 1, 1],\\n                [0, 0, 1],\\n            ]\\n            npow = min(bit, n - bit)\\n            v = matpowv(mat, npow, v, p)\\n            bit = M\\n        return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961368,
                "title": "java-simple-easy-o-n-solution",
                "content": "The idea is to add powers of 2 if the last bit is 1.\\n\\n```\\n    public int concatenatedBinary(int n) {\\n        long res = 0, mul = 1;\\n        int mod = 1_000_000_007;\\n        for(int i = n; i > 0; --i){\\n            int no = i;\\n            while(no > 0){\\n                if(no % 2 == 1) res = (res + mul) % mod;\\n                no >>= 1;\\n                mul = (mul<<1) % mod;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }",
                "solutionTags": [],
                "code": "The idea is to add powers of 2 if the last bit is 1.\\n\\n```\\n    public int concatenatedBinary(int n) {\\n        long res = 0, mul = 1;\\n        int mod = 1_000_000_007;\\n        for(int i = n; i > 0; --i){\\n            int no = i;\\n            while(no > 0){\\n                if(no % 2 == 1) res = (res + mul) % mod;\\n                no >>= 1;\\n                mul = (mul<<1) % mod;\\n            }\\n        }\\n        \\n        return (int)res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2612473,
                "title": "c-bit-manipulation-fully-explained-solution",
                "content": "Countbits function returns the number of bits in the number n\\nLet\\'s understand this with an example, \\n\\nWe will take the example of a decimal number(base 10).\\nIf we take log10(n)+1 it will return the number of digits in the base 10.\\n\\nFor example, \\n\\nlog10(121)+1 = 3\\nlog10(87)+1 = 2\\nlog10(2)+1 = 1\\n\\nNow, the same goes for a log base 2 in a binary system.\\nlog2(5)+1 = 3\\nlog2(3)+1 = 2\\nlog2(1)+1 = 2\\n\\nOnce we have the number of bits, we can continue ahead\\n\\n1. we just left shift our temp variable by the number of bits in ith number\\n2. then we xor temp with i\\n\\nFor example,\\n\\ntemp=0;\\nn=2;\\ni->1 to 2;\\nFor i=1,\\n(temp<<1)^i -> (0<<1)^1 -> (00)^01 -> 01\\ntemp = 01\\n\\nnext ,\\n\\nFor i=2,\\n(temp<<2)^i -> (01<<2)^2 -> (0100)^10 -> 0110\\ntemp = 110 -> 6\\nso 6 will be the answer in this way\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long int MOD = 1e9+7;\\n    \\n    int countbits(int n){\\n        return log2(n)+1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        \\n        long long temp = 0;\\n        for(int i=1;i<=n;i++) temp = ((temp<<countbits(i))^i)%MOD;\\n        return temp%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int MOD = 1e9+7;\\n    \\n    int countbits(int n){\\n        return log2(n)+1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        \\n        long long temp = 0;\\n        for(int i=1;i<=n;i++) temp = ((temp<<countbits(i))^i)%MOD;\\n        return temp%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037296,
                "title": "javascript-easy-solution-beats-95",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThere are less efficient solutions which involve converting numbers to strings, or calculating the binary length each time, but the most efficient solution is actually even more basic, since we know precisely when a binary number will increase its length by 1.\\n\\nSo we can just iterate through while using **len** to keep track of how much you need to multiply **ans** by in order to fit **i** into the new **ans**. Don\\'t forget to mod by **1e9+7**.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **148ms / 39.8MB** (95% / 84%).\\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 0b100\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len <<= 1\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```\\nThe same code but with decimal instead of binary for **len**:\\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 0b100\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len <<= 1\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```\n```javascript\\nvar concatenatedBinary = function(n) {\\n    let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037274,
                "title": "c-from-tle-to-40ms",
                "content": "inituitive brute force. We add each number bit by bit. But this will be TLE.\\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    int ans = 0;\\n\\t\\n\\tstack<int> stk;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i;\\n\\n      while (x > 0) {\\n        stk.push(x % 2);\\n        x /= 2;\\n      }\\n\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n\\nWe can optimize the following part to reduce the cost.\\n```\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n```\\nupdate it to\\n```\\nans = (ans << len) % mod + i;\\n```\\n\\nWhat happend here is with the second solution we add the whole number with one ```<<``` operation instead of multiple ```<<``` operations with the first solution.\\n```len``` is the binary length of a number which is equal to stack length of the first solution.\\nIn another words, we recude ```<<``` operator from ```len``` times to 1 time.\\n\\nSolution 2,\\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    long ans = 0;\\n    const int mod = 1000000007;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i, len = 0;\\n\\n      while (x > 0) {\\n        ++len;\\n        x /= 2;\\n      }\\n\\n      ans = (ans << len) % mod + i;\\n    }\\n\\n    return ans % mod;\\n  }\\n};\\n```\\n\\nThanks to @jitendragupta1981,  we could make it more reasonable.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        const int mod = 1000000007;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int x = i, len = 0;\\n            \\n            while (x > 0) {\\n                ++len;\\n                x /= 2;\\n            }\\n            \\n            ans = ((ans << len) + i) % mod; // or ans = ((ans << len) | i) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    int ans = 0;\\n\\t\\n\\tstack<int> stk;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i;\\n\\n      while (x > 0) {\\n        stk.push(x % 2);\\n        x /= 2;\\n      }\\n\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\n      while (!stk.empty()) {\\n        ans = ans * 2 + stk.top();\\n        stk.pop();\\n\\n        ans %= 1000000007;\\n      }\\n```\n```\\nans = (ans << len) % mod + i;\\n```\n```<<```\n```<<```\n```len```\n```<<```\n```len```\n```\\nclass Solution {\\n public:\\n  int concatenatedBinary(int n) {\\n    long ans = 0;\\n    const int mod = 1000000007;\\n\\n    for (int i = 1; i <= n; ++i) {\\n      int x = i, len = 0;\\n\\n      while (x > 0) {\\n        ++len;\\n        x /= 2;\\n      }\\n\\n      ans = (ans << len) % mod + i;\\n    }\\n\\n    return ans % mod;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        const int mod = 1000000007;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int x = i, len = 0;\\n            \\n            while (x > 0) {\\n                ++len;\\n                x /= 2;\\n            }\\n            \\n            ans = ((ans << len) + i) % mod; // or ans = ((ans << len) | i) % mod;\\n        }\\n        \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612136,
                "title": "daily-leetcoding-challenge-september-day-23",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Change to Binary String\n\n  \n**Approach 2:** Math\n\n  \n**Approach 3:** Math (Bitwise Operation)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** Math (Bitwise Operation)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 961447,
                "title": "python-c-simple-4-liner-inbuilt-and-bitwise",
                "content": "Using Python Inbuilt bin method:\\nPython\\n```\\n def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for i in range(1,n+1):\\n            res+=bin(i)[2:]\\n        return int(res,2)%(10**9 + 7)\\n```\\n\\nUsing bitwise operation:\\nC++\\n\\n```\\nint concatenatedBinary(int n) {\\n        long int res = 0, shift = 0 ;\\n        long int mod = 1e9 + 7;\\n        for (long int i = 1; i<=n; i++){\\n            if( (i & (i-1)) == 0)\\n                shift+=1;\\n            res = ((res<<shift)|i )%mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for i in range(1,n+1):\\n            res+=bin(i)[2:]\\n        return int(res,2)%(10**9 + 7)\\n```\n```\\nint concatenatedBinary(int n) {\\n        long int res = 0, shift = 0 ;\\n        long int mod = 1e9 + 7;\\n        for (long int i = 1; i<=n; i++){\\n            if( (i & (i-1)) == 0)\\n                shift+=1;\\n            res = ((res<<shift)|i )%mod;\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961399,
                "title": "java-python-3-bit-manipulations",
                "content": "```java\\n    private static final List<Integer> table = new ArrayList<>(Arrays.asList(0));\\n    public int concatenatedBinary(int n) {\\n        if (table.size() <= n) {\\n            long num = table.get(table.size() - 1);\\n            for (int i = table.size(); i <= n; ++i) {\\n                num <<= 32 - Integer.numberOfLeadingZeros(i);\\n                num |= i;\\n                num %= 1_000_000_007;\\n                table.add((int)num);\\n            }\\n        }\\n        return table.get(n);\\n    }\\n```\\n```python\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join(bin(i)[2 :] for i in range(1, n + 1)), 2) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private static final List<Integer> table = new ArrayList<>(Arrays.asList(0));\\n    public int concatenatedBinary(int n) {\\n        if (table.size() <= n) {\\n            long num = table.get(table.size() - 1);\\n            for (int i = table.size(); i <= n; ++i) {\\n                num <<= 32 - Integer.numberOfLeadingZeros(i);\\n                num |= i;\\n                num %= 1_000_000_007;\\n                table.add((int)num);\\n            }\\n        }\\n        return table.get(n);\\n    }\\n```\n```python\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join(bin(i)[2 :] for i in range(1, n + 1)), 2) % (10 ** 9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1376623,
                "title": "c-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        //start from n to 1\\n        long long ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            //calculate the bits in the current number (i)\\n            long long  num=(log(i)/log(2)) + 1;\\n            //left shift the bits as we need to append the i\\n            ans=ans<<num;\\n            ans|=i;\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        //start from n to 1\\n        long long ans=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            //calculate the bits in the current number (i)\\n            long long  num=(log(i)/log(2)) + 1;\\n            //left shift the bits as we need to append the i\\n            ans=ans<<num;\\n            ans|=i;\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038608,
                "title": "java-with-explaination-o-n-time-o-1-space-minimum-lines-bitwise",
                "content": "1. if it is asked to make a decimal number how would concatenation work?\\nfor example ->\\nsuppose 1 is first number and we want to concate it with 2. it can be written as 1* 10+2=12\\nsuppose 1 is first number and we want to concate it with 21. it can be written as 1* 100+21=121\\nsuppose 1 is first number and we want to concate it with 342. it can be written as 1* 1000+341=1341\\nso what we can deduce is the result of append is like = original_num* pow(10,lengthOfSecondString) + secondString.\\nin case of 1 and 341. length of 341 is 3 so, res= 1* pow(10,3) + 341\\n2. so we just need to run loop from 2 to n and start applying above logic to build the answer.\\n3. second observation. since above example is in decimal system that is why we are multiplying by 10 power. if it is binary me need to multiply by power (2,lengthOfSecondNumber).\\n4. Now question is we need to find length of number in binary format. log of a number in base 2 will give the length of number in binary format +1. just like log of a number base 10 +1 gives length in decimal format. In java log base 2 method is not available only base 10 is available. so we can use below log property. \\n5. for this we could use below formula - \\nMath.log2(n) = Math.log10(n)/Math.log10(2);\\n6.now we have length. we can using power method to multiply firstNumber* pow(2,lengthOfSecond) or we can use left shift operator. as we know left shift by 1 is multiply by 2. and left shift of length will be multiply by 2^length.\\n\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long result=1;\\n        int length=0;\\n        for(int i=2;i<=n;i++) {\\n            length=((int)(Math.log(i)/Math.log(2)))+1;\\n            result=((result<<length)+i)%1000000007;\\n        }\\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019740,
                "title": "very-simple-java-solution-with-explanation",
                "content": "Here is the process how you can derive recurrent formula\\n\\nresult(n) = result(n - 1) * 2^binaryDigitsOf(n) + n\\n\\nwhere binaryDigitsOf(n) is the number of binary digits needed to write number n. \\n\\ni = 1:\\n1 -> \"1\" = 1\\nresult is 1\\n\\ni = 2:\\n2 -> \"1\"\"10\" = (110) = (1 10) = 1 * 4 + 2 = result * 2^binaryDigitsOf(2) + 2 = result * 2^binaryDigitsOf(i) + i = 6\\nresult is 6\\n\\ni = 3:\\n3 -> \"110\"\"11\" = (11011) = (110 11) = 6 * 4 + 3 = result * 2^binaryDigitsOf(3) + 3 = result * 2^binaryDigitsOf(i) + i = 27\\nresult is 27\\n\\ni = 4:\\n4 -> \"11011\"\"100\" = (11011100)  = (11011 100) = 27 * 8 + 4 = result * 2^binaryDigitsOf(4) + 4 = result * 2^binaryDigitsOf(i) + i = 220\\nresult is 220\\n\\nAnd so on until n. We just need to take care of overflow, because of that we use long instead of int and do modulo operation. At the end we convert it to the int. That\\'s it. Enjoy in code!\\n\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n\\t\\tint MOD = 1_000_000_007;\\n\\t\\t\\n\\t\\tlong[] powersOf2 = getPowersOf2();\\n\\t\\t\\n\\t\\tlong result = 0;\\n\\t\\t\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tresult = (result * powersOf2[getNumberOfBinaryDigits(i, powersOf2)] + i) % MOD;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (int) (result % MOD);\\n    }\\n\\t\\n\\tprivate int getNumberOfBinaryDigits(int n, long[] powersOf2) {\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tif (powersOf2[i] > n) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t} else if (powersOf2[i] == n) {\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 1000; // never will come here\\n\\t}\\n\\n\\tprivate long[] getPowersOf2() {\\n\\t\\tlong[] powersOf2 = new long[32];\\n\\t\\t\\n\\t\\tpowersOf2[0] = 1;\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tpowersOf2[i] = 2 * powersOf2[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn powersOf2;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n\\t\\tint MOD = 1_000_000_007;\\n\\t\\t\\n\\t\\tlong[] powersOf2 = getPowersOf2();\\n\\t\\t\\n\\t\\tlong result = 0;\\n\\t\\t\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tresult = (result * powersOf2[getNumberOfBinaryDigits(i, powersOf2)] + i) % MOD;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn (int) (result % MOD);\\n    }\\n\\t\\n\\tprivate int getNumberOfBinaryDigits(int n, long[] powersOf2) {\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tif (powersOf2[i] > n) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t} else if (powersOf2[i] == n) {\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn 1000; // never will come here\\n\\t}\\n\\n\\tprivate long[] getPowersOf2() {\\n\\t\\tlong[] powersOf2 = new long[32];\\n\\t\\t\\n\\t\\tpowersOf2[0] = 1;\\n\\t\\t\\n\\t\\tfor (int i = 1; i < 32; i++) {\\n\\t\\t\\tpowersOf2[i] = 2 * powersOf2[i - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn powersOf2;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612717,
                "title": "python-one-line-solution-94-beats",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)\\n    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1,n+1)]),2)%(10**9+7)\\n    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2612278,
                "title": "c-must-know-method-explained",
                "content": "Understanding: In a **binary represenatation**, **1110** = 14 can be written as: **1100** + **10** = (**11**<<*2*) +  (**10**<<*0*) = *12+2 = 14*.\\n(All Binary Notation are in Bold.) \\nExample:\\nLets say n = *3*.\\nSo, concatenation would be: **1 10 11 100**\\nEach time we concatenate, we left shift our previous number by length of binary representation of that number.\\nSo, at *1*, we have *1*.\\nAt *2*, we have **1** **10**, (**1**<<*2*) + **10** = *4 + 2 = 6*,One left shifts twice to create space for the new number which has *2* bits in it. \\nAt *3*, similarly, **110** **11**, 6 is left shifted twice, so* 6x2x2 = 24 + 3*(the new number) = *27*.\\n\\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            //Length increases on each power of two.\\n            if ((i&(i - 1)) == 0) \\n                ++length;\\n            //Left shift by that length.\\n            ans = ((ans << length) % mod + i) % mod;\\n            cout << length << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int length = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            //Length increases on each power of two.\\n            if ((i&(i - 1)) == 0) \\n                ++length;\\n            //Left shift by that length.\\n            ans = ((ans << length) % mod + i) % mod;\\n            cout << length << endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1037382,
                "title": "c-o-n-solution",
                "content": "Left shift the answer every time by len and add the number, and then increment the length value at powers of 2.\\n```\\n  int concatenatedBinary(int n) {\\n    long ans=0;\\n    int mod=1e9+7,len=1;\\n    for(int i=1;i<=n;++i){\\n        ans=(ans<<len)%mod+i;\\n        if((i&(i+1))==0)\\n            len++;\\n    }\\n\\treturn ans % mod;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int concatenatedBinary(int n) {\\n    long ans=0;\\n    int mod=1e9+7,len=1;\\n    for(int i=1;i<=n;++i){\\n        ans=(ans<<len)%mod+i;\\n        if((i&(i+1))==0)\\n            len++;\\n    }\\n\\treturn ans % mod;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961432,
                "title": "java-simple",
                "content": "**1680. Concatenation of Consecutive Binary Numbers**\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int i=1;\\n        int mod = (int)Math.pow(10,9) + 7;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<=n){\\n            sb.append(Integer.toBinaryString(i)); // Build string with integers\\n            i++;\\n        }\\n        String binary = sb.toString();\\n        int current = 0;\\n        for(i=0; i<binary.length();i++){\\n            current += binary.charAt(i) ==\\'1\\'? 1:0; // add 1 if it is a 1\\n            if(i+1 != binary.length()) // only multiply if it is not the last place or else it will be too big!\\n                current = ((current % mod) * 2) % mod; // modular multiplication to avoid overflow\\n        }\\n        return current;\\n    }\\n}\\n```\\n**PROBLEM OVERVIEW**\\nGiven an int, n, concatenate all numbers from 1 to n in binary. Convert this binary number into decimal. Numbers may be large so return the answer mod 10^9 + 7.\\n\\n**SOLUTION ANALYSIS**\\nUse a StringBuilder for efficient String concatenation. For each decimal value 1 to n, we can use Java\\'s inbuilt function Integer.toBinaryString(int i) to concatenate the binary representation.\\n\\nAfter that, we need to use modular multiplication to avoid overflow. To convert binary to decimal, we typically add 1 if it is a 1 at that place value and then multiply the sum by 2. However, bcause the number may be too large, we take the remainder of the current number and mod (10^9 + 7) before and after multiplying. By doing so, we prevent overflow.\\n\\nFor modular multiplication, the typical code is like this :\\n```\\npublic int modularMultiplication(int a, int b, int mod){\\n\\treturn ((a%mod) * (b%mod)) % mod;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int i=1;\\n        int mod = (int)Math.pow(10,9) + 7;\\n        StringBuilder sb = new StringBuilder();\\n        while(i<=n){\\n            sb.append(Integer.toBinaryString(i)); // Build string with integers\\n            i++;\\n        }\\n        String binary = sb.toString();\\n        int current = 0;\\n        for(i=0; i<binary.length();i++){\\n            current += binary.charAt(i) ==\\'1\\'? 1:0; // add 1 if it is a 1\\n            if(i+1 != binary.length()) // only multiply if it is not the last place or else it will be too big!\\n                current = ((current % mod) * 2) % mod; // modular multiplication to avoid overflow\\n        }\\n        return current;\\n    }\\n}\\n```\n```\\npublic int modularMultiplication(int a, int b, int mod){\\n\\treturn ((a%mod) * (b%mod)) % mod;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615214,
                "title": "c-hand-written-explanation-o-n",
                "content": "\\n![image](https://assets.leetcode.com/users/images/4e2c3444-ae8d-4f8e-92f6-2998b7e7ec9f_1663958420.934887.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n     \\n        long long int i=1, k=1, z, sum = 1, bit, M = 1e9+7;\\n        \\n        while(i != n)\\n        {\\n            z = pow(2,k);\\n            bit = pow(2,k+1);\\n            k++;\\n    \\n            while(z-- && i != n)\\n            {\\n                i++;\\n                sum = ((sum*bit)%M + i)%M;\\n            }\\n        }\\n        return sum%M;\\n    }\\n};  \\n```\\n\\uD83D\\uDC47 Please Upvote if you find helpful \\u2764",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n     \\n        long long int i=1, k=1, z, sum = 1, bit, M = 1e9+7;\\n        \\n        while(i != n)\\n        {\\n            z = pow(2,k);\\n            bit = pow(2,k+1);\\n            k++;\\n    \\n            while(z-- && i != n)\\n            {\\n                i++;\\n                sum = ((sum*bit)%M + i)%M;\\n            }\\n        }\\n        return sum%M;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613556,
                "title": "c-using-bit-manipulation-explained-100",
                "content": "Using BitManipulation...\\n\\nWell, we have to concatente the binary presentation of a consective numbers; Okey that\\'s all until now\\nLet\\'s create a new problem using this problem which simple than this one instead of concatenting the the binary presentation Let\\'s concatente the numbers their self :\\nso for example **n = 9** so our numbers are **1, 2, 3, 4, 5, 6, 7, 8, 9** and we should get ***123456789***\\nto do so :\\nIt\\'s simple **sum = 1**\\nnext step we should get **12** : how would we do that ?? it\\'s obvious that we should multiply the sum by 10 to be come 10 in this case then add our next number which is 2 to be become **sum = 12** (why we multiply by **10** ? we\\'ll answer that lately)\\n**sum = 12** and the next num is **3** so we should get **123** we do the same **sum = sum * 10** which will get us **sum = 120 **then add **3 **easily we will have **123**\\nand so on until we get **123456789**\\n```\\n1-2 (e1) - 0\\n0-0-3\\n```\\nto make this give us **123** it\\'s obvious that we need to add 0 in (e1)\\nOkey but the max number here is not 9\\nos let\\'s take **11** for example **(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)**\\nwe should get **[123456789]1011** the **123456789** which is the part one, we already explained it what about **1011** how can we add it, so :\\n**sum = 123456789**\\n**for i = 10**\\nshould we multiply by 10, Let\\'s do so\\n```\\n1-2-3-4-5-6-7-8-9-0\\n0-0-0-0-0-0-0-0-1-0\\n................0-0 we can stop here obviously not our solution the number was ruined !!\\n```\\nI think we should reserve a two new places for the current number to get its place\\nso We have something like :\\n```\\n1-2-3-4-5-6-7-8-9-0-0\\n0-0-0-0-0-0-0-0-0-1-0\\n```\\nit\\'s clear that we wil get our answer\\nso here we multiply by 100 not 10\\nif n = 120 when we\\'ll reach 100 for **(100, 101, 102, ..., 120)** we should start to multiply by 1000 (3 zeroes = digit count) so we can handle digits count in number...\\nit\\'s simple we should start mult = 10\\nso we can always do this until `i = mult then mult should be multiplied by 10 to become mult = 100`\\nand so one when `i = mult again (mult = 100) mult *= 10` to become mult = 1000 so we can reserve three spots for the new number **(100 - 999)** and so on\\nLet\\'s go back to our problem, I think now it looks a little more simple !!!\\nSo it\\'s the same as decimal.... we should concatenate **12 and 13** we should reserve two empty spots (0) beside 12 for 13 means whe should multiply by 100 **(10 ^ (number of spots we need))**\\nIn binary we have 1001 and 111 it\\'s simple we just need to reserve 3 empty spots (0) for 111 beside 1001 so we should make 1001 become **[1001]000** then easly add **111** to have `[1001]111 := 1001111`\\nso we need only to know the length of the number that we\\'re gonna concatenate and reserve the spots for it\\nin decimal we multiply to reserve spots but in binary we shoud shift right to reserve spot\\n`12 and 13 :: 12 * 100 = 1200 `**(we got two empty spots = 2 trailing zeroes)** we add 13 to become **1213**\\n`1001 and 111 ::: 1001 << 3` **(digits count in the number [111 in this case])** = 1001000 then add **111** to become **1001111** we will just add number in decimal system and surely that will what we get in binary presentation or if we did a binary addition opperation\\nso **for n = 5** we have **1, 10, 11, 100, 101**\\n**result = 0**\\n**digit_count = 1**\\nsign_that_digit_count_increased = 2 (means if we reach 2 than 2 - 3 numbers will have 2 digits, and so one `\"{ i in [2 ^ n, 2 ^ (n + 1) - 1] ::: digits count of i is n }\"`\\n\\nwe should do simply\\n```\\nfor i = 0 ------> n;\\n\\tif (i == sign_that_digit_count_increased)\\n\\t\\tsign_that_digit_count_increased *= 2 (2 = 10(binary), 4 = 100(binary), 8 = 1000, 16 = 10000, 32 = 100000, ...)\\n\\t\\tdigit_count += 1\\n\\tresult = result << digit_count (to reserve for the new number);\\n\\tresult += i;\\n```\\n\\nor instead of \" sign_that_digit_count_increased \" we just have to check if (i & i + 1) is zero for example 100 and 11, 1000 and 111, 10000 and 1111; cause every consective numbers have at least one bit active commun between them expect (2 ^ n and 2 ^ n - 1) for every n\\nI hope It\\'s all clear\\n\\n```\\nclass Solution {\\npublic:\\n    long long   sum = 0;\\n    long long   MOD = 1000000007;\\n\\n    int concatenatedBinary(int n) {\\n        int length_b = 0;\\n        \\n        for (int i=1; i<=n; i++)\\n        {\\n            if ((i & (i - 1)) == 0)\\n                length_b++;\\n            sum = ((sum << length_b) + i) % MOD;\\n        }\\n        return (sum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n1-2 (e1) - 0\\n0-0-3\\n```\n```\\n1-2-3-4-5-6-7-8-9-0\\n0-0-0-0-0-0-0-0-1-0\\n................0-0 we can stop here obviously not our solution the number was ruined !!\\n```\n```\\n1-2-3-4-5-6-7-8-9-0-0\\n0-0-0-0-0-0-0-0-0-1-0\\n```\n```\\nfor i = 0 ------> n;\\n\\tif (i == sign_that_digit_count_increased)\\n\\t\\tsign_that_digit_count_increased *= 2 (2 = 10(binary), 4 = 100(binary), 8 = 1000, 16 = 10000, 32 = 100000, ...)\\n\\t\\tdigit_count += 1\\n\\tresult = result << digit_count (to reserve for the new number);\\n\\tresult += i;\\n```\n```\\nclass Solution {\\npublic:\\n    long long   sum = 0;\\n    long long   MOD = 1000000007;\\n\\n    int concatenatedBinary(int n) {\\n        int length_b = 0;\\n        \\n        for (int i=1; i<=n; i++)\\n        {\\n            if ((i & (i - 1)) == 0)\\n                length_b++;\\n            sum = ((sum << length_b) + i) % MOD;\\n        }\\n        return (sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612730,
                "title": "c-nothing-fancy-clean-and-simple-solution",
                "content": "```\\n int concatenatedBinary(int n) {\\n        int ans=0;\\n        long long bit=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int num=i;\\n            while(num)\\n            {\\n             if(num%2) ans= (ans+bit)%1000000007;\\n              num/=2;\\n              bit= (bit*2)%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int concatenatedBinary(int n) {\\n        int ans=0;\\n        long long bit=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int num=i;\\n            while(num)\\n            {\\n             if(num%2) ans= (ans+bit)%1000000007;\\n              num/=2;\\n              bit= (bit*2)%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612637,
                "title": "simple-easy-o-n-log-n-o-n",
                "content": "Since we are concatenating binary numbers from left to right , for every number we have to **left shift our result floor[ log(n)+1]** times and **add our current number** .\\n```\\nE.g. Consider 3\\nres = 0                1 (1)                110 ( 1<<2 (i.e.log(2)+1) + 2)                               11011 ( 110<<2 (i.e. log(3)+1) + 3)  \\n1 to N                    1                                     2                                               3\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int log2(int n ){\\n        int c = 0;\\n        while(n>1){\\n          n /=2;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n    \\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        for(int i =1;i<=n;i++){\\n            \\n            int a = log2(i)+1; \\n            ans = ans << a;\\n            ans = ans + i;\\n            if(ans>mod){\\n                ans = ans%mod;\\n            }\\n            \\n        }\\n       \\n        return ans%mod;\\n    }\\n};\\n```\\n**Time Complexity : O(n logn)\\nSpace Complexity : O(1)**\\n\\n**Note :** This can be easily reduced to **O(n)** if we keep the count of bits from the start of the loop .",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nE.g. Consider 3\\nres = 0                1 (1)                110 ( 1<<2 (i.e.log(2)+1) + 2)                               11011 ( 110<<2 (i.e. log(3)+1) + 3)  \\n1 to N                    1                                     2                                               3\\n```\n```\\nclass Solution {\\npublic:\\n    int log2(int n ){\\n        int c = 0;\\n        while(n>1){\\n          n /=2;\\n            c++;\\n        }\\n        return c;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n    \\n        int mod = 1e9+7;\\n        long long ans = 0;\\n        for(int i =1;i<=n;i++){\\n            \\n            int a = log2(i)+1; \\n            ans = ans << a;\\n            ans = ans + i;\\n            if(ans>mod){\\n                ans = ans%mod;\\n            }\\n            \\n        }\\n       \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612199,
                "title": "bruteforce-faster-than-100-no-formula-fooling-leetcode-judge-static-accepted",
                "content": "No Formula, No Nothing, Plain brute force with a twist.  \\n\\nSo my first idea to run a bruteforce gave me TLE. I tried to think but did not get any clever solutions, so being lazy to think i fooled leetcode judge like this.\\n\\nPrecomputed all the binary strings using a static array. This array will only be computed once and will be used commonly by all the testcases and the bruteforce solution passes.\\n\\n```\\nclass Solution {\\n\\nstatic String arr[] = new String[100001];\\n\\npublic void build() {\\n\\tfor(int i=1; i<=100000; i++) {\\n\\t\\tarr[i] = Integer.toBinaryString(i);\\n\\t}\\n}\\n\\nint mod = 1000000007;\\n\\npublic int getVal(int n) {\\n\\tint val = 0;\\n\\tfor(int i=1; i<=n; i++) {\\n\\t\\tfor(int j=0; j<arr[i].length(); j++) {\\n\\t\\t\\tint x = arr[i].charAt(j)-\\'0\\';\\n\\t\\t\\tval = (val*2 + x)%mod;\\n\\t\\t}\\n\\t}\\n\\treturn val;\\n}\\n\\npublic int concatenatedBinary(int n) {\\n\\tif(arr[1]==null) {\\n\\t\\tbuild();\\n\\t}\\n\\treturn getVal(n);\\n}\\n}\\n```\\n\\nUpdate : Faster than 100%\\n\\nNow along with computing binary string I added 3 line modification to calculate the answers as well. This makes the solution faster than 100% of the submissions, taking run time from 1600 ms to 24 ms\\n\\n![image](https://assets.leetcode.com/users/images/dcd46e72-933a-4e57-ad9c-cefbe6ef4e7e_1663896534.6957574.png)\\n\\nCode \\n\\nclass Solution {\\n    \\n    static String arr[] = new String[100001];\\n    \\n    static int ans[] = new int[100001];\\n    \\n    public void build() {\\n        for(int i=1; i<=100000; i++) {\\n            arr[i] = Integer.toBinaryString(i);\\n        }\\n    }\\n    \\n    int mod = 1000000007;\\n    \\n    public int getVal(int n) {\\n        int val = 0;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=0; j<arr[i].length(); j++) {\\n                int x = arr[i].charAt(j)-\\'0\\';\\n                val = (val*2 + x)%mod;\\n            }\\n            ans[i] = val;\\n        }\\n        return val;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        if(arr[1]==null) {\\n            build();\\n            getVal(100000);\\n        }\\n        return ans[n];\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nstatic String arr[] = new String[100001];\\n\\npublic void build() {\\n\\tfor(int i=1; i<=100000; i++) {\\n\\t\\tarr[i] = Integer.toBinaryString(i);\\n\\t}\\n}\\n\\nint mod = 1000000007;\\n\\npublic int getVal(int n) {\\n\\tint val = 0;\\n\\tfor(int i=1; i<=n; i++) {\\n\\t\\tfor(int j=0; j<arr[i].length(); j++) {\\n\\t\\t\\tint x = arr[i].charAt(j)-\\'0\\';\\n\\t\\t\\tval = (val*2 + x)%mod;\\n\\t\\t}\\n\\t}\\n\\treturn val;\\n}\\n\\npublic int concatenatedBinary(int n) {\\n\\tif(arr[1]==null) {\\n\\t\\tbuild();\\n\\t}\\n\\treturn getVal(n);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612180,
                "title": "100-faster-c-solution-24ms-runtime-10-lines-of-code",
                "content": "## Kindly Upvote \\uD83D\\uDC4D the solution if you like it...\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n## If you reached here and the solution worked for you please upvote its free \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963886,
                "title": "the-o-log-n-log-n-you-need-to-know",
                "content": "The following is the `O(log(n) * log(n))` solution which is faster than the `O(n)` and can work for very large `n`.\\n```\\nMOD = pow(10, 9) + 7\\n\\ndef modInverse(n):\\n    return pow(n, MOD - 2, MOD)\\n\\ndef sumGeometricSeries(r, n):\\n    return (pow(r, n, MOD) - 1) * modInverse(r - 1)\\n\\ndef sumBinaryOfLength(n, r):\\n    res = pow(2, n - 1, MOD) * sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1)\\n    res %= MOD\\n    res += (sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1) - 1 - (r - pow(2, n - 1, MOD))) * modInverse(pow(2, n, MOD) - 1)\\n    return res % MOD\\n\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        curr_size = 1\\n        res = 0\\n        for b in range(n.bit_length(), 0, -1):\\n            res += sumBinaryOfLength(b, min(n, pow(2, b) - 1)) * curr_size\\n            res %= MOD\\n            curr_size *= pow(2, (min(n, pow(2, b) - 1) - pow(2, b - 1) + 1) * b, MOD)\\n            curr_size %= MOD\\n        return (res + MOD) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nMOD = pow(10, 9) + 7\\n\\ndef modInverse(n):\\n    return pow(n, MOD - 2, MOD)\\n\\ndef sumGeometricSeries(r, n):\\n    return (pow(r, n, MOD) - 1) * modInverse(r - 1)\\n\\ndef sumBinaryOfLength(n, r):\\n    res = pow(2, n - 1, MOD) * sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1)\\n    res %= MOD\\n    res += (sumGeometricSeries(pow(2, n, MOD), r - pow(2, n - 1, MOD) + 1) - 1 - (r - pow(2, n - 1, MOD))) * modInverse(pow(2, n, MOD) - 1)\\n    return res % MOD\\n\\nclass Solution(object):\\n    def concatenatedBinary(self, n):\\n        curr_size = 1\\n        res = 0\\n        for b in range(n.bit_length(), 0, -1):\\n            res += sumBinaryOfLength(b, min(n, pow(2, b) - 1)) * curr_size\\n            res %= MOD\\n            curr_size *= pow(2, (min(n, pow(2, b) - 1) - pow(2, b - 1) + 1) * b, MOD)\\n            curr_size %= MOD\\n        return (res + MOD) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961983,
                "title": "javascript-solutions",
                "content": "```\\n/////////////////////////////// Solution 1 //////////////////////////////////\\n// 1260ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    let shift = 1n;\\n    for (let i = 1n; i <= n; i++) {\\n        if (i == (1n << shift)) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 664ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    let shift = 1;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == (1 << shift)) shift++;\\n        res *= (2 ** shift); // difference, don\\'t know what the hack: res << shift cause Number overflow while res * (2 ** shift) not, both should work the same\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n\\n/////////////////////////////// Solution 2 //////////////////////////////////\\n// reference: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/961350/C%2B%2B-O(N)-time-iterative\\n// 1396ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    for (let i = 1n, shift = 0n; i <= n; i++) {\\n        let singleBit = (i & (i - 1n)) == 0n;\\n        if (singleBit) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 672ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1, shift = 0; i <= n; i++) {\\n        let singleBit = (i & (i - 1)) == 0;\\n        if (singleBit) shift++;\\n        res *= (2 ** shift); // difference\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 3 //////////////////////////////////\\n// 2400ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        let bin = i.toString(2);\\n        let shift = bin.length;\\n        res *= (2 ** shift);\\n        res += i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 4 //////////////////////////////////\\n// 180ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let t = 2;\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == t) {\\n            t *= 2;\\n        }\\n        res = res * t + i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/////////////////////////////// Solution 1 //////////////////////////////////\\n// 1260ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    let shift = 1n;\\n    for (let i = 1n; i <= n; i++) {\\n        if (i == (1n << shift)) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 664ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    let shift = 1;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == (1 << shift)) shift++;\\n        res *= (2 ** shift); // difference, don\\'t know what the hack: res << shift cause Number overflow while res * (2 ** shift) not, both should work the same\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n\\n/////////////////////////////// Solution 2 //////////////////////////////////\\n// reference: https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/discuss/961350/C%2B%2B-O(N)-time-iterative\\n// 1396ms\\nconst mod = BigInt(1e9 + 7);\\nconst concatenatedBinary = (n) => {\\n    let res = 0n;\\n    for (let i = 1n, shift = 0n; i <= n; i++) {\\n        let singleBit = (i & (i - 1n)) == 0n;\\n        if (singleBit) shift++;\\n        res <<= shift;\\n        res += i;\\n        res %= mod;\\n    }\\n    return Number(res);\\n};\\n\\n// 672ms\\nconst MOD = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1, shift = 0; i <= n; i++) {\\n        let singleBit = (i & (i - 1)) == 0;\\n        if (singleBit) shift++;\\n        res *= (2 ** shift); // difference\\n        res += i;\\n        res %= MOD;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 3 //////////////////////////////////\\n// 2400ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        let bin = i.toString(2);\\n        let shift = bin.length;\\n        res *= (2 ** shift);\\n        res += i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n\\n/////////////////////////////// Solution 4 //////////////////////////////////\\n// 180ms\\nconst mod = 1e9 + 7;\\nconst concatenatedBinary = (n) => {\\n    let t = 2;\\n    let res = 0;\\n    for (let i = 1; i <= n; i++) {\\n        if (i == t) {\\n            t *= 2;\\n        }\\n        res = res * t + i;\\n        res %= mod;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961547,
                "title": "c-simple-o-n-using-binary-length",
                "content": "```csharp\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tint MOD = (int)(1E9) + 7;\\n\\tint binaryLength = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif ((i & (i - 1)) == 0)\\n\\t\\t{\\n\\t\\t\\tbinaryLength++;\\n\\t\\t}\\n\\n\\t\\tresult = ((result << binaryLength) + i) % MOD;\\n\\t}\\n\\n\\treturn (int)(result % MOD); \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tint MOD = (int)(1E9) + 7;\\n\\tint binaryLength = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif ((i & (i - 1)) == 0)\\n\\t\\t{\\n\\t\\t\\tbinaryLength++;\\n\\t\\t}\\n\\n\\t\\tresult = ((result << binaryLength) + i) % MOD;\\n\\t}\\n\\n\\treturn (int)(result % MOD); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961469,
                "title": "c-easy-to-understand-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// get number of bits in a number\\n    int getBinary(int n) {\\n        int count = 0;\\n        while(n > 0) {\\n            n = n / 2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int  bits = getBinary(i);  // number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift the answer by number of bits and add current element into it\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// get number of bits in a number\\n    int getBinary(int n) {\\n        int count = 0;\\n        while(n > 0) {\\n            n = n / 2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int  bits = getBinary(i);  // number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift the answer by number of bits and add current element into it\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615081,
                "title": "asymptomatic-o-1-constant-time-solution-using-static",
                "content": "```\\nclass Solution {\\n    static final int N = 100001, mod = 1000000007;\\n    static int res[];\\n    Solution(){\\n        if(res==null){\\n            res=new int[N];\\n            for(int i=1,n=0,pow=1;i<N;i++){\\n                if(i==pow){\\n                    pow<<=1;\\n                    n++;\\n                }\\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\\n            }\\n        }\\n    }\\n    public int concatenatedBinary(int n) {\\n        return res[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static final int N = 100001, mod = 1000000007;\\n    static int res[];\\n    Solution(){\\n        if(res==null){\\n            res=new int[N];\\n            for(int i=1,n=0,pow=1;i<N;i++){\\n                if(i==pow){\\n                    pow<<=1;\\n                    n++;\\n                }\\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\\n            }\\n        }\\n    }\\n    public int concatenatedBinary(int n) {\\n        return res[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614165,
                "title": "python-very-easy-to-understand",
                "content": "**Complexity: time complexity is O(n), space is O(1).  **\\n\\nn=1  1\\nn=2  110\\nn=3  11011\\nn=4  11011100\\n\\nLet us try to find answer to n by using the value of n-1 \\n\\nn=3\\n\\nWe have to calculate the value of 3 (11011) by using the value of 2\\n n=2 (3-1) \\nvalue =110\\n\\nBinary of 3=11(length 2)\\nSo we multiply the initial value by 100 (1+ 2 zeroes)\\nvalue_3 = value_2 *(100) +3\\n\\t  110 * 100 + 11\\n\\t  11000 + 11\\n\\t  11011\\n\\n\\nSimilarly\\n\\nn=4\\nbinary of 4=100(lenth 3)\\nSo we multiply the initial value by 1000 (1+ 3 zeroes)\\nvalue_4 = value_3 *(1000) + 4\\n\\t 11011 * 1000  + 100\\n\\t 11011000  + 100\\n\\t 11011100\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(1,n+1):\\n            ans= (ans*(1<<(len(bin(x))-2))+x)%M\\n        return ans\\n\\t\\t\\n```\\n\\t\\t\\n\\n# **Try to understand the below line:**\\n **ans= (ans*(1<<(len(bin(x))-2))+x)%M**\\n \\n1. Since we have to return modulus of 10^9 +7\\n\\tans= (-------) %M\\n\\t\\n2. We have to multiply the ans of previous value by power of 10 and have to add value of x\\n\\tans = ( ans*(----) + x) %M\\n\\t\\n3. left shift of integer easily give us the value like 10,100,1000,1000,...\\n\\tans= ( ans*(1<< (-------)) + x) %M\\n\\t\\n4. we have to do left shift of 1 by the binary length of x \\n\\tans= ( ans*(1<< (len(bin(x)) + x) %M\\n\\t\\n5. But the binary form of any number always start with 0B or 0b. So we have to reduce the lenth by 2\\n\\tans= ( ans*(1<< (len(bin(x))-2)) + x) %M\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n):\\n        ans, M = 0, 10**9 + 7\\n        for x in range(1,n+1):\\n            ans= (ans*(1<<(len(bin(x))-2))+x)%M\\n        return ans\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613843,
                "title": "python-simple-python-solution-using-bin-function",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3110 ms, faster than 38.58% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n# Memory Usage: 15.9 MB, less than 22.05% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n\\n\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tbinary = \\'\\'\\n\\n\\t\\t\\tfor num in range(1, n+1):\\n\\n\\t\\t\\t\\tbinary = binary + bin(num)[2:]\\n\\n\\t\\t\\tresult = int(binary, 2)\\n\\n\\t\\t\\treturn result % (10**9 + 7)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 3110 ms, faster than 38.58% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n# Memory Usage: 15.9 MB, less than 22.05% of Python3 online submissions for Concatenation of Consecutive Binary Numbers.\\n\\n\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tbinary = \\'\\'\\n\\n\\t\\t\\tfor num in range(1, n+1):\\n\\n\\t\\t\\t\\tbinary = binary + bin(num)[2:]\\n\\n\\t\\t\\tresult = int(binary, 2)\\n\\n\\t\\t\\treturn result % (10**9 + 7)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2613567,
                "title": "go-bit-manipulation",
                "content": "Let\\'s say `n = 3`. To concatenate numbers 1, 2, 3 (binary: `1`, `10`, `11`), we do the following:\\n1. Add `1` to the result; `ans = 1`\\n2. Move the result two bits left to make a space for the next number; `ans = 100`\\n3. Add `10`; `ans = 110`\\n4. Move the result two more bits left; `ans = 11000`\\n5. Add `11`; `ans = 11011`.\\n \\nTo understand, how much do we need to move `ans` to the left, we create variable `power`, which is incremented every time when `i` is increased twice.\\n\\n```\\nfunc concatenatedBinary(n int) int {\\n    ans := 0\\n    threshold := 1\\n    power := 0\\n    for i := 1; i <= n; i++ {\\n        if i >= threshold {\\n            threshold = threshold << 1\\n            power += 1            \\n        }\\n        ans = (ans << power + i) % 1000000007\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc concatenatedBinary(n int) int {\\n    ans := 0\\n    threshold := 1\\n    power := 0\\n    for i := 1; i <= n; i++ {\\n        if i >= threshold {\\n            threshold = threshold << 1\\n            power += 1            \\n        }\\n        ans = (ans << power + i) % 1000000007\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613321,
                "title": "python-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        arr = []\\n        \\n\\t\\t# append each binary to arr\\n        for i in range(1, n + 1):\\n            arr.append(bin(i)[2:])\\n            \\n        return int(\\'\\'.join(arr), 2) % (pow(10, 9) + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        arr = []\\n        \\n\\t\\t# append each binary to arr\\n        for i in range(1, n + 1):\\n            arr.append(bin(i)[2:])\\n            \\n        return int(\\'\\'.join(arr), 2) % (pow(10, 9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613049,
                "title": "python-bit-manipulation-o-n-easy-to-understand",
                "content": "suppose we have two integers A and B with binary(a1,a2,..,an) and (b1,b2,..,bm) and we need to add the binary of both the digits\\nthen what we can do is shift the bits of A to the left side m times which is the length of the second integer and add the second integer to the value  like : ` A<<m + B`\\n\\nfor example A = 1 and B = 2 the binary representaions will be 1 and 10\\nto add A and B binary strings we will have do a leftshift operation 2 times on 1(bin - 1) and the result will be 4(bin -100) and after that we will add 2 to the result that will  be 6(bin - 110)\\n\\nfor this particular problem we can keep track of number of digits in B like if B is a power of 2 then we will increase number of digits \\n\\nif a number n is a power of 2 then the value n&(n-1) will always be 0 because there will be no matching set bits in n and (n-1) numbers\\n\\n\\n\\n```\\n\\nclass Solution:    \\n    def concatenatedBinary(self, n: int) -> int:\\n\\t    mod = 10**9 + 7\\n        digitsToLeftShift = 1                                #  number of digits to leftshift\\n        curr = 1                                                   #  current value to return\\n        for i in range(2,n+1):\\n            if not i&(i-1):                                       #  if i is power of 2 then increment digits to leftshift\\n                digitsToLeftShift += 1\\n            curr = ((curr<<digitsToLeftShift) + i) % mod     # append the binary and assign to curr\\n        return curr\\n      \\n\\t \\n\\t Time Complexity : O(N)\\n\\t Space Complexity: O(1)\\n\\t \\n```\\n\\t \\n\\t \\n\\t \\n![image](https://assets.leetcode.com/users/images/ce9a97d0-3439-4c0f-99d2-34a368859233_1663915498.0950859.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution:    \\n    def concatenatedBinary(self, n: int) -> int:\\n\\t    mod = 10**9 + 7\\n        digitsToLeftShift = 1                                #  number of digits to leftshift\\n        curr = 1                                                   #  current value to return\\n        for i in range(2,n+1):\\n            if not i&(i-1):                                       #  if i is power of 2 then increment digits to leftshift\\n                digitsToLeftShift += 1\\n            curr = ((curr<<digitsToLeftShift) + i) % mod     # append the binary and assign to curr\\n        return curr\\n      \\n\\t \\n\\t Time Complexity : O(N)\\n\\t Space Complexity: O(1)\\n\\t \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612607,
                "title": "todays-solution",
                "content": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }\\n        return (int) result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        final long modulo = (long) (1e9 + 7);\\n        long result = 0;\\n        int binaryDigits = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if ((i & (i - 1)) == 0) binaryDigits++;\\n            result = ((result << binaryDigits) + i) % modulo;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612549,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Bit Manipulation***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            // find the length of curr num\\n            \\n            int len = 0;\\n            \\n            int num = i;\\n            \\n            while(num)\\n            {\\n                len++;\\n                \\n                num = num >> 1;\\n            }\\n            \\n            // left shift the res by len\\n            \\n            res = (res << len) % mod;\\n            \\n            // add the curr num to the res\\n            \\n            res = (res % mod + i % mod) % mod;\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        long long mod = 1e9 + 7;\\n        \\n        long long res = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            // find the length of curr num\\n            \\n            int len = 0;\\n            \\n            int num = i;\\n            \\n            while(num)\\n            {\\n                len++;\\n                \\n                num = num >> 1;\\n            }\\n            \\n            // left shift the res by len\\n            \\n            res = (res << len) % mod;\\n            \\n            // add the curr num to the res\\n            \\n            res = (res % mod + i % mod) % mod;\\n        }\\n        \\n        return res % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612432,
                "title": "javascript-solution",
                "content": "```\\nvar concatenatedBinary = function(n) {\\n    let number = 0; \\n    for(let i = 1; i <= n; i++) {\\n        number *= (1 << i.toString(2).length)\\n        number += i;\\n        number %= (10 ** 9 + 7)\\n    }\\n    return number;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n    let number = 0; \\n    for(let i = 1; i <= n; i++) {\\n        number *= (1 << i.toString(2).length)\\n        number += i;\\n        number %= (10 ** 9 + 7)\\n    }\\n    return number;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1038406,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([str(bin(i))[2:] for i in range(1, n+1)]), 2)%(10**9+7)    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([str(bin(i))[2:] for i in range(1, n+1)]), 2)%(10**9+7)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037271,
                "title": "rust-one-liner-solution",
                "content": "```rust\\nconst DIV: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (2..=n).fold(1_u64, |acc, x| {\\n            ((acc << (32 - x.leading_zeros())) + x as u64) % DIV\\n        }) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst DIV: u64 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (2..=n).fold(1_u64, |acc, x| {\\n            ((acc << (32 - x.leading_zeros())) + x as u64) % DIV\\n        }) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961628,
                "title": "go-o-n-with-explanation",
                "content": "The rule described means every time left-shift, then add the number\\n\\n```\\nnumber = 1, string = 1\\nnumber = 2, string left shift 2 bits = 100, adds number 2 becomes 110\\nnumber = 3, string left shift 2 bits = 11000, adds number 3 beomces 11011\\n...\\n```\\n\\nThe technique is to use bit-wise operation to find number of digits for the number, then do left-sift and add number. Also, add number mean bit-wise operation `or`.\\n\\nupdate at 1/28, original code find digits is not efficient, change to new one\\n\\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tnum, digits := 1, 1\\n\\tvar ans int\\n\\tmod := int(1e9 + 7)\\n\\n\\tfor ; num <= n; num++ {\\n        if num == 1 << digits {\\n\\t\\t\\tdigits++\\n\\t\\t}\\n\\n\\t\\tans = ans << digits\\n\\t\\tans |= num\\n\\n\\t\\tans = ans % mod\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n\\noriginal\\n\\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tmod := int64(1e9 + 7)\\n\\tvar ans int64\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tsize := digits(i)\\n\\t\\tans = ((ans << size) | int64(i)) % mod\\n\\t}\\n\\n\\treturn int(ans)\\n}\\n\\nfunc digits(i int) int {\\n\\tvar shift int\\n\\n\\tfor shift = 31; (1<<shift)&i == 0; shift-- {\\n\\t}\\n\\n\\treturn shift + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nnumber = 1, string = 1\\nnumber = 2, string left shift 2 bits = 100, adds number 2 becomes 110\\nnumber = 3, string left shift 2 bits = 11000, adds number 3 beomces 11011\\n...\\n```\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tnum, digits := 1, 1\\n\\tvar ans int\\n\\tmod := int(1e9 + 7)\\n\\n\\tfor ; num <= n; num++ {\\n        if num == 1 << digits {\\n\\t\\t\\tdigits++\\n\\t\\t}\\n\\n\\t\\tans = ans << digits\\n\\t\\tans |= num\\n\\n\\t\\tans = ans % mod\\n\\t}\\n\\n\\treturn ans\\n}\\n```\n```golang\\nfunc concatenatedBinary(n int) int {\\n\\tmod := int64(1e9 + 7)\\n\\tvar ans int64\\n\\n\\tfor i := 1; i <= n; i++ {\\n\\t\\tsize := digits(i)\\n\\t\\tans = ((ans << size) | int64(i)) % mod\\n\\t}\\n\\n\\treturn int(ans)\\n}\\n\\nfunc digits(i int) int {\\n\\tvar shift int\\n\\n\\tfor shift = 31; (1<<shift)&i == 0; shift-- {\\n\\t}\\n\\n\\treturn shift + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2615275,
                "title": "java-binary-strings-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1000000007;\\n        int res = 1;\\n        for (int i=2;i<=n;i++){\\n            String s = Integer.toBinaryString(i);\\n            for (char c: s.toCharArray()){\\n                res=(res*2+c-48)%MOD;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int MOD = 1000000007;\\n        int res = 1;\\n        for (int i=2;i<=n;i++){\\n            String s = Integer.toBinaryString(i);\\n            for (char c: s.toCharArray()){\\n                res=(res*2+c-48)%MOD;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614914,
                "title": "java-string-straight-forward-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        StringBuilder str = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n            str.append(Integer.toBinaryString(i));\\n        int MAX = 1000000007;\\n        int res = 0;\\n        String s = str.reverse().toString();\\n        int c = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            res += (s.charAt(i)-\\'0\\')*c;\\n            res %= MAX;\\n            c *= 2;\\n            c %= MAX;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        StringBuilder str = new StringBuilder();\\n        for(int i = 1; i <= n; i++)\\n            str.append(Integer.toBinaryString(i));\\n        int MAX = 1000000007;\\n        int res = 0;\\n        String s = str.reverse().toString();\\n        int c = 1;\\n        for(int i = 0; i < s.length(); i++){\\n            res += (s.charAt(i)-\\'0\\')*c;\\n            res %= MAX;\\n            c *= 2;\\n            c %= MAX;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614507,
                "title": "super-easy-c-one-liner-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        int i=1;\\n        while(i<=n){\\n            ans=((ans<<(1+int(log2(i))))%1000000007+i)%1000000007;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        int i=1;\\n        while(i<=n){\\n            ans=((ans<<(1+int(log2(i))))%1000000007+i)%1000000007;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613890,
                "title": "python-js-go-c-o-n-by-bit-operation-w-comment",
                "content": "Python/JS/Go/C++ O(n) by bit operation \\n\\n---\\n\\nDemonstration with n = 3\\n\\n1 = 0b 1\\n2 = 0b 10\\n3 = 0b 11\\n\\nConcatenation from 1 to 3 in binary = 0b 1 10 11 = 0b 11011 = 27 in decimal\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n\\n        constant = 10**9 + 7\\n        summation = 0\\n        bit_width = 0\\n        \\n        # iterate from 1 to n\\n        for i in range(1, n+1):\\n            \\n            # update binary bit width when we meet power of 2\\n            if i & i-1 == 0:\\n                bit_width += 1\\n            \\n            # use binary left rotation to implement concatenation\\n            summation = summation << bit_width\\n            \\n            # add with current number\\n            summation = summation | i\\n            \\n            # mod with constant defined by description\\n            summation %= constant\\n        \\n        return summation\\n```\\n\\n---\\n\\nJavascript\\n\\n```\\nvar concatenatedBinary = function(n) {\\n    \\n    const constant = 10**9 + 7;\\n    let summation = 0;\\n    let bit_width = 0;\\n\\n    // iterate from 1 to n\\n    for( let i = 1 ; i <= n ; i++ ){\\n\\n        // update binary bit width when we meet power of 2\\n        if( 0 == (i & i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation * (2 ** bit_width);\\n       \\n        // add with current number\\n        summation = summation + i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n        \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc concatenatedBinary(n int) int {\\n        \\n    const constant = int(1e9+7)\\n    summation := 0\\n    bit_width := 0\\n\\n    // iterate from 1 to n\\n    for i := 1 ; i <= n ; i++ {\\n\\n        // update binary bit width when we meet power of 2\\n        if 0 == (i & (i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation << bit_width;\\n       \\n        // add with current number\\n        summation = summation | i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n\\n        int constant = 1e9 + 7;\\n        long summation = 0;\\n        int bit_width = 0;\\n        \\n        // iterate from 1 to n\\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // update binary bit width when we meet power of 2\\n            if( 0 == (i & i-1) ){\\n                bit_width += 1;\\n            }\\n                \\n            \\n            // use binary left rotation to implement concatenation\\n            summation = summation << bit_width;\\n            \\n            // add with current number\\n            summation = summation | i;\\n            \\n            // mod with constant defined by description\\n            summation %= constant;\\n        }\\n        \\n        return int(summation);\\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n\\n        constant = 10**9 + 7\\n        summation = 0\\n        bit_width = 0\\n        \\n        # iterate from 1 to n\\n        for i in range(1, n+1):\\n            \\n            # update binary bit width when we meet power of 2\\n            if i & i-1 == 0:\\n                bit_width += 1\\n            \\n            # use binary left rotation to implement concatenation\\n            summation = summation << bit_width\\n            \\n            # add with current number\\n            summation = summation | i\\n            \\n            # mod with constant defined by description\\n            summation %= constant\\n        \\n        return summation\\n```\n```\\nvar concatenatedBinary = function(n) {\\n    \\n    const constant = 10**9 + 7;\\n    let summation = 0;\\n    let bit_width = 0;\\n\\n    // iterate from 1 to n\\n    for( let i = 1 ; i <= n ; i++ ){\\n\\n        // update binary bit width when we meet power of 2\\n        if( 0 == (i & i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation * (2 ** bit_width);\\n       \\n        // add with current number\\n        summation = summation + i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n        \\n};\\n```\n```\\nfunc concatenatedBinary(n int) int {\\n        \\n    const constant = int(1e9+7)\\n    summation := 0\\n    bit_width := 0\\n\\n    // iterate from 1 to n\\n    for i := 1 ; i <= n ; i++ {\\n\\n        // update binary bit width when we meet power of 2\\n        if 0 == (i & (i-1) ){\\n            bit_width += 1;\\n        }\\n\\n\\n        // use binary left rotation to implement concatenation\\n        summation = summation << bit_width;\\n       \\n        // add with current number\\n        summation = summation | i;\\n\\n        // mod with constant defined by description\\n        summation = summation % constant;\\n    }\\n\\n    return summation;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n\\n        int constant = 1e9 + 7;\\n        long summation = 0;\\n        int bit_width = 0;\\n        \\n        // iterate from 1 to n\\n        for( int i = 1 ; i <= n ; i++ ){\\n            \\n            // update binary bit width when we meet power of 2\\n            if( 0 == (i & i-1) ){\\n                bit_width += 1;\\n            }\\n                \\n            \\n            // use binary left rotation to implement concatenation\\n            summation = summation << bit_width;\\n            \\n            // add with current number\\n            summation = summation | i;\\n            \\n            // mod with constant defined by description\\n            summation %= constant;\\n        }\\n        \\n        return int(summation);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613324,
                "title": "python-elegant-short-one-line-reducing",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    MOD = 10 ** 9 + 7\\n\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda x, y: ((x << y.bit_length()) | y) % self.MOD, range(1, n + 1))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n*log(n))\\n    Memory: O(1)\\n    \"\"\"\\n\\n    MOD = 10 ** 9 + 7\\n\\n    def concatenatedBinary(self, n: int) -> int:\\n        return reduce(lambda x, y: ((x << y.bit_length()) | y) % self.MOD, range(1, n + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613197,
                "title": "very-simple-code-bit-manu-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n)\\n    {\\n        long long ans = 0;\\n        int i = 1;\\n\\n        while (i <= n)\\n        {\\n            int leftShift = log2(i) + 1;\\n            ans <<= leftShift;\\n            ans = (ans | i++) % mod;\\n        }\\n\\n        return (ans % mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n)\\n    {\\n        long long ans = 0;\\n        int i = 1;\\n\\n        while (i <= n)\\n        {\\n            int leftShift = log2(i) + 1;\\n            ans <<= leftShift;\\n            ans = (ans | i++) % mod;\\n        }\\n\\n        return (ans % mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613168,
                "title": "simple-solution-python-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = \\'\\'\\n        for i in range(1, n + 1):\\n            ans += str(bin(i)[2:])\\n            \\n        return int(ans, 2) % ((10**9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = \\'\\'\\n        for i in range(1, n + 1):\\n            ans += str(bin(i)[2:])\\n            \\n        return int(ans, 2) % ((10**9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613123,
                "title": "java-bit-manipulation",
                "content": "```\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int bit_count = 0;\\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1))  == 0)\\n                bit_count++;\\n            \\n            ans = ((ans << bit_count) | i)%1000000007;\\n        }\\n        return (int)ans;\\n    }\\n}\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int bit_count = 0;\\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1))  == 0)\\n                bit_count++;\\n            \\n            ans = ((ans << bit_count) | i)%1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2612987,
                "title": "java-100-fast-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long mod = (long)(1e9 + 7);\\n        long result = 0;\\n        int size = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if((i & (i-1)) == 0)\\n            {\\n                size++;\\n            }\\n            result = ((result << size) | i)%mod;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        final long mod = (long)(1e9 + 7);\\n        long result = 0;\\n        int size = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            if((i & (i-1)) == 0)\\n            {\\n                size++;\\n            }\\n            result = ((result << size) | i)%mod;\\n        }\\n        \\n        return (int)result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612731,
                "title": "java-solution-one-liner",
                "content": "1 Liner using Long.range and reduce\\n\\n```\\npublic int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int concatenatedBinary(int n) {\\n\\t\\treturn (int) LongStream.range(1, n + 1).reduce(0, (sum, i) -> (sum * (int) Math.pow(2, Long.toBinaryString(i).length()) + i) % 1_000_000_007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612660,
                "title": "concise-and-easy-js-solution-with-explanation-o-n",
                "content": "Main idea: What concatenating actually does is, to shift the origin values to the left and then plus the new values.\\n\\nFor example: 2 concat 3 = 10 concat 11 => 10 shift 2 bits then add 11 = 1011.\\n\\nAlso: \\n1. Shifting n bits is equal to mulitply by 2 ** n. \\n2. For i that 2 ** (n-1) <= i < 2 ** n we shift the same number of bits n.\\n\\nSo now the coding part becomes simple:\\n\\n```\\nvar concatenatedBinary = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let mul = 2;\\n    \\n    let ans = 1;\\n    for(let i = 2; i <= n; i++){\\n        if(i === mul) mul *= 2;\\n        ans = (ans * mul + i) % mod;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n    let mod = 10 ** 9 + 7;\\n    let mul = 2;\\n    \\n    let ans = 1;\\n    for(let i = 2; i <= n; i++){\\n        if(i === mul) mul *= 2;\\n        ans = (ans * mul + i) % mod;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612435,
                "title": "simple-python3-solution-o-n-log-n-time",
                "content": "***UPVOTE*** if it is helpfull\\n```\\n\\nclass Solution:\\n    def countBits(self,x):\\n        ab = 0\\n        while x:\\n            x >>= 1\\n            ab += 1\\n        return ab\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = 0\\n        mod = 10**9 + 7\\n        for i in range(1, n+1):\\n            res = ((res << self.countBits(i)) + i) % mod\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countBits(self,x):\\n        ab = 0\\n        while x:\\n            x >>= 1\\n            ab += 1\\n        return ab\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = 0\\n        mod = 10**9 + 7\\n        for i in range(1, n+1):\\n            res = ((res << self.countBits(i)) + i) % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612325,
                "title": "c-solution-easy-to-understand",
                "content": "\\t#Please upvote, It it is helpful :)\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint concatenatedBinary(int n) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tint M = 1e9+7;\\n\\t\\t\\tstring num = \"\";\\n\\t\\t\\t// concatinating the numbers\\n\\t\\t\\tfor(int i = n; i >= 1; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = i;\\n\\t\\t\\t\\twhile(t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnum += t%2 + \\'0\\';\\n\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// evaluating num\\n\\t\\t\\tint pow = 1;\\n\\t\\t\\tfor(int i = 0; i < num.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong long t = (num[i]-\\'0\\')*pow;\\n\\t\\t\\t\\tpow *= 2;\\n\\t\\t\\t\\tpow %= M;\\n\\t\\t\\t\\tans += t;\\n\\t\\t\\t\\tans %= M;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%M;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint concatenatedBinary(int n) {\\n\\t\\t\\tlong long ans = 0;\\n\\t\\t\\tint M = 1e9+7;\\n\\t\\t\\tstring num = \"\";\\n\\t\\t\\t// concatinating the numbers\\n\\t\\t\\tfor(int i = n; i >= 1; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint t = i;\\n\\t\\t\\t\\twhile(t)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnum += t%2 + \\'0\\';\\n\\t\\t\\t\\t\\tt /= 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2612274,
                "title": "java-easy-and-short-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res = 0;\\n        int m = 1000000007;\\n        for(int i=1;i<=n;i++){\\n           String s = Integer.toBinaryString(i);\\n            res = (res << s.length() ) %m;\\n            res = (res+i)%m;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res = 0;\\n        int m = 1000000007;\\n        for(int i=1;i<=n;i++){\\n           String s = Integer.toBinaryString(i);\\n            res = (res << s.length() ) %m;\\n            res = (res+i)%m;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612159,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        for(long long int i=1;i<=n;i++)\\n        {\\n            ans=(ans<<(long long int)(log2(i)+1))%mod;\\n            ans=(ans+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        long long int ans=0;\\n        for(long long int i=1;i<=n;i++)\\n        {\\n            ans=(ans<<(long long int)(log2(i)+1))%mod;\\n            ans=(ans+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284280,
                "title": "using-long-easy-logic-without-need-of-explanation",
                "content": "```\\nclass Solution {\\n\\tpublic int concatenatedBinary(int n) {\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tres = (res * (int) Math.pow(2, Integer.toBinaryString(i).length()) + i) % 1000000007;\\n\\t\\t}\\n\\t\\treturn (int) res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int concatenatedBinary(int n) {\\n\\t\\tlong res = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tres = (res * (int) Math.pow(2, Integer.toBinaryString(i).length()) + i) % 1000000007;\\n\\t\\t}\\n\\t\\treturn (int) res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940790,
                "title": "python-o-n-pure-bit-manipulation-without-strings-explanation",
                "content": "Concatenation in binary is analagous to shifting left the overall result by the amount of bits necessary to store the next number to concatenate and then summing the value. For example:\\n```\\nresult= 1 = 0b1\\nnext_number = 2 = 0b10\\n\\nresult << 2 => result = 0b100\\nresult = result + next_number = 0b100 + 0b10 = 0b110\\n```\\n\\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = 0\\n        MOD = (10**9 + 7)\\n        L = 0\\n        for num in range(1, n + 1):\\n            # Reached a new length. e.g. 1, 10, 100, 1000, etc...\\n            # We could also compute the length for every number as math.floor(math.log2(num) + 1)\\n            # As per https://en.wikipedia.org/wiki/Bit-length\\n            if (num & (num - 1)) == 0:\\n                L += 1\\n            result = ((result << L) + num) % MOD\\n        return result\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nresult= 1 = 0b1\\nnext_number = 2 = 0b10\\n\\nresult << 2 => result = 0b100\\nresult = result + next_number = 0b100 + 0b10 = 0b110\\n```\n```python\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = 0\\n        MOD = (10**9 + 7)\\n        L = 0\\n        for num in range(1, n + 1):\\n            # Reached a new length. e.g. 1, 10, 100, 1000, etc...\\n            # We could also compute the length for every number as math.floor(math.log2(num) + 1)\\n            # As per https://en.wikipedia.org/wiki/Bit-length\\n            if (num & (num - 1)) == 0:\\n                L += 1\\n            result = ((result << L) + num) % MOD\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212044,
                "title": "c-faster-than-99-37",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint concatenatedBinary(int n) {\\n\\t\\tint64_t ans = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tint bits = 32 - __builtin_clz(i);\\n\\t\\t\\tans = (ans << bits | i) % 1\\'000\\'000\\'007;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint concatenatedBinary(int n) {\\n\\t\\tint64_t ans = 0;\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tint bits = 32 - __builtin_clz(i);\\n\\t\\t\\tans = (ans << bits | i) % 1\\'000\\'000\\'007;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037956,
                "title": "c-easy-and-simple-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037953,
                "title": "c-o-n-fast-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int concatenatedBinary(int n) {\\n        long long int result=1;\\n        int total_bits=0;\\n        for(int i=2;i<=n;i++)\\n        {\\n            total_bits =  (int)log2(i)+1;\\n            result= (result<< total_bits) +i;\\n            if(result>INT_MAX)\\n                result= result%1000000007;\\n            \\n        }\\n        return result%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037831,
                "title": "cpp-recursion-easy-to-understand-with-explanation",
                "content": "We will be using recursion to solve this question. Assume that we have an answer till `n-1` returned by the recursive function. We store this in the `temp` variable. \\n\\nNow, from this `temp`, we need to calculate the final answer for the given `n`.\\n\\n* Shift the answer returned for `n-1` (stored in `temp`) by the number of bits to represent `n`.\\n* Add `n` to that.\\n* Return (with mod `1000000007`)\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    unsigned int helper(unsigned int n) \\n    { \\n       unsigned int count = 0; \\n       while (n) \\n       { \\n            count++; \\n            n >>= 1; \\n        } \\n        return count; \\n    } \\n    \\n    int concatenatedBinary(int n) {\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        long temp = concatenatedBinary(n-1);\\n        \\n        return ((temp<<helper(n)) + n)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    unsigned int helper(unsigned int n) \\n    { \\n       unsigned int count = 0; \\n       while (n) \\n       { \\n            count++; \\n            n >>= 1; \\n        } \\n        return count; \\n    } \\n    \\n    int concatenatedBinary(int n) {\\n        if (n == 1){\\n            return 1;\\n        }\\n        \\n        long temp = concatenatedBinary(n-1);\\n        \\n        return ((temp<<helper(n)) + n)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037641,
                "title": "python-simple-solution-casting-of-types-using-built-ins",
                "content": "Approach: Convert int to binary (string to join) and then back to int.\\n\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        binaryString = \"\" #our result in form of a string\\n        for i in range(1,n+1):\\n            #cast integer i into binary, and then to string, and remove the \"0b\" component in the front\\n            binaryString += str(bin(i))[2:]\\n        #cast from binary to integer\\n        decimal = int(binaryString, 2)\\n\\n        return decimal % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        binaryString = \"\" #our result in form of a string\\n        for i in range(1,n+1):\\n            #cast integer i into binary, and then to string, and remove the \"0b\" component in the front\\n            binaryString += str(bin(i))[2:]\\n        #cast from binary to integer\\n        decimal = int(binaryString, 2)\\n\\n        return decimal % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037587,
                "title": "python-straightforward",
                "content": "This is straightforward but non-optimal solution. Luckily it can pass when I did for the daily chanllenge. \\nAfter reading the LC solution, I realilze this might be one advantange of Python, and the Math solution might be what the problem wants to test ...\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \\'\\'\\n        \\n        for i in range(1, n+1):\\n            res += bin(i)[2:]\\n        \\n        \\n        return int(res,2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \\'\\'\\n        \\n        for i in range(1, n+1):\\n            res += bin(i)[2:]\\n        \\n        \\n        return int(res,2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037513,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n        int mod = 1000000007;\\n        int num = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            String binaryRep = Integer.toBinaryString(i);\\n            \\n            for(char ch:binaryRep.toCharArray())\\n            {\\n                int val = (ch==\\'0\\')?0:1;\\n                \\n                num = ((num*2)%mod + val)%mod;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        \\n        int mod = 1000000007;\\n        int num = 0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            String binaryRep = Integer.toBinaryString(i);\\n            \\n            for(char ch:binaryRep.toCharArray())\\n            {\\n                int val = (ch==\\'0\\')?0:1;\\n                \\n                num = ((num*2)%mod + val)%mod;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037339,
                "title": "python-using-bin-and-int-functions",
                "content": "\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = \"\"\\n        for i in range(0, n+1):\\n            stp +=bin(i)[2:]\\n        return int(stp, 2) % (10**9 + 7)\\n```\\n\\nUpdated Code :\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = []\\n        for i in range(0, n+1):\\n            stp.append(bin(i)[2:])\\n        stp = \"\".join(stp)\\n        return int(stp, 2) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = \"\"\\n        for i in range(0, n+1):\\n            stp +=bin(i)[2:]\\n        return int(stp, 2) % (10**9 + 7)\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        stp = []\\n        for i in range(0, n+1):\\n            stp.append(bin(i)[2:])\\n        stp = \"\".join(stp)\\n        return int(stp, 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037306,
                "title": "concatenation-of-consecutive-binary-numbers-python-one-liner",
                "content": "You can use `bin(integer)[2:]` or `format(integer, \\'b\\')` or `f\\'{integer:b}\\'` to get binary string. Then convert it back to `int` from `binary` by `int(string, 2)`.\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([format(x, \\'b\\') for x in range(1, n + 1)]), 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\\'\\'.join([format(x, \\'b\\') for x in range(1, n + 1)]), 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037258,
                "title": "c-easy-to-understand-included-comments-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long  int M = 1000000007;//modulo operator\\n      long long  int d1=0,res;\\n        for(long long int i=1;i<=n;i++){\\n            d1=((d1<<(int(log2(i))+1))%M+i)%M;//shifting the bits to left side \\n           \\n            \\n        }\\n      \\n     \\n        return d1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long  int M = 1000000007;//modulo operator\\n      long long  int d1=0,res;\\n        for(long long int i=1;i<=n;i++){\\n            d1=((d1<<(int(log2(i))+1))%M+i)%M;//shifting the bits to left side \\n           \\n            \\n        }\\n      \\n     \\n        return d1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965373,
                "title": "c-o-nlogn-simple-solution",
                "content": "```\\n    #define mod 1000000007\\nint concatenatedBinary(int n) \\n{\\n\\tlong ret=0,p=1;\\n\\tfor(int i=n;i>=1;--i)\\n\\t{\\n\\t\\tint temp=i;\\n\\t\\twhile(temp)\\n\\t\\t{\\n\\t\\t\\tret+=(temp&1)*p;\\n\\t\\t\\ttemp/=2;\\n\\t\\t\\tp*=2;   \\n\\t\\t\\tp%=mod;\\n\\t\\t\\tret%=mod;\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    #define mod 1000000007\\nint concatenatedBinary(int n) \\n{\\n\\tlong ret=0,p=1;\\n\\tfor(int i=n;i>=1;--i)\\n\\t{\\n\\t\\tint temp=i;\\n\\t\\twhile(temp)\\n\\t\\t{\\n\\t\\t\\tret+=(temp&1)*p;\\n\\t\\t\\ttemp/=2;\\n\\t\\t\\tp*=2;   \\n\\t\\t\\tp%=mod;\\n\\t\\t\\tret%=mod;\\n\\t\\t}\\n\\t}\\n\\treturn ret;\\n}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 962240,
                "title": "simple-recursive-1-line-c-python-solution",
                "content": "The idea is to use a simple formula:\\n**a(n) = a(n-1) * 2^(1 + floor(log2(n))) + n**\\n**C++:** \\n```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int concatenatedBinary(int n) {\\n        return (n == 1) ? 1 : (concatenatedBinary(n - 1) * (long)(pow(2, 1 + (int)log2(n))) + n) % mod;\\n    }\\n};\\n```\\n**PS:** The declaration line of mod can be removed and it can be directly placed in the return statement of the function.\\n\\n**Python:**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return 1 if n == 1 else (self.concatenatedBinary(n - 1) * int(math.pow(2, 1 + int(math.log2(n)))) + n) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int concatenatedBinary(int n) {\\n        return (n == 1) ? 1 : (concatenatedBinary(n - 1) * (long)(pow(2, 1 + (int)log2(n))) + n) % mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return 1 if n == 1 else (self.concatenatedBinary(n - 1) * int(math.pow(2, 1 + int(math.log2(n)))) + n) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962051,
                "title": "python-4-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = \"\"\\n        for i in range(1, n+1):\\n            result = result + bin(i)[2:]\\n        return int(result , 2) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        result = \"\"\\n        for i in range(1, n+1):\\n            result = result + bin(i)[2:]\\n        return int(result , 2) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961968,
                "title": "easy-solution-with-explanation-c",
                "content": "let\\'s take an example \\n**n = 3**\\n\\n**Intially ans = 1;**\\n\\n\\n**for i --> 2**\\n\\tnumber of bits in 2 is 2;\\n\\tshift answer by number of bits i.e. 2 ans add i\\n\\tans = 1 << 2 + 2\\n\\t\\t= 6\\n\\n**for i --> 3**\\n\\tnumber of bits in 3 is 2;\\n\\tshift answer by number of bits i.e. 2 ans add i\\n\\tans = 6 << 2 + 3\\n\\t\\t= 27\\n\\n**so, answer is 27.**\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int bits = (int)log2(i)+1;  // count number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift current ans by number of bits in i and current element to ans.\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 1;\\n        int mod = 1e9 + 7;\\n        for(int i = 2; i <= n; i++) {\\n            int bits = (int)log2(i)+1;  // count number of bits in i\\n            ans = ((ans << bits) % mod + i) % mod; // left shift current ans by number of bits in i and current element to ans.\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961818,
                "title": "c-simple-o-nlogn-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int concatenatedBinary(int n) \\n    {\\n        long long mod=1e9+7;\\n        long long sum=0,mul=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int k=i;\\n            while(k>0)\\n            {\\n                sum=sum+(mul*(k%2))%mod;\\n                k=k/2;\\n                mul=(mul*2)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int concatenatedBinary(int n) \\n    {\\n        long long mod=1e9+7;\\n        long long sum=0,mul=1;\\n        for(int i=n;i>0;i--)\\n        {\\n            int k=i;\\n            while(k>0)\\n            {\\n                sum=sum+(mul*(k%2))%mod;\\n                k=k/2;\\n                mul=(mul*2)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961456,
                "title": "python-o-n-100-faster-easy-to-understand",
                "content": "```\\n#Try to understand this without using any Brute-force approach. (Its Competitive Programming, Learn as much as you can) :-)\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        l,ans =0,0\\n        for i in range(1,n+1):    \\n            if i & (i - 1) == 0:\\n                l+=1\\n            ans=((ans <<l)|i)%(10**9+7)\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#Try to understand this without using any Brute-force approach. (Its Competitive Programming, Learn as much as you can) :-)\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        l,ans =0,0\\n        for i in range(1,n+1):    \\n            if i & (i - 1) == 0:\\n                l+=1\\n            ans=((ans <<l)|i)%(10**9+7)\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961455,
                "title": "python-using-bin-and-int-function",
                "content": "**Easy to understand and using bin() and int() functions**\\n*Simple python3 solution*\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        b, m = [], (10 ** 9) + 7\\n        for i in range(1, n + 1):\\n            s = bin(i)\\n            b.append(s[2:])\\n        s = \\'\\'.join(b)\\n        return int(s, 2) % m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        b, m = [], (10 ** 9) + 7\\n        for i in range(1, n + 1):\\n            s = bin(i)\\n            b.append(s[2:])\\n        s = \\'\\'.join(b)\\n        return int(s, 2) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961424,
                "title": "java-clean-o-n-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int concatenatedBinary(int n) {\\n\\t\\t\\tlong size = 0, result = 0;\\n\\n\\t\\t\\tint ma = (int)1e9+7;\\n\\n\\t\\t\\tfor(int i = 1;i<=n;i++) {\\n\\t\\t\\t\\tif((i&(i-1)) == 0) size++;\\n\\n\\t\\t\\t\\tresult = ((result << size) | i)%ma;\\n\\t\\t\\t}\\n\\t\\t\\treturn (int)result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int concatenatedBinary(int n) {\\n\\t\\t\\tlong size = 0, result = 0;\\n\\n\\t\\t\\tint ma = (int)1e9+7;\\n\\n\\t\\t\\tfor(int i = 1;i<=n;i++) {\\n\\t\\t\\t\\tif((i&(i-1)) == 0) size++;\\n\\n\\t\\t\\t\\tresult = ((result << size) | i)%ma;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 961397,
                "title": "brute-force-works",
                "content": "```\\ndef d(n):  \\n    return bin(n).replace(\"0b\", \"\") \\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        a=\"\"\\n        for i in range(1,n+1):\\n            a+=d(i)\\n        return int(a,2)%(pow(10,9)+7)\\n```\\n\\nNo idea whats the point of this question?",
                "solutionTags": [],
                "code": "```\\ndef d(n):  \\n    return bin(n).replace(\"0b\", \"\") \\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        a=\"\"\\n        for i in range(1,n+1):\\n            a+=d(i)\\n        return int(a,2)%(pow(10,9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961376,
                "title": "javascript-solution",
                "content": "\\tvar concatenatedBinary = function(n) {\\n\\t\\tconst mod = 1000000007;\\n\\t\\tlet len = 1, num = 0;\\n\\n\\t\\tfor (let i = 1; i <= n; i++) {\\n\\t\\t\\tfor (let j = 0; j < len; j++) {\\n\\t\\t\\t\\t num = (num << 1) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\tnum = (num + i) % mod;\\n\\n\\t\\t\\tif (((i+1) & i) === 0) {\\n\\t\\t\\t\\tlen++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn num;\\n\\t};\\n\\n\\t/*\\n\\t  1  10  11  100 101 110 111 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111\\n\\n\\t  1  6   27  220 \\n\\t*/",
                "solutionTags": [],
                "code": "\\tvar concatenatedBinary = function(n) {\\n\\t\\tconst mod = 1000000007;\\n\\t\\tlet len = 1, num = 0;\\n\\n\\t\\tfor (let i = 1; i <= n; i++) {\\n\\t\\t\\tfor (let j = 0; j < len; j++) {\\n\\t\\t\\t\\t num = (num << 1) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\tnum = (num + i) % mod;\\n\\n\\t\\t\\tif (((i+1) & i) === 0) {\\n\\t\\t\\t\\tlen++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn num;\\n\\t};\\n\\n\\t/*\\n\\t  1  10  11  100 101 110 111 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111\\n\\n\\t  1  6   27  220 \\n\\t*/",
                "codeTag": "Unknown"
            },
            {
                "id": 961371,
                "title": "python3-1-line",
                "content": "**Algo**\\nScan from `1` to `n` and concatenate their binary representation together. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(i)[2:] for i in range(1, n+1)), 2) % 1_000_000_007\\n```\\n\\nEdited on 12/08/2020\\nA more reasonable approach is given below. \\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = k = 0\\n        for x in range(1, n+1): \\n            if not x & x-1: k += 1\\n            ans = ((ans << k) + x) % 1_000_000_007\\n        return ans \\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(i)[2:] for i in range(1, n+1)), 2) % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans = k = 0\\n        for x in range(1, n+1): \\n            if not x & x-1: k += 1\\n            ans = ((ans << k) + x) % 1_000_000_007\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871440,
                "title": "easy-java-solution-using-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied (Bit manupulation)\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%mod)+i)%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied (Bit manupulation)\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        \\n        long ans =0;\\n        for(int i=1; i<=n; i++){\\n            ans = (((ans<<(1+(int)(Math.log(i) / Math.log(2))))%mod)+i)%mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795168,
                "title": "c-clear-and-smart-brute-force-solution",
                "content": "# Intuition\\nThis a brute force solution but with good optimization.\\n\\n# Approach\\nSo solve this problem for n = 3. if n = 3 then our concatenated string s = 11011. if s is a string then the result will be for each i res += s[i] * 2 ^ (n - i - 1). So my code is the same logic but I started counting from the end \\'cause when I count from the end I don\\'t need calculate 2 power of i I just multiply current pow to 2 and MOD it.\\n\\n# Complexity\\n- Time complexity:\\nO(20 * n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n\\n    const int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n) {\\n        int res = 0, cur = 1;\\n        \\n        for (int i = n; i > 0; i--) {\\n            int x = i;\\n            while (x > 0) {\\n                if (x & 1) {\\n                    res = (res + cur) % mod;\\n                }\\n                cur = (cur * 2) % mod;\\n                x /= 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using i64 = long long;\\n\\n    const int mod = 1e9 + 7;\\n\\n    int concatenatedBinary(int n) {\\n        int res = 0, cur = 1;\\n        \\n        for (int i = n; i > 0; i--) {\\n            int x = i;\\n            while (x > 0) {\\n                if (x & 1) {\\n                    res = (res + cur) % mod;\\n                }\\n                cur = (cur * 2) % mod;\\n                x /= 2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325772,
                "title": "simplest-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for x in range(1, n+1):\\n            res += bin(x)[2:]\\n        return int(res, 2) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for x in range(1, n+1):\\n            res += bin(x)[2:]\\n        return int(res, 2) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658623,
                "title": "python-solution-bitwise-left-shift-o-n-explaination",
                "content": "```\\n# Every time the earlier bits gonna shifted towards left side \\n# & left shift = multiply by 2\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        num = 1\\n        for i in range(2, n+1):\\n            num = ((num << i.bit_length()) + i) % (10**9 + 7)\\n        return num\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Every time the earlier bits gonna shifted towards left side \\n# & left shift = multiply by 2\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        num = 1\\n        for i in range(2, n+1):\\n            num = ((num << i.bit_length()) + i) % (10**9 + 7)\\n        return num\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638924,
                "title": "c-o-n",
                "content": "Here We Use the Logic:\\nSuppose we have n=3\\nSo,  we can express it as Sum of 1* 2^4 + 2* 2^2 + 3* 2^0 =27\\nThe Powers of 2 as we go left in the Sum is just the addition of log base 2 of later numbers added with 1\\nAfter that it\\'s just normal modulo arithmetic\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) \\n    {\\n        long long int ans=0;\\n        int M=pow(10,9)+7;\\n        long long int raise=1;\\n        int LOG;\\n        while(n>0)\\n        {\\n            ans=((ans%M)+((n%M)*(raise))%M)%M;\\n            LOG=log(n)/log(2);\\n            LOG++;\\n            LOG=pow(2,LOG);\\n            raise=((raise%M)*(LOG%M))%M;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) \\n    {\\n        long long int ans=0;\\n        int M=pow(10,9)+7;\\n        long long int raise=1;\\n        int LOG;\\n        while(n>0)\\n        {\\n            ans=((ans%M)+((n%M)*(raise))%M)%M;\\n            LOG=log(n)/log(2);\\n            LOG++;\\n            LOG=pow(2,LOG);\\n            raise=((raise%M)*(LOG%M))%M;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618852,
                "title": "easy-optimized-short-c-solution",
                "content": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        int dig=1;\\n        long long res=1;\\n        for(int i=2; i<=n; i++)\\n        {\\n            if(i>=pow(2, dig)) dig++;\\n            res=res<<dig;\\n            res+=i;\\n            res=res%1000000007;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        \\n        int dig=1;\\n        long long res=1;\\n        for(int i=2; i<=n; i++)\\n        {\\n            if(i>=pow(2, dig)) dig++;\\n            res=res<<dig;\\n            res+=i;\\n            res=res%1000000007;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2616510,
                "title": "concatenation-of-consecutive-binary-numbers",
                "content": "class Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans,lft=0,0\\n**        # modulo = 1000000007\\n**        #iterate through n\\n        for i in range(1,n+1):\\n            if i & (i-1) == 0:\\n                lft += 1\\n                #here we use left shift operator to get our result\\n            ans = ((ans << lft)| i) % (10 ** 9 + 7)\\n        return ans\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        ans,lft=0,0\\n**        # modulo = 1000000007\\n**        #iterate through n\\n        for i in range(1,n+1):\\n            if i & (i-1) == 0:\\n                lft += 1\\n                #here we use left shift operator to get our result\\n            ans = ((ans << lft)| i) % (10 ** 9 + 7)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2615468,
                "title": "detailed-commented-solution-with-steps-0-n-time-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    step 1: initilize ans = 1;\\n    step 2: make a function to count the leftmostsetbit in a number coz this will tell us to shift the number to the left as new numbers are comming to add\\n    step 3: now add the number in the shifted value\\n    12 will be like\\n    1 -> \"1\"\\n    2 ->\" 10 \" so ans = (1<<2) + 2\\n    3-> \"11\" so ans =  (ans <<2) + 3\\n    and so on\\n    \\n    \\n    */\\n    const long long int mod = 1e9+7;\\n    int leftmostSetBit(int n){\\n        int pos = 0;\\n        while(n>0){\\n            n = n>>1; // do the right shift untill the number is zero\\n            pos++;\\n        }\\n        return pos;\\n    }\\n    int concatenatedBinary(int n) {\\n        // 12 ka \\n        long long int ans = 1;\\n        int siz = leftmostSetBit(n);\\n        int t = n;\\n        for(int i = 2;i<=n;i++){\\n            int s = leftmostSetBit(i);\\n            ans = ((ans<<s)+i)%mod;// leftShift of Negative values\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    step 1: initilize ans = 1;\\n    step 2: make a function to count the leftmostsetbit in a number coz this will tell us to shift the number to the left as new numbers are comming to add\\n    step 3: now add the number in the shifted value\\n    12 will be like\\n    1 -> \"1\"\\n    2 ->\" 10 \" so ans = (1<<2) + 2\\n    3-> \"11\" so ans =  (ans <<2) + 3\\n    and so on\\n    \\n    \\n    */\\n    const long long int mod = 1e9+7;\\n    int leftmostSetBit(int n){\\n        int pos = 0;\\n        while(n>0){\\n            n = n>>1; // do the right shift untill the number is zero\\n            pos++;\\n        }\\n        return pos;\\n    }\\n    int concatenatedBinary(int n) {\\n        // 12 ka \\n        long long int ans = 1;\\n        int siz = leftmostSetBit(n);\\n        int t = n;\\n        for(int i = 2;i<=n;i++){\\n            int s = leftmostSetBit(i);\\n            ans = ((ans<<s)+i)%mod;// leftShift of Negative values\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615104,
                "title": "python-bitwise-solution-o-1-space-complexity-o-n-time-complexity",
                "content": "```\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        m=\"\"\\n        for i in range(1, (n+1)):\\n            a = bin(i)\\n            m += a[2:]\\n        m = int(m,2)\\n        \\n        if m >=pow(10,9) +7:\\n            m = m % (pow(10,9) +7)\\n            \\n        return m\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        m=\"\"\\n        for i in range(1, (n+1)):\\n            a = bin(i)\\n            m += a[2:]\\n        m = int(m,2)\\n        \\n        if m >=pow(10,9) +7:\\n            m = m % (pow(10,9) +7)\\n            \\n        return m\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2615049,
                "title": "c-diagram-related-problems-python-solutions",
                "content": "![image](https://assets.leetcode.com/users/images/a51840d3-03ae-48dc-91b6-3ae2ff1159c3_1663954899.9468222.png)\\n![image](https://assets.leetcode.com/users/images/6414f0a5-9d9d-45bc-b455-a3a29782b012_1663954919.334429.png)\\n```\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**EDIT 1**\\n**Optimization** in `numberOfBits` function\\n```\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\\n**EDIT 2**\\nAnother way of ***calculating length of binary number*** suggested by @CoolBud\\n```\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\\n**EDIT 3**\\nAnother way of **calculating length of binary number** suggested by @Sopindm\\n```\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\\n**Binary Representation Related Problems**\\n1. Add Binary\\n2. Add Two Numbers\\n3. Counting Bits\\n4. Binary Watch\\n5. Reverse Bits\\n6. Binary Number with Alternating Bits\\n7. Hamming Distance\\n8. Prime Number of Set Bits in Binary Representation\\n# Python code\\n**Method 1**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        mod=10**9 +7\\n        size=0\\n        res=0\\n        for i in range(1,n+1):\\n            if(i&(i-1)==0):\\n                size+=1\\n            res=((res<<size)%mod +i)%mod\\n        return res \\n```\\n**Method 2**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res=\"\"\\n        for i in range(1,n+1):\\n            res+=bin(i).replace(\\'0b\\',\\'\\')\\n        return int(res,2) %(10**9 +7)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int numberOfBits(int n) {\\n\\t\\t  return log2(n) + 1;\\n    }\\n    \\n    int concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7;\\n        \\n        for (int i = 1; i <= n; ++i) {\\n            int len = numberOfBits(i);\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nint numberOfBits(int n) {\\n   int leadingZeros = __builtin_clz(n);\\n   return 32 - leadingZeros;\\n}\\n```\n```\\nint numberOfBits(int n) {\\n    return log2(n) + 1;\\n}\\n```\n```\\nint concatenatedBinary(int n) {\\n        long ans = 0, MOD = 1e9 + 7, len = 0;\\n        for (int i = 1; i <= n; ++i) {\\n            if(__builtin_popcount(i) == 1) ++len;\\n            ans = ((ans << len) % MOD + i) % MOD;\\n        }\\n        return ans;\\n}\\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        mod=10**9 +7\\n        size=0\\n        res=0\\n        for i in range(1,n+1):\\n            if(i&(i-1)==0):\\n                size+=1\\n            res=((res<<size)%mod +i)%mod\\n        return res \\n```\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res=\"\"\\n        for i in range(1,n+1):\\n            res+=bin(i).replace(\\'0b\\',\\'\\')\\n        return int(res,2) %(10**9 +7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615041,
                "title": "simple-java-solution-4-lines-of-code",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long val=0, i=0;\\n        while(i++<n)\\n            val= ((val<<(1+(int)(Math.log(i)/Math.log(2))))+i)%1000000007;\\n        return (int)val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long val=0, i=0;\\n        while(i++<n)\\n            val= ((val<<(1+(int)(Math.log(i)/Math.log(2))))+i)%1000000007;\\n        return (int)val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615004,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\n    int helper(int i)\\n    {\\n        return log2(i)+1;\\n    }\\npublic:\\n    int concatenatedBinary(int n) {\\n        long  ans=0,mod=1e9+7;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int len=helper(i);\\n            ans=((ans<<len)%mod+i)%mod;\\n            cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper(int i)\\n    {\\n        return log2(i)+1;\\n    }\\npublic:\\n    int concatenatedBinary(int n) {\\n        long  ans=0,mod=1e9+7;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int len=helper(i);\\n            ans=((ans<<len)%mod+i)%mod;\\n            cout<<ans<<\" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2614994,
                "title": "c-javascript-simulation-bitwise",
                "content": "<iframe src=\"https://leetcode.com/playground/i9vaEivy/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "Math",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/i9vaEivy/shared\" frameBorder=\"0\" width=\"100%\" height=\"340\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2614971,
                "title": "c-bit-manipulation-fast-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int length(int n){\\n        return log2(n) + 1; // length of binary representation of a n number\\n        \\n    }\\n    int concatenatedBinary(int n) {\\n        long ans = 0; // even tho return type is int.\\n        int mod = 1e9 + 7;\\n        \\n        for(int i=1;i<=n;i++){\\n            int len = length(i);\\n            ans = ((ans << len) % mod + i) % mod; // left shift the ans and then add the i number init,(concatenate)\\n        }\\n        \\n        \\n        \\n        return ans % mod;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(int n){\\n        return log2(n) + 1; // length of binary representation of a n number\\n        \\n    }\\n    int concatenatedBinary(int n) {\\n        long ans = 0; // even tho return type is int.\\n        int mod = 1e9 + 7;\\n        \\n        for(int i=1;i<=n;i++){\\n            int len = length(i);\\n            ans = ((ans << len) % mod + i) % mod; // left shift the ans and then add the i number init,(concatenate)\\n        }\\n        \\n        \\n        \\n        return ans % mod;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614848,
                "title": "c-recursive-solution",
                "content": "int concatenatedBinary(int n) {\\n        \\n        long long mod = 1000000007;\\n        if(n==1)\\n            return 1;\\n        \\n        long long val  = concatenatedBinary(n-1)*pow(2,ceil(log2(n+1)));\\n        return (val+n)%mod;\\n    }",
                "solutionTags": [],
                "code": "int concatenatedBinary(int n) {\\n        \\n        long long mod = 1000000007;\\n        if(n==1)\\n            return 1;\\n        \\n        long long val  = concatenatedBinary(n-1)*pow(2,ceil(log2(n+1)));\\n        return (val+n)%mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2614701,
                "title": "java-simple-solution-better-than-100-with-explanation-1-general-method-2-binary-operation",
                "content": "```\\n/* approach:- \\n            the approach is pretty simple but all the matter is the way in which we can do it so the it will be very efficient in terms of time complexity\\n            \\n       -> So we need to interate from 1 to given n and concatenate all binary string from 1 to n and return the result\\n       -> The result can be pretty big as n can be 1<n<10^5  which an int cant hold so wee are using long annd make sure to do mod with 10^9+7 to get the value for bigger n values\\n       \\n       -> Now convert the number to binary string and find it length \\n       \\n         general approach                     |             binary operation\\n                                              |\\n   1.String bs=Integer.to binaryString(n);    |    1.if (n&(n-1)) ==0   len++;\\n     int len=bs.length()                      |      ex:- for 4-> (4 & 3) -> (100&011)==0 so len++\\n       \\n      -> Now append the number(binary string) to the previous binary string.\\n      \\n       general approach                       |             binary operation\\n                                              |\\n   1.  result = result+n                      |    1. result=result|num \\n       general string appending               |       or will work same as + operation\\n                                              |\\n                                              |\\n       o(n) better then 50%                   |     o(n) better than 100%        \\n      \\n*/\\n\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1000_000_007;\\n        int len=0;\\n        for(int i=1;i<=n;i++){\\n            //String binarystring=Integer.toBinaryString(i);\\n            if((i&(i-1))==0)\\n                len++;\\n            res=(res<<len|i)%mod;\\n            //res=(res+i)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/* approach:- \\n            the approach is pretty simple but all the matter is the way in which we can do it so the it will be very efficient in terms of time complexity\\n            \\n       -> So we need to interate from 1 to given n and concatenate all binary string from 1 to n and return the result\\n       -> The result can be pretty big as n can be 1<n<10^5  which an int cant hold so wee are using long annd make sure to do mod with 10^9+7 to get the value for bigger n values\\n       \\n       -> Now convert the number to binary string and find it length \\n       \\n         general approach                     |             binary operation\\n                                              |\\n   1.String bs=Integer.to binaryString(n);    |    1.if (n&(n-1)) ==0   len++;\\n     int len=bs.length()                      |      ex:- for 4-> (4 & 3) -> (100&011)==0 so len++\\n       \\n      -> Now append the number(binary string) to the previous binary string.\\n      \\n       general approach                       |             binary operation\\n                                              |\\n   1.  result = result+n                      |    1. result=result|num \\n       general string appending               |       or will work same as + operation\\n                                              |\\n                                              |\\n       o(n) better then 50%                   |     o(n) better than 100%        \\n      \\n*/\\n\\n\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1000_000_007;\\n        int len=0;\\n        for(int i=1;i<=n;i++){\\n            //String binarystring=Integer.toBinaryString(i);\\n            if((i&(i-1))==0)\\n                len++;\\n            res=(res<<len|i)%mod;\\n            //res=(res+i)%mod;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614685,
                "title": "c-easy-beginner-friendly-95-fast-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans = 0, mod = 1e9 + 7;\\n        int sz = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                sz++;\\n            \\n            ans = (ans*(1<<sz) + i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6ca6396a-6878-4d2d-bf38-1c71c91c2721_1663948202.0333488.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int ans = 0, mod = 1e9 + 7;\\n        int sz = 0;\\n        \\n        for(int i = 1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                sz++;\\n            \\n            ans = (ans*(1<<sz) + i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614583,
                "title": "brute-force-python",
                "content": "\\'\\'\\'\\ndef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tres=\\'\\'\\n\\t\\t   for i in range(1,n+1):\\n\\t\\t\\t\\tres=res+bin(i)[2:]\\n\\t\\t\\tres=int(res,2)\\n\\t\\t\\treturn res%1000000007\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\ndef concatenatedBinary(self, n: int) -> int:\\n\\n\\t\\t\\tres=\\'\\'\\n\\t\\t   for i in range(1,n+1):\\n\\t\\t\\t\\tres=res+bin(i)[2:]\\n\\t\\t\\tres=int(res,2)\\n\\t\\t\\treturn res%1000000007\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2614546,
                "title": "c-100-memory-100-runtime-o-n",
                "content": "Memory usage on this seems pretty random, ranges from 25% to 100% on identical submissions. Runtime is consistently 100%.\\n```\\nint concatenatedBinary(int n){\\n    long res = 0; // long so that intermediate results fit in memory\\n    int modnum = pow(10, 9) + 7;\\n    int numbits;\\n\\t\\n    for ( int i=1; i<=n; i++ ){\\n\\t\\t// Get number of bits in binary representation\\n        numbits = 32 - __builtin_clz(i); \\n\\t\\t// right shift result by number of bits, add i, then take modulus\\n        res = ((res<<numbits) + i)%modnum; \\n    }\\n    \\n    return(res);\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e74fd5cc-2f6c-48ea-82fd-03b6832aa943_1663945583.184223.png)\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint concatenatedBinary(int n){\\n    long res = 0; // long so that intermediate results fit in memory\\n    int modnum = pow(10, 9) + 7;\\n    int numbits;\\n\\t\\n    for ( int i=1; i<=n; i++ ){\\n\\t\\t// Get number of bits in binary representation\\n        numbits = 32 - __builtin_clz(i); \\n\\t\\t// right shift result by number of bits, add i, then take modulus\\n        res = ((res<<numbits) + i)%modnum; \\n    }\\n    \\n    return(res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2614492,
                "title": "c-short-solution-using-bit-manipulation",
                "content": "**Simple Loop**\\n\\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tlong m = 2;\\n\\tlong mod = 1000000007;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif (i == m)\\n\\t\\t{\\n\\t\\t\\tm *= 2;\\n\\t\\t}\\n\\t\\tresult = (result * m + i) % mod;\\n\\t}\\n\\treturn (int)result;\\n}\\n```\\n**Bit Manipulation**\\n\\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\n\\tlong result = 0;\\n\\tvar mod = 1000000007;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t{\\n\\t\\tvar binary = Convert.ToString(i, 2);\\n\\t\\tresult = (result << binary.Length) % mod;\\n\\t\\tresult = (result + i) % mod;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\tlong result = 0;\\n\\tlong m = 2;\\n\\tlong mod = 1000000007;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tif (i == m)\\n\\t\\t{\\n\\t\\t\\tm *= 2;\\n\\t\\t}\\n\\t\\tresult = (result * m + i) % mod;\\n\\t}\\n\\treturn (int)result;\\n}\\n```\n```\\npublic int ConcatenatedBinary(int n)\\n{\\n\\n\\tlong result = 0;\\n\\tvar mod = 1000000007;\\n\\tfor (var i = 1; i <= n; i++)\\n\\t{\\n\\t\\tvar binary = Convert.ToString(i, 2);\\n\\t\\tresult = (result << binary.Length) % mod;\\n\\t\\tresult = (result + i) % mod;\\n\\t}\\n\\n\\treturn (int)result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2614351,
                "title": "python-one-line-with-explanation",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\\n\\n**Explanation**\\n \\nFirst we have :\\n```\\nbin(x)[2:] for x in range(1, n + 1)\\n```\\nThis loops through from 1 to n (inclusive) and and converts the number to binary. We then slice the result to remove the \\'0b\\' prefix that\\'s there by default. The total result of the above segment is a python generator (think of it as a list of the each of the values. i.e. [bin(1), bin(2), ...])\\n\\nExpanding, we have :\\n```\\n\"\".join( bin(x)[2:] for x in range(1, n + 1) )\\n```\\nThis gets the above generator and converts it to a string (it concatenates each value in the \\'list\\')\\n\\nExpanding futher, we have :\\n```\\nint( \"\".join(bin(x)[2:] for x in range(1, n + 1)) , 2)\\n```\\nThis just converts the resultant string to a binary number\\n\\nAnd finally :\\n```\\nreturn int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\\nThis returns the result modulo 10 ^ 9 + 7 as required.\\n```\\n\\n\\n\\n```\\nIf you found this solution helpful, please upvote it \\uD83D\\uDE01",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\n```\\nbin(x)[2:] for x in range(1, n + 1)\\n```\n```\\n\"\".join( bin(x)[2:] for x in range(1, n + 1) )\\n```\n```\\nint( \"\".join(bin(x)[2:] for x in range(1, n + 1)) , 2)\\n```\n```\\nreturn int(\"\".join(bin(x)[2:] for x in range(1, n + 1)), 2) % 1000000007\\n```\n```\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614346,
                "title": "c-o-n-simple-code",
                "content": "```\\nint mostSigBit(int n)\\n{\\n \\n    // calculate the  number\\n    // of leading zeroes\\n    int k = __builtin_clz(n);\\n \\n    // position of the most\\n    // significant digit:\\n    return sizeof(int)*8 - k;\\n}\\n\\nlong long MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n)\\n    {\\n        long long ret = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            int iLen = mostSigBit(i);\\n            ret <<= iLen;\\n            ret += i;\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint mostSigBit(int n)\\n{\\n \\n    // calculate the  number\\n    // of leading zeroes\\n    int k = __builtin_clz(n);\\n \\n    // position of the most\\n    // significant digit:\\n    return sizeof(int)*8 - k;\\n}\\n\\nlong long MOD = 1e9+7;\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n)\\n    {\\n        long long ret = 0;\\n        for(int i=1; i<=n; i++)\\n        {\\n            int iLen = mostSigBit(i);\\n            ret <<= iLen;\\n            ret += i;\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614213,
                "title": "complete-explaination-using-overview-binary-diagram",
                "content": "```\\n/*\\n    Observation:\\n    -----------\\n    \\n    Let\\'s see changes for 3(N)\\n        n     result_dec_value      binary_of_current_n     result_binary_string\\n        1        1                     1                           1\\n        2        6                     10                          110\\n        3        27                    11                          11011\\n        \\n    Here in the above sequence of operations we can clearly observe that\\n    appending the binary form of current n to an existing resultent binary\\n    string, will left shift the resultent binary string by the numbers of\\n    total bits in current n.\\n    \\n    For example:\\n    -----------\\n        n -> 1, result_dec_val -> 1, bin(1) -> 1, result_bin -> 1\\n        \\n        n -> 2, result_dec_val -> ?, bin(2) -> 10, result_bin -> 110\\n        \\n        result_dec_val = (prev_result_bin << (total_bits_in_current_n)) + n;\\n        \\n                       = (1 << 2) + 2\\n                       = 4 + 2\\n                       = 6\\n                       \\n        NOTE: 1. (1 << 2) nothing but -> (2 * 2)\\n              2. total_bits_in_current_n -> means bits that are\\n              responsible to represent the value of n.(avoid leading 0 bits)\\n              \\n              \\n        so therefore, we can conclude that\\n        \\n        If we have equivalent decemal value for all binaries [1, (n - 1)],\\n        from that we can evaluate decimal for n by using formula\\n        \\n        decVal(n) = [decVal(n - 1) << (log2(n) + 1)] + n\\n        \\n        here in the above formula : (log2(n) + 1) gives total number bits in n in base 2\\n        decVal(n - 1) : decimal value calculated so far from binaries of [1, n - 1]\\n        \\n        the formula can be placed inside a for loop & n is replaced by loop variable\\n        let say i.\\n\\n*/\\n\\nclass Solution {\\n    \\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    private int log2(int n) {\\n        return (int)(Math.log10(n) / Math.log10(2)) + 1;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        long decVal = 1;\\n        for(int i = 2; i <= n; i += 1) {\\n            decVal = ((decVal << log2(i)) % M + i) % M;\\n        }\\n        \\n        return (int)decVal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    Observation:\\n    -----------\\n    \\n    Let\\'s see changes for 3(N)\\n        n     result_dec_value      binary_of_current_n     result_binary_string\\n        1        1                     1                           1\\n        2        6                     10                          110\\n        3        27                    11                          11011\\n        \\n    Here in the above sequence of operations we can clearly observe that\\n    appending the binary form of current n to an existing resultent binary\\n    string, will left shift the resultent binary string by the numbers of\\n    total bits in current n.\\n    \\n    For example:\\n    -----------\\n        n -> 1, result_dec_val -> 1, bin(1) -> 1, result_bin -> 1\\n        \\n        n -> 2, result_dec_val -> ?, bin(2) -> 10, result_bin -> 110\\n        \\n        result_dec_val = (prev_result_bin << (total_bits_in_current_n)) + n;\\n        \\n                       = (1 << 2) + 2\\n                       = 4 + 2\\n                       = 6\\n                       \\n        NOTE: 1. (1 << 2) nothing but -> (2 * 2)\\n              2. total_bits_in_current_n -> means bits that are\\n              responsible to represent the value of n.(avoid leading 0 bits)\\n              \\n              \\n        so therefore, we can conclude that\\n        \\n        If we have equivalent decemal value for all binaries [1, (n - 1)],\\n        from that we can evaluate decimal for n by using formula\\n        \\n        decVal(n) = [decVal(n - 1) << (log2(n) + 1)] + n\\n        \\n        here in the above formula : (log2(n) + 1) gives total number bits in n in base 2\\n        decVal(n - 1) : decimal value calculated so far from binaries of [1, n - 1]\\n        \\n        the formula can be placed inside a for loop & n is replaced by loop variable\\n        let say i.\\n\\n*/\\n\\nclass Solution {\\n    \\n    private static final int M = 1_000_000_000 + 7;\\n    \\n    private int log2(int n) {\\n        return (int)(Math.log10(n) / Math.log10(2)) + 1;\\n    }\\n    \\n    public int concatenatedBinary(int n) {\\n        long decVal = 1;\\n        for(int i = 2; i <= n; i += 1) {\\n            decVal = ((decVal << log2(i)) % M + i) % M;\\n        }\\n        \\n        return (int)decVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614128,
                "title": "rust-one-liner",
                "content": "```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as u64).fold(0u64, |o, i| {\\n            ((o << 64 - i.leading_zeros()) + i) % 1_000_000_007\\n        }) as i32\\n    }\\n}\\n```\\n\\nA more readable one without `fold`:\\n```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        let mut o = 0;\\n        for i in 1..=n as u64 {\\n            o <<= 64 - i.leading_zeros();\\n            o += i;\\n            o %= 1_000_000_007\\n        }\\n        o as i32\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as u64).fold(0u64, |o, i| {\\n            ((o << 64 - i.leading_zeros()) + i) % 1_000_000_007\\n        }) as i32\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        let mut o = 0;\\n        for i in 1..=n as u64 {\\n            o <<= 64 - i.leading_zeros();\\n            o += i;\\n            o %= 1_000_000_007\\n        }\\n        o as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613932,
                "title": "c-easy-and-explained-solution-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string binary(int n)\\n    {\\n        string t=\"\";\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            {\\n                t+=\\'1\\';\\n            }\\n            else\\n            {\\n                t+=\\'0\\';\\n            }\\n            n/=2;\\n        }\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    int concatenatedBinary(int n) \\n    {\\n        string s=\"\";\\n        const int N=1e9+7;\\n        long long ans=0;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s+=binary(i); //Function  to calculate the binary of every number upto n\\n        }\\n        int m=s.length(),p=1;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            if(s[i]!=0)  // Checking if char is 0 or not, it prevents from TLE because we only perform operarions when s[i]=1\\n            {\\n                ans+=p*(s[i]-\\'0\\');\\n                ans%=N;  //Modulo 1e9+7;\\n            }\\n            p*=2;\\n            p%=N; //Modulo 1e9+7            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string binary(int n)\\n    {\\n        string t=\"\";\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            {\\n                t+=\\'1\\';\\n            }\\n            else\\n            {\\n                t+=\\'0\\';\\n            }\\n            n/=2;\\n        }\\n        reverse(t.begin(),t.end());\\n        return t;\\n    }\\n    int concatenatedBinary(int n) \\n    {\\n        string s=\"\";\\n        const int N=1e9+7;\\n        long long ans=0;\\n        int j=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            s+=binary(i); //Function  to calculate the binary of every number upto n\\n        }\\n        int m=s.length(),p=1;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            if(s[i]!=0)  // Checking if char is 0 or not, it prevents from TLE because we only perform operarions when s[i]=1\\n            {\\n                ans+=p*(s[i]-\\'0\\');\\n                ans%=N;  //Modulo 1e9+7;\\n            }\\n            p*=2;\\n            p%=N; //Modulo 1e9+7            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613926,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tmod = 1000000007\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in range(1,n+1):    \\n\\t\\t\\t\\tres = res << num.bit_length() # left shifting length of the binary value of num\\n\\t\\t\\t\\tres = (res | num) % mod # adding the current number\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tmod = 1000000007\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num in range(1,n+1):    \\n\\t\\t\\t\\tres = res << num.bit_length() # left shifting length of the binary value of num\\n\\t\\t\\t\\tres = (res | num) % mod # adding the current number\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2613841,
                "title": "c-fastest-and-easiest-basic-shift-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int val=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            val=((val << (1 + int(log2(i)))) % 1000000007 +i) % 1000000007;\\n            i ++ ;\\n        }\\n        return val;\\n    }\\n};\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long int val=0;\\n        int i=1;\\n        while(i<=n)\\n        {\\n            val=((val << (1 + int(log2(i)))) % 1000000007 +i) % 1000000007;\\n            i ++ ;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613775,
                "title": "java-simple-2-line-solution-linear-o-n",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long value = 0;\\n        // iterate for all numbers till n\\n        for(int i=1;i<=n;i++)\\n            value = ((value << countBits(i)) + i)%mod;        \\n        return (int)value;\\n    }\\n    // util to get total bit count\\n    private int countBits(int n)\\n    {\\n        int count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n >>= 1;\\n        }\\n          \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long value = 0;\\n        // iterate for all numbers till n\\n        for(int i=1;i<=n;i++)\\n            value = ((value << countBits(i)) + i)%mod;        \\n        return (int)value;\\n    }\\n    // util to get total bit count\\n    private int countBits(int n)\\n    {\\n        int count = 0;\\n        while (n != 0)\\n        {\\n            count++;\\n            n >>= 1;\\n        }\\n          \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613659,
                "title": "c-iterative-easy-to-understand",
                "content": "Let f(n) = concatenation of binary numbers from 1 to n\\nSo we need to find f(n)\\n\\nWe append the numbers from 1 to n one by one in a loop.\\nTo find f(i),\\n\\twe left shift the f(i-1) by number of bits in i, and add i to it\\n\\tthen we take the mod\\n\\n**eg.** n = 4\\nf(1) = 1\\n\\tf(2) = 1<<(number of bits in 2) + 2 = 1<<2 + 2 = 100 + 10 = 110\\n\\tf(3) = 11<<(number of bits in 3) + 3 = 11<<2 + 3 = 11000 + 11 = 11011\\n\\tf(4) = 1011<<(number of bits in 4) + 4 = 11011<< 3 + 4 = 11011000 + 100 = 11011100\\n(also taking mod 1e9+7 simultaneously in each step to avoid overflow)\\n\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 0;\\n        for(long long i=1; i<=n; i++) {\\n            ans = ((ans << ((int)floor(log2(i)) + 1)) + i)%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long long ans = 0;\\n        for(long long i=1; i<=n; i++) {\\n            ans = ((ans << ((int)floor(log2(i)) + 1)) + i)%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613633,
                "title": "blazingly-fast-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        if(n == 1) return 1;\\n        long long prev = 1;\\n        long long bits = 1;\\n        for(int i = 2; i <= n; i ++) {\\n            if((i & (i - 1)) == 0) {\\n                bits ++;\\n            }\\n            prev <<= bits;\\n            prev = prev + i;\\n            prev %= ((int)1e9 + 7);\\n        } \\n        return (int) prev;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        if(n == 1) return 1;\\n        long long prev = 1;\\n        long long bits = 1;\\n        for(int i = 2; i <= n; i ++) {\\n            if((i & (i - 1)) == 0) {\\n                bits ++;\\n            }\\n            prev <<= bits;\\n            prev = prev + i;\\n            prev %= ((int)1e9 + 7);\\n        } \\n        return (int) prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613478,
                "title": "c-o-n-easy-solution",
                "content": "In this problem we are traversing from 1 to n and then \\ncalculating binary length of every ith value and then left shifting with previous value and adding current decimal value.\\n\\n**For calculating length of binary digit-**\\nwe are using [ 1 + log2(i) ] = digit length\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int i;\\n        long long int val = 0;\\n        for(i=1;i<=n;i++){\\n            val = ((val << (1 + int(log2(i)))) % 1000000007 + i) % 1000000007;\\n        }\\n        return val;\\n    }\\n};\\n```\\n\\nIn last we are doing mod 10^9 + 7.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int i;\\n        long long int val = 0;\\n        for(i=1;i<=n;i++){\\n            val = ((val << (1 + int(log2(i)))) % 1000000007 + i) % 1000000007;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613464,
                "title": "python-bin-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tm=10**9+7\\n\\t\\t\\ttemp=\"\"\\n\\t\\t\\tfor _ in range(1,n+1):\\n\\t\\t\\t\\ttemp+=bin(_)[2:]\\n\\t\\t\\treturn int(temp,2)%m",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef concatenatedBinary(self, n: int) -> int:\\n\\t\\t\\tm=10**9+7\\n\\t\\t\\ttemp=\"\"\\n\\t\\t\\tfor _ in range(1,n+1):\\n\\t\\t\\t\\ttemp+=bin(_)[2:]\\n\\t\\t\\treturn int(temp,2)%m",
                "codeTag": "Java"
            },
            {
                "id": 2613430,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), base=2) % 1000000007",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        return int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), base=2) % 1000000007",
                "codeTag": "Java"
            },
            {
                "id": 2613297,
                "title": "simplest-fastest-quickest-java-solution-via-bit-manipulation-all-himself-by-lord-noddy",
                "content": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1_000_000_007;\\n        \\n        int size=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if((i&(i-1))==0) size++;\\n            \\n            res=(res<<size|i) % mod;\\n        }\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        long res=0;\\n        int mod=1_000_000_007;\\n        \\n        int size=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if((i&(i-1))==0) size++;\\n            \\n            res=(res<<size|i) % mod;\\n        }\\n        return (int) res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613296,
                "title": "rust-modular-math",
                "content": "If you like my solutions, you should check out [my github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n\\n### Modular arithmetic\\n\\nThe concatenation of `A` and `B`, i.e.`AB`, can be expressed\\nas: `A * 2.pow(BITS-B.leading_zeroes()) + B`. In other words we\\nshift `A` some positions to the left in order to fit `B` to the\\nright of `A`: `(A << BITS-B.leading_zeroes()) + B`\\n\\nNo we can use modular arithmetic to calculate the result:\\n\\n* `(a*b) mod c == ((a mod c) * (b mod c)) mod c`\\n* `(a+b) mod c == ((a mod c) + (b mod c)) mod c`\\n\\n#### Sticking strictly to the formula:\\n\\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        // (a*b) mod c == ((a mod c) * (b mod c)) mod c\\n\\n        // We\\'ve already %MOD-ed the answer at the end of the loop,\\n        // thus we can skip %MOD-ing it here. It\\'s left just to make\\n        // it more similar to the formula above\\n        let a = answer % MOD;\\n\\n        //  Calculate how many places we have to move\\n        // \"answer\" to the left in order to be able to\\n        // concatenate it with X\\n        let b = (1 << 64 - x.leading_zeros()) % MOD;\\n\\n        // Move \"answer\" to the left and take to MOD\\n        let m = (a * b) % MOD;\\n\\n        // (a+b) mod c == ((a mod c) + (b mod c)) mod c\\n        //\\n        // We know that X is in the range [0:10^5], thus\\n        // it\\'s always smaller than MOD, so we don\\'t\\n        // need to do (X % MOD). And M was already %-ed above\\n        //\\n        // Concatenate X and take the MOD\\n        answer = (x + m) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```\\n\\n#### Optimizing the multiplications\\n\\n* Because N can be at most `10^5` it\\'s will always be smaller than the\\n  MOD (`10^9+7`), thus we don\\'t need to %MOD the `n` values\\n* The largest bitshift value of `N` 10^5`( i.e. `2^17`) we calculate is smaller\\n  than the MOD, thus we can avoid doing the %MOD here as well\\n* Multiplying by a power of two is equal to a bit-shift to the left\\n\\nGiven those three points we can optimize:\\n```text\\nlet a = answer % MOD;\\nlet b = (1 << 64 - x.leading_zeros()) % MOD;\\nlet m = (a * b) % MOD;\\n```\\n\\nto just \\n```text\\nlet y = (answer << 64 - x.leading_zeros()) % MOD;\\n```\\n\\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        let y = (answer << 64 - x.leading_zeros()) % MOD;\\n        answer = (x + y) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        // (a*b) mod c == ((a mod c) * (b mod c)) mod c\\n\\n        // We\\'ve already %MOD-ed the answer at the end of the loop,\\n        // thus we can skip %MOD-ing it here. It\\'s left just to make\\n        // it more similar to the formula above\\n        let a = answer % MOD;\\n\\n        //  Calculate how many places we have to move\\n        // \"answer\" to the left in order to be able to\\n        // concatenate it with X\\n        let b = (1 << 64 - x.leading_zeros()) % MOD;\\n\\n        // Move \"answer\" to the left and take to MOD\\n        let m = (a * b) % MOD;\\n\\n        // (a+b) mod c == ((a mod c) + (b mod c)) mod c\\n        //\\n        // We know that X is in the range [0:10^5], thus\\n        // it\\'s always smaller than MOD, so we don\\'t\\n        // need to do (X % MOD). And M was already %-ed above\\n        //\\n        // Concatenate X and take the MOD\\n        answer = (x + m) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```\n```text\\nlet a = answer % MOD;\\nlet b = (1 << 64 - x.leading_zeros()) % MOD;\\nlet m = (a * b) % MOD;\\n```\n```text\\nlet y = (answer << 64 - x.leading_zeros()) % MOD;\\n```\n```rust\\nconst MOD: u64 = 10u64.pow(9) + 7;\\n\\npub fn concatenated_binary(n: i32) -> i32 {\\n    assert!(n >= 0 && n <= 10i32.pow(5));\\n    let n = n as u64;\\n\\n    let mut answer = 0u64;\\n\\n    for x in 1..=n {\\n        let y = (answer << 64 - x.leading_zeros()) % MOD;\\n        answer = (x + y) % MOD;\\n    }\\n\\n    answer as i32\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613252,
                "title": "java-solution-bit-manipulation-and-string",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n        int len = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            // checks if i is power of 2 \\n            // (length of binary number increases by +1 with every power of 2)\\n            if ((i & (i - 1)) == 0) len++;      \\n            bin = ((bin << len) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n#### OR\\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            String binaryStr = Integer.toBinaryString(i);\\n            bin = ((bin << binaryStr.length()) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n * logn) - Integer.toBinaryString() takes logn time\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n        int len = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            // checks if i is power of 2 \\n            // (length of binary number increases by +1 with every power of 2)\\n            if ((i & (i - 1)) == 0) len++;      \\n            bin = ((bin << len) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int concatenatedBinary(int n) {\\n        int mod = 1000000007;\\n        long bin = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            String binaryStr = Integer.toBinaryString(i);\\n            bin = ((bin << binaryStr.length()) | i) % mod;\\n        }\\n\\n        return (int) bin;\\n    }\\n}\\n\\n// TC: O(n * logn) - Integer.toBinaryString() takes logn time\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613227,
                "title": "rust-one-liner-with-comments",
                "content": "The algorithm - maintain a running \"sum\" that we keep modulo the given prime. For each number, shift the sum the number of steps necessary to accomodate all the set bits in the number, and OR in the bits into the sum.\\n\\nImplementation notes - just a few minor tweaks compared to other published solutions for this pretty easy problem:\\n* I used `reduce` here instead of `fold`, so that we initialize the running sum with 1, instead of initializing the `fold` state with 0 and then OR:ing in the 1. On the other hand, we have to make an `.unwrap()`, which we wouldn\\'t have to do with a `fold`.\\n* `SumType` and `SumType::BITS` to avoid magic values.\\n\\n```\\ntype SumType = i64;\\nconst MOD: SumType = 1000000007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as SumType).reduce(|acc, num| ((acc << (SumType::BITS - num.leading_zeros())) | num) % MOD).unwrap() as _\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype SumType = i64;\\nconst MOD: SumType = 1000000007;\\n\\nimpl Solution {\\n    pub fn concatenated_binary(n: i32) -> i32 {\\n        (1..=n as SumType).reduce(|acc, num| ((acc << (SumType::BITS - num.leading_zeros())) | num) % MOD).unwrap() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613203,
                "title": "3-lines-of-code-place-value-and-facevalue-manipulation-c-explaination-faster-100",
                "content": "Trick is to add left shift of previous number formed till now by the size of binary string formed by the present number(Place Value) and then adding the present number.\\n\\nDoing left shift by size \\'sz\\' is equivalent to multiplying by \\'sz\\'th power of 2.\\nSize of strings can be updated whenever we hit powers of 2.\\ndo take mod(1e9+7) whenever possible inorder to avoid overflows.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int ans=0,sz=0;\\n        for(int i=1;i<=n;i++){\\n            if(i==(1<<sz))sz++;// increments whenever we hit next power of 2\\n            ans=((ans*1LL*(1<<sz))%md+i)%md; // left shift previous number formed then add i, then take mod\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHOPE THIS HELPS :)",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int ans=0,sz=0;\\n        for(int i=1;i<=n;i++){\\n            if(i==(1<<sz))sz++;// increments whenever we hit next power of 2\\n            ans=((ans*1LL*(1<<sz))%md+i)%md; // left shift previous number formed then add i, then take mod\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613189,
                "title": "one-line-python-solution",
                "content": "```\\ndef concatenatedBinary(self, n: int) -> int:\\n\\treturn int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), 2) % (10**9 + 7)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef concatenatedBinary(self, n: int) -> int:\\n\\treturn int(\"\".join([bin(i)[2:] for i in range(1, n+1)]), 2) % (10**9 + 7)",
                "codeTag": "Python3"
            },
            {
                "id": 2613134,
                "title": "c-bit-manipulation-explanation-o-n-logn",
                "content": "```\\n\\nHere I took every bit and compute how much it will contribute to the answer . \\nn = 3 , we have to take 1 (1) , 2 (10), 3(11) . So the anwer will (decimal value of 11011) % 1e9+7 . \\nif we will travarse from back we can get the answer . But the problem arrives when ,if we are on Xth bit and (1<<X) is not fit in our datatype . \\nSo for that problem we will take  (1<<(X-1)) % 1e9+7 and multiply it with 2. \\nThat\\'s how we\\'ll get all value of (1<<X) without overflow and add it to the answer according to the condition ( bit is set or not) . \\n\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int mul(int a , int b){\\n        return 1ll*a*b%mod;\\n    }\\n    int sum(int a ,int b){\\n        a += b;\\n        a %= mod;\\n        return a;\\n    }\\n    int concatenatedBinary(int n) {\\n        int val = 0 , idx = 0 , prev = 1;\\n        for(int i = n ; i >=1 ;i--){\\n            int cur = i;\\n            while(cur > 0 ){\\n                int rem = cur%2;\\n                if(idx == 0){\\n                    val = sum(val,rem)%mod;;\\n                    prev = 1;\\n                }else{\\n                    int multi = mul(prev,2)%mod;\\n                    if(rem)\\n                        val = sum(multi,val)%mod;\\n                    prev = multi;\\n                }\\n                cur >>= 1;\\n                idx++;\\n            }\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int mul(int a , int b){\\n        return 1ll*a*b%mod;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2613128,
                "title": "brute-force-works-self-explanatory",
                "content": "Two brute force ways since the constraint is small\\nFYI, the __builtin_clz is to count the leading zeros of the integer. \\nThe later one may be a bit faster.\\n```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1) ++ len;\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 32 - __builtin_clz(i);\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 0;\\n            for (int j = i; j; j >>= 1) ++ len;\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const int mod = 1e9 + 7;\\n        long long ans = 0;\\n        for (int i = 1; i <= n; ++ i) {\\n            int len = 32 - __builtin_clz(i);\\n            ans = (ans << len | i) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613118,
                "title": "c-bit-manipulation-easy-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, i=0, x = 1;\\n        while(x <= n){\\n            if((x&(x-1)) == 0)\\n                i++;\\n            ans = ((ans << i) | x)%1000000007;\\n            x++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        long ans = 0, i=0, x = 1;\\n        while(x <= n){\\n            if((x&(x-1)) == 0)\\n                i++;\\n            ans = ((ans << i) | x)%1000000007;\\n            x++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2613035,
                "title": "100-fast-javascript-solution-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/7bfba09e-bc39-4517-9086-b2d8eca5725a_1663914882.3470545.png)\\n```\\nvar concatenatedBinary = function(n) {\\n     let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar concatenatedBinary = function(n) {\\n     let ans = 1, len = 4\\n    for (let i = 2; i <= n; i++) {\\n        if (i === len) len *= 2\\n        ans = (ans * len + i) % 1000000007;\\n    }\\n    return ans\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2613006,
                "title": "c-o-n",
                "content": "\\tpublic int ConcatenatedBinary(int n) \\n\\t\\t{\\n\\t\\t\\tlong current =  0;\\n\\t\\t\\tlong modulo = 1_000_000_000 + 7;\\n\\t\\t\\tfor(long i = 1; i <= n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong power = 1;\\n\\t\\t\\t\\twhile(power <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpower = power*2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrent = (current*power)%modulo;\\n\\t\\t\\t\\tcurrent = (current + i)%modulo;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int)current;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\tpublic int ConcatenatedBinary(int n) \\n\\t\\t{\\n\\t\\t\\tlong current =  0;\\n\\t\\t\\tlong modulo = 1_000_000_000 + 7;\\n\\t\\t\\tfor(long i = 1; i <= n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong power = 1;\\n\\t\\t\\t\\twhile(power <= i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpower = power*2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrent = (current*power)%modulo;\\n\\t\\t\\t\\tcurrent = (current + i)%modulo;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (int)current;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2612834,
                "title": "c-solution",
                "content": "```\\nint mod = 1e9+7; \\n\\nint concatenatedBinary(int n){\\n    long ans = 0;\\n    int k = 0;\\n    for (int i = 1 ; i <= n ; i++){\\n        if ((i & (i-1)) == 0){\\n            k++;\\n        }\\n        ans <<= k;\\n        ans |= i;\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mod = 1e9+7; \\n\\nint concatenatedBinary(int n){\\n    long ans = 0;\\n    int k = 0;\\n    for (int i = 1 ; i <= n ; i++){\\n        if ((i & (i-1)) == 0){\\n            k++;\\n        }\\n        ans <<= k;\\n        ans |= i;\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612810,
                "title": "c-solution-bit-manipulation-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/637abd8d-1252-4b74-b076-34c2ace3c940_1663910848.5433705.png)\\n\\n\\n```\\npublic int ConcatenatedBinary(int n) {\\n        long res = 0;\\n        int shift = 0;\\n        int m = 1000000007;\\n        \\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                shift++;\\n\\n            res = ((res<<shift) | i)%m;\\n        }\\n        \\n        return (int)(res%m);\\n    }\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int ConcatenatedBinary(int n) {\\n        long res = 0;\\n        int shift = 0;\\n        int m = 1000000007;\\n        \\n        for(int i=1; i<=n; i++){\\n            if((i&(i-1)) == 0)\\n                shift++;\\n\\n            res = ((res<<shift) | i)%m;\\n        }\\n        \\n        return (int)(res%m);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612739,
                "title": "java-concise-o-n-with-explanation",
                "content": "First of all, the number of left-shifts is the number of `2` we need to multiply.\\n\\nFor instance, when `n = 3`,\\n* It is `1`, `10`, and `11`.\\n* We start with `1`, and we left-shift 2 positions after we add `10`, which get us `110`  `= ` `1 * 2 * 2 + 2 = 6`.\\n* And then we left-shift two positions again after we add `11`, which give us `11011` `=` `6 * 2 * 2 + 3 = 27`.\\n\\n```\\n    private static int MOD = 1000000007;\\n\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int highest = 2;\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= highest) {\\n                highest *= 2;\\n            }\\n            ans = (ans * highest + i) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n    private static int MOD = 1000000007;\\n\\n    public int concatenatedBinary(int n) {\\n        long ans = 0;\\n        int highest = 2;\\n        for (int i = 1; i <= n; i++) {\\n            if (i >= highest) {\\n                highest *= 2;\\n            }\\n            ans = (ans * highest + i) % MOD;\\n        }\\n        return (int) ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612684,
                "title": "c-bit-manipulation-6-lines-clean-and-concise",
                "content": "**Video Explanation :**\\n[https://www.youtube.com/watch?v=97UNhXjpiVc](http://)\\n\\n**Code :** \\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        \\n        long long int ans=0;\\n        int p=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int tt=log2(i);\\n            ans=((ans<<(tt+1))%mod+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    int concatenatedBinary(int n) {\\n        \\n        long long int ans=0;\\n        int p=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int tt=log2(i);\\n            ans=((ans<<(tt+1))%mod+i)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612635,
                "title": "java-bitwise-operation-3-solutions",
                "content": "\\n# one line solution:\\n```\\n\\n    //Runtime: 311 ms, faster than 54.55% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 42.3 MB, less than 29.87% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    public int concatenatedBinary(int n) {\\n        return (int) LongStream.range(2, n + 1)\\n                .reduce(1, (sum, i) -> ((sum << Long.toBinaryString(i).length()) | i) % 1_000_000_007);\\n    }\\n```\\n\\n\\n# Bitwise operation\\n```\\n\\t//Runtime: 84 ms, faster than 90.91% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 40.8 MB, less than 81.82% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Bitwise operation\\n    //Time: O(N); Space: O(1)\\n    public int concatenatedBinary(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1, shift = 1;\\n        for (int i = 2; i <= n; i++){\\n            if ((i & (i - 1)) == 0) shift++;\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```\\n\\n\\n\\n```\\n    //Runtime: 468 ms, faster than 46.75% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 121.9 MB, less than 5.19% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Integer.toBinaryString\\n    //Time: O(N * lgN); Space: O(N)\\n    public int concatenatedBinary_1(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1;\\n        for (int i = 2; i <= n; i++){\\n            int shift = Integer.toBinaryString(i).length(); //consume time....\\n//            int shift = Integer.toString(i, 2).length();\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    //Runtime: 311 ms, faster than 54.55% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 42.3 MB, less than 29.87% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    public int concatenatedBinary(int n) {\\n        return (int) LongStream.range(2, n + 1)\\n                .reduce(1, (sum, i) -> ((sum << Long.toBinaryString(i).length()) | i) % 1_000_000_007);\\n    }\\n```\n```\\n\\t//Runtime: 84 ms, faster than 90.91% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 40.8 MB, less than 81.82% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Bitwise operation\\n    //Time: O(N); Space: O(1)\\n    public int concatenatedBinary(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1, shift = 1;\\n        for (int i = 2; i <= n; i++){\\n            if ((i & (i - 1)) == 0) shift++;\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```\n```\\n    //Runtime: 468 ms, faster than 46.75% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Memory Usage: 121.9 MB, less than 5.19% of Java online submissions for Concatenation of Consecutive Binary Numbers.\\n    //Integer.toBinaryString\\n    //Time: O(N * lgN); Space: O(N)\\n    public int concatenatedBinary_1(int n) {\\n        final int MODULO = 1_000_000_007;\\n\\n        long res = 1;\\n        for (int i = 2; i <= n; i++){\\n            int shift = Integer.toBinaryString(i).length(); //consume time....\\n//            int shift = Integer.toString(i, 2).length();\\n            res = ((res << shift) | i) % MODULO;\\n        }\\n        return (int) (res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612612,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const long MOD= 1e9+7;\\n        long long ans=0;\\n        for (int i=1;i<=n;i++) {\\n            \\n            ans=ans<<(long)(log2(i)+1);\\n            ans=(ans|i)%MOD;\\n        }\\n                      return ans%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        const long MOD= 1e9+7;\\n        long long ans=0;\\n        for (int i=1;i<=n;i++) {\\n            \\n            ans=ans<<(long)(log2(i)+1);\\n            ans=(ans|i)%MOD;\\n        }\\n                      return ans%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612588,
                "title": "0-ms",
                "content": "Calculating `dp` once for all numbers, then every test case is O(1).\\n**C++**\\n```cpp\\nlong long dp[100001] = {};\\nclass Solution {\\npublic:\\nint concatenatedBinary(int n) {\\n    if (!dp[1])\\n        for (auto i = 1; i <= 100000; ++i)\\n            dp[i] = ((dp[i - 1] << ((int)log2(i) + 1)) + i) % 1000000007;\\n    return dp[n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long dp[100001] = {};\\nclass Solution {\\npublic:\\nint concatenatedBinary(int n) {\\n    if (!dp[1])\\n        for (auto i = 1; i <= 100000; ++i)\\n            dp[i] = ((dp[i - 1] << ((int)log2(i) + 1)) + i) % 1000000007;\\n    return dp[n];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612509,
                "title": "c-96-65-faster-than-all-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }\\n            \\n            result = (result * next + i) % max_n;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int concatenatedBinary(int n) {\\n        int next = 1, length = 1;\\n        long max_n = pow(10, 9) + 7, result = 0;\\n        for (int i = 0; i <= n; i++) {\\n            if (i == next) {\\n                next *= 2;\\n                length++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2612492,
                "title": "swift-fast-and-simple-solution",
                "content": "```\\nclass Solution {\\n    func concatenatedBinary(_ n: Int) -> Int {\\n        var binaryArray = [Bool]()\\n        for i in 1...n {\\n            binaryArray += i.toBinary()\\n        }\\n        var result = 0\\n        for bool in binaryArray {\\n            result = result * 2 % 1000000007\\n            if bool {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Int {\\n    func toBinary() -> [Bool] {\\n        var i = self\\n        var result = [Bool]()\\n        while i != 0 {\\n            if i % 2 != 0 {\\n                result.insert(true, at: 0)\\n            } else {\\n                result.insert(false, at: 0)\\n            }\\n            i /= 2\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func concatenatedBinary(_ n: Int) -> Int {\\n        var binaryArray = [Bool]()\\n        for i in 1...n {\\n            binaryArray += i.toBinary()\\n        }\\n        var result = 0\\n        for bool in binaryArray {\\n            result = result * 2 % 1000000007\\n            if bool {\\n                result += 1\\n            }\\n        }\\n        return result\\n    }\\n}\\n\\nextension Int {\\n    func toBinary() -> [Bool] {\\n        var i = self\\n        var result = [Bool]()\\n        while i != 0 {\\n            if i % 2 != 0 {\\n                result.insert(true, at: 0)\\n            } else {\\n                result.insert(false, at: 0)\\n            }\\n            i /= 2\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612485,
                "title": "python-3-line-solution-easy-approach",
                "content": "\\n        bin_str = \\'\\'\\n        for i in range(1, n+1): bin_str += bin(i)[2:]\\n        return int(bin_str, 2)%(10**9 + 7)",
                "solutionTags": [],
                "code": "\\n        bin_str = \\'\\'\\n        for i in range(1, n+1): bin_str += bin(i)[2:]\\n        return int(bin_str, 2)%(10**9 + 7)",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570251,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            },
            {
                "id": 1979089,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            },
            {
                "id": 2005613,
                "content": [
                    {
                        "username": "ToffeeLu",
                        "content": "Generally, 10^5 means it could accept even O(nlogn) solutions, but actually it could not accept O(32n) solution.\\nAlso the run & submit button are not consistent, when I click run for the largest test case 100000, it goes well, but when I submit, TLE for a smaller test case.\\nNot to say this question is harder for some language.\\nBad question."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "100 medium questions solved yay"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "congrats broo!\\n"
                    },
                    {
                        "username": "Kartikey_Bartwal",
                        "content": "congratulations mate! Wish you best wishes"
                    },
                    {
                        "username": "piyushboorra",
                        "content": " ` int concatenatedBinary(int n) {\n        int M=1e9+7;\n\n        vector<int>pref(n+1);\n\n        long long int ans=0;\n\n        pref[n]=0;\n\n        for(int i=n-1;i>=1;i--)\n\n        {\n            pref[i]=pref[i+1]+(log2(i+1)+1);\n\n        }\n        for(long long int i=1;i<=n;i++)\n\n        {\n            ans|=((i<<pref[i])%M);\n\n        }\n        return ans%M;\n\n    }`\nwhy this code fails on 3rd sample test case(when n=12) ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Incompatibility",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You are asked to distribute this array into <code>k</code> subsets of <strong>equal size</strong> such that there are no two equal elements in the same subset.</p>\n\n<p>A subset&#39;s <strong>incompatibility</strong> is the difference between the maximum and minimum elements in that array.</p>\n\n<p>Return <em>the <strong>minimum possible sum of incompatibilities</strong> of the </em><code>k</code> <em>subsets after distributing the array optimally, or return </em><code>-1</code><em> if it is not possible.</em></p>\n\n<p>A subset is a group integers that appear in the array with no particular order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,1,4], k = 2\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,3,8,1,3,1,2,2], k = 4\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,3,3,6,3,3], k = 3\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 16</code></li>\n\t<li><code>nums.length</code> is divisible by <code>k</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 961969,
                "title": "python-true-o-n-n-2-n-bit-dp-explained",
                "content": "I saw a lot of solutions here, which state that they have complexity `O(n*2^n)`, but without really explaining why it is true. Here is my implementation, using bitmask, which is similar to TSE problem (https://en.wikipedia.org/wiki/Travelling_salesman_problem): we need to keep state in the form: `bitmask, last`, where:\\n1. `bitmask` is bitmask for all numbers already taken.\\n2. `last` is index of last taken number.\\n\\nHow are we going to form our groups: sort our numbers first and imagine we have numbers `[1,1,2,3,3,4]`: and `k = 3`. Then we need to create first group of `2` elements, for example it can be elements with indexes `1,2`, and we have current bitmask `011000`, then we need to form another group of `2` elements, for example it can be elements with indexes `0,5`, so we have bitmask `111001` now. Finally we put last two elements in last group. We can interpret it as TSE problem: we choose path `1->2->0->5->3->4`.  Note, that in each group we only choose increasing indexes, whereas between groups than can decrease (but can increase also).\\n\\nNow, what we have in our algorithm:\\n1. We iterate over all possible `mask`\\n2. Calculate places, where we have `1` in this mask.\\n3. Now, we can have two cases: first, if `len(n_z_bits)%(n//k) == 1`: it means, that it is time to start new group, so we can choose any index we want, not neccecerily bigger than previous, so we choose `permutations` here: there will be exactly `t(t-1)/2` pairs and for each of them we update `dp[mask][l]`.\\n4. In other case, it means, that we need to continue to build our group, so next index should be bigger than previous and we choose `combinations` here. Also we check that new number is not equal to last one we have and again update `dp[mask][l]`.\\n5. Finally, we return minimum from `dp[-1]`.\\n\\n**Complexity**: time complexity is `O(n*n*2^n)` as TSE have: we have `2^n` bitmasks and we have `O(n^2)` time to process each mask. In python it is working not very fast, I can say it is barely accepted, so, I think there should be `O(n*2^n)` solution as well, if you know such solution (desirebly with explanations), please let me know!\\n\\n```python\\nclass Solution:\\n    def minimumIncompatibility(self, nums, k):\\n        n = len(nums)\\n        if k == n: return 0\\n        dp = [[float(\"inf\")] * n for _ in range(1<<n)] \\n        nums.sort()\\n        for i in range(n): dp[1<<i][i] = 0\\n\\n        for mask in range(1<<n):\\n            n_z_bits = [j for j in range(n) if mask&(1<<j)]\\n            if len(n_z_bits)%(n//k) == 1:\\n                for j, l in permutations(n_z_bits, 2):\\n                    dp[mask][l] = min(dp[mask][l], dp[mask^(1<<l)][j])\\n            else:\\n                for j, l in combinations(n_z_bits, 2):\\n                    if nums[j] != nums[l]:\\n                        dp[mask][j] = min(dp[mask][j], dp[mask^(1<<j)][l] + nums[l] - nums[j])\\n                        \\n        return min(dp[-1]) if min(dp[-1]) != float(\"inf\") else -1\\n```\\n\\n**PS**: leetcode changed their tests, so I also need to adjust my code a bit. Complexity is still the same, but now it is working 9800-9950 milliseconds, so barely passes =)\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumIncompatibility(self, nums, k):\\n        n = len(nums)\\n        if k == n: return 0\\n        dp = [[float(\"inf\")] * n for _ in range(1<<n)] \\n        nums.sort()\\n        for i in range(n): dp[1<<i][i] = 0\\n\\n        for mask in range(1<<n):\\n            n_z_bits = [j for j in range(n) if mask&(1<<j)]\\n            if len(n_z_bits)%(n//k) == 1:\\n                for j, l in permutations(n_z_bits, 2):\\n                    dp[mask][l] = min(dp[mask][l], dp[mask^(1<<l)][j])\\n            else:\\n                for j, l in combinations(n_z_bits, 2):\\n                    if nums[j] != nums[l]:\\n                        dp[mask][j] = min(dp[mask][j], dp[mask^(1<<j)][l] + nums[l] - nums[j])\\n                        \\n        return min(dp[-1]) if min(dp[-1]) != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961451,
                "title": "c-dp-with-explanation-and-comments",
                "content": "Since n is at most 16, we can use a bitmap to represent any subset of the input array. Define `dp[b]` as the answer to the subset represented by bitmap `b`, we can iterate over all the valid subset `tb` of `b` of size `n/k`, and update `dp[b]` as `min(dp[b], dp[b-tb]+dp[tb])`.\\n\\nTo speed up the inner loop, we can pre-generate all the valid subsets of size `n/k` and corresponding incompatibilities.\\n\\n**Original Solution:**\\n```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = n/k;\\n        const vector<pair<int, int>> bmap = getMap(nums, m);\\n\\n        vector<int> dp(1<<n, -1);\\n        dp[0] = 0;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) % m != 0) continue;\\n            for (const auto& [tb, v] : bmap) {\\n                if (tb > b) break; // Only try m-digit combinations smaller than b.\\n                if ((tb & b) != tb) continue;\\n                if (dp[b-tb] == -1) continue;\\n                if (dp[b] == -1) dp[b] = dp[b-tb]+v;\\n                else dp[b] = min(dp[b], dp[b-tb]+v);\\n            }\\n        }\\n        return dp.back();\\n    }\\n\\nprivate:\\n    // Pre-generates all valid subsets and corresponding incompatibilities.\\n    vector<pair<int, int>> getMap(const vector<int>& nums, int m) {\\n\\t    const int n = nums.size();\\n        vector<pair<int, int>> ans;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) != m) continue;\\n\\n            int vis = 0;\\n            int mx = 0, mn = 16;\\n            bool is_good = true;\\n            for (int i = 0; i < n; ++i) {\\n                if ((b & (1<<i)) == 0) continue;\\n                if (vis & (1<<nums[i])) {\\n                    is_good = false;\\n                    break;\\n                }\\n                vis |= (1<<nums[i]);\\n                mx = max(mx, nums[i]);\\n                mn = min(mn, nums[i]);\\n            }\\n            if (!is_good) continue;\\n            \\n            ans.emplace_back(b, mx-mn);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Optimization (credit to [@apluscs](https://leetcode.com/apluscs/))**\\nInstead of interating over `bmap` in the innner loop, we can iterate over all the sub-bitmasks of `b` instead. (See details in @apluscs\\'s great [comment](https://leetcode.com/problems/minimum-incompatibility/discuss/961451/C++-DP-with-explanation-and-comments/782104) below).\\n```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = n/k;\\n        const vector<int> bmap = getMap(nums, m);\\n\\n        vector<int> dp(1<<n, -1);\\n        dp[0] = 0;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) % m != 0) continue;\\n\\t\\t\\t// Reference: https://cp-algorithms.com/algebra/all-submasks.html\\n            for (int tb = b; tb; tb = (tb-1)&b) {\\n                if (bmap[tb] == -1) continue;\\n                if (dp[b-tb] == -1) continue;\\n                if (dp[b] == -1) dp[b] = dp[b-tb]+bmap[tb];\\n                else dp[b] = min(dp[b], dp[b-tb]+bmap[tb]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n\\nprivate:\\n    // Generates a vetor v where:\\n    //   v[b] = the incompatibility of bitmask b, if b represents a valid subset of size m\\n    //   v[b] = -1, if b is not a valid subset of size m\\n    vector<int> getMap(const vector<int>& nums, int m) {\\n\\t    const int n = nums.size();\\n        vector<int> ans(1<<n, -1);\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) != m) continue;\\n\\n            int vis = 0;\\n            int mx = 0, mn = 16;\\n            bool is_good = true;\\n            for (int i = 0; i < n; ++i) {\\n                if ((b & (1<<i)) == 0) continue;\\n                if (vis & (1<<nums[i])) {\\n                    is_good = false;\\n                    break;\\n                }\\n                vis |= (1<<nums[i]);\\n                mx = max(mx, nums[i]);\\n                mn = min(mn, nums[i]);\\n            }\\n            if (!is_good) continue;\\n            \\n            ans[b] = mx-mn;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = n/k;\\n        const vector<pair<int, int>> bmap = getMap(nums, m);\\n\\n        vector<int> dp(1<<n, -1);\\n        dp[0] = 0;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) % m != 0) continue;\\n            for (const auto& [tb, v] : bmap) {\\n                if (tb > b) break; // Only try m-digit combinations smaller than b.\\n                if ((tb & b) != tb) continue;\\n                if (dp[b-tb] == -1) continue;\\n                if (dp[b] == -1) dp[b] = dp[b-tb]+v;\\n                else dp[b] = min(dp[b], dp[b-tb]+v);\\n            }\\n        }\\n        return dp.back();\\n    }\\n\\nprivate:\\n    // Pre-generates all valid subsets and corresponding incompatibilities.\\n    vector<pair<int, int>> getMap(const vector<int>& nums, int m) {\\n\\t    const int n = nums.size();\\n        vector<pair<int, int>> ans;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) != m) continue;\\n\\n            int vis = 0;\\n            int mx = 0, mn = 16;\\n            bool is_good = true;\\n            for (int i = 0; i < n; ++i) {\\n                if ((b & (1<<i)) == 0) continue;\\n                if (vis & (1<<nums[i])) {\\n                    is_good = false;\\n                    break;\\n                }\\n                vis |= (1<<nums[i]);\\n                mx = max(mx, nums[i]);\\n                mn = min(mn, nums[i]);\\n            }\\n            if (!is_good) continue;\\n            \\n            ans.emplace_back(b, mx-mn);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = n/k;\\n        const vector<int> bmap = getMap(nums, m);\\n\\n        vector<int> dp(1<<n, -1);\\n        dp[0] = 0;\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) % m != 0) continue;\\n\\t\\t\\t// Reference: https://cp-algorithms.com/algebra/all-submasks.html\\n            for (int tb = b; tb; tb = (tb-1)&b) {\\n                if (bmap[tb] == -1) continue;\\n                if (dp[b-tb] == -1) continue;\\n                if (dp[b] == -1) dp[b] = dp[b-tb]+bmap[tb];\\n                else dp[b] = min(dp[b], dp[b-tb]+bmap[tb]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n\\nprivate:\\n    // Generates a vetor v where:\\n    //   v[b] = the incompatibility of bitmask b, if b represents a valid subset of size m\\n    //   v[b] = -1, if b is not a valid subset of size m\\n    vector<int> getMap(const vector<int>& nums, int m) {\\n\\t    const int n = nums.size();\\n        vector<int> ans(1<<n, -1);\\n        for (int b = 0; b < (1<<n); ++b) {\\n            if (__builtin_popcount(b) != m) continue;\\n\\n            int vis = 0;\\n            int mx = 0, mn = 16;\\n            bool is_good = true;\\n            for (int i = 0; i < n; ++i) {\\n                if ((b & (1<<i)) == 0) continue;\\n                if (vis & (1<<nums[i])) {\\n                    is_good = false;\\n                    break;\\n                }\\n                vis |= (1<<nums[i]);\\n                mx = max(mx, nums[i]);\\n                mn = min(mn, nums[i]);\\n            }\\n            if (!is_good) continue;\\n            \\n            ans[b] = mx-mn;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961392,
                "title": "python-bruteforce-dp",
                "content": "Idea: store the results of all valid subsets of the original array, there are at most `2^16=65536` states that we need to calculate.\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        d=len(nums)//k # the length of each partition\\n        \\n        @lru_cache(None)\\n        def helper(nums):\\n            if not nums:\\n                return 0\\n            ret=10**15\\n            for a in combinations(nums,d): # choose a as a partition\\n                if len(set(a))<d: # check for duplicates\\n                    continue\\n                left=list(nums) # numbers left after removing partition a\\n                for v in a:\\n                    left.remove(v)\\n                ret=min(ret,max(a)-min(a)+helper(tuple(left)))\\n            return ret\\n        \\n        ans=helper(tuple(nums)) # turn the input into a tuple so the function can be cached\\n        return ans if ans!=10**15 else -1\\n```\\n**Edit**: **Optimization** (credit to @Gowe, @bismeet): we can create each partition by `combinations(set(nums),d)` and skip the check for duplicates (see details in the comments).\\n\\n**Time complexity** (credit to @apluscs): `O(n *(n choose d)*2^n)`, where `d` is the size of each partition. We have `O(2^n)` states, for each state we loop over `O(n choose d)` cases and for each case we need to create a set/tuple of length `O(n)`. \\nHowever, this seems to be overestimating the complexity by a lot, as for `n=16` we get the worst case : `16*(16 choose 8)*2^16=1.3e10`. My guess is that on average we only calculate for the subsets whose sizes are multiples of `d` and not all `2^n` states are needed. I tried to calculate the complexity without approximations and got the worst cast is about `2.8e7` when `n=16, d=4`.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        d=len(nums)//k # the length of each partition\\n        \\n        @lru_cache(None)\\n        def helper(nums):\\n            if not nums:\\n                return 0\\n            ret=10**15\\n            for a in combinations(nums,d): # choose a as a partition\\n                if len(set(a))<d: # check for duplicates\\n                    continue\\n                left=list(nums) # numbers left after removing partition a\\n                for v in a:\\n                    left.remove(v)\\n                ret=min(ret,max(a)-min(a)+helper(tuple(left)))\\n            return ret\\n        \\n        ans=helper(tuple(nums)) # turn the input into a tuple so the function can be cached\\n        return ans if ans!=10**15 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961470,
                "title": "java-backtrack-solution-with-optimizations",
                "content": "The idea is a simple backtracking approach, but with optimizations to avoid unnecessary computations.\\nThere are two optimizations used in the method **backtrack**:\\n* using a set of **visited** sets, that is sets that have already been considered in this backtracking phase. If there are two sets that are the same it\\'s no use considering adding the current element to both of them, because the two resulting backtracking trees are going to be the same anyway.\\n* stopping backtracking when we see that the current solution (accumulated in **acc**) is bigger than the best solution so far.\\n\\n```\\nclass Solution {\\n    private int min = Integer.MAX_VALUE;\\n    private int bucketSize = 0;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        bucketSize = n / k;\\n        \\n        List<Set<Integer>> sets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            sets.add(new HashSet<>());\\n        }\\n        \\n        backtrack(nums, 0, sets, 0);\\n        \\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    \\n    private void backtrack(int[] nums, int idx, List<Set<Integer>> sets, int acc) {\\n        if (idx >= nums.length) {\\n            min = Math.min(min, acc);\\n            return;\\n        }\\n        \\n        Set<Set<Integer>> visited = new HashSet<>();\\n        \\n        for (Set<Integer> set: sets) {\\n            if (set.contains(nums[idx]) || set.size() == bucketSize || visited.contains(set)) continue;\\n            int impact = computeImpact(set, nums[idx]);\\n            acc += impact;\\n            if (acc < min) {\\n                set.add(nums[idx]);\\n                backtrack(nums, idx+1, sets, acc);\\n                set.remove(nums[idx]);\\n            }\\n            acc -= impact;\\n            visited.add(set);\\n        }\\n    }\\n    \\n    private int computeImpact(Set<Integer> set, int num) {\\n        if (set.size() == 0) return 0;\\n        if (set.size() == 1) return Math.abs(num - set.iterator().next());\\n        int lo = Integer.MAX_VALUE;\\n        int hi = Integer.MIN_VALUE;\\n        \\n        for (int x: set) {\\n            lo = Math.min(lo, x);\\n            hi = Math.max(hi, x);\\n        }\\n        \\n        if (num < lo) return lo - num;\\n        if (num > hi) return num - hi;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int min = Integer.MAX_VALUE;\\n    private int bucketSize = 0;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        bucketSize = n / k;\\n        \\n        List<Set<Integer>> sets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            sets.add(new HashSet<>());\\n        }\\n        \\n        backtrack(nums, 0, sets, 0);\\n        \\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    \\n    private void backtrack(int[] nums, int idx, List<Set<Integer>> sets, int acc) {\\n        if (idx >= nums.length) {\\n            min = Math.min(min, acc);\\n            return;\\n        }\\n        \\n        Set<Set<Integer>> visited = new HashSet<>();\\n        \\n        for (Set<Integer> set: sets) {\\n            if (set.contains(nums[idx]) || set.size() == bucketSize || visited.contains(set)) continue;\\n            int impact = computeImpact(set, nums[idx]);\\n            acc += impact;\\n            if (acc < min) {\\n                set.add(nums[idx]);\\n                backtrack(nums, idx+1, sets, acc);\\n                set.remove(nums[idx]);\\n            }\\n            acc -= impact;\\n            visited.add(set);\\n        }\\n    }\\n    \\n    private int computeImpact(Set<Integer> set, int num) {\\n        if (set.size() == 0) return 0;\\n        if (set.size() == 1) return Math.abs(num - set.iterator().next());\\n        int lo = Integer.MAX_VALUE;\\n        int hi = Integer.MIN_VALUE;\\n        \\n        for (int x: set) {\\n            lo = Math.min(lo, x);\\n            hi = Math.max(hi, x);\\n        }\\n        \\n        if (num < lo) return lo - num;\\n        if (num > hi) return num - hi;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965432,
                "title": "c-clean-with-detailed-explanation",
                "content": "**General idea**\\nEvaluate every valid subset of the given array (where a valid subset is one with no duplicates and has the correct number of elements). For each valid subset, find its range (where range = maximum - minimum) + the sum of ranges of all other subsets (precomputed via dp)\\n\\n**Implementation**\\n* Pre-generate the range (max - min) for each subset of nums that doesn\\'t have any duplicates\\n* Note: to find each subset, you can use bitmasks (i.e. iterate from 1 to (1 << n) - 1, and find how many bits of each bitmask are set to 1, etc.)\\n* Then take each subset of nums and apply DP to it as follows:\\n\\t* Take every sub-subset of this subset and see if it has the right number of elements (== n / k)\\n\\t* If it does, then dp[subset] = range[sub-subset] + dp[all other elements in subset excluding those in sub-subset]\\n\\nFor further implementation details, check out the comments in the code. \\n\\n**Example**\\n* Take the example of [1,1,2,3,4,5,5,6] and k = 4. I.e., you need to split the given array into 4 groups of 2 elements each.\\n* Consider every subset. Say we are looking at the first 4 elements [1,1,2,3] - which corresponds to a mask of 00001111 (or 11110000 - shouldn\\'t matter).\\n* Now consider every submask of this mask that has exactly 2 elements. That would correspond to [1,1], [1,2], [1,3], [2, 3]. \\n* [1,1] will be rejected as it has duplicates. \\n* Next, we take [1,2] (note that [1,2] is a submask of 1010 on the 4 element array [1,1,2,3] from the prior step). dp[[1,1,2,3]] = range[[1,2]] + dp[[1,3]]. Here, range[1,2] = 2 - 1 = 1 and dp[1,3] would have been calculated already since our DP is being built incrementally.\\n\\n```\\nconst int INF = 1e9;\\n\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int i, n = nums.size(), subset_size = n / k;\\n        sort(nums.begin(), nums.end());\\n        \\n        // Pre-calculate the range (max - min) for each subset of nums\\n\\t\\t// Note that there are (1 << n) subsets (i.e. 2 ^ n subsets) of an array of size n\\n        vector<int> range(1 << n, INF);\\n        \\n        // Each mask represents every possible subset of elements in num (so, \"mask\" == \"subset\")\\n\\t\\t// Specifically, if the bit at position i of mask is set to 1, then we include that number in the subset\\n        for(int mask = 1; mask < (1 << n); mask++) {\\n            int small = -1, big = -1;\\n            bool dup = false;\\n            \\n            // Identify elements that belong to this subset, find the largest & smallest, check for duplicates\\n\\t\\t\\t// Recall that this array was sorted in the beginning of the function\\n            for(i=0; i<n && !dup; i++)\\n                if(mask & (1 << i)) {\\n                    if(small == -1)\\n                        small = nums[i];\\n                    if(big == nums[i])\\n                        dup = true;\\n                    big = nums[i];\\n                }\\n            \\n            // If no duplicates were found, then calculate and store the range for this subset\\n            if(!dup)\\n                range[mask] = big - small;\\n        }\\n        \\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n\\n        // Iterate over every mask (i.e. subset) and calculate its minimum sum\\n        for(int mask = 1; mask < (1 << n); mask++) {\\n            \\n            // Iterate over every submask for current mask\\n            for(int submask = mask; submask; submask = (submask - 1) & mask) {\\n                \\n                // Check that submask has the right number of elements\\n                if(__builtin_popcount(submask) == subset_size) \\n                    // Note that      mask = submask + (mask ^ submask)\\n                    // ==> i.e.,      mask ^ submask = mask - submask\\n                    // In other words, (mask ^ submask) represents those elements in mask that are not in submask\\n                    dp[mask] = min(dp[mask], range[submask] + dp[mask ^ submask]);\\n            }\\n        }\\n\\t\\t// dp.back() == dp[(1 << n) - 1];\\n        return dp.back() >= INF ? -1 : dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst int INF = 1e9;\\n\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int i, n = nums.size(), subset_size = n / k;\\n        sort(nums.begin(), nums.end());\\n        \\n        // Pre-calculate the range (max - min) for each subset of nums\\n\\t\\t// Note that there are (1 << n) subsets (i.e. 2 ^ n subsets) of an array of size n\\n        vector<int> range(1 << n, INF);\\n        \\n        // Each mask represents every possible subset of elements in num (so, \"mask\" == \"subset\")\\n\\t\\t// Specifically, if the bit at position i of mask is set to 1, then we include that number in the subset\\n        for(int mask = 1; mask < (1 << n); mask++) {\\n            int small = -1, big = -1;\\n            bool dup = false;\\n            \\n            // Identify elements that belong to this subset, find the largest & smallest, check for duplicates\\n\\t\\t\\t// Recall that this array was sorted in the beginning of the function\\n            for(i=0; i<n && !dup; i++)\\n                if(mask & (1 << i)) {\\n                    if(small == -1)\\n                        small = nums[i];\\n                    if(big == nums[i])\\n                        dup = true;\\n                    big = nums[i];\\n                }\\n            \\n            // If no duplicates were found, then calculate and store the range for this subset\\n            if(!dup)\\n                range[mask] = big - small;\\n        }\\n        \\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n\\n        // Iterate over every mask (i.e. subset) and calculate its minimum sum\\n        for(int mask = 1; mask < (1 << n); mask++) {\\n            \\n            // Iterate over every submask for current mask\\n            for(int submask = mask; submask; submask = (submask - 1) & mask) {\\n                \\n                // Check that submask has the right number of elements\\n                if(__builtin_popcount(submask) == subset_size) \\n                    // Note that      mask = submask + (mask ^ submask)\\n                    // ==> i.e.,      mask ^ submask = mask - submask\\n                    // In other words, (mask ^ submask) represents those elements in mask that are not in submask\\n                    dp[mask] = min(dp[mask], range[submask] + dp[mask ^ submask]);\\n            }\\n        }\\n\\t\\t// dp.back() == dp[(1 << n) - 1];\\n        return dp.back() >= INF ? -1 : dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961672,
                "title": "python-dfs-backtracking-pruning-100-ms",
                "content": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        f = Counter(nums)\\n        if any(f[num] > k for num in f):\\n            return -1\\n        bags = [[] for i in range(k)]\\n        res = float(\"inf\")\\n        n = len(nums)\\n        M = n // k\\n        nums.sort()\\n\\t\\t\\n\\t\\t###precalculate gaps_sum for pruning\\n        s = 0\\n\\t\\tcur = []\\n        numbers = sorted(f.keys())\\n        gaps = defaultdict(int)\\n        gaps_sum =defaultdict(int)\\n        for i in range(1,len(numbers)):\\n            gaps[numbers[i]] = numbers[i] - numbers[i-1]\\n        for i in range(n-1,-1,-1):\\n            cur.append(gaps[nums[i]])\\n            cur.sort()\\n            s += gaps[nums[i]]\\n            gaps_sum[i,0] = s\\n            for empty in range(1,min(k+1,len(cur))):\\n                gaps_sum[i,empty] = gaps_sum[i,empty-1] - cur[-empty]\\n        \\n\\t\\t### DFS put #i number in #j bag\\n        def DFS(i,cur_res,empty_bags):\\n            nonlocal res\\n            if i == n:\\n                res = min(res,cur_res)\\n                return\\n            if cur_res + gaps_sum[i,empty_bags] >= res  : \\n                return \\n            \\n            for j in range(k):\\n\\t\\t\\t\\t### skip when 1. encounter same combination 2. avoid duplicate number in some bags 3. bag is full\\n                if (j > 0 and bags[j] == bags[j-1]) or (bags[j] and bags[j][-1] == nums[i]) or (len(bags[j]) == M):\\n                    continue\\n                else:\\n                    bags[j].append(nums[i])\\n                    if len(bags[j]) == 1:\\n                        DFS(i+1,cur_res,empty_bags-1)\\n                    else:\\n                        DFS(i+1,cur_res+bags[j][-1]-bags[j][-2],empty_bags)\\n                    bags[j].pop()                \\n        DFS(0,0,k)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        f = Counter(nums)\\n        if any(f[num] > k for num in f):\\n            return -1\\n        bags = [[] for i in range(k)]\\n        res = float(\"inf\")\\n        n = len(nums)\\n        M = n // k\\n        nums.sort()\\n\\t\\t\\n\\t\\t###precalculate gaps_sum for pruning\\n        s = 0\\n\\t\\tcur = []\\n        numbers = sorted(f.keys())\\n        gaps = defaultdict(int)\\n        gaps_sum =defaultdict(int)\\n        for i in range(1,len(numbers)):\\n            gaps[numbers[i]] = numbers[i] - numbers[i-1]\\n        for i in range(n-1,-1,-1):\\n            cur.append(gaps[nums[i]])\\n            cur.sort()\\n            s += gaps[nums[i]]\\n            gaps_sum[i,0] = s\\n            for empty in range(1,min(k+1,len(cur))):\\n                gaps_sum[i,empty] = gaps_sum[i,empty-1] - cur[-empty]\\n        \\n\\t\\t### DFS put #i number in #j bag\\n        def DFS(i,cur_res,empty_bags):\\n            nonlocal res\\n            if i == n:\\n                res = min(res,cur_res)\\n                return\\n            if cur_res + gaps_sum[i,empty_bags] >= res  : \\n                return \\n            \\n            for j in range(k):\\n\\t\\t\\t\\t### skip when 1. encounter same combination 2. avoid duplicate number in some bags 3. bag is full\\n                if (j > 0 and bags[j] == bags[j-1]) or (bags[j] and bags[j][-1] == nums[i]) or (len(bags[j]) == M):\\n                    continue\\n                else:\\n                    bags[j].append(nums[i])\\n                    if len(bags[j]) == 1:\\n                        DFS(i+1,cur_res,empty_bags-1)\\n                    else:\\n                        DFS(i+1,cur_res+bags[j][-1]-bags[j][-2],empty_bags)\\n                    bags[j].pop()                \\n        DFS(0,0,k)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 961669,
                "title": "clean-java",
                "content": "DFS + memo, we use dp[curHandElement, remainingElement] to cache\\n\\nremainingElement use Arrays.hashCode(count) to save\\n\\nlogic is pretty straight forward, we pick number one by one, and when we meet the size N of one bucket, we clean the numbers at hand and start picking again.\\n\\nversion1: hasSet version (118ms)\\n```\\nclass Solution {\\n    int N;\\n    Map<String, Integer> memo;\\n    int k;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        memo = new HashMap<>(); k = k;\\n        int[] count = new int[17];\\n        for (int num : nums) if (++count[num] > k) return -1;  // if same number more than k times, we can not answer the question cause there must be one bucket with same number twice\\n        N = nums.length / k;   //N is the number of element in each bucket\\n        return dfs(new HashSet<>(), count);\\n    }\\n    \\n    private int dfs(Set<Integer> level, int[] count) {\\n        if (level.size() == N)\\n            return end(count) ? findDiff(level) : findDiff(level) + dfs(new HashSet<>(), count);\\n        String key = Arrays.hashCode(count) + \" \" + level; //count is remaining element status, level is current hand bucket element\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int res = 1000;\\n        for (int i = 1; i <= 16; i++) {\\n            if (count[i] <= 0) continue; //no more this number left\\n            if (!level.add(i)) continue; //at hand same number already exist\\n            count[i]--;\\n            res = Math.min(res, dfs(level, count));\\n            count[i]++;\\n            level.remove(i);\\n            if (level.size() == 0) break;   // first element we don\\'t need to expand\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int findDiff(Set<Integer> level) {\\n        return Collections.max(level) - Collections.min(level);\\n    }\\n    \\n    private boolean end(int[] count) {\\n        for (int c : count) if (c != 0) return false;\\n        return true;\\n    }\\n}\\n\\n```\\n\\nversion2:  bitMask version (59ms)\\n\\ncurrent hand element use bitMask to save\\n\\n```\\nclass Solution {\\n    int N;\\n    Map<String, Integer> memo;\\n    int k;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        memo = new HashMap<>(); k = k;\\n        int[] count = new int[17];\\n        for (int num : nums) if (++count[num] > k) return -1;\\n        N = nums.length / k;\\n        return dfs(0, count);\\n    }\\n    \\n    private int dfs(int level, int[] count) {\\n        if (Integer.bitCount(level) == N) {\\n            if (end(count)) return findDiff(level);\\n            else return findDiff(level) + dfs(0, count);\\n        } \\n        String key = Arrays.hashCode(count) + \" \" + level;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int res = 1000;\\n        for (int i = 1; i <= 16; i++) {\\n            if (count[i] <= 0) continue;\\n            int mask = 1 << i;\\n            if ((level & mask) != 0) continue;\\n            level |= mask;\\n            count[i]--;\\n            res = Math.min(res, dfs(level, count));\\n            count[i]++;\\n            level ^= mask;\\n            if (Integer.bitCount(level) == 0) break;  // first element we don\\'t need to expand\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int findDiff(int level) {\\n        int max = 0, min = 16;\\n        for (int i = 1; i <= 16; i++) {\\n            int mask = 1 << i;\\n            if ((level & mask) == 0) continue;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        return max - min;\\n    }\\n    \\n    private boolean end(int[] count) {\\n        for (int c : count) if (c != 0) return false;\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int N;\\n    Map<String, Integer> memo;\\n    int k;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        memo = new HashMap<>(); k = k;\\n        int[] count = new int[17];\\n        for (int num : nums) if (++count[num] > k) return -1;  // if same number more than k times, we can not answer the question cause there must be one bucket with same number twice\\n        N = nums.length / k;   //N is the number of element in each bucket\\n        return dfs(new HashSet<>(), count);\\n    }\\n    \\n    private int dfs(Set<Integer> level, int[] count) {\\n        if (level.size() == N)\\n            return end(count) ? findDiff(level) : findDiff(level) + dfs(new HashSet<>(), count);\\n        String key = Arrays.hashCode(count) + \" \" + level; //count is remaining element status, level is current hand bucket element\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int res = 1000;\\n        for (int i = 1; i <= 16; i++) {\\n            if (count[i] <= 0) continue; //no more this number left\\n            if (!level.add(i)) continue; //at hand same number already exist\\n            count[i]--;\\n            res = Math.min(res, dfs(level, count));\\n            count[i]++;\\n            level.remove(i);\\n            if (level.size() == 0) break;   // first element we don\\'t need to expand\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int findDiff(Set<Integer> level) {\\n        return Collections.max(level) - Collections.min(level);\\n    }\\n    \\n    private boolean end(int[] count) {\\n        for (int c : count) if (c != 0) return false;\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int N;\\n    Map<String, Integer> memo;\\n    int k;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        memo = new HashMap<>(); k = k;\\n        int[] count = new int[17];\\n        for (int num : nums) if (++count[num] > k) return -1;\\n        N = nums.length / k;\\n        return dfs(0, count);\\n    }\\n    \\n    private int dfs(int level, int[] count) {\\n        if (Integer.bitCount(level) == N) {\\n            if (end(count)) return findDiff(level);\\n            else return findDiff(level) + dfs(0, count);\\n        } \\n        String key = Arrays.hashCode(count) + \" \" + level;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        int res = 1000;\\n        for (int i = 1; i <= 16; i++) {\\n            if (count[i] <= 0) continue;\\n            int mask = 1 << i;\\n            if ((level & mask) != 0) continue;\\n            level |= mask;\\n            count[i]--;\\n            res = Math.min(res, dfs(level, count));\\n            count[i]++;\\n            level ^= mask;\\n            if (Integer.bitCount(level) == 0) break;  // first element we don\\'t need to expand\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    \\n    private int findDiff(int level) {\\n        int max = 0, min = 16;\\n        for (int i = 1; i <= 16; i++) {\\n            int mask = 1 << i;\\n            if ((level & mask) == 0) continue;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        return max - min;\\n    }\\n    \\n    private boolean end(int[] count) {\\n        for (int c : count) if (c != 0) return false;\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961409,
                "title": "python-classic-top-down-bitmask-dp",
                "content": "There are a number of good bitmask DP explanations on Leetcode, but here, we just make some small adjustments. \\nTime: O(n*2^n)\\nSpace: O(n)\\n\\n```\\nfrom itertools import combinations \\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        groupSize = len(nums) // k\\n        @lru_cache(None)\\n        def helper(bitmask): # return minimal sum of incompatibilities achievable with unselected indices.\\n            if bitmask == 0:\\n                return 0\\n            else:\\n                optimal = float(\\'inf\\')\\n                remaining = [i for i in range(len(nums)) if bitmask & (1 << i)]\\n                comb = combinations(remaining,groupSize) \\n                for combo in list(comb): \\n                    comboElems = [nums[-elem-1] for elem in combo]\\n                    if len(set(comboElems)) != groupSize:\\n                        continue\\n                    else:\\n                        newBitmask = bitmask\\n                        for idx in combo:\\n                            newBitmask ^= 1 << idx\\n                        incompat = max(comboElems)-min(comboElems)\\n                        optimal = min(optimal,incompat+helper(newBitmask))\\n                    \\n                return optimal\\n            \\n        result = helper(2**len(nums)-1)\\n        if result == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations \\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        groupSize = len(nums) // k\\n        @lru_cache(None)\\n        def helper(bitmask): # return minimal sum of incompatibilities achievable with unselected indices.\\n            if bitmask == 0:\\n                return 0\\n            else:\\n                optimal = float(\\'inf\\')\\n                remaining = [i for i in range(len(nums)) if bitmask & (1 << i)]\\n                comb = combinations(remaining,groupSize) \\n                for combo in list(comb): \\n                    comboElems = [nums[-elem-1] for elem in combo]\\n                    if len(set(comboElems)) != groupSize:\\n                        continue\\n                    else:\\n                        newBitmask = bitmask\\n                        for idx in combo:\\n                            newBitmask ^= 1 << idx\\n                        incompat = max(comboElems)-min(comboElems)\\n                        optimal = min(optimal,incompat+helper(newBitmask))\\n                    \\n                return optimal\\n            \\n        result = helper(2**len(nums)-1)\\n        if result == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961654,
                "title": "python-simple-backtracking-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/da932706-954a-4246-821e-95c9c8078733_1607233824.1326246.png)\\n```python\\nclass Solution(object):\\n    def minimumIncompatibility(self, nums, k):\\n        nums.sort(reverse = True)\\n        upperbound = len(nums) // k\\n        arr = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, sum(arr[i][0]-arr[i][-1] for i in range(k)))\\n                return True\\n            flag = 0\\n            for j in range(k):\\n                if not arr[j] or (len(arr[j]) < upperbound and arr[j][-1] != nums[i]):\\n                    arr[j].append(nums[i])\\n                    if assign(i+1):\\n                        flag += 1\\n                    arr[j].pop()\\n                if flag >= 2: break\\n            return flag != 0\\n        if max(collections.Counter(nums).values()) > k: return -1\\n        assign(0)\\n        return self.res\\n```\\n\\nBacktracking is a very time consuming algorithm. If we don\\'t have early break, its time complexity will be O(n!) (for example Hamiltonian and NQueens problems). So we usually need to have an early break condition, which is a tricky part.\\n\\nIn this case, I implemented backtracking with two attemps (nums[i] can be assigned to arr[j] and arr[j+1]). A simple and fast solution.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution(object):\\n    def minimumIncompatibility(self, nums, k):\\n        nums.sort(reverse = True)\\n        upperbound = len(nums) // k\\n        arr = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, sum(arr[i][0]-arr[i][-1] for i in range(k)))\\n                return True\\n            flag = 0\\n            for j in range(k):\\n                if not arr[j] or (len(arr[j]) < upperbound and arr[j][-1] != nums[i]):\\n                    arr[j].append(nums[i])\\n                    if assign(i+1):\\n                        flag += 1\\n                    arr[j].pop()\\n                if flag >= 2: break\\n            return flag != 0\\n        if max(collections.Counter(nums).values()) > k: return -1\\n        assign(0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961608,
                "title": "c-memorization-tle-to-ac-during-contest",
                "content": "Below is the code for which I got TLE\\n```\\nclass Solution {\\npublic:\\n    int n ,G, INF = 1<<29, K; // G is sizeof subset needed\\n    vector<int>nums;\\n    vector<int>freq;\\n    int dfs(int idx, int g, int mask, int mini, int maxi) {\\n        if (idx >= K) return 0;\\n        if (g == G) {\\n            return dfs(idx+1, 0, 0, n + 1, 0) + maxi - mini;\\n        }\\n        \\n        int ret = INF;\\n        for (int i = 1; i <=n ;i++) if (freq[i] > 0 && (mask&(1<<i)) == 0) {\\n            freq[i]--;\\n            ret = min(ret, dfs(idx, g + 1, mask |(1<<i), min(mini, i), max(maxi, i)));\\n            freq[i]++;\\n        }\\n        return ret;\\n        \\n    }\\n    int minimumIncompatibility(vector<int>& N, int k) {\\n        n = N.size(), K= k;\\n        nums = N;\\n        G = n/k;\\n        freq.resize(n + 1, 0);\\n        for (int num : N) freq[num]++;\\n        int ans = dfs(0, 0, 0, n + 1, 0);\\n        return ans >= INF ? -1: ans;\\n    }\\n};\\n```\\nAfter TLE  I realised we can precompute the valid mask and can run the dfs on same. Below is the solution for same\\n```\\nclass Solution {\\npublic:\\n    int n, K, INF = 1<<29;\\n    vector<int>nums;\\n    vector<pair<int, int>>validMask;\\n    int memo[17][(1<<16) + 10];\\n    bool isValid(int mask) {\\n        unordered_map<int, bool> seen;\\n        for (int i =0 ; i < n; i++) {\\n            if (mask&(1<<i) ) {\\n                if (seen.count(nums[i])) return false;\\n                seen[nums[i]] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(int idx, int mask) {\\n        if (idx == K) return 0;\\n        if (memo[idx][mask] != -1) return memo[idx][mask];\\n        int ret = INF;\\n        for (auto m : validMask) if ((m.first&mask) == 0){\\n            ret = min(ret, solve(idx + 1, mask|m.first) + m.second);\\n        }\\n        return memo[idx][mask] = ret;\\n    }\\n    int getMin(int mask) {\\n        int mini = n + 1;\\n        for (int i =0 ; i < n; i++) if (mask&(1<<i) ) mini = min(mini, nums[i]);\\n        return mini;\\n    }\\n    int getMax(int mask) {\\n        int maxi = 0;\\n        for (int i =0 ; i < n; i++) if (mask&(1<<i) ) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n    int minimumIncompatibility(vector<int>& N, int k) {\\n        nums = N, K = k;\\n        n = nums.size();\\n        int G = n /k;\\n        for (int i = 0; i < (1<<n); i++) {\\n            int c =0;\\n            for (int j =0 ; j < n; j++) if (i&(1<<j)) c++;\\n            if (c == G && isValid(i)) validMask.push_back({i, getMax(i)- getMin(i)});\\n        }\\n        int m = validMask.size();\\n        memset(memo, -1, sizeof(memo));\\n        int ans = solve(0, 0);\\n        return ans >= INF ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ,G, INF = 1<<29, K; // G is sizeof subset needed\\n    vector<int>nums;\\n    vector<int>freq;\\n    int dfs(int idx, int g, int mask, int mini, int maxi) {\\n        if (idx >= K) return 0;\\n        if (g == G) {\\n            return dfs(idx+1, 0, 0, n + 1, 0) + maxi - mini;\\n        }\\n        \\n        int ret = INF;\\n        for (int i = 1; i <=n ;i++) if (freq[i] > 0 && (mask&(1<<i)) == 0) {\\n            freq[i]--;\\n            ret = min(ret, dfs(idx, g + 1, mask |(1<<i), min(mini, i), max(maxi, i)));\\n            freq[i]++;\\n        }\\n        return ret;\\n        \\n    }\\n    int minimumIncompatibility(vector<int>& N, int k) {\\n        n = N.size(), K= k;\\n        nums = N;\\n        G = n/k;\\n        freq.resize(n + 1, 0);\\n        for (int num : N) freq[num]++;\\n        int ans = dfs(0, 0, 0, n + 1, 0);\\n        return ans >= INF ? -1: ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n, K, INF = 1<<29;\\n    vector<int>nums;\\n    vector<pair<int, int>>validMask;\\n    int memo[17][(1<<16) + 10];\\n    bool isValid(int mask) {\\n        unordered_map<int, bool> seen;\\n        for (int i =0 ; i < n; i++) {\\n            if (mask&(1<<i) ) {\\n                if (seen.count(nums[i])) return false;\\n                seen[nums[i]] = true;\\n            }\\n        }\\n        return true;\\n    }\\n    int solve(int idx, int mask) {\\n        if (idx == K) return 0;\\n        if (memo[idx][mask] != -1) return memo[idx][mask];\\n        int ret = INF;\\n        for (auto m : validMask) if ((m.first&mask) == 0){\\n            ret = min(ret, solve(idx + 1, mask|m.first) + m.second);\\n        }\\n        return memo[idx][mask] = ret;\\n    }\\n    int getMin(int mask) {\\n        int mini = n + 1;\\n        for (int i =0 ; i < n; i++) if (mask&(1<<i) ) mini = min(mini, nums[i]);\\n        return mini;\\n    }\\n    int getMax(int mask) {\\n        int maxi = 0;\\n        for (int i =0 ; i < n; i++) if (mask&(1<<i) ) maxi = max(maxi, nums[i]);\\n        return maxi;\\n    }\\n    int minimumIncompatibility(vector<int>& N, int k) {\\n        nums = N, K = k;\\n        n = nums.size();\\n        int G = n /k;\\n        for (int i = 0; i < (1<<n); i++) {\\n            int c =0;\\n            for (int j =0 ; j < n; j++) if (i&(1<<j)) c++;\\n            if (c == G && isValid(i)) validMask.push_back({i, getMax(i)- getMin(i)});\\n        }\\n        int m = validMask.size();\\n        memset(memo, -1, sizeof(memo));\\n        int ans = solve(0, 0);\\n        return ans >= INF ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961535,
                "title": "java-bottom-up-bit-mask-dp-o-n-3-n",
                "content": "```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[1<<n];\\n        int bucketSize = n/k;\\n        for(int i=1; i<(1<<n); i++){\\n            int count = Integer.bitCount(i);\\n            if(count==bucketSize){\\n                int max = 0;\\n                int min = Integer.MAX_VALUE;\\n                int[] freq = new int[n+1];\\n                for(int j=0; j<n; j++){\\n                    boolean isSet = (i & (1<<j))>0;\\n                    if(isSet){\\n                        if(++freq[nums[j]]>1){\\n                            dp[i] = -1;\\n                            break;\\n                        }\\n                        else{\\n                            min = Math.min(min, nums[j]);\\n                            max = Math.max(max, nums[j]);\\n                        }\\n                    }\\n                }\\n                if(dp[i]!=-1){\\n                    dp[i] = max-min;\\n                }\\n            }\\n            else if(count%bucketSize==0){\\n                dp[i] = Integer.MAX_VALUE;\\n                for(int cur = i; cur>0; cur=(cur-1)&i){\\n                    if(Integer.bitCount(cur)==bucketSize){\\n                        int comp = i ^ cur;\\n                        if(dp[cur]==-1 || dp[comp]==-1){\\n                            continue;\\n                        }\\n                        dp[i] = Math.min(dp[i], dp[cur]+dp[comp]);\\n                    }\\n                }\\n                if(dp[i] == Integer.MAX_VALUE){\\n                    dp[i] = -1;\\n                }\\n            }\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[1<<n];\\n        int bucketSize = n/k;\\n        for(int i=1; i<(1<<n); i++){\\n            int count = Integer.bitCount(i);\\n            if(count==bucketSize){\\n                int max = 0;\\n                int min = Integer.MAX_VALUE;\\n                int[] freq = new int[n+1];\\n                for(int j=0; j<n; j++){\\n                    boolean isSet = (i & (1<<j))>0;\\n                    if(isSet){\\n                        if(++freq[nums[j]]>1){\\n                            dp[i] = -1;\\n                            break;\\n                        }\\n                        else{\\n                            min = Math.min(min, nums[j]);\\n                            max = Math.max(max, nums[j]);\\n                        }\\n                    }\\n                }\\n                if(dp[i]!=-1){\\n                    dp[i] = max-min;\\n                }\\n            }\\n            else if(count%bucketSize==0){\\n                dp[i] = Integer.MAX_VALUE;\\n                for(int cur = i; cur>0; cur=(cur-1)&i){\\n                    if(Integer.bitCount(cur)==bucketSize){\\n                        int comp = i ^ cur;\\n                        if(dp[cur]==-1 || dp[comp]==-1){\\n                            continue;\\n                        }\\n                        dp[i] = Math.min(dp[i], dp[cur]+dp[comp]);\\n                    }\\n                }\\n                if(dp[i] == Integer.MAX_VALUE){\\n                    dp[i] = -1;\\n                }\\n            }\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 993175,
                "title": "c-short-and-clean-code-with-explanation-easy-to-understand-beat-100",
                "content": "The key point is, when we build a new group, we always pick the smallest available number.\\n\\n```\\npublic class Solution\\n{\\n    private int min = int.MaxValue;\\n    public int MinimumIncompatibility(int[] nums, int k)\\n    {\\n        Array.Sort(nums);\\n        DFS(nums, nums.Length / k, 0, 0, 1, 0, 1);\\n        return min == int.MaxValue ? -1 : min;\\n    }\\n\\n    private void DFS(int[] nums, int groupSize, int start, int end, int curSize, int sum, int used)\\n    {\\n        if (curSize == groupSize) // Current group is full, try to build next group\\n        {\\n            sum += nums[end] - nums[start]; //Calculate new sum. nums are sorted, so end is max and start is min\\n            if (sum >= min) return; //No need to continue\\n            for (int newStart = start + 1; newStart < nums.Length; newStart++) //Find new start index for next group\\n            {\\n                int bit = 1 << newStart;\\n                if ((used & bit) == bit) continue;\\n                DFS(nums, groupSize, newStart, newStart, 1, sum, used | bit);\\n                return; //Important! Always pick the smallest available number, no need to continue the loop.\\n            }\\n            min = sum; //Can\\'t find new start, meaning all numbers are used already, set min.\\n        }\\n        else // Current group is not full\\n        {\\n            for (int newEnd = end + 1; newEnd < nums.Length; newEnd++) //Try to add more bigger number to the group\\n            {\\n                int bit = 1 << newEnd;\\n                if ((used & bit) == bit || nums[newEnd] == nums[end]) continue;\\n                DFS(nums, groupSize, start, newEnd, curSize + 1, sum, used | bit);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private int min = int.MaxValue;\\n    public int MinimumIncompatibility(int[] nums, int k)\\n    {\\n        Array.Sort(nums);\\n        DFS(nums, nums.Length / k, 0, 0, 1, 0, 1);\\n        return min == int.MaxValue ? -1 : min;\\n    }\\n\\n    private void DFS(int[] nums, int groupSize, int start, int end, int curSize, int sum, int used)\\n    {\\n        if (curSize == groupSize) // Current group is full, try to build next group\\n        {\\n            sum += nums[end] - nums[start]; //Calculate new sum. nums are sorted, so end is max and start is min\\n            if (sum >= min) return; //No need to continue\\n            for (int newStart = start + 1; newStart < nums.Length; newStart++) //Find new start index for next group\\n            {\\n                int bit = 1 << newStart;\\n                if ((used & bit) == bit) continue;\\n                DFS(nums, groupSize, newStart, newStart, 1, sum, used | bit);\\n                return; //Important! Always pick the smallest available number, no need to continue the loop.\\n            }\\n            min = sum; //Can\\'t find new start, meaning all numbers are used already, set min.\\n        }\\n        else // Current group is not full\\n        {\\n            for (int newEnd = end + 1; newEnd < nums.Length; newEnd++) //Try to add more bigger number to the group\\n            {\\n                int bit = 1 << newEnd;\\n                if ((used & bit) == bit || nums[newEnd] == nums[end]) continue;\\n                DFS(nums, groupSize, start, newEnd, curSize + 1, sum, used | bit);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965262,
                "title": "python3-backtracking",
                "content": "**Algo**\\nThis is an organized brute force approach. We simply put the elements following the rule into stacks and compute incompatibility. Here, the two tricks are \\n1) `if cand + len(nums) - i > ans: return` meaning that if there is no chance for the current run to get smaller incompability we simply return;\\n2) `len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii])` meaning current stack has enough space for an extra element, `nums[i]` hasn\\'t been added to this stack yet, and it is different from the previous stack (otherwise what\\'s the point of adding it to an identical stack). \\n\\nWithout these two tricks, one would have TLE. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        def fn(i, cand): \\n            \"\"\"Populate stack and compute minimum incompatibility.\"\"\"\\n            nonlocal ans \\n            if cand + len(nums) - i - sum(not x for x in stack) > ans: return \\n            if i == len(nums): ans = cand\\n            else: \\n                for ii in range(k): \\n                    if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): \\n                        stack[ii].append(nums[i])\\n                        if len(stack[ii]) == 1: fn(i+1, cand)\\n                        else: fn(i+1, cand + stack[ii][-1] - stack[ii][-2])\\n                        stack[ii].pop()\\n        \\n        ans = inf\\n        stack = [[] for _ in range(k)]\\n        fn(0, 0)\\n        return ans if ans < inf else -1\\n```\\n\\nFor those who are uncomfortable with `nonlocal` variables, an alternative implementation is given below \\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        def fn(i, cand=0, ans=inf):\\n            \"\"\"Return minimum incompatibility via backtracking.\"\"\"\\n            if cand + len(nums) - i - sum(not x for x in stack) >= ans: return ans # early return \\n            if i == len(nums): return cand\\n            for ii in range(k): \\n                if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): \\n                    stack[ii].append(nums[i])\\n                    if len(stack[ii]) == 1: ans = fn(i+1, cand, ans)\\n                    else: ans = fn(i+1, cand + stack[ii][-1] - stack[ii][-2], ans)\\n                    stack[ii].pop()\\n            return ans \\n        \\n        stack = [[] for _ in range(k)]\\n        ans = fn(0)\\n        return ans if ans < inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        def fn(i, cand): \\n            \"\"\"Populate stack and compute minimum incompatibility.\"\"\"\\n            nonlocal ans \\n            if cand + len(nums) - i - sum(not x for x in stack) > ans: return \\n            if i == len(nums): ans = cand\\n            else: \\n                for ii in range(k): \\n                    if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): \\n                        stack[ii].append(nums[i])\\n                        if len(stack[ii]) == 1: fn(i+1, cand)\\n                        else: fn(i+1, cand + stack[ii][-1] - stack[ii][-2])\\n                        stack[ii].pop()\\n        \\n        ans = inf\\n        stack = [[] for _ in range(k)]\\n        fn(0, 0)\\n        return ans if ans < inf else -1\\n```\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        def fn(i, cand=0, ans=inf):\\n            \"\"\"Return minimum incompatibility via backtracking.\"\"\"\\n            if cand + len(nums) - i - sum(not x for x in stack) >= ans: return ans # early return \\n            if i == len(nums): return cand\\n            for ii in range(k): \\n                if len(stack[ii]) < len(nums)//k and (not stack[ii] or stack[ii][-1] != nums[i]) and (not ii or stack[ii-1] != stack[ii]): \\n                    stack[ii].append(nums[i])\\n                    if len(stack[ii]) == 1: ans = fn(i+1, cand, ans)\\n                    else: ans = fn(i+1, cand + stack[ii][-1] - stack[ii][-2], ans)\\n                    stack[ii].pop()\\n            return ans \\n        \\n        stack = [[] for _ in range(k)]\\n        ans = fn(0)\\n        return ans if ans < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961731,
                "title": "golang-javascript-bitmask-dp-dfs",
                "content": "```go\\ntype indicesAndIndex struct {\\n    indices []int\\n    index int\\n}\\n\\nfunc minimumIncompatibility(nums []int, k int) int {\\n    // do some easy O(n) checks to see if we can return before the\\n    // major computation\\n    length := len(nums)\\n    \\n    // if there is only 1 number in each subset, we know the result is 0\\n    if length == k {\\n        return 0\\n    }\\n    \\n    // if the count of a value is more than the number of subsets\\n    // we know there will be repeating numbers in a subset so we return -1\\n    freqCount := make(map[int]int)\\n    for _, num := range nums {\\n        if count, ok := freqCount[num]; ok {\\n            if count == k {\\n                return -1\\n            } else {\\n                freqCount[num] = count + 1\\n            }\\n        } else {\\n            freqCount[num] = 1\\n        }\\n    }    \\n    \\n    // (aka memo, dp, /*python*/ @lru_cache)\\n    cache := make(map[int]int)\\n    numberOfElementsInBucket := length / k\\n    \\n    /* \\n    BITWISE\\n    to store the number of elements used, we use bitwise which has a 0 or 1 value\\n    1 - means index was used\\n    0 - means index was not used\\n    */    \\n    // create a mask to indicate all indexes in `nums` were used\\n    allIndicesUsedMask := (1 << length) - 1\\n    // create a mask to indicate no indexes in `nums` were used\\n    currentUsedIndicesMask := 0\\n    \\n    return dfs(currentUsedIndicesMask, allIndicesUsedMask, numberOfElementsInBucket, &nums, &cache)\\n}\\n\\nfunc dfs(currentUsedIndicesMask, allIndicesUsedMask, numberOfElementsInBucket int, nums *[]int, cache *map[int]int) int {\\n    // if we used all the values in nums, return 0\\n    if currentUsedIndicesMask == allIndicesUsedMask {\\n        return 0\\n    }\\n    \\n    // if the indicies used and unused is the same as a previous\\n    // DFS call, return the previous call because\\n    // we know we already have calculated the minimum incompatibility cost\\n    if val, ok := (*cache)[currentUsedIndicesMask]; ok {\\n        return val\\n    }\\n    \\n    // we add all indices to a slice for indicies that have not been used yet\\n    // and \\'values\\' have not been used/seen (we only want unique values)\\n    // *note: we don\\'t care which index of a value we get just as long as no 2 indices have the same value\\n    valsToIndices := make(map[int]bool)\\n    indices := make([]int, 0)\\n    for idx, val := range *nums {\\n        // if we already used the indices, skip this index\\n        if (currentUsedIndicesMask & (1 << idx)) != 0 {\\n            continue\\n        }\\n        // if we have not seen this value before, add it to the indices slice\\n        if _, ok := valsToIndices[val]; !ok {\\n            valsToIndices[val] = true\\n            indices = append(indices, idx)\\n        }\\n    }\\n\\n    // create all different combinations of indices\\n    // *note: this is different from \"permutations\"\\n    combinations := createCombinations(&indices, numberOfElementsInBucket)\\n    \\n    // create a variable to store the minimum incompatibility cose\\n    // 99999 is just a place holder, you can replace this with MAX_INT\\n    minIncompatibilityCost := 99999\\n    \\n    /*\\n    for every combination\\n    - create a new mask by adding a 1 to every position of index\\n    - caculate the incompatibility cost by finding the max and min value\\n    - then call DFS again while adding the incompatibility cost to the returned value\\n    - compare the minimum of all the different costs\\n    */\\n    for i, _ := range combinations {\\n        indices := combinations[i]\\n        nextUsedIndicesMask := currentUsedIndicesMask\\n        minVal, maxVal := 9999, -9999 // values are from 0-16\\n        for _, index := range indices {\\n            val := (*nums)[index]\\n            minVal = minInt(minVal, val)\\n            maxVal = maxInt(maxVal, val)\\n            nextUsedIndicesMask = nextUsedIndicesMask | (1 << index)\\n        }\\n        incompatibilityCost := maxVal - minVal\\n        minIncompatibilityCost = minInt(minIncompatibilityCost,\\n                                        dfs(nextUsedIndicesMask, \\n                                            allIndicesUsedMask, \\n                                            numberOfElementsInBucket, \\n                                            nums, \\n                                            cache) + incompatibilityCost)\\n    }\\n    \\n    // store the cost into the cache so we don\\'t need to compute this\\n    // state again\\n    (*cache)[currentUsedIndicesMask] = minIncompatibilityCost\\n    \\n    // return the cost\\n    return minIncompatibilityCost\\n}\\n\\nfunc createCombinations(indices *[]int, combinationLen int) [][]int {\\n    n := len(*indices)\\n    combinations := make([][]int, 0)\\n    if n < combinationLen {\\n        return combinations\\n    }\\n    stack := []indicesAndIndex { { indices: []int{}, index: 0 } }\\n    m := 1\\n    for ; m > 0; m = len(stack) {\\n        idxsAndidx := stack[m - 1]\\n        stack = stack[:m - 1]\\n        idxs, i := idxsAndidx.indices, idxsAndidx.index\\n        o := len(idxs)\\n        for ; i < n; i++ {\\n            combination := make([]int, o, o + 1)\\n            copy(combination, idxs)\\n            combination = append(combination, (*indices)[i])\\n            if combinationLen == len(combination) {\\n                combinations = append(combinations, combination)\\n            } else {\\n                stack = append(stack, indicesAndIndex{ indices: combination, index: i + 1 })\\n            }\\n        }\\n    }\\n    return combinations\\n}\\n\\nfunc minInt(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxInt(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}\\n```\\n\\n```javascript\\n////////////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////////////\\n\\n\\nvar minimumIncompatibility = function(nums, k) {\\n\\t////// FROM HERE TO\\n    if (nums.length === k) return 0;\\n    \\n    const maxInBucket = nums.length / k;\\n    const freqCount = {};\\n    for (const n of nums) {\\n        if (freqCount[n]) {\\n            if (freqCount[n] === k) {\\n                return -1\\n            } else {\\n                freqCount[n]++\\n            }\\n        } else {\\n            freqCount[n] = 1\\n        }\\n    }\\n\\t/////// HERE is just saving time\\n    \\n\\t// create a cache (aka memo, dp, dynamic programming, momoization)\\n    const cache = {}\\n\\t// create a mask to know when all the indicies are used\\n    const allIndiciesUsedMask = 2 ** nums.length - 1;\\n    \\n    const dfs = (usedIndicesBitMask) => {\\n\\t    // if we have used all the indicies then we return 0\\n        if (usedIndicesBitMask === allIndiciesUsedMask) {\\n            return 0;\\n        }\\n\\t\\t// if we have seen this combination before, return the\\n\\t\\t// result that was calculated before\\n\\t\\t// otherwise do the hard work LOL\\n        if (cache[usedIndicesBitMask]) {\\n            return cache[usedIndicesBitMask];\\n        }\\n        \\n\\t\\t// find all the indicies that are available to be used\\n\\t\\t// skip duplicate values\\n        const valsToIndices = {};\\n        for (let i = 0; i < nums.length; i++) {\\n            const indexMask = 1 << i;\\n            if (usedIndicesBitMask & indexMask) continue;\\n            const value = nums[i];\\n            if (!valsToIndices.hasOwnProperty(value)) {\\n                valsToIndices[value] = i;\\n            }\\n        }\\n        const indicesAvailable = Object.values(valsToIndices);\\n\\n        // this is hard to explain but it\\'s basically calculating the minimum\\n\\t\\t// cost while marking the indicies that are going to be used for each\\n\\t\\t// combination\\n        let minIncompatibilityCost = Infinity;\\n        const combinations = createCombinations(indicesAvailable, maxInBucket);\\n        for (const indices of combinations) {\\n            let nextMask = usedIndicesBitMask;\\n            let minVal = Infinity;\\n            let maxVal = -Infinity;\\n            for (const index of indices) {\\n                minVal = Math.min(minVal, nums[index]);\\n                maxVal = Math.max(maxVal, nums[index]);\\n                nextMask = nextMask | (1 << index);\\n            }\\n            const incompatibilityCost = maxVal - minVal;\\n            minIncompatibilityCost = \\n                Math.min(minIncompatibilityCost, dfs(nextMask) + incompatibilityCost);\\n        }\\n        return cache[usedIndicesBitMask] = minIncompatibilityCost;\\n    }\\n    return dfs(0);\\n};\\n\\nfunction createCombinations(indices, len) {\\n    const combinations = [];\\n    \\n    if (indices.length < len) {\\n        return combinations;\\n    }\\n    \\n    const stack = [[[], 0]];\\n    while (stack.length > 0) {\\n        let [combi, i] = stack.pop();\\n        for (; i < indices.length; i++) {\\n            const combination = [...combi, indices[i]];\\n            if (combination.length === len) {\\n                combinations.push(combination);\\n            } else {\\n                stack.push([combination, i + 1]);\\n            }\\n        }\\n    }\\n    \\n    return combinations;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```go\\ntype indicesAndIndex struct {\\n    indices []int\\n    index int\\n}\\n\\nfunc minimumIncompatibility(nums []int, k int) int {\\n    // do some easy O(n) checks to see if we can return before the\\n    // major computation\\n    length := len(nums)\\n    \\n    // if there is only 1 number in each subset, we know the result is 0\\n    if length == k {\\n        return 0\\n    }\\n    \\n    // if the count of a value is more than the number of subsets\\n    // we know there will be repeating numbers in a subset so we return -1\\n    freqCount := make(map[int]int)\\n    for _, num := range nums {\\n        if count, ok := freqCount[num]; ok {\\n            if count == k {\\n                return -1\\n            } else {\\n                freqCount[num] = count + 1\\n            }\\n        } else {\\n            freqCount[num] = 1\\n        }\\n    }    \\n    \\n    // (aka memo, dp, /*python*/ @lru_cache)\\n    cache := make(map[int]int)\\n    numberOfElementsInBucket := length / k\\n    \\n    /* \\n    BITWISE\\n    to store the number of elements used, we use bitwise which has a 0 or 1 value\\n    1 - means index was used\\n    0 - means index was not used\\n    */    \\n    // create a mask to indicate all indexes in `nums` were used\\n    allIndicesUsedMask := (1 << length) - 1\\n    // create a mask to indicate no indexes in `nums` were used\\n    currentUsedIndicesMask := 0\\n    \\n    return dfs(currentUsedIndicesMask, allIndicesUsedMask, numberOfElementsInBucket, &nums, &cache)\\n}\\n\\nfunc dfs(currentUsedIndicesMask, allIndicesUsedMask, numberOfElementsInBucket int, nums *[]int, cache *map[int]int) int {\\n    // if we used all the values in nums, return 0\\n    if currentUsedIndicesMask == allIndicesUsedMask {\\n        return 0\\n    }\\n    \\n    // if the indicies used and unused is the same as a previous\\n    // DFS call, return the previous call because\\n    // we know we already have calculated the minimum incompatibility cost\\n    if val, ok := (*cache)[currentUsedIndicesMask]; ok {\\n        return val\\n    }\\n    \\n    // we add all indices to a slice for indicies that have not been used yet\\n    // and \\'values\\' have not been used/seen (we only want unique values)\\n    // *note: we don\\'t care which index of a value we get just as long as no 2 indices have the same value\\n    valsToIndices := make(map[int]bool)\\n    indices := make([]int, 0)\\n    for idx, val := range *nums {\\n        // if we already used the indices, skip this index\\n        if (currentUsedIndicesMask & (1 << idx)) != 0 {\\n            continue\\n        }\\n        // if we have not seen this value before, add it to the indices slice\\n        if _, ok := valsToIndices[val]; !ok {\\n            valsToIndices[val] = true\\n            indices = append(indices, idx)\\n        }\\n    }\\n\\n    // create all different combinations of indices\\n    // *note: this is different from \"permutations\"\\n    combinations := createCombinations(&indices, numberOfElementsInBucket)\\n    \\n    // create a variable to store the minimum incompatibility cose\\n    // 99999 is just a place holder, you can replace this with MAX_INT\\n    minIncompatibilityCost := 99999\\n    \\n    /*\\n    for every combination\\n    - create a new mask by adding a 1 to every position of index\\n    - caculate the incompatibility cost by finding the max and min value\\n    - then call DFS again while adding the incompatibility cost to the returned value\\n    - compare the minimum of all the different costs\\n    */\\n    for i, _ := range combinations {\\n        indices := combinations[i]\\n        nextUsedIndicesMask := currentUsedIndicesMask\\n        minVal, maxVal := 9999, -9999 // values are from 0-16\\n        for _, index := range indices {\\n            val := (*nums)[index]\\n            minVal = minInt(minVal, val)\\n            maxVal = maxInt(maxVal, val)\\n            nextUsedIndicesMask = nextUsedIndicesMask | (1 << index)\\n        }\\n        incompatibilityCost := maxVal - minVal\\n        minIncompatibilityCost = minInt(minIncompatibilityCost,\\n                                        dfs(nextUsedIndicesMask, \\n                                            allIndicesUsedMask, \\n                                            numberOfElementsInBucket, \\n                                            nums, \\n                                            cache) + incompatibilityCost)\\n    }\\n    \\n    // store the cost into the cache so we don\\'t need to compute this\\n    // state again\\n    (*cache)[currentUsedIndicesMask] = minIncompatibilityCost\\n    \\n    // return the cost\\n    return minIncompatibilityCost\\n}\\n\\nfunc createCombinations(indices *[]int, combinationLen int) [][]int {\\n    n := len(*indices)\\n    combinations := make([][]int, 0)\\n    if n < combinationLen {\\n        return combinations\\n    }\\n    stack := []indicesAndIndex { { indices: []int{}, index: 0 } }\\n    m := 1\\n    for ; m > 0; m = len(stack) {\\n        idxsAndidx := stack[m - 1]\\n        stack = stack[:m - 1]\\n        idxs, i := idxsAndidx.indices, idxsAndidx.index\\n        o := len(idxs)\\n        for ; i < n; i++ {\\n            combination := make([]int, o, o + 1)\\n            copy(combination, idxs)\\n            combination = append(combination, (*indices)[i])\\n            if combinationLen == len(combination) {\\n                combinations = append(combinations, combination)\\n            } else {\\n                stack = append(stack, indicesAndIndex{ indices: combination, index: i + 1 })\\n            }\\n        }\\n    }\\n    return combinations\\n}\\n\\nfunc minInt(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc maxInt(a, b int) int {\\n    if a < b {\\n        return b\\n    }\\n    return a\\n}\\n```\n```javascript\\n////////////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////////////\\n////////////////////////////////////////////////////////////////////////////////////////////\\n\\n\\nvar minimumIncompatibility = function(nums, k) {\\n\\t////// FROM HERE TO\\n    if (nums.length === k) return 0;\\n    \\n    const maxInBucket = nums.length / k;\\n    const freqCount = {};\\n    for (const n of nums) {\\n        if (freqCount[n]) {\\n            if (freqCount[n] === k) {\\n                return -1\\n            } else {\\n                freqCount[n]++\\n            }\\n        } else {\\n            freqCount[n] = 1\\n        }\\n    }\\n\\t/////// HERE is just saving time\\n    \\n\\t// create a cache (aka memo, dp, dynamic programming, momoization)\\n    const cache = {}\\n\\t// create a mask to know when all the indicies are used\\n    const allIndiciesUsedMask = 2 ** nums.length - 1;\\n    \\n    const dfs = (usedIndicesBitMask) => {\\n\\t    // if we have used all the indicies then we return 0\\n        if (usedIndicesBitMask === allIndiciesUsedMask) {\\n            return 0;\\n        }\\n\\t\\t// if we have seen this combination before, return the\\n\\t\\t// result that was calculated before\\n\\t\\t// otherwise do the hard work LOL\\n        if (cache[usedIndicesBitMask]) {\\n            return cache[usedIndicesBitMask];\\n        }\\n        \\n\\t\\t// find all the indicies that are available to be used\\n\\t\\t// skip duplicate values\\n        const valsToIndices = {};\\n        for (let i = 0; i < nums.length; i++) {\\n            const indexMask = 1 << i;\\n            if (usedIndicesBitMask & indexMask) continue;\\n            const value = nums[i];\\n            if (!valsToIndices.hasOwnProperty(value)) {\\n                valsToIndices[value] = i;\\n            }\\n        }\\n        const indicesAvailable = Object.values(valsToIndices);\\n\\n        // this is hard to explain but it\\'s basically calculating the minimum\\n\\t\\t// cost while marking the indicies that are going to be used for each\\n\\t\\t// combination\\n        let minIncompatibilityCost = Infinity;\\n        const combinations = createCombinations(indicesAvailable, maxInBucket);\\n        for (const indices of combinations) {\\n            let nextMask = usedIndicesBitMask;\\n            let minVal = Infinity;\\n            let maxVal = -Infinity;\\n            for (const index of indices) {\\n                minVal = Math.min(minVal, nums[index]);\\n                maxVal = Math.max(maxVal, nums[index]);\\n                nextMask = nextMask | (1 << index);\\n            }\\n            const incompatibilityCost = maxVal - minVal;\\n            minIncompatibilityCost = \\n                Math.min(minIncompatibilityCost, dfs(nextMask) + incompatibilityCost);\\n        }\\n        return cache[usedIndicesBitMask] = minIncompatibilityCost;\\n    }\\n    return dfs(0);\\n};\\n\\nfunction createCombinations(indices, len) {\\n    const combinations = [];\\n    \\n    if (indices.length < len) {\\n        return combinations;\\n    }\\n    \\n    const stack = [[[], 0]];\\n    while (stack.length > 0) {\\n        let [combi, i] = stack.pop();\\n        for (; i < indices.length; i++) {\\n            const combination = [...combi, indices[i]];\\n            if (combination.length === len) {\\n                combinations.push(combination);\\n            } else {\\n                stack.push([combination, i + 1]);\\n            }\\n        }\\n    }\\n    \\n    return combinations;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961483,
                "title": "java-dfs-memo-explain",
                "content": "Explanation:\\n1. Since the nums array is small, we can use bit to represent what element we can still select. For example, if bit=01101,it means we can sill select A[0],A[2],A[3]\\n2. For each subset, we want to select goal=n/k elements\\n3. For each select option that the current subset try to use, we only need to make sure that there is no repeat elements and we have those elements\\n4. state can be represented as dp(bit,k) [bit:what elements are remained, k:which subset ]\\n5. For optimization, since each subset choose n/k elements, we can only place those state with bitcount==n/k into the options we can use\\n\\n\\n```\\nclass Solution {\\n    int k;int n;int goal;\\n    int dp[][];\\n    List<Integer>bits=new ArrayList<>();\\n    public int minimumIncompatibility(int[] A, int k) {\\n        this.n=A.length;\\n        this.k=k;\\n        goal=n/k;\\n        \\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i:A){\\n            if(!map.containsKey(i))map.put(i,0);\\n            map.put(i,map.get(i)+1);\\n            if(map.get(i)>k)return -1;\\n        }\\n        \\n        \\n        int state=(1<<n)-1;\\n        for(int i=0;i<=state;i++){\\n            if(Integer.bitCount(i)==goal)bits.add(i);\\n        }\\n        \\n        dp=new int[1<<n][k];\\n        for(int i=0;i<dp.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        return dfs(A,state,0);\\n    }\\n    \\n    public int dfs(int A[],int state,int index){\\n        if(index>=k){\\n            return 0;\\n        }\\n        \\n        int res=1000;\\n        if(dp[state][index]!=-1)return dp[state][index];\\n        for(int bit:bits){\\n            if(Integer.bitCount(bit)==goal){\\n                int newstate=state;\\n                int mn=100,mx=-1;\\n                boolean visit[]=new boolean[n+1];\\n                boolean good=true;\\n                for(int j=0;j<n;j++){\\n                    if((bit&(1<<j))!=0){\\n                        if(visit[A[j]]==true||(state&(1<<j))==0){\\n                            good=false;\\n                            break;\\n                        }\\n                        visit[A[j]]=true;\\n                        newstate=newstate^(1<<j);\\n                        mx=Math.max(mx,A[j]);\\n                        mn=Math.min(mn,A[j]);\\n                    }\\n                }\\n                if(good)res=Math.min(res,mx-mn+dfs(A,newstate,index+1));\\n            }\\n            \\n        }\\n        dp[state][index]=res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k;int n;int goal;\\n    int dp[][];\\n    List<Integer>bits=new ArrayList<>();\\n    public int minimumIncompatibility(int[] A, int k) {\\n        this.n=A.length;\\n        this.k=k;\\n        goal=n/k;\\n        \\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(int i:A){\\n            if(!map.containsKey(i))map.put(i,0);\\n            map.put(i,map.get(i)+1);\\n            if(map.get(i)>k)return -1;\\n        }\\n        \\n        \\n        int state=(1<<n)-1;\\n        for(int i=0;i<=state;i++){\\n            if(Integer.bitCount(i)==goal)bits.add(i);\\n        }\\n        \\n        dp=new int[1<<n][k];\\n        for(int i=0;i<dp.length;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        return dfs(A,state,0);\\n    }\\n    \\n    public int dfs(int A[],int state,int index){\\n        if(index>=k){\\n            return 0;\\n        }\\n        \\n        int res=1000;\\n        if(dp[state][index]!=-1)return dp[state][index];\\n        for(int bit:bits){\\n            if(Integer.bitCount(bit)==goal){\\n                int newstate=state;\\n                int mn=100,mx=-1;\\n                boolean visit[]=new boolean[n+1];\\n                boolean good=true;\\n                for(int j=0;j<n;j++){\\n                    if((bit&(1<<j))!=0){\\n                        if(visit[A[j]]==true||(state&(1<<j))==0){\\n                            good=false;\\n                            break;\\n                        }\\n                        visit[A[j]]=true;\\n                        newstate=newstate^(1<<j);\\n                        mx=Math.max(mx,A[j]);\\n                        mn=Math.min(mn,A[j]);\\n                    }\\n                }\\n                if(good)res=Math.min(res,mx-mn+dfs(A,newstate,index+1));\\n            }\\n            \\n        }\\n        dp[state][index]=res;\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741884,
                "title": "easy-cpp-iterating-through-submasks-o-3-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& a, int k) {\\n        int n = (int) a.size();\\n        vector <int> cost(1 << n, 1e5);\\n        vector <int> dp(1 << n, 1e8);\\n        k = n / k;\\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n            if (__builtin_popcount(mask) != k) continue;\\n            set <int> now;\\n            for (int i = 0; i < n; ++i) {\\n                if ((mask >> i) & 1) now.insert(a[i]);\\n            }\\n            if ((int) now.size() != k) continue;\\n            cost[mask] = (*now.rbegin()) - (*now.begin());\\n            //dp[mask] = cost[mask];\\n        }\\n        dp[0] = 0;\\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n            int mask2 = ((1 << n) - 1) ^ mask;\\n            for (int sub = mask2; sub; sub = (sub - 1) & mask2) {\\n                if (__builtin_popcount(sub) != k) continue;\\n                dp[mask ^ sub] = min(dp[mask ^ sub], dp[mask] + cost[sub]);\\n            }\\n        }\\n        if (dp[(1 << n) - 1] > 1e4) return -1;\\n        return dp[(1 << n) - 1];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& a, int k) {\\n        int n = (int) a.size();\\n        vector <int> cost(1 << n, 1e5);\\n        vector <int> dp(1 << n, 1e8);\\n        k = n / k;\\n        for (int mask = 0; mask < (1 << n); ++mask) {\\n            if (__builtin_popcount(mask) != k) continue;\\n            set <int> now;\\n            for (int i = 0; i < n; ++i) {\\n                if ((mask >> i) & 1) now.insert(a[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 995956,
                "title": "java-o-k-n-solution-with-early-termination-9ms-98",
                "content": "This problem is asking us to do the reversal of  \"merging k sorted lists into one sorted list\".\\nIn other words, considering we are \"distributing a sorted list to k sorted lists\".\\nThe time complexity is O(k^n) since each number can have k choices.\\n\\n```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    void helper(int[] nums, int s, LinkedList<LinkedList<Integer>> buckets, int k, int size, int total) {\\n        if(total >= ans) return; //early termination\\n        if (s == nums.length) {\\n            ans = total; // With early termination, Math.min() is no longer needed.\\n        } else {\\n            // distribute current number to an existing bucket\\n            for (int i=0; i<buckets.size(); i++) {\\n                LinkedList<Integer> bucket = buckets.get(i);\\n                if (bucket.size() < size && bucket.peekLast() < nums[s]) {\\n                    int distance = nums[s] - bucket.peekLast();\\n                    bucket.addLast(nums[s]);\\n                    helper(nums, s+1, buckets, k, size, total+distance);\\n                    bucket.removeLast();\\n                }\\n            }\\n            // distribute current number to an empty bucket\\n            if (buckets.size() < k) {\\n                LinkedList<Integer> bucket = new LinkedList<>();\\n                bucket.add(nums[s]);\\n                buckets.addLast(bucket);\\n                helper(nums, s+1, buckets, k, size, total);\\n                buckets.removeLast();\\n            }\\n        }\\n    }\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        helper(nums, 0, new LinkedList<>(), k, nums.length/k, 0);\\n        return ans == Integer.MAX_VALUE?-1: ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = Integer.MAX_VALUE;\\n    void helper(int[] nums, int s, LinkedList<LinkedList<Integer>> buckets, int k, int size, int total) {\\n        if(total >= ans) return; //early termination\\n        if (s == nums.length) {\\n            ans = total; // With early termination, Math.min() is no longer needed.\\n        } else {\\n            // distribute current number to an existing bucket\\n            for (int i=0; i<buckets.size(); i++) {\\n                LinkedList<Integer> bucket = buckets.get(i);\\n                if (bucket.size() < size && bucket.peekLast() < nums[s]) {\\n                    int distance = nums[s] - bucket.peekLast();\\n                    bucket.addLast(nums[s]);\\n                    helper(nums, s+1, buckets, k, size, total+distance);\\n                    bucket.removeLast();\\n                }\\n            }\\n            // distribute current number to an empty bucket\\n            if (buckets.size() < k) {\\n                LinkedList<Integer> bucket = new LinkedList<>();\\n                bucket.add(nums[s]);\\n                buckets.addLast(bucket);\\n                helper(nums, s+1, buckets, k, size, total);\\n                buckets.removeLast();\\n            }\\n        }\\n    }\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        helper(nums, 0, new LinkedList<>(), k, nums.length/k, 0);\\n        return ans == Integer.MAX_VALUE?-1: ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963090,
                "title": "java-easy-to-understand-commented-dp",
                "content": "1. Initialize the mask to ```(1 << N) - 1``` to so that the mask will start as ```11...11```, the 1\\'s represent that the number at that index can still be used for a group.  \\n\\n2. For each valid mask generate all possible combinations of bits of size ```S=N/k``` (Creating combinations of size S is extremely important since then we don\\'t need to keep track of which numbers have already been used in the current group in our state) which we can then transform it into a mask representing the combination, e.g. if ```mask=111``` and ```S=2``` then we can have possible combinations: ```011, 101, 110```\\n\\n3. XOR the combination mask with the original mask to remove those elements from the next state and continue the recursion.\\n\\n4. Base case when ```mask==0``` since then every number has been used\\n\\n```Java\\nclass Solution {\\n    final int INF = (int)(1e5 + 7);\\n    int N, S;\\n    Integer[] dp;\\n    int[] vals;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        N = nums.length;\\n        S = N / k;\\n        dp = new Integer[1 << N];\\n        Arrays.sort(nums);\\n        vals = nums;\\n        \\n        int ans = recurse(nums, (1 << N) - 1);\\n        \\n        return ans == INF ? -1 : ans;\\n    }    \\n    \\n    private int recurse(int[] nums, int mask) {\\n        if (mask == 0) {\\n            return 0;\\n        }\\n        else if (dp[mask] != null) {\\n            return dp[mask];\\n        }\\n        \\n        int ans = INF;\\n        \\n        //Get the indices of all bits that are set, these represent the numbers in the array that we can still select.\\n        //Then generate all possible combinations of these indices\\n        List<Integer> indices = getAvailableIndices(mask);\\n        List<List<Integer>> combinations = new ArrayList<List<Integer>>();\\n        generateCombinations(combinations, indices, new ArrayList<Integer>(), 0);\\n        int numCombinations = combinations.size();\\n        \\n        for (int i = 0; i < numCombinations; i++) {\\n            List<Integer> currentCombination = combinations.get(i);\\n\\n            int removedMask = 0;\\n\\n            //OR all the bits that we will be removing\\n            for (int j = 0; j < S; j++) {\\n                removedMask |= 1 << currentCombination.get(j);\\n            }\\n\\n            //since array is sorted and the combinations traversing the array from left to right,\\n            //the smallestIndex corresponds to the smallest number and the same argument applies for the largest number.\\n            int smallestIndex = currentCombination.get(0);\\n            int largestIndex = currentCombination.get(S - 1);\\n\\n            int smallestNumber = nums[smallestIndex];\\n            int largestNumber = nums[largestIndex];\\n\\n            //Use XOR between mask and removedMask to turn off the bits that we used.\\n            ans = Math.min(ans, largestNumber - smallestNumber + recurse(nums, mask ^ removedMask));\\n        }\\n        \\n        return dp[mask] = ans;\\n    }\\n    \\n    private List<Integer> getAvailableIndices(int mask) {\\n        List<Integer> indices = new ArrayList<Integer>();\\n        \\n        //Check to see which bits are set, e.g. 101 => bits 2 and 0 are set.\\n        for (int i = 0; i < N; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                indices.add(i);             \\n            }\\n        }\\n        \\n        return indices;\\n    }\\n    \\n    private void generateCombinations(List<List<Integer>> combinations, List<Integer> indices, List<Integer> cur, int ind) {\\n        if (cur.size() == S) {\\n            combinations.add(cur);\\n            return;\\n        }\\n        else if (ind == indices.size()) {\\n            return;\\n        }\\n        \\n        //Add this index to the current combination\\n        List<Integer> copy = new ArrayList<Integer>(cur);\\n        copy.add(indices.get(ind));\\n        int newInd = ind + 1;\\n        \\n        //avoid duplicates\\n        while (newInd < indices.size() && vals[indices.get(newInd)] == vals[indices.get(ind)]) newInd++;\\n        generateCombinations(combinations, indices, copy, newInd);\\n        \\n        \\n        //skip this index\\n        copy = new ArrayList<Integer>(cur);\\n        generateCombinations(combinations, indices, copy, ind + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```(1 << N) - 1```\n```11...11```\n```S=N/k```\n```mask=111```\n```S=2```\n```011, 101, 110```\n```mask==0```\n```Java\\nclass Solution {\\n    final int INF = (int)(1e5 + 7);\\n    int N, S;\\n    Integer[] dp;\\n    int[] vals;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        N = nums.length;\\n        S = N / k;\\n        dp = new Integer[1 << N];\\n        Arrays.sort(nums);\\n        vals = nums;\\n        \\n        int ans = recurse(nums, (1 << N) - 1);\\n        \\n        return ans == INF ? -1 : ans;\\n    }    \\n    \\n    private int recurse(int[] nums, int mask) {\\n        if (mask == 0) {\\n            return 0;\\n        }\\n        else if (dp[mask] != null) {\\n            return dp[mask];\\n        }\\n        \\n        int ans = INF;\\n        \\n        //Get the indices of all bits that are set, these represent the numbers in the array that we can still select.\\n        //Then generate all possible combinations of these indices\\n        List<Integer> indices = getAvailableIndices(mask);\\n        List<List<Integer>> combinations = new ArrayList<List<Integer>>();\\n        generateCombinations(combinations, indices, new ArrayList<Integer>(), 0);\\n        int numCombinations = combinations.size();\\n        \\n        for (int i = 0; i < numCombinations; i++) {\\n            List<Integer> currentCombination = combinations.get(i);\\n\\n            int removedMask = 0;\\n\\n            //OR all the bits that we will be removing\\n            for (int j = 0; j < S; j++) {\\n                removedMask |= 1 << currentCombination.get(j);\\n            }\\n\\n            //since array is sorted and the combinations traversing the array from left to right,\\n            //the smallestIndex corresponds to the smallest number and the same argument applies for the largest number.\\n            int smallestIndex = currentCombination.get(0);\\n            int largestIndex = currentCombination.get(S - 1);\\n\\n            int smallestNumber = nums[smallestIndex];\\n            int largestNumber = nums[largestIndex];\\n\\n            //Use XOR between mask and removedMask to turn off the bits that we used.\\n            ans = Math.min(ans, largestNumber - smallestNumber + recurse(nums, mask ^ removedMask));\\n        }\\n        \\n        return dp[mask] = ans;\\n    }\\n    \\n    private List<Integer> getAvailableIndices(int mask) {\\n        List<Integer> indices = new ArrayList<Integer>();\\n        \\n        //Check to see which bits are set, e.g. 101 => bits 2 and 0 are set.\\n        for (int i = 0; i < N; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                indices.add(i);             \\n            }\\n        }\\n        \\n        return indices;\\n    }\\n    \\n    private void generateCombinations(List<List<Integer>> combinations, List<Integer> indices, List<Integer> cur, int ind) {\\n        if (cur.size() == S) {\\n            combinations.add(cur);\\n            return;\\n        }\\n        else if (ind == indices.size()) {\\n            return;\\n        }\\n        \\n        //Add this index to the current combination\\n        List<Integer> copy = new ArrayList<Integer>(cur);\\n        copy.add(indices.get(ind));\\n        int newInd = ind + 1;\\n        \\n        //avoid duplicates\\n        while (newInd < indices.size() && vals[indices.get(newInd)] == vals[indices.get(ind)]) newInd++;\\n        generateCombinations(combinations, indices, copy, newInd);\\n        \\n        \\n        //skip this index\\n        copy = new ArrayList<Integer>(cur);\\n        generateCombinations(combinations, indices, copy, ind + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861692,
                "title": "c-bitmask-dp-o-n-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[70000];\\n    int dp(int mask,vector <int> &comb,map <int ,int> &values){\\n        if (mask==0) return 0;\\n        if (memo[mask]!=-1) return memo[mask];\\n        int best=INT_MAX/2;\\n        for (auto &c: comb){\\n            if ((mask & c)==c){\\n                best=min(best,dp(mask ^ c,comb,values)+values[c]);\\n            }\\n        }\\n        return memo[mask]=best;\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        int l=n/k;\\n        memset(memo,-1,sizeof(memo));\\n        map <int ,int> values;\\n        vector <int> comb;\\n        for (int mask=0;mask<(1<<n);mask++){\\n            int val=0;\\n            for (int i=0;i<n;i++){\\n                if ((mask & (1<<i))!=0) val++;\\n            }\\n            if (val==l){\\n                bool flag=true;\\n                vector <int> seen(n+1,0);\\n                vector <int> okay;\\n                for (int j=0;j<n;j++){\\n                    if ((mask & (1<<j))!=0){\\n                        if (seen[nums[j]]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                        seen[nums[j]]=1;\\n                        okay.push_back(nums[j]);\\n                    } \\n                }\\n                if (flag){\\n                    values[mask]=*max_element(okay.begin(),okay.end())-*min_element(okay.begin(),okay.end());\\n                    comb.push_back(mask);\\n                }\\n            }\\n        }\\n        int ans=dp((1<<n)-1,comb,values);\\n        return (ans<INT_MAX/2)?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[70000];\\n    int dp(int mask,vector <int> &comb,map <int ,int> &values){\\n        if (mask==0) return 0;\\n        if (memo[mask]!=-1) return memo[mask];\\n        int best=INT_MAX/2;\\n        for (auto &c: comb){\\n            if ((mask & c)==c){\\n                best=min(best,dp(mask ^ c,comb,values)+values[c]);\\n            }\\n        }\\n        return memo[mask]=best;\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        int l=n/k;\\n        memset(memo,-1,sizeof(memo));\\n        map <int ,int> values;\\n        vector <int> comb;\\n        for (int mask=0;mask<(1<<n);mask++){\\n            int val=0;\\n            for (int i=0;i<n;i++){\\n                if ((mask & (1<<i))!=0) val++;\\n            }\\n            if (val==l){\\n                bool flag=true;\\n                vector <int> seen(n+1,0);\\n                vector <int> okay;\\n                for (int j=0;j<n;j++){\\n                    if ((mask & (1<<j))!=0){\\n                        if (seen[nums[j]]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                        seen[nums[j]]=1;\\n                        okay.push_back(nums[j]);\\n                    } \\n                }\\n                if (flag){\\n                    values[mask]=*max_element(okay.begin(),okay.end())-*min_element(okay.begin(),okay.end());\\n                    comb.push_back(mask);\\n                }\\n            }\\n        }\\n        int ans=dp((1<<n)-1,comb,values);\\n        return (ans<INT_MAX/2)?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1040172,
                "title": "c-dp-o-n-n-2-n",
                "content": "Solution is inspired from following solution [[Python] True O(n*n*2^n) bit dp, explained](https://leetcode.com/problems/minimum-incompatibility/discuss/961969/Python-True-O(n*n*2n)-bit-dp-explained).\\n\\nWe try to fill up the dynamic programming table ```dp[mask][last]```, where it stores minimum incompatibility of elements that are one in ```mask``` and last selected element is ```last```. For example, ```dp[13][2]``` gives minimum incompatibility for selecting 0\\'th,2\\'nd,3\\'rd where last selected element is 2\\'nd (13 = 2^0 + 2^2 + 2^3). We know that each group have same number of elements. So, by counting number of set bits in ```mask``` we can know how many elements selected for last group. For example, assume each group should have 2 elements. Then, by looking ```dp[13][2]``` we can say that last group has only [2]. Incompatibility is calculated as max_element - min_element, as it is given in problemt statement. If we select elements of each group in increasing manner, only first and last selected elements affect incompatibility of the group. For example, for ```dp[13][2]``` 2\\'nd element is first one for its group, then its incompatibility calculation should have ```-nums[2]```. Also we can know max_element for group when calculating ```dp[mask][last]```. That is, when ```number_of_set_elements_of_mask % group_size == 0```. So we have three cases to calculate ```dp[mask][last]```.\\n* if ```number_of_set_elements_of_mask % group_size == 0``` then last element. ```dp[mask][last] = min(dp[prev][last_prev]) + nums[last]``` for all ```last_prev```.\\n* if ```number_of_set_elements_of_mask % group_size == 1``` then first element. ```dp[mask][last] = min(dp[prev][last_prev]) - nums[last]``` for all ```last_prev```.\\n* else middle elements, which does not have any effect to incompatability calculation. ```dp[mask][last] = min(dp[prev][last_prev])``` for all ```last_prev```.\\n\\nTime complexity is O(n^2 * n^2). 2^n * n for dp table and n for finding previous best. I think optimization can be done to decrease it to O(n^2 * n).\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int INF = nums.back()*n;\\n        vector<vector<int>> dp(1<<n, vector<int>(n, INF));\\n        vector<int> dp_best(1<<n, INF);\\n        int group_size = n/k;\\n        \\n        if(group_size == 1)\\n            return 0;\\n        \\n        dp_best[0] = 0;\\n        \\n        int mx = 1<<n;\\n        for(int i=1; i<mx; i++){\\n            int n_ones = __builtin_popcount(i), mn, prev;\\n            \\n            for(int j=0; j<n; j++){\\n                if(((1<<j) & i) == 0) continue;\\n                prev = i^(1<<j);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(n_ones % group_size == 1) {// first one\\n                    dp[i][j] = dp_best[prev] - nums[j];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                mn = INF;\\n                for(int p=0; p<j && nums[p]!=nums[j]; p++)\\n                    mn = min(mn, dp[prev][p]);\\n                \\n                if(n_ones % group_size == 0) // last one\\n                    dp[i][j] = mn + nums[j];\\n                if(n_ones % group_size > 1) // middle ones\\n                    dp[i][j] = mn;\\n            }\\n            \\n            for(int j=0; j<n; j++)\\n                dp_best[i] = min(dp_best[i], dp[i][j]);\\n        }\\n        \\n        if(dp_best[(1<<n)-1] >= INF)\\n            return -1;\\n        return dp_best[(1<<n)-1];\\n    }\\n};\\n```\\n\\nThanks for [@JackyD](https://leetcode.com/JackyD) for suggesting me to make a post for this solution.\\n",
                "solutionTags": [],
                "code": "```dp[mask][last]```\n```mask```\n```last```\n```dp[13][2]```\n```mask```\n```dp[13][2]```\n```dp[13][2]```\n```-nums[2]```\n```dp[mask][last]```\n```number_of_set_elements_of_mask % group_size == 0```\n```dp[mask][last]```\n```number_of_set_elements_of_mask % group_size == 0```\n```dp[mask][last] = min(dp[prev][last_prev]) + nums[last]```\n```last_prev```\n```number_of_set_elements_of_mask % group_size == 1```\n```dp[mask][last] = min(dp[prev][last_prev]) - nums[last]```\n```last_prev```\n```dp[mask][last] = min(dp[prev][last_prev])```\n```last_prev```\n```\\nclass Solution {\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int INF = nums.back()*n;\\n        vector<vector<int>> dp(1<<n, vector<int>(n, INF));\\n        vector<int> dp_best(1<<n, INF);\\n        int group_size = n/k;\\n        \\n        if(group_size == 1)\\n            return 0;\\n        \\n        dp_best[0] = 0;\\n        \\n        int mx = 1<<n;\\n        for(int i=1; i<mx; i++){\\n            int n_ones = __builtin_popcount(i), mn, prev;\\n            \\n            for(int j=0; j<n; j++){\\n                if(((1<<j) & i) == 0) continue;\\n                prev = i^(1<<j);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(n_ones % group_size == 1) {// first one\\n                    dp[i][j] = dp_best[prev] - nums[j];\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n                mn = INF;\\n                for(int p=0; p<j && nums[p]!=nums[j]; p++)\\n                    mn = min(mn, dp[prev][p]);\\n                \\n                if(n_ones % group_size == 0) // last one\\n                    dp[i][j] = mn + nums[j];\\n                if(n_ones % group_size > 1) // middle ones\\n                    dp[i][j] = mn;\\n            }\\n            \\n            for(int j=0; j<n; j++)\\n                dp_best[i] = min(dp_best[i], dp[i][j]);\\n        }\\n        \\n        if(dp_best[(1<<n)-1] >= INF)\\n            return -1;\\n        return dp_best[(1<<n)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962654,
                "title": "python-brute-force-with-some-pre-pruning",
                "content": "Key to not TLE on this problem is, given the set of numbers `nums`, only consider subset of `nums` that is of size n//k, and with only unique values. So we\\'ll first generate only valid candidate subsets, and for convinience and efficiency, each candidate subset will be represented a tuple: `(bitmask, diff)`. The `bitmask` will have `n//k` bits set where if bit-i is set, it means `nums[i]` is part of the candidate subset. `diff` is the max{values in subset} - min {values in subset}. Then we\\'ll go through all possible k combinations of the candidate subsets and see which results in the minimum incompatibility value.\\n\\nThe key recurrence is:\\nLet `s` represent the set of numbers selected in k partitions and `p` a subset of `s` containing `n//k` unique values. f(s) be the minimum discrepancy over them, then:\\n`f(s) = argmin[all valid p \\u2286 s]{f(s - p) + max{all values in p} - min{all values in p}}`\\n\\nHere\\'s the top-down recursive version which is easier to come up first than the dynamic programming version:\\n```\\n    def minimumIncompatibility_recursive_topdown(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ALL_SELECTED = (1 << n) - 1\\n        valid_subsets = self.gen_valid_subsets(nums, k)\\n            \\n        @functools.lru_cache(None)\\n        def f(s):\\n            if s == ALL_SELECTED:\\n                return 0\\n            \\n            min_incomp = float(\\'inf\\')\\n            for i in range(len(valid_subsets)):\\n                if s & valid_subsets[i][0] != 0:\\n                    # If we do choose to use the i-th subset of numbers, none of them should\\n                    # have been previously selected by a different subset\\n                    continue\\n\\n                min_incomp = min(min_incomp, f(s | valid_subsets[i][0]) + valid_subsets[i][1])\\n            \\n            return min_incomp\\n                \\n        result = f(0)\\n        return result if result != float(\\'inf\\') else -1\\n```\\n\\nThen mechanically convert the above to use dynamic programming:\\n```\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)       \\n\\t\\tALL_SELECTED = (1 << n) - 1\\n        valid_subsets = self.gen_valid_subsets(nums, k)\\n\\n        f = [float(\\'inf\\')] * (1 << n)\\n        f[0] = 0\\n        for s in range(1, 1 << n):\\n            if bin(s).count(\"1\") % (n//k) != 0:\\n                continue\\n            for i in range(len(valid_subsets)):\\n                if s & valid_subsets[i][0] != valid_subsets[i][0]:\\n                    continue\\n                f[s] = min(f[s], f[s ^ valid_subsets[i][0]] + valid_subsets[i][1])\\n        \\n        return f[ALL_SELECTED] if f[ALL_SELECTED] != float(\\'inf\\') else -1\\n```\\n\\nBoth would use the standard recursive function to generate candidate subsets:\\n```\\n    def gen_valid_subsets(self, nums, k):\\n        n = len(nums)\\n        set_size = n // k\\n        subsets = []\\n        def choose(i, seen, s, max_val, min_val):\\n            if len(seen) == set_size:\\n                # Each valid tuple contains the bitmask representing the subset of n//k numbers\\n                # selected and the discrepancy value\\n                subsets.append((s, max_val - min_val))\\n                return\\n\\n            if i == n:\\n                return\\n\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                choose(i + 1, seen, s | (1 << i), max(max_val, nums[i]), min(min_val, nums[i]))\\n                seen.remove(nums[i])\\n\\n            choose(i + 1, seen, s, max_val, min_val)\\n\\n        choose(0, set(), 0, float(\\'-inf\\'), float(\\'inf\\'))\\n        return subsets \\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def minimumIncompatibility_recursive_topdown(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        ALL_SELECTED = (1 << n) - 1\\n        valid_subsets = self.gen_valid_subsets(nums, k)\\n            \\n        @functools.lru_cache(None)\\n        def f(s):\\n            if s == ALL_SELECTED:\\n                return 0\\n            \\n            min_incomp = float(\\'inf\\')\\n            for i in range(len(valid_subsets)):\\n                if s & valid_subsets[i][0] != 0:\\n                    # If we do choose to use the i-th subset of numbers, none of them should\\n                    # have been previously selected by a different subset\\n                    continue\\n\\n                min_incomp = min(min_incomp, f(s | valid_subsets[i][0]) + valid_subsets[i][1])\\n            \\n            return min_incomp\\n                \\n        result = f(0)\\n        return result if result != float(\\'inf\\') else -1\\n```\n```\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)       \\n\\t\\tALL_SELECTED = (1 << n) - 1\\n        valid_subsets = self.gen_valid_subsets(nums, k)\\n\\n        f = [float(\\'inf\\')] * (1 << n)\\n        f[0] = 0\\n        for s in range(1, 1 << n):\\n            if bin(s).count(\"1\") % (n//k) != 0:\\n                continue\\n            for i in range(len(valid_subsets)):\\n                if s & valid_subsets[i][0] != valid_subsets[i][0]:\\n                    continue\\n                f[s] = min(f[s], f[s ^ valid_subsets[i][0]] + valid_subsets[i][1])\\n        \\n        return f[ALL_SELECTED] if f[ALL_SELECTED] != float(\\'inf\\') else -1\\n```\n```\\n    def gen_valid_subsets(self, nums, k):\\n        n = len(nums)\\n        set_size = n // k\\n        subsets = []\\n        def choose(i, seen, s, max_val, min_val):\\n            if len(seen) == set_size:\\n                # Each valid tuple contains the bitmask representing the subset of n//k numbers\\n                # selected and the discrepancy value\\n                subsets.append((s, max_val - min_val))\\n                return\\n\\n            if i == n:\\n                return\\n\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                choose(i + 1, seen, s | (1 << i), max(max_val, nums[i]), min(min_val, nums[i]))\\n                seen.remove(nums[i])\\n\\n            choose(i + 1, seen, s, max_val, min_val)\\n\\n        choose(0, set(), 0, float(\\'-inf\\'), float(\\'inf\\'))\\n        return subsets \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961477,
                "title": "python-easy-understanding-dfs-with-memo",
                "content": "**Idea:**\\nLet\\'s assume the problem is for dictionary `d,` we need to divide them into `k` groups with each group size as `count`, we can pick a group of numbers first and transform the problem to a sub-problem of `(new_d, k - 1, count)`\\n**Implementation**\\nUse `frozenset` to hash\\n```\\nimport collections\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dfs(d, k, count):\\n            d = dict(d)\\n            # Special cases\\n            if k == 1:\\n                if len(d) >= count:\\n                    return max(d.keys()) - min(d.keys())\\n                else:\\n                    return -1\\n            if count == 1:\\n                return 0\\n            if len(d) < count:\\n                return -1\\n            for key in d:\\n                if d[key] > k:\\n                    return -1\\n            \\n            # Pick a group first\\n            from itertools import combinations   \\n            res = float(\\'inf\\')\\n            perm = combinations(d.keys(), count) \\n            for i in list(perm):\\n                gap = max(i) - min(i)\\n                for cur in i:\\n                    d[cur] -= 1\\n                    if d[cur] == 0:\\n                        del d[cur]\\n                        \\n                # Update result\\n                nex = dfs(frozenset(d.items()), k - 1, count)\\n                if nex != -1:\\n                    res = min(res, gap + nex)\\n                for cur in i:\\n                    if cur not in d:\\n                        d[cur] = 0\\n                    d[cur] += 1\\n\\n            return res if res != float(\\'inf\\') else -1\\n        \\n        d = {}\\n        for num in nums:\\n            if num not in d:\\n                d[num] = 0\\n            d[num] += 1\\n            \\n        return dfs(frozenset(d.items()), k, len(nums) // k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dfs(d, k, count):\\n            d = dict(d)\\n            # Special cases\\n            if k == 1:\\n                if len(d) >= count:\\n                    return max(d.keys()) - min(d.keys())\\n                else:\\n                    return -1\\n            if count == 1:\\n                return 0\\n            if len(d) < count:\\n                return -1\\n            for key in d:\\n                if d[key] > k:\\n                    return -1\\n            \\n            # Pick a group first\\n            from itertools import combinations   \\n            res = float(\\'inf\\')\\n            perm = combinations(d.keys(), count) \\n            for i in list(perm):\\n                gap = max(i) - min(i)\\n                for cur in i:\\n                    d[cur] -= 1\\n                    if d[cur] == 0:\\n                        del d[cur]\\n                        \\n                # Update result\\n                nex = dfs(frozenset(d.items()), k - 1, count)\\n                if nex != -1:\\n                    res = min(res, gap + nex)\\n                for cur in i:\\n                    if cur not in d:\\n                        d[cur] = 0\\n                    d[cur] += 1\\n\\n            return res if res != float(\\'inf\\') else -1\\n        \\n        d = {}\\n        for num in nums:\\n            if num not in d:\\n                d[num] = 0\\n            d[num] += 1\\n            \\n        return dfs(frozenset(d.items()), k, len(nums) // k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588018,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums, k):\\n        length = len(nums)//k\\n        \\n        @lru_cache(None)\\n        def dfs(nums):\\n            if not nums: return 0\\n            \\n            min_val = float(\"inf\")\\n            \\n            for i in itertools.combinations(nums,length):\\n                if len(set(i)) < length: continue\\n                    \\n                new_nums = list(nums)\\n                \\n                for j in i:\\n                    new_nums.remove(j)\\n                    \\n                min_val = min(min_val,max(i)-min(i)+dfs(tuple(new_nums)))\\n                \\n            return min_val\\n        \\n        result = dfs(tuple(nums))\\n        \\n        return result if result != float(\"inf\") else -1\\n\\n            \\n        \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums, k):\\n        length = len(nums)//k\\n        \\n        @lru_cache(None)\\n        def dfs(nums):\\n            if not nums: return 0\\n            \\n            min_val = float(\"inf\")\\n            \\n            for i in itertools.combinations(nums,length):\\n                if len(set(i)) < length: continue\\n                    \\n                new_nums = list(nums)\\n                \\n                for j in i:\\n                    new_nums.remove(j)\\n                    \\n                min_val = min(min_val,max(i)-min(i)+dfs(tuple(new_nums)))\\n                \\n            return min_val\\n        \\n        result = dfs(tuple(nums))\\n        \\n        return result if result != float(\"inf\") else -1\\n\\n            \\n        \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497904,
                "title": "c-version-backtrack-with-visited-set-modified-from-java-with-comments",
                "content": "This is really a hard one to understand... Personally I don\\'t like the bitmask-type question, which is rarely in real interview.\\nI am glad to see solution done by @pigorski. I read that solution and write my own C++ version here, with a bit optimization (maybe?). Please see comments.\\n\\nlink to original [solution by pigorski](https://leetcode.com/problems/minimum-incompatibility/discuss/961470/Java-backtrack-solution-with-optimizations)\\n\\n```\\nclass Solution {\\npublic:\\n    // put index into sets\\n    void dfs(int index, int m, int csum, int & res, vector<int>& nums, vector<vector<int>> & sets) {\\n        if (csum > res) {\\n            return; // early terminate, if cost already over current best solution\\n        }\\n        if (index == nums.size()) { // all values from nums have been allocated, time to update final solution\\n            res = min(res, csum);\\n            return;\\n        }\\n        \\n        set<vector<int>> visited; \\n\\t\\t// we dont need to put nums[index] into the same set\\n\\t\\t// For example, if current sets include [[0, 1], [0, 1]], we only need to update [[0, 1, 2] [0, 1]], \\n\\t\\t// no need to do [[0, 1][0,1, 2]]\\n        \\n        for (int i = 0; i < sets.size(); ++i) {\\n            if (visited.count(sets[i])) {\\n                continue;\\n            }\\n            visited.insert(sets[i]);\\n\\n            if (sets[i].empty()) { // for empty set, we always put value inside, no change to total cost\\n                sets[i].push_back(nums[index]);\\n                dfs(index + 1, m, csum, res, nums, sets);\\n                sets[i].pop_back();\\n            } else {\\n                if (sets[i].back() >= nums[index] || sets[i].size() == m) { \\n\\t\\t\\t\\t    // every number must be larger than the previous one, this might be an optimization. Simplify difference\\n\\t\\t\\t\\t\\t// calculation and avoid duplicates.\\n                    continue;\\n                }\\n                int last = sets[i].back();\\n                int diff = (nums[index] - last); // increment to total incompatibility\\n\\n                sets[i].push_back(nums[index]);\\n                dfs(index + 1, m, csum + diff, res, nums, sets);\\n                sets[i].pop_back();                \\n            }\\n        }\\n        \\n    }\\n    \\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int n = nums.size(); // [1,n]\\n        vector<int> count(nums.size() + 1);\\n        int maxl = 0;\\n        for (int i: nums) {\\n            count[i]++;\\n            maxl = max(maxl, count[i]);\\n        }\\n        if (maxl > k) {\\n            return -1;\\n        }\\n        int m = n / k; // length for each\\n        vector<vector<int>> sets(k); // k empty sets\\n        sort(begin(nums), end(nums));\\n        int res = INT_MAX;\\n        \\n        dfs(0, m, 0, res, nums, sets);\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // put index into sets\\n    void dfs(int index, int m, int csum, int & res, vector<int>& nums, vector<vector<int>> & sets) {\\n        if (csum > res) {\\n            return; // early terminate, if cost already over current best solution\\n        }\\n        if (index == nums.size()) { // all values from nums have been allocated, time to update final solution\\n            res = min(res, csum);\\n            return;\\n        }\\n        \\n        set<vector<int>> visited; \\n\\t\\t// we dont need to put nums[index] into the same set\\n\\t\\t// For example, if current sets include [[0, 1], [0, 1]], we only need to update [[0, 1, 2] [0, 1]], \\n\\t\\t// no need to do [[0, 1][0,1, 2]]\\n        \\n        for (int i = 0; i < sets.size(); ++i) {\\n            if (visited.count(sets[i])) {\\n                continue;\\n            }\\n            visited.insert(sets[i]);\\n\\n            if (sets[i].empty()) { // for empty set, we always put value inside, no change to total cost\\n                sets[i].push_back(nums[index]);\\n                dfs(index + 1, m, csum, res, nums, sets);\\n                sets[i].pop_back();\\n            } else {\\n                if (sets[i].back() >= nums[index] || sets[i].size() == m) { \\n\\t\\t\\t\\t    // every number must be larger than the previous one, this might be an optimization. Simplify difference\\n\\t\\t\\t\\t\\t// calculation and avoid duplicates.\\n                    continue;\\n                }\\n                int last = sets[i].back();\\n                int diff = (nums[index] - last); // increment to total incompatibility\\n\\n                sets[i].push_back(nums[index]);\\n                dfs(index + 1, m, csum + diff, res, nums, sets);\\n                sets[i].pop_back();                \\n            }\\n        }\\n        \\n    }\\n    \\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        int n = nums.size(); // [1,n]\\n        vector<int> count(nums.size() + 1);\\n        int maxl = 0;\\n        for (int i: nums) {\\n            count[i]++;\\n            maxl = max(maxl, count[i]);\\n        }\\n        if (maxl > k) {\\n            return -1;\\n        }\\n        int m = n / k; // length for each\\n        vector<vector<int>> sets(k); // k empty sets\\n        sort(begin(nums), end(nums));\\n        int res = INT_MAX;\\n        \\n        dfs(0, m, 0, res, nums, sets);\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081585,
                "title": "0-ms-binary-search-dfs-clean-and-easy-to-understand",
                "content": "This solution is inspired by https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1010057/JavaPython-Binary-Search-100\\n\\n```\\nfunc minimumIncompatibility(nums []int, k int) int {\\n    cnts := make([]int, len(nums)+1, len(nums)+1) //1 <= nums[i] <= nums.length\\n    for _, n := range nums {if cnts[n]++; cnts[n] > k {return -1}} //no two equal elements in the same subset.\\n\\n    setlen := len(nums)/k\\n    targetSum := 0 \\n    \\n    var dfs func(cnti, j, sum int, sets [][]int) bool\\n    dfs = func(cnti, j, sum int, sets [][]int) bool {   \\n        if len(sets[j]) == setlen {\\n            if sum += sets[j][setlen-1] - sets[j][0]; sum > targetSum {return false} //make the lower bound l higher\\n            \\n            if j++; j == k {return true} //smaller targetSum is possible, make the upper bound r lower\\n            \\n            cnti = 1\\n        }\\n        \\n        for i := cnti; i < len(cnts); i++{\\n            if cnts[i] == 0 {continue}\\n            \\n            l := len(sets[j])\\n            if l > 0 && sum+i-sets[j][0] > targetSum {return false} //make the lower bound l higher\\n            \\n            cnts[i]--\\n            sets[j] = append(sets[j], i)\\n            if dfs(i+1, j, sum, sets) {\\n\\t\\t\\t\\tsets[j] = sets[j][:l]\\n\\t\\t\\t\\tcnts[i]++\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n            \\n            sets[j] = sets[j][:l]          \\n            cnts[i]++\\n            if l == 0 {return false}\\n        }\\n        \\n        return false\\n    }\\n    \\n    l, r := 0, 120 //1 <= k <= nums.length <= 16, so the upper bound is 120 = (16-1)*8\\n    for l < r{\\n        targetSum = (l+r)>>1\\n        if dfs(1, 0, 0, make([][]int, k, k)) {\\n            r = targetSum\\n        }else{\\n            l = targetSum+1\\n        }\\n    }\\n    \\n    return l\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumIncompatibility(nums []int, k int) int {\\n    cnts := make([]int, len(nums)+1, len(nums)+1) //1 <= nums[i] <= nums.length\\n    for _, n := range nums {if cnts[n]++; cnts[n] > k {return -1}} //no two equal elements in the same subset.\\n\\n    setlen := len(nums)/k\\n    targetSum := 0 \\n    \\n    var dfs func(cnti, j, sum int, sets [][]int) bool\\n    dfs = func(cnti, j, sum int, sets [][]int) bool {   \\n        if len(sets[j]) == setlen {\\n            if sum += sets[j][setlen-1] - sets[j][0]; sum > targetSum {return false} //make the lower bound l higher\\n            \\n            if j++; j == k {return true} //smaller targetSum is possible, make the upper bound r lower\\n            \\n            cnti = 1\\n        }\\n        \\n        for i := cnti; i < len(cnts); i++{\\n            if cnts[i] == 0 {continue}\\n            \\n            l := len(sets[j])\\n            if l > 0 && sum+i-sets[j][0] > targetSum {return false} //make the lower bound l higher\\n            \\n            cnts[i]--\\n            sets[j] = append(sets[j], i)\\n            if dfs(i+1, j, sum, sets) {\\n\\t\\t\\t\\tsets[j] = sets[j][:l]\\n\\t\\t\\t\\tcnts[i]++\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n            \\n            sets[j] = sets[j][:l]          \\n            cnts[i]++\\n            if l == 0 {return false}\\n        }\\n        \\n        return false\\n    }\\n    \\n    l, r := 0, 120 //1 <= k <= nums.length <= 16, so the upper bound is 120 = (16-1)*8\\n    for l < r{\\n        targetSum = (l+r)>>1\\n        if dfs(1, 0, 0, make([][]int, k, k)) {\\n            r = targetSum\\n        }else{\\n            l = targetSum+1\\n        }\\n    }\\n    \\n    return l\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 974495,
                "title": "javascript-recursive-solution-beats-100",
                "content": "```js\\nvar minSum = Number.MAX_SAFE_INTEGER;\\n\\nvar recur = function(curIdx, subsets, nums, k, countOfEveryGroup, currentSum) {\\n    if (curIdx === nums.length && currentSum < minSum) {\\n        minSum = currentSum;\\n        return;\\n    }\\n    var curNum = nums[curIdx];\\n    for (var subsetIdx = 0; subsetIdx < subsets.length; subsetIdx++) {\\n        var subset = subsets[subsetIdx];\\n        if (subset.length >= countOfEveryGroup || subset.indexOf(curNum) !== -1) continue;\\n        var minOfCurSubSet = Math.min(...subset);\\n        var maxOfCurSubSet = Math.max(...subset);\\n        subset.push(curNum);\\n        var shouldAddToSum = 0;\\n        if (curNum > maxOfCurSubSet) {\\n            shouldAddToSum += (curNum - maxOfCurSubSet);\\n        } else if (curNum < minOfCurSubSet) {\\n            shouldAddToSum += (minOfCurSubSet - curNum);\\n        }\\n        var newSum = currentSum + shouldAddToSum;\\n        if (newSum < minSum) {\\n            recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, newSum);\\n        }\\n        subset.pop();\\n    }\\n    if (subsets.length < k) {\\n        var newSubset = [curNum];\\n        subsets.push(newSubset);\\n        recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, currentSum);\\n        subsets.pop();\\n    }\\n};\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumIncompatibility = function(nums, k) {\\n    if (k === 0) return -1;\\n    var numsCount = nums.length;\\n    var countOfEveryGroup = numsCount / k;\\n    var numCountArr = new Array(16).fill(0);\\n    nums.forEach(num => numCountArr[num]++);\\n    if (numCountArr.some(count => count > k)) return -1;\\n    if (k === 1) return Math.max(...nums) - Math.min(...nums);\\n    minSum = Number.MAX_SAFE_INTEGER;\\n    \\n    recur(0, [], nums, k, countOfEveryGroup, 0);\\n    return minSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nvar minSum = Number.MAX_SAFE_INTEGER;\\n\\nvar recur = function(curIdx, subsets, nums, k, countOfEveryGroup, currentSum) {\\n    if (curIdx === nums.length && currentSum < minSum) {\\n        minSum = currentSum;\\n        return;\\n    }\\n    var curNum = nums[curIdx];\\n    for (var subsetIdx = 0; subsetIdx < subsets.length; subsetIdx++) {\\n        var subset = subsets[subsetIdx];\\n        if (subset.length >= countOfEveryGroup || subset.indexOf(curNum) !== -1) continue;\\n        var minOfCurSubSet = Math.min(...subset);\\n        var maxOfCurSubSet = Math.max(...subset);\\n        subset.push(curNum);\\n        var shouldAddToSum = 0;\\n        if (curNum > maxOfCurSubSet) {\\n            shouldAddToSum += (curNum - maxOfCurSubSet);\\n        } else if (curNum < minOfCurSubSet) {\\n            shouldAddToSum += (minOfCurSubSet - curNum);\\n        }\\n        var newSum = currentSum + shouldAddToSum;\\n        if (newSum < minSum) {\\n            recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, newSum);\\n        }\\n        subset.pop();\\n    }\\n    if (subsets.length < k) {\\n        var newSubset = [curNum];\\n        subsets.push(newSubset);\\n        recur(curIdx + 1, subsets, nums, k, countOfEveryGroup, currentSum);\\n        subsets.pop();\\n    }\\n};\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar minimumIncompatibility = function(nums, k) {\\n    if (k === 0) return -1;\\n    var numsCount = nums.length;\\n    var countOfEveryGroup = numsCount / k;\\n    var numCountArr = new Array(16).fill(0);\\n    nums.forEach(num => numCountArr[num]++);\\n    if (numCountArr.some(count => count > k)) return -1;\\n    if (k === 1) return Math.max(...nums) - Math.min(...nums);\\n    minSum = Number.MAX_SAFE_INTEGER;\\n    \\n    recur(0, [], nums, k, countOfEveryGroup, 0);\\n    return minSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 968956,
                "title": "golang-dp-with-explanation-o-2-n-n-2",
                "content": "For one group of selected numbers with size k, incompatibility is determined and order doesn\\'t matter, also remaining numbers need to keep selecting size k numbers, which means it\\'s a recursion.\\n\\n```\\ne.g. nums = [1, 2, 3, 4, 5, 6], k = 2\\nif selected = [2, 5], incompatibility = 5 - 2 = 3\\nif selected = [5, 2], incompatibility = 5 - 2 = 3\\nit means order of selection doens\\'t change incompatibility value.\\n\\nremaining nums = [1, 3, 4, 6], keep selecting size = 2 numbers until no numbers can be selected.\\n```\\n\\nSelect k size numbers and order doesn\\'t matter means to find combinations of numbers.\\n\\nTo denote some numbers are selected disrescarding order, bitmask can be used.\\n\\nTime complexity for this is similar to traveling salseman problem (TSP). There are n numbers to start, total 2^n combinations, for each route is determined takes n to find incompatibility value, overall time complexity is O(2^n * n^2).\\n\\n```\\ne.g. nums = [1, 2, 3, 4, 5, 6], k = 2\\n  bitmask = [0  0  0  0  0  0] means no number is selected\\n\\nselect numbers = [2, 5], bitmask = [0  1  0  0  1  0]\\nselect numbers = [5, 2], bitmask = [0  1  0  0  1  0]\\n\\nso if selected numbers are same with different order, bitmask gets same value which can be used to check if group of numbers are selected or not\\n```\\n\\nOverall algorithm is to find valid combination of number with size equals to k, iterate through all of combinations, find incompatibiity value and keep select remaing numbers for size equals to k.\\n\\n```golang\\nfunc minimumIncompatibility(nums []int, k int) int {\\n\\tsize := len(nums)\\n\\tif size == k {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// make sure no number appear more than k times\\n\\tcounter := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tcounter[n]++\\n\\t\\tif counter[n] > k {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\n\\tmaxMask := (1 << size) - 1\\n\\tused := make(map[int]int)\\n\\n\\tval := dfs(nums, 0, maxMask, size/k, used)\\n\\tif val >= 9999 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn val\\n}\\n\\nfunc dfs(nums []int, currentMask, maxMask, groupSize int, used map[int]int) int {\\n\\tif currentMask == maxMask {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// used already computed value\\n\\tif val, ok := used[currentMask]; ok {\\n\\t\\treturn val\\n\\t}\\n\\n\\t// find unique unused numbers\\n\\tuniq := make(map[int]bool)\\n\\tavailable := make([]int, 0)\\n\\tsize := len(nums)\\n\\tfor i := 0; i < size; i++ {\\n\\t\\tif (1<<(size-1-i))&currentMask > 0 || uniq[nums[i]] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tuniq[nums[i]] = true\\n\\n\\t\\tavailable = append(available, i)\\n\\t}\\n\\n\\t// insufficient to form a group\\n\\tif len(available) < groupSize {\\n\\t\\treturn 9999\\n\\t}\\n\\n\\t// generate combinations from those numbers\\n\\tcombs := findCombinations(available, groupSize)\\n\\n\\t// count value\\n\\tincompatibility := 9999\\n\\tfor _, c := range combs {\\n\\t\\tnextMask := currentMask\\n\\t\\tmaxVal, minVal := math.MinInt32, math.MaxInt32\\n\\n\\t\\tfor _, j := range c {\\n\\t\\t\\tmaxVal = max(maxVal, nums[j])\\n\\t\\t\\tminVal = min(minVal, nums[j])\\n\\t\\t\\tnextMask |= 1 << (size - 1 - j)\\n\\t\\t}\\n\\n\\t\\tincompatibility = min(incompatibility, maxVal-minVal+dfs(nums, nextMask, maxMask, groupSize, used))\\n\\t}\\n\\tused[currentMask] = incompatibility\\n\\n\\treturn incompatibility\\n}\\n\\ntype Comb struct {\\n\\tIdx  int\\n\\tData []int\\n}\\n\\n// BFS\\nfunc findCombinations(available []int, groupSize int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tstack := []Comb{\\n\\t\\t{0, []int{}},\\n\\t}\\n\\tsize := len(available)\\n\\n\\tfor len(stack) > 0 {\\n\\t\\ts := stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tidx, data := s.Idx, s.Data\\n\\n\\t\\tif len(data) == groupSize {\\n\\t\\t\\tans = append(ans, data)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor ; idx < size; idx++ {\\n\\t\\t\\tlength := len(data)\\n\\t\\t\\ttmp := make([]int, length, length+1)\\n\\t\\t\\tcopy(tmp, data)\\n\\t\\t\\ttmp = append(tmp, available[idx])\\n\\t\\t\\tstack = append(stack, Comb{\\n\\t\\t\\t\\tIdx:  idx + 1,\\n\\t\\t\\t\\tData: tmp,\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\ne.g. nums = [1, 2, 3, 4, 5, 6], k = 2\\nif selected = [2, 5], incompatibility = 5 - 2 = 3\\nif selected = [5, 2], incompatibility = 5 - 2 = 3\\nit means order of selection doens\\'t change incompatibility value.\\n\\nremaining nums = [1, 3, 4, 6], keep selecting size = 2 numbers until no numbers can be selected.\\n```\n```\\ne.g. nums = [1, 2, 3, 4, 5, 6], k = 2\\n  bitmask = [0  0  0  0  0  0] means no number is selected\\n\\nselect numbers = [2, 5], bitmask = [0  1  0  0  1  0]\\nselect numbers = [5, 2], bitmask = [0  1  0  0  1  0]\\n\\nso if selected numbers are same with different order, bitmask gets same value which can be used to check if group of numbers are selected or not\\n```\n```golang\\nfunc minimumIncompatibility(nums []int, k int) int {\\n\\tsize := len(nums)\\n\\tif size == k {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// make sure no number appear more than k times\\n\\tcounter := make(map[int]int)\\n\\tfor _, n := range nums {\\n\\t\\tcounter[n]++\\n\\t\\tif counter[n] > k {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\n\\tmaxMask := (1 << size) - 1\\n\\tused := make(map[int]int)\\n\\n\\tval := dfs(nums, 0, maxMask, size/k, used)\\n\\tif val >= 9999 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn val\\n}\\n\\nfunc dfs(nums []int, currentMask, maxMask, groupSize int, used map[int]int) int {\\n\\tif currentMask == maxMask {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// used already computed value\\n\\tif val, ok := used[currentMask]; ok {\\n\\t\\treturn val\\n\\t}\\n\\n\\t// find unique unused numbers\\n\\tuniq := make(map[int]bool)\\n\\tavailable := make([]int, 0)\\n\\tsize := len(nums)\\n\\tfor i := 0; i < size; i++ {\\n\\t\\tif (1<<(size-1-i))&currentMask > 0 || uniq[nums[i]] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tuniq[nums[i]] = true\\n\\n\\t\\tavailable = append(available, i)\\n\\t}\\n\\n\\t// insufficient to form a group\\n\\tif len(available) < groupSize {\\n\\t\\treturn 9999\\n\\t}\\n\\n\\t// generate combinations from those numbers\\n\\tcombs := findCombinations(available, groupSize)\\n\\n\\t// count value\\n\\tincompatibility := 9999\\n\\tfor _, c := range combs {\\n\\t\\tnextMask := currentMask\\n\\t\\tmaxVal, minVal := math.MinInt32, math.MaxInt32\\n\\n\\t\\tfor _, j := range c {\\n\\t\\t\\tmaxVal = max(maxVal, nums[j])\\n\\t\\t\\tminVal = min(minVal, nums[j])\\n\\t\\t\\tnextMask |= 1 << (size - 1 - j)\\n\\t\\t}\\n\\n\\t\\tincompatibility = min(incompatibility, maxVal-minVal+dfs(nums, nextMask, maxMask, groupSize, used))\\n\\t}\\n\\tused[currentMask] = incompatibility\\n\\n\\treturn incompatibility\\n}\\n\\ntype Comb struct {\\n\\tIdx  int\\n\\tData []int\\n}\\n\\n// BFS\\nfunc findCombinations(available []int, groupSize int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tstack := []Comb{\\n\\t\\t{0, []int{}},\\n\\t}\\n\\tsize := len(available)\\n\\n\\tfor len(stack) > 0 {\\n\\t\\ts := stack[len(stack)-1]\\n\\t\\tstack = stack[:len(stack)-1]\\n\\t\\tidx, data := s.Idx, s.Data\\n\\n\\t\\tif len(data) == groupSize {\\n\\t\\t\\tans = append(ans, data)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor ; idx < size; idx++ {\\n\\t\\t\\tlength := len(data)\\n\\t\\t\\ttmp := make([]int, length, length+1)\\n\\t\\t\\tcopy(tmp, data)\\n\\t\\t\\ttmp = append(tmp, available[idx])\\n\\t\\t\\tstack = append(stack, Comb{\\n\\t\\t\\t\\tIdx:  idx + 1,\\n\\t\\t\\t\\tData: tmp,\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n\\nfunc max(i, j int) int {\\n\\tif i >= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n\\nfunc min(i, j int) int {\\n\\tif i <= j {\\n\\t\\treturn i\\n\\t}\\n\\treturn j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965985,
                "title": "java-double-bitmasking-dp-pruning-early-halt",
                "content": "```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        int size = n / k;\\n        int complete = (1 << n) - 1;\\n        if (k == nums.length) {\\n            return 0;\\n        }\\n        int[] cnt = new int[17];\\n        for (int x : nums) {\\n            cnt[x]++;\\n        }\\n        for (int i = 0; i < 17; i++) {\\n            if (cnt[i] > k) {\\n                return -1;\\n            }\\n        }\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(nums);\\n        return dfs(0, -1, nums, Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 0, size, complete, dp, true);\\n    }\\n    \\n    private int dfs(int mask, int index, int[] nums, int min, int max, int set, int cnt, int limit, int complete, Map<String, Integer> dp, boolean halt) {\\n        String key = mask + \" \" + set;\\n        if (mask == complete) {\\n            return max - min;\\n        }\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int add = 0;\\n        if (cnt == limit) {\\n            set = 0;\\n            cnt = 0;\\n            add = max - min;\\n            min = Integer.MAX_VALUE;\\n            max = Integer.MIN_VALUE;\\n            index = -1;\\n            halt = true;\\n        }\\n        int last = -1;\\n        for (int i = index + 1; i < nums.length; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            if ((set & (1 << nums[i])) != 0) {\\n                continue;\\n            }\\n            if (nums[i] == last) {\\n                continue;\\n            }\\n            int next = dfs(mask | (1 << i), i, nums, Math.min(min, nums[i]), Math.max(max, nums[i]), set | (1 << nums[i]), cnt + 1, limit, complete, dp, false);\\n            res = Math.min(res, next);\\n            last = nums[i];\\n            if (halt) {\\n                break;\\n            }\\n        }\\n        if (res != Integer.MAX_VALUE) {\\n            res += add;\\n        }\\n        dp.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        int size = n / k;\\n        int complete = (1 << n) - 1;\\n        if (k == nums.length) {\\n            return 0;\\n        }\\n        int[] cnt = new int[17];\\n        for (int x : nums) {\\n            cnt[x]++;\\n        }\\n        for (int i = 0; i < 17; i++) {\\n            if (cnt[i] > k) {\\n                return -1;\\n            }\\n        }\\n        Map<String, Integer> dp = new HashMap<>();\\n        Arrays.sort(nums);\\n        return dfs(0, -1, nums, Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 0, size, complete, dp, true);\\n    }\\n    \\n    private int dfs(int mask, int index, int[] nums, int min, int max, int set, int cnt, int limit, int complete, Map<String, Integer> dp, boolean halt) {\\n        String key = mask + \" \" + set;\\n        if (mask == complete) {\\n            return max - min;\\n        }\\n        if (dp.containsKey(key)) {\\n            return dp.get(key);\\n        }\\n        int res = Integer.MAX_VALUE;\\n        int add = 0;\\n        if (cnt == limit) {\\n            set = 0;\\n            cnt = 0;\\n            add = max - min;\\n            min = Integer.MAX_VALUE;\\n            max = Integer.MIN_VALUE;\\n            index = -1;\\n            halt = true;\\n        }\\n        int last = -1;\\n        for (int i = index + 1; i < nums.length; i++) {\\n            if ((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            if ((set & (1 << nums[i])) != 0) {\\n                continue;\\n            }\\n            if (nums[i] == last) {\\n                continue;\\n            }\\n            int next = dfs(mask | (1 << i), i, nums, Math.min(min, nums[i]), Math.max(max, nums[i]), set | (1 << nums[i]), cnt + 1, limit, complete, dp, false);\\n            res = Math.min(res, next);\\n            last = nums[i];\\n            if (halt) {\\n                break;\\n            }\\n        }\\n        if (res != Integer.MAX_VALUE) {\\n            res += add;\\n        }\\n        dp.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963948,
                "title": "python-backtracking-code-with-comments",
                "content": "Mixture of two backtracking approaches. \\n* [[Python] simple backtracking beats 100%\\n](https://leetcode.com/problems/minimum-incompatibility/discuss/961470/Java-backtrack-solution-with-optimizations)\\n* [Java backtrack solution with optimizations](https://leetcode.com/problems/minimum-incompatibility/discuss/961470/Java-backtrack-solution-with-optimizations)\\n\\n\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        d = len(nums) // k\\n        nums = sorted(nums, reverse=True)\\n        \\n        part = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        \\n        def calc():\\n            # Calculate incompatability score from all partitions\\n            score = 0\\n            for l in part:\\n                if len(l) <= 1:\\n                    continue\\n                score += (l[0] - l[-1])\\n            return score\\n        \\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, calc())\\n                return\\n            \\n            visited = set()\\n            for j in range(k):\\n                if len(part[j]) == d or (len(part[j]) > 0 and part[j][-1] == nums[i]) or (tuple(part[j]) in visited):\\n                    # Already full or previous element is identical or duplicate partition\\n                    continue\\n                \\n                # Not to test same partition again and again\\n\\t\\t\\t\\t# [[1], [], []] is same as [[], [1], []]\\n                visited.add(tuple(part[j]))\\n                \\n                part[j].append(nums[i])\\n                if calc() < self.res:\\n                    assign(i+1)\\n                part[j].pop()\\n            return\\n        \\n        assign(0)\\n        return -1 if self.res == float(\\'inf\\') else self.res           \\n```\\n\\n`Should also pass: nums=[10,10,9,9,8,8,8,8,2,1], k=5`\\n\\n### Optimization ideas\\n* Used sorted nums list for easier cacluation of Incompatibility\\n* Early break on ongoing total score exceeds current minimum complete total score\\n* Visited set for not visiting duplicate partiton in different position",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        d = len(nums) // k\\n        nums = sorted(nums, reverse=True)\\n        \\n        part = [[] for _ in range(k)]\\n        self.res = float(\\'inf\\')\\n        \\n        def calc():\\n            # Calculate incompatability score from all partitions\\n            score = 0\\n            for l in part:\\n                if len(l) <= 1:\\n                    continue\\n                score += (l[0] - l[-1])\\n            return score\\n        \\n        def assign(i):\\n            if i == len(nums):\\n                self.res = min(self.res, calc())\\n                return\\n            \\n            visited = set()\\n            for j in range(k):\\n                if len(part[j]) == d or (len(part[j]) > 0 and part[j][-1] == nums[i]) or (tuple(part[j]) in visited):\\n                    # Already full or previous element is identical or duplicate partition\\n                    continue\\n                \\n                # Not to test same partition again and again\\n\\t\\t\\t\\t# [[1], [], []] is same as [[], [1], []]\\n                visited.add(tuple(part[j]))\\n                \\n                part[j].append(nums[i])\\n                if calc() < self.res:\\n                    assign(i+1)\\n                part[j].pop()\\n            return\\n        \\n        assign(0)\\n        return -1 if self.res == float(\\'inf\\') else self.res           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 961801,
                "title": "python3-greedy-time-o-n-lg-n-k-n-with-explaination",
                "content": "\\nI tried two directions greedily, from large numbers to small numbers, and small numbers to large numbers.\\n\\nTry both direction and then pick the min of two candidates.\\n\\nLet\\'s explain small-to-large direction first.\\n\\n1. Build a counting table, and sort the keys.\\n2. First reject those test cases where some numbers appear more than k times.\\n3. For those numbers appear exactly `k` times, put them to each group, one to one.\\n4. Pick distinct numbers, from small to large, putting them into the first group until it is full. \\n5. For those numbers smaller than those in `step 4`, If their counts `== k-1` , we shall put them to the remaining `k-1` groups, one to one.\\n\\nRepeat until we fill all groups.\\nThen try the large-to-small direction again.\\n\\nApparently the two directions will give different partitioning, so I just take the smallest. Not sure if it is a valid method, or just lucky on those test case.\\n\\nHope someone could give more intuition or proof of the correctness/incorrectness.\\n\\n`n lg n` comes from sorting.\\n`k*n` comes from for-loop, for worst case that we have all distinct numbers.\\n\\ntime: 20~36 ms\\t\\nspace: 14.1~14.3 MB\\n\\n```\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\tdef helper(to_reverse):\\n\\t\\tcc = Counter(nums)\\n\\t\\tif cc.most_common()[0][1] > k:  # if a num more than k times, cant do\\n\\t\\t\\treturn -1\\n\\n\\t\\tif to_reverse:\\n\\t\\t\\tli = sorted(cc.keys())\\n\\t\\telse:\\n\\t\\t\\tli = sorted(cc.keys(), reverse=True)\\n\\n\\t\\tm = len(nums) // k\\n\\t\\tn = len(nums)\\n\\n\\t\\tstacks = [[] for _ in range(k)] # k stacks for each group\\n\\t\\tself.i = 0  # to indicate the st we will append to\\n\\n\\t\\tdef put(x):\\n\\t\\t\\tif len(stacks[self.i]) == m:\\n\\t\\t\\t\\tself.i += 1\\n\\t\\t\\tstacks[self.i].append(x)\\n\\n\\t\\tdef put_many(x): # put to each group\\n\\t\\t\\tfor _i in range(self.i + 1, k): # put to all after stacks\\n\\t\\t\\t\\tstacks[_i].append(x)\\n\\n\\t\\tput_count = 0  # count how many times we put\\n\\n\\t\\t# for those numbers w/ k counts\\n\\t\\tfor x in li:\\n\\t\\t\\tif cc[x] == k:\\n\\t\\t\\t\\tfor _i in range(self.i, k): \\n\\t\\t\\t\\t\\tstacks[_i].append(x)\\n\\t\\t\\t\\tput_count += k\\n\\t\\t\\t\\tcc[x] = 0\\n\\n\\t\\twhile put_count < len(nums):\\n\\t\\t\\talready_put = False  # already put a num in this for-loop\\n\\t\\t\\tfor x in li:\\n\\t\\t\\t\\tif already_put and len(stacks[self.i]) == m:  # if this group full, check the remaining numbers to see if they need to be partitioned into each group\\n\\t\\t\\t\\t\\tif cc[x] == k - self.i - 1:\\n\\t\\t\\t\\t\\t\\tput_many(x)\\n\\t\\t\\t\\t\\t\\tput_count += k - self.i - 1\\n\\t\\t\\t\\t\\t\\tcc[x] = 0\\n\\t\\t\\t\\telif cc[x] > 0:  # put number to group in order\\n\\t\\t\\t\\t\\tput(x)\\n\\t\\t\\t\\t\\tput_count += 1\\n\\t\\t\\t\\t\\tcc[x] -= 1\\n\\t\\t\\t\\t\\talready_put = True\\n\\n\\t\\treturn sum([max(st) - min(st) for st in stacks])  # compute the incompatibility\\n\\n\\treturn min(helper(True), helper(False))  \\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\tdef helper(to_reverse):\\n\\t\\tcc = Counter(nums)\\n\\t\\tif cc.most_common()[0][1] > k:  # if a num more than k times, cant do\\n\\t\\t\\treturn -1\\n\\n\\t\\tif to_reverse:\\n\\t\\t\\tli = sorted(cc.keys())\\n\\t\\telse:\\n\\t\\t\\tli = sorted(cc.keys(), reverse=True)\\n\\n\\t\\tm = len(nums) // k\\n\\t\\tn = len(nums)\\n\\n\\t\\tstacks = [[] for _ in range(k)] # k stacks for each group\\n\\t\\tself.i = 0  # to indicate the st we will append to\\n\\n\\t\\tdef put(x):\\n\\t\\t\\tif len(stacks[self.i]) == m:\\n\\t\\t\\t\\tself.i += 1\\n\\t\\t\\tstacks[self.i].append(x)\\n\\n\\t\\tdef put_many(x): # put to each group\\n\\t\\t\\tfor _i in range(self.i + 1, k): # put to all after stacks\\n\\t\\t\\t\\tstacks[_i].append(x)\\n\\n\\t\\tput_count = 0  # count how many times we put\\n\\n\\t\\t# for those numbers w/ k counts\\n\\t\\tfor x in li:\\n\\t\\t\\tif cc[x] == k:\\n\\t\\t\\t\\tfor _i in range(self.i, k): \\n\\t\\t\\t\\t\\tstacks[_i].append(x)\\n\\t\\t\\t\\tput_count += k\\n\\t\\t\\t\\tcc[x] = 0\\n\\n\\t\\twhile put_count < len(nums):\\n\\t\\t\\talready_put = False  # already put a num in this for-loop\\n\\t\\t\\tfor x in li:\\n\\t\\t\\t\\tif already_put and len(stacks[self.i]) == m:  # if this group full, check the remaining numbers to see if they need to be partitioned into each group\\n\\t\\t\\t\\t\\tif cc[x] == k - self.i - 1:\\n\\t\\t\\t\\t\\t\\tput_many(x)\\n\\t\\t\\t\\t\\t\\tput_count += k - self.i - 1\\n\\t\\t\\t\\t\\t\\tcc[x] = 0\\n\\t\\t\\t\\telif cc[x] > 0:  # put number to group in order\\n\\t\\t\\t\\t\\tput(x)\\n\\t\\t\\t\\t\\tput_count += 1\\n\\t\\t\\t\\t\\tcc[x] -= 1\\n\\t\\t\\t\\t\\talready_put = True\\n\\n\\t\\treturn sum([max(st) - min(st) for st in stacks])  # compute the incompatibility\\n\\n\\treturn min(helper(True), helper(False))  \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 961661,
                "title": "python-bottom-up-solution",
                "content": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        def countBit(n):\\n            res = 0\\n            while n != 0:\\n                res += n % 2\\n                n = n // 2\\n            return res\\n        def toNum(l):\\n            return sum([1 << i for i in l])\\n        def toList(n):\\n            l = []\\n            for i in range(len(nums)):\\n                if n % 2:\\n                    l.append(i)\\n                n = n // 2\\n            return l\\n        def selectBit(n, k):\\n            return [toNum(l) for l in itertools.combinations(toList(n),k)]\\n        def getCompatibility(l):\\n            if len(set([nums[i] for i in l])) != len(l):\\n                return 1000\\n            else:\\n                x = [nums[i] for i in l]\\n                return max(x) - min(x)\\n        \\n        if len(nums) == k:\\n            return 0\\n        if k == 1:\\n            if len(set(nums)) != len(nums):\\n                return -1\\n            else:\\n                return max(nums) - min(nums)\\n        \\n        partition_size = len(nums) // k\\n        n = len(nums)\\n        \\n        buckets = [[] for i in range(n+1)]\\n        for i in range(1, 1 << n):\\n            buckets[countBit(i)].append(i)\\n        dp = [1000 for i in range(1 << n)]\\n        for j in buckets[partition_size]:\\n            dp[j] = getCompatibility(toList(j))\\n        for i in range(partition_size * 2, n+1, partition_size):\\n            for j in buckets[i]:\\n                #print(j, k)\\n                for l in selectBit(j, partition_size):\\n                    dp[j] = min(dp[j], dp[l] + dp[j-l])\\n        if dp[(1 << n) - 1] == 1000:\\n            return -1\\n        return dp[(1 << n) - 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        def countBit(n):\\n            res = 0\\n            while n != 0:\\n                res += n % 2\\n                n = n // 2\\n            return res\\n        def toNum(l):\\n            return sum([1 << i for i in l])\\n        def toList(n):\\n            l = []\\n            for i in range(len(nums)):\\n                if n % 2:\\n                    l.append(i)\\n                n = n // 2\\n            return l\\n        def selectBit(n, k):\\n            return [toNum(l) for l in itertools.combinations(toList(n),k)]\\n        def getCompatibility(l):\\n            if len(set([nums[i] for i in l])) != len(l):\\n                return 1000\\n            else:\\n                x = [nums[i] for i in l]\\n                return max(x) - min(x)\\n        \\n        if len(nums) == k:\\n            return 0\\n        if k == 1:\\n            if len(set(nums)) != len(nums):\\n                return -1\\n            else:\\n                return max(nums) - min(nums)\\n        \\n        partition_size = len(nums) // k\\n        n = len(nums)\\n        \\n        buckets = [[] for i in range(n+1)]\\n        for i in range(1, 1 << n):\\n            buckets[countBit(i)].append(i)\\n        dp = [1000 for i in range(1 << n)]\\n        for j in buckets[partition_size]:\\n            dp[j] = getCompatibility(toList(j))\\n        for i in range(partition_size * 2, n+1, partition_size):\\n            for j in buckets[i]:\\n                #print(j, k)\\n                for l in selectBit(j, partition_size):\\n                    dp[j] = min(dp[j], dp[l] + dp[j-l])\\n        if dp[(1 << n) - 1] == 1000:\\n            return -1\\n        return dp[(1 << n) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961572,
                "title": "python-backtrack-memoization",
                "content": "```\\nimport collections\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        size = len(nums)//k\\n        if len(nums)%k!=0:\\n            return False\\n        cnt = [0]*(len(nums)+1)\\n        for i in nums:\\n            cnt[i]+=1\\n        for i in cnt:\\n            if i>k:\\n                return -1\\n        self.res = inf\\n        res = 0\\n        memo = {}\\n        @lru_cache(None)\\n        def dfs(index,k,currsize,currmin,currmax,cnt):\\n            if k==0:\\n                return 0\\n            res = inf\\n            for i in range(index,len(nums)+1):\\n                currnum = i\\n                \\n                if cnt[currnum]>0:\\n                    newcnt = list(cnt)\\n                    newcnt[currnum]-=1\\n                    temp1=currmin \\n                    temp2= currmax\\n                    currmin = min(currmin,currnum)\\n                    currmax = max(currmax,currnum)\\n                    if currsize+1==size:\\n                        res= min(res,currmax-currmin+dfs(0,k-1,0,inf,-inf,tuple(newcnt)))\\n                    else:\\n                        res = min(res,dfs(i+1,k,currsize+1,currmin,currmax,tuple(newcnt)))\\n                    \\n                    currmin = temp1\\n                    currmax = temp2\\n            return res\\n        res = dfs(0,k,0,inf,-inf,tuple(cnt))\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        size = len(nums)//k\\n        if len(nums)%k!=0:\\n            return False\\n        cnt = [0]*(len(nums)+1)\\n        for i in nums:\\n            cnt[i]+=1\\n        for i in cnt:\\n            if i>k:\\n                return -1\\n        self.res = inf\\n        res = 0\\n        memo = {}\\n        @lru_cache(None)\\n        def dfs(index,k,currsize,currmin,currmax,cnt):\\n            if k==0:\\n                return 0\\n            res = inf\\n            for i in range(index,len(nums)+1):\\n                currnum = i\\n                \\n                if cnt[currnum]>0:\\n                    newcnt = list(cnt)\\n                    newcnt[currnum]-=1\\n                    temp1=currmin \\n                    temp2= currmax\\n                    currmin = min(currmin,currnum)\\n                    currmax = max(currmax,currnum)\\n                    if currsize+1==size:\\n                        res= min(res,currmax-currmin+dfs(0,k-1,0,inf,-inf,tuple(newcnt)))\\n                    else:\\n                        res = min(res,dfs(i+1,k,currsize+1,currmin,currmax,tuple(newcnt)))\\n                    \\n                    currmin = temp1\\n                    currmax = temp2\\n            return res\\n        res = dfs(0,k,0,inf,-inf,tuple(cnt))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961568,
                "title": "python-dfs-branch-and-bound",
                "content": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        bucket = [set() for _ in range(k)]\\n        self.ans = math.inf\\n        def dfs(i):\\n            res = 0\\n            for b in bucket:\\n                if b:\\n                    res += max(b) - min(b)\\n            if res >= self.ans:\\n                return\\n            if i == n:\\n                self.ans = min(self.ans, res)\\n            else:\\n                seen = set()\\n                for b in bucket:\\n                    if tuple(b) not in seen and nums[i] not in b and len(b) < n // k:\\n                        b.add(nums[i])\\n                        dfs(i + 1)\\n                        b.discard(nums[i])\\n                        seen.add(tuple(b))\\n        dfs(0)\\n        return -1 if self.ans == math.inf else self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        bucket = [set() for _ in range(k)]\\n        self.ans = math.inf\\n        def dfs(i):\\n            res = 0\\n            for b in bucket:\\n                if b:\\n                    res += max(b) - min(b)\\n            if res >= self.ans:\\n                return\\n            if i == n:\\n                self.ans = min(self.ans, res)\\n            else:\\n                seen = set()\\n                for b in bucket:\\n                    if tuple(b) not in seen and nums[i] not in b and len(b) < n // k:\\n                        b.add(nums[i])\\n                        dfs(i + 1)\\n                        b.discard(nums[i])\\n                        seen.add(tuple(b))\\n        dfs(0)\\n        return -1 if self.ans == math.inf else self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448659,
                "title": "c-dp-solution-with-brief-comment-o-n-n-2-n-31-lines-56ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 0x3f3f3f3f;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int sz = n/k; // size of every group\\n      //dp(mask, i) select mask, pre select i\\n      //if (bit set of mask) == sz, select first available\\n      //else select first after i available\\n      sort(nums.begin(), nums.end());\\n      int dp[1<<n][n];\\n      memset(dp, inf, sizeof(dp));\\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\\n      for (int m = 0; m < (1<<n)-1; ++m) {\\n        int cnt = __builtin_popcount(m);\\n        for (int i = 0; i < n; ++i) {\\n          if (dp[m][i] == inf) { continue; }\\n          if (cnt%sz == 0) {\\n            int j = __builtin_ffs(~m)-1;\\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\\n          } else {\\n            for (int j = i+1; j < n; ++j) {\\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\\n            }\\n          }\\n        }\\n      }\\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int inf = 0x3f3f3f3f;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int sz = n/k; // size of every group\\n      //dp(mask, i) select mask, pre select i\\n      //if (bit set of mask) == sz, select first available\\n      //else select first after i available\\n      sort(nums.begin(), nums.end());\\n      int dp[1<<n][n];\\n      memset(dp, inf, sizeof(dp));\\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\\n      for (int m = 0; m < (1<<n)-1; ++m) {\\n        int cnt = __builtin_popcount(m);\\n        for (int i = 0; i < n; ++i) {\\n          if (dp[m][i] == inf) { continue; }\\n          if (cnt%sz == 0) {\\n            int j = __builtin_ffs(~m)-1;\\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\\n          } else {\\n            for (int j = i+1; j < n; ++j) {\\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\\n            }\\n          }\\n        }\\n      }\\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418399,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int n ;\\n    int k ;\\n    vector<bool>visited ;\\n    int ret = INT_MAX ;\\n    \\n    void dfs(vector<int>&nums, int cur, int count, int low, int high, int sum){\\n        if(count == n/k){\\n            int i = 0;  \\n            while(i < n && visited[i])\\n                i++ ;\\n            if(i == n){\\n                ret = min(ret , sum + high - low) ;\\n                return ;\\n            }\\n            else{\\n                visited[i] = true ;\\n                dfs(nums, i, 1, nums[i], nums[i], sum + high - low) ;\\n                visited[i] = false ;\\n            }\\n        }\\n        else{\\n            int last = -1 ;\\n            for(int i = cur+1; i < n; i++){\\n                if(visited[i])\\n                    continue ;\\n                if(nums[i] == nums[cur])\\n                    continue ;\\n                if(nums[i] == last)\\n                    continue ;\\n                visited[i] = true ;\\n                dfs(nums, i, count+1, low, nums[i], sum) ;\\n                last = nums[i] ;\\n                visited[i] = false ;\\n            }\\n        }\\n    }\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        this->n = nums.size() ;\\n        this->k = k ;\\n        visited.resize(n) ;\\n        sort(nums.begin(), nums.end() ) ;\\n        int cn = 1 ;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]){\\n                cn++ ;\\n                if(cn > k)\\n                    return -1 ;\\n            }\\n            else\\n                cn = 1 ;\\n        }\\n        if(cn > k)\\n            return -1 ;\\n        visited[0] = true ;\\n        dfs(nums, 0, 1, nums[0], nums[0], 0) ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n ;\\n    int k ;\\n    vector<bool>visited ;\\n    int ret = INT_MAX ;\\n    \\n    void dfs(vector<int>&nums, int cur, int count, int low, int high, int sum){\\n        if(count == n/k){\\n            int i = 0;  \\n            while(i < n && visited[i])\\n                i++ ;\\n            if(i == n){\\n                ret = min(ret , sum + high - low) ;\\n                return ;\\n            }\\n            else{\\n                visited[i] = true ;\\n                dfs(nums, i, 1, nums[i], nums[i], sum + high - low) ;\\n                visited[i] = false ;\\n            }\\n        }\\n        else{\\n            int last = -1 ;\\n            for(int i = cur+1; i < n; i++){\\n                if(visited[i])\\n                    continue ;\\n                if(nums[i] == nums[cur])\\n                    continue ;\\n                if(nums[i] == last)\\n                    continue ;\\n                visited[i] = true ;\\n                dfs(nums, i, count+1, low, nums[i], sum) ;\\n                last = nums[i] ;\\n                visited[i] = false ;\\n            }\\n        }\\n    }\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        this->n = nums.size() ;\\n        this->k = k ;\\n        visited.resize(n) ;\\n        sort(nums.begin(), nums.end() ) ;\\n        int cn = 1 ;\\n        \\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]){\\n                cn++ ;\\n                if(cn > k)\\n                    return -1 ;\\n            }\\n            else\\n                cn = 1 ;\\n        }\\n        if(cn > k)\\n            return -1 ;\\n        visited[0] = true ;\\n        dfs(nums, 0, 1, nums[0], nums[0], 0) ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382252,
                "title": "c-brute-force-with-3-steps-listed-to-not-tle",
                "content": "There are 3 parts to this problem to make it not TLE.\\n1) Backtracking to save memory.\\n2) Don\\'t add number to duplicate columns.\\n3) Do not search for any solution that is less efficient than the found answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        if (k == nums.size()) return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> cur(k, vector<int>(3));\\n        dfs(0, nums, cur, nums.size() / k, 0);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    void dfs(int i, vector<int>& n, vector<vector<int>>& c, int s, int sum){        \\n            if (i == n.size()) ans = min(ans, sum);\\n            if (sum >= ans) return;\\n            set<vector<int>> m;\\n        for (int y = 0; y < c.size(); ++y){\\n            if (c[y][1] == n[i] || c[y][2] == s ||\\n                (c[y][2] == 1 && c[y][0] == n[i]) || m.find(c[y]) != m.end()) continue;\\n            m.insert(c[y]);\\n            if (c[y][2] == 0){\\n                c[y][1] = c[y][0] = n[i], ++c[y][2];\\n                dfs(i + 1, n, c, s, sum);\\n                c[y][1] = c[y][2] = c[y][0] = 0;\\n            }\\n            else{\\n                int prev = c[y][1];\\n                c[y][1] = n[i], ++c[y][2];\\n                dfs(i + 1, n, c, s, sum - (prev - c[y][0]) + (c[y][1] - c[y][0]));\\n                c[y][1] = prev, --c[y][2];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        if (k == nums.size()) return 0;\\n        sort(nums.begin(), nums.end());\\n        vector<vector<int>> cur(k, vector<int>(3));\\n        dfs(0, nums, cur, nums.size() / k, 0);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n    void dfs(int i, vector<int>& n, vector<vector<int>>& c, int s, int sum){        \\n            if (i == n.size()) ans = min(ans, sum);\\n            if (sum >= ans) return;\\n            set<vector<int>> m;\\n        for (int y = 0; y < c.size(); ++y){\\n            if (c[y][1] == n[i] || c[y][2] == s ||\\n                (c[y][2] == 1 && c[y][0] == n[i]) || m.find(c[y]) != m.end()) continue;\\n            m.insert(c[y]);\\n            if (c[y][2] == 0){\\n                c[y][1] = c[y][0] = n[i], ++c[y][2];\\n                dfs(i + 1, n, c, s, sum);\\n                c[y][1] = c[y][2] = c[y][0] = 0;\\n            }\\n            else{\\n                int prev = c[y][1];\\n                c[y][1] = n[i], ++c[y][2];\\n                dfs(i + 1, n, c, s, sum - (prev - c[y][0]) + (c[y][1] - c[y][0]));\\n                c[y][1] = prev, --c[y][2];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209184,
                "title": "backtracking-smart-optimizations-crazy-performance-31ms-for-python",
                "content": "# Intuition\\n\\nThe base idea is backtracking. All possible combinations of subsets are checked using a recursion.\\n\\nIdeas used to implement major backtracking optimizations:\\n\\n1. Backtrack greedily: try combinations with close (to each other) numbers first.\\n2. Exit the current backtracking branch as soon as it\\'s clear that the minimum score won\\'t be beaten. The greedier the combinataion, the higher the chance for it to be the best, therefore the best combination is found quickly, and the rest combinations are skipped early.\\n3. Avoid walking same combinations:\\n    - Don\\'t walk same subsets in different order.\\n    - Don\\'t walk elements of a subset in different order.\\n\\n# Approach\\n\\nThe description implies that you are familiar with the concept of backtracking. The combinations are build subset by subset, each subset is built number by number on is a separate recursion step.\\n\\nA dictionary is used to store the count of each number in `nums`. It\\'s implemented with an array because the variety of numbers is very small and it\\'s much faster than a hash-map.\\n\\nThe backtracking uses it to detect which numbers are not \"put\" into the subsets yet. The actual subsets aren\\'t built, it is not necessary. The dictionary is changed temporarily during the backtracking.\\n\\nThe current minimum sum of incompatibilities (`minScore`) is also stored globally so that any backtracking branch knows the minimum sum and can exit.\\n\\nThe state of backtracking is defined by 3 more values:\\n\\n- `involvedNumsCount` \\u2014 the count of numbers from `nums` that has already been \"put\" into the subsets. When it\\'s equal `len(nums)`, the process is complete (all the numbers have been \"put\" into the subsets).\\n- `score` \\u2014 the current sum of incompatibilities. It\\'s calculated even if the current subset is incomplete. It\\'s possible due to this property:\\n    ```\\n    score\\n    = subset[m-1] - subset[0]\\n    = (subset[m-1] - subset[m-2])\\n      + ...\\n      + (subset[2] - subset[1])\\n      + (subset[1] - subset[0])\\n    ```\\n    where `m` is the size of a complete subset.\\n- `lastNum` \\u2014 if the current subset is incomplete, stores the last number of the subset, otherwise stores `None`. Required to calculate the score for the next step using the formula above, and to know the largest number in the subset.\\n\\nThe code of the recursion step continues the current combination of subsets. It checks each not yet involved number greedily: from the smallest to the largest. Since the variety of numbers is very limited, a simple loop from `1` to `n` is used.\\n\\n- If this is a start of a new subset (`lastNum` is `None`), only the first available number is cheched. It\\'s excessive to check the other numbers because the first available number is a part of some subset anyway. Checking other numbers would lead to building the same combination of subsets in different order (the order of subsets doesn\\'t affect the score).\\n- If this is a continuation of an incomplete subset, check only available numbers that are greater than any number inside the current subset. It ensures that permutations of a subset aren\\'t checked (the order inside the subsets doesn\\'t affect the score).\\n\\nBefore going into the next recursion step, the algorithm checks whether it\\'s impossible to beat the best score in the current situation. If yes, the backtracking branch exits. It\\'s checked by comparing the most optimistic final score with the current minimum final score (`minScore`). The optimistic score is calculated assuming that the rest subsets will contain only adjecent numbers.\\n\\n# Complexity\\n- Time complexity:\\n\\nI don\\'t know, sorry.\\n\\nIf there was no fast exit, the number of steps would be the number of ways to split `nums` into `k` equal subsets: `O(n! / ((n/k)!)^k / k!)` (in the worst case).\\n\\n- Space complexity:\\n\\nThe `nums` counter and the depth of the recursion. Both are `O(n)` in the worst case.\\n\\n# Code\\n```python\\nclass Solution:\\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    subsetSize = int(n / k)\\n    numCounts = [0] * (n + 1)\\n    for num in nums:\\n      numCounts[num] += 1\\n    minScore = math.inf\\n\\n    def backtrack(involvedNumsCount, currentScore, lastNum):\\n      nonlocal minScore\\n\\n      if involvedNumsCount == n:\\n        minScore = currentScore\\n        return\\n\\n      involvedNumsCount += 1\\n      subsetEnd = involvedNumsCount % subsetSize == 0\\n\\n      if lastNum is None:\\n        for num in range(1, n + 2 - subsetSize):\\n          if numCounts[num] == 0:\\n            continue\\n\\n          numCounts[num] -= 1\\n          backtrack(involvedNumsCount, currentScore, None if subsetEnd else num)\\n          numCounts[num] += 1\\n\\n          # Avoids checking same subsets in different order\\n          break\\n      else:\\n        numsLeft = n - involvedNumsCount\\n        # Assuming that the other numbers are adjacent\\n        optimisticRestScore = numsLeft - floor(numsLeft / subsetSize)\\n        \\n        # `lastNum + 1` as the start avoids checking permutations of subsets\\n        for num in range(lastNum + 1, n + 1):\\n          if numCounts[num] == 0:\\n            continue\\n\\n          nextScore = currentScore + num - lastNum\\n          if nextScore + optimisticRestScore >= minScore:\\n            # The next nums will give even bigger score\\n            return\\n\\n          numCounts[num] -= 1\\n          backtrack(involvedNumsCount, nextScore, None if subsetEnd else num)\\n          numCounts[num] += 1\\n    \\n    backtrack(0, 0, None)\\n    return minScore if minScore is not math.inf else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n    score\\n    = subset[m-1] - subset[0]\\n    = (subset[m-1] - subset[m-2])\\n      + ...\\n      + (subset[2] - subset[1])\\n      + (subset[1] - subset[0])\\n    ```\n```python\\nclass Solution:\\n  def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n    n = len(nums)\\n    subsetSize = int(n / k)\\n    numCounts = [0] * (n + 1)\\n    for num in nums:\\n      numCounts[num] += 1\\n    minScore = math.inf\\n\\n    def backtrack(involvedNumsCount, currentScore, lastNum):\\n      nonlocal minScore\\n\\n      if involvedNumsCount == n:\\n        minScore = currentScore\\n        return\\n\\n      involvedNumsCount += 1\\n      subsetEnd = involvedNumsCount % subsetSize == 0\\n\\n      if lastNum is None:\\n        for num in range(1, n + 2 - subsetSize):\\n          if numCounts[num] == 0:\\n            continue\\n\\n          numCounts[num] -= 1\\n          backtrack(involvedNumsCount, currentScore, None if subsetEnd else num)\\n          numCounts[num] += 1\\n\\n          # Avoids checking same subsets in different order\\n          break\\n      else:\\n        numsLeft = n - involvedNumsCount\\n        # Assuming that the other numbers are adjacent\\n        optimisticRestScore = numsLeft - floor(numsLeft / subsetSize)\\n        \\n        # `lastNum + 1` as the start avoids checking permutations of subsets\\n        for num in range(lastNum + 1, n + 1):\\n          if numCounts[num] == 0:\\n            continue\\n\\n          nextScore = currentScore + num - lastNum\\n          if nextScore + optimisticRestScore >= minScore:\\n            # The next nums will give even bigger score\\n            return\\n\\n          numCounts[num] -= 1\\n          backtrack(involvedNumsCount, nextScore, None if subsetEnd else num)\\n          numCounts[num] += 1\\n    \\n    backtrack(0, 0, None)\\n    return minScore if minScore is not math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199534,
                "title": "top-down-recursion-use-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Integer[] mem = new Integer[1<<nums.length];\\n        int min =  min(nums,k,(1<<nums.length)-1,mem);\\n        return min==Integer.MAX_VALUE?-1:min;\\n    }\\n\\n    public int min(int[] nums,int k,int mask,Integer[] mem){\\n        if(mask==0)\\n            return 0;\\n        if(mem[mask]!=null)\\n            return mem[mask];\\n        int min = Integer.MAX_VALUE;\\n        a:\\n        for(int sub = mask;sub>0;sub = (sub-1)&mask){\\n            if(Integer.bitCount(sub)!=nums.length/k)\\n                continue;\\n\\n            TreeSet<Integer> set = new TreeSet<>();\\n            for(int i = 0;i<nums.length;i++){\\n                if((sub&(1<<i))>0){\\n                    if(!set.add(nums[i]))\\n                        continue a;\\n\\n                }\\n            }\\n            int next = min(nums,k,mask&(~sub),mem);\\n            if(next!=Integer.MAX_VALUE){\\n                min = Math.min(min,set.last()-set.first()+next);\\n            }\\n        }\\n        mem[mask] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Integer[] mem = new Integer[1<<nums.length];\\n        int min =  min(nums,k,(1<<nums.length)-1,mem);\\n        return min==Integer.MAX_VALUE?-1:min;\\n    }\\n\\n    public int min(int[] nums,int k,int mask,Integer[] mem){\\n        if(mask==0)\\n            return 0;\\n        if(mem[mask]!=null)\\n            return mem[mask];\\n        int min = Integer.MAX_VALUE;\\n        a:\\n        for(int sub = mask;sub>0;sub = (sub-1)&mask){\\n            if(Integer.bitCount(sub)!=nums.length/k)\\n                continue;\\n\\n            TreeSet<Integer> set = new TreeSet<>();\\n            for(int i = 0;i<nums.length;i++){\\n                if((sub&(1<<i))>0){\\n                    if(!set.add(nums[i]))\\n                        continue a;\\n\\n                }\\n            }\\n            int next = min(nums,k,mask&(~sub),mem);\\n            if(next!=Integer.MAX_VALUE){\\n                min = Math.min(min,set.last()-set.first()+next);\\n            }\\n        }\\n        mem[mask] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131217,
                "title": "c-dp-bitmask-o-n-2-2-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[70000];\\n    int dp(int mask,vector <int> &comb,map <int ,int> &values){\\n        if (mask==0) return 0;\\n        if (memo[mask]!=-1) return memo[mask];\\n        int best=INT_MAX/2;\\n        for (auto &c: comb){\\n            if ((mask & c)==c){\\n                best=min(best,dp(mask ^ c,comb,values)+values[c]);\\n            }\\n        }\\n        return memo[mask]=best;\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        int l=n/k;\\n        memset(memo,-1,sizeof(memo));\\n        map <int ,int> values;\\n        vector <int> comb;\\n        for (int mask=0;mask<(1<<n);mask++){\\n            int val=0;\\n            for (int i=0;i<n;i++){\\n                if ((mask & (1<<i))!=0) val++;\\n            }\\n            if (val==l){\\n                bool flag=true;\\n                vector <int> seen(n+1,0);\\n                vector <int> okay;\\n                for (int j=0;j<n;j++){\\n                    if ((mask & (1<<j))!=0){\\n                        if (seen[nums[j]]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                        seen[nums[j]]=1;\\n                        okay.push_back(nums[j]);\\n                    } \\n                }\\n                if (flag){\\n                    values[mask]=*max_element(okay.begin(),okay.end())-*min_element(okay.begin(),okay.end());\\n                    comb.push_back(mask);\\n                }\\n            }\\n        }\\n        int ans=dp((1<<n)-1,comb,values);\\n        return (ans<INT_MAX/2)?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[70000];\\n    int dp(int mask,vector <int> &comb,map <int ,int> &values){\\n        if (mask==0) return 0;\\n        if (memo[mask]!=-1) return memo[mask];\\n        int best=INT_MAX/2;\\n        for (auto &c: comb){\\n            if ((mask & c)==c){\\n                best=min(best,dp(mask ^ c,comb,values)+values[c]);\\n            }\\n        }\\n        return memo[mask]=best;\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        int l=n/k;\\n        memset(memo,-1,sizeof(memo));\\n        map <int ,int> values;\\n        vector <int> comb;\\n        for (int mask=0;mask<(1<<n);mask++){\\n            int val=0;\\n            for (int i=0;i<n;i++){\\n                if ((mask & (1<<i))!=0) val++;\\n            }\\n            if (val==l){\\n                bool flag=true;\\n                vector <int> seen(n+1,0);\\n                vector <int> okay;\\n                for (int j=0;j<n;j++){\\n                    if ((mask & (1<<j))!=0){\\n                        if (seen[nums[j]]==1){\\n                            flag=false;\\n                            break;\\n                        }\\n                        seen[nums[j]]=1;\\n                        okay.push_back(nums[j]);\\n                    } \\n                }\\n                if (flag){\\n                    values[mask]=*max_element(okay.begin(),okay.end())-*min_element(okay.begin(),okay.end());\\n                    comb.push_back(mask);\\n                }\\n            }\\n        }\\n        int ans=dp((1<<n)-1,comb,values);\\n        return (ans<INT_MAX/2)?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2755332,
                "title": "python-short-dfs-solution-value-based-bitmask",
                "content": "Note all nums[i]<16, we can directly use bitmask to represent the values used in each subset.\\nPruning condition discussed in [this solution](https://leetcode.com/problems/minimum-incompatibility/discuss/961672/Python-DFS-backtracking-pruning-(~100-ms)) will be more efficient with a single mask value.\\n```\\nWith this bitmask, we can efficiently check the following condion\\n1. same combination   --> check value of mask\\n2. avoid duplicate number  -->  check whether the bit in mask is 1 \\n3. bag is full  --> check number of 1 in mask\\n```\\n\\n```\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\tif max(Counter(nums).values())>k:\\n\\t\\treturn -1\\n\\tnums, mask, ans = sorted(nums), [0]*k, max(nums)*k\\n\\n\\tdef score(m):\\n\\t\\tmx = int(log2(m))   # leftmost 1\\'s location - max value\\n\\t\\tmn = int(log2(m&-m)) # rightmost 1\\'s location - min value\\n\\t\\treturn mx-mn\\n\\n\\tdef dfs(i, j, ans):\\n\\t\\tif sum(score(m) for m in mask if m)+len(nums) - j - sum(not m for m in mask) >= ans:\\n\\t\\t\\treturn ans\\n\\t\\t# each unassigned num will increase incompatibility at least by 1\\n\\n\\t\\tif j==len(nums):\\n\\t\\t\\treturn sum(score(m) for m in mask)\\n\\t\\tfor i in range(k):\\n\\t\\t\\tif mask[i].bit_count()<len(nums)//k and (not mask[i]&(1<<nums[j])) and (not i or mask[i-1] != mask[i]):\\n\\t\\t\\t\\tmask[i] |= (1<<nums[j])   # add nums[j] in mask[i]\\n\\t\\t\\t\\tans = dfs(i, j+1, ans)\\n\\t\\t\\t\\tmask[i] ^= (1<<nums[j])  # remove nums[j] in mask[i]\\n\\t\\treturn ans\\n\\n\\treturn dfs(0, 0, ans)\\n```",
                "solutionTags": [],
                "code": "```\\nWith this bitmask, we can efficiently check the following condion\\n1. same combination   --> check value of mask\\n2. avoid duplicate number  -->  check whether the bit in mask is 1 \\n3. bag is full  --> check number of 1 in mask\\n```\n```\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\tif max(Counter(nums).values())>k:\\n\\t\\treturn -1\\n\\tnums, mask, ans = sorted(nums), [0]*k, max(nums)*k\\n\\n\\tdef score(m):\\n\\t\\tmx = int(log2(m))   # leftmost 1\\'s location - max value\\n\\t\\tmn = int(log2(m&-m)) # rightmost 1\\'s location - min value\\n\\t\\treturn mx-mn\\n\\n\\tdef dfs(i, j, ans):\\n\\t\\tif sum(score(m) for m in mask if m)+len(nums) - j - sum(not m for m in mask) >= ans:\\n\\t\\t\\treturn ans\\n\\t\\t# each unassigned num will increase incompatibility at least by 1\\n\\n\\t\\tif j==len(nums):\\n\\t\\t\\treturn sum(score(m) for m in mask)\\n\\t\\tfor i in range(k):\\n\\t\\t\\tif mask[i].bit_count()<len(nums)//k and (not mask[i]&(1<<nums[j])) and (not i or mask[i-1] != mask[i]):\\n\\t\\t\\t\\tmask[i] |= (1<<nums[j])   # add nums[j] in mask[i]\\n\\t\\t\\t\\tans = dfs(i, j+1, ans)\\n\\t\\t\\t\\tmask[i] ^= (1<<nums[j])  # remove nums[j] in mask[i]\\n\\t\\treturn ans\\n\\n\\treturn dfs(0, 0, ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2742012,
                "title": "no-dp-no-recursion-c-graph-solution",
                "content": "class Solution {\\npublic:\\n\\n    \\n    int minimumIncompatibility(vector<int>& arr, int k) {\\n        \\n        \\n        int n = arr.size();\\n        \\n        vector<int> masks;\\n        unordered_map<int, int> cost;\\n        k = n / k;\\n        \\n        for(int i = 0; i < (1 << n); i++)\\n        {\\n            int x = __builtin_popcount(i);\\n            \\n            \\n            if(x == k)\\n            {\\n                int mask = 0;\\n                bool flag = 1;\\n                \\n                for(int j = 0; j < n; j++)\\n                if(i & (1 << j))\\n                {\\n                      if(mask & (1 << arr[j]))\\n                        {\\n                            flag = 0;\\n                            break;\\n                        }\\n                    else mask = mask | (1 << arr[j]);\\n                }\\n                     \\n                if(flag)\\n                {\\n                     masks.push_back(i);\\n                    \\n                     int x = 0;\\n                    \\n                     for(int k = 16; k >= 0; k--)\\n                         if(mask & (1 << k))\\n                         {\\n                             x = k;\\n                             break;\\n                         }\\n                    \\n                    for(int k = 0; k <= 16; k++)\\n                        if(mask & (1 << k))\\n                        {\\n                            x = x - k;\\n                            break;\\n                        }\\n                             \\n                     cost[i] = x;\\n\\n                }\\n                 \\n            }\\n            \\n        }\\n        \\n       \\n\\n       priority_queue< pair<int, int> , vector< pair<int, int> >, greater< pair<int, int> > > pq;\\n        \\n        int x = (1 << n) - 1;\\n        int m = masks.size();\\n        \\n        vector<int> dis(1 << n, 1e9);\\n        \\n        pq.push({0, x});\\n        \\n        dis[x] = 0;\\n        \\n        \\n        while(pq.size())\\n        {\\n            auto pr = pq.top();\\n            pq.pop();\\n            \\n            int mask = pr.second;\\n            int d = pr.first;\\n            \\n            if(d > dis[mask])\\n                continue;\\n\\n            if(mask == 0)\\n                return dis[0];\\n            \\n            for(int i = 0; i < m; i++)\\n                if((masks[i] & (mask)) == masks[i])\\n                {\\n                     if(dis[masks[i] ^ mask] > (d + cost[masks[i]]))\\n                     {\\n                         dis[masks[i] ^ mask] = d + cost[masks[i]];\\n                         pq.push({dis[masks[i] ^ mask], mask ^ masks[i]});\\n                     }\\n                }\\n            \\n        \\n        }\\n        \\n        return -1;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    \\n    int minimumIncompatibility(vector<int>& arr, int k) {\\n        \\n        \\n        int n = arr.size();\\n        \\n        vector<int> masks;\\n        unordered_map<int, int> cost;\\n        k = n / k;\\n        \\n        for(int i = 0; i < (1 << n); i++)\\n        {\\n            int x = __builtin_popcount(i);\\n            \\n            \\n            if(x == k)\\n            {\\n                int mask = 0;\\n                bool flag = 1;\\n                \\n                for(int j = 0; j < n; j++)\\n                if(i & (1 << j))\\n                {\\n                      if(mask & (1 << arr[j]))\\n                        {\\n                            flag = 0;\\n                            break;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2735702,
                "title": "python-dfs-backtracking-pruning-solution-faster-than-100-91ms",
                "content": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        ctrNums = Counter(nums)\\n        if any(ctrNums[num] > k for num in ctrNums):\\n            return -1\\n        bags, res, sz = [[] for _ in range(k)], inf, len(nums)\\n        maxNumsperBag, numbers = sz // k, sorted(ctrNums.keys())\\n        nums.sort()\\n        curSize, curBag, gaps, gapsSum = 0, [], defaultdict(int), defaultdict(int)\\n        cntUniqueNums = len(numbers)\\n        for i in range(1, cntUniqueNums):\\n            gaps[numbers[i]] = numbers[i] - numbers[i - 1]\\n        for i in range(sz - 1, -1, -1):\\n            curBag.append(gaps[nums[i]])\\n            curBag.sort()\\n            curSize += gaps[nums[i]]\\n            gapsSum[i, 0] = curSize\\n            for empty in range(1, min(k + 1, len(curBag))):\\n                gapsSum[i, empty] = gapsSum[i, empty - 1] - curBag[-empty]\\n        \\n        def dfs(i: int, curRes: int, emptyBags: int) -> None:\\n            nonlocal res\\n            if i == sz:\\n                res = min(res, curRes)\\n                return\\n            if curRes + gapsSum[i, emptyBags] >= res: \\n                return\\n            for j in range(k):\\n                if (j > 0 and bags[j] == bags[j - 1]) or (bags[j] and bags[j][-1] == nums[i]) or (len(bags[j])) == maxNumsperBag:\\n                    continue\\n                else:\\n                    bags[j].append(nums[i])\\n                    if len(bags[j]) == 1:\\n                        dfs(i + 1, curRes, emptyBags - 1)\\n                    else:\\n                        dfs(i + 1, curRes + bags[j][-1] - bags[j][-2], emptyBags)\\n                    bags[j].pop()\\n        \\n        dfs(0, 0, k)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        ctrNums = Counter(nums)\\n        if any(ctrNums[num] > k for num in ctrNums):\\n            return -1\\n        bags, res, sz = [[] for _ in range(k)], inf, len(nums)\\n        maxNumsperBag, numbers = sz // k, sorted(ctrNums.keys())\\n        nums.sort()\\n        curSize, curBag, gaps, gapsSum = 0, [], defaultdict(int), defaultdict(int)\\n        cntUniqueNums = len(numbers)\\n        for i in range(1, cntUniqueNums):\\n            gaps[numbers[i]] = numbers[i] - numbers[i - 1]\\n        for i in range(sz - 1, -1, -1):\\n            curBag.append(gaps[nums[i]])\\n            curBag.sort()\\n            curSize += gaps[nums[i]]\\n            gapsSum[i, 0] = curSize\\n            for empty in range(1, min(k + 1, len(curBag))):\\n                gapsSum[i, empty] = gapsSum[i, empty - 1] - curBag[-empty]\\n        \\n        def dfs(i: int, curRes: int, emptyBags: int) -> None:\\n            nonlocal res\\n            if i == sz:\\n                res = min(res, curRes)\\n                return\\n            if curRes + gapsSum[i, emptyBags] >= res: \\n                return\\n            for j in range(k):\\n                if (j > 0 and bags[j] == bags[j - 1]) or (bags[j] and bags[j][-1] == nums[i]) or (len(bags[j])) == maxNumsperBag:\\n                    continue\\n                else:\\n                    bags[j].append(nums[i])\\n                    if len(bags[j]) == 1:\\n                        dfs(i + 1, curRes, emptyBags - 1)\\n                    else:\\n                        dfs(i + 1, curRes + bags[j][-1] - bags[j][-2], emptyBags)\\n                    bags[j].pop()\\n        \\n        dfs(0, 0, k)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601654,
                "title": "tc-90-pruning-brute-force-dfs-explained-python",
                "content": "```\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\t\\t#this problem is very similar to Fair distribution of cookies but harder because len(nums)=16\\n        n = len(nums)\\n        bagSize = n//k\\n        nums.sort()#sorting really helps with pruning conditions\\n        def distribute(index, cand): \\n            nonlocal ans\\n            # Pruning condition 1\\n            # n - index - sum(not x for x in bags) represents number of unused items after empty bags have one item,\\n            # each unused item will increase the incompatibility (diff) by atleast one\\n            # so if the min_increase in compatibility is worse than our current answer, terminate that branch\\n            if cand + n - index - sum(not x for x in bags) > ans: return \\n            if index == len(nums): ans = cand\\n            else: \\n                for b_i in range(k):\\n                    # bags[b_i][-1] != nums[index] is used to avoid duplicate num in the same bag (not allowed)\\n                    # Pruning Condition 2 -> very important\\n                    # bags[b_i-1] != bags[b_i] is used to avoid duplicate bags, i.e same bag but different index\\n                    if len(bags[b_i])<bagSize and (not bags[b_i] or bags[b_i][-1]!=nums[index]) and (not b_i or bags[b_i-1]!=bags[b_i]):\\n                        bags[b_i].append(nums[index])\\n                        if len(bags[b_i]) == 1: distribute(index+1, cand)\\n                        #two ways to calculate incompatibility\\n                        #[0,2,5] => (2-0) + (5-2) == (5-0) = incompatibility\\n                        else: distribute(index+1, cand + bags[b_i][-1] - bags[b_i][-2])\\n                        bags[b_i].pop()\\n        \\n        ans = inf\\n        bags = [[] for _ in range(k)]\\n        distribute(0, 0)\\n        return ans if ans < inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\t\\t#this problem is very similar to Fair distribution of cookies but harder because len(nums)=16\\n        n = len(nums)\\n        bagSize = n//k\\n        nums.sort()#sorting really helps with pruning conditions\\n        def distribute(index, cand): \\n            nonlocal ans\\n            # Pruning condition 1\\n            # n - index - sum(not x for x in bags) represents number of unused items after empty bags have one item,\\n            # each unused item will increase the incompatibility (diff) by atleast one\\n            # so if the min_increase in compatibility is worse than our current answer, terminate that branch\\n            if cand + n - index - sum(not x for x in bags) > ans: return \\n            if index == len(nums): ans = cand\\n            else: \\n                for b_i in range(k):\\n                    # bags[b_i][-1] != nums[index] is used to avoid duplicate num in the same bag (not allowed)\\n                    # Pruning Condition 2 -> very important\\n                    # bags[b_i-1] != bags[b_i] is used to avoid duplicate bags, i.e same bag but different index\\n                    if len(bags[b_i])<bagSize and (not bags[b_i] or bags[b_i][-1]!=nums[index]) and (not b_i or bags[b_i-1]!=bags[b_i]):\\n                        bags[b_i].append(nums[index])\\n                        if len(bags[b_i]) == 1: distribute(index+1, cand)\\n                        #two ways to calculate incompatibility\\n                        #[0,2,5] => (2-0) + (5-2) == (5-0) = incompatibility\\n                        else: distribute(index+1, cand + bags[b_i][-1] - bags[b_i][-2])\\n                        bags[b_i].pop()\\n        \\n        ans = inf\\n        bags = [[] for _ in range(k)]\\n        distribute(0, 0)\\n        return ans if ans < inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292073,
                "title": "java-iterative-dp-2-codes",
                "content": "#### Update.\\nThanks to the top-voted post @DBabichev. I implemented his/her/their idea in Java here. \\nA bit slower than my first version (464ms) but a lot more concise.\\n#### Java\\n```Java\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        k=nums.length/k;\\n        int n = nums.length,INF=100;\\n        int[][] dp = new int[1<<n][n];\\n        for (int[] d : dp){\\n            Arrays.fill(d, INF);\\n        }\\n        for (int i=0;i<n;i++){\\n            dp[1<<i][i]=0;\\n        }\\n        for (int i = 1; i < 1<<n; i++){\\n            int c = Integer.bitCount(i);\\n            for (int j=0;j<n&&c%k==0;j++){\\n                for (int w=0;w<n&&(i&1<<j)>0;w++){\\n                    if ((i&1<<w)==0){\\n                        dp[i|1<<w][w]=Math.min(dp[i|1<<w][w], dp[i][j]);\\n                    }\\n                }\\n            }\\n            for (int j=0;j<n&&c%k!=0;j++){\\n                for (int w=j+1;w<n&&(i&1<<j)>0;w++){\\n                    if ((i&1<<w)==0&&nums[w]!=nums[j]){\\n                        dp[i|1<<w][w]=Math.min(dp[i|1<<w][w], dp[i][j]+nums[w]-nums[j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = Arrays.stream(dp[(1<<n)-1]).min().getAsInt();\\n        return ans==INF?-1:ans;\\n    }\\n}\\n```\\n#### OLD\\nNot the way we are supposed to do bottom-up DP, but I could only come up with 2 bottom-up DP approaches.\\n1. Get the base case first and use submask trick. This will result in a lot of unnecessary computation as we will be skipping lots of masks whose bit set isn\\'t `n/k`. will run in `O(3^n)`.\\n\\n2. Go for `O(2^n)` & don\\'t use submask trick but use bitset to prune masks. This should ideally be faster? I am not quite sure. Depending on test cases.\\n\\nHere I am presenting the second way.\\n\\nIt passed (AC) with average speed (about 300ms).\\n\\n#### Java\\n```Java\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length/k,cnt=0,INF=100;\\n        BitSet[] bits = new BitSet[nums.length];\\n        Arrays.setAll(bits, o -> new BitSet());\\n        int[] dp = new int[1<<nums.length];\\n        int[] map = new int[1<<nums.length];\\n        Arrays.fill(dp, INF);\\n        int[] seen = new int[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            seen[nums[i]]=i;\\n        }\\n        for (int v = (1<<n)-1; v<1<<nums.length; v=next(v)){ // base case\\n            int max = 0, min = INF;\\n            boolean ok = true;\\n            for (int j = 0; j < nums.length&&ok; j++){\\n                if ((v&1<<j)>0){\\n                    ok &= !(seen[nums[j]]!=j&&(v&1<<seen[nums[j]])>0);\\n                    seen[nums[j]]=j;\\n                    min=Math.min(min, nums[j]);\\n                    max=Math.max(max, nums[j]);\\n                }\\n            }\\n            for (int j = 0; j < nums.length && ok; j++){\\n                if ((v&1<<j)==0){\\n                    bits[j].set(cnt); // set the mask\\n                }\\n            }\\n            if (ok){\\n                dp[v]=max-min;\\n                map[cnt++]=v;\\n            }\\n        }\\n        for (int i = 1; i < k; i++){ // DP\\n            for (int v = (1<<i*n)-1; v<1<<nums.length; v=next(v)){\\n                BitSet cur = new BitSet();\\n                cur.set(0, cnt);\\n                for (int j = 0; j < nums.length; j++){\\n                    if ((v&1<<j)>0){ // prune unfit (contradictory) candidates\\n                        cur.and(bits[j]);\\n                    }\\n                }\\n                for (int j = cur.nextSetBit(0); j>=0; j=cur.nextSetBit(j+1)){\\n                    dp[map[j]|v]=Math.min(dp[map[j]|v],dp[map[j]]+dp[v]);\\n                }\\n            }\\n        }\\n        return dp[(1<<nums.length)-1]==INF?-1:dp[(1<<nums.length)-1];\\n    }\\n\\n    private int next(int v){ // gen the next mask\\n        int t = (v | (v - 1)) + 1;\\n        v = t | ((((t & -t) / (v & -v)) >> 1) - 1);\\n        return v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        k=nums.length/k;\\n        int n = nums.length,INF=100;\\n        int[][] dp = new int[1<<n][n];\\n        for (int[] d : dp){\\n            Arrays.fill(d, INF);\\n        }\\n        for (int i=0;i<n;i++){\\n            dp[1<<i][i]=0;\\n        }\\n        for (int i = 1; i < 1<<n; i++){\\n            int c = Integer.bitCount(i);\\n            for (int j=0;j<n&&c%k==0;j++){\\n                for (int w=0;w<n&&(i&1<<j)>0;w++){\\n                    if ((i&1<<w)==0){\\n                        dp[i|1<<w][w]=Math.min(dp[i|1<<w][w], dp[i][j]);\\n                    }\\n                }\\n            }\\n            for (int j=0;j<n&&c%k!=0;j++){\\n                for (int w=j+1;w<n&&(i&1<<j)>0;w++){\\n                    if ((i&1<<w)==0&&nums[w]!=nums[j]){\\n                        dp[i|1<<w][w]=Math.min(dp[i|1<<w][w], dp[i][j]+nums[w]-nums[j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = Arrays.stream(dp[(1<<n)-1]).min().getAsInt();\\n        return ans==INF?-1:ans;\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length/k,cnt=0,INF=100;\\n        BitSet[] bits = new BitSet[nums.length];\\n        Arrays.setAll(bits, o -> new BitSet());\\n        int[] dp = new int[1<<nums.length];\\n        int[] map = new int[1<<nums.length];\\n        Arrays.fill(dp, INF);\\n        int[] seen = new int[nums.length+1];\\n        for (int i = 0; i < nums.length; i++){\\n            seen[nums[i]]=i;\\n        }\\n        for (int v = (1<<n)-1; v<1<<nums.length; v=next(v)){ // base case\\n            int max = 0, min = INF;\\n            boolean ok = true;\\n            for (int j = 0; j < nums.length&&ok; j++){\\n                if ((v&1<<j)>0){\\n                    ok &= !(seen[nums[j]]!=j&&(v&1<<seen[nums[j]])>0);\\n                    seen[nums[j]]=j;\\n                    min=Math.min(min, nums[j]);\\n                    max=Math.max(max, nums[j]);\\n                }\\n            }\\n            for (int j = 0; j < nums.length && ok; j++){\\n                if ((v&1<<j)==0){\\n                    bits[j].set(cnt); // set the mask\\n                }\\n            }\\n            if (ok){\\n                dp[v]=max-min;\\n                map[cnt++]=v;\\n            }\\n        }\\n        for (int i = 1; i < k; i++){ // DP\\n            for (int v = (1<<i*n)-1; v<1<<nums.length; v=next(v)){\\n                BitSet cur = new BitSet();\\n                cur.set(0, cnt);\\n                for (int j = 0; j < nums.length; j++){\\n                    if ((v&1<<j)>0){ // prune unfit (contradictory) candidates\\n                        cur.and(bits[j]);\\n                    }\\n                }\\n                for (int j = cur.nextSetBit(0); j>=0; j=cur.nextSetBit(j+1)){\\n                    dp[map[j]|v]=Math.min(dp[map[j]|v],dp[map[j]]+dp[v]);\\n                }\\n            }\\n        }\\n        return dp[(1<<nums.length)-1]==INF?-1:dp[(1<<nums.length)-1];\\n    }\\n\\n    private int next(int v){ // gen the next mask\\n        int t = (v | (v - 1)) + 1;\\n        v = t | ((((t & -t) / (v & -v)) >> 1) - 1);\\n        return v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195621,
                "title": "c-o-3-n-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int leftmostbit(int x){\\n        return __builtin_ffs(x)-1;\\n    }\\n    int rightmostbit(int x){\\n        return 31 - __builtin_clz(x);\\n    }\\n    \\n    int minCompat(int mask, vector<int>& nums){\\n        int rsb = rightmostbit(mask);\\n        int lsb = leftmostbit(mask);\\n        int prev = lsb;\\n        for(int i=lsb+1; i<=rsb; i++){\\n            if(mask&(1<<i)){\\n                if(nums[prev] == nums[i])\\n                    return INT_MAX;\\n                prev = i;\\n            }\\n        }\\n        return  nums[rsb] - nums[lsb];\\n    }\\n    \\n    const int N = 16+1;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        \\n        if(n%k!=0)\\n            return -1;\\n        int np = n/k;\\n        vector<int>freq(N);\\n        for(auto& x:nums){\\n            freq[x]++;\\n            if(freq[x]>k)\\n                return -1;\\n        }\\n        \\n        int fmask = (1<<n)-1;\\n        \\n        sort(nums.begin(), nums.end());\\n      \\n        vector<long>dp(fmask+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int mask=1; mask<fmask+1; mask++){\\n            if(__builtin_popcount(mask)%np != 0)\\n                continue;\\n            for(int submask = mask; submask>0; submask = (submask-1)&mask){\\n                if(__builtin_popcount(submask) != np)\\n                    continue;\\n                dp[mask] = min(dp[mask], dp[mask-submask] + minCompat(submask, nums));\\n            }\\n        }\\n        \\n        return dp[fmask];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int leftmostbit(int x){\\n        return __builtin_ffs(x)-1;\\n    }\\n    int rightmostbit(int x){\\n        return 31 - __builtin_clz(x);\\n    }\\n    \\n    int minCompat(int mask, vector<int>& nums){\\n        int rsb = rightmostbit(mask);\\n        int lsb = leftmostbit(mask);\\n        int prev = lsb;\\n        for(int i=lsb+1; i<=rsb; i++){\\n            if(mask&(1<<i)){\\n                if(nums[prev] == nums[i])\\n                    return INT_MAX;\\n                prev = i;\\n            }\\n        }\\n        return  nums[rsb] - nums[lsb];\\n    }\\n    \\n    const int N = 16+1;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n        \\n        if(n%k!=0)\\n            return -1;\\n        int np = n/k;\\n        vector<int>freq(N);\\n        for(auto& x:nums){\\n            freq[x]++;\\n            if(freq[x]>k)\\n                return -1;\\n        }\\n        \\n        int fmask = (1<<n)-1;\\n        \\n        sort(nums.begin(), nums.end());\\n      \\n        vector<long>dp(fmask+1,INT_MAX);\\n        dp[0] = 0;\\n        for(int mask=1; mask<fmask+1; mask++){\\n            if(__builtin_popcount(mask)%np != 0)\\n                continue;\\n            for(int submask = mask; submask>0; submask = (submask-1)&mask){\\n                if(__builtin_popcount(submask) != np)\\n                    continue;\\n                dp[mask] = min(dp[mask], dp[mask-submask] + minCompat(submask, nums));\\n            }\\n        }\\n        \\n        return dp[fmask];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324788,
                "title": "java-backtracking-with-smart-pruning-1ms-beats-100",
                "content": "```\\nclass Solution {\\n    Node [] nodes;\\n    int size;\\n    int result = 1_000_000;\\n    \\n    int currentSum;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        size = nums.length / k;\\n        \\n        nodes = new Node[k];\\n        \\n        for (int i = 0; i < k; ++i)\\n            nodes[i] = new Node();\\n        \\n        Arrays.sort(nums);\\n        currentSum = 0;\\n        \\n        solve (nums, 0);\\n        \\n        return result == 1_000_000 ? -1 : result;\\n    }\\n    \\n    private void solve (int [] nums, int idx){\\n        if (idx == nums.length){\\n            result = currentSum;\\n            return;\\n        }\\n        \\n        int minSize = size;\\n        \\n        int prevMin, prevMax, diff;\\n        \\n        for (Node node : nodes){\\n            if (node.size == minSize || node.visited[nums[idx]])\\n                continue;\\n            \\n            minSize = node.size;\\n            \\n            prevMin = node.min;\\n            prevMax = node.max;\\n            \\n            diff = prevMax - prevMin;\\n            \\n            node.min = Math.min(node.min, nums[idx]);\\n            node.max = Math.max(node.max, nums[idx]);\\n            node.size++;\\n            node.visited[nums[idx]] = true;\\n            \\n            if (prevMin == 20){\\n                currentSum += node.max - node.min;\\n            }else {\\n                currentSum += node.max - node.min - diff;\\n            }\\n            \\n            if (currentSum < result)\\n                solve (nums, idx + 1);\\n            \\n            if (prevMin == 20){\\n                currentSum -= node.max - node.min;\\n            }else {\\n                currentSum -= node.max - node.min - diff;\\n            }\\n            \\n            node.visited[nums[idx]] = false;\\n            node.size--;\\n            node.min = prevMin;\\n            node.max = prevMax;\\n        }\\n    }\\n}\\nclass Node {\\n    boolean [] visited;\\n    int size;\\n    int min;\\n    int max;\\n    \\n    Node (){\\n        visited = new boolean[17];\\n        min = 20;\\n        max = 0;\\n        size = 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Node [] nodes;\\n    int size;\\n    int result = 1_000_000;\\n    \\n    int currentSum;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        size = nums.length / k;\\n        \\n        nodes = new Node[k];\\n        \\n        for (int i = 0; i < k; ++i)\\n            nodes[i] = new Node();\\n        \\n        Arrays.sort(nums);\\n        currentSum = 0;\\n        \\n        solve (nums, 0);\\n        \\n        return result == 1_000_000 ? -1 : result;\\n    }\\n    \\n    private void solve (int [] nums, int idx){\\n        if (idx == nums.length){\\n            result = currentSum;\\n            return;\\n        }\\n        \\n        int minSize = size;\\n        \\n        int prevMin, prevMax, diff;\\n        \\n        for (Node node : nodes){\\n            if (node.size == minSize || node.visited[nums[idx]])\\n                continue;\\n            \\n            minSize = node.size;\\n            \\n            prevMin = node.min;\\n            prevMax = node.max;\\n            \\n            diff = prevMax - prevMin;\\n            \\n            node.min = Math.min(node.min, nums[idx]);\\n            node.max = Math.max(node.max, nums[idx]);\\n            node.size++;\\n            node.visited[nums[idx]] = true;\\n            \\n            if (prevMin == 20){\\n                currentSum += node.max - node.min;\\n            }else {\\n                currentSum += node.max - node.min - diff;\\n            }\\n            \\n            if (currentSum < result)\\n                solve (nums, idx + 1);\\n            \\n            if (prevMin == 20){\\n                currentSum -= node.max - node.min;\\n            }else {\\n                currentSum -= node.max - node.min - diff;\\n            }\\n            \\n            node.visited[nums[idx]] = false;\\n            node.size--;\\n            node.min = prevMin;\\n            node.max = prevMax;\\n        }\\n    }\\n}\\nclass Node {\\n    boolean [] visited;\\n    int size;\\n    int min;\\n    int max;\\n    \\n    Node (){\\n        visited = new boolean[17];\\n        min = 20;\\n        max = 0;\\n        size = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061121,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int gmin = INT_MAX;\\n    \\n    int dfs(int e,int ma,int mi,vector<int> &nums,int isUsed, vector<int>& b,int nidx,int bidx,int k,int sz,int prev){\\n        \\n        if(bidx == k){\\n            gmin = min(e,gmin);\\n            return e;\\n        }\\n        if( e > gmin) return INT_MAX;\\n        if(bitset<32>(b[bidx]).count() == sz){\\n            return dfs(e + ma - mi,INT_MIN,INT_MAX,nums,isUsed,b,0,bidx+1,k,sz,-1);\\n        }\\n        \\n        \\n        \\n        if(nidx == nums.size()) return INT_MAX;\\n        \\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = nidx; i < nums.size(); i++){\\n            \\n            if(isUsed&(1<<i) || (b[bidx]&(1<<nums[i]) || nums[i] <= prev)) continue;\\n            \\n            \\n            \\n            b[bidx]^=(1<<nums[i]);\\n            isUsed ^= (1<<i);\\n            ans = min(ans,dfs(e,max(ma,nums[i]),min(mi,nums[i]),nums,isUsed,b,i+1,bidx,k,sz,nums[i]));\\n            \\n            b[bidx]^=(1<<nums[i]);\\n            isUsed ^= (1<<i);\\n            \\n            if(b[bidx] == 0) break;\\n            \\n        }\\n   \\n        \\n        return ans;\\n    }\\n    \\n    \\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n          vector<int> b(k);\\n        sort(nums.begin(),nums.end());\\n        //return 0;\\n        int ans = dfs(0,INT_MIN,INT_MAX,nums,0,b,0,0,k,nums.size()/k,-1);\\n        return ans != INT_MAX?ans:-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int gmin = INT_MAX;\\n    \\n    int dfs(int e,int ma,int mi,vector<int> &nums,int isUsed, vector<int>& b,int nidx,int bidx,int k,int sz,int prev){\\n        \\n        if(bidx == k){\\n            gmin = min(e,gmin);\\n            return e;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1050356,
                "title": "rust-solution-4ms",
                "content": "```\\n    pub fn minimum_incompatibility(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(ind: usize, nums: &Vec<i32>, buckets: &mut Vec<VecDeque<i32>>, k: usize, bucket_len: usize, total: i32, res: &mut i32) {\\n            if ind == nums.len() {\\n                *res = total;\\n                return;\\n            }\\n            \\n            for i in 0..buckets.len().min(k + 1) {\\n                if buckets[i].len() < bucket_len &&\\n                    (buckets[i].is_empty() || *buckets[i].back().unwrap() < nums[ind])\\n                 {\\n                    let cur = nums[ind] - *buckets[i].back().unwrap_or(&nums[ind]) + total;\\n                    if cur < *res {\\n                        buckets[i].push_back(nums[ind]);\\n                        dfs(ind + 1, nums, buckets, k.max(i + 1), bucket_len, cur, res);\\n                        buckets[i].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n        let k = k as usize;\\n        let mut buckets = vec![VecDeque::with_capacity(nums.len() / k as usize); k as usize];\\n        let mut res = std::i32::MAX;\\n        dfs(0, &nums, &mut buckets, 0, nums.len() / k as usize, 0, &mut res);\\n        if res == std::i32::MAX {\\n            return -1;\\n        }\\n        res\\n    }\\n```",
                "solutionTags": [
                    "Rust",
                    "Backtracking"
                ],
                "code": "```\\n    pub fn minimum_incompatibility(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(ind: usize, nums: &Vec<i32>, buckets: &mut Vec<VecDeque<i32>>, k: usize, bucket_len: usize, total: i32, res: &mut i32) {\\n            if ind == nums.len() {\\n                *res = total;\\n                return;\\n            }\\n            \\n            for i in 0..buckets.len().min(k + 1) {\\n                if buckets[i].len() < bucket_len &&\\n                    (buckets[i].is_empty() || *buckets[i].back().unwrap() < nums[ind])\\n                 {\\n                    let cur = nums[ind] - *buckets[i].back().unwrap_or(&nums[ind]) + total;\\n                    if cur < *res {\\n                        buckets[i].push_back(nums[ind]);\\n                        dfs(ind + 1, nums, buckets, k.max(i + 1), bucket_len, cur, res);\\n                        buckets[i].pop_back();\\n                    }\\n                }\\n            }\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n        let k = k as usize;\\n        let mut buckets = vec![VecDeque::with_capacity(nums.len() / k as usize); k as usize];\\n        let mut res = std::i32::MAX;\\n        dfs(0, &nums, &mut buckets, 0, nums.len() / k as usize, 0, &mut res);\\n        if res == std::i32::MAX {\\n            return -1;\\n        }\\n        res\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010188,
                "title": "backtracking-and-prune",
                "content": "I didn\\'t get it in the contest but I learned this trick after contest. It costs 4000ms so I think there must be some other solutions which are better, or maybe there are other prune situations I don\\'t know.\\n```\\n\\n# load local leetcode lib\\nimport pathlib\\nlc_lib_path = pathlib.Path(\\'../lc_lib.py\\')\\nif lc_lib_path.exists():\\n    import sys\\n    sys.path.insert(0, \\'..\\')\\n    from lc_lib import *\\n\\nold_print = print\\ndef print(*args, **kwargs):\\n    if lc_lib_path.exists():\\n        old_print(*args, **kwargs)\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        print(nums)\\n        n = len(nums)\\n        elements_per_group = n//k\\n        groups = [SortedList() for _ in range(k)]\\n        inf = float(\\'inf\\')\\n        result = inf\\n\\n        def dfs(i, cur_res):\\n            nonlocal result\\n            if i==n:\\n                result = min(result, cur_res)\\n\\n            if cur_res>=result:\\n                return\\n\\n            num = nums[i]\\n            for j in range(k):\\n                group = groups[j]\\n                if any([\\n                    len(group)>=elements_per_group,\\n                    j>0 and group==groups[j-1],\\n                    num in group,\\n                   ]):\\n                    continue\\n                res_add = 0\\n                if group and (num<group[0] or num>group[-1]):\\n                    res_add = min(abs(num-group[0]), abs(num-group[-1]))\\n                group.add(num)\\n                dfs(i+1, cur_res+res_add)\\n                group.remove(num)\\n                    \\n        dfs(0, 0)\\n        return result if result!=inf else -1\\n\\nif __name__==\\'__main__\\':\\n    if lc_lib_path.exists():\\n        s = Solution()\\n\\n        nums = [1,2,1,4]\\n        k = 2\\n        r = s.minimumIncompatibility(nums,k)\\n        print(r)\\n        print(\\'-\\'*30)\\n\\n        nums = [7,3,16,15,1,13,1,2,14,5,3,10,6,2,7,15]\\n        k = 8\\n        r = s.minimumIncompatibility(nums,k)\\n        print(r)\\n        print(\\'-\\'*30)\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# load local leetcode lib\\nimport pathlib\\nlc_lib_path = pathlib.Path(\\'../lc_lib.py\\')\\nif lc_lib_path.exists():\\n    import sys\\n    sys.path.insert(0, \\'..\\')\\n    from lc_lib import *\\n\\nold_print = print\\ndef print(*args, **kwargs):\\n    if lc_lib_path.exists():\\n        old_print(*args, **kwargs)\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        print(nums)\\n        n = len(nums)\\n        elements_per_group = n//k\\n        groups = [SortedList() for _ in range(k)]\\n        inf = float(\\'inf\\')\\n        result = inf\\n\\n        def dfs(i, cur_res):\\n            nonlocal result\\n            if i==n:\\n                result = min(result, cur_res)\\n\\n            if cur_res>=result:\\n                return\\n\\n            num = nums[i]\\n            for j in range(k):\\n                group = groups[j]\\n                if any([\\n                    len(group)>=elements_per_group,\\n                    j>0 and group==groups[j-1],\\n                    num in group,\\n                   ]):\\n                    continue\\n                res_add = 0\\n                if group and (num<group[0] or num>group[-1]):\\n                    res_add = min(abs(num-group[0]), abs(num-group[-1]))\\n                group.add(num)\\n                dfs(i+1, cur_res+res_add)\\n                group.remove(num)\\n                    \\n        dfs(0, 0)\\n        return result if result!=inf else -1\\n\\nif __name__==\\'__main__\\':\\n    if lc_lib_path.exists():\\n        s = Solution()\\n\\n        nums = [1,2,1,4]\\n        k = 2\\n        r = s.minimumIncompatibility(nums,k)\\n        print(r)\\n        print(\\'-\\'*30)\\n\\n        nums = [7,3,16,15,1,13,1,2,14,5,3,10,6,2,7,15]\\n        k = 8\\n        r = s.minimumIncompatibility(nums,k)\\n        print(r)\\n        print(\\'-\\'*30)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992710,
                "title": "java-with-dp-and-backtracking",
                "content": "```\\nclass Solution {\\n    int MAX=256;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        if(k==nums.length) return 0;\\n        var cnts=new char[16];\\n        Arrays.fill(cnts,\\'0\\');\\n        for(var num:nums) {\\n            cnts[num-1]=(char)(cnts[num-1]+1);\\n            if(cnts[num-1]-\\'0\\'>k) return -1;\\n        }\\n        // each group has n nums\\n        var n=nums.length/k;\\n        return dfs(cnts,n,k,new HashMap<String,Integer>());\\n    }\\n    \\n    int dfs(char[] cnts,int n,int k,Map<String,Integer> dp) {\\n        if(k==0) return 0;\\n        var key=new String(cnts);\\n        var cnt=dp.get(key);\\n        if(cnt==null) {\\n            cnt=helper(cnts,n,k,dp,0,0,new int[n]);\\n            dp.put(key,cnt);\\n        }\\n        return cnt;\\n    }\\n    \\n    int helper(char[] cnts,int n,int k,Map<String,Integer> dp,int idx,int cnt,int[] dest) {\\n        // already get n numbers\\n        if(n==cnt) return dest[n-1]-dest[0]+dfs(cnts,n,k-1,dp);\\n        // ran out of number\\n        if(idx==cnts.length) return MAX;\\n        //skip idx\\n        var res=helper(cnts,n,k,dp,idx+1,cnt,dest);\\n        if(cnts[idx]>\\'0\\') {\\n            // backtracking\\n            cnts[idx]=(char)(cnts[idx]-1);\\n            dest[cnt]=idx;\\n            res=Math.min(res,helper(cnts,n,k,dp,idx+1,cnt+1,dest));\\n            cnts[idx]=(char)(cnts[idx]+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MAX=256;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        if(k==nums.length) return 0;\\n        var cnts=new char[16];\\n        Arrays.fill(cnts,\\'0\\');\\n        for(var num:nums) {\\n            cnts[num-1]=(char)(cnts[num-1]+1);\\n            if(cnts[num-1]-\\'0\\'>k) return -1;\\n        }\\n        // each group has n nums\\n        var n=nums.length/k;\\n        return dfs(cnts,n,k,new HashMap<String,Integer>());\\n    }\\n    \\n    int dfs(char[] cnts,int n,int k,Map<String,Integer> dp) {\\n        if(k==0) return 0;\\n        var key=new String(cnts);\\n        var cnt=dp.get(key);\\n        if(cnt==null) {\\n            cnt=helper(cnts,n,k,dp,0,0,new int[n]);\\n            dp.put(key,cnt);\\n        }\\n        return cnt;\\n    }\\n    \\n    int helper(char[] cnts,int n,int k,Map<String,Integer> dp,int idx,int cnt,int[] dest) {\\n        // already get n numbers\\n        if(n==cnt) return dest[n-1]-dest[0]+dfs(cnts,n,k-1,dp);\\n        // ran out of number\\n        if(idx==cnts.length) return MAX;\\n        //skip idx\\n        var res=helper(cnts,n,k,dp,idx+1,cnt,dest);\\n        if(cnts[idx]>\\'0\\') {\\n            // backtracking\\n            cnts[idx]=(char)(cnts[idx]-1);\\n            dest[cnt]=idx;\\n            res=Math.min(res,helper(cnts,n,k,dp,idx+1,cnt+1,dest));\\n            cnts[idx]=(char)(cnts[idx]+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983460,
                "title": "python-backtracking-dfs-with-pruning",
                "content": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        subsets = tuple([set()] * k)\\n        set_size = n // k\\n        acc = float(\\'inf\\')\\n        \\n        def recur(i: int, subsets: \"Tuple[Set(int)]\") -> int:\\n            res = float(\\'inf\\')\\n            for j in range(k):\\n                if nums[i] not in subsets[j] and len(subsets[j]) < set_size:\\n                    visited = False\\n                    for x in range(j):\\n                        if subsets[x] == subsets[j]:\\n                            visited = True\\n                    if not visited: # pruning: if the same subset has been considered, stop going forward\\n                        new = [s.copy() for s in subsets]\\n                        new[j].add(nums[i])\\n                        curr = check(new)\\n                        if i == n - 1:\\n                            res = min(res, curr)\\n                        else:\\n                            nonlocal acc\\n                            if curr < acc: # pruing: if the current sum of incompatibilities is already bigger than current best result, stop going forward\\n                                res = min(res, recur(i+1, new))\\n            if res < acc:\\n                acc = res\\n            return res\\n        \\n        def check(subsets: \"Tuple[Set(int)]\") -> int:\\n            return sum([max(s) - min(s) if s else 0 for s in subsets])\\n            \\n        \\n        ans = recur(0, subsets)\\n        if ans == float(\\'inf\\'):\\n            ans  = -1\\n        return ans\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        subsets = tuple([set()] * k)\\n        set_size = n // k\\n        acc = float(\\'inf\\')\\n        \\n        def recur(i: int, subsets: \"Tuple[Set(int)]\") -> int:\\n            res = float(\\'inf\\')\\n            for j in range(k):\\n                if nums[i] not in subsets[j] and len(subsets[j]) < set_size:\\n                    visited = False\\n                    for x in range(j):\\n                        if subsets[x] == subsets[j]:\\n                            visited = True\\n                    if not visited: # pruning: if the same subset has been considered, stop going forward\\n                        new = [s.copy() for s in subsets]\\n                        new[j].add(nums[i])\\n                        curr = check(new)\\n                        if i == n - 1:\\n                            res = min(res, curr)\\n                        else:\\n                            nonlocal acc\\n                            if curr < acc: # pruing: if the current sum of incompatibilities is already bigger than current best result, stop going forward\\n                                res = min(res, recur(i+1, new))\\n            if res < acc:\\n                acc = res\\n            return res\\n        \\n        def check(subsets: \"Tuple[Set(int)]\") -> int:\\n            return sum([max(s) - min(s) if s else 0 for s in subsets])\\n            \\n        \\n        ans = recur(0, subsets)\\n        if ans == float(\\'inf\\'):\\n            ans  = -1\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 982264,
                "title": "greedy-stupid-bruteforce-python-o-n-max-k-log-n",
                "content": "Main method sorts list and divides it on left and right (k+1) times. Calc() function tries to greedilly to distribute elements of each part into 0 to k subsets:\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        maxi = (nums[-1] - nums[0] ) * k + 1\\n        ans = maxi\\n        n = len(nums)\\n        pack = n // k\\n        for i in range(k+1):\\n            l = self.calc(nums[0:i*pack], i)\\n            r = self.calc(nums[i*pack:], k-i)\\n            if l >= 0 and r >= 0:\\n                res = l + r\\n                print(i, res)\\n                ans = min(ans, res)\\n        \\n        if ans == maxi: return -1\\n        return ans\\n        \\n    def calc(self, nums: List[int], k: int) -> int:\\n        if not nums or not k: return 0\\n        \\n        c = collections.Counter(nums)\\n        keys = sorted(c.keys())\\n        if max(c.values()) > k: return -1\\n        ans, l, r, s = 0, 0, 0, 0\\n        pack = len(nums) // k\\n        n = len(nums)\\n        pq = []\\n        for subset in range(k):\\n            include = []\\n            size = len(c)\\n            for i in keys:\\n                if i not in c: continue\\n                if k-subset == c[i] or size == pack:\\n                    include.append(i)\\n                    c[i] -= 1\\n                else:\\n                    size -= 1            \\n            \\n            ans += include[-1] - include[0]\\n            \\n            for j in include:\\n                if c[j] == 0:\\n                    del c[j]\\n            \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        maxi = (nums[-1] - nums[0] ) * k + 1\\n        ans = maxi\\n        n = len(nums)\\n        pack = n // k\\n        for i in range(k+1):\\n            l = self.calc(nums[0:i*pack], i)\\n            r = self.calc(nums[i*pack:], k-i)\\n            if l >= 0 and r >= 0:\\n                res = l + r\\n                print(i, res)\\n                ans = min(ans, res)\\n        \\n        if ans == maxi: return -1\\n        return ans\\n        \\n    def calc(self, nums: List[int], k: int) -> int:\\n        if not nums or not k: return 0\\n        \\n        c = collections.Counter(nums)\\n        keys = sorted(c.keys())\\n        if max(c.values()) > k: return -1\\n        ans, l, r, s = 0, 0, 0, 0\\n        pack = len(nums) // k\\n        n = len(nums)\\n        pq = []\\n        for subset in range(k):\\n            include = []\\n            size = len(c)\\n            for i in keys:\\n                if i not in c: continue\\n                if k-subset == c[i] or size == pack:\\n                    include.append(i)\\n                    c[i] -= 1\\n                else:\\n                    size -= 1            \\n            \\n            ans += include[-1] - include[0]\\n            \\n            for j in include:\\n                if c[j] == 0:\\n                    del c[j]\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978825,
                "title": "are-the-duplicate-elements-making-this-problem-difficult",
                "content": "For distinct elements input, we will sort the given array and the split in k equal sized groups and make the answer.\\nI am not able to see the twist in this problem except the duplicates. \\nplease put your thoughts.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 970492,
                "title": "c-top-down-2-n-n-n-tle",
                "content": "Getting the message `56 / 56 test cases passed, but took too long.` after submission.\\n\\n\\n    \\n    int find(int i, int j, vector<int> &nums, int n, int k, vector<vector<int> >&dp) {\\n        \\n        int setBits = 0;\\n        int temp = i;\\n        while (temp > 0) {\\n            if (temp % 2 != 0)\\n                setBits ++;\\n            temp = temp/2;\\n        }\\n        \\n        if (setBits == n)\\n        {\\n            return 0;\\n        }\\n    \\n        \\n        if( j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        int x = j;\\n        \\n        int numberOfElementsInCurrentSubset = setBits % (n/k) ;\\n        while (x < nums.size()) {\\n            \\n            if ( (i & (1 << x)) != 0) {\\n                x++;\\n                continue;\\n            }\\n            \\n            int newX = x+1;\\n            while(newX < nums.size() && nums[x] == nums[newX]) {\\n                newX++;\\n            }\\n            \\n            \\n            ans = min(ans, find(i, newX, nums, n, k, dp));\\n            if(numberOfElementsInCurrentSubset == 0) {\\n                int val =  find ( i | (1 << x), newX, nums, n, k,  dp);\\n                \\n                if(val != INT_MAX)\\n                    ans = min (ans, (-1*nums[x]) + val);\\n                \\n            } else if(numberOfElementsInCurrentSubset == ((n/k)-1)) {\\n                int val =  find(i | ( 1 << x), 0, nums, n, k, dp);\\n                \\n                if (val != INT_MAX)\\n                    ans = min(ans, nums[x] + val);\\n                \\n            } else {\\n                int val =  find ( i | (1 << x), newX, nums, n, k,  dp);\\n                \\n                if(val != INT_MAX)\\n                    ans = min (ans, val);\\n\\n            }\\n            \\n            x = newX; \\n        }\\n        \\n        dp[i][j] = ans;\\n        \\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        if(nums.size() % k != 0 )\\n            return -1;\\n        if( (nums.size() / k) == 1)\\n            return 0;\\n        vector<vector<int> > dp(pow(2, 17), vector<int>(17, -1));\\n        sort(nums.begin(), nums.end());\\n \\n        \\n        int ans = find(0, 0, nums, nums.size(), k, dp);\\n        if(ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "Getting the message `56 / 56 test cases passed, but took too long.` after submission.\\n\\n\\n    \\n    int find(int i, int j, vector<int> &nums, int n, int k, vector<vector<int> >&dp) {\\n        \\n        int setBits = 0;\\n        int temp = i;\\n        while (temp > 0) {\\n            if (temp % 2 != 0)\\n                setBits ++;\\n            temp = temp/2;\\n        }\\n        \\n        if (setBits == n)\\n        {\\n            return 0;\\n        }\\n    \\n        \\n        if( j >= n)\\n            return INT_MAX;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        int x = j;\\n        \\n        int numberOfElementsInCurrentSubset = setBits % (n/k) ;\\n        while (x < nums.size()) {\\n            \\n            if ( (i & (1 << x)) != 0) {\\n                x++;\\n                continue;\\n            }\\n            \\n            int newX = x+1;\\n            while(newX < nums.size() && nums[x] == nums[newX]) {\\n                newX++;\\n            }\\n            \\n            \\n            ans = min(ans, find(i, newX, nums, n, k, dp));\\n            if(numberOfElementsInCurrentSubset == 0) {\\n                int val =  find ( i | (1 << x), newX, nums, n, k,  dp);\\n                \\n                if(val != INT_MAX)\\n                    ans = min (ans, (-1*nums[x]) + val);\\n                \\n            } else if(numberOfElementsInCurrentSubset == ((n/k)-1)) {\\n                int val =  find(i | ( 1 << x), 0, nums, n, k, dp);\\n                \\n                if (val != INT_MAX)\\n                    ans = min(ans, nums[x] + val);\\n                \\n            } else {\\n                int val =  find ( i | (1 << x), newX, nums, n, k,  dp);\\n                \\n                if(val != INT_MAX)\\n                    ans = min (ans, val);\\n\\n            }\\n            \\n            x = newX; \\n        }\\n        \\n        dp[i][j] = ans;\\n        \\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        if(nums.size() % k != 0 )\\n            return -1;\\n        if( (nums.size() / k) == 1)\\n            return 0;\\n        vector<vector<int> > dp(pow(2, 17), vector<int>(17, -1));\\n        sort(nums.begin(), nums.end());\\n \\n        \\n        int ans = find(0, 0, nums, nums.size(), k, dp);\\n        if(ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 963867,
                "title": "java-top-down-dp-with-memo-28ms-beats-88",
                "content": "\\tpublic int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = helper(0, nums, k, 0, new Integer[1 << nums.length]);\\n        return res >= 1000? -1 : res;\\n    }\\n    \\n    private int helper(int blocks, int[] nums, int k, int state, Integer[] memo){\\n        if(blocks == k) return 0;\\n        if(memo[state] != null) return memo[state];\\n        List<int[]> list = new ArrayList();\\n        generateNewBlocks(0, 0, 17, -1, nums, state, 0, nums.length / k, list);\\n        int res = 1000;\\n        for(int[] arr : list){\\n            res = Math.min(res, arr[0] + helper(blocks + 1, nums, k, state | arr[1], memo));\\n        }\\n        return memo[state] = res;\\n    }\\n    \\n    private void generateNewBlocks(int idx, int max, int min, int prev, int[] nums, int state, int mask, int len, List<int[]> list){\\n        if(Integer.bitCount(mask) == len){\\n            list.add(new int[]{max - min, mask});\\n            return;\\n        }\\n        while(idx < nums.length && ((state & (1 << idx)) != 0 || nums[idx] == prev)) idx ++;\\n        if(idx == nums.length) return;\\n        if(mask != 0) generateNewBlocks(idx + 1, max, min, prev, nums, state, mask, len, list);\\n        int newmask = mask | (1 << idx), newmax = Math.max(max, nums[idx]), newmin = Math.min(min, nums[idx]);\\n        generateNewBlocks(idx + 1, newmax, newmin, nums[idx], nums, state, newmask, len, list);\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int minimumIncompatibility(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = helper(0, nums, k, 0, new Integer[1 << nums.length]);\\n        return res >= 1000? -1 : res;\\n    }\\n    \\n    private int helper(int blocks, int[] nums, int k, int state, Integer[] memo){\\n        if(blocks == k) return 0;\\n        if(memo[state] != null) return memo[state];\\n        List<int[]> list = new ArrayList();\\n        generateNewBlocks(0, 0, 17, -1, nums, state, 0, nums.length / k, list);\\n        int res = 1000;\\n        for(int[] arr : list){\\n            res = Math.min(res, arr[0] + helper(blocks + 1, nums, k, state | arr[1], memo));\\n        }\\n        return memo[state] = res;\\n    }\\n    \\n    private void generateNewBlocks(int idx, int max, int min, int prev, int[] nums, int state, int mask, int len, List<int[]> list){\\n        if(Integer.bitCount(mask) == len){\\n            list.add(new int[]{max - min, mask});\\n            return;\\n        }\\n        while(idx < nums.length && ((state & (1 << idx)) != 0 || nums[idx] == prev)) idx ++;\\n        if(idx == nums.length) return;\\n        if(mask != 0) generateNewBlocks(idx + 1, max, min, prev, nums, state, mask, len, list);\\n        int newmask = mask | (1 << idx), newmax = Math.max(max, nums[idx]), newmin = Math.min(min, nums[idx]);\\n        generateNewBlocks(idx + 1, newmax, newmin, nums[idx], nums, state, newmask, len, list);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 963094,
                "title": "ruby-backtracking",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_incompatibility(nums, k)\\n  @sorted_nums, @k = nums.sort.reverse, k\\n\\n  @nums_count = nums.count\\n  @subset_size = @nums_count/k\\n  @subsets = k.times.map{[]}\\n  \\n  @result = Float::INFINITY\\n  \\n  return -1 if @sorted_nums.group_by{|num| num}.values.map(&:count).max > @k\\n  solver(0)\\n  \\n  @result\\nend\\n\\ndef solver(i)\\n  if i == @nums_count\\n    @result = [@result, @k.times.map{|j| @subsets[j].first - @subsets[j].last}.sum].min\\n    return true\\n  end\\n  \\n  flag = 0\\n  @k.times do |j|\\n    if !@subsets[j] || @subsets[j].count < @subset_size && @subsets[j].last != @sorted_nums[i]\\n      @subsets[j] << @sorted_nums[i]\\n      flag += 1 if solver(i + 1)\\n\\n      @subsets[j].pop\\n    end\\n    \\n    break if flag >= 2\\n  end\\n  \\n  flag != 0\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Backtracking"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef minimum_incompatibility(nums, k)\\n  @sorted_nums, @k = nums.sort.reverse, k\\n\\n  @nums_count = nums.count\\n  @subset_size = @nums_count/k\\n  @subsets = k.times.map{[]}\\n  \\n  @result = Float::INFINITY\\n  \\n  return -1 if @sorted_nums.group_by{|num| num}.values.map(&:count).max > @k\\n  solver(0)\\n  \\n  @result\\nend\\n\\ndef solver(i)\\n  if i == @nums_count\\n    @result = [@result, @k.times.map{|j| @subsets[j].first - @subsets[j].last}.sum].min\\n    return true\\n  end\\n  \\n  flag = 0\\n  @k.times do |j|\\n    if !@subsets[j] || @subsets[j].count < @subset_size && @subsets[j].last != @sorted_nums[i]\\n      @subsets[j] << @sorted_nums[i]\\n      flag += 1 if solver(i + 1)\\n\\n      @subsets[j].pop\\n    end\\n    \\n    break if flag >= 2\\n  end\\n  \\n  flag != 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 963001,
                "title": "java-time-o-n-2-n-3-n-space-o-2-n",
                "content": "```\\n    static int MAX_VALUE = Integer.MAX_VALUE/2;\\n    \\n    private int sln1(int[] nums, int k){\\n        int n = nums.length;\\n        int c = n/k;\\n        int[] map = new int[1<<n];\\n\\t\\t//preprocessing O(n*2^n)\\n        for(int i = 0;i< map.length;i++){\\n            int max = -1;\\n            int min = n+1;\\n            if(Integer.bitCount(i) != c) map[i] = MAX_VALUE;\\n            else{\\n                Set<Integer> set = new HashSet<>();\\n                for(int j =0; j< n;j++){\\n                    if((i&(1<<j))!=0) {\\n                        set.add(nums[j]);\\n                        max = Math.max(max, nums[j]);\\n                        min = Math.min(min, nums[j]);\\n                    }\\n                }\\n                if(set.size()==c)  map[i] = max-min;\\n                else map[i] = MAX_VALUE;\\n            }\\n        }\\n\\n        int res = dfs2(k, (1<<n)-1, map, new Integer[1<<n]);\\n        if (res >= MAX_VALUE) return -1;\\n        else return res;\\n    }\\n\\t\\n\\t//O(3^N)\\n\\tprivate int dfs2(int k, int mask, int[] map, Integer[] dp){\\n        if(k == 0) return mask==0? 0 :MAX_VALUE;\\n        if(dp[mask] != null) return dp[mask];\\n        int res = MAX_VALUE;\\n        for(int sub = mask; sub>0; sub = (sub-1)&mask){\\n            if(map[sub] == MAX_VALUE) continue;\\n            res = Math.min(res, dfs2(k-1,  mask^sub, map , dp)+map[sub]);\\n        }\\n        dp[mask] = res;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    static int MAX_VALUE = Integer.MAX_VALUE/2;\\n    \\n    private int sln1(int[] nums, int k){\\n        int n = nums.length;\\n        int c = n/k;\\n        int[] map = new int[1<<n];\\n\\t\\t//preprocessing O(n*2^n)\\n        for(int i = 0;i< map.length;i++){\\n            int max = -1;\\n            int min = n+1;\\n            if(Integer.bitCount(i) != c) map[i] = MAX_VALUE;\\n            else{\\n                Set<Integer> set = new HashSet<>();\\n                for(int j =0; j< n;j++){\\n                    if((i&(1<<j))!=0) {\\n                        set.add(nums[j]);\\n                        max = Math.max(max, nums[j]);\\n                        min = Math.min(min, nums[j]);\\n                    }\\n                }\\n                if(set.size()==c)  map[i] = max-min;\\n                else map[i] = MAX_VALUE;\\n            }\\n        }\\n\\n        int res = dfs2(k, (1<<n)-1, map, new Integer[1<<n]);\\n        if (res >= MAX_VALUE) return -1;\\n        else return res;\\n    }\\n\\t\\n\\t//O(3^N)\\n\\tprivate int dfs2(int k, int mask, int[] map, Integer[] dp){\\n        if(k == 0) return mask==0? 0 :MAX_VALUE;\\n        if(dp[mask] != null) return dp[mask];\\n        int res = MAX_VALUE;\\n        for(int sub = mask; sub>0; sub = (sub-1)&mask){\\n            if(map[sub] == MAX_VALUE) continue;\\n            res = Math.min(res, dfs2(k-1,  mask^sub, map , dp)+map[sub]);\\n        }\\n        dp[mask] = res;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 962982,
                "title": "python3-dp-top-down-with-comments",
                "content": "```python\\n    def minimumIncompatibility(self, A: List[int], k: int) -> int:\\n        n = len(A) # <= 16\\n        if n == k: return 0 # each subset has just one integer\\n        if n % k != 0: return -1\\n        c = Counter(A)\\n        if any(x > k for x in c.values()): return -1\\n        if k == 1: return max(A) - min(A)\\n        gs = n // k # group size\\n        \\n        @lru_cache(None)\\n        def f(A, k):\\n            # there is euqal elements for one subset, invalid, set to float(\\'inf\\')\\n            if 1 == k: return max(A) - min(A) if len(set(A)) == len(A) else float(\\'inf\\')\\n            res, us = float(\\'inf\\'), set(A)\\n            for g in itertools.combinations(us, gs):\\n                s, can, B = Counter(g), max(g) - min(g), list(A)\\n                for x in g: B.remove(x)\\n                res = min(res, can + f(tuple(B), k - 1))\\n            return res\\n        res = f(tuple(A), k)\\n        return -1 if res == float(\\'inf\\') else res\\n```\\t\\t",
                "solutionTags": [],
                "code": "```python\\n    def minimumIncompatibility(self, A: List[int], k: int) -> int:\\n        n = len(A) # <= 16\\n        if n == k: return 0 # each subset has just one integer\\n        if n % k != 0: return -1\\n        c = Counter(A)\\n        if any(x > k for x in c.values()): return -1\\n        if k == 1: return max(A) - min(A)\\n        gs = n // k # group size\\n        \\n        @lru_cache(None)\\n        def f(A, k):\\n            # there is euqal elements for one subset, invalid, set to float(\\'inf\\')\\n            if 1 == k: return max(A) - min(A) if len(set(A)) == len(A) else float(\\'inf\\')\\n            res, us = float(\\'inf\\'), set(A)\\n            for g in itertools.combinations(us, gs):\\n                s, can, B = Counter(g), max(g) - min(g), list(A)\\n                for x in g: B.remove(x)\\n                res = min(res, can + f(tuple(B), k - 1))\\n            return res\\n        res = f(tuple(A), k)\\n        return -1 if res == float(\\'inf\\') else res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 962966,
                "title": "python-104ms-beats-100",
                "content": "```\\nfrom collections import Counter\\nfrom itertools import combinations\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        Ctmp = Counter(nums)\\n        C = [0]*(max(v for v in Ctmp)+1)\\n        for v in Ctmp:\\n            C[v] = Ctmp[v]\\n        \\n        \\n        @lru_cache(None) # I saw this trick from other answers\\n        def dfs(C,k):\\n            if k==0:\\n                return 0\\n            V = [v for v,c in enumerate(C) if c>0]\\n            tot = sum(C)\\n            if max(C)>k:\\n                return None\\n\\n            dev = float(\\'inf\\')\\n\\t\\t\\t# In the following for loop I only count potential \\n\\t\\t\\t# groups that includes the smallest element\\n            for g in combinations(V[1:], tot//k-1):\\n                g = [V[0]]+list(g)\\n                newC = list(C)\\n                for v in g:\\n                    newC[v] -=1\\n                o = dfs(tuple(newC), k-1)\\n                if o is not None:\\n                    dev = min(dev, g[-1]-g[0]+o)\\n\\n            if dev<float(\\'inf\\'):\\n                return int(dev)\\n            return None\\n        \\n        out = dfs(tuple(C), k)\\n        if out is not None:\\n            return out\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom itertools import combinations\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        Ctmp = Counter(nums)\\n        C = [0]*(max(v for v in Ctmp)+1)\\n        for v in Ctmp:\\n            C[v] = Ctmp[v]\\n        \\n        \\n        @lru_cache(None) # I saw this trick from other answers\\n        def dfs(C,k):\\n            if k==0:\\n                return 0\\n            V = [v for v,c in enumerate(C) if c>0]\\n            tot = sum(C)\\n            if max(C)>k:\\n                return None\\n\\n            dev = float(\\'inf\\')\\n\\t\\t\\t# In the following for loop I only count potential \\n\\t\\t\\t# groups that includes the smallest element\\n            for g in combinations(V[1:], tot//k-1):\\n                g = [V[0]]+list(g)\\n                newC = list(C)\\n                for v in g:\\n                    newC[v] -=1\\n                o = dfs(tuple(newC), k-1)\\n                if o is not None:\\n                    dev = min(dev, g[-1]-g[0]+o)\\n\\n            if dev<float(\\'inf\\'):\\n                return int(dev)\\n            return None\\n        \\n        out = dfs(tuple(C), k)\\n        if out is not None:\\n            return out\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962941,
                "title": "java-backtracking-solution-with-optimizations-beats-11-11",
                "content": "```\\nclass Solution {\\n    \\n    int minIncompatability = Integer.MAX_VALUE;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        if (nums.length%k != 0) return -1;\\n        int elementsPerSubset = nums.length / k;\\n        List<Set<Integer>> currentState = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            currentState.add(new HashSet<Integer>());\\n        }\\n        recHelper(0, nums, elementsPerSubset, k, currentState);\\n        \\n        return minIncompatability == Integer.MAX_VALUE ? -1 : minIncompatability;\\n    }\\n    \\n    public List<Set<Integer>> deepCopyState(List<Set<Integer>> currentState) {\\n        List<Set<Integer>> copyOfCurrentState = new ArrayList<>(); \\n        for (Set<Integer> s : currentState) {\\n            copyOfCurrentState.add(new HashSet<>(s)); \\n        } \\n        return copyOfCurrentState;\\n    }\\n    \\n    public int calculateCurrentInCompatability(List<Set<Integer>> solution) {\\n        int sum = 0; \\n        for (Set<Integer> set : solution) {\\n            if (set.size() > 0) sum += set.stream().max(Integer::compare).get() - set.stream().min(Integer::compare).get(); \\n        } \\n        return sum;\\n    }\\n    \\n    public void recHelper(int currentIndex, int[] nums, int elementsPerSubset, int k, List<Set<Integer>> currentState) {\\n        if (currentIndex == nums.length) {\\n            int inCompatability = calculateCurrentInCompatability(currentState);\\n            if (inCompatability < minIncompatability) minIncompatability = inCompatability;\\n        }\\n        else if (currentIndex < nums.length) {\\n            for (int i = 0; i < k; i++) {\\n                List<Set<Integer>> copyOfCurrentState = deepCopyState(currentState);\\n                Set<Integer> set = copyOfCurrentState.get(i);\\n                if (set.size() < elementsPerSubset && !set.contains(nums[currentIndex])) {\\n                    if (set.size() == 0) while(i < k && copyOfCurrentState.get(i).isEmpty()) i++;\\n                    set.add(nums[currentIndex]);\\n                    if (calculateCurrentInCompatability(copyOfCurrentState) <= minIncompatability)\\n                        recHelper(currentIndex+1, nums, elementsPerSubset, k, copyOfCurrentState);\\n                }\\n            }            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int minIncompatability = Integer.MAX_VALUE;\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        if (nums.length%k != 0) return -1;\\n        int elementsPerSubset = nums.length / k;\\n        List<Set<Integer>> currentState = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            currentState.add(new HashSet<Integer>());\\n        }\\n        recHelper(0, nums, elementsPerSubset, k, currentState);\\n        \\n        return minIncompatability == Integer.MAX_VALUE ? -1 : minIncompatability;\\n    }\\n    \\n    public List<Set<Integer>> deepCopyState(List<Set<Integer>> currentState) {\\n        List<Set<Integer>> copyOfCurrentState = new ArrayList<>(); \\n        for (Set<Integer> s : currentState) {\\n            copyOfCurrentState.add(new HashSet<>(s)); \\n        } \\n        return copyOfCurrentState;\\n    }\\n    \\n    public int calculateCurrentInCompatability(List<Set<Integer>> solution) {\\n        int sum = 0; \\n        for (Set<Integer> set : solution) {\\n            if (set.size() > 0) sum += set.stream().max(Integer::compare).get() - set.stream().min(Integer::compare).get(); \\n        } \\n        return sum;\\n    }\\n    \\n    public void recHelper(int currentIndex, int[] nums, int elementsPerSubset, int k, List<Set<Integer>> currentState) {\\n        if (currentIndex == nums.length) {\\n            int inCompatability = calculateCurrentInCompatability(currentState);\\n            if (inCompatability < minIncompatability) minIncompatability = inCompatability;\\n        }\\n        else if (currentIndex < nums.length) {\\n            for (int i = 0; i < k; i++) {\\n                List<Set<Integer>> copyOfCurrentState = deepCopyState(currentState);\\n                Set<Integer> set = copyOfCurrentState.get(i);\\n                if (set.size() < elementsPerSubset && !set.contains(nums[currentIndex])) {\\n                    if (set.size() == 0) while(i < k && copyOfCurrentState.get(i).isEmpty()) i++;\\n                    set.add(nums[currentIndex]);\\n                    if (calculateCurrentInCompatability(copyOfCurrentState) <= minIncompatability)\\n                        recHelper(currentIndex+1, nums, elementsPerSubset, k, copyOfCurrentState);\\n                }\\n            }            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962924,
                "title": "java-backtracking-solution-passed-with-pruning",
                "content": "Idea:\\n* Having `k` buckets and using recursion to try every buckets.\\n* Using `TreeSet` to be the bucket data structure so that we can get minimum and maximum value in the bucket quickly.\\n\\nThe original solution without pruning cannot pass because of TLE. So two pruning ideas to improve the performance:\\n1. If the current accumulated incompatibility has been over the known global minimum incompatibility, then prune this branch.\\n2. The current number should be placed into empty buckets only for once.\\n\\n```\\nclass Solution {\\n    private int global = Integer.MAX_VALUE;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) {\\n            return -1;\\n        }\\n        int s = n / k;\\n        List<TreeSet<Integer>> buckets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            buckets.add(new TreeSet<>());\\n        }\\n        return helper(nums, 0, buckets, s, k);\\n    }\\n    \\n    // TLE without pruning.\\n    private int helper(int[] nums, int pos, List<TreeSet<Integer>> subsets, int s, int k) {\\n        int n = nums.length;\\n        if (pos == n) {\\n            int res = 0;\\n            for (TreeSet<Integer> subset : subsets) {\\n                res += subset.last() - subset.first();\\n            }\\n            global = Math.min(global, res);\\n            return res;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        int current = 0;\\n        for (int i = 0; i < subsets.size(); i++) {\\n            TreeSet<Integer> subset = subsets.get(i);\\n            if (subset.size() == s) {\\n                current += subset.last() - subset.first();\\n            }\\n            // Prune 1: if the current approach have already passed the known minimum, then break;\\n            if (current > global) {\\n                break;\\n            }\\n            // Prune 2: number will only try one empty bucket.\\n            if (i - 1 >= 0 && subsets.get(i - 1).isEmpty()) {\\n                break;\\n            }\\n            if (!subset.contains(nums[pos]) && subset.size() < s) {\\n                subset.add(nums[pos]);\\n                int res = helper(nums, pos + 1, subsets, s, k);\\n                if (res != -1) {\\n                    ans = Math.min(ans, res);\\n                }\\n                subset.remove(nums[pos]);\\n            }\\n        }\\n        if (ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int global = Integer.MAX_VALUE;\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n % k != 0) {\\n            return -1;\\n        }\\n        int s = n / k;\\n        List<TreeSet<Integer>> buckets = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            buckets.add(new TreeSet<>());\\n        }\\n        return helper(nums, 0, buckets, s, k);\\n    }\\n    \\n    // TLE without pruning.\\n    private int helper(int[] nums, int pos, List<TreeSet<Integer>> subsets, int s, int k) {\\n        int n = nums.length;\\n        if (pos == n) {\\n            int res = 0;\\n            for (TreeSet<Integer> subset : subsets) {\\n                res += subset.last() - subset.first();\\n            }\\n            global = Math.min(global, res);\\n            return res;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        int current = 0;\\n        for (int i = 0; i < subsets.size(); i++) {\\n            TreeSet<Integer> subset = subsets.get(i);\\n            if (subset.size() == s) {\\n                current += subset.last() - subset.first();\\n            }\\n            // Prune 1: if the current approach have already passed the known minimum, then break;\\n            if (current > global) {\\n                break;\\n            }\\n            // Prune 2: number will only try one empty bucket.\\n            if (i - 1 >= 0 && subsets.get(i - 1).isEmpty()) {\\n                break;\\n            }\\n            if (!subset.contains(nums[pos]) && subset.size() < s) {\\n                subset.add(nums[pos]);\\n                int res = helper(nums, pos + 1, subsets, s, k);\\n                if (res != -1) {\\n                    ans = Math.min(ans, res);\\n                }\\n                subset.remove(nums[pos]);\\n            }\\n        }\\n        if (ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962691,
                "title": "python-top-down-dp",
                "content": "<details>\\n\\n<summary><b>Approach:</b> (click to show)</summary>\\n\\nEach bin must contain ```nums.length / k``` numbers.\\nIterate over the ```k``` bins and generate all possible\\ncombinations of numbers that can go into each bin.\\n\\nIf a combination contains two of the same number,\\nthen skip that combination.\\n\\nThe cost of selecting a certain combination for a bin\\nis the maximum number in the combination minus\\nthe minimum number in the combination.\\n\\nThe total cost is the cost of the combination selected\\nplus the minimum cost that can be achieved with the\\nremaining numbers.\\n\\n</details>\\n\\n<details>\\n\\n<summary><b>Optimizations:</b> (click to show)</summary>\\n\\n<br>\\n\\n1. If ```nums.length == k``` then there is one bin for every number, the answer is zero.\\n2. If there are more than ```k``` of any number, then there is no solution, the answer is -1.\\n\\n</details>\\n\\n<br>\\n\\n```python\\n# Runtime: 7812 ms (see below for faster solution)\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\t\\tif max(collections.Counter(nums).values()) > k - i:\\n\\t\\t\\treturn math.inf\\n\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums) - min(nums)\\n\\n\\t\\tbest = math.inf\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[i] for i in combo]\\n\\t\\t\\tif len(set(numbers)) == len(numbers):\\n\\t\\t\\t\\tcombo = set(combo)\\n\\t\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple([n for i,n in enumerate(nums) if i not in combo])))\\n\\t\\treturn best\\n\\n\\tif k == len(nums): return 0\\n\\tbin_size = len(nums) // k\\n\\tres = helper(0, tuple(nums))\\n\\treturn -1 if (res == math.inf) else res\\n```\\n\\n<br>\\n\\n<details>\\n\\n<summary><b>Annotated Code:</b> (click to show)</summary>\\n\\n```python\\n#Runtime: 7812 ms: (see below for faster implementation)\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t# If any number occurs more than k times, there is no solution\\n\\tc = collections.Counter(nums)\\n\\tif max(c.values()) > k:\\n\\t\\treturn -1\\n\\n\\t# If there is one bin for each number then the answer zero\\n\\tif k == len(nums):\\n\\t\\treturn 0\\n\\n\\t# This is the size of each bin\\n\\tbin_size = len(nums) // k\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\n\\t\\t# k - 1 bins have been filled, if all the numbers in nums are distinct the remaining nums get binned together\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums) - min(nums) if len(set(nums)) == len(nums) else math.inf\\n\\n\\t\\tbest = math.inf\\n\\n\\t\\t# Consider all combinations of bin_size numbers to place in the current bin\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[i] for i in combo]\\n\\n\\t\\t\\t# Do not place two of the same number into a bin\\n\\t\\t\\tif len(set(numbers)) == len(numbers):\\n\\t\\t\\t\\tcombo = set(combo)\\n\\t\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple([n for i,n in enumerate(nums) if i not in combo])))\\n\\n\\t\\treturn best\\n\\n\\treturn helper(0, tuple(nums))\\n```\\n\\n</details>\\n\\n<details>\\n\\n<summary><b>Faster Solution:</b> 3656 ms (click to show)</summary>\\n\\nThis is the same approach as above, except instead of keeping track\\nof a tuple of the remaining numbers. We keep track of the count for each number:\\n\\n```\\nnums = (1, 1, 1, 2, 3, 3, 4, 5)\\nbecomes\\nnums = ((3, 1), (1, 2), (2, 3), (1, 4), (1, 5))\\n```\\n\\nThis makes the code less readable, but faster to execute.\\nThe reason is because in the first solution, we had to make sure that\\ntwo of the same number did not get grouped together.\\n\\nBy grouping numbers like so, it is guaranteed guarantee that two \\nof the same number will not get grouped together.\\n\\n```python\\n# Runtime: 3656 ms\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\n\\t\\tif max(nums)[0] > k - i:\\n\\t\\t\\treturn math.inf\\n\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums)[1] - min(nums)[1]\\n\\n\\t\\tbest = math.inf\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[j][1] for j in combo]\\n\\t\\t\\tcombo = set(combo)\\n\\t\\t\\tnew_nums = []\\n\\t\\t\\tfor j in range(len(nums)):\\n\\t\\t\\t\\tif j in combo:\\n\\t\\t\\t\\t\\tf, n = nums[j]\\n\\t\\t\\t\\t\\tif f > 1:\\n\\t\\t\\t\\t\\t\\tnew_nums.append((f-1,n))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnew_nums.append(nums[j])\\n\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple(new_nums)))\\n\\t\\treturn best\\n\\n\\tif k == len(nums): return 0\\n\\tc = collections.Counter(nums)\\n\\tbin_size = len(nums) // k\\n\\tnums = tuple([(c[num], num) for num in c])\\n\\tres = helper(0, nums)\\n\\treturn -1 if (res == math.inf) else res\\n```\\n\\n</details>",
                "solutionTags": [],
                "code": "```nums.length / k```\n```k```\n```nums.length == k```\n```k```\n```python\\n# Runtime: 7812 ms (see below for faster solution)\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\t\\tif max(collections.Counter(nums).values()) > k - i:\\n\\t\\t\\treturn math.inf\\n\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums) - min(nums)\\n\\n\\t\\tbest = math.inf\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[i] for i in combo]\\n\\t\\t\\tif len(set(numbers)) == len(numbers):\\n\\t\\t\\t\\tcombo = set(combo)\\n\\t\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple([n for i,n in enumerate(nums) if i not in combo])))\\n\\t\\treturn best\\n\\n\\tif k == len(nums): return 0\\n\\tbin_size = len(nums) // k\\n\\tres = helper(0, tuple(nums))\\n\\treturn -1 if (res == math.inf) else res\\n```\n```python\\n#Runtime: 7812 ms: (see below for faster implementation)\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t# If any number occurs more than k times, there is no solution\\n\\tc = collections.Counter(nums)\\n\\tif max(c.values()) > k:\\n\\t\\treturn -1\\n\\n\\t# If there is one bin for each number then the answer zero\\n\\tif k == len(nums):\\n\\t\\treturn 0\\n\\n\\t# This is the size of each bin\\n\\tbin_size = len(nums) // k\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\n\\t\\t# k - 1 bins have been filled, if all the numbers in nums are distinct the remaining nums get binned together\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums) - min(nums) if len(set(nums)) == len(nums) else math.inf\\n\\n\\t\\tbest = math.inf\\n\\n\\t\\t# Consider all combinations of bin_size numbers to place in the current bin\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[i] for i in combo]\\n\\n\\t\\t\\t# Do not place two of the same number into a bin\\n\\t\\t\\tif len(set(numbers)) == len(numbers):\\n\\t\\t\\t\\tcombo = set(combo)\\n\\t\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple([n for i,n in enumerate(nums) if i not in combo])))\\n\\n\\t\\treturn best\\n\\n\\treturn helper(0, tuple(nums))\\n```\n```\\nnums = (1, 1, 1, 2, 3, 3, 4, 5)\\nbecomes\\nnums = ((3, 1), (1, 2), (2, 3), (1, 4), (1, 5))\\n```\n```python\\n# Runtime: 3656 ms\\ndef minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, nums):\\n\\n\\t\\tif max(nums)[0] > k - i:\\n\\t\\t\\treturn math.inf\\n\\n\\t\\tif i == k - 1:\\n\\t\\t\\treturn max(nums)[1] - min(nums)[1]\\n\\n\\t\\tbest = math.inf\\n\\t\\tcombos = itertools.combinations(list(range(len(nums))), bin_size)\\n\\t\\tfor combo in combos:\\n\\t\\t\\tnumbers = [nums[j][1] for j in combo]\\n\\t\\t\\tcombo = set(combo)\\n\\t\\t\\tnew_nums = []\\n\\t\\t\\tfor j in range(len(nums)):\\n\\t\\t\\t\\tif j in combo:\\n\\t\\t\\t\\t\\tf, n = nums[j]\\n\\t\\t\\t\\t\\tif f > 1:\\n\\t\\t\\t\\t\\t\\tnew_nums.append((f-1,n))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tnew_nums.append(nums[j])\\n\\t\\t\\tbest = min(best, max(numbers) - min(numbers) + helper(i+1, tuple(new_nums)))\\n\\t\\treturn best\\n\\n\\tif k == len(nums): return 0\\n\\tc = collections.Counter(nums)\\n\\tbin_size = len(nums) // k\\n\\tnums = tuple([(c[num], num) for num in c])\\n\\tres = helper(0, nums)\\n\\treturn -1 if (res == math.inf) else res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 962605,
                "title": "swift-top-down-bitmask-dp-o-n-2-2-n",
                "content": "\\tclass Solution {\\n\\t\\tvar arr: [Int]!, n = 0, size = 0, total = 0, starts: [Int]!\\n\\t\\tvar dp = [[[[Int]]]](repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t[[[Int]]](repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[[Int]] (repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[Int](repeating: -1, count: 17),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t count: 8),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  count: 1<<16),\\n\\t\\t\\t\\t\\t\\t\\t count: 16)\\n\\t\\tlet inf = 10000000000\\n\\n\\t\\tfunc minimumIncompatibility(_ nums: [Int], _ k: Int) -> Int {\\n\\t\\t\\tguard k != 1 else {\\n\\t\\t\\t\\tlet set = Set(nums)\\n\\t\\t\\t\\tif set.count == nums.count {\\n\\t\\t\\t\\t\\treturn nums.max()!-nums.min()!\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t}\\n\\t\\t\\tguard nums.count != k else {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t\\tarr = nums.sorted()\\n\\t\\t\\tstarts = [0] + arr\\n\\t\\t\\tn = arr.count\\n\\t\\t\\ttotal = (1<<n)-1\\n\\t\\t\\tsize = n/k\\n\\n\\t\\t\\tlet res = dfs(0,0,0,0)\\n\\t\\t\\treturn res == inf ? -1 : res\\n\\t\\t}\\n\\n\\t\\t/**\\n\\t\\t cur is the element we need to start scanning from\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  01234567\\n\\t\\t mask is used to track which elemnents are used, e.g. 01100011 means 1st, 2nd, 6th and 7th elements are used\\n\\t\\t gsize tracks the size of this group, each group is arr.count/k elements\\n\\t\\t start tracks the starting point of this group, it\\'s used to find the min element of this group, since we are sorting the array, starting point is minimum element. It\\'s 1-based index. so if array size is n, start will go from, 1 to n instead of 0 to n-1.\\n\\t\\t */\\n\\t\\tfunc dfs(_ cur: Int,\\n\\t\\t\\t\\t _ mask: Int,\\n\\t\\t\\t\\t _ gsize: Int,\\n\\t\\t\\t\\t _ start: Int) -> Int {\\n\\n\\t\\t\\tif mask == total {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\n\\t\\t\\tguard dp[cur][mask][gsize][start] == -1 else {\\n\\t\\t\\t\\treturn dp[cur][mask][gsize][start]\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar res = inf\\n\\n\\t\\t\\t// start = 0 means this is a new group\\n\\t\\t\\tif start == 0 {\\n\\t\\t\\t\\tvar i = 0, j = 0\\n\\t\\t\\t\\t//for new group we first find the first element in the group\\n\\t\\t\\t\\twhile i < n {\\n\\t\\t\\t\\t\\tj = 1<<i\\n\\t\\t\\t\\t\\tguard j&mask == 0 else {\\n\\t\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlet mc = mask|j\\n\\n\\t\\t\\t\\tfor k in stride(from: i+1, to: n, by: 1) {\\n\\t\\t\\t\\t\\t//find next eligible element\\n\\t\\t\\t\\t\\tguard arr[i] != arr[k] else {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t//start array is 1 based so we add 1 to i\\n\\t\\t\\t\\t\\tres = min(res, dfs(k, mc, 1, i + 1))\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor i in stride(from: cur, to: n, by: 1) {\\n\\t\\t\\t\\t\\tlet j = 1<<i\\n\\t\\t\\t\\t\\tguard mask&j == 0 else {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// if this is the last item in the group, we need to finx max-min and add it to result\\n\\t\\t\\t\\t\\tif gsize == size-1 {\\n\\t\\t\\t\\t\\t\\tlet mn = starts[start]\\n\\t\\t\\t\\t\\t\\tlet mx = arr[i]\\n\\t\\t\\t\\t\\t\\t//because this group has ended, next cur will start from 0, next group size will be 0 and start will be unavailable (0 means unavailable and start array is 1 based)\\n\\t\\t\\t\\t\\t\\tres = min(res, mx-mn + dfs(0, mask|j, 0, 0))\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tvar next = i+1\\n\\t\\t\\t\\t\\t\\twhile next < n && (arr[i] == arr[next]) {\\n\\t\\t\\t\\t\\t\\t\\tnext += 1\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t//find next item in group\\n\\t\\t\\t\\t\\t\\tif next < n {\\n\\t\\t\\t\\t\\t\\t\\tres = min(res, dfs(next, mask|j, gsize + 1, start))\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[cur][mask][gsize][start] = res\\n\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\t\\tvar arr: [Int]!, n = 0, size = 0, total = 0, starts: [Int]!\\n\\t\\tvar dp = [[[[Int]]]](repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t[[[Int]]](repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[[Int]] (repeating:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t[Int](repeating: -1, count: 17),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t count: 8),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  count: 1<<16),\\n\\t\\t\\t\\t\\t\\t\\t count: 16)\\n\\t\\tlet inf = 10000000000\\n\\n\\t\\tfunc minimumIncompatibility(_ nums: [Int], _ k: Int) -> Int {\\n\\t\\t\\tguard k != 1 else {\\n\\t\\t\\t\\tlet set = Set(nums)\\n\\t\\t\\t\\tif set.count == nums.count {\\n\\t\\t\\t\\t\\treturn nums.max()!-nums.min()!\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 962339,
                "title": "python-2-solutions-1-brute-force-1-memoization-ac",
                "content": "In the first solution, we calculate all possible parition combinations, then we calculating *all combinations of the parition combinations*, calculate the agreement, and update result to be the minimum of all our calculations.\\n\\nIn the second solution, we re-frame the problem as a tree search. Our recursive function contains this line,`for combo in itertools.combinations(nums, partition_len)`, which essentially loops over each possible parition, removes the parition from the array, and calls itself again to calculate a new parition. This is pretty much the same idea as before, except we do it recursively instead of iteratively. Furthermore, we add the `@functools.lru_cache(maxsize=None)` decorator to automatically add memoization to our solution.  One small note is we have to cast `nums` to a `tuple` as `lru_cache` requires functions to have immutable input.\\n\\n\\n**Brute force**\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        \\n        nums.sort()\\n        \\n        x = len(nums)//k\\n        \\n        combos = []\\n        \\n        for i in itertools.combinations(nums, x):\\n            if len(set(i)) == x:\\n                combos.append(i)\\n                \\n        result = float(\\'inf\\')\\n                \\n        for i in itertools.combinations(combos, k):                                          \\n            if sorted([y for x in i for y in x]) == nums:                \\n                score = sum([max(x) - min(x) for x in i])                \\n                result = min(score, result)\\n        \\n        return result if result != float(\"inf\") else -1\\n```\\n\\n\\n**Memoization**\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n                        \\n        partition_len = len(nums) // k        \\n                \\n        @functools.lru_cache(maxsize=None)\\n        def recurse(nums):            \\n            if not nums: return 0      \\n            \\n            result = float(\\'inf\\')\\n            \\n            for combo in itertools.combinations(nums, partition_len):                \\n                \\n                if len(set(combo)) < partition_len: continue\\n                                                 \\n                updated_nums = list(nums) \\n                for i in combo:\\n                    updated_nums.remove(i)\\n                                    \\n                result = min(\\n                    result,\\n                    max(combo) - min(combo) + recurse(tuple(updated_nums))\\n                )\\n                \\n            return result\\n        \\n        result = recurse(tuple(nums))\\n        \\n        return result if result != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        \\n        nums.sort()\\n        \\n        x = len(nums)//k\\n        \\n        combos = []\\n        \\n        for i in itertools.combinations(nums, x):\\n            if len(set(i)) == x:\\n                combos.append(i)\\n                \\n        result = float(\\'inf\\')\\n                \\n        for i in itertools.combinations(combos, k):                                          \\n            if sorted([y for x in i for y in x]) == nums:                \\n                score = sum([max(x) - min(x) for x in i])                \\n                result = min(score, result)\\n        \\n        return result if result != float(\"inf\") else -1\\n```\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n                        \\n        partition_len = len(nums) // k        \\n                \\n        @functools.lru_cache(maxsize=None)\\n        def recurse(nums):            \\n            if not nums: return 0      \\n            \\n            result = float(\\'inf\\')\\n            \\n            for combo in itertools.combinations(nums, partition_len):                \\n                \\n                if len(set(combo)) < partition_len: continue\\n                                                 \\n                updated_nums = list(nums) \\n                for i in combo:\\n                    updated_nums.remove(i)\\n                                    \\n                result = min(\\n                    result,\\n                    max(combo) - min(combo) + recurse(tuple(updated_nums))\\n                )\\n                \\n            return result\\n        \\n        result = recurse(tuple(nums))\\n        \\n        return result if result != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962188,
                "title": "python-simple-backtrack-with-pruning",
                "content": "The idea behind my solution is to put numbers in all possible non empty sets,\\nif there are empty sets, put current number in only one empty set.\\nPrune backtracking if there is already better solution.\\n```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        l = n // k\\n        \\n        subs = [set() for _ in range(k)]\\n        \\n        best = float(\\'inf\\')\\n        \\n        def backtrack(i):\\n            nonlocal best\\n            \\n\\t\\t\\t# current incompatibility\\n            incopat = sum(max(s) - min(s) for s in subs if s)\\n            \\n            if i == n:\\n                best = min(best, incopat)\\n                return\\n            \\n            if best < incopat: #  no need to investigate already bad solution\\n                return\\n            \\n            for j in range(k):\\n\\t\\t\\t\\t#  try to put current number into:\\n\\t\\t\\t\\t#  - all valid non empty sets\\n\\t\\t\\t\\t#  - and the only single empty set\\n                if len(subs[j]) == 0:\\n                    subs[j].add(nums[i])\\n                    backtrack(i + 1)\\n                    subs[j].remove(nums[i])\\n                    break\\n                if nums[i] not in subs[j] and len(subs[j]) < l:\\n                    subs[j].add(nums[i])\\n                    backtrack(i + 1)\\n                    subs[j].remove(nums[i])\\n                    \\n        backtrack(0)\\n        return best if best != float(\\'inf\\') else -1\\n```\\n                \\n                \\n                \\n        \\n            \\n                \\n            \\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        l = n // k\\n        \\n        subs = [set() for _ in range(k)]\\n        \\n        best = float(\\'inf\\')\\n        \\n        def backtrack(i):\\n            nonlocal best\\n            \\n\\t\\t\\t# current incompatibility\\n            incopat = sum(max(s) - min(s) for s in subs if s)\\n            \\n            if i == n:\\n                best = min(best, incopat)\\n                return\\n            \\n            if best < incopat: #  no need to investigate already bad solution\\n                return\\n            \\n            for j in range(k):\\n\\t\\t\\t\\t#  try to put current number into:\\n\\t\\t\\t\\t#  - all valid non empty sets\\n\\t\\t\\t\\t#  - and the only single empty set\\n                if len(subs[j]) == 0:\\n                    subs[j].add(nums[i])\\n                    backtrack(i + 1)\\n                    subs[j].remove(nums[i])\\n                    break\\n                if nums[i] not in subs[j] and len(subs[j]) < l:\\n                    subs[j].add(nums[i])\\n                    backtrack(i + 1)\\n                    subs[j].remove(nums[i])\\n                    \\n        backtrack(0)\\n        return best if best != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961888,
                "title": "c-memoization-o-n-2-m",
                "content": "O(N*2^M), where N = max(nums[i]), M = length(nums); N can be made equal to count(distinct(nums[i])).\\n\\n```\\nint d[17][1 << 16];\\n\\nclass Solution {\\n    int search(vector<int>& a, int l, int m, int n, int i, int u, int x, int y)\\n    {\\n        int s = 0;\\n        if (n == l)\\n        {\\n            s = a[i - 1] - u;\\n            for (i = m = x = 0; i < a.size(); ++i)\\n                if ((y & (1 << i)) == 0 && (x & (1 << a[i])) == 0)\\n                    ++m, x |= 1 << a[i];\\n            if (m == 0)\\n                return s;\\n            n = i = u = x = 0;\\n        }\\n        if (d[u][y] == 0)\\n        {\\n            int r = 1000;\\n            for (; i < a.size() && l - n <= m; ++i)\\n                if ((y & (1 << i)) == 0 && (x & (1 << a[i])) == 0)\\n                    r = min(r, search(a, l, --m, n + 1, i + 1, n == 0 ? a[i] : u, x | (1 << a[i]), y | (1 << i)));\\n            d[u][y] = r + 1;\\n        }\\n        return s + d[u][y] - 1;\\n    }\\n    \\npublic:\\n    int minimumIncompatibility(vector<int>& a, int k) {\\n        memset(d, 0, sizeof(d));\\n        sort(a.begin(), a.end());\\n        int r = search(a, a.size() / k, a.size(), a.size() / k, 1, a[0], 0, 0);\\n        return r == 1000 ? -1 : r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint d[17][1 << 16];\\n\\nclass Solution {\\n    int search(vector<int>& a, int l, int m, int n, int i, int u, int x, int y)\\n    {\\n        int s = 0;\\n        if (n == l)\\n        {\\n            s = a[i - 1] - u;\\n            for (i = m = x = 0; i < a.size(); ++i)\\n                if ((y & (1 << i)) == 0 && (x & (1 << a[i])) == 0)\\n                    ++m, x |= 1 << a[i];\\n            if (m == 0)\\n                return s;\\n            n = i = u = x = 0;\\n        }\\n        if (d[u][y] == 0)\\n        {\\n            int r = 1000;\\n            for (; i < a.size() && l - n <= m; ++i)\\n                if ((y & (1 << i)) == 0 && (x & (1 << a[i])) == 0)\\n                    r = min(r, search(a, l, --m, n + 1, i + 1, n == 0 ? a[i] : u, x | (1 << a[i]), y | (1 << i)));\\n            d[u][y] = r + 1;\\n        }\\n        return s + d[u][y] - 1;\\n    }\\n    \\npublic:\\n    int minimumIncompatibility(vector<int>& a, int k) {\\n        memset(d, 0, sizeof(d));\\n        sort(a.begin(), a.end());\\n        int r = search(a, a.size() / k, a.size(), a.size() / k, 1, a[0], 0, 0);\\n        return r == 1000 ? -1 : r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961786,
                "title": "java-solution-using-recursion-backtracking",
                "content": "```\\nint ans=Integer.MAX_VALUE;\\n    \\npublic boolean recursionfromright(ArrayList<Integer> list,ArrayList<Integer> mlist,int sz,int ct,int k,int idx,int max,int min,int cans){\\n        if(mlist.size()==sz && ct==(k-1)){\\n            ans=Math.min(ans,cans+(max-min));   \\n            return true;\\n        }\\n        \\n        int csz=mlist.size();\\n         int diff=0;\\n        if(mlist.size()==sz){\\n            mlist=new ArrayList<Integer>();\\n            // System.out.println(max+\" \"+min+\" \"+list.get(idx));\\n            diff=(max-min);  idx=list.size()-1;  max=Integer.MIN_VALUE; min=Integer.MAX_VALUE;\\n            \\n        }\\n        \\n        for(int i=idx;i>=0;i--){\\n            if(!mlist.contains(list.get(i))){\\n                int val=list.get(i);  mlist.add(val);  list.remove(i);\\n                if(csz==sz){cans+=diff; ct+=1;}\\n                \\n                boolean res=recursionfromright(list,mlist,sz,ct,k,i-1,Math.max(max,val),Math.min(min,val),cans);\\n                if(res)return true;\\n                mlist.remove(mlist.size()-1);  list.add(i,val);\\n                \\n                if(csz==sz){cans-=diff; ct-=1;}\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean recursionfromleft(ArrayList<Integer> list,ArrayList<Integer> mlist,int sz,int ct,int k,int idx,int max,int min,int cans){\\n        if(mlist.size()==sz && ct==(k-1)){\\n            ans=Math.min(ans,cans+(max-min));   \\n            return true;\\n        }\\n        \\n        int csz=mlist.size();\\n         int diff=0;\\n        if(mlist.size()==sz){\\n            mlist=new ArrayList<Integer>();\\n            diff=(max-min);  idx=0;\\n            // ct++;  \\n        }\\n        \\n        for(int i=idx;i<list.size();i++){\\n            if(!mlist.contains(list.get(i))){\\n                int val=list.get(i);\\n                mlist.add(val); list.remove(i);  int omax=max,omin=min;\\n                if(csz==sz){cans+=diff; ct+=1;  max=Integer.MIN_VALUE; min=Integer.MAX_VALUE;}\\n                \\n                boolean res=recursionfromleft(list,mlist,sz,ct,k,i,Math.max(max,val),Math.min(min,val),cans);\\n                \\n                if(res)return true;\\n                mlist.remove(mlist.size()-1);\\n                list.add(i,val);\\n                if(csz==sz){cans-=diff; ct-=1; max=omax; min=omin;}\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int freq=hm.getOrDefault(nums[i],0)+1;\\n            if(freq>k)return -1;\\n            hm.put(nums[i],freq);\\n        }\\n        \\n        int n=nums.length;\\n        \\n        int size=n/k;\\n        \\n        Arrays.sort(nums);\\n        ArrayList<Integer> list1=new ArrayList<>();\\n        ArrayList<Integer> list2=new ArrayList<>();\\n        for(int val:nums){list1.add(val); list2.add(val);}\\n        \\n        recursionfromright(list1,new ArrayList<Integer>(),size,0,k,list1.size()-1,Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        recursionfromleft(list2,new ArrayList<Integer>(),size,0,k,0,Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n                 \\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint ans=Integer.MAX_VALUE;\\n    \\npublic boolean recursionfromright(ArrayList<Integer> list,ArrayList<Integer> mlist,int sz,int ct,int k,int idx,int max,int min,int cans){\\n        if(mlist.size()==sz && ct==(k-1)){\\n            ans=Math.min(ans,cans+(max-min));   \\n            return true;\\n        }\\n        \\n        int csz=mlist.size();\\n         int diff=0;\\n        if(mlist.size()==sz){\\n            mlist=new ArrayList<Integer>();\\n            // System.out.println(max+\" \"+min+\" \"+list.get(idx));\\n            diff=(max-min);  idx=list.size()-1;  max=Integer.MIN_VALUE; min=Integer.MAX_VALUE;\\n            \\n        }\\n        \\n        for(int i=idx;i>=0;i--){\\n            if(!mlist.contains(list.get(i))){\\n                int val=list.get(i);  mlist.add(val);  list.remove(i);\\n                if(csz==sz){cans+=diff; ct+=1;}\\n                \\n                boolean res=recursionfromright(list,mlist,sz,ct,k,i-1,Math.max(max,val),Math.min(min,val),cans);\\n                if(res)return true;\\n                mlist.remove(mlist.size()-1);  list.add(i,val);\\n                \\n                if(csz==sz){cans-=diff; ct-=1;}\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    public boolean recursionfromleft(ArrayList<Integer> list,ArrayList<Integer> mlist,int sz,int ct,int k,int idx,int max,int min,int cans){\\n        if(mlist.size()==sz && ct==(k-1)){\\n            ans=Math.min(ans,cans+(max-min));   \\n            return true;\\n        }\\n        \\n        int csz=mlist.size();\\n         int diff=0;\\n        if(mlist.size()==sz){\\n            mlist=new ArrayList<Integer>();\\n            diff=(max-min);  idx=0;\\n            // ct++;  \\n        }\\n        \\n        for(int i=idx;i<list.size();i++){\\n            if(!mlist.contains(list.get(i))){\\n                int val=list.get(i);\\n                mlist.add(val); list.remove(i);  int omax=max,omin=min;\\n                if(csz==sz){cans+=diff; ct+=1;  max=Integer.MIN_VALUE; min=Integer.MAX_VALUE;}\\n                \\n                boolean res=recursionfromleft(list,mlist,sz,ct,k,i,Math.max(max,val),Math.min(min,val),cans);\\n                \\n                if(res)return true;\\n                mlist.remove(mlist.size()-1);\\n                list.add(i,val);\\n                if(csz==sz){cans-=diff; ct-=1; max=omax; min=omin;}\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public int minimumIncompatibility(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int freq=hm.getOrDefault(nums[i],0)+1;\\n            if(freq>k)return -1;\\n            hm.put(nums[i],freq);\\n        }\\n        \\n        int n=nums.length;\\n        \\n        int size=n/k;\\n        \\n        Arrays.sort(nums);\\n        ArrayList<Integer> list1=new ArrayList<>();\\n        ArrayList<Integer> list2=new ArrayList<>();\\n        for(int val:nums){list1.add(val); list2.add(val);}\\n        \\n        recursionfromright(list1,new ArrayList<Integer>(),size,0,k,list1.size()-1,Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        recursionfromleft(list2,new ArrayList<Integer>(),size,0,k,0,Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n                 \\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961712,
                "title": "python-easy-to-understand",
                "content": "```\\nfrom functools import lru_cache\\nfrom itertools import combinations\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:        \\n        counter = Counter(nums)\\n        num, cnt = counter.most_common(1)[0]\\n        if cnt > k: return -1\\n        \\n        length = len(nums)//k\\n        \\n        @lru_cache(None)\\n        def helper(nums_tuple):\\n            if not nums_tuple:\\n                return 0\\n\\n            ans = float(\\'inf\\')\\n            \\n            for a in combinations(set(nums_tuple), length):\\n                if len(set(a)) < length: continue\\n                    \\n                remainings = list(nums_tuple)\\n                for x in a:\\n                    remainings.remove(x)\\n                    \\n                ans = min(ans, max(a) - min(a) + helper(tuple(remainings)))\\n\\n            return ans\\n        \\n        return helper(tuple(nums))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nfrom itertools import combinations\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:        \\n        counter = Counter(nums)\\n        num, cnt = counter.most_common(1)[0]\\n        if cnt > k: return -1\\n        \\n        length = len(nums)//k\\n        \\n        @lru_cache(None)\\n        def helper(nums_tuple):\\n            if not nums_tuple:\\n                return 0\\n\\n            ans = float(\\'inf\\')\\n            \\n            for a in combinations(set(nums_tuple), length):\\n                if len(set(a)) < length: continue\\n                    \\n                remainings = list(nums_tuple)\\n                for x in a:\\n                    remainings.remove(x)\\n                    \\n                ans = min(ans, max(a) - min(a) + helper(tuple(remainings)))\\n\\n            return ans\\n        \\n        return helper(tuple(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961711,
                "title": "can-anyone-help-why-this-bruteforce-approach-giving-wrong-result",
                "content": "Can anyone help why this code gives 12 instead of 6 for testcase\\nnums = [6,3,8,1,3,1,2,2], k = 4\\n\\n```\\nclass Solution {\\npublic:\\n\\tvoid find(int curind, vector<int> &arr, vector<bool> &used, unordered_set<int> &curbucket, int n_rem_bucket, int &best, int bucketsize, int cursum)\\n\\t{\\n\\t\\tint n = arr.size();\\n\\t\\tif (n_rem_bucket == 1)\\n\\t\\t{\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tint maxi = INT_MIN;\\n            curbucket.clear();\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!used[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurbucket.insert(arr[i]);\\n                    maxi = max(maxi, arr[i]);\\n                    mini = min(mini, arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            if (curbucket.size() != bucketsize)\\n            {\\n                curbucket.clear();\\n                return;\\n            }\\n\\t\\t\\tbest = min(best, cursum + maxi - mini);\\n\\t\\t\\tcurbucket.clear();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint p = curbucket.size();\\n\\t\\tif (p == bucketsize)\\n\\t\\t{\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tint maxi = INT_MIN;\\n\\t\\t\\tunordered_set<int>::iterator it;\\n\\t\\t\\tfor (it = curbucket.begin(); it != curbucket.end(); it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmini = min(mini, *it);\\n\\t\\t\\t\\tmaxi = max(maxi, *it);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurbucket.clear();\\n\\t\\t\\tfind(0, arr, used, curbucket, n_rem_bucket-1, best, bucketsize, cursum+maxi-mini);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = curind; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (!used[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tunordered_set<int>::iterator it;\\n\\t\\t\\t\\tit = curbucket.find(arr[i]);\\n\\t\\t\\t\\tif (it == curbucket.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tused[i] = true;\\n\\t\\t\\t\\t\\tcurbucket.insert(arr[i]);\\n\\t\\t\\t\\t\\tfind(i+1, arr, used, curbucket, n_rem_bucket, best, bucketsize, cursum);\\n\\t\\t\\t\\t\\tcurbucket.erase(arr[i]);\\n\\t\\t\\t\\t\\tused[i] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    int minimumIncompatibility(vector<int>& arr, int k) {\\n    \\tint n = arr.size();\\n    \\tif (n % k) return -1;\\n        int best = INT_MAX;\\n        int cursum = 0;\\n        int bucketsize = n/k;\\n        vector<bool> used(n, false);\\n        unordered_set<int> curbucket;\\n        find(0, arr, used, curbucket, k, best, bucketsize, 0);\\n\\n        if (best == INT_MAX) return -1;\\n        return best;\\n    }\\n};\\n```\\nThanks in advance.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvoid find(int curind, vector<int> &arr, vector<bool> &used, unordered_set<int> &curbucket, int n_rem_bucket, int &best, int bucketsize, int cursum)\\n\\t{\\n\\t\\tint n = arr.size();\\n\\t\\tif (n_rem_bucket == 1)\\n\\t\\t{\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tint maxi = INT_MIN;\\n            curbucket.clear();\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!used[i])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcurbucket.insert(arr[i]);\\n                    maxi = max(maxi, arr[i]);\\n                    mini = min(mini, arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            if (curbucket.size() != bucketsize)\\n            {\\n                curbucket.clear();\\n                return;\\n            }\\n\\t\\t\\tbest = min(best, cursum + maxi - mini);\\n\\t\\t\\tcurbucket.clear();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint p = curbucket.size();\\n\\t\\tif (p == bucketsize)\\n\\t\\t{\\n\\t\\t\\tint mini = INT_MAX;\\n\\t\\t\\tint maxi = INT_MIN;\\n\\t\\t\\tunordered_set<int>::iterator it;\\n\\t\\t\\tfor (it = curbucket.begin(); it != curbucket.end(); it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmini = min(mini, *it);\\n\\t\\t\\t\\tmaxi = max(maxi, *it);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurbucket.clear();\\n\\t\\t\\tfind(0, arr, used, curbucket, n_rem_bucket-1, best, bucketsize, cursum+maxi-mini);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor (int i = curind; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (!used[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tunordered_set<int>::iterator it;\\n\\t\\t\\t\\tit = curbucket.find(arr[i]);\\n\\t\\t\\t\\tif (it == curbucket.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tused[i] = true;\\n\\t\\t\\t\\t\\tcurbucket.insert(arr[i]);\\n\\t\\t\\t\\t\\tfind(i+1, arr, used, curbucket, n_rem_bucket, best, bucketsize, cursum);\\n\\t\\t\\t\\t\\tcurbucket.erase(arr[i]);\\n\\t\\t\\t\\t\\tused[i] = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n    int minimumIncompatibility(vector<int>& arr, int k) {\\n    \\tint n = arr.size();\\n    \\tif (n % k) return -1;\\n        int best = INT_MAX;\\n        int cursum = 0;\\n        int bucketsize = n/k;\\n        vector<bool> used(n, false);\\n        unordered_set<int> curbucket;\\n        find(0, arr, used, curbucket, k, best, bucketsize, 0);\\n\\n        if (best == INT_MAX) return -1;\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961703,
                "title": "c-dfs-24ms-100",
                "content": "The most effient branch cut condition comes from compare 2 slots see if they are equal.\\n\\n\\n```\\nstruct slot\\n{\\n    int array[16];\\n    int cur = 0;\\n    int n = 0;\\n    int d = 0;\\n    \\n    inline bool valid(int v)\\n    {\\n        if (cur == 0)\\n        {\\n            return true;\\n        }\\n        return (array[cur - 1] < v) && (cur < n);\\n    }\\n\\n    inline int push(int v)\\n    {\\n        int d1 = diff();\\n        array[cur] = v;\\n        cur++; \\n        int d = diff();\\n        return d - d1;\\n    }\\n\\n    inline int pop(int v)\\n    {\\n        int d1 = diff();\\n        cur--;\\n        int d = diff();\\n        return d - d1;\\n    }\\n\\n    inline int diff()\\n    {\\n        if (cur == 0) return 0;\\n        return array[cur - 1] - array[0];\\n    }\\n    \\n    inline bool equal(slot& s)\\n    {\\n        if (cur != s.cur)\\n        {\\n            return false;   \\n        }\\n        if (cur == 0) return true;\\n        if (array[0] != s.array[0]) return false;\\n        if (array[cur - 1] != s.array[cur - 1]) return false;\\n        return true;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int n;\\n    vector<slot> slots;\\n    int res = INT_MAX;\\n    void visit(vector<int>& nums, int p , int sum)\\n    {\\n        if (p == n)\\n        {        \\n            res = min(res, sum);\\n        }\\n        if (sum >= res)\\n        {\\n            return;\\n        }\\n        int v = nums[p];\\n        for (int i = 0; i < slots.size(); i++)\\n        {\\n            if (slots[i].valid(v) )\\n            {\\n                bool dup = false;\\n                for (int j = 0; j < i; j++)\\n                {\\n                    if (slots[i].equal(slots[j]))\\n                    {\\n                        dup = true;\\n                        break;\\n                    }\\n                }\\n                if (dup)\\n                {\\n                    continue;\\n                }\\n                sum += slots[i].push(v);\\n                visit(nums, p + 1, sum);\\n                sum += slots[i].pop(v);\\n            }\\n        }\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        n = nums.size();\\n        \\n        if (k == n) return 0;\\n        slots.resize(k);\\n        unordered_map<int, int> m;\\n        for (auto& v : nums)\\n        {\\n            m[v]++;\\n        }\\n        for (auto& p : m)\\n        {\\n            if (p.second > k)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        for (auto& slot : slots)\\n        {\\n            slot.n = n / k;\\n        }\\n        sort(nums.begin(), nums.end());\\n        visit(nums, 0, 0);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct slot\\n{\\n    int array[16];\\n    int cur = 0;\\n    int n = 0;\\n    int d = 0;\\n    \\n    inline bool valid(int v)\\n    {\\n        if (cur == 0)\\n        {\\n            return true;\\n        }\\n        return (array[cur - 1] < v) && (cur < n);\\n    }\\n\\n    inline int push(int v)\\n    {\\n        int d1 = diff();\\n        array[cur] = v;\\n        cur++; \\n        int d = diff();\\n        return d - d1;\\n    }\\n\\n    inline int pop(int v)\\n    {\\n        int d1 = diff();\\n        cur--;\\n        int d = diff();\\n        return d - d1;\\n    }\\n\\n    inline int diff()\\n    {\\n        if (cur == 0) return 0;\\n        return array[cur - 1] - array[0];\\n    }\\n    \\n    inline bool equal(slot& s)\\n    {\\n        if (cur != s.cur)\\n        {\\n            return false;   \\n        }\\n        if (cur == 0) return true;\\n        if (array[0] != s.array[0]) return false;\\n        if (array[cur - 1] != s.array[cur - 1]) return false;\\n        return true;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    int n;\\n    vector<slot> slots;\\n    int res = INT_MAX;\\n    void visit(vector<int>& nums, int p , int sum)\\n    {\\n        if (p == n)\\n        {        \\n            res = min(res, sum);\\n        }\\n        if (sum >= res)\\n        {\\n            return;\\n        }\\n        int v = nums[p];\\n        for (int i = 0; i < slots.size(); i++)\\n        {\\n            if (slots[i].valid(v) )\\n            {\\n                bool dup = false;\\n                for (int j = 0; j < i; j++)\\n                {\\n                    if (slots[i].equal(slots[j]))\\n                    {\\n                        dup = true;\\n                        break;\\n                    }\\n                }\\n                if (dup)\\n                {\\n                    continue;\\n                }\\n                sum += slots[i].push(v);\\n                visit(nums, p + 1, sum);\\n                sum += slots[i].pop(v);\\n            }\\n        }\\n    }\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        n = nums.size();\\n        \\n        if (k == n) return 0;\\n        slots.resize(k);\\n        unordered_map<int, int> m;\\n        for (auto& v : nums)\\n        {\\n            m[v]++;\\n        }\\n        for (auto& p : m)\\n        {\\n            if (p.second > k)\\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        for (auto& slot : slots)\\n        {\\n            slot.n = n / k;\\n        }\\n        sort(nums.begin(), nums.end());\\n        visit(nums, 0, 0);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961611,
                "title": "can-anyone-figure-out-what-is-the-complexity-of-this-code",
                "content": "Nothing fancy, but just stored the `max-min` of a subset in `cache`.\\nThe part I do not understand is what is the complexity.\\nConsider following test case:\\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\\n16\\nThe invocation of `solve` on the bottom of stack has a for loop of size `2^n`, although within it only 16 selections are valid.\\nOn the 2nd level of the stack the size of the for loop reduces to `2^(n - 1)`\\n... and so on. The complexity seems extreamly huge.\\nEven when we only consider valid selections on each level, at minimum shouldn\\'t the complexity be `16! (16*15*...*2*1)`? Why does it simply not get a TLE?\\n```\\nclass Solution {\\n    private int[] cache, dp;\\n\\n    private int solve(int mask) {\\n        if (dp[mask] == Integer.MAX_VALUE) {\\n            dp[mask] = Integer.MAX_VALUE / 2;\\n            for (int i = mask; i != 0; i = (i - 1) & mask) {\\n                if (cache[i] != Integer.MAX_VALUE) {\\n                    dp[mask] = Math.min(dp[mask], cache[i] + solve(mask & ~i));\\n                }\\n            }\\n        }\\n        return dp[mask];\\n    }\\n\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int allMask = (1 << nums.length) - 1, size = nums.length / k;\\n        Arrays.sort(nums);\\n        cache = new int[allMask + 1];\\n        dp = new int[allMask + 1];\\n        Arrays.fill(cache, Integer.MAX_VALUE);\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for (int i = 0; i <= allMask; i++) {\\n            if (Integer.bitCount(i) != size) continue;\\n            int pre = -1, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n            for (int j = i, b = 0; j != 0; j >>= 1, b++) {\\n                if ((j & 1) == 1) {\\n                    if (pre == nums[b]) {\\n                        pre = Integer.MIN_VALUE;\\n                        break;\\n                    }\\n                    min = Math.min(min, nums[b]);\\n                    max = Math.max(max, nums[b]);\\n                    pre = nums[b];\\n                }\\n            }\\n            if (pre != Integer.MIN_VALUE) cache[i] = max - min;\\n        }\\n        int ans = solve(allMask);\\n        return ans >= Integer.MAX_VALUE / 2 ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] cache, dp;\\n\\n    private int solve(int mask) {\\n        if (dp[mask] == Integer.MAX_VALUE) {\\n            dp[mask] = Integer.MAX_VALUE / 2;\\n            for (int i = mask; i != 0; i = (i - 1) & mask) {\\n                if (cache[i] != Integer.MAX_VALUE) {\\n                    dp[mask] = Math.min(dp[mask], cache[i] + solve(mask & ~i));\\n                }\\n            }\\n        }\\n        return dp[mask];\\n    }\\n\\n    public int minimumIncompatibility(int[] nums, int k) {\\n        int allMask = (1 << nums.length) - 1, size = nums.length / k;\\n        Arrays.sort(nums);\\n        cache = new int[allMask + 1];\\n        dp = new int[allMask + 1];\\n        Arrays.fill(cache, Integer.MAX_VALUE);\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for (int i = 0; i <= allMask; i++) {\\n            if (Integer.bitCount(i) != size) continue;\\n            int pre = -1, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n            for (int j = i, b = 0; j != 0; j >>= 1, b++) {\\n                if ((j & 1) == 1) {\\n                    if (pre == nums[b]) {\\n                        pre = Integer.MIN_VALUE;\\n                        break;\\n                    }\\n                    min = Math.min(min, nums[b]);\\n                    max = Math.max(max, nums[b]);\\n                    pre = nums[b];\\n                }\\n            }\\n            if (pre != Integer.MIN_VALUE) cache[i] = max - min;\\n        }\\n        int ans = solve(allMask);\\n        return ans >= Integer.MAX_VALUE / 2 ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961587,
                "title": "seems-bug-got-tle-with-all-passed",
                "content": "O(3 ^ n) algorithm\\n\\n```\\nclass Solution {\\n    void better(int& x, int y, int z) {\\n        if (y < 0 || z < 0) return;\\n        y += z;\\n        if (x < 0 || x > y) {\\n            x = y;\\n        }\\n    }\\n\\n    void dfs(const vector<int>& nums, const int want, const int ind, const int mask, const int have, const int mini, const int maxi, vector<int>& all) {\\n        if (want < 0 || nums.size() - ind < want) return;\\n        if (ind == nums.size()) {\\n            all[mask] = maxi - mini;\\n            return;\\n        }\\n        dfs(nums, want, ind + 1, mask, have, mini, maxi, all);\\n        if ((have & (1 << nums[ind])) == 0) {\\n            dfs(nums, want - 1, ind + 1, mask | (1 << ind), have | (1 << nums[ind]), \\n                min(mini, nums[ind]), max(maxi, nums[ind]), all);\\n            \\n        }\\n    }\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = 1 << n;\\n        if (n == k) return 0;\\n        vector<int> all(m, -1);\\n        dfs(nums, n / k, 0, 0, 0, 12345, -12345, all);\\n        vector<int> dp(m, -1);\\n        dp[0] = 0;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = (i - 1) & i;; j = (j - 1) & i) {\\n                better(dp[i], dp[j], all[i ^ j]);\\n                if (j == 0) break;\\n            }\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```\\n\\nThis says all passed.\\n![image](https://assets.leetcode.com/users/images/eb3a9067-f0c2-4124-9025-122fd0dae602_1607230943.521663.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void better(int& x, int y, int z) {\\n        if (y < 0 || z < 0) return;\\n        y += z;\\n        if (x < 0 || x > y) {\\n            x = y;\\n        }\\n    }\\n\\n    void dfs(const vector<int>& nums, const int want, const int ind, const int mask, const int have, const int mini, const int maxi, vector<int>& all) {\\n        if (want < 0 || nums.size() - ind < want) return;\\n        if (ind == nums.size()) {\\n            all[mask] = maxi - mini;\\n            return;\\n        }\\n        dfs(nums, want, ind + 1, mask, have, mini, maxi, all);\\n        if ((have & (1 << nums[ind])) == 0) {\\n            dfs(nums, want - 1, ind + 1, mask | (1 << ind), have | (1 << nums[ind]), \\n                min(mini, nums[ind]), max(maxi, nums[ind]), all);\\n            \\n        }\\n    }\\npublic:\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n        const int n = nums.size(), m = 1 << n;\\n        if (n == k) return 0;\\n        vector<int> all(m, -1);\\n        dfs(nums, n / k, 0, 0, 0, 12345, -12345, all);\\n        vector<int> dp(m, -1);\\n        dp[0] = 0;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = (i - 1) & i;; j = (j - 1) & i) {\\n                better(dp[i], dp[j], all[i ^ j]);\\n                if (j == 0) break;\\n            }\\n        }\\n        return dp[m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961549,
                "title": "golang-search-memorisation-bitmask-48ms",
                "content": "The basic idea is to search all possible k groups and calculate the optimal value. It can be optimised with memorisation using bitmask as key. Key steps:\\n1. sort `nums` so that we can skip duplicate values. For example, `nums = [1,1,2,3,4,5]`, then we can skip the second `1` later\\n2. use bitmask `usable` to represent if certain number has been used\\n3. Then search all possibilities\\n4. At each iteration we try to find `len(nums)/k` numbers satisfying the rule (no duplicate). once found, we update `newUsable` and recursively search the best result for the rest.\\n\\t5. If the rest return `-1` it means it\\'s impossible\\n\\t6. otherwise, we add to it the current group\\'s incompatibility value `nums[index[len(index)-1]]-nums[index[0]]`  and take `min` with existing `ans`\\n\\n```\\nfunc minimumIncompatibility(nums []int, k int) int {\\n  seen := make(map[int]int)\\n  sort.Ints(nums)\\n  // every bit means if the corresponding num is suable.\\n  // e.g. if nums = [1,2,3,4] then initially usable = 1111.\\n  // If we consume \"2, 3\", then it becomes 1001\\n  usable := (1 << len(nums)) -1\\n  \\n  ans := helper(nums, k, usable, seen)\\n  \\n  fmt.Println(seen)\\n  return ans\\n}\\n\\nfunc helper(nums []int, k int, usable int, seen map[int]int) int {\\n  // it means we\\'ve used all number\\n  if usable == 0 {\\n    return 0\\n  }\\n    \\n  if _, ok := seen[usable]; ok {\\n    return seen[usable]\\n  }\\n  \\n  ans := -1\\n  bit := 1 << (len(nums)) // intent to have one extra left shift so at the biginning of each iteration we can safely do bit >> 1\\n  for i := range nums {\\n    bit = bit >> 1\\n\\n    // make sure nums[i] is not used\\n    if bit & usable == 0 {\\n      continue\\n    }\\n    \\n    // make sure nums[i] is not equal to nums[i-1]\\n    if i != 0 && nums[i] == nums[i-1] && (bit << 1 & usable != 0) {\\n      continue\\n    }\\n    \\n    index := make([]int, 0)\\n    newBit := bit << 1 // intent to have one extra left shift so at the begining of each iteration we can safely do newBit >> 1\\n    for j := i; j < len(nums); j++ {\\n      newBit = newBit >> 1\\n      // make sure nums[j] is not used\\n      if newBit & usable == 0 {\\n        continue\\n      }\\n      // make sure nums[j] is not equal to nums[j-1]\\n      if j != 0 && nums[j] == nums[j-1] && (newBit << 1 & usable != 0) {\\n        continue\\n      }\\n      \\n      index = append(index, j)\\n      if len(index) == len(nums)/k {\\n        break\\n      }\\n    }\\n    \\n    if len(index) != len(nums)/k {\\n      break\\n    }\\n    \\n    newUsable := usable\\n    bit := 1\\n    for i := range index {\\n      newUsable = newUsable ^ (bit << (len(nums)-1-index[i]))\\n    }\\n    \\n    // fmt.Printf(\"usable=%b, newUsable=%b, index=%v\\\\n\", usable, newUsable, index)\\n    ret := helper(nums, k, newUsable, seen)\\n    if ret != -1 {\\n      if ans == -1 {\\n        ans = nums[index[len(index)-1]]-nums[index[0]] + ret\\n      } else {\\n        ans = min(ans, nums[index[len(index)-1]]-nums[index[0]] + ret)\\n      }\\n    }\\n  }\\n  \\n  seen[usable] = ans\\n  return ans\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumIncompatibility(nums []int, k int) int {\\n  seen := make(map[int]int)\\n  sort.Ints(nums)\\n  // every bit means if the corresponding num is suable.\\n  // e.g. if nums = [1,2,3,4] then initially usable = 1111.\\n  // If we consume \"2, 3\", then it becomes 1001\\n  usable := (1 << len(nums)) -1\\n  \\n  ans := helper(nums, k, usable, seen)\\n  \\n  fmt.Println(seen)\\n  return ans\\n}\\n\\nfunc helper(nums []int, k int, usable int, seen map[int]int) int {\\n  // it means we\\'ve used all number\\n  if usable == 0 {\\n    return 0\\n  }\\n    \\n  if _, ok := seen[usable]; ok {\\n    return seen[usable]\\n  }\\n  \\n  ans := -1\\n  bit := 1 << (len(nums)) // intent to have one extra left shift so at the biginning of each iteration we can safely do bit >> 1\\n  for i := range nums {\\n    bit = bit >> 1\\n\\n    // make sure nums[i] is not used\\n    if bit & usable == 0 {\\n      continue\\n    }\\n    \\n    // make sure nums[i] is not equal to nums[i-1]\\n    if i != 0 && nums[i] == nums[i-1] && (bit << 1 & usable != 0) {\\n      continue\\n    }\\n    \\n    index := make([]int, 0)\\n    newBit := bit << 1 // intent to have one extra left shift so at the begining of each iteration we can safely do newBit >> 1\\n    for j := i; j < len(nums); j++ {\\n      newBit = newBit >> 1\\n      // make sure nums[j] is not used\\n      if newBit & usable == 0 {\\n        continue\\n      }\\n      // make sure nums[j] is not equal to nums[j-1]\\n      if j != 0 && nums[j] == nums[j-1] && (newBit << 1 & usable != 0) {\\n        continue\\n      }\\n      \\n      index = append(index, j)\\n      if len(index) == len(nums)/k {\\n        break\\n      }\\n    }\\n    \\n    if len(index) != len(nums)/k {\\n      break\\n    }\\n    \\n    newUsable := usable\\n    bit := 1\\n    for i := range index {\\n      newUsable = newUsable ^ (bit << (len(nums)-1-index[i]))\\n    }\\n    \\n    // fmt.Printf(\"usable=%b, newUsable=%b, index=%v\\\\n\", usable, newUsable, index)\\n    ret := helper(nums, k, newUsable, seen)\\n    if ret != -1 {\\n      if ans == -1 {\\n        ans = nums[index[len(index)-1]]-nums[index[0]] + ret\\n      } else {\\n        ans = min(ans, nums[index[len(index)-1]]-nums[index[0]] + ret)\\n      }\\n    }\\n  }\\n  \\n  seen[usable] = ans\\n  return ans\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 961530,
                "title": "any-greedy-method",
                "content": "some greedy rules besides searching?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 961526,
                "title": "python-bruteforce-a-hard-solution-for-a-medium-question",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        def func(a,k):\\n            if a not in dd:\\n                d={}\\n                for x in a: d[x]=d.get(x,0)+1\\n                if max(d.values())>k: dd[a]=-1\\n                elif k==1: dd[a]=a[-1]-a[0]\\n                else:\\n                    s=-1\\n                    for x in combinations([i for i in range(1,len(a))],(k//2)*n-1):\\n                        x,l,r=set(x),[a[0]],[]\\n                        for i in range(1,len(a)):\\n                            if i in x: l.append(a[i])\\n                            else: r.append(a[i])\\n                        p,q=func(tuple(l),k//2),func(tuple(r),k-k//2)\\n                        if p!=-1 and q!=-1 and (s==-1 or p+q<s): s=p+q\\n                    dd[a]=s\\n            return dd[a]\\n        dd,n={},len(nums)//k\\n        if n==1: return 0\\n        nums.sort()\\n        return func(tuple(nums),k)\\n```\\n\\nFrankly, I didn\\'t see why it was medium, unless there are some fundamentally better solutions, perhaps for 1 <= nums[i] <= nums.length.\\n\\nAnyway, the idea is to divide nums into two k//2, (k+1)//2 parts, until k==1.\\n\\nI tried this in contest simply because it would unlikely get TLE.\\nSay, if len(nums) = 16, k = 2, the time complexity would be Comb(15,7) * Comb(7,3) * Comb(3,1) < 1,000,000, the safe threshold for leetcode.",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minimumIncompatibility(self, nums: List[int], k: int) -> int:\\n        def func(a,k):\\n            if a not in dd:\\n                d={}\\n                for x in a: d[x]=d.get(x,0)+1\\n                if max(d.values())>k: dd[a]=-1\\n                elif k==1: dd[a]=a[-1]-a[0]\\n                else:\\n                    s=-1\\n                    for x in combinations([i for i in range(1,len(a))],(k//2)*n-1):\\n                        x,l,r=set(x),[a[0]],[]\\n                        for i in range(1,len(a)):\\n                            if i in x: l.append(a[i])\\n                            else: r.append(a[i])\\n                        p,q=func(tuple(l),k//2),func(tuple(r),k-k//2)\\n                        if p!=-1 and q!=-1 and (s==-1 or p+q<s): s=p+q\\n                    dd[a]=s\\n            return dd[a]\\n        dd,n={},len(nums)//k\\n        if n==1: return 0\\n        nums.sort()\\n        return func(tuple(nums),k)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564873,
                "content": [
                    {
                        "username": "kretash",
                        "content": "Shouln\\'t this be hard? Not only because it was the last question in the contest but it\\'s also way harder than the 2 other medium ones."
                    }
                ]
            }
        ]
    }
]