[
    {
        "title": "Finding the Topic of Each Post",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568744,
                "content": [
                    {
                        "username": "arjunsuri",
                        "content": "WITH post_split AS (SELECT post_id, value split_word \\nFROM Posts  \\n    CROSS APPLY STRING_SPLIT(content, \\' \\')), #split your string \\n\\npost_topics AS (select distinct post_id, topic_id\\nFROM post_split p \\nLEFT JOIN Keywords k on LOWER(k.word) = LOWER(p.split_word)\\n) #match split words with Keywords table\\n\\n\\nselect post_id, isnull(string_agg(topic_id, \\',\\') WITHIN GROUP(ORDER BY topic_id ),\\'Ambiguous!\\') topic\\nfrom post_topics\\ngroup by post_id #concatenate the results"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum White Tiles After Covering With Carpets",
        "question_content": "<p>You are given a <strong>0-indexed binary</strong> string <code>floor</code>, which represents the colors of tiles on a floor:</p>\n\n<ul>\n\t<li><code>floor[i] = &#39;0&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>black</strong>.</li>\n\t<li>On the other hand, <code>floor[i] = &#39;1&#39;</code> denotes that the <code>i<sup>th</sup></code> tile of the floor is colored <strong>white</strong>.</li>\n</ul>\n\n<p>You are also given <code>numCarpets</code> and <code>carpetLen</code>. You have <code>numCarpets</code> <strong>black</strong> carpets, each of length <code>carpetLen</code> tiles. Cover the tiles with the given carpets such that the number of <strong>white</strong> tiles still visible is <strong>minimum</strong>. Carpets may overlap one another.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of white tiles still visible.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png\" style=\"width: 400px; height: 73px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;10110101&quot;, numCarpets = 2, carpetLen = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/10/ex2.png\" style=\"width: 353px; height: 123px;\" />\n<pre>\n<strong>Input:</strong> floor = &quot;11111&quot;, numCarpets = 2, carpetLen = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= carpetLen &lt;= floor.length &lt;= 1000</code></li>\n\t<li><code>floor[i]</code> is either <code>&#39;0&#39;</code> or <code>&#39;1&#39;</code>.</li>\n\t<li><code>1 &lt;= numCarpets &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1863955,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`dp[i][k]` means that,\\nusing `k` tiles to cover the first `i` tiles\\nthe minimum number of white tiles still visible.\\n\\n\\nFor each tile `s[i]`, we heve two options,\\nOne option is doing nothing, `jump` this tile,\\n`jump = dp[i - 1][k] + int(s[i - 1])`\\nThe other option is covering this tile\\n`cover = dp[i - l][k - 1]`\\n\\nThen we take the minimum result of two options:\\n`dp[i][k] = min(jump, cover)`\\n\\nFinally after explore all combination of `(i,k)`,\\nwe return `dp[n][nc]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(NC)`\\nSpace `O(NC)`\\nwhere `N = floor.length` and `C = numCarpets`.\\nSpace can be optimized to `O(N)`.\\n<br>\\n\\n**Java**\\n```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int minimumWhiteTiles(String s, int nc, int l) {\\n        int n = s.length(), dp[][] = new int[n + 1][nc + 1];\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s.charAt(i - 1) - \\'0\\';\\n                int cover = k > 0 ? dp[Math.max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = Math.min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```cpp\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(nc + 1));\\n        for (int i = 1; i <= n; ++i) {\\n            for (int k = 0; k <= nc; ++k) {\\n                int jump = dp[i - 1][k] + s[i - 1] - \\'0\\';\\n                int cover = k > 0 ? dp[max(i - l, 0)][k - 1] : 1000;\\n                dp[i][k] = min(cover, jump);\\n            }\\n        }\\n        return dp[n][nc];\\n    }\\n```\n```py\\n    def minimumWhiteTiles(self, A, k, l):\\n\\n        @lru_cache(None)\\n        def dp(i, k):\\n            if i <= 0: return 0\\n            return min(int(A[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)\\n            \\n        return dp(len(A), k) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1864150,
                "title": "c-solution-top-down-dynamic-programming-recursion-memoization",
                "content": "Iterate over string `floor`:\\n\\n- At each index `pos` in the string `floor` we have two options:\\n\\n    - Use a carpet, that starts from the index `pos` and ends at `pos + carpetLength - 1`. All tiles in this part will change to black, hence move to index `pos + carpetLength`\\n    - Skip the index and move to next index `pos + 1`. This time the tile at index `pos` will be unchanged, thus add `1` to the answer if it\\'s a white tile.\\n\\n- After either of the options, recursively move to the next index. Return the minimum of the above two options.\\n\\nBase Case:\\n\\n- If we have traversed the whole string `floor`, then no white tiles present. Hence return `0`.\\n- If we have used all the available carpets, then the remaining string will not change. Hence return the number of `1`\\'s in the remaining string. (Store the number of `1`s for the suffix `[i, N]` in the array `suffix` beforehand, instead of finding it again and again).\\n\\nThere will be repeated subproblems corresponding to index (`pos`) and the number of carpet used (`used`). Hence store the result in the table `dp` and use it to answer repeated problems insetad of going into recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int suffix[1001];\\n\\n    void findSuffixSum(string& floor) {\\n        int n = floor.size();\\n        \\n        suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int solve(string& floor, int numCarpets, int carpetLen, int pos, int used) {\\n        if (pos >= floor.size()) {\\n            return 0;\\n        } else if (used == numCarpets) {\\n            return suffix[pos];\\n        }\\n        \\n        if (dp[pos][used] != -1) {\\n            return dp[pos][used];\\n        }\\n\\n        return dp[pos][used] = min(solve(floor, numCarpets, carpetLen, pos + carpetLen, used + 1),\\n                      (floor[pos] == \\'1\\') + solve(floor, numCarpets, carpetLen, pos + 1, used));\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp, -1, sizeof(dp));\\n        findSuffixSum(floor);\\n        \\n        return solve(floor, numCarpets, carpetLen, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863872,
                "title": "python-short-dp-explained",
                "content": "Problem constraints will help you to understand that this problem can be solved with `dp`. Let the state `dp(i, t)` be minimum number of white tiles when we allowed to use `t` number of carpets such that their right (and hence all carpets) lies in `[0, i]`. Then each moment of time we have option to take carpet or do not take it:\\n1. If we take, previous state is `dp(i - L, t - 1)`.\\n2. If we do not take it, previous state is `dp(i - 1, t) + `int(floor[i] == \"1\")`.\\n\\n#### Complexity\\nIt is `O(n^2)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, k, L):\\n        @lru_cache(None)\\n        def dp(i, t):\\n            if t < 0: return float(\"inf\")\\n            if i < 0: return 0\\n            return min(dp(i - L, t - 1), dp(i - 1, t) + int(floor[i] == \"1\"))\\n        \\n        return dp(len(floor) - 1, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863912,
                "title": "dp-detailed-explanation-with-commented-code",
                "content": "Imagine we are covering the floor with carpets from left to right. At any point in this exercise, we will be at some point i and have carpetsRemaining carpets remaining. At this point we are only concerned with covering the floor from i to n - 1. \\nIn other words i can say that the state at any point is fully defined by (current position, carpets remaining)\\n\\nWhen we are standing at index i, we have 2 choices\\n\\t* either skip this tile and leave it uncovered\\n\\t* use one carpet starting from here.\\n\\nFirst off, If we are currently on a black tile, it makes no sense to start a new carpet here, so we just move one step to the right. (whatever white tiles we cover by starting here, we can cover from i + 1 and possibly more)\\nNow that we are on a white tile, \\n\\t* If we apply option 1 and skip this tile, we would expose 1 white tile and continue the exercise from tile i + 1 with the same number of carpets remaining\\n\\t* If we apply option 2 and start a new carpet here, we would use one carpet and continue the exercise from tile i + carpetLen.\\n\\twe would obviously want to take the option which would expose the minumum number of white tiles. \\n\\nIf f( i , carpetsRemaining ) represents the minimum number if white tiles exposed for the floor from i to n - 1 with carpetsRemaining carpets remaining, \\n//base cases\\n* if( i >= n) then ans = 0. ( we have fully covered the floor and are standing to the right of it)\\n* if( carpetsRemaining == 0 ) then ans = number of zeroes from i to n - 1. (We dont have any more carpets and will expose everything here on out)\\n```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\\n//recursive cases\\n* if( floor[i] == BLACK ) then ans = f ( i + 1, carpetsRemaining). (Just ignore this tile, continue from next index)\\n* if( floor[i] == WHITE ) then ans = Max of\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* 1 + f( i + 1, carpetsRemaining)      (expose this tile, hence + 1, and continue with same number of carpets)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t* f( i + carpetLen, carpetsRemaining - 1 )      (start a new carpet here, skip carpetLen tiles, but have 1 less carpet)\\n\\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\\n\\nThere are (n * numCarpets) states, we momoize the result for each state in a 2D array.\\nTime Complexity: O(n * numCarpets)\\nSpace Complexity: O(n * numCarpets)\\n\\nFull Code:\\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tif(i >= a.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif(carpets_left == 0) {\\n\\t\\treturn suffix[i];      //suffix[i] = number of white tiles from index i to n (can be calculated using a simple for loop)\\n\\t}\\n```\n```\\n\\t // first check if this state has already been visited, if so return the answer already computed\\n\\tif(dp[i][carpets_left] != UNVISITED) {      \\n\\t\\treturn dp[i][carpets_left];\\n\\t}\\n\\tif(a[i] == BLACK) {\\n\\t\\t//this tile is black, skip it\\n\\t\\tdp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t}\\n\\telse {\\n\\t\\t//start carpet here\\n\\t\\tint start_carpet_here = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n\\t\\t//dont start carpet here\\n\\t\\tint dont_start_carpet_here = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\t\\tdp[i][carpets_left] = Math.min(start_carpet_here, dont_start_carpet_here);\\n\\t}\\n\\n\\treturn dp[i][carpets_left];\\n```\n```\\nclass Solution {\\n    private static final int UNVISITED = -1;\\n    private static final char BLACK = \\'0\\';\\n    private static final char WHITE = \\'1\\';\\n\\n    private int f(int i, int carpets_left, char[] a, int[][] dp, int[] suffix, int carpetLen) {\\n        if(i >= a.length) {\\n            return 0;\\n        }\\n        if(carpets_left == 0) {\\n            return suffix[i];\\n        }\\n        if(dp[i][carpets_left] != UNVISITED) {\\n            return dp[i][carpets_left];\\n        }\\n        if(a[i] == BLACK) {\\n            dp[i][carpets_left] = f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n        }\\n        else {\\n            //start carpet here\\n            int start = f(i + carpetLen, carpets_left - 1, a, dp, suffix, carpetLen);\\n            //dont start carpet here\\n            int dont = 1 + f(i + 1, carpets_left, a, dp, suffix, carpetLen);\\n\\n            dp[i][carpets_left] = Math.min(start, dont);\\n        }\\n\\n        return dp[i][carpets_left];\\n    }\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.length();\\n        char[] a = floor.toCharArray();\\n        \\n        //calculating the suffix array\\n        int[] suffix = new int[n + 1];\\n        for(int i = n - 1; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1];\\n            if(a[i] == WHITE) {\\n                suffix[i] ++;\\n            }\\n        }\\n        \\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for(int[] row : dp) {\\n            Arrays.fill(row, UNVISITED);\\n        }\\n\\n        return f(0, numCarpets, a, dp, suffix, carpetLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863967,
                "title": "memory-optimized-dp",
                "content": "It feels like there could be some clever way to lay carpets, but there isn\\'t. We need to search for an optimal solution.\\n\\n> Note: problem constrains give it away.\\n\\nWe start with the top-down approach, and then convert it to the bottom-up one. By analyzing the tabulation, we can reduce the memory usage to O(n). The runtime for the final, memory-optimized bottom-up approach is 120 ms.\\n\\n#### Top-Down\\nFor the search, we can skip positions with black tiles.\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\\n\\n#### Bottom-Up\\n**C++**\\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\\n\\n#### Memory-Optimized Bottom-Up DP\\nWe can rearrange loops from the solution above so that the first loop iterates through carpets. That way, we only need to store tabulation values for the current and previous step. \\n\\n**C++**\\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001][1001] = {};\\nint dfs(string &floor, int i, int n, int len) {\\n    if (n < 0)\\n        return floor.size();\\n    if (floor.size() - i <= n * len)\\n        return 0;\\n    if (floor[i] == \\'0\\')\\n        return dfs(floor, i + 1, n, len);\\n    if (dp[i][n] == 0)\\n        dp[i][n] = 1 + min(1 + dfs(floor, i + 1, n, len), dfs(floor, i + len, n - 1, len)); \\n    return dp[i][n] - 1;\\n}\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    return dfs(floor, 0, numCarpets, len);\\n} \\n```\n```cpp\\nint dp[1001][1001] = {};\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    for (int i = floor.size() - 1; i >= 0; --i) {\\n        dp[i][0] = dp[i + 1][0] + (floor[i] == \\'1\\');\\n        for (int c = 1; c <= numCarpets; ++c)\\n            dp[i][c] = min(dp[i + 1][c] + (floor[i] == \\'1\\'), dp[min(1000, i + len)][c - 1]);\\n    }\\n    return dp[0][numCarpets];\\n}  \\n```\n```cpp\\nint minimumWhiteTiles(string floor, int numCarpets, int len) {\\n    int sz = floor.size(), dp[2][1001] = {};\\n    for (int i = 0; i < sz; ++i)\\n        dp[0][i + 1] += dp[0][i] + (floor[i] == \\'1\\');  \\n    for (int c = 1; c <= numCarpets; ++c)\\n        for (int i = 0; i < sz; ++i)\\n            dp[c % 2][i + 1] = min(dp[c % 2][i] + (floor[i] == \\'1\\'),\\n                dp[(c + 1) % 2][max(0, i + 1 - len)]);\\n    return dp[numCarpets % 2][sz];\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863927,
                "title": "c-easy-to-understand-with-explanation-and-optimizations-dp",
                "content": "Hello, while it may seem like a difficult one, the fourth question can be done with an almost bruteforce approach with some optimizations.\\n\\nLet dp[i][j] denote the maximum number of ones we can cover with i carpets till index j(**with current carpet ending exactly at index j**). Assuming that the current carpet ends at exactly j *greatly simplifies* the problem\\n\\nNow, dp[i][j]= number of ones in string[j:j-len]+ max(dp[i-1][j-len], dp[i-1][j-len-1],....dp[i-1][0])\\n\\nOptimizations:\\nWe store this max part of previous iteration of i till j-len in a helper variable. (prevmax)\\nWe use prefix sum array to calculate number of white blocks in a range in O(1) time\\nWe only need the ith and i-1th rows of the dp array, so space can be reduced (didn\\'t do it due to time constraints during contest)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int dp[1001][1001]={0};\\n        int pre[1000]={0};\\n        if(floor[0]==\\'1\\')pre[0]=1;\\n        for(int i=1;i<floor.size();i++){\\n            pre[i]+=pre[i-1];\\n            if(floor[i]==\\'1\\')pre[i]++;\\n        }\\n        for(int i=1;i<=numCarpets;i++){\\n            int prevmax=0;\\n            for(int j=0;j<floor.size();j++){\\n                if(j<carpetLen) dp[i][j]=pre[j];\\n                else{\\n                    prevmax=max(prevmax,dp[i-1][j-carpetLen]);\\n                    dp[i][j]=pre[j]-pre[j-carpetLen]+prevmax;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<floor.size();i++)ans=max(ans,dp[numCarpets][i]);\\n        return pre[floor.size()-1]-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864377,
                "title": "java-knapsack-solution",
                "content": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int pref[];\\n\\n    public int minimumWhiteTiles(String floor, int tot, int len) {\\n        char a[] = floor.toCharArray();\\n        this.pref = new int[a.length];\\n        int c = 0;\\n        this.dp = new int[a.length + 1][tot + 1];\\n        for (int d[] : dp) Arrays.fill(d, -1);\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == \\'1\\') c++;\\n            pref[i] = c;\\n        }\\n        return pref[a.length - 1] - solve(0, a, tot, len);  // total ones - max removed\\n    }\\n\\n    int dp[][];\\n\\n    private int solve(int index, char a[], int tot, int len) {\\n        if (index >= a.length || tot == 0) {\\n            return 0;\\n        }\\n        if (dp[index][tot] != -1) return dp[index][tot];\\n        int ones = pref[Math.min(index + len - 1, a.length - 1)] - (index == 0 ? 0 : pref[index - 1]);\\n        int take = ones + solve(index + len, a, tot - 1, len);  // either take it and add one\\'s count in that subsegment\\n        int dont = solve(index + 1, a, tot, len);  // or dont \\n        return dp[index][tot] = Math.max(take, dont);  // return max of both\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863879,
                "title": "c-fixed-length-sliding-window-dp",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Fixed-length Sliding Window + DP\\n\\n**Intuition**:\\n\\n1. Use a sliding window of length `carpetLen` to compute a `cover` array where `cover[i]` is the number of white tiles covered by a carpet placed ending at `floor[i]`.\\n2. Use DP to calculate the maximum coverable white tiles using `numCarpets` carpets.\\n\\n**Algorithm**:\\n\\n**Fixed-length Sliding Window**:\\n\\nKeep a rolling sum `white` as the number of white tiles within the sliding window.\\n\\nFor each `i` in range `[0, N)`, we:\\n* increment `white` if `s[i] == \\'1\\'`\\n* decrement `white` if `s[i - len] == \\'1\\'`\\n* Set `cover[i] = white`.\\n\\n**DP**:\\n\\nLet `dp[i][j + 1]` be the maximum number of coverable white tiles where `1 <= i <= numCarpet` is number of carpets used and `0 <= j < N` is the last index where we can place carpet.\\n\\nAll `dp` values are initialized as `0`s.\\n\\nFor each `dp[i][j + 1]`, we have two options:\\n1. Don\\'t place carpet at index `j`. `dp[i][j+1] = dp[i][j]`\\n2. Place carpet ending at index `j` covering `cover[j]` white tiles. And we can place `i-1` carpets at or before `j-carpetLen`. So, `dp[i][j+1] = dp[i-1][j-carpetLen+1] + cover[j]`.\\n\\n```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\\n\\n`dp[numCarpet][N]` is the maximum number of white titles coverable. The answer is the number of total white tiles minus `dp[numCarpet][N]`. \\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\\n\\nWe can reduce the space complexity to `O(N)` by using rolling arrays.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j + 1] = max(\\n                    dp[i][j],                                                                   // don\\'t place carpet at index `j`\\n                    (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]      // place carpet at index `j`\\n                  )\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N * numCarpet)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<vector<int>> dp(numCarpet + 1, vector<int>(N + 1));\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                dp[i][j + 1] = max(dp[i][j], (j - carpetLen + 1 >= 0 ? dp[i - 1][j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n        }\\n        return sum - dp[numCarpet][N];\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/\\n// Author: github.com/lzl124631x\\n// Time: O(N * numCarpet)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpet, int carpetLen) {\\n        int N = floor.size(), sum = 0;\\n        vector<int> cover(N);\\n        for (int i = 0, white = 0; i < N; ++i) {\\n            sum += floor[i] - \\'0\\';\\n            white += floor[i] - \\'0\\';\\n            if (i - carpetLen >= 0) white -= floor[i - carpetLen] - \\'0\\'; \\n            cover[i] = white;\\n        }\\n        vector<int> dp(N + 1);\\n        for (int i = 1; i <= numCarpet; ++i) {\\n            vector<int> next(N + 1);\\n            for (int j = 0; j < N; ++j) {\\n                next[j + 1] = max(next[j], (j - carpetLen + 1 >= 0 ? dp[j - carpetLen + 1] : 0) + cover[j]);\\n            }\\n            swap(dp, next);\\n        }\\n        return sum - dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864445,
                "title": "c-knapsack-memoization",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<int> suffix;\\n    vector<vector<int>> memo;\\npublic:\\n    \\n    int doit(string& floor, int carp, int len, int ind) {\\n        if (ind >= n)   return 0;\\n        if (carp == 0)  return suffix[ind]; // if no carpets are left then all the white tiles from current index to the last will be visible\\n        if (memo[carp][ind] != -1)  return memo[carp][ind];\\n        int a = doit(floor, carp-1, len, ind+len); // carpet is used\\n        int b = doit(floor, carp, len, ind+1) + (floor[ind] == \\'1\\'); // carpet is not used\\n        return memo[carp][ind] = min(a, b);\\n    }\\n        \\n    int minimumWhiteTiles(string floor, int carp, int len) {\\n        \\n        n = size(floor);\\n        suffix.resize(n+1, 0);\\n        memo.resize(carp+1, vector<int>(n+1, -1));\\n        suffix[n-1] = (floor[n-1] == \\'1\\');\\n        for (int i=n-2; ~i; i--)\\n            suffix[i] = suffix[i+1] + (floor[i] == \\'1\\');\\n        \\n        return doit(floor, carp, len, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864242,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int recur(string &s, int numCarpets, int len, int i, vector<vector < int>> &dp, vector< int > &sufOnes)\\n        {\\n            if (i >= s.size())\\n                return 0;\\n            if (numCarpets == 0)\\n                return sufOnes[i];\\n\\n            if (dp[i][numCarpets] != -1)\\n            {\\n                return dp[i][numCarpets];\\n            }\\n            if (s[i] == \\'0\\')\\n            {\\n                dp[i][numCarpets] = recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n            }\\n            else\\n            {\\n               \\t//start carpet here\\n                int start = recur(s, numCarpets - 1, len, i + len, dp, sufOnes);\\n               \\t//dont start carpet here\\n                int dont = 1 + recur(s, numCarpets, len, i + 1, dp, sufOnes);\\n\\n                dp[i][numCarpets] = min(start, dont);\\n            }\\n\\n            return dp[i][numCarpets];\\n        }\\n    int minimumWhiteTiles(string s, int n, int len)\\n    {\\n        int nn = s.size() + 1, mm = n + 1;\\n        vector<int> sufOnes(s.size() + 1, 0);\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            sufOnes[i] = sufOnes[i + 1];\\n            if (s[i] == \\'1\\')\\n            {\\n                sufOnes[i]++;\\n            }\\n        }\\n        vector<vector < int>> dp(nn, vector<int> (mm, -1));\\n        return recur(s, n, len, 0, dp, sufOnes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863886,
                "title": "c-dp-memoization",
                "content": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\n\\tvector<vector<int>> dp;\\n    int func(int i,string& s,int car,int len){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][car]!=-1) return dp[i][car];\\n        if(s[i]==\\'0\\') return dp[i][car]=func(i+1,s,car,len);\\n        else{ \\n            int ans=INT_MAX;\\n            ans=1+func(i+1,s,car,len);\\n            if(car>0) ans=min(ans,func(i+len,s,car-1,len));\\n            return dp[i][car]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string s, int car, int len) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(car+1,-1));\\n        return func(0,s,car,len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1872882,
                "title": "python-readable-and-easy-understand-bottom-up-dp-solution-in-python",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        if carpetLen*numCarpets >= n:\\n            return 0\\n        floorlist = []\\n        for i in floor:\\n            if i == \\'1\\':\\n                floorlist.append(1)\\n            else:\\n                floorlist.append(0)\\n        dp=[[0] * n for i in range(numCarpets)]\\n        \\n        for i in range(carpetLen, n):\\n            dp[0][i] = min(floorlist[i] + dp[0][i-1], sum(floorlist[:i - carpetLen + 1]))\\n        for j in range(1, numCarpets):\\n            for i in range(carpetLen * j, n):\\n                dp[j][i] = min(floorlist[i] + dp[j][i - 1], dp[j - 1][i - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332778,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(string &floor, int Carpets, int Len, int idx, vector<vector<int>> &dp)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n        int val = 0;\\n        if(dp[idx][Carpets] != -1) return dp[idx][Carpets];\\n        if(Carpets == 0)\\n        {\\n            for(int i = idx; i < floor.size(); i++)\\n                if(floor[i] == \\'1\\') val++;\\n        }\\n        else\\n        {\\n            if(floor[idx] == \\'0\\')\\n                val = dfs(floor, Carpets, Len, idx+1, dp);\\n            else\\n            {\\n                val = min(1+dfs(floor, Carpets, Len, idx+1, dp), dfs(floor, Carpets-1, Len, idx+Len, dp));\\n            }\\n        }\\n        return dp[idx][Carpets] = val;\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> dp(n+1, vector<int> (numCarpets+1, -1));\\n        return dfs(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864204,
                "title": "recursion-memoization-time-saver-trick",
                "content": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```\\nThe question could be solved in a recursive manner where you just need to know the index and the number of carpets left, now at any index we have two options either we can use the available carpets or we can leave this index as it is. We can consider both options and return the minimum of both the available options.\\n\\nI have used a trick that is I used a reference variable to store dp[idx][numCarpets], now imagine those questions where we have 3 or 4 states and we don\\'t want those dp[][][] states again and again. We can simply use reference variables and we can use them our code to save sometime in competitions.\\n\\nPlease upvote if you have learnt anything from this post.",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[1001][1001];\\n    int helper(string &floor, int idx, int numCarpets, int len)\\n    {\\n        if(idx >= floor.size())\\n            return 0;\\n\\t\\t\\t\\n        int &ans = dp[idx][numCarpets]; //reference variable so that we dont have to write this again \\n        \\n        if(ans != -1) //if state already calculated no need to calculate again directly return its value\\n            return ans;\\n        \\n        int op1 = INT_MAX, op2 = INT_MAX;\\n\\t\\t//when you dont use a new carpet from the current index\\n        op1 = (floor[idx] == \\'1\\') + helper(floor, idx+1, numCarpets, len);\\n\\t\\t//when you use a new carpet from the current index\\n        if(numCarpets > 0)\\n        op2 = helper(floor, idx+len, numCarpets-1, len);\\n        return ans = min(op1, op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetlen) {\\n        memset(dp, -1, sizeof(dp));\\n        return helper(floor, 0, numCarpets, carpetlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863913,
                "title": "python-dynamic-programming-prefix-sum-solution-explained",
                "content": "So this is a dynamic programming question with a trick.\\nYou can guess it using the given constraints.\\nThe solution can be divided into two parts:\\n*  Recursively find ways to use carpets to cover the floor \\n* Optimize using **Prefix Sum** to find the number of white tiles present between two indices of the floor\\n\\nPlease read through the comments for better understanding!\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\tn = len(floor)\\n\\t\\t#Using memo table to store predefined computations\\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \\n        def solve(N,numCarpets):\\n\\t\\t\\t#Base Case\\n            if N>=n:\\n                return 0\\n\\t\\t\\t#If calculated previously use that solution\\n            if memo[N][numCarpets]!=-1:\\n                return memo[N][numCarpets]\\n\\t\\t\\t\\t\\n            used = 0 # If you use the carpet\\n            notused = 0 # If you donot use the carpet\\n\\t\\t\\t\\n            if floor[N]==\\'1\\': # We might use the carpet in this part\\n                if numCarpets>0: #Whether we even have some carpets or not\\n\\t\\t\\t\\t    \"\"\"\\n\\t\\t\\t\\t\\tOptimization Part\\n\\t\\t\\t\\t\\tWe are finding the number of ones present in this part of the floor.\\n\\t\\t\\t\\t\\tprefix[lastInd] - Number of ones till lastInd\\n\\t\\t\\t\\t\\tprefix[N] - Number of ones till Nth Index.\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tTheir difference gives us how many ones present between the two.\\n\\t\\t\\t\\t    \"\"\"\\n                    lastInd = min(N+carpetLen,len(floor)) \\n                    ans = prefix[lastInd] - prefix[N]\\n                    \\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tFind the max if we use or donot use carpet at this index\\n\\t\\t\\t\\t\\tIf we do we add  --- ans and decrement remaining carpets\\n\\t\\t\\t\\t\\telse we donot\\n\\t\\t\\t\\t\\t\"\"\"\\n                    used = max(solve(N+carpetLen,numCarpets-1)+ans,solve(N+1,numCarpets))\\n                            \\n                else:\\n                    used = 0\\n            \\n            else:\\n\\t\\t\\t#If we donot use the carpet although I feel this might be redundant code\\n                notused = solve(N+1,numCarpets)\\n            \\n\\t\\t\\t#Using max function to find the number of white tiles removed\\n            memo[N][numCarpets] = max(used,notused)\\n            return memo[N][numCarpets]\\n\\t\\t\\n\\t\\t#Total White tiles\\n        ones = 0\\n        for x in floor:\\n            if x == \\'1\\':\\n                ones+=1\\n        \\n\\t\\t#Using Prefix array to store number of ones till i th index\\n        prefix = [0]*(n+1)\\n        for i in range(1,n+1):\\n            if floor[i-1]==\\'1\\':\\n                prefix[i] = prefix[i-1]+1\\n            else:\\n                prefix[i] = prefix[i-1]\\n\\t\\t\\t\\t\\n       \\n        removed = solve(0,numCarpets)\\n        \\n        return ones-removed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889364,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int min(int a, int b)\\n    {\\n        if(a<b) return a;\\n        return b;\\n    }\\n    \\n    int func(string &floor, int numCarpets, int &carpetLen, int i, vector<int> &prefix)\\n    {\\n        //Base Cases\\n        if(i>=floor.size())\\n            return 0;\\n        if(numCarpets==0)\\n            return 0;\\n        \\n        //Memoization\\n        if(dp[i][numCarpets]!=-1)\\n            return dp[i][numCarpets];\\n        \\n        //Check if current tile is black, if it is then skip it\\n        if(floor[i]==\\'0\\')\\n            return dp[i][numCarpets]=func(floor, numCarpets, carpetLen, i+1, prefix);\\n        \\n        //temp stores the value of index where pointer i should point after the carpet covers white tiles \\n        //sometimes i+len can place you out of scope of prefix array that\\'s why floor.size() is also considered\\n        int temp=min(i+carpetLen, floor.size())-1;\\n        int white=prefix[temp];\\n        if(i!=0) // i==0 is not fit for this condition(no elements before index 0)\\n            white-=prefix[i-1]; // this line gives exact number of white tiles in between(covered by carpet)\\n        /*Suppose 1 0 1 1 0 1 0 1 is the input floor array and carpetLen =2. Prefix array would be 1 1 2 3 3 4 4 5.\\n        Let us suppose  i=2 then \\n        temp=i+carpetLen-1 temp=2+2-1 temp=4-1 temp=3  \\n        white=prefix[temp] white=prefix[3] white=3 \\n        white=white-prefix[i-1]= white=3-prefix[2-1]= white=3-prefix[1] white=3-1 white=2*/\\n        \\n        \\n        int pick=white+func(floor,numCarpets-1,carpetLen, i+carpetLen, prefix); //when you use a new carpet from the current index\\n        int notpick=func(floor,numCarpets,carpetLen, i+1, prefix); //when you dont use a new carpet from the current index\\n        \\n        return dp[i][numCarpets]=max(pick, notpick); //maximum number of white tiles that can be covered by the carpet\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        //for faster i/p o/p\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        memset(dp,-1,sizeof dp);\\n        \\n        //prefix array is used to store total number of white tiles till current index\\n        vector<int>prefix(floor.size()); \\n        if(floor[0]==\\'1\\')\\n            prefix[0]=1;\\n        else\\n            prefix[0]=0;\\n        \\n        for(int i=1; i<floor.size(); i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        \\n        if(prefix[floor.size()-1]==0)\\n            return 0;\\n        \\n        // minimum number of white tiles still visible = total number of white tiles - maximum number of white tiles that can be covered by the carpet\\n        return prefix[floor.size()-1]-func(floor, numCarpets, carpetLen, 0, prefix); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863869,
                "title": "python3-dp-accepted-is-my-runtime-analysis-correct-o-2-n",
                "content": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "solutionTags": [],
                "code": "Below is accepted.\\n\\nI struggle with figuring out runtime for DP problems, can someone help? \\nIs it O(2^N)? My reasoning being that at each backtrack calll, you either cover the piano, or you don\\'t. That\\'s 2 choices with at most N steps/piano tiles.\\n\\nAlso what would be the best way to manually memoize the results without using @lru_cache here?\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets * carpetLen >= len(floor):\\n            return 0\\n        \\n        white_to_right = [0] * len(floor)\\n        for i in range(len(floor)-1, -1, -1):\\n            if i == len(floor) - 1:\\n                white_to_right[i] = 1 if floor[i] == \\'1\\' else 0\\n            else:\\n                white_to_right[i] = white_to_right[i+1]\\n                white_to_right[i] += 1 if floor[i] == \\'1\\' else 0\\n        \\n        @lru_cache(maxsize=None)\\n        def backtrack(index, remaining):\\n            if index >= len(floor):\\n                return 0\\n            \\n            if remaining == 0:\\n                return white_to_right[index]\\n            \\n            # cover carpet starting at this index\\n            cover_now = backtrack(index + carpetLen, remaining - 1)\\n\\n            # no-op, cover at next index\\n            cover_later = backtrack(index + 1, remaining)\\n            cover_later += 1 if floor[index] == \\'1\\' else 0\\n            \\n            return min(cover_now, cover_later)\\n\\n        return backtrack(0, numCarpets)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1985493,
                "title": "c-0-1-knapsack",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[1001][1001];\\n    int solve(string& floor,int idx,int n,int car,int len,vector<int>&prefix)\\n    {\\n        if(idx==n || car==0)\\n            return 0;\\n        \\n        if(dp[idx][car]!=-1)\\n            return dp[idx][car];\\n        \\n        int range=min(idx+len-1,n-1);\\n        int cnt=prefix[range];\\n        \\n        if(idx>0)\\n            cnt-=prefix[idx-1];\\n        \\n        int pick=cnt+solve(floor,min(idx+len,n),n,car-1,len,prefix);\\n        int skip=solve(floor,idx+1,n,car,len,prefix);\\n        return dp[idx][car]=max(pick,skip);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int Carpet, int carpetLen) {       \\n        \\n        memset(dp,-1,sizeof dp);\\n        int n=floor.size();\\n        vector<int>prefix(n,0);\\n        int cnt=0;\\n        for(auto i=0;i<n;++i)\\n        {\\n            if(floor[i]==\\'1\\')\\n                cnt++;\\n            \\n            prefix[i]=cnt;\\n        \\n        }\\n        return cnt-solve(floor,0,floor.size(),Carpet,carpetLen,prefix);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880725,
                "title": "java-top-down-dynamic-programming-memoization",
                "content": "Solution:\\n```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> cache;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        cache = new HashMap<>();\\n        return helper(floor, 0, numCarpets, carpetLen);\\n    }\\n    \\n    public int helper(String floor, int position, int numCarpets, int carpetLen) {\\n        if (position >= floor.length()) {\\n            return 0;\\n        }\\n        \\n        if (floor.length() - position <= numCarpets * carpetLen) {\\n            return 0;\\n        }\\n        \\n        String key = position + \", \" + numCarpets;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        \\n        if (numCarpets == 0) {\\n            int output = floor.charAt(position) - \\'0\\' + helper(floor, position + 1, 0, carpetLen);\\n            \\n            cache.put(key, output);\\n            return output;\\n        }\\n        \\n        int output = Math.min(floor.charAt(position) - \\'0\\' + helper(floor, position + 1, numCarpets, carpetLen), helper(floor, position + carpetLen, numCarpets - 1, carpetLen));\\n        \\n        cache.put(key, output);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877103,
                "title": "dynamic-programming-based-solution-recursion-memoization-c-clean-code",
                "content": "# Code :\\n\\n```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N*M)` \\n* Space : `O(N*M)`\\n\\t* N : length of `floor` string\\n\\t* M : number of carpets available\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n    vector<int> whiteCount; // Stores no. of white tiles from ith index till the end\\n    \\n\\t// Count number of white tile from index till end \\n\\t// Suffix sum of no. of white tiles\\n    void countTiles(string& floor, int n) {\\n        whiteCount.resize(n+2, 0);\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            whiteCount[i] = whiteCount[i+1] + (floor[i] == \\'1\\');\\n        }\\n    }\\n    \\n    int uncoveredWhiteTiles(string& floor, vector<vector<int>>& dp, int numCarpets, int idx, int carpetLen, int n) {\\n        \\n\\t\\t// If we reach the end, then no white is remaining\\n\\t\\t// Assuming that all previous white tiles are covered already using carpets\\n        if(idx >= n) {\\n            return 0;\\n        }\\n\\t\\t// If no carpet is available, then all the white tiles from current index\\n\\t\\t// Till the end are uncovered. Hence return its count\\n        if(numCarpets == 0) {\\n            return whiteCount[idx];\\n        }\\n        \\n\\t\\t// If we have some value for current state in DP table, then return it\\n        if(dp[idx][numCarpets] != -1) return dp[idx][numCarpets];\\n        \\n        int countWhites = n;\\n        \\n        // We have two choices at this point\\n\\t\\t// Choice 1 : Use a carpet starting from current index till carpetLen\\n\\t\\t// Choice 2 : Do no use any carpet, and move to next index. \\n\\t\\t// But if current tile is white then count it as uncovered\\n        countWhites = min(\\n            uncoveredWhiteTiles(floor, dp, numCarpets-1, idx+carpetLen, carpetLen, n),\\n            uncoveredWhiteTiles(floor, dp, numCarpets, idx+1, carpetLen, n) + (floor[idx] == \\'1\\')\\n        );\\n        \\n\\t\\t// Return minimum count of uncovered white tiles using one of the two choices\\n        return dp[idx][numCarpets] = countWhites;\\n    }\\n    \\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        countTiles(floor, n);\\n        vector<vector<int>> dp(n+1, vector<int>(numCarpets+1, -1));\\n         \\n        return uncoveredWhiteTiles(floor, dp, numCarpets, 0, carpetLen, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874969,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7e91381aab0f51486f380f703245463c99fed635) for solutions of biweekly 74. \\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = [[0]*(1 + numCarpets) for _ in range(len(floor)+1)]\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(0, numCarpets+1): \\n                if floor[i] == \\'1\\': \\n                    dp[i][j] = 1 + dp[i+1][j] \\n                    if j: \\n                        if i+carpetLen >= len(floor): dp[i][j] = 0 \\n                        else: dp[i][j] = min(dp[i+carpetLen][j-1], dp[i][j])\\n                else: dp[i][j] = dp[i+1][j]\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866410,
                "title": "java-solution-100-faster-using-dp-tabulation",
                "content": "Explatation in comments.\\nPlease **Upvote** if you undrstand this.\\n...\\nclass Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }\\n            }\\n        }\\n        \\n        return dp[numCarpets][n];\\n    }\\n}\\n...",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n\\t\\n\\t\\tchar[] arr = floor.toCharArray();\\n\\t\\t\\n\\t\\tint n = arr.length;\\n\\t\\t//using dp\\n\\t\\t\\n\\t\\tint[][] dp = new int[numCarpets + 1][n + 1];\\n\\t\\t//dp[i][j] -> no of whites in arr(0, i) when j carpet is used\\n\\t\\t//row -> number of carpets\\n\\t\\t//columns -> arr / floor\\n        \\n        for(int i = 0; i <= numCarpets; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(i == 0)\\n                    dp[i][j] = dp[i][j - 1] + (arr[j - 1] - \\'0\\');\\n                else if(j <= carpetLen)//cover all floor\\n                    dp[i][j] = 0;\\n                else{\\n                    int w = Math.min(dp[i - 1][j - carpetLen], dp[i - 1][j]);\\n                    //minimum no of whites if only j - 1 carpet is used already\\n\\t\\t\\t\\t\\t//we want to minimize whites by using or not using jth carpet\\n                    \\n                    //dp[i][j - 1] -> minimum no of moves if we used i carpets already\\n\\t\\t\\t\\t\\t//arr[j - 1] - \\'0\\' -> adds white count for j - 1 th char\\n\\t\\t\\t\\t\\t\\n                    int min = Math.min(w, dp[i][j - 1] + (arr[j - 1] - \\'0\\'));\\n                    //minimum whites in any case\\n                    \\n                    dp[i][j] = min;//update\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1866351,
                "title": "simple-solution-in-java-concise-and-elegant-with-memoization",
                "content": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] dp;\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        this.dp = new int[floor.length()+1][numCarpets+1];\\n        for(int i=0; i<floor.length(); i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        char[] str = floor.toCharArray();\\n        return find(0, str, numCarpets, carpetLen);\\n    }\\n    \\n    // Find the minimum number of white tiles visible\\n    private int find(int index, char[] floor, int numCarpets, int carpetLen){\\n        if(numCarpets < 0) return Integer.MAX_VALUE;\\n        if(index >= floor.length) return 0;\\n        \\n        if(dp[index][numCarpets] != -1){\\n            return dp[index][numCarpets];\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        // If current tile is black, move to the next\\n        if(floor[index] == \\'0\\'){\\n            min = find(index+1, floor, numCarpets, carpetLen);\\n        }\\n        \\n        // If current tile is white, two options, cover the current white tile or not \\n        if(floor[index] == \\'1\\'){\\n            min = Math.min(min, find(index + carpetLen, floor, numCarpets - 1, carpetLen));\\n            min = Math.min(min, 1 + find(index + 1, floor, numCarpets, carpetLen));\\n        }\\n        \\n        dp[index][numCarpets] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864848,
                "title": "c-dynamic-programing-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int n, int k) {\\n        \\n        int m= a.size();\\n        \\n        vector<int> v(m+1,0),h;\\n        \\n        v[0] = 0;\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            v[i] = v[i-1];\\n            if(a[i-1]==\\'1\\')\\n                v[i]++;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            h = v;\\n            v[0] = 0;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(a[j-1]==\\'1\\')\\n                {   \\n                    if(j>=k)\\n                        v[j] = min(h[j-k],v[j-1]+1);\\n                    else\\n                        v[j] = 0;\\n                }\\n                else\\n                    v[j] = v[j-1];\\n            }\\n        } \\n        \\n        return v[m];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864331,
                "title": "python-dp-inspired-by-kadane-algo-and-buy-sell-stock-iv",
                "content": "I. Intuition:\\nThe key idea is that we find the maximum tiles can be covered with one carpet (at a time).\\n\\nFor the example:\\n`floor = \"10110101\"`\\n`numCarpets=2`\\n`carpetLen=2`\\n\\nWith numCapets = 2, that means we will have 2 carpets to use. \\nFirst, we find the maximum tiles that the first carpet can cover.\\n`dp[first_carpet] = [0, 1, 1, 1, 2, 2, 2, 2, 2]`\\nWe can say that at the end of 9th floor, with one carpet, we can cover at most 2 tiles. Now we store the maximum tiles can be covered with one carpet in `prev_state`\\nSecond, we now need to find the maxmimum tiles that the second carpet can cover. Then we take the sum of max tiles that the first carpet cover with the max tiles that the second carpet can cover. \\n`dp[second_carpet] = [0, 1, 1, 2, 3, 3, 3, 3, 3]`\\n\\nII. Resources:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/solution/627971\\n\\nIII. Code:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n \\n        updated_floor = [0]*(len(floor)+1)\\n        running = 0\\n        for index, tiles in enumerate(floor):\\n            if tiles == \\'1\\':\\n                running += 1\\n            updated_floor[index+1] = running\\n  \\n        prev_state = [0]*(len(floor)+1)\\n        for i in range(numCarpets):\\n            dp = [0]*(len(floor)+1)\\n            for j in range(len(dp)-1):\\n                if floor[j] == \\'1\\':\\n                    \\n                    dp[j+1] = max(prev_state[j+1], prev_state[max(j+1-carpetLen, 0)] + updated_floor[j+1]-updated_floor[max(j+1-carpetLen, 0)], dp[j])\\n                    \\n                else:\\n                    dp[j+1] = max(prev_state[j+1], dp[j])\\n                    \\n            prev_state = dp\\n   \\n        return updated_floor[-1] - dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864235,
                "title": "neat-and-clean-recursion-memoization-easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        s = floor;\\n        n = s.length();\\n        len = carpetLen;\\n        memset(dp, -1, sizeof(dp));\\n        prefix[0] = (s[0] == \\'1\\');\\n        for(int i = 1; i < n; ++i)\\n            prefix[i] = prefix[i-1] + (s[i] == \\'1\\');\\n        prefix[n] = prefix[n-1];\\n        int ans = solve(0, numCarpets);\\n        return max(0, prefix[n] - ans);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    string s;\\n    int n;\\n    int prefix[1001];\\n    int len;\\n    int dp[1001][1001];\\n    int solve(int index, int carpet) {\\n        if(carpet <= 0 || index >= n)\\n            return 0;\\n        if(dp[index][carpet] != -1)\\n            return dp[index][carpet];\\n        int x = 0;\\n        if(index)\\n            x = prefix[index - 1];\\n        int y = prefix[min(index + len - 1, n)];\\n        return dp[index][carpet] = max(solve(index + 1, carpet), y - x + solve(index + len, carpet - 1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1864225,
                "title": "python3-simple-bottom-up-dp-solution",
                "content": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for k in range(1, numCarpets+1):\\n            for i in range(1, n+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[-1][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864167,
                "title": "classical-dp-memoization-similiar-to-0-1-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }\\n        if(dp[i][nc] != -1) return dp[i][nc];\\n        int left = fun(i+len,f,nc-1,len);\\n        int right = (f[i] == \\'1\\' ? 1 : 0) + fun(i+1,f,nc,len);\\n        \\n        return dp[i][nc] = min(left,right);\\n        \\n    }\\n    int minimumWhiteTiles(string f, int nc, int len) {\\n        \\n        n = f.size();\\n        pre = vector<int> (n);\\n        dp = vector<vector<int>> (n,vector<int> (nc+1,-1));\\n        pre[0] = (f[0] == \\'1\\' ? 1 : 0);\\n        for(int i=1;i<n;i++){\\n            pre[i] = (f[i] == \\'1\\' ? 1 : 0) + pre[i-1];\\n        }\\n        \\n        return fun(0,f,nc,len);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> pre;\\n    int n;\\n    vector<vector<int>> dp;\\n    int fun(int i,string &f,int nc,int len){\\n        \\n        if(i >= n) return 0;\\n        if(nc == 0){\\n            return pre[n-1] - (i == 0 ? 0 : pre[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1864077,
                "title": "problem-analysis-with-formula-dynamic-programming-tabulation-approach",
                "content": "## At first glance\\n\\nLet\\'s analyze the problem at hand before writing the code. We are given the following inputs:\\n\\n - **Floor**, which is a string of characters `0` and `1` only.\\n\\t - **0** denotes a black tile.\\n\\t - **1** denotes a white tile.\\n - **Number of Carpets**, the number of carpets we can place.\\n - **Length of Carpet**, the range of a carpet to make everything black.\\n\\nThe problem is about *minimizing* the number of white tiles. Note the keyword \\'minimizing\\', which already tells us that this is going to be an optimization problem. You might have guessed it, dynamic programming is the answer to this problem. In specific, we will be using the *tabulation* approach.\\n\\n<br>\\n\\n## Problem Analysis\\n\\n*Note*: From this point forward, we will be referring the **Number of Carpets** as **R** (remaining carpets), **Length of Carpet** as **L** and the **Floor** as **F**.\\n\\nIn order to find minimum number of white tile possible, we need to find the optimal formula for minimizing the white tile count. After further inspection, we can see that at any index ***i***, we have two possible options:\\n\\n - Place a carpet on index ***i***, if and only if **R > 0**.\\n - Skip the current index.\\n\\nThis gives us the following optimal formula (denoted as ***opt***):\\n\\n![image](https://assets.leetcode.com/users/images/2145aad6-6484-40c5-b3f2-e352decf6ff4_1647705757.213423.png)\\n\\n## Implementation\\n\\nA reference implementation in C++ is given below:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```\\n\\nThis runs in **pseudo-polynomial time O(|F| \\xD7 R)** and has a space complexity **O(|F| \\xD7 R)**. Note that this is *not polynomial*, but [pseudo-polynomial](https://en.wikipedia.org/wiki/Pseudo-polynomial_time).\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int L) {\\n        vector<vector<int>> opt(floor.size() + 1, vector<int>(numCarpets + 1, 0));\\n\\n        for (int i = (int) floor.size() - 1; i >= 0; i--) {\\n            int F_i = floor[i] - \\'0\\';\\n\\n            for (int R = 0; R <= numCarpets; R++) {\\n\\n                if (R == 0)\\n                    opt[i][R] = F_i + opt[i + 1][R];\\n                else if (i + L >= floor.size())\\n                    opt[i][R] = 0;\\n                else\\n                    opt[i][R] = min(F_i + opt[i + 1][R], opt[i + L][R - 1]);\\n            }\\n        }\\n\\n        return opt[0][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864073,
                "title": "c-simple-recursive-memoization-easy-to-think-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```\\n***If you find this helpful, please show some love in the form of upvote***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minCover(string& s, int index, int numCarpets, int len){\\n        if(index >= s.length())     // if index >= s.length(), then there is no tiles present.\\n            return 0;\\n        if(dp[index][numCarpets] != -1)     // State of the dp is represented by current index and no of Carpets remaining\\n            return dp[index][numCarpets];\\n        int res1 = INT_MAX;\\n        if(numCarpets > 0)\\n            res1 = minCover(s, index + len, numCarpets-1, len);     // If carpet is still remaining, we can try covering tiles in the range [index, index + len - 1]\\n        int res2 = minCover(s, index+1, numCarpets, len);       // finding min no of white tiles visible if we doesn\\'t cover the tile on this particular index\\n        if(s[index] == \\'1\\')                 // white tile present at index, so if we don\\'t cover those tile, then add corresponding count to res2\\n            res2++;\\n        return dp[index][numCarpets] = min(res1, res2);   // finally we choose the minimum from the above two case\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length(), vector<int>(numCarpets+1, -1));\\n        return minCover(floor, 0, numCarpets, carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613914,
                "title": "python-top-down-dp-almost-one-liner",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, nums: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dfs(i, rem):\\n            return 0 if i >= len(nums) else min((1 if nums[i]==\\'1\\' else 0) + dfs(i+1, rem), dfs(i+carpetLen, rem-1) if rem and nums[i]==\\'1\\' else float(\\'inf\\'))\\n        \\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191050,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string &s, int num, int len, int i, vector<vector<int>>&dp){\\n        if(i>=s.length()){\\n            return 0;\\n        }\\n        if(num==0){\\n            int count = 0;\\n        for(int j = i; j<=s.length()-1;j++){\\n            if(s[j]==\\'1\\'){\\n                count++;\\n            }\\n\\n        } \\n                       return count;\\n        }\\n        if(dp[i][num]!=-1){\\n            return dp[i][num];\\n        }\\n        if(s[i]==\\'0\\'){\\n            return dp[i][num] = helper(s,num,len,i+1,dp);\\n        }\\n        int mn = i + len-1;\\n        if(mn >= s.length()){\\n            mn = s.length()-1;\\n        }\\n    \\n        return dp[i][num] = min(helper(s,num-1,len,i+len,dp),1+helper(s,num,len,i+1,dp));\\n    }\\n    \\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.length()+1, vector<int>(numCarpets+1,-1));\\n        return helper(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153754,
                "title": "python-2-liner-using-lambda-function-and-lru-cache",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, x: str, n: int, cl: int) -> int:\\n        f=lru_cache(None)(lambda i,n: 0 if i>=len(x) else min((1 if x[i]==\\'1\\' else 0)+f(i+1,n),(inf if n==0 else f(i+cl,n-1))))\\n        return f(0,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115070,
                "title": "c-dp-bottom-up-dp-similar-to-knapsack",
                "content": "Please upvote\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int len) {\\n        int n=floor.size();\\n        int x=numCarpets;\\n        floor=\\'#\\'+floor;//so that ith row of dp matches with the ith character\\n        vector<vector<int>> dp(n+1,vector<int>(x+1,0));\\n        dp[0][0]=0;\\n        for(int i=0;i<=x;i++){\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=n;i++){\\n            dp[i][0]=dp[i-1][0]+(floor[i]==\\'1\\');\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=x;j++){\\n                if(j>=1){\\n\\t\\t\\t\\t//if we have atleast 1 carpet or even more\\n\\t\\t\\t\\t//then we can use\\n\\t\\t\\t\\t//however before usuing at i also check if i-len>=0\\n                    if(i-len>=0){\\n                        dp[i][j]=min(dp[i-len][j-1],dp[i-1][j]+(floor[i]==\\'1\\'));\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t//if we do not have any carpet\\n                    dp[i][j]=dp[i-1][j]+(floor[i]==\\'1\\');\\n                }\\n            }\\n        }\\n        return dp[n][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052637,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        int[][] dp = new int[n + 1][numCarpets + 1];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j <= numCarpets; j++) {\\n                if (floor.charAt(i - 1) == \\'1\\') dp[i][j] = dp[i - 1][j] + 1;\\n                else dp[i][j] = dp[i - 1][j];\\n                if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[Math.max(0, i - carpetLen)][j - 1]);\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880957,
                "title": "scala",
                "content": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.math.min\\nimport scala.util.chaining._\\n\\nobject Solution {\\n  private val Black = \\'0\\'\\n\\n  def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = floor\\n    .indices\\n    .zip(floor.map(_ - Black).scanRight(0)(_ + _))\\n    .toMap\\n    .withDefaultValue(0)\\n    .pipe { (1 to numCarpets)\\n      .foldLeft(_) { case (previousNumWhiteTiles, _) => floor\\n        .indices\\n        .foldRight(Map[Int, Int]().withDefaultValue(0)) { case (i, currentNumWhiteTiles) =>\\n          currentNumWhiteTiles + \\n            (i -> min(floor(i) - Black + currentNumWhiteTiles(i + 1), previousNumWhiteTiles(i + carpetLen)))\\n        }\\n      }\\n      .apply(0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1879842,
                "title": "java-simple-memiozation",
                "content": "```\\nclass Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }\\n        dp = new Integer[floor.length()][numCarpets + 1];\\n        //  suff[i] = number of white tiles in s[i....]\\n\\t\\tsuff = cumulative(floor);\\n        return helper(floor, numCarpets, carpetLen, 0);\\n    }\\n    \\n\\t//  normal suffix array\\n    public int[] cumulative(String s) {\\n        int[] suff = new int[s.length()];\\n        suff[s.length() - 1] = (s.charAt(s.length() - 1) == \\'0\\' ? 0 : 1);\\n        for (int i = s.length() - 2; i >= 0; i--) {\\n            suff[i] = suff[i + 1] + (s.charAt(i) == \\'0\\' ? 0 : 1);\\n        }\\n        return suff;\\n    }\\n    \\n    public int helper(String s, int n, int k, int idx) {\\n        \\n        //  no more floors remaining so no white carpets need to be covered\\n        if (idx >= s.length()) {\\n            return 0;\\n        }\\n        \\n        if (dp[idx][n] != null) {\\n            return dp[idx][n];\\n        }\\n        \\n        //  floors remaining but carpets exhausted\\n        if (n == 0) {\\n            return suff[idx];\\n        }\\n        \\n        //  this is already black skip this floor\\n        if (s.charAt(idx) == \\'0\\') {\\n            return helper(s, n, k, idx + 1);\\n        }\\n        \\n        //  now we have two choices whether to leave this white\\n        //  as it is or cover this in black\\n        \\n        \\n        //  if covering this and any other black floor in range as black\\n        int answer = helper(s, n - 1, k, idx + k);\\n        \\n        //  leaving this as white as it was\\n        answer = Math.min(answer, helper(s, n, k, idx + 1) + 1);\\n        return dp[idx][n] = answer;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] suff;\\n    Integer[][] dp;\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {    \\n        if (carpetLen == floor.length()) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1879319,
                "title": "why-my-bottom-up-code-is-giving-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int memo(int i, int j, vector<int>& pref, int cl,\\n    //          vector<vector<int>>& dp)\\n    // {\\n    //     if(i >= pref.size() || j <= 0)\\n    //         return 0;\\n    //     if(dp[i][j] != -1)\\n    //         return dp[i][j];\\n    //     else\\n    //     {\\n    //         dp[i][j] = max(memo(i+cl, j-1, pref, cl, dp)\\n    //                        + pref[i], \\n    //                        memo(i+1, j, pref, cl, dp));\\n    //     }\\n    //     return dp[i][j];\\n    // }\\n    int minimumWhiteTiles(string& f, int n, int cl) {\\n        vector<vector<int>> dp(1001, vector<int>(1001, -1));\\n        int tot = 0;\\n        for(auto x : f)\\n            if(x == \\'1\\')\\n                tot++;\\n        vector<int> pref(f.size(), 0);\\n        int x = f.size() - 1;\\n        for(int i = 0; i < cl; i++, x--)\\n        {\\n            if(x < f.size() - 1)\\n                pref[x] = pref[x+1];\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n        }\\n        int y = f.size() - 1;\\n        while(x >= 0)\\n        {\\n            pref[x] = pref[x+1];\\n            if(f[y] == \\'1\\')\\n                pref[x]--;\\n            if(f[x] == \\'1\\')\\n                pref[x]++;\\n            x--;\\n            y--;\\n        }\\n        for(int i = 0; i <= f.size(); i++)\\n            dp[i][0] = 0;\\n        for(int j = 0; j <= n; j++)\\n            dp[f.size()][j] = 0;\\n        for(int i = f.size()-1; i >= 0; i--)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                dp[i][j] = max(dp[i+1][j],\\n                               dp[min(i+cl,int(f.size()-1))][j-1]\\n                               + pref[i]);\\n            }\\n        }\\n        return tot > dp[0][n] ? tot - dp[0][n] : 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876280,
                "title": "c-dp-heavily-commented",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate:\\n    int dp[1001][1001];\\n    int suffix[1001];\\npublic:\\n    int recur(string &floor,int numCarpets,int carpetLen,int idx)\\n    {\\n        //Base Cases\\n        if(idx>=floor.size())\\n            return 0;\\n    \\n        if(numCarpets==0)\\n            return suffix[idx];\\n        \\n        //Memoization\\n        if(dp[idx][numCarpets]!=-1)\\n            return dp[idx][numCarpets];\\n        \\n        //Check if current tile is white,\\n        //We need to add 1 because we are skipping\\n        int op1=(floor[idx]==\\'1\\')+recur(floor,numCarpets,carpetLen,idx+1);\\n        //We are using one carpet and hence we jump directly \\n        //by carpetLen moves\\n        int op2=recur(floor,numCarpets-1,carpetLen,idx+carpetLen);\\n        return dp[idx][numCarpets]=min(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n       int n=floor.size();\\n       memset(dp,-1,sizeof dp);\\n        \\n       /*We make a suffix array which will tell \\n       us count of white tiles after current tile\\n       (including current tile also), we need to do this step\\n       else we will get TLE */\\n       suffix[n - 1] = (floor[n - 1] == \\'1\\');\\n        for (int i = n - 2; i >= 0; i--) {\\n            suffix[i] = suffix[i + 1] + (floor[i] == \\'1\\');\\n        }\\n        return recur(floor,numCarpets,carpetLen,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870498,
                "title": "java-simple-top-down-dp-with-explanation",
                "content": "Basically we consider each suffix from ```floor[0...I]``` using ```J``` carpets. There are 2 transition options to consider and minimize over for this building upon \"smaller\"* subproblems.\\n\\nCase 1: We use a carpet that ends at ```I```th position. So this means we simply need ```subproblem(I-carpetLen, J-1)``` because all tiles from ```I-carpetLen + 1``` to ```I``` now have 0 white tiles due to spending 1 carpet so we are at pos ```I - carpetLen``` with 1 less carpet.\\n\\nCase 2: We do not use a carpet that ends at ```I```th position. So the ```I```th tile is uncovered. So this tile has to be included towards count of white tiles so add ```floor(I) == 0? 1 : 0```. And then we\\'re left with ```subproblem(I-1, J)``` as we haven\\'t spent any carpets.\\n\\nThat is ```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\\n\\n\\\\* \"smaller\" in sense that subproblem(I\\', J\\') < subproblem(I, J) if I\\' <= I and J\\' <= J and not case that (I\\', J\\') = (I, J)\\n\\nThere are a few edge cases that should be easily understandable from code below.\\nCode:\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```floor[0...I]```\n```J```\n```I```\n```subproblem(I-carpetLen, J-1)```\n```I-carpetLen + 1```\n```I```\n```I - carpetLen```\n```I```\n```I```\n```floor(I) == 0? 1 : 0```\n```subproblem(I-1, J)```\n```subproblem(I, J) = Min(subproblem(I-carpetLen, J-1), subproblem(I-1, J) + floor(I) == 0? 1 : 0)```\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // memo[I][J] = subproblem of floor[0...I] with J numCarpets.\\n        // so I range from 0...(floor.len - 1) so floor.len possibilities\\n        // and J range from 0 ... numCarpets so numCarpets+1 possibilities\\n        Integer[][] memo = new Integer[floor.length()][numCarpets + 1];\\n        return dfs(floor.length() - 1, numCarpets, carpetLen, memo, floor);\\n    }\\n    \\n    // precond. i and j both >=0. don\\'t add check at start, instead maintain this\\n    private int dfs(int i, int j, int carpetLen, Integer[][] memo, String floor) {\\n        //if (i < 0 || j < 0) {\\n            //return 0;\\n        //}\\n        if (memo[i][j] != null) {\\n            return memo[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        // case 1: only when have at least 1 carpet to work with so let one extend and end at I\\n        if (j > 0) {\\n            if (i - carpetLen >= 0) {\\n                min = Math.min(min, dfs(i - carpetLen, j-1, carpetLen, memo, floor));\\n            } else {\\n                // have enough carpet to span all of [0...i] so no while tiles visible\\n                memo[i][j] = 0;\\n                return 0;\\n            }\\n        }\\n        // case 2: tile does not extend till here\\n        if (i > 0) {\\n            min = Math.min(min, dfs(i-1, j, carpetLen, memo, floor) + ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        } else {\\n            min = Math.min(min, ((floor.charAt(i) == \\'1\\')? 1 : 0));\\n        }\\n        memo[i][j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866616,
                "title": "java-solution-top-down-dp-2-approaches",
                "content": "**Explanation :**\\n\\nHere, I want to showcase 2 approaches for solving the problem using memoization :\\n\\t\\t1. counting the minimum number of exposed white tiles using `suffix-sum` and\\n\\t\\t2. counting the maximum number of white tiles covered by the given carpets and subtracting this from the total number of white tiles to get the exposed white tiles using `prefix-sum`\\n\\n**Approach 1 :**\\n\\n```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\\n\\n**Approach 2 :**\\n\\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```\\n\\n**PS -** Any suggestions or improvements are most welcome.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] suffixSum = new int[floor.length()];\\n        suffixSum[floor.length() - 1] = (floor.charAt(floor.length() - 1) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = floor.length() - 2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i + 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n\\n        return coverTilesDP(floor, 0, carpetLen, numCarpets, dp, suffixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] suffixSum) {\\n        if (idx >= str.length()) {\\n            return 0;\\n        } else if (numCarpets == 0) {\\n            return suffixSum[idx];\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\t\\t\\n        // include\\n        int min1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, suffixSum);\\n        // exclude\\n        int min2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, suffixSum) + (str.charAt(idx) == \\'1\\' ? 1 : 0);\\n\\n        return dp[idx][numCarpets] = Math.min(min1, min2);\\n    }\\n```\n```\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        Integer[][] dp = new Integer[floor.length() + 1][numCarpets + 1];\\n        int[] prefixSum = new int[floor.length()];\\n        prefixSum[0] = (floor.charAt(0) == \\'1\\' ? 1 : 0);\\n\\n        for (int i = 1; i < floor.length(); i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (floor.charAt(i) == \\'1\\' ? 1 : 0);\\n        }\\n        return prefixSum[floor.length() - 1] - coverTilesDP(floor, 0, carpetLen,\\n                                                            numCarpets, dp, prefixSum);\\n    }\\n\\n    private int coverTilesDP(String str, int idx, int carpetLen,\\n                             int numCarpets, Integer[][] dp, int[] prefixSum) {\\n        if (idx >= str.length() || numCarpets == 0) {\\n            return 0;\\n        }\\n\\n        if (dp[idx][numCarpets] != null) {\\n            return dp[idx][numCarpets];\\n        }\\n\\n        // include\\n        int max1 = coverTilesDP(str, idx + carpetLen, carpetLen, numCarpets - 1, dp, prefixSum) +\\n                   (prefixSum[Math.min(idx + carpetLen - 1, prefixSum.length - 1)] - (idx >= 1 ? prefixSum[idx - 1] : 0));\\n        // exclude\\n        int max2 = coverTilesDP(str, idx + 1, carpetLen, numCarpets, dp, prefixSum);\\n\\n        return dp[idx][numCarpets] = Math.max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865413,
                "title": "top-down-c-solution-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(int i,string &floor,int numCarpets, int &carpetLen, vector<vector<int>> &dp)\\n    {\\n        if(i==floor.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[i][numCarpets]!=-1)\\n        {\\n            return dp[i][numCarpets];\\n        }\\n        \\n        int ans=0;\\n        //Put carpet here only if you have 1 or more carpet left\\n            if(i+carpetLen<=floor.length()&&numCarpets>0)\\n            {\\n                ans+=carpetLen+explore(i+carpetLen,floor,numCarpets-1,carpetLen,dp);\\n            }\\n            else if(numCarpets>0)\\n            {      //When current index+ carpet length > floor.length\\n                 ans+=floor.length()-i;\\n            }\\n        \\n        \\n        //Dont put carpert here\\n        if(floor[i]==\\'0\\')\\n        {   //If current carpet is black\\n            ans=max(ans,1+explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        else\\n        {\\n            ans=max(ans,explore(i+1,floor,numCarpets,carpetLen,dp));\\n        }\\n        \\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.length();\\n        //Store number of maximum black carpet from  index\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        //Explore will return maximum number of black carpet \\n\\t\\t//we just subtract it from floor length to get \\n\\t\\t//minimum number of white carpet\\n        return n-explore(0,floor,numCarpets,carpetLen,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865216,
                "title": "java-simple-solution-with-explaination",
                "content": "I was having the problem to think but got intuition of DP by seeing constraints. But Now how to implement DP what will be the variables to play . Basically think on which variables you are dependent;\\nYes You have to travel the complete the floor string so this variable is changing and second the number of carpet is changing. \\ncarpet length is constant .\\nThis is similar to knapsack yes , here each carpet has value that is length. \\nAt each index you have two choice either use carpet or don\\'t use it;\\nif already black skip and move forward\\nif white you can use carpet or you can leave white (thus cnt will be increased)\\n\\nif all carpet are used and still floor is not completed just return number of white tiles are left;\\nbelow is the code\\n\\n\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }\\n        return helper( 0, numCarpets, carpetLen, dp, floor);\\n    }\\n    public int helper(int i, int nc, int l, int[][] dp, String s){\\n        \\n        if(i>= s.length()) return 0;\\n        if(nc<=0){\\n            int cnt=0;\\n            for(int j= i; j<s.length(); j++){\\n                if(s.charAt(j)==\\'1\\'){\\n                    cnt++;\\n                }\\n            }\\n            return cnt;\\n        }\\n        \\n        if(dp[i][nc]!=-1) return dp[i][nc];\\n        \\n        \\n        if(s.charAt(i)==\\'0\\'){\\n            return dp[i][nc]= helper(i+1, nc,l , dp , s);\\n        }\\n        else{\\n            int jump= 1+ helper(i+1, nc, l, dp, s);\\n            int cover= helper(i+ l, nc-1, l, dp, s);\\n            \\n            return dp[i][nc]= Math.min(jump, cover);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        // we have to cover the tiles  we first see the color if it is black \\n        // we leave if its white we have option to jump or we cover it;\\n        int dp[][]= new int[floor.length()+1][numCarpets+1];\\n        for(int a[]: dp){\\n            Arrays.fill(a, -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1865059,
                "title": "dp-edge-case-optimization-with-explanations",
                "content": "Two edge cases can be handled explicitly before running DP:\\n(1) `if numCarpets * carpetLen >= n`, i.e. the totally length of carpets altogether is longer than the length of `floor`, return 0 immediately;\\n(2) `if carpetLen == 1`, then the problem becomes trivial and we can cover the carpets \"greedily\". Adding this edge check is particularly useful for a few long test cases (as it would save half of the time for such cases), which does help to get AC for this problem.\\nThe rest of the code deals with the general cases by using DP, where `dp[i][j]` represents the minimum white tiles after covering with `j` carpets for first `i` tiles.\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t# edge case handling\\n        if numCarpets * carpetLen >= n:\\n            return 0\\n        if carpetLen == 1:\\n            return max(sum([int(c) for c in floor]) - numCarpets, 0)\\n\\t\\t# DP initialization\\n        dp = [[None] * (numCarpets + 1) for _ in range(n + 1)]\\n        for j in range(numCarpets + 1):\\n            dp[0][j] = 0\\n        for i in range(1, n + 1):\\n            dp[i][0] = dp[i - 1][0] + int(floor[i - 1])\\n\\t\\t# DP transition formula\\n        for i in range(1, n + 1):\\n            for j in range(1, numCarpets + 1):\\n                dp[i][j] = min(dp[i - 1][j] + int(floor[i - 1]), dp[max(i - carpetLen, 0)][j - 1])\\n        return dp[n][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864943,
                "title": "c-easy-to-understand-memoization-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n    int solve(string &floor,int i,int n,int l,vector<int> &prefix)\\n    {\\n        if(i>=floor.size()||n==0)\\n        return 0;\\n        if(dp[i][n]!=-1)\\n        return dp[i][n];\\n        if(floor[i]==\\'0\\')\\n        return dp[i][n]=solve(floor,i+1,n,l,prefix);\\n        int x=min((int)(floor.size()),(int)(i+l))-1;\\n        int white=prefix[x];\\n        if(i!=0)\\n        white-=prefix[i-1];\\n        int ans1=white+solve(floor,i+l,n-1,l,prefix);\\n        int ans2=solve(floor,i+1,n,l,prefix);\\n        return dp[i][n]=max(ans1,ans2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<int> prefix(n);\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=numCarpets;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        if(floor[0]==\\'1\\')\\n        prefix[0]=1;\\n        else\\n        prefix[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]=prefix[i-1]+(floor[i]==\\'1\\');\\n        }\\n        int total_white=prefix[n-1];\\n        if(total_white==0)\\n        return 0;\\n        return total_white-solve(floor,0,numCarpets,carpetLen,prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864915,
                "title": "c-dp-recursion-memorization-easy-to-understand",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int carpetLen, fLen;\\n    vector<int> sum;\\n    vector<vector<int>> dp;\\n    int solve(int pos, int numCar, string& floor){\\n        if(pos >= fLen){\\n            return 0;\\n        }\\n        \\n        if(numCar == 0){\\n            return 0;\\n        }\\n        \\n        int &ret = dp[pos][numCar];\\n        \\n        if(ret != -1){\\n            return ret;\\n        }\\n        \\n        int taken = 0, notTaken = 0;\\n        int fSum = 0, lSum = 0;\\n        \\n        fSum = pos > 0 ? sum[pos - 1] : 0;\\n        lSum = pos + carpetLen > fLen ? sum[fLen - 1] : sum[pos + carpetLen - 1];\\n        \\n        taken = lSum - fSum + solve(pos + carpetLen,  numCar - 1, floor);\\n        notTaken = solve(pos + 1, numCar, floor);\\n        \\n        return ret = max(taken, notTaken);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        fLen = floor.size();\\n        this->carpetLen = carpetLen;\\n        sum.resize(fLen + 1, 0);\\n        dp.resize(fLen + 1, vector<int> (numCarpets + 1, -1));\\n        sum[0] = floor[0] - \\'0\\';\\n        \\n        for(int i = 1; i < fLen; i++){\\n            sum[i] = sum[i - 1] + (floor[i] - \\'0\\');\\n        }\\n        \\n        return sum[fLen - 1] - solve(0, numCarpets, floor);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864513,
                "title": "java-using-dynamic-programming-simple-solution",
                "content": "First, if numCarpets * carpetLen > floor.size(), the answer is always 0 because the entire floor can be covered.\\nOtherwise,This problem can be solved by using dynamic programming.\\nThe variables in the DP are\\n1. length of confirmed Floor (starting from the left end at 0)\\n2. number of carpets used\\n\\nThe spatial computational complexity of a 2-dimensional array using the above variables is O(1e6).\\n\\nPlease see the image below for a sample transition with floor = \"10110\", numCarpets = 2, carpetLen = 2.\\n![image](https://assets.leetcode.com/users/images/20a2a6f5-af47-40d4-a972-6e2e000d96e3_1647710851.003477.png)\\n\\nThe red arrow shows the transition when the carpet is pulled.\\n`dp[i+cl][j+1] = Math.min(dp[i+cl][j+1], dp[i][j]);`\\n\\u203B Math.min(i+cl,f.length) is used in my code because the index could exceed floor.size().\\n\\nThe black arrow is the transition if the carpet is not pulled.\\nIf the next floor is white, increase the value by +1 from the current value.\\n`dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j] + floor[i]);`\\n\\nWe have solved this problem by performing two different transitions for each item in the dp array.\\n\\nex) the gray items and arrows are not valid, we can show that there is no transition from dp[0][0] to dp[1][0],dp[1][1] for example, because the length of the carpet is more than 2.\\n\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        //1. Redefine for variable name shortening\\n        int ln = floor.length();\\n        int nc = numCarpets;\\n        int cl = carpetLen;\\n        \\n        //2. Return 0 if all floors can be covered from carpet length * number of carpets.\\n        char[] f = floor.toCharArray();\\n        int cover = numCarpets * carpetLen;\\n        if(cover >= f.length) return 0;\\n        \\n        \\n        //3. Dynamic Programming\\n        int[][] dp = new int[ln+1][nc+1];\\n        for(int i = 0; i <= ln; i++) Arrays.fill(dp[i],f.length);\\n        dp[0][0] = 0;\\n        for(int i = 0; i < ln; i++){\\n            int plus = f[i]-\\'0\\';\\n            for(int j = 0; j <= nc; j++){\\n                dp[i+1][j] = Math.min(dp[i+1][j],dp[i][j] + plus);\\n                if(j != nc) dp[Math.min(i+cl,f.length)][j+1] = Math.min(dp[Math.min(i+cl,f.length)][j+1], dp[i][j]);\\n            }\\n        }\\n        return dp[ln][nc];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864481,
                "title": "c-dp-house-robber",
                "content": "This problem can be converted to [house robber](https://leetcode.com/problems/house-robber/) then solved by dynamic programming.\\nWhen the total length of carpet is equal to or exceed the length of the floor, there should be no white left. When it\\'s not, we should always looking for non-overlapping solution as at least one of the optimal solution doesn\\'t include overlapping. The reason is that we can always rearrange carpets to not overlap and covering all the original tiles and some more.\\nSo we can calculate how many white tiles can be covered starting from each position, the problem is to select ```numCarpet``` of positions, with minimum distance of any two position is ```carpetLen```, to get the maximum sum. It\\'s equivalent to house robber except that we not only can\\'t rob consecutive houses, we can\\'t rob houses within some given distance ```carpetLen```. Also we have a fixed amount of house we have to rob, so instead of a 1D DP as we did in house robber, a standard 2D DP approach should suffice. See annotation for details.\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```\\nThis solution should be able to optimized to O(N) space complexity by using two 1D vectors.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```numCarpet```\n```carpetLen```\n```carpetLen```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n\\t\\t//too many carpets, cover all the floor\\n        int l = floor.size();\\n        if(numCarpets*carpetLen>=l) {return 0;}\\n\\t\\t\\n        // sliding window to calculate how many white tiles can be covered for a carpet starting at position i\\n        int white = 0;             // number of total white tiles on the floor\\n        int m = l-carpetLen+1;     // number of possible carpet starting position\\n        vector<int> cover(m,0);    // number of white tiles covered for a carpet starting at each position\\n        for(int i=0; i<carpetLen; i++){\\n            cover[0] += (floor[i]==\\'1\\');\\n            white += (floor[i]==\\'1\\');\\n        }\\n        for(int i=1; i<m; i++){\\n            cover[i] = cover[i-1] - (floor[i-1]==\\'1\\') + (floor[i+carpetLen-1]==\\'1\\');\\n            white += (floor[i+carpetLen-1]==\\'1\\');\\n        }\\n\\t\\t\\n        // dp to find the maximum sum of numCarpets elements from cover[0:m-1], \\n\\t\\t// with any of the two elements having minimum distance of carpetLen\\n\\t\\t// dp[k][i] stands for the maximum sum for k elements in cover[0:i]\\n        vector<vector<int>> dp(numCarpets+1, vector<int>(m,0));\\n        dp[1][0] = cover[0];\\n        for(int i=1; i<m; i++){\\n            dp[1][i] = max(dp[1][i-1],cover[i]);\\n        }\\n        for(int carpet=2; carpet<=numCarpets; carpet++){\\n            for(int i=(carpet-1)*carpetLen; i<m; i++){\\n\\t\\t\\t\\t// either we don\\'t select current element, \\n\\t\\t\\t\\t// or we select current element and limit the range of last selected element before i-carpetLen\\n                dp[carpet][i] = max(dp[carpet][i-1],cover[i]+dp[carpet-1][i-carpetLen]);\\n            }\\n        }\\n        return white-dp[numCarpets][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864442,
                "title": "c-dp-solution-memoization-100-fast-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```\\nComment below if you have any doubt\\nPlease upvote if you like\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &hash, int &num, int &len, int i, int j, vector<vector<int>> &dp){\\n        int n = hash.size();\\n        if (j >= num or i >= n)  return 0;\\n        if (dp[i][j] != -1) return dp[i][j];\\n//     Dont want to put the carpet on the ith place\\n        int not_take = solve(hash, num, len, i+1, j, dp);\\n//     Want to put the carpet on the ith place and the corresponding value which it gives is added\\n        int take = hash[i] + solve(hash, num, len, i+len, j+1, dp);\\n        \\n        return dp[i][j] = max(not_take, take);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        int n = floor.size();\\n        if (num*len >= n)   return 0;    \\n        int var = 0, count = 0;\\n        for (int i = 0;i < n;i++)   count += (floor[i] == \\'1\\');\\n        if (count == n){\\n            return (n - (num*len));\\n        }\\n//     hash stores that if we put the carpet at the ith position \\n//     then how much white space i\\'ll cover\\n        vector<int> hash(n);\\n        for (int i = n-1;i >= 0;i--){\\n            if (floor[i] == \\'1\\'){\\n                var += 1;\\n            }\\n            if (i+len < n and floor[i+len] == \\'1\\'){\\n                var -= 1;\\n            }\\n            hash[i] = var;\\n        }\\n//     dp[i][j] stores if i am on the ith index and jth carpet is used \\n//     then how much maximum white spaces i\\'ll cover\\n        vector<vector<int>> dp(n, vector<int> (num, -1));\\n//     solve gives me the maximus white i can cover with carpet using the num number of carpets \\n//     of length len\\n        int temp = solve(hash, num, len, 0, 0, dp);\\n        return count - temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864395,
                "title": "c-solution-memo-recursive-prefix-array",
                "content": "So , Here i changed the question instead of finding the minimum no of white tiles after placing k tiles , I am trying to find the maximum white tiles i can cover with the  k tiles and return the answer after subtracting with the  intital  no of white tiles present in the string.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    vector<int>prefix;\\n    int helper(int idx,int k,string& floor,int len){\\n        if(idx >= floor.size())return 0;\\n        if(dp[idx][k] != -1)return dp[idx][k];\\n        int op1 = helper(idx + 1,k,floor,len);\\n        int op2 = 0;\\n        if(floor[idx] == \\'1\\' && k > 0){\\n            int sz = min(idx + len,(int)floor.size());\\n            int y = prefix[sz - 1];\\n            if(idx - 1 >= 0){\\n                y -= prefix[idx - 1];\\n            }\\n            op2 = y + helper(idx + len,k - 1,floor,len);\\n        }\\n        return dp[idx][k] = max(op1,op2);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int cnt = 0;\\n        int n = floor.size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i =0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\')cnt++;\\n        }\\n        prefix.resize(n + 1,0);\\n        prefix[0] = (floor[0] == \\'1\\');\\n        for(int i =1;i<=n;i++){\\n            if(floor[i] == \\'1\\'){\\n                prefix[i] = prefix[i - 1] + 1;\\n            }\\n            else prefix[i] = prefix[i - 1];\\n        }\\n        if(cnt == 0)return 0;\\n        return cnt - helper(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864304,
                "title": "python3-dp-o-n-numcarpets-solution-got-a-tle-is-this-intended",
                "content": "My solution is given as\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```\\nShould I make it more faster? \\nIs this intended?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp = dict() # i, num_carpets remaining -> num white\\n        n = len(floor)\\n        for i in range(n+1)[::-1]:\\n            for j in range(numCarpets+1):\\n                if i == n:\\n                    dp[(i,j)] = 0\\n                    continue\\n                \\n                if floor[i] == \\'0\\':\\n                    dp[(i,j)] = dp[(i+1,j)]\\n                else:\\n                    dp[(i,j)] = 1+dp[(i+1,j)] \\n                    if j > 0:\\n                        dp[(i,j)] = min(dp[(i,j)], dp[(min(i+carpetLen, n),j-1)])\\n        \\n        return dp[(0, numCarpets)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864125,
                "title": "dp-intuition-with-explaination",
                "content": "**Intuition**\\n\\n\\nlets suppose are at ith index.\\n\\nsuppose we are at index i and with j carpets\\ndp[i][j] denotes minimum number of uncovered white cells from 0 to i with j \\ncarpets.\\n\\n1. if number of carpets = 0 dp[i][j] = number of carpets from 0 to i.\\n\\n\\nsuppose we are at index i and with j carpets\\n1. we dont put carpet. in this case number of uncovered white cells will be \\nnumber of uncovered white cells at i-1 +  1 (if ith cell is )\\ndp[i][j]  = dp[i-1][j] + 1 if ith carpet is red;\\n\\n\\n2. if we are placing carpet (j>0) such that ith is the last cell covered.\\n\\ni-carpetlength < 0 that means we are fulling covering from 0 to i.\\n[i][j] = 0\\n\\ni-carpetlength >= 0 that means we are covering from\\ni-carpetlength+1 to i and number of carpet left are j-1\\n\\nso dp[i][j] = dp[i-carpetlength][j-1] // cells i-carpetlength+1 to i is covered\\n\\nat last we will take minimmum of both the values \\ndp[i][j]  = min(dp[i-1][j]) + 1 if ith carpet is red, 0 if i-carpetlength < 0 else dp[i-carpetlength][j-1]\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1));\\n        int ans = 0;\\n        vector<int>freq(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ans += floor[i]-\\'0\\';\\n            freq[i] = ans;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<=numCarpets;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = freq[i];\\n                    continue;\\n                }\\n                if(i-carpetLen < 0)\\n                {\\n                    dp[i][j] = 0;\\n                }\\n                else if(i-carpetLen >= 0)\\n                {\\n                    dp[i][j] = dp[i-carpetLen][j-1];\\n                }\\n                int value = 0;\\n                if(i>0)\\n                {\\n                        value += floor[i]-\\'0\\';\\n                      dp[i][j] = min(dp[i-1][j] + value ,dp[i][j]);\\n                }\\n                else\\n                {\\n                      value += floor[i]-\\'0\\';\\n                    dp[i][j] = min(value ,dp[i][j]);\\n                }\\n          }\\n           \\n        }\\n        return dp[n-1][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864052,
                "title": "python-dp-memoization-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        if numCarpets*carpetLen >= len(floor):\\n            return 0\\n        l = list(map(int,list(floor)))\\n        dp = [[-1]*(numCarpets+1) for j in range(len(l))]\\n        \\n        def rec(i,n):\\n            nonlocal l\\n            if n == 0 or i >= len(l):\\n                return sum(l[i:])\\n            if dp[i][n] != -1:\\n                return dp[i][n]\\n            dp[i][n] = min(rec(i+carpetLen,n-1),rec(i+1,n)+l[i])\\n            return dp[i][n]\\n        \\n        return rec(0,numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864031,
                "title": "dp-memorization-easy-to-understand-solution-c-o-n-2-time-and-o-n-2-space",
                "content": "We can solve this problem by using standard concepts of solving a 2-d DP problem.\\nFor each tile, we have two options --\\ni) We place a the carpet starting from the current tile\\nii) We do not place a carpet\\n\\nFurther, here is an observations to be made\\n-- Placing carpet starting from a black tile is not feasible. SO before placing a carpet, we will check whether the current tile is white or not.\\n\\n\\nBelow is the code for the approach explained above. Lines have been commented in order to understand better.\\n\\n```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(string &a,int i,int j,int k,int len,vector<vector<long long int>> &dp)\\n{\\n    \\n    // dp states --\\n    //     i --> represents the index of the tiles\\n    //     j --> represents the number of black carpets used\\n    \\n    if(i>=a.size())\\n    {\\n        // base case\\n        return 0;\\n    }\\n    \\n    if(dp[i][j]!=-1)\\n    {\\n        // since the current tile is already black, no need of covering it\\n        \\n        return dp[i][j];\\n    }\\n    \\n    \\n    if(a[i]==\\'1\\')\\n    {\\n        // the current tile is white in color, so we have two options\\n        \\n        int op1=INT_MAX,op2=INT_MAX;\\n        \\n        // option 1 - place carpet\\n        \\n        if(j<k) // we can only place carpets if we have some remaining black carpets\\n            op1=solve(a,i+len,j+1,k,len,dp);\\n        \\n        // option 2 - dont place the carpet\\n        op2=1+solve(a,i+1,j,k,len,dp);\\n        \\n        \\n        return dp[i][j]=min(op1,op2);\\n    }\\n    \\n    return dp[i][j]=solve(a,i+1,j,k,len,dp);\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string a, int k, int len) {\\n        \\n        // creating a two dimensional dp array\\n        vector<vector<long long int>> dp(a.size()+10,vector<long long int>(k+10,-1));\\n        \\n        return solve(a,0,0,k,len,dp);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863972,
                "title": "python3-dp-solution-in-o-mn-time-and-o-n-space",
                "content": "# dp solution:\\n* `dp[i][j]` represents for the max number of covered white tiles within `floor[:j + 1]` using `i` carpets\\n* `dp[i][j] = max(max(dp[i][k] for k in range(j)), white count in floor[j - carpetLen : j + 1] + dp[i - 1][j - carpetLen])`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\\n\\n# optimization:\\nsince `dp[i]` only depend on `dp[i-1]`, we cound reduce space complexity to `O(N)`\\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n    n = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n\\t\\t\\n    dp = [[0] * (n) for _ in range(numCarpets + 1)]\\n    for i in range(1, numCarpets + 1):\\n        max_ = 0\\n        for j in range(n):\\n            # i carpets\\n            # cover [0:j + 1] floor\\n            if j - carpetLen < 0:\\n                dp[i][j] = cnt_white[j]\\n            else:\\n                dp[i][j] = max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[i - 1][j - carpetLen])\\n                max_ = dp[i][j]\\n    return cnt - dp[-1][-1]\\n```\n```\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n    # dp\\n\\tn = len(floor)\\n    cnt_white = []\\n    cnt = 0\\n    for i in floor:\\n        cnt += int(i)\\n        cnt_white.append(cnt)\\n    dp = [0] * (n)\\n    for i in range(1, numCarpets + 1):\\n        nxt = []\\n        max_ = 0\\n        for j in range(n):\\n            if j - carpetLen < 0:\\n                nxt.append(cnt_white[j])\\n            else:\\n                nxt.append(max(max_, cnt_white[j] - cnt_white[j - carpetLen] + dp[j - carpetLen]))\\n                max_ = nxt[-1]\\n        dp = nxt\\n    return cnt - dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1863921,
                "title": "python3-2d-dp-solution-explained",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        \"\"\"\\n        dp(pos, numC) -> returns min number of white tiles seen from pos to the end of the floor\\n                         if we have numC number of carpets left\\n        \\n        if numC > 0, i.e. we have some carpets remaining:\\n            if the tile at index pos is white, then we have two choices, \\n                either place a carpet from pos to pos + carpetLen - 1\\n                or skip this tile, so number of white tiles increases by one, and calculate the minimum answer from index\\n                pos + 1\\n            else\\n                no need to cover this tile, we can move ahead\\n        else:\\n            we cannot cover any more white tiles\\n            so return number of white tiles from pos to the end of floor\\n        \\n        \\n        time complexity : O(numCarpets * len(floor)) ~ O(n^2)\\n        \"\"\"\\n    \\n        @lru_cache(None) \\n        def dp(pos, numC):\\n            if pos >= n:\\n                return 0\\n            \\n            if numC > 0:\\n                if floor[pos] == \"1\":\\n                    return min(1 + dp(pos + 1, numC), dp(pos + carpetLen, numC - 1))\\n                else:\\n                    return dp(pos + 1, numC)\\n            else:\\n                return ones[pos]\\n                \\n        \\n        n = len(floor)\\n        \\n        #ones[i] stores the number of white tiles from index i to the end of floor \\n        ones = [0 for i in range(n)]\\n        ones[-1] = (floor[-1] == \"1\")\\n        \\n        for i in range(n-2, -1, -1):\\n            ones[i] = ones[i+1] + (floor[i] == \"1\")\\n            \\n            \\n        return dp(0, numCarpets)\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863880,
                "title": "c-with-comments-dp",
                "content": "```dp[idx][rem]``` wil store  maximum tiles we can cover from ```idx to last index``` if we are at index ```idx``` with ```rem``` amount of carpet\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```dp[idx][rem]```\n```idx to last index```\n```idx```\n```rem```\n```\\nclass Solution {\\npublic:\\n    vector<int>tile;\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string f, int num, int len) {\\n        int sz=f.size(),totalWHiteTiles=0;\\n        for(int i=0;i<sz;i++){\\n            if(f[i]==\\'1\\')\\n                totalWHiteTiles++;\\n            tile.push_back(totalWHiteTiles);\\n        }\\n        dp.resize(sz,vector<int>(num+1,-1));\\n        return totalWHiteTiles-helper(f,0,num,len);\\n    }\\n    int helper(string &floor,int idx,int rem,int &len){\\n        if(idx>=floor.size() || rem==0)\\n            return 0;\\n        if(dp[idx][rem]!=-1)\\n            return dp[idx][rem];\\n        int sz=floor.size();\\n        // don\\'t start covering the tiles from here\\n        int a=helper(floor,idx+1,rem,len);\\n        // start covering the  tiles from here\\n        int b=helper(floor,idx+len,rem-1,len);\\n        // last index where the carpet can go if we start coering from here\\n        int lastIdx=idx+len-1;\\n        // calculating how many tiles we will civer if we start from here\\n        b+=tile[lastIdx>=sz?(sz-1):lastIdx]-tile[idx];\\n        if(floor[idx]==\\'1\\')\\n            b++;\\n        dp[idx][rem]=max(a,b);\\n        return dp[idx][rem];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845101,
                "title": "easy-intuitive-solution-using-recursion-and-memoization",
                "content": "# Intuition\\nwe will try to put carpet on every white tile where it exists till\\nour number of carpets are over.\\n\\n# Approach\\nif we find a white tile we will put a carpet based on the length of\\nthe carpet and look for more white tile and put carpet over them too,\\nif the number of carpet is over we cant do anything at that case we \\nhave to count the white tiles. If it is black tile we ignore it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size(),vector<int>(numCarpets+1,-1));\\n        return solve(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    int solve(int i,string &floor, int numCarpets, int &carpetLen,vector<vector<int>>&dp){\\n        if(i == floor.size()) return 0;\\n        if(dp[i][numCarpets] != -1) return dp[i][numCarpets];\\n\\n        if(floor[i] == \\'1\\'){\\n            int putCarpet=INT_MAX;\\n            if(numCarpets!=0) \\n            {\\n               int temp= floor.size();\\n                putCarpet = solve( min(temp,i+carpetLen),floor,numCarpets-1,carpetLen,dp);\\n            }\\n\\n            int notput=1+solve(i+1,floor,numCarpets,carpetLen,dp);\\n\\n            return dp[i][numCarpets] = min(putCarpet,notput);\\n\\n        }else{\\n            //ignore black tiles\\n            return dp[i][numCarpets] =solve(i+1,floor,numCarpets,carpetLen,dp);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843439,
                "title": "dp-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int f(int ind,int count,string  &s,int carpetlen,vector<vector<int>>&dp){\\n        if(count<0)return -1e9;\\n        if(ind >= s.size())return 0;\\n\\n        if(dp[ind][count]!=-1)return dp[ind][count];\\n        int color = -1e9;\\n        int notcolor = -1e9;\\n        if(s[ind] == \\'0\\'){\\n            notcolor = 1 + f(ind+1,count,s,carpetlen,dp);//we donot need to color this index as it is laredy black \\n        }\\n        else if(s[ind] == \\'1\\'){\\n            notcolor = f(ind+1,count,s,carpetlen,dp);\\n            if(ind+carpetlen >=s.size()){\\n                color=(s.size() - ind);\\n            }\\n            else color=carpetlen;\\n            color+=f(ind+carpetlen,count-1,s,carpetlen,dp);//color means we are coloring \\n        }\\n\\n        return dp[ind][count] = max(color,notcolor);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        int count = numCarpets;\\n        vector<vector<int>>dp(n,vector<int>(count+1,-1));\\n        int k = f(0,count,floor,carpetLen,dp);\\n        cout<<k<<endl;\\n        return n - k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3784168,
                "title": "0-1-knapsack-pick-not-pick-easy-to-read-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n,l;\\nint numCarpets;\\nint dp[1000+1][1000+1];\\n    int solve(string &floor, int ind, int rem){\\n        if(ind>=n) return 0;\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        if(floor[ind]==\\'1\\'){\\n           int pick=INT_MAX,not_pick=INT_MAX;\\n\\n            if(rem) pick=solve(floor,ind+l,rem-1);\\n            not_pick=1+solve(floor,ind+1,rem);\\n            return dp[ind][rem]=min(op1,op2);\\n        }\\n        return dp[ind][rem]=solve(floor,ind+1,rem);\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n=floor.size(), l=carpetLen;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,0,numCarpets);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776595,
                "title": "dp-solution-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,string &s,int k,int len,vector<int> &pre,vector<vector<int>> &dp){\\n        int n = s.size();\\n        if(i>=n) return 0;\\n        \\n        if(dp[i][k]!=-1) return dp[i][k];\\n        \\n        int tk=-1e9,ksum=0;\\n        ksum=(i+len<=n)?(pre[i+len]-pre[i]):(pre[n]-pre[i]);\\n        \\n        if(k>0 and s[i]==\\'1\\') tk = ksum+solve(i+len,s,k-1,len,pre,dp);\\n        int nottk = 0+solve(i+1,s,k,len,pre,dp);\\n        \\n        return dp[i][k]=max(tk,nottk);\\n    }\\n    int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        int n = s.size();\\n        vector<int> pre(n+1,0);\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,-1));\\n        for(int i=1;i<=n;i++) {\\n            pre[i]=pre[i-1];\\n            if(s[i-1]==\\'1\\') pre[i]+=1;\\n        }\\n        \\n        return pre[n]-solve(0,s,numCarpets,carpetLen,pre,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763375,
                "title": "my-solution",
                "content": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * the dynamic programming solution is employed.\\n *\\n * `dp[carpets][tiles]` stands for the minimum number of while tiles\\n * when `carpets` carpets have been covered in the tile range [0, tiles),\\n * 0 inclusive, `tiles` exclusive.\\n * where `carpets` is in the range [0, `numCarpets`], both inclusive\\n *       `tiles` is in the range [0, `floor.size()`], both inclusive\\n *\\n * initial:\\n * if `carpets` == 0\\n * 1. if tiles == 0,\\n *    dp[carpets][tiles] = 0\\n * 2. if tiles > 0,\\n *    dp[carpets][tiles] = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n *\\n * induction:\\n * 1. if tiles == 0\\n *    dp[carpets][tiles] = 0\\n * 2. otherwise\\n * 2.1. let `covered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is covered by a carpet\\n *      covered = dp[carpets - 1][max(0, tiles - carpetLen)]\\n * 2.2. let `uncovered` stand for the minimum number of while tiles\\n *      if the `tiles - 1`\\'th tile is not covered by a carpet,\\n *      uncovered = dp[carpets][tiles - 1] + (floor[tiles - 1] == \\'1\\' ? 1 : 0)\\n * dp[carpets][tiles] = min(covered, uncovered)\\n *\\n * target:\\n * dp[numCarpets][floor.size()]\\n *\\n * Time Complexity: O(numCarpets * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `floor`\\n */\\nclass Solution {\\n public:\\n  int minimumWhiteTiles(const string &floor, const int numCarpets, const int carpetLen) {\\n    constexpr int range = 2;\\n    constexpr char white = \\'1\\';\\n    const int n = static_cast<int>(floor.size());\\n    int dp[range][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    for (int tiles = 1; tiles < n + 1; ++tiles) {\\n      dp[previous][tiles] = dp[previous][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n    }\\n    \\n    for (int carpets = 1; carpets < numCarpets + 1; ++carpets) {\\n      for (int tiles = 1; tiles < n + 1; ++tiles) {\\n        const int covered = dp[previous][max(0, tiles - carpetLen)];\\n        const int uncovered = dp[current][tiles - 1] + (floor[tiles - 1] == white ? 1 : 0);\\n        dp[current][tiles] = min(covered, uncovered);\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    \\n    return dp[previous][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729027,
                "title": "c-java-memoization-commented",
                "content": "## Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    #define WHITE \\'1\\'\\n    \\n    vector<vector<int>> dp;\\n    int n, c;\\n    \\n    int solve(string &floor, int ind, int rem){\\n\\n        // Reached end - No white tiles visible\\n        if(ind >= n) return 0;\\n\\n        // Checking cache\\n        if(dp[ind][rem] != -1) return dp[ind][rem];\\n\\n        int res = 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n        \\n        // Don\\'t cover this tile \\n        // If its a white tile, one white tile is visible already\\n        res = (floor[ind] == WHITE) + solve(floor, ind + 1, rem);\\n        \\n        // Cover this tile if its a white tile and carpets are still remaining\\n        if(floor[ind] == WHITE and rem) res = min(res, solve(floor, ind + c, rem - 1));\\n        \\n        // Caching\\n        return dp[ind][rem] = res;\\n        \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        n = floor.length(), c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = vector<vector<int>> (n + 1, vector<int> (numCarpets + 1, -1));\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n\\n    private static final char WHITE = \\'1\\';\\n    private int[][] dp;\\n    private int n, c;\\n\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        n = floor.length();\\n        c = carpetLen;\\n\\n        // 2D DP {index, carpetsRemaining}\\n        dp = new int[n + 1][numCarpets + 1];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(floor, 0, numCarpets);\\n    }\\n\\n    private int solve(String floor, int ind, int rem) {\\n        // Reached end - No white tiles visible\\n        if (ind >= n) {\\n            return 0;\\n        }\\n\\n        // Checking cache\\n        if (dp[ind][rem] != -1) {\\n            return dp[ind][rem];\\n        }\\n\\n        int res = (int) 1e8;\\n\\n        // We have 2 options -> Cover this tile or don\\'t\\n\\n        // Don\\'t cover this tile\\n        // If it\\'s a white tile, one white tile is visible already\\n        res = (floor.charAt(ind) == WHITE ? 1 : 0) + solve(floor, ind + 1, rem);\\n\\n        // Cover this tile if it\\'s a white tile and carpets are still remaining\\n        if (floor.charAt(ind) == WHITE && rem > 0) {\\n            res = Math.min(res, solve(floor, ind + c, rem - 1));\\n        }\\n\\n        // Caching\\n        dp[ind][rem] = res;\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727529,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```dp[i][j]``` is minimum number of visible white tiles in the first ```i``` tiles ([0, i]) which are coverd by ```j``` carpets.\\nIf the tile is black, ```dp[i][j] = dp[i][j-1] + 1```.\\nIf the tile is white, we have 2 choices,\\none is using a carpet to to cover it, ```dp[i][j] = dp[i-1][j-carpetLen]```.\\nAnother is not to cover it, ```dp[i][j] = dp[i][j-1] + 1```.\\nWe select minimum choice, ```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```.\\n\\nAt first, there is no carpet, so ```dp[0][j]``` is number of white tiles in the first ```j``` tiles.\\n\\ntc and sc are O(numCarpets * len(floor))\\n\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\\n### space optimization\\nuse scrolling array.\\n### python\\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][j]```\n```i```\n```j```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = dp[i-1][j-carpetLen]```\n```dp[i][j] = dp[i][j-1] + 1```\n```dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])```\n```dp[0][j]```\n```j```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n\\t\\t\\n\\t\\t# floor are covered by carpets entirely\\n        if numCarpets * carpetLen >= size: return 0\\n\\t\\t\\n        dp  = [[0] * size for _ in range(numCarpets+1)]\\n\\t\\t\\n\\t\\t# At first, there is no carpet\\n\\t\\t# dp[0][j] is number of white tiles in the first j tiles\\n        dp[0][0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i])\\n        \\n        for i in range(1, numCarpets+1):\\n\\t\\t\\t# there have i carpets, it can covered i * carpetLen tiles, \\n\\t\\t\\t# so dp[i][0...i * carpetLen-1] are 0\\n\\t\\t\\t\\n            for j in range(i * carpetLen, size):\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# min(not to cover, use a carpet to cover j-th tile)\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen])\\n        return dp[numCarpets][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int size = floor.size();\\n        if (numCarpets * carpetLen >= size) return 0;\\n        vector<vector<int>> dp (numCarpets+1, vector<int>(size));\\n        dp[0][0] = (\\'1\\' == floor[0]);\\n        for (int i = 1; i < size; i+=1) \\n            dp[0][i] = dp[0][i-1] + (\\'1\\' == floor[i]); \\n        for (int i = 1; i <= numCarpets; i+=1) {\\n            for (int j = i * carpetLen; j < size; j+=1) {\\n                dp[i][j] = min(dp[i][j-1] + (\\'1\\' == floor[j]), dp[i-1][j-carpetLen]); \\n            }\\n        }\\n        return dp[numCarpets][size-1];\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        size = len(floor)\\n        if numCarpets * carpetLen >= size: return 0\\n        dp  = [0] * size\\n        dp[0] = \\'1\\' == floor[0]\\n        for i in range(1, size):\\n            dp[i] = dp[i-1] + (\\'1\\' == floor[i])\\n        for i in range(1, numCarpets+1):\\n            tmp = dp[:] # dp[i-1][j-carpetLen]\\n            dp[i * carpetLen - 1] = 0 # notice that dp[j-1]\\n            for j in range(i * carpetLen, size):\\n                dp[j] = min(dp[j-1] + (\\'1\\' == floor[j]), tmp[j-carpetLen])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697042,
                "title": "easy-to-understand-c-recursive-memoization-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming take and not take simple intuition.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSolved using Dynamic Programming approach.\\nThere are 3 case , starting from the first tile \\n1. Black tile : skip and move to next tile\\n2. White tile not Take : skip and move to next tile\\n3. White tile take : use the carpet to cover and move to (curr tile + carpetLen - 1 )th tile\\nthen take the max of all.\\nWe are taking max because we have to find min uncovered tile, so max covered tile. \\n\\n# Complexity\\n- Time complexity:\\nO(floor.length() * numCarpets)\\n\\n- Space complexity:\\nO(floor.length() * numCarpets)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int i, int num, int &len, vector<int> &prefix_floor, string &floor,int &n,vector<vector<int>> &dp){\\n        if(i>=n || num==0) return 0;\\n        if(dp[i][num]!=-1) return dp[i][num];\\n        if(floor[i]==\\'0\\') return dp[i][num] = f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int notTake =  f(i+1,num,len,prefix_floor,floor,n,dp);\\n        int bnd = min(i+len-1,n-1);\\n        int white = prefix_floor[bnd];\\n        if(i!=0) white = white - prefix_floor[i-1];\\n        int take = white + f(i+len,num-1,len,prefix_floor,floor,n,dp);\\n        return dp[i][num] = max(take,notTake);\\n    }\\n\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> prefix_floor;\\n        int count = 0;\\n        if(floor[0]==\\'1\\'){\\n            prefix_floor.push_back(1);\\n            count++;\\n        }\\n        else prefix_floor.push_back(1);\\n        for(int i=1; i<n; i++){\\n            if(floor[i]==\\'1\\'){\\n                prefix_floor.push_back(1 + prefix_floor[i-1]);\\n                count++;\\n            }\\n            else{\\n                prefix_floor.push_back(prefix_floor[i-1]);\\n            }\\n        }\\n        vector<vector<int>> dp(n,vector<int>(numCarpets+1,-1));\\n        return count-f(0,numCarpets,carpetLen,prefix_floor,floor,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560127,
                "title": "python-readable-and-easy-understand-dp-solution-commented-86-faster",
                "content": "# Intuition\\nIf the tile is white, put there a carpet or not.\\n\\n# Complexity\\n- Time complexity: O(n*numCarpets)\\n\\n- Space complexity: O(n*numCarpets)\\n\\n# Code\\n```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        dp = [[0]*(numCarpets+1) for i in range(len(floor))]\\n\\n        for i in range(len(floor)):\\n            for j in range(numCarpets+1):\\n                if j == 0:              # no carpets\\n                    dp[i][j] = floor.count(\\'1\\', 0, i+1)\\n                elif floor[i] == \\'0\\':   # black tail\\n                    dp[i][j] = dp[i-1][j]\\n                elif carpetLen > i:     # the carpet is longer than the tails\\n                    dp[i][j] = 0\\n                else:                   # put a carpet or leave it visible\\n                    dp[i][j] = min(dp[i-1][j] + 1,\\n                                   dp[i-carpetLen][j-1])\\n        \\n        return dp[len(floor)-1][numCarpets]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544325,
                "title": "python3-clean-and-concise-dp",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cl: int) -> int:\\n        \\n        n=len(floor)\\n        total=sum(int(ch) for ch in floor)\\n        \\n        @cache\\n        def f(ind,count):\\n            if ind<0 or count==0:\\n                return 0\\n            \\n            ans=floor[max(0,ind-cl+1):ind+1].count(\"1\") + f(ind-cl,count-1)\\n            ans=max(ans,f(ind-1,count))\\n            \\n            return ans\\n        \\n        return total-f(n-1,nc)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542793,
                "title": "python-simple-dp-solution-with-simple-explanation-in-comments",
                "content": "\\n- Space complexity:\\nO(n^2) time and space\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        # first thought is dp[i][j] = min white covering floor[i:] with j carpets of carpetLen\\n        # dp[i-1][j] = dp[i][j] if floor[i-1] is black\\n        # if floor[i-1] is white, then either we can cover it with a carpet or not\\n            # either its dp[i][j]+1 (an extra white that is uncovered) or\\n            # dp[i+carpetLen][j-1] whichever is smaller. \\n         \\n        # last row will be covering nothing on the floor with j carpets, so all 0\\n        # first column will be covering floor[i:] with 0 carpets\\n        dp = []\\n        for i in range(len(floor)): dp.append([1000]*(numCarpets+1))\\n        dp.append([0]*(numCarpets+1))\\n        for i in range(len(floor)-1, -1, -1): \\n            for j in range(numCarpets, -1, -1):\\n                if floor[i] == \"0\": #black\\n                    dp[i][j] = dp[i+1][j]\\n                else: #white\\n                    uncover = dp[i+1][j] +1\\n                    upper_bound = min(i+carpetLen, len(floor)) \\n                    cover = 9999\\n                    if j-1>=0:\\n                        cover = dp[upper_bound][j-1]\\n                    dp[i][j] = min(uncover, cover)\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534474,
                "title": "dp-recursion-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(string &floor, int numCarpets, int carpetLen,int index,vector<vector<int>>&dp )\\n    {\\n        int n =floor.size();\\n        if(index>=n)return 0;\\n        if(dp[index][numCarpets]!=-1)return dp[index][numCarpets];\\n        int o1=INT_MAX;\\n        int o2=INT_MAX;\\n        if(floor[index]==\\'1\\')\\n        {\\n            o1=1+dfs(floor,numCarpets,carpetLen,index+1,dp);\\n            if(numCarpets>0)\\n            {\\n                o2=dfs(floor,numCarpets-1,carpetLen,index+carpetLen,dp);\\n            }\\n        }\\n        else\\n        {\\n           return dp[index][numCarpets]=dfs(floor,numCarpets,carpetLen,index+1,dp); \\n        }\\n        return dp[index][numCarpets]=min(o1,o2);\\n\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>dp(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return dfs(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528393,
                "title": "ruby-100",
                "content": "\\n# Code\\n```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_white_tiles(floor, num_carpets, carpet_len)\\n  n = floor.length\\n  return 0 if carpet_len * num_carpets >= n\\n\\n  floor_list = floor.chars.map { |c| c == \\'1\\' ? 1 : 0 }\\n  dp = Array.new(num_carpets) { Array.new(n, 0) }\\n\\n  (carpet_len...n).each do |i|\\n    dp[0][i] = [floor_list[i] + dp[0][i - 1], floor_list[0..(i - carpet_len)].sum].min\\n  end\\n\\n  (1...num_carpets).each do |j|\\n    (carpet_len * j...n).each do |i|\\n      dp[j][i] = [floor_list[i] + dp[j][i - 1], dp[j - 1][i - carpet_len]].min\\n    end\\n  end\\n\\n  dp[-1][-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3484473,
                "title": "c-dynamic-programming-pick-not-pick",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(string &floor, int i){\\n        int count = 0;\\n        for(int j=i;j<floor.size();j++)\\n            count += floor[j] == \\'1\\';\\n        return count;\\n    }\\n    \\n    \\n    int solve(string &floor, int num, int len, int i, vector<vector<int>> &dp){\\n        if(i >= floor.size())\\n            return 0;\\n        if(num == 0)\\n            return fun(floor,i);\\n        if(dp[i][num] != -1)\\n            return dp[i][num];\\n        int take = solve(floor,num-1,len,i+len,dp);\\n        int nottake = solve(floor,num,len,i+1,dp);\\n        if(floor[i] == \\'1\\')\\n            nottake++;\\n        return dp[i][num] = min(take,nottake);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>> dp(floor.size()+1,vector<int> (numCarpets+1,-1));\\n        return solve(floor,numCarpets,carpetLen,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407430,
                "title": "simple-memoization-based-solution",
                "content": "# Approach\\nThree choices\\n1. Use carpet if available and necessary. In this can case jump to index + carpet length\\n2. Do not use carpet even if available and necessary. Increase count by 1 and move to next index. Here we save carpt to be used later. \\n3. Handle scenarios like no carpet available or carpet not necessary because tile is lready black. \\n\\n\\n# Complexity\\n- Time complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(floorLength * numberOfCarpets)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] memo = new int[floor.length()][numCarpets+1];\\n        for(int[] arr : memo) {\\n            Arrays.fill(arr, -1);\\n        }\\n        return solve(floor, numCarpets, carpetLen, 0, memo);\\n    }\\n\\n    int solve(String floor, int numCarpets, int carpetLen, int index, int[][] memo) {\\n        if(index >= floor.length()) {\\n            return 0;\\n        }\\n        if(memo[index][numCarpets] != -1) {\\n            return memo[index][numCarpets];\\n        }\\n        if(numCarpets > 0) {\\n            if(floor.charAt(index) == \\'0\\') {\\n                return memo[index][numCarpets] = solve(floor, numCarpets, carpetLen, index+1, memo);\\n            }\\n            else {\\n                int coveredWhite = solve(floor, numCarpets-1, carpetLen, index+carpetLen, memo);\\n                int unCoveredWhite = 1 + solve(floor, numCarpets, carpetLen, index+1, memo);\\n                return memo[index][numCarpets] = Math.min(coveredWhite, unCoveredWhite);\\n            }\\n        }\\n        else {\\n            int count = 0;\\n            for(int i = index; i < floor.length(); i++) {\\n                count = floor.charAt(i) == \\'1\\' ? count + 1 : count;\\n            }\\n            return memo[index][numCarpets] = count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356674,
                "title": "c-golang-dp",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        vector<vector<int>> DP(2, vector<int>(n + carpetLen));\\n        for(int i = n - 1; i >= 0; i--) DP[0][i] += DP[0][i + 1] + floor[i] - \\'0\\';\\n        for(int i = 0; i < numCarpets; i++) {\\n            for(int j = n - 1; j >= 0; j--) {\\n                DP[(i + 1) % 2][j] = min(DP[i % 2][j + carpetLen], DP[(i + 1) % 2][j + 1] + (floor[j] - \\'0\\')); \\n            }\\n        }\\n        return DP[numCarpets % 2][0];\\n    }\\n};\\n\\n\\n// Golang\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    var n int = len(floor)\\n    DP := make([][]int, 2)\\n    DP[0] = make([]int, n + carpetLen)\\n    DP[1] = make([]int, n + carpetLen)\\n    for i := n - 1; i >= 0; i-- {\\n        DP[0][i] += DP[0][i + 1] + int(floor[i] - \\'0\\')\\n    } \\n    for i := 0; i < numCarpets; i++ {\\n        for j := n - 1; j >= 0; j-- {\\n            DP[(i + 1) % 2][j] = DP[(i + 1) % 2][j + 1] + int(floor[j] - \\'0\\')\\n            if DP[i % 2][j + carpetLen] < DP[(i + 1) % 2][j] {\\n                DP[(i + 1) % 2][j] = DP[i % 2][j + carpetLen]\\n            }\\n        }\\n    }\\n    return DP[numCarpets % 2][0]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262511,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_white_tiles(floor: String, num_carpets: i32, carpet_len: i32) -> i32 {\\n        let floor = floor.as_bytes();\\n        let n = floor.len();\\n        let mut dp = vec![vec![0; num_carpets as usize + 1]; n + 1];\\n        for i in 1..=n {\\n            for k in 0..=num_carpets as usize {\\n                let jump = dp[i - 1][k] + (floor[i - 1] - b\\'0\\') as i32;\\n                let cover = if k > 0 {\\n                    dp[i.saturating_sub(carpet_len as usize)][k - 1]\\n                } else {\\n                    1000\\n                };\\n                dp[i][k] = jump.min(cover);\\n            }\\n        }\\n        dp[n][num_carpets as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3238008,
                "title": "python-memo-recursion",
                "content": "Here I collect number of covered `1` and then return the difference between the total number of `1` and number of covered, trying to minimize the coverage which in turn minimize the difference.\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        memo = [[None] * numCarpets for _ in range(len(floor))]\\n        prefix = [0] * (len(floor) + 1)\\n        for i, val in enumerate(floor):\\n            prefix[i + 1] = int(val) + prefix[i]\\n        \\n        def helper(i, k):\\n            nonlocal floor, numCarpets, carpetLen, prefix, memo\\n            \\n            if i == len(floor) or k == -1:\\n                return 0\\n            if memo[i][k] is not None:\\n                return memo[i][k]\\n            \\n            right = min(i + carpetLen, len(floor))\\n            covered = prefix[right] - prefix[i] + helper(right, k - 1)\\n            not_covered = helper(i + 1, k)\\n            memo[i][k] = max(covered,  not_covered)\\n            \\n            return memo[i][k]\\n        \\n        return prefix[-1] - helper(0, numCarpets - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214130,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n        n, k = len(floor), numCarpets\\n\\n        @lru_cache(None)\\n        def dfs(i,k):\\n            if k < 0:\\n                return float(\"inf\")\\n\\n            if i >= n:\\n                return 0\\n\\n            if floor[i] == \"1\": return min(1+dfs(i+1,k),dfs(i+carpetLen,k-1))\\n\\n            return dfs(i+1,k)\\n\\n        return dfs(0,k)\\n\\n            \\n\\n            \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191098,
                "title": "python-dp-how-to-avoid-tle",
                "content": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "The thing I did to avoid TLE was, if you come to a point where the last carpetLen tiles are all 1s, you can \\'break\\' and greedily stop looking to place this next carpet after, as you won\\'t get a better result than if you place it here (or before here).\\n\\nThat\\'s in this line: \\'                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\'\\n\\n\\'\\'\\'\\nmemo={}\\n        floor = [int(floor[i]) for i in range(len(floor))]\\n        pres = [0]\\n        for i in floor:\\n            pres.append(pres[-1] + i)\\n        \\n            \\n        N=len(floor)\\n        \\n        def dp(ind,carpetsleft):\\n            nonlocal memo\\n            nonlocal pres\\n            nonlocal N\\n            \\n            if ind>=len(floor):\\n                return 0\\n            if (ind,carpetsleft) in memo:\\n                return memo[(ind,carpetsleft)]\\n            if carpetsleft ==0:\\n                return pres[-1] - pres[ind]\\n            \\n            cur = float(\\'inf\\')\\n            uncovered = 0\\n            for i in range(ind,N):\\n                \\n                cur = min(cur, uncovered + dp(i+carpetLen,carpetsleft-1))\\n                \\n                if pres[min(N,i+carpetLen)]-pres[i] == carpetLen:\\n                    break\\n                    \\n                uncovered += floor[i]\\n            \\n            memo[(ind,carpetsleft)] = cur\\n            return cur\\n\\n        return dp(0,numCarpets)\\n\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3156969,
                "title": "tc-o-n-number-of-carpet",
                "content": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n      vector<int> pre;\\n        int solve(string &floor, int pos,int num, int len,vector<vector<int>> &dp)\\n        {\\n            if(pos<0)return 0;\\n            if(num==0)return pre[pos];\\n            if(dp[pos][num]!=-1)return dp[pos][num];\\n            int ans=1e9;\\n            if(floor[pos]==\\'0\\')\\n            {\\n                ans=min(ans,solve(floor,pos-1,num,len,dp));\\n            }\\n            else\\n            {\\n                ans=min(ans,min(solve(floor,pos-len,num-1,len,dp),1+solve(floor,pos-1,num,len,dp)));\\n            }\\n            return dp[pos][num]=ans;\\n            \\n        }\\n        int minimumWhiteTiles(string floor, int num, int len)\\n        {\\n            int n=floor.size();\\n            int o=0;\\n            pre.resize(n+1,0);\\n            for(int i=0;i<n;i++)\\n            {\\n                if(floor[i]==\\'1\\')o++;\\n                pre[i]=o;\\n            }\\n            vector<vector<int>> dp(n+1,vector<int>(num+1,-1));\\n            return solve(floor,n-1,num,len,dp);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148659,
                "title": "dp-python-clean",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, carpetLen: int) -> int:\\n        m = len(floor)\\n        dp = [[0 for _ in range(m)] for _ in range(n + 1)]\\n        for i in range(len(dp[0])):\\n            dp[0][i] = floor[:i + 1].count(\\'1\\')\\n        for i in range(1, n + 1):\\n            for j in range(i * carpetLen, m):\\n                dp[i][j] = min(dp[i][j - 1] + (floor[j] == \\'1\\'), dp[i - 1][j - carpetLen])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086449,
                "title": "scala-top-down-dp",
                "content": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nimport scala.collection.mutable.HashMap\\nobject Solution {\\n    def minimumWhiteTiles(floor: String, numCarpets: Int, carpetLen: Int): Int = {\\n        def mem[I, O](f: I => O) = new HashMap[I, O]() {\\n            override def apply(key: I) = getOrElseUpdate(key, f(key))\\n        }\\n        \\n        lazy val dp: ((Int, Int)) => Int = mem {\\n            case (i, _) if (i < 0) => 0\\n            case (i, 0) => floor.take(i + 1).count(_ == \\'1\\')\\n            case (i, j) => dp(i - carpetLen, j - 1) min dp(i - 1, j) + floor(i) - \\'0\\'\\n        }\\n        \\n        dp(floor.size - 1, numCarpets)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3076052,
                "title": "3-lines-prefix-sum-python-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, nc: int, cpl: int) -> int:\\n        acc = [0] + list(accumulate(map(int, floor))) + [floor.count(\"1\")] * cpl\\n        @lru_cache(None)\\n        def dp(i, c): return 0 if c==0 or i>=len(floor) else max(dp(i+1,c), acc[i+cpl]-acc[i]+dp(i+cpl,c-1))\\n        return acc[-1] - dp(0, nc)\\n\\n\\n       \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040120,
                "title": "easy-top-down-dp-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//returns the min no. of white carpets ;\\n    int f(int i, int k, int kl, string &s, vector<vector<int>> & dp){\\n        //base cases\\n        if(i < 0)return 0;\\n        if(k == 0){\\n            //return all the white tiles in the string s[0...i];\\n            int ones = 0;\\n            for(int ii=0; ii<=i; ii++){\\n                ones += (s[ii]==\\'1\\');\\n            }\\n            return ones;\\n        }\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans = INT_MAX;;\\n        //we ignore;\\n        ans = f(i-1, k, kl, s, dp) + (s[i] == \\'1\\');\\n        //we cover it;\\n        ans = min(ans, f(i-kl, k-1, kl, s, dp));\\n\\n        return dp[i][k] = ans;\\n    }\\n\\n    int minimumWhiteTiles(string s, int k, int kl) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(k+1, -1));\\n        return f(n-1, k, kl, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971453,
                "title": "c-simple-recursion-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninclude | exclude dp problems\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a prefix array to save the loop over carplen \\nand apply DP and recusion over the prefix array\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int solve(int idx,vector<int> &arr,int k,int n,vector<vector<int>> &dp){\\n        if(n==0 || idx>=arr.size()){\\n            return 0;\\n        }\\n\\n        if(dp[idx][n]!=-1)return dp[idx][n];\\n\\n        // use \\n        int use;\\n        if(idx==0)use=arr[idx+(k-1)] + solve(idx+k,arr,k,n-1,dp);\\n        else if(idx+k>=arr.size()) use=arr.back()-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n        else use = use=arr[idx+(k-1)]-arr[idx-1] + solve(idx+k,arr,k,n-1,dp);\\n\\n        // skip\\n        int skip=solve(idx+1,arr,k,n,dp);\\n\\n        return dp[idx][n]=max(use,skip);\\n\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int n, int k) {\\n        int cnt=0;\\n        vector<int> arr;\\n        int sz=floor.length();\\n        vector<vector<int>> dp(sz+1,vector<int>(n+1,-1));\\n        for(auto i:floor){\\n            if(i==\\'1\\')cnt++;\\n        arr.push_back(cnt);\\n        }\\n\\n        return cnt-solve(0,arr,k,n,dp);\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961259,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961258,
                "title": "java-o-numofcarpets-floorlength",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(numOfCarpets * floorLength)\\n# Code\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if(numCarpets * carpetLen >= floor.length()) return 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        dp[0][0] = floor.charAt(0) == \\'0\\' ? 0 : 1;\\n        for(int i=1;i<floor.length();i++) dp[0][i] = dp[0][i-1] + (floor.charAt(i) == \\'0\\' ? 0 : 1);\\n\\n        for(int i=1;i<=numCarpets;i++) {\\n            for(int j=carpetLen;j<floor.length();j++) {\\n                if(floor.charAt(j) == \\'0\\') {\\n                    dp[i][j] = dp[i][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(1 + dp[i][j-1], dp[i-1][j-carpetLen]);\\n                }\\n            }\\n        }\\n        return dp[numCarpets][floor.length()-1];\\n    }\\n    // 1 1 2 3 3 4 4 5\\n    // 0 0 1 1 1 2 2 3\\n    // 0 0 0 0 0 1 1 2\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941866,
                "title": "c-simple-dp-fast-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &dp, string &s,int idx, int k, int len)\\n    {\\n        int n = s.size(), ans = 0;\\n        if(idx >= n)return 0;\\n        if(dp[idx][k]!=-1)return dp[idx][k];\\n        if(s[idx] == \\'0\\')\\n        {\\n            ans = max(ans, 1 + solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        else\\n        {\\n            ans = max(ans, solve(dp, s,idx+1,k,len));\\n            if(k>0)ans = max(ans , min(len, n-idx) + solve(dp, s, idx+len,k-1,len));\\n        }\\n        return dp[idx][k] = ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen){\\n        vector<vector<int>> dp(floor.size()+1, vector<int> (numCarpets + 1, -1));\\n        int max_cnt = solve(dp, floor, 0, numCarpets, carpetLen);\\n        return floor.size()-max_cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927625,
                "title": "golang-dp-prefix-sum",
                "content": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(s string, nc int, cl int) int {\\n\\tps := make([]int, 0, len(s))\\n\\tc := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == 49 {\\n\\t\\t\\tc++\\n\\t\\t}\\n\\t\\tps = append(ps, c)\\n\\t}\\n\\n\\tmem := make([][]int, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tmem[i] = make([]int, nc+1)\\n\\t\\tfor j := 0; j < nc+1; j++ {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\n\\tvar dp func(p, oc int) int\\n\\tdp = func(p, oc int) int {\\n\\t\\tif p >= len(s) {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif oc <= 0 {\\n\\t\\t\\treturn ps[len(ps)-1] - ps[p-1]\\n\\t\\t}\\n\\t\\tif mem[p][oc] != -1 {\\n\\t\\t\\treturn mem[p][oc]\\n\\t\\t}\\n\\t\\tmem[p][oc] = 0\\n\\t\\tif s[p] == 49 {\\n\\t\\t\\tmem[p][oc] += 1 + dp(p+1, oc)\\n\\t\\t} else {\\n\\t\\t\\tmem[p][oc] += dp(p+1, oc)\\n\\t\\t}\\n\\t\\tk := dp(p+cl, oc-1)\\n\\t\\tif k < mem[p][oc] {\\n\\t\\t\\tmem[p][oc] = k\\n\\t\\t}\\n\\t\\treturn mem[p][oc]\\n\\t}\\n\\treturn dp(0, nc)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903745,
                "title": "javascript-dynamicprogramming-time-o-floor-numcarpets",
                "content": "# Complexity\\n- Time complexity:\\n$$O(floor * numCarpets)$$\\n\\n- Space complexity:\\n$$O(floor)$$\\n\\n# Code\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let prev = Array(floor.length + 1).fill(0);\\n\\n    for (let i = 1; i <= floor.length; i++)\\n        prev[i] = prev[i - 1] + (floor[i - 1] == \"1\");\\n\\n    for (let j = 1; j <= numCarpets; j++) {\\n        const cur = Array(floor.length + 1).fill(0);\\n\\n        for (let i = 1; i <= floor.length; i++)\\n            cur[i] = Math.min(cur[i - 1] + (floor[i - 1] == \"1\"), \\n                i >= carpetLen ? prev[i - carpetLen] : 0);\\n\\n        prev = cur;\\n    }\\n    return prev.at(-1);\\n};\\n```\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    const dp = Array.from({ length: floor.length }, \\n        () => Array(numCarpets + 1).fill(Infinity));\\n\\n    for (let i = floor.length - 1; i >= 0; i--)\\n        dp[i][0] = (i + 1 < floor.length && dp[i + 1][0]) + (floor[i] == \"1\");\\n\\n    const recursion = (index, numCarpets) => {\\n        if (index >= floor.length) return 0;\\n        if (dp[index][numCarpets] < Infinity) return dp[index][numCarpets];\\n\\n        return dp[index][numCarpets] = Math.min(\\n            (floor[index] == \"1\") + recursion(index + 1, numCarpets), \\n            recursion(index + carpetLen, numCarpets - 1)\\n        );\\n    };\\n\\n    return recursion(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886735,
                "title": "dp-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int helper(int i,string &f,int j,int cl,vector<vector<int>>&dp){\\n        if( i>=f.size() ){\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        if(f[i]==\\'0\\'){\\n           return dp[i][j]= helper(i+1,f,j,cl,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            ans=1+helper(i+1, f,j,cl,dp);\\n            if(j>0) ans= min(ans,helper(i+cl, f,j-1,cl,dp));\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n,vector<int>(numCarpets+1,-1));\\n        return helper(0,floor,numCarpets,carpetLen,dp);\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842581,
                "title": "python-dp-pruning-o-n-2-faster-than-94",
                "content": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "<code>\\n        import sys\\n        sys.setrecursionlimit(2000000)\\n\\n        n = len(floor)\\n        pre_sums = [0] * (n + 1)\\n        for i, c in enumerate(floor):\\n            pre_sums[i + 1] = pre_sums[i] + (c == \"1\")\\n\\n        @lru_cache(maxsize=None)\\n        def dp(n, k):\\n            \"\"\"\\n            dp[n,k]: \\u524Dn\\u4E2A\\u7528k\\u4E2A\\u5730\\u6BEF\\u8986\\u76D6\\uFF0C\\u6700\\u591A\\u80FD\\u8986\\u76D6\\u591A\\u5C11\\u4E2Awhite floor(1). maximum number of white floor in floor[:n] could be coverd by k carpet\\n            dp[n,k] = max(dp[n - carpetLen][k - 1] + sum(1 in floor[n - carpetLen:n]), dp[n - 1,k])\\n            \"\"\"\\n            if k == 0 or n <= 0:\\n                return 0\\n\\n            # full cover, the most import optimization. TLE -> runtime_percentile: 94%\\n            if k >= pre_sums[n] or k * carpetLen >= n:\\n                return pre_sums[n]\\n\\n            i = max(n - carpetLen, 0)\\n            return max(\\n                dp(i, k - 1) + pre_sums[n] - pre_sums[i],\\n                dp(n - 1, k)\\n            )\\n        return pre_sums[-1] - dp(len(floor), numCarpets)\\n</code>",
                "codeTag": "Python3"
            },
            {
                "id": 2839251,
                "title": "dp-c-coin-change-problem-variant",
                "content": "\\n\\n# Approach\\ncoin change problem\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    int minimumWhiteTiles(string floor, int num, int len) {\\n          \\n          int w=0;\\n          int n=floor.size();\\n          vector<int>v(n+1,0);\\n          vector<vector<int>>dp(num+1,vector<int>(n+1,0));\\n          for(int i=1;i<=n;i++)\\n          {\\n              if(floor[i-1]==\\'1\\')w++;\\n              v[i]=v[i-1]+(floor[i-1]==\\'1\\');\\n              \\n          }\\n                for(int i=1;i<=num;i++)\\n                {\\n                    for(int j=1;j<=n;j++)\\n                    {\\n                        if(j<len)\\n                        {\\n                            dp[i][j]=v[j];\\n                            continue;\\n                        }\\n                    int use=v[j]-v[j-len]+dp[i-1][j-len];\\n                          \\n                    int not_use=dp[i][j-1];\\n                       dp[i][j]=max(use,not_use);\\n                    }\\n                }\\n           int maxi=0;\\n      \\n           for(int i=1;i<=n;i++)\\n           {\\n               maxi=max(maxi,dp[num][i]);\\n             \\n           }\\n    \\n           return w-maxi;\\n          \\n         //return max(0,w-rec(Len-1,floor,num,Len,v,dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797559,
                "title": "c-easy-understanding-dynamic-programming",
                "content": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    vector<int> suffix;\\n    int utilfunc(int i,int j,string &floor,int len)\\n    {\\n        if(i >= floor.length())\\n        {\\n            return 0;\\n        }\\n        \\n        if(j == 0)\\n        {\\n            return suffix[i];\\n        }\\n        \\n        if(dp[i][j] != -1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        int ans1 = utilfunc(i+1,j,floor,len) + (floor[i] == \\'1\\');\\n        int ans2 = utilfunc(i+len,j-1,floor,len);\\n        return dp[i][j] = min(ans1,ans2);\\n    }\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int len) {\\n        memset(dp,-1,sizeof(dp));\\n        int n  = floor.size();\\n        suffix.resize(n,0);\\n        suffix[n-1] = floor[n-1] == \\'1\\';\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] += suffix[i+1] + (floor[i] == \\'1\\');\\n        }\\n        \\n        return utilfunc(0,num,floor,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563262,
                "title": "memoization-explained-all-possible-ways-c",
                "content": "* Let\\'s think about all possible ways...\\n\\t* we skip the \\u2B1B Black Box  ( `memo(s,num,len,i+1)` )\\n\\t* now we have \\uD83D\\uDD32 White Box -\\n\\t\\t* we choose to cover it ( `memo(s,num-1,len,i+len)` ) thus covering next **i+len-1** boxes\\n\\t\\t* we skip this box too and let\\'s add 1 to **uncovered white box collection** ( `1 + memo(s,num,len,i+1)` )\\n\\nthe minimum uncovered white boxes among all possible ways is our desired answer....\\n`UPVOTE IF YOU LIKE \\uD83D\\uDE0E\\uD83D\\uDE4C`\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.size()+1,vector<int>(numCarpets+1,-1));\\n        return memo(floor,numCarpets,carpetLen,0);\\n    }\\n    int memo(string& s, int num, int len, int i){\\n        int n = s.size();\\n        if(i > n-1) return 0;\\n        if(num == 0){\\n            int cnt = 0;\\n            for(int j = i; j < n; ++j){\\n                if(s[j] == \\'1\\') cnt++;\\n            }\\n            return cnt;\\n        }\\n        if(dp[i][num] != -1) return dp[i][num];\\n        if(s[i] == \\'0\\') return dp[i][num] = memo(s,num,len,i+1);\\n        int cover = memo(s,num-1,len,i+len);\\n        int skip = 1 + memo(s,num,len,i+1);\\n        return dp[i][num] = min(cover,skip);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544757,
                "title": "c-dp-memoization",
                "content": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint tiles(int i, string &floor, int numCarpets, int carpetLen,vector<vector<int>>&dp)\\n    {\\n        if(i>=floor.size()) return 0;\\n        if(numCarpets==0)\\n        {\\n            int c=0;\\n            for(;i<floor.size();i++)\\n            {\\n                if(floor[i]==\\'1\\')   c++;\\n            }\\n            return c;\\n        }\\n        if(dp[i][numCarpets]!=-1)   return dp[i][numCarpets];\\n        int ans=INT_MAX;\\n        if(floor[i]==\\'1\\')   //here if current floor index has value \\'1\\' we can  use carpet to cover 1\\'s  or we can just move forward by 1 index\\n        ans= min(tiles(i+carpetLen,floor,numCarpets-1,carpetLen,dp),1+tiles(i+1,floor,numCarpets,carpetLen,dp));\\n        else ans= tiles(i+1,floor,numCarpets,carpetLen,dp); // and if current index has value \\'0\\' we will move forward by 1 index\\n        return dp[i][numCarpets]=ans;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) \\n    {\\n        int n=floor.size();\\n        vector<vector<int>>dp(n+1,vector<int>(numCarpets+1,-1));\\n        return tiles(0,floor,numCarpets,carpetLen,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2542978,
                "title": "python-go-c-top-down-vs-bottom-up-2d-vs-1d-dp-o-mn",
                "content": "*Python* top-down 2D-DP w/ built-in memo\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\\n\\n*Python* bottom-up 2D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\\n\\n*Python* bottom-up 1D-DP\\n\\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\\n\\n*Go* bottom-up 1D-DP in 94ms\\n\\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\\n\\n*C++* bottom-up 1D-DP\\n\\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    dp = functools.cache(\\n        lambda i, j: 1000 if i < 0 else 0 if j < 0\\n        else min(dp(i - 1, j - carpetLen), dp(i, j - 1) + int(floor[j]))\\n    )\\n    return dp(numCarpets, len(floor) - 1)\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    m, n = numCarpets + 2, len(floor) + carpetLen\\n    dp, A = [[[0, 1000][not i]] * n for i in range(m)], list(map(int, floor))\\n    for i in range(1, m):\\n        for j in range(carpetLen, n):\\n            dp[i][j] = min(dp[i - 1][j - carpetLen], dp[i][j - 1] + A[j - carpetLen])\\n    return dp[-1][-1]\\n```\n```python\\ndef minimumWhiteTiles(self, floor, numCarpets, carpetLen):\\n    n = len(floor) + carpetLen\\n    X, Y = [0] * carpetLen + list(itertools.accumulate(map(int, floor))), [0] * n\\n    A = list(map(int, floor))\\n    for _ in range(numCarpets):\\n        for i in range(carpetLen, n):\\n            Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen])\\n        X, Y = Y, X\\n    return X[-1]\\n```\n```go\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tn := len(floor)\\n\\tA := make([]int, n)\\n\\tfor i, c := range floor {\\n\\t\\tif c == \\'1\\' {\\n\\t\\t\\tA[i] = 1\\n\\t\\t}\\n\\t}\\n\\tX := make([]int, carpetLen)\\n\\tn += carpetLen\\n\\tfor i := carpetLen; i < n; i++ {\\n\\t\\tX = append(X, X[i-1]+A[i-carpetLen])\\n\\t}\\n\\tY := make([]int, n)\\n\\tfor __ := 0; __ < numCarpets; __++ {\\n\\t\\tfor i := carpetLen; i < n; i++ {\\n\\t\\t\\tY[i] = min(X[i-carpetLen], Y[i-1]+A[i-carpetLen])\\n\\t\\t}\\n\\t\\tX, Y = Y, X\\n\\t}\\n\\treturn X[n-1]\\n}\\n```\n```c++\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n    int n = floor.size();\\n    vector<int> A(n); for (int i = 0; i < n; ++i) if (floor[i] == \\'1\\') A[i] = 1;\\n    n += carpetLen;\\n    vector<int> X(carpetLen); for (int i = carpetLen; i < n; ++i) X.push_back(X[i - 1] + A[i - carpetLen]);\\n    vector<int> Y(n);\\n    for (int _ = 0; _ < numCarpets; ++_) {\\n        for (int i = carpetLen; i < n; ++i) Y[i] = min(X[i - carpetLen], Y[i - 1] + A[i - carpetLen]);\\n        swap(X, Y);\\n    }\\n    return X[n - 1];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2515048,
                "title": "c-dp-o-n-m-with-prefix-sum-with-detailed-explanation",
                "content": "The first step is to clarify this sentence: \"Carpets may overlap one another.\" Of course carpets could overlap, however if there is an optimal solution where carpets overlap, there is also an optimal solution where carpets don\\'t. As the result we can disregard solutions where carpets overlap. The only exception to this is when the cumulated size of the carpets in longer than the floor, but in that case there is no visible white tile.\\n\\nSecond step is to define dp[c][i], and in the present case it\\'s the maximum number of white tiles covered by any arrangement of c carpets in between tile 1 and tile i. As the order of the carpets doesn\\'t matter (they are all the same), we can say that the first carpet is before the second carpet and so on. Which leads to the following:\\n- First carpet: k1 is the number of white tiles covered with the first carpet at position i (covering tiles from i - len + 1 to i) thus dp[1][i] = max(dp[1][i - 1], k1) as we consider the best solution so far.\\n- Second carpet: k2 is  the number of white tiles covered with the second carpet at position i, then we add the best possible number of white tiles covered with the first carpet which is dp[1][i - len] as there is no overlap. As the result dp[2][i] = max(dp[2][i - 1], k2 + dp[1][i - len].\\n\\nBy extension we obtain this definition: dp[c][i] = max(dp[c][i - 1], kc + dp[c - 1][i - len], with kc the number of white tiles covered with carpet kc.\\n\\nFine, we now have a DP algorithm, however to make it O(n * m) we need to compute kc in O(1), and this is what the prefix sum is for. Instead of iterating through the tiles within each interval [i - len + 1, i], we just need to make the difference between the prefix sum of the last tile and the prefix sum of the tile just before the considered interval.\\n\\n**O(n * m) time, O(n * m) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\\n\\n**O(n * m) time, O(n) space solution:**\\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> dp(carpets + 1, vector<int>(n + 1, 0));\\n\\t\\tfor (int c = 1; c <= carpets; c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[c][i] = max(dp[c][i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dp[c - 1][i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\treturn pre[n] - dp[carpets][n];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint minimumWhiteTiles(string floor, int carpets, int len) {\\n\\t\\tint n = (int)floor.size();\\n\\t\\tif (carpets * len >= n) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvector<int> pre(n + 1, 0); // number of white tiles\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tpre[i] = pre[i - 1] + (int)(floor[i - 1] == \\'1\\');\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>> vec(2, vector<int>(n + 1, 0));\\n\\t\\tvector<int>& dp = vec[0];\\n\\t\\tvector<int>& dx = vec[1];\\n\\t\\tfor (int c = 1; c <= carpets; swap(dp, dx), c++) {\\n\\t\\t\\tfor (int i = c * len; i <= n - (carpets - c) * len; i++) {\\n\\t\\t\\t\\tdp[i] = max(dp[i - 1],\\n\\t\\t\\t\\t\\tpre[i] - pre[i - len] + dx[i - len]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn pre[n] - dx[n];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498730,
                "title": "dp-recursion-simple",
                "content": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }\\n           \\n        if(dp[i][j]!= -1) return dp[i][j];\\n        int x= sol(i+l, j+1,v,f);\\n        int y= sol(i+1,j, v,f );\\n        if(f[i]==\\'1\\') y++;\\n   //     cout<<i<<\" \"<<j<<\" \"<<x<<\" \"<<y<<\"\\\\n\";\\n        return dp[i][j]= min(x,y);\\n    }\\npublic:\\n    int minimumWhiteTiles(string f, int numCarpets, int carpetLen) {\\n        n=f.size();\\n        m=numCarpets;\\n        l=carpetLen;\\n     //   cout<<n<<\" \"<<m<<\"\\\\n\";\\n        dp.resize(n, vector<int>(m+1,-1));\\n        vector<int> v;\\n        int b=0;\\n        for(auto i:f)\\n        {\\n           b+= i-\\'0\\';\\n            v.push_back(b);\\n        }\\n        return  sol(0,0,v,f);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int n,m,l;\\n     vector<vector<int>>dp;\\n    int sol(int i, int j, vector<int>&v ,string& f)\\n    {\\n          if(i>= n) return 0;\\n          if(j>=m)\\n          {\\n              if(i==0) return v.back();\\n              return v.back()- v[i-1];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2342212,
                "title": "java-easy-solution-explained",
                "content": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int f(char[] arr,int i,int n,int len,int[] whites,int dp[][])\\n    {\\n        if(i>=arr.length||n==0)//outofbounds\\n        {\\n            return 0;\\n        }\\n        if(dp[i][n]!=-1)\\n        {\\n            return dp[i][n];\\n        }\\n        if(arr[i]==\\'0\\')//black\\n        {\\n            return dp[i][n]=f(arr,i+1,n,len,whites,dp);//skip\\n        }\\n        //boundary check\\n        int l=Math.min(i+len,arr.length)-1;//if white,get the min index after add carpte\\'s len\\n        int white=whites[l];\\n        if(i!=0)\\n        {\\n            white-=whites[i-1];//if i==0 no need to diff for white tiles\\n        }\\n        int pick=white+f(arr,i+len,n-1,len,whites,dp);// either pick ->white tile+after effect of putting carpet\\n        int nopick=f(arr,i+1,n,len,whites,dp);// not picking skipping\\n        return dp[i][n]=Math.max(pick,nopick);//getting max of both\\n    }\\n    public int minimumWhiteTiles(String floor, int n, int len) {\\n        int whites[]=new int[floor.length()];//prefix sum of whites\\n        int dp[][]=new int[floor.length()+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                dp[i][j]=-1;   \\n            }\\n        }\\n        char arr[]=floor.toCharArray();\\n        whites[0]=(arr[0]==\\'1\\'?1:0);// prefix sum of whites 0th ele may or maynot be white in case..\\n        for(int i=1;i<arr.length;i++)\\n        {\\n            whites[i]=whites[i-1]+(arr[i]==\\'1\\'?1:0);//prefix sum\\n        }\\n        if(whites[floor.length()-1]==0)// after prefix sum the last ele is 0 then no whites at all return 0 simply\\n        {\\n            return 0;\\n        }\\n        return whites[floor.length()-1]-f(arr,0,n,len,whites,dp);// no.of whites required-> so total whites-used white tiles\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291254,
                "title": "java-from-tle-to-ac-both-dp",
                "content": "First up, the naive DP solution. \\n\\nThe idea is simple - let `dp[i][j] be the min white tiles if we use i carpet for subarray 0...j.` \\nFor each carpet, we try to place it at all the location, then we have the transitional state: \\n`dp[i][j] = min(dp[i-1][k-carpetLen]+count) where carpetLen <= k <= j` and count = the number of white tiles between the gap.\\n\\nNeedless to say, it got TLE.\\n```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\\nso we have to come up with something better...\\nThis time we will consider `dp[i][j] = the min white tiles for subarray 0 ... i with j carpets used`\\nthen we should have `dp[i][j] = min(dp[i-1][j]+(1 or 0), dp[i-carpetLen][j-1])`\\nThis works.\\n\\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// TLE\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[] dp = new int[floor.length()];\\n        for (int i = 0; i < floor.length(); i++){\\n            dp[i]=(i==0?0:dp[i-1])+floor.charAt(i)-\\'0\\';\\n        }\\n        for (int i = 1; i <= numCarpets; i++){\\n            for (int j = floor.length()-1; j >= 0; j--){\\n                for (int k = j,cnt=0; k >= carpetLen; k--){\\n                    dp[j]=Math.min(dp[k-carpetLen]+cnt,dp[j]);\\n                    cnt+=floor.charAt(k)-\\'0\\';\\n                }\\n                if (j<carpetLen){\\n                    dp[j]=0;\\n                }\\n            }\\n        }\\n\\n        return dp[floor.length()-1];\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        if (numCarpets*carpetLen>=floor.length()){\\n            return 0;\\n        }\\n        int[][] dp = new int[floor.length()][numCarpets+1];\\n        for (int i = 0; i < floor.length(); i++){\\n            for (int j = 0; j <= numCarpets; j++){\\n                dp[i][j]=Math.min((i==0?0:dp[i-1][j])+floor.charAt(i)-\\'0\\',j==0?1000:i<carpetLen?0:dp[i-carpetLen][j-1]);\\n            }\\n        }\\n        return dp[floor.length()-1][numCarpets];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247732,
                "title": "java-solution-40ms-o-n-space",
                "content": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        char [] tiles = floor.toCharArray();\\n        int n = tiles.length;\\n        \\n        int [] dp = new int[n+1];\\n        \\n        int whiteTiles = 0;\\n        for(int i = 1; i<=n; i++){\\n            if(tiles[i-1]==\\'1\\') whiteTiles++;\\n            dp[i] = whiteTiles;\\n        }\\n        \\n        for(int i = 1; i<=numCarpets; i++){\\n            int [] temp = new int[n+1];\\n            for(int j = 1; j<=n; j++){\\n                temp[j] = tiles[j-1]==\\'0\\' ? temp[j-1] : Math.min(dp[Math.max(j-carpetLen, 0)], 1+temp[j-1]);\\n            }\\n            dp = temp;\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240116,
                "title": "linear-time-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        vector<int> dp(n,  0), ndp(n, 0);\\n        for(int i = 0; i < n; i++) {\\n            dp[i] = (i ? dp[i-1] : 0) + floor[i] - \\'0\\';\\n        }\\n        for(int i = 1; i <= numCarpets; i++) {\\n            for(int j = 0; j < n; j++) {\\n                ndp[j] =  (j ? ndp[j-1]: 0) + floor[j] - \\'0\\';\\n                ndp[j] = (j < carpetLen) ? 0 : min(ndp[j], dp[j - carpetLen]);\\n            }\\n            dp = ndp;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172666,
                "title": "python-dp-prefix-sum-with-thought-process-on-optimization-when-being-asked-during-interviews",
                "content": "### Dynamic Programming + Prefix Sum\\nNote this problem is not greedy, so you get wrong answer if you get the interval for consective `1`, sort them and greedly put carpets from the longest interval. \\nBesides, this one is not a sliding window problem either. Try with this example `111010111` with `2` carpets with length of `3`. \\nThen we need iterate every possible layout with each floor, which denotes to dynamic programming.\\nFirst, let\\'s simplify the solution without optimzation. We use `dp[f][c]` represent the number of white tiles visible, and for each floor `f`, we have 2 options, put one carpet or not, which recall you the backpack problems. If we decide to put one carpet, then the result is `dp[f + length][c - 1]`, otherwise `dp[f + 1][c]`. Then we return the minimum one.\\n\\nSecondly, let\\'s observe the base case.\\n```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\\nFinally, let\\'s put `memoziation` on the recursive function. It looks working, but we got `TLE`. \\n\\nAlright, let\\'s optimize it. \\nFirst of all, if current `f` is black tile, we don\\'t need to cover with carpet, so we can just return `dp[f + 1][c]` if `floor[f] == \\'0\\'`.\\nSecondly, if the total length of carpet is longer than the floor, we can cover the entire floor, then the answer is `0`.\\nThridly, the time we count the remaining white tiles is linear, can we quickly get the number of white tiles given a range? prefix sum is the answer.\\n\\nLet\\'s put it all together!\\n\\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```\\n\\n*Time Complexity*= **O(NC)**, N means the length of floor, the C means the number of tiles.\\n*Space Complexity* = **O(NC)**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n* f == n: no more floor to cover, return 0\\n* c == 0: no more tiles to use, return the number of white tiles remaining \\n```\n```python\\ndef minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\tn = len(floor)\\n\\tpre = [0]\\n\\tfor c in floor:\\n\\t\\tpre.append(pre[-1] + int(c))\\n        \\n\\t@cache\\n\\tdef helper(f, c):\\n\\t\\tif f >= n or c * carpetLen >= n - f:\\n\\t\\t\\treturn 0\\n\\t\\tif c == 0:\\n\\t\\t\\treturn pre[-1] - pre[f]\\n\\t\\tif floor[f] == \\'0\\':\\n\\t\\t\\treturn helper(f + 1, c)\\n\\t\\treturn min(1 + helper(f + 1, c), helper(f + carpetLen, c - 1))\\n\\treturn helper(0, numCarpets)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146064,
                "title": "java-o-m-n-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        int[][] dp = new int[floor.length()+1][numCarpets+1]; // minium while tile at ith position using j carpets\\n        int num = 0;\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            \\n            for (int j = 0; j < dp[i].length; j++) {\\n                if (i == 0) dp[i][j] = 0;\\n                else dp[i][j] = Integer.MAX_VALUE/2;\\n            }\\n            \\n            if (i >= 1 && floor.charAt(i-1) == \\'1\\') num++;\\n            dp[i][0] = num;\\n        }\\n        \\n        \\n        \\n      \\n        for (int i = 1; i < dp.length; i++) {\\n            for (int j = 1; j<= numCarpets; j++) {\\n              \\n                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + (floor.charAt(i-1) ==\\'1\\'?1:0)); //carpet not cover ith tile\\n                \\n                dp[i][j] = Math.min(dp[i][j], (i >= carpetLen)? dp[i-carpetLen][j-1]:0); // carpet cover ith tile\\n                \\n                \\n\\n                \\n            }\\n        }\\n        \\n        return dp[dp.length-1][numCarpets];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077907,
                "title": "python-top-down-approach-dp-with-prefix-sum",
                "content": "We can approach this problem using dynamic programming. Before we dive into the details of the implementation, however, let us try and grasp the intution underlying this method.\\n\\nIf we scan the string from left to right, we can make a few observations:\\n1. At each index of the string, `idx`, if we only consider the first `idx` indices, we can maintain a count of the minimum number of ones in the string if we only tile that \"window\" or substring of the original floor.\\n2. At each index, we have a choice to make -- we can either place a tile (ending at `idx` and starting at index `idx - carpetLen + 1`) or not place a tile\\n\\nIn the second case, consider each path we can take. If we do not place a tile, then we simply have more tiles left to tile the remaining floor (i.e. indices preceding `idx` from `0` to `idx - 1`, inclusive), but we may fail to cover an available tile if `floor[idx] == \\'1\\'`. If we do place a tile, then we have less tiles left to tile the remaining floor, but we are guaranteed to cover everything from `idx - carpetLen + 1` to `idx`. \\n\\nFrom here, we arrive at our dynamic programming relation, where `dp(idx, n)` represents the minimum number of remaining available tiles from indices `0` to `idx` using `n` pieces of carpet. \\n- if we the carpet we have remaining `n * carpetLen` is at least the number of available tiles, then we will not have any tiles remaining, since we can cover all tiles\\n- if we have no more carpet remaining, (i.e. `n == 0`), then we cannot tile any more pieces of the floor, so we simply return the number of available tiles preceding and including `idx`\\n- otherwise, we consider the optimal choice out of our two aforementioned cases (i.e. `dp(idx, n) = min(dp(idx - carpetLen, n - 1), dp(idx - 1, n) + floor[idx])`\\n\\nNow that we have set up this recurrence, we can use a top down dynamic programming approach to maintain intermediate results and assist in our final computation of `dp(len(floor) - 1, numCarpets)`. To calculate the number of available tiles in a given range of `floor` in constant time, a prefix sum array was built and used.\\n\\nThis method runs in `O(numCarpets * len(floor))` time, since we are able to cache intermediate results and uses `O(numCarpets * len(floor))` space.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        prefix = [0] * (len(floor) + 1)\\n        for i in range(1, len(prefix)):\\n            prefix[i] = 1 + prefix[i - 1] if floor[i - 1] == \\'1\\' else prefix[i - 1]\\n        def ones(i, j):\\n            return prefix[j + 1] - prefix[i]\\n        @cache\\n        def dp(idx, n):\\n            if n * carpetLen >= idx + 1:\\n                return 0\\n            if idx == 0:\\n                return ones(0, 0)\\n            if n == 0:\\n                return ones(0, idx)\\n            return min(dp(idx - carpetLen, n - 1), \\n                           dp(idx - 1, n) + ones(idx, idx))\\n        return dp(len(floor) - 1, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055688,
                "title": "c-2d-dp-few-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = (int)floor.length();\\n        if(numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int>(numCarpets + 1));\\n        for(int i = 0; i <= n; ++i)\\n        {\\n            for(int j = 0; j <= numCarpets; j++)\\n            {\\n                if(i == 0 and j == 0){\\n                    dp[i][j] = 0;\\n                }else if(i == 0){\\n                    dp[i][j] = 0;\\n                }else if(j == 0){\\n                    dp[i][j] = dp[i-1][j] + ((floor[i-1] == \\'1\\') ? 1 : 0);\\n                }else{\\n                    if(floor[i-1] == \\'0\\'){\\n                        dp[i][j] = dp[i-1][j];\\n                    }else{\\n                        dp[i][j] = (i - carpetLen < 0) ? 0 : dp[i-carpetLen][j-1];\\n                        dp[i][j] = min(dp[i][j], 1 + dp[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053240,
                "title": "top-down-approach-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }\\n        else return dp[k][idx]=solve(s,k,l,idx+1);\\n        return dp[k][idx]=INT_MAX;\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(floor,numCarpets,carpetLen,0);\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[1005][1005];\\n    int solve(string &s,int k,int l,int idx){\\n        if(idx>=s.size()&&k>=0)return 0;\\n        if(k<0)return INT_MAX;\\n        if(dp[k][idx]!=-1)return dp[k][idx];\\n        if(s[idx]==\\'1\\'){\\n            return dp[k][idx]=min(1+solve(s,k,l,idx+1),solve(s,k-1,l,idx+l));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2028180,
                "title": "c-easy-bottom-up-2d-dp",
                "content": "Approach / Ideas:\\n2D DP:\\nLet f[i][j] represent the min # of while tiles remaining in floor[0..i]\\nafter applying j carpets.\\nlet z be the carpet length, and c be numCarpets.\\nThen we have:\\nf[i][j] is the min of:\\n (a) f[i-1][j], if floor[i] is not white.\\n otherwise:\\n (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n\\n```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2D DP:\\n// Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n// after applying j carpets.\\n// let z be the carpet length, and c be numCarpets.\\n// Then we have:\\n// f[i][j] is the min of:\\n//  (a) f[i-1][j], if floor[i] is not white.\\n//  otherwise:\\n//  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n//  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n//\\n// TODO: Use two rolling dp-rows to reduce space complexity to O(n) from O(n*c).\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(const string& floor, int numCarpets, int carpetLen) {\\n        const int n = floor.size();\\n        const int c = numCarpets;\\n        const int z = carpetLen;\\n\\n        // enough carpets to cover all tiles?\\n        if (c * z >= n) {\\n            return 0; // all tiles, including white tiles, are covered by carpets.\\n        }\\n\\n        // prefix sum for counting the white tiles in O(1) time by using O(n) space.\\n        vector<int> prefixSum(n);\\n        {\\n            prefixSum[0] = floor[0] == \\'1\\' ? 1 : 0;\\n            for (int i = 1; i < n; ++i) {\\n                prefixSum[i] = prefixSum[i - 1] + (floor[i] == \\'1\\' ? 1 : 0);\\n            }\\n        }\\n\\n        // enough carpets for all white tiles?\\n        if (prefixSum.back() <= c) {\\n            return 0;\\n        }\\n        // Let f[i][j] represent the min # of while tiles remaining in floor[0..i]\\n        // after applying j carpets.\\n        // let z be the carpet length, and c be numCarpets.\\n        vector<vector<int>> f(n, vector<int>(c + 1, n + 1));\\n        // initialize f[0][...]\\n        f[0][0] = prefixSum[0];\\n        for (int j = 1; j <= c; ++j) {\\n            f[0][j] = 0; // one carpet is enough to cover the first tile\\n        }\\n\\n        // General case\\n        // f[i][j] is the min of:\\n        //  (a) f[i-1][j], if floor[i] is not white.\\n        //  otherwise:\\n        //  (b) f[i-z][j-1], when use 1 carpet to cover floor[i-z+1...i]\\n        //  (c) 1 + f[i-1][j],  when we deliberately don\\'t cover [i].\\n        for (int i = 1; i < n; ++i) {\\n            f[i][0] = prefixSum[i];\\n            for (int j = 1; j <= c; ++j) {\\n                if (IsWhiteTile(floor, i)) {\\n                    // (i-z) is the pos before the carpet whose right-side is at [i].\\n                    f[i][j] =\\n                            min(i - z >= 0 ? f[i - z][j - 1] : 0, //\\n                                1 + f[i - 1][j]);\\n                } else { // black tile --> no need to cover with carpet\\n                    f[i][j] = f[i - 1][j];\\n                }\\n            }\\n        }\\n        return f[n - 1][c];\\n    }\\n\\nprivate:\\n    static inline bool IsWhiteTile(const string& floor, int i) {\\n        return floor[i] == \\'1\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013213,
                "title": "c-90-dp-time-o-mn-space-o-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(\\n        string floor, \\n        int n,\\n        int k\\n    ) {\\n        int m = floor.size();\\n        if (n * k >= m) return 0;\\n        \\n        vector<int> ps(m+1);\\n        for (int i = 1; i <= m; ++i)\\n            ps[i] = ps[i-1] + (floor[i-1] == \\'1\\');\\n        \\n        vector<int> dp, dq;\\n        dp = ps;\\n        for (int i = 1; i <= n; ++i) {\\n            dq.assign(m+1, 0);\\n            for (int j = i*k+1; j <= m; ++j) {\\n                dq[j] = min(\\n                    dq[j-1]+(floor[j-1]==\\'1\\'),\\n                    dp[j-k]\\n                );\\n            }\\n            dp = dq;\\n        }\\n        \\n        return dp[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007330,
                "title": "c-dp-bottom-up-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int i, j;\\n        const int inf = 1001;\\n        int len = floor.length();\\n        vector<vector<int>> dp(len + 1, vector<int> (numCarpets + 1, inf));\\n        \\n        // Base Cases\\n        for(i = 0; i <= numCarpets; i++){\\n            dp[0][i] = 0;\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            dp[i][0] = dp[i - 1][0] + (floor[i - 1] == \\'1\\' ? 1 : 0);\\n        }\\n        \\n        for(i = 1; i <= len; i++){\\n            for(j = 1; j <= numCarpets; j++){\\n                int isWhiteTile = floor[i - 1] == \\'1\\' ? 1 : 0;\\n                \\n                dp[i][j] = dp[i - 1][j] + isWhiteTile;\\n                \\n                if(i - carpetLen >= 0){\\n                    dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]);\\n                }\\n                else{\\n                    dp[i][j] = min(dp[i][j], dp[0][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[len][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986971,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n\\t\\t\\n\\t\\t#prefix sum of white tiles till now\\n        f = [0] * (n+1)\\n        for i in range(1, n+1):\\n            f[i] += f[i-1]\\n            if floor[i-1] == \\'1\\':\\n                f[i] += 1\\n\\t\\t\\n\\t\\t#dp over each index for different no. of tiles\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            for j in range(1,numCarpets+1):\\n                prevIdx = max(0, i-carpetLen)\\n                newCoverage = f[i]-f[prevIdx] + dp[prevIdx][j-1]\\n                dp[i][j] = max(dp[i-1][j], newCoverage)\\n\\t\\t\\t\\t\\n        return f[n] - dp[n][numCarpets]",
                "codeTag": "Java"
            },
            {
                "id": 1972034,
                "title": "java-bottom-up-dp-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int len = floor.length();\\n        int[][] dp = new int[numCarpets + 1][len+1];\\n        int[] prefix = new int[len];\\n        int tiles = 0, total = 0;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            tiles += floor.charAt(i) - \\'0\\'; // calculate total no of Tiles within the Carpet Length Window\\n            if(i - carpetLen >= 0) // start excluding tiles which are not in the Range anymore of the Carpet Length given\\n                tiles -= floor.charAt(i - carpetLen) - \\'0\\'; \\n            prefix[i] = tiles; // the total no of tiles covered within the Carpet Length range for current index\\n            total += floor.charAt(i) - \\'0\\';\\n        }\\n            \\n        for(int i = 1; i <= numCarpets; i++)\\n        { \\n            for(int j = 0; j < len; j++)\\n            {\\n                int doNot = dp[i][j]; // if we do not wish to cover current Tile\\n                int doTake = dp[i-1][Math.max(0, j - carpetLen + 1)] + prefix[j]; // if we do wish to cover current tile\\n                // we should go back the Carpet length & check for tiles not covered before j - carpet Length distance\\n                dp[i][j + 1] = Math.max(doTake, doNot);\\n            }\\n        }\\n        \\n        return total - dp[numCarpets][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940507,
                "title": "python3-dp-beats-100",
                "content": "Standard DP solution with a few optimizations:\\n* We will never lay a carpet starting on a black tile. We could defer laying the carpet and cover the same or more white tiles.\\n* If the next carpetLen tiles are all white, we will always lay a carpet.\\n\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        whiteTileSegment = \\'1\\' * carpetLen\\n        \\n        # Minimum white tiles shown on tile i..len(tiles)-1 with n carpets.\\n\\t\\t@cache\\n        def dp(i, n):\\n\\t\\t    # No tiles remain.\\n            if i >= len(floor):\\n                return 0\\n            # No carpets remain, return the count of remaining white tiles.\\n            if n == 0:\\n                return floor[i:].count(\\'1\\')\\n            # Tile i is black, we will never lay a carpet starting on a black tile.\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, n)\\n            # There is enough carpet left to cover all remaining tiles.\\n            if len(floor) - i < n * carpetLen:\\n                return 0\\n            # The next carpetLen tiles are all white, we will always lay a carpet here.\\n            if floor[i:i + carpetLen] == whiteTileSegment:\\n                return dp(i + carpetLen, n - 1)\\n            \\n            dontLayCarpet = 1 + dp(i + 1, n)\\n            layCarpet = dp(i + carpetLen, n - 1)\\n            return min(dontLayCarpet, layCarpet)\\n                  \\n        return dp(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916981,
                "title": "very-simple-dp-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    \\n    private int[] suffix=new int[1002];\\n    \\n    private void generateSuffixArray(String floor){\\n        int c=0;\\n        for(int i=0;i<floor.length();i++){\\n            if(floor.charAt(i) == \\'1\\')\\n                c++;\\n            suffix[i]=c;\\n        }\\n    }\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        \\n        generateSuffixArray(floor);\\n        int arr[][]=new int[numCarpets+1][floor.length()];\\n        \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr[i].length;j++){\\n                if(i==0)\\n                    arr[i][j]=0;\\n                else{\\n                    arr[i][j]=suffix[j];\\n                    if(j-carpetLen >=0)\\n                        arr[i][j]=arr[i][j]-suffix[j-carpetLen]+arr[i-1][j-carpetLen];\\n                    if(j-1>=0)\\n                        arr[i][j]=Math.max(arr[i][j-1],arr[i][j]);\\n                }\\n\\n            }\\n\\n        }\\n        \\n        return suffix[floor.length()-1]-arr[numCarpets][floor.length()-1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914589,
                "title": "easy-to-understand-dp",
                "content": "The idea is simple to use DP and memoization to maintain the number of covered tiles at an index i with k remaining carpets.\\n\\n```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumWhiteTiles = function(floor, numCarpets, carpetLen) {\\n    let answer = Number.MAX_SAFE_INTEGER, dp = {};\\n    \\n    floor = floor.split(\\'\\');\\n    \\n    function findMaxCoveredTiles(index, carpetsLeft) {\\n        if(index >= floor.length) {\\n            return 0;\\n        }\\n        if(dp[index]) {\\n            if(dp[index][carpetsLeft] != undefined) {\\n                return dp[index][carpetsLeft];\\n            }\\n        }\\n        else {\\n            dp[index] = {};\\n        }\\n        \\n        dp[index][carpetsLeft] = Number.MIN_SAFE_INTEGER;\\n        if(carpetsLeft) {\\n            dp[index][carpetsLeft] = Math.min(carpetLen, floor.length - index) + findMaxCoveredTiles(index + carpetLen, carpetsLeft - 1);\\n        }\\n\\n        dp[index][carpetsLeft] = Math.max(dp[index][carpetsLeft], !+floor[index] + findMaxCoveredTiles(index + 1, carpetsLeft));\\n        \\n        return dp[index][carpetsLeft];\\n    }\\n    \\n    return floor.length - findMaxCoveredTiles(0, numCarpets);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1907291,
                "title": "golang-search-with-memoization",
                "content": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n    memo := make([][]int, len(floor))\\n    for i := 0; i < len(memo); i++ {\\n        memo[i] = make([]int, numCarpets + 1)\\n        for j := 0; j < len(memo[i]); j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    return dfs(floor, numCarpets, carpetLen, 0, memo)\\n}\\n\\nfunc dfs(floor string, carp int, size int, pos int, memo [][]int) int {\\n    if pos >= len(floor) {\\n        return 0\\n    }\\n    \\n    if memo[pos][carp] != -1 {\\n        return memo[pos][carp]\\n    }\\n    \\n    res := 0\\n    if floor[pos] == \\'0\\' {\\n        res = dfs(floor, carp, size, pos + 1, memo)\\n    } else {\\n        res = 1 + dfs(floor, carp, size, pos + 1, memo)\\n        if carp > 0 {\\n            res = min(res, dfs(floor, carp - 1, size, pos + size, memo))\\n        }\\n    }  \\n    \\n    memo[pos][carp] = res\\n    \\n    return res\\n}\\n\\nfunc min(a int, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906286,
                "title": "java-top-down-dp-with-greedy-beats-91-43",
                "content": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy"
                ],
                "code": "```\\n    /*\\n    TLE without the \"allWhite\" check. Otherwise,\\n\\n    Runtime: 89 ms, faster than 91.43% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n    Memory Usage: 48.9 MB, less than 89.69% of Java online submissions for Minimum White Tiles After Covering With Carpets.\\n     */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int[][] cache = new int[floor.length()][numCarpets + 1];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        char[] colors = floor.toCharArray();\\n        return minimumWhiteTiles(colors, numCarpets, carpetLen, 0, cache);\\n    }\\n\\n    private int minimumWhiteTiles(char[] colors, int numCarpets, int carpetLen, int ind, int[][] cache) {\\n        if (numCarpets * carpetLen >= colors.length - ind) {\\n            return 0;\\n        }\\n\\n        if (cache[ind][numCarpets] != -1) {\\n            return cache[ind][numCarpets];\\n        }\\n\\n        if (numCarpets == 0) {\\n            int remainingWhite = 0;\\n            for (int i = ind; i < colors.length; i++) {\\n                if (colors[i] == \\'1\\') {\\n                    remainingWhite++;\\n                }\\n            }\\n            cache[ind][numCarpets] = remainingWhite;\\n            return remainingWhite;\\n        }\\n\\n        int white = 0;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = ind; i < colors.length; i++) {\\n            if (colors[i] == \\'1\\') { // Greedy\\n                min = Math.min(min, white + minimumWhiteTiles(colors, numCarpets - 1, carpetLen, i + carpetLen, cache));\\n                white++;\\n\\n                // Greedy\\n                if (allWhite(colors, i, carpetLen)) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        min = min == Integer.MAX_VALUE ? 0 : min;\\n        cache[ind][numCarpets] = min;\\n\\n        return min;\\n    }\\n\\n    private boolean allWhite(char[] colors, int ind, int carpetLen) {\\n        for (int j = 0; j < carpetLen && ind + j < colors.length; j++) {\\n            if (colors[ind + j] == \\'0\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903622,
                "title": "golang-dp-solution",
                "content": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc minimumWhiteTiles(floor string, numCarpets int, carpetLen int) int {\\n\\tblack, white := byte(\\'0\\'), byte(\\'1\\')\\n\\t_ = black\\n\\t_ = white\\n\\tif numCarpets*carpetLen >= len(floor) {\\n\\t\\treturn 0\\n\\t}\\n\\tdpMask := make([][]int, len(floor))\\n\\tfor i := range dpMask {\\n\\t\\tdpMask[i] = make([]int, numCarpets+1)\\n\\t}\\n\\tif floor[0] == white {\\n\\t\\tfor i := 1; i < len(dpMask[0]); i++ {\\n\\t\\t\\tdpMask[0][i] = 1\\n\\t\\t}\\n\\t}\\n\\twhiteHelper := make([]int, len(floor)+1)\\n\\tfor i := range floor {\\n\\t\\twhiteHelper[i+1] = whiteHelper[i]\\n\\t\\tif floor[i] == white {\\n\\t\\t\\twhiteHelper[i+1]++\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < len(floor); i++ {\\n\\t\\tfor carpets := 1; carpets <= numCarpets; carpets++ {\\n\\t\\t\\tdpMask[i][carpets] = dpMask[i-1][carpets]\\n\\t\\t\\tif i < carpetLen {\\n\\t\\t\\t\\tdpMask[i][carpets] = whiteHelper[i+1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttempWhiteMask := whiteHelper[i+1] - whiteHelper[i+1-carpetLen] + dpMask[i-carpetLen][carpets-1]\\n\\t\\t\\t\\tif tempWhiteMask > dpMask[i][carpets] {\\n\\t\\t\\t\\t\\tdpMask[i][carpets] = tempWhiteMask\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn whiteHelper[len(whiteHelper)-1] - dpMask[len(dpMask)-1][numCarpets]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901600,
                "title": "python3-clear-top-down-greedy-dp-solution",
                "content": "The greedy strategy is that we always want to make the decision whether or not to start tiling at an indice with an element \\'1\\'. Then, we can apply memoization.\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, n: int, l: int) -> int:\\n        m = len(floor)\\n        \\n        @lru_cache(None)\\n        def dp(i, used):\\n            if i >= m:\\n                return 0\\n            if used < 1:\\n                return dp(i + 1, used) + (1 if floor[i] == \\'1\\' else 0)\\n            if used * l >= m - i:\\n                return 0\\n            if floor[i] == \\'0\\':\\n                return dp(i + 1, used)\\n            return min(dp(i + l, used - 1), dp(i + 1, used) + 1)\\n        \\n        res = dp(0, n)\\n        dp.cache_clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899559,
                "title": "dp-prefix-sum-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int clen;\\n    \\n    vector<int> prefix;\\n    \\n    int dp[1001][1001];\\n    \\n    int helper(string floor, int idx, int numc){\\n        \\n        //cout << idx << \" \" << numc << endl;\\n        \\n        int n = floor.size();\\n        \\n        if(numc == 0 || idx >= n) return 0;\\n        \\n        if(dp[idx][numc] != -1) return dp[idx][numc];\\n        \\n        if(floor[idx] == \\'0\\') return dp[idx][numc] = helper(floor, idx+1, numc);\\n        \\n        int res = INT_MIN;\\n    \\n        int tillIdxCover = min(n, idx+clen);\\n        int tilesCovered = prefix[tillIdxCover-1] - prefix[idx]+1;\\n        \\n        res = max(res, tilesCovered +helper(floor, tillIdxCover, numc-1));\\n        \\n        if(tilesCovered == clen) return dp[idx][numc] = res;\\n        \\n        res = max(res, helper(floor, idx+1, numc));\\n            \\n        return dp[idx][numc] = res;\\n \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        int n = floor.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        clen = carpetLen;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0;i<floor.size();i++){\\n            if(floor[i] == \\'1\\') cnt++;\\n            prefix.push_back(cnt);\\n        }\\n        \\n        if(cnt == 0) return 0;\\n        \\n        return cnt-helper(floor, 0, numCarpets);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1897112,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n = floor.size();\\n        if (numCarpets * carpetLen >= n) return 0;\\n        vector<vector<int>> dp(n + 1, vector<int> (numCarpets + 1, INF));\\n        int white = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (floor[i] == \\'1\\') {\\n                ++white;\\n            }\\n            dp[i + 1][0] = white;\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int k = 0; k <= numCarpets; k++) {\\n                if (floor[i] == \\'0\\') {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k]);\\n                }\\n                else {\\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][k] + 1);\\n                }\\n                if (i + carpetLen <= n && k + 1 <= numCarpets) {\\n                    dp[i + carpetLen][k + 1] = min(dp[i + carpetLen][k + 1], dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[n][numCarpets];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896751,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        int minimumWhiteTiles(string s, int numCarpets, int carpetLen) {\\n        vector<int> floor(carpetLen * (s.size() / carpetLen + (s.size() % carpetLen != 0)) + 1);\\n        for (int i = 1; i < floor.size(); ++i) {\\n            floor[i] = floor[i - 1] + (i <= s.size() ? s[i - 1] - \\'0\\' : 0);\\n        }\\n        \\n        int res = 0;\\n        vector<vector<int>> maxWhite(numCarpets + 1, vector<int>(floor.size()));\\n        for (int i = 1; i <= numCarpets; ++i) {\\n            for (int j = carpetLen * i; j < floor.size(); ++j) {\\n                maxWhite[i][j] = maxWhite[i][j - 1];\\n                maxWhite[i][j] = max(maxWhite[i][j], maxWhite[i - 1][j - carpetLen] + floor[j] - floor[j - carpetLen]);\\n                res = max(res, maxWhite[i][j]);\\n            }\\n        }\\n\\n        return floor.back() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896494,
                "title": "c-very-simple-solution",
                "content": "ON EVERY TIILE WE HAVE TO CHOICES \\nEITHER TO PUT THE CARPET OR MOVE AHEAD\\nWRITE THIS IN RECURRSION\\n```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solver(string & floor,int nc,int cl,int i,int n,int dis[],vector<vector<int>>&dp)\\n    {\\n        \\n        \\n        if(i==0|| nc==0)\\n            return 0;\\n      \\n        if(dp[i][nc]!=-1)\\n            return dp[i][nc];\\n        \\n        int k=dis[i]-dis[max(0,i-cl)];\\n        \\n        int ans=0;\\n        ans=max(ans,solver(floor,nc-1,cl,max(0,i-cl),n,dis,dp)+k);\\n        ans=max(ans,solver(floor,nc,cl,i-1,n,dis,dp));\\n        \\n        \\n        \\n        return dp[i][nc]=ans;\\n        \\n        \\n    }\\n    int minimumWhiteTiles(string floor, int nc, int cl) {\\n        \\n        int n=floor.length();\\n        int dis[n+1];\\n        vector<vector<int>>dp(n+1,vector<int>(nc+1,-1));\\n        int total=0;\\n      \\n        dis[0]=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(floor[i-1]==\\'1\\')\\n            {\\n                total++;\\n                dis[i]=dis[i-1]+1;\\n            }\\n            else\\n                dis[i]=dis[i-1];\\n        }\\n        \\n        \\n      \\n        return total-solver(floor,nc,cl,n,n,dis,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894976,
                "title": "c-dp-memo-prefix-sum",
                "content": "\\tclass Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }\\n    }\\n    \\n    int memo(int i, int used, string &s, int n, int nc, int l, vector<vector<int>> &dp, vector<int> &pre) {\\n        \\n        if(i >= n || nc == used)\\n            return 0;\\n        \\n        if(dp[i][used] != -1)\\n            return dp[i][used];\\n        \\n        if(s[i] == \\'0\\')\\n            dp[i][used] = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        else {\\n            int ind = min(i + l - 1, n - 1);\\n            int ans = pre[ind];\\n            if(i > 0)\\n                ans -= pre[i - 1];\\n        \\n            int include = memo(i + l, used + 1, s, n, nc, l, dp, pre);\\n            int exclude = memo(i + 1, used, s, n, nc, l, dp, pre);\\n        \\n            dp[i][used] = max(include + ans, exclude);\\n        }\\n        \\n        return dp[i][used];\\n    }\\n    \\n\\tpublic:\\n    int minimumWhiteTiles(string s, int nc, int l) {\\n        \\n        int n = s.length();\\n        vector<int> pre(n, 0);\\n        fillPrefix(pre, s, n);\\n        \\n        if(pre[n - 1] == 0)\\n            return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (nc, -1));\\n        return pre[n - 1] - memo(0, 0, s, n, nc, l, dp, pre);\\n    }\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n    void fillPrefix(vector<int> &pre, string &s, int n) {\\n        \\n        int p = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'1\\')\\n                p++;\\n            \\n            pre[i] = p;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1889341,
                "title": "c-dp-solution-bottom-up",
                "content": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            public int MinimumWhiteTiles(string floor, int numCarpets, int carpetLen)\\n            {\\n                int[,] m = new int[floor.Length + 1, numCarpets + 1];\\n                int count = 0;\\n\\n                //Setup first column when there is no carpets available.  \\n                for (int r = floor.Length - 1; r >= 0; r--)\\n                {\\n                    if (floor[r] == \\'1\\')\\n                    {\\n                        count++;\\n                        m[r, 0] = count;\\n                    }\\n                    else\\n                    {\\n                        m[r, 0] = m[r + 1, 0];\\n                    }\\n                }\\n\\n\\t\\t\\t\\t//Looping through each column.  Each column represents the num of available carpets.\\n                for (int c = 1; c <= numCarpets; c++)\\n                {\\n                    for (int r = floor.Length - 1; r >= 0; r--)\\n                    {\\n                        if (floor[r] == \\'0\\')\\n                        {\\n                            m[r, c] = m[r + 1, c];\\n                        }\\n                        else\\n                        {\\n                            //current tile of the floor, the cost of using the carpet.\\n\\t\\t\\t\\t\\t\\t\\t//cost means the minimum num of white tiles visible.\\n                            var a = r + carpetLen <= floor.Length ? m[r + carpetLen, c - 1] : 0;\\n\\n                            //compare it with no carpet at the current tile, Take the smaller one.\\n                            m[r, c] = Math.Min(a, m[r + 1, c] + 1);\\n                        }\\n                    }\\n                };\\n                return m[0, numCarpets];\\n\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888435,
                "title": "c-easy-dp-solution",
                "content": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "here when ever we incounter a white tiles then only we have to make sure have to cover it else we can continue moving over string moreover we have to insure once we incounter white tiles and used carpet to cover it then wee could easely move length of carpet step ahead as it would cover both white and black tiles \\n\\nint f(int i,string& s, int n, int l,vector<vector<int>>& dp)\\n    {\\n        if(i<0 )\\n            return 0;\\n        if(dp[i][n] != -1)\\n            return dp[i][n];\\n        int t=1e8,nt=0;\\n        nt = s[i]-\\'0\\' + f(i-1,s,n,l,dp);\\n        if(n>0 && s[i] == \\'1\\')\\n        t = f(i-l,s,n-1,l,dp);\\n        return dp[i][n] = min(t,nt);\\n    }\\n    \\n    int minimumWhiteTiles(string s, int n, int l) {\\n        \\n        int n1 = s.size();\\n        vector<vector<int>> dp(n1,vector<int>(n+1,-1));\\n        return f(n1-1,s,n,l,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1888259,
                "title": "presum-dp",
                "content": "My thought is very similar to the solution of this problem https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/.\\n\\nDefine dp state:\\n\\n`dp[i][j]: when use i carpet, starting from j-th floor, the maximum covered white tiles.`\\n\\nThe relation between dp states:\\n\\n`dp[i][j] = dp[i-1][j-k] + # of covered white tiles by i-th carpet.`\\n`i-1` is the number of carpet used \\n`j-k` is the maximum possible starting floor for `i-1` floors. (The best strategy is not to overlap the carpets).\\n\\nTo quickly get the # of covered white tiles by i-th carpet, we need to calculate the prefix sum of white tiles.\\n\\n\\nRemember we want to find the maximum covered white tiles.\\nIf after the i-th carpet covered tile starting from position j,\\nthe overall covered white tiles are not better than previous result,\\nprevious result should be used. So we have the following relation:\\n        \\n`dp[i][j] = max(dp[i][j], dp[i][j-1]);`\\n        \\n        \\nExample:\\n```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfloor:\\n1 1 0 0 0 1 0 1 0\\n        \\ncarpet len: 2, num carpets: 1\\n        \\ndp[1] = [2 2 2 2 2 2 2 2 2]\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int m = numCarpets, n = floor.length(), k = carpetLen;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        vector<int> presum(n+1, 0);\\n        floor = \"#\" + floor;\\n        int count = 0;\\n        for(int i=1; i<=n; i++) {\\n            count += (floor[i]-\\'0\\');\\n            presum[i] = presum[i-1]+(floor[i]-\\'0\\');\\n        }\\n        \\n        int ret = count;\\n        for(int i=1; i<=m && ret>0; i++) {\\n            for(int j=(i-1)*k+1; j<=n && ret>0; j++) {\\n                dp[i][j] = (i==1?0:dp[i-1][j-k]) + presum[min(n,j+k-1)] - presum[j-1];\\n                dp[i][j] = max(dp[i][j], dp[i][j-1]);\\n                ret = min(ret, count - dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886286,
                "title": "easy-top-down-knapsack-solution-c",
                "content": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        int n=floor.size();\\n        vector<vector<int>> dp(n+1,vector<int>(numCarpets+1,0));\\n        //Initialising\\n        for(int i=0;i<n;i++){\\n            if(i!=0)\\n            dp[i][0]=dp[i-1][0];\\n            if(floor[i]==\\'1\\'){\\n                dp[i][0]+=1;\\n            }\\n        }\\n        for (int j=1; j<=numCarpets;j++){ \\n            for(int i=0;i<n;i++){\\n                int skipcarpet;\\n                if(i==0)\\n                    skipcarpet=floor[i]==\\'1\\' ? 1 :0;\\n                else\\n                skipcarpet=floor[i]==\\'1\\' ? dp[i-1][j]+1 :dp[i-1][j];\\n                if(i-carpetLen>=0)\\n                dp[i][j]=min(dp[i-carpetLen][j-1], skipcarpet);  // min(usecarpet,skipcarpet)\\n                else \\n                 dp[i][j]=min(0,skipcarpet);\\n            }\\n        }\\n        \\n        return dp[n-1][numCarpets];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886192,
                "title": "python-top-down-passing-no-tle",
                "content": "Simple thing to speed up the code is keep a cached sum of number of white tiles remaining after index `i` so that once we have 0 carpets left it\\'s easy to figure out how many white tiles remain.\\n\\n```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```python\\nfrom functools import cache\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def nums(i):\\n            if i == len(floor):\\n                return 0\\n            return (floor[i] == \\'1\\') + nums(i+1)\\n        @cache\\n        def dfs(i, n):\\n            if i >= len(floor):\\n                return 0\\n            if n == 0:\\n                return nums(i)\\n            if floor[i] == \\'0\\':\\n                return dfs(i+1, n)\\n            return min(1+dfs(i+1, n), dfs(i+carpetLen, n-1))\\n        return dfs(0, numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885527,
                "title": "python-c-dp-solution",
                "content": "Step1 :\\nCalcualte the number of white tiles can be cover if we put a carpet at each position\\nStep2:\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 1\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = 2\\n\\t....\\n\\tCalculte the maximum number of tiles can be covered at each postion for carpet count = carpetLen\\nStep3:\\n\\tTotal while tiles minus maximum tiles can be convered is the final answer\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\\n\\n\\nPython\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> dp(floor.size());\\n        vector<int> cover;\\n        int cnt = 0;\\n        for (int i = 0;i< floor.size();i++){\\n            if (floor[i] == \\'1\\'){\\n                cnt +=1;\\n            }\\n            if (i >= carpetLen && floor[i-carpetLen] == \\'1\\'){\\n                cnt -=1;\\n            }\\n            cover.push_back(cnt);\\n        }\\n        while (numCarpets){\\n            numCarpets--;\\n            vector<int> dp2;\\n            int max_cover = 0;\\n            for (int j = 0;j<floor.size();j++){\\n                if (j >= carpetLen){\\n                    max_cover = max(max_cover,dp[j-carpetLen]);\\n                }\\n                dp2.push_back(max_cover + cover[j]);\\n            }\\n            dp = dp2;\\n        }\\n        int res = 0;\\n        for (auto &c:floor){\\n            res += ( c ==\\'1\\');\\n        }\\n        res -= *max_element(dp.begin(),dp.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        white = sum(c == \\'1\\' for c in floor)\\n        #dp[i] -> the maximum white tiles can be covered at position i\\n        dp = [0]*len(floor)\\n        #cover[i] -> the number of tiles can be covered if put a carpet at position i\\n        cover = []\\n        cnt = 0\\n        #calculate cover[i] (prefix)\\n        for i in range(len(floor)):\\n            if floor[i] == \\'1\\':\\n                cnt += 1\\n            if i >= carpetLen and floor[i-carpetLen] == \\'1\\':\\n                cnt -= 1\\n            cover.append(cnt)\\n        for i in range(numCarpets):\\n            max_cover = 0\\n            dp2 = []\\n            for j in range(len(floor)):\\n                #since (j-carpetLen+1)th ~ (j)th tiles can be cover if a carpet is put a postion j , \\n                #we only need to find the maximum tiles can be cover before positon (j-carpetLen) at the last round\\n                if j >= carpetLen:\\n                    max_cover = max(max_cover,dp[j-carpetLen])\\n                dp2.append(cover[j] + max_cover)\\n            dp = dp2 \\n        return white - max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885460,
                "title": "why-my-swift-code-runs-out-as-tle",
                "content": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```\\n\\nI chaned the code to JS and used the same solution, all test cases were passed.",
                "solutionTags": [],
                "code": "```swft\\nclass Solution {\\n  func minimumWhiteTiles(_ floor: String, _ numCarpets: Int, _ carpetLen: Int) -> Int {\\n    let arr = Array(floor)\\n    var memo: [String: Int] = [:]\\n    func aux(_ index: Int, _ remains: Int) -> Int {\\n      let key = \"\\\\(index)-\\\\(remains)\"\\n      if memo[key] != nil {\\n        return memo[key]!\\n      }\\n      if remains < 0 {\\n        return Int.max\\n      }\\n      if index >= floor.count || remains * carpetLen >= floor.count - index {\\n        return 0\\n      }\\n      if arr[index] == \"0\" {\\n        memo[key] = aux(index + 1, remains)\\n        return memo[key]!\\n      }\\n      memo[key] = min(\\n        aux(index + carpetLen, remains - 1),\\n        1 + aux(index + 1, remains)\\n      )\\n      return memo[key]!\\n    }\\n     return aux(0, numCarpets)\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885216,
                "title": "python-top-down",
                "content": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "solutionTags": [],
                "code": "n = len(floor)\\n        dp = [[0]*(numCarpets+1) for _ in range(n+1)]\\n        for i in range(1, n+1):\\n            dp[i][0] = dp[i-1][0] + (floor[i-1] == \\'1\\')\\n        \\n        for i in range(1, n + 1):\\n            for k in range(1, numCarpets+1):\\n                dp[i][k] = min(dp[max(0, i-carpetLen)][k-1], dp[i-1][k]+(floor[i-1] == \\'1\\'))\\n\\n        return dp[n][numCarpets]",
                "codeTag": "Unknown"
            },
            {
                "id": 1877990,
                "title": "java-top-down-dynamic-programming-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private String floor;\\n    private int[] presum;\\n    /**\\n    1. define state\\n    dp[i][k]\\n    max number of white floor covered starting at index i, with k carpets left\\n    \\n    2. state transition\\n    dp[i][k] = max(\\n                dp[j][k - 1] + coveredWhiteTiles from this used carpet, \\n                the used carpet covers index (j - 1 - carpetLen) to (j - 1), (j - 1 - carpetLen) >= i\\n                  )\\n                  \\n    3. base state\\n    k = 0: dp[i][0] = 0\\n    i >= n: dp[i][k] = 0\\n    \\n    */\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int n = floor.length();\\n        this.floor = floor;\\n        this.presum = new int[n];\\n        int whiteTiles = 0;\\n        for (int i = 0; i < floor.length(); i++) {\\n            char c = floor.charAt(i);\\n            if (c == \\'1\\') {\\n                whiteTiles++;\\n            }\\n            presum[i] = whiteTiles;\\n        }\\n        int maxCovered = dp(0, numCarpets, new int[n][numCarpets + 1], carpetLen);\\n        return whiteTiles - maxCovered;\\n    }\\n    \\n    private int dp(int index, int k, int[][] memo, int len) {\\n        int n = memo.length;\\n        if (index >= n || k <= 0) {\\n            return 0;\\n        }\\n        if (memo[index][k] > 0) {\\n            return memo[index][k];\\n        }\\n        int maxCovered = 0;\\n        for (int j = index; j < n; j++) {\\n            if (floor.charAt(j) == \\'1\\') {\\n                int right = Math.min(n, j + len);\\n                int coveredWhiteTiles = presum[right - 1] - (j - 1 >= 0 ? presum[j - 1] : 0);\\n                if (coveredWhiteTiles > maxCovered) {\\n                    maxCovered = coveredWhiteTiles;\\n                    memo[index][k] = Math.max(memo[index][k], \\n                                          coveredWhiteTiles + \\n                                          dp(right, k - 1, memo, len));\\n                }\\n            }\\n        }\\n        return memo[index][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872004,
                "title": "c-simple-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int get(int i,int k,string &s,int l)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int res=s[i]-\\'0\\'+get(i+1,k,s,l);\\n        if(s[i]==\\'1\\' && k>0)\\n            res=min(res,get(i+l,k-1,s,l));\\n        return dp[i][k]=res;\\n    }\\n    int minimumWhiteTiles(string &s, int k, int l) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return get(0,k,s,l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871574,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `M` be the amount of carpets we are given, each of length `K`.  Then we can use prefix sums `S` to count the amount of `\\'1\\'` within the window `A[i..i + K)`, ie. from `i` inclusive to `i + K` non-inclusive to simulate carpet placements in O(1) time.  Then we have 2 possibilites to consider for each `i`<sup>th</sup> index candidate carpet placement:\\n\\n1. \\u2705 include\\n2. \\uD83D\\uDEAB exclude\\n\\nThus, we try all possibilities, keeping track the `i`<sup>th</sup> index candidate carpet placement and how many carpets we `have` (initially `M`) to formulate the optimal solution as the recursive stack unwinds.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var j = Math.min(i + K, N)\\n            var include = S[i] - S[j] + go(j, have - 1)\\n            var exclude = go(i + 1, have)\\n            return Math.max(include, exclude)\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var m = mutableMapOf<String, Int>()\\n        fun go(i: Int = 0, have: Int = M): Int {\\n            if (i == N || have == 0)\\n                return 0\\n            var k = \"$i,$have\"\\n            if (!m.contains(k)) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + go(j, have - 1)\\n                var exclude = go(i + 1, have)\\n                m[k] = Math.max(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return S[0] - S[N] - go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWhiteTiles(A: String, M: Int, K: Int): Int {\\n        var N = A.length\\n        var S = IntArray(N + 1) { 0 }\\n        for (i in N - 1 downTo 0)\\n            S[i] = (if (A[i] == \\'1\\') 1 else 0) + S[i + 1]\\n        var dp = Array(N + 1) { IntArray(M + 1) { 0 } }\\n        for (have in 1..M) {\\n            for (i in N - 1 downTo 0) {\\n                var j = Math.min(i + K, N)\\n                var include = S[i] - S[j] + dp[j][have - 1]\\n                var exclude = dp[i + 1][have]\\n                dp[i][have] = Math.max(include, exclude)\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M]\\n    }\\n}\\n```\n```\\nlet minimumWhiteTiles = (A, M, K) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let j = Math.min(i + K, N);\\n        let include = S[i] - S[j] + go(j, have - 1),\\n            exclude = go(i + 1, have);\\n        return Math.max(include, exclude);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let go = (i = 0, have = M) => {\\n        if (i == N || !have)\\n            return 0;\\n        let k = `${i},${have}`;\\n        if (!m.has(k)) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + go(j, have - 1),\\n                exclude = go(i + 1, have);\\n            m.set(k, Math.max(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return S[0] - S[N] - go();\\n};\\n```\n```\\nlet minimumWhiteTiles = (A, M, K, m = new Map()) => {\\n    let N = A.length;\\n    let S = Array(N + 1).fill(0);\\n    for (let i = N - 1; 0 <= i; --i)\\n        S[i] = Number(A[i] == \\'1\\') + S[i + 1];\\n    let dp = [...Array(N + 1)].map(_ => Array(M + 1).fill(0));\\n    for (let have = 1; have <= M; ++have) {\\n        for (let i = N - 1; 0 <= i; --i) {\\n            let j = Math.min(i + K, N);\\n            let include = S[i] - S[j] + dp[j][have - 1],\\n                exclude = dp[i + 1][have];\\n            dp[i][have] = Math.max(include, exclude);\\n        }\\n    }\\n    return S[0] - S[N] - dp[0][M];\\n};\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        @cache\\n        def go(i = 0, have = M):\\n            if i == N or not have:\\n                return 0\\n            j = min(i + K, N)\\n            include = S[i] - S[j] + go(j, have - 1)\\n            exclude = go(i + 1, have)\\n            return max(include, exclude)\\n        return S[0] - S[N] - go()\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, A: str, M: int, K: int) -> int:\\n        N = len(A)\\n        S = [0] * (N + 1)\\n        for i in range(N - 1, -1, -1):\\n            S[i] = int(A[i] == \\'1\\') + S[i + 1]\\n        dp = [[0] * (M + 1) for _ in range(N + 1)]\\n        for have in range(1, M + 1):\\n            for i in range(N - 1, -1, -1):\\n                j = min(i + K, N)\\n                include = S[i] - S[j] + dp[j][have - 1]\\n                exclude = dp[i + 1][have]\\n                dp[i][have] = max(include, exclude)\\n        return S[0] - S[N] - dp[0][M]\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                let exclude = (go.f)(go, i + 1, have);\\n                return max(include, exclude);\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\n//\\n// TODO: question -- how do capture the mutable map m within a recursive closure?\\n//\\nuse std::cmp::min;\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut m = HashMap::new();\\n        struct Go<\\'a> { f: &\\'a dyn Fn(&Go, usize, i32) -> i32 }\\n        let go = Go {\\n            f: &|go, i, have| {\\n                if i == N || have == 0 {\\n                    return 0;\\n                }\\n                let k = format!(\"{},{}\", i, have);\\n                if !m.contains_key(&k) {\\n                    let j = min(i + K as usize, N);\\n                    let include = S[i] - S[j] + (go.f)(go, j, have - 1);\\n                    let exclude = (go.f)(go, i + 1, have);\\n                    m.insert(&k, max(include, exclude));\\n                }\\n                return *m.get(&k).unwrap();\\n            }\\n        };\\n        return S[0] - S[N] - (go.f)(&go, 0, M);\\n    }\\n}\\n```\n```\\nuse std::cmp::min;\\nuse std::cmp::max;\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn minimum_white_tiles(A: String, M: i32, K: i32) -> i32 {\\n        let N = A.len();\\n        let mut S = vec![0; N + 1];\\n        for i in (0..N).rev() {\\n            S[i] = if A.chars().nth(i).unwrap() == \\'1\\' { 1 } else { 0 } + S[i + 1];\\n        }\\n        let mut dp = vec![vec![0; M as usize + 1]; N + 1];\\n        for have in 1..=M as usize {\\n            for i in (0..N).rev() {\\n                let j = min(i + K as usize, N);\\n                let include = S[i] - S[j] + dp[j][have - 1];\\n                let exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M as usize];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto j = min(i + K, N);\\n            auto include = S[i] - S[j] + go(j, have - 1),\\n                 exclude = go(i + 1, have);\\n            return max(include, exclude);\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minimumWhiteTiles(string A, int M, int K, Map m = {}) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        auto key = [](auto a, auto b) {\\n            stringstream ss; ss << a << \",\" << b;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto have) {\\n            if (A.size() <= i || !have)\\n                return 0;\\n            auto k = key(i, have);\\n            if (m.find(k) == m.end()) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + go(j, have - 1),\\n                     exclude = go(i + 1, have);\\n                m[k] = max(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return S[0] - S[N] - go(0, M);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minimumWhiteTiles(string A, int M, int K) {\\n        int N = A.size();\\n        VI S(N + 1);\\n        for (auto i{ N - 1 }; 0 <= i; --i)\\n            S[i] = A[i] - \\'0\\' + S[i + 1];\\n        VVI dp(N + 1, VI(M + 1, 0));\\n        for (auto have{ 1 }; have <= M; ++have) {\\n            for (auto i{ N - 1 }; 0 <= i; --i) {\\n                auto j = min(i + K, N);\\n                auto include = S[i] - S[j] + dp[j][have - 1],\\n                     exclude = dp[i + 1][have];\\n                dp[i][have] = max(include, exclude);\\n            }\\n        }\\n        return S[0] - S[N] - dp[0][M];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870731,
                "title": "c-iterative-dp-knsapsack",
                "content": "```class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }\\n                 else{\\n                     dp[i][j] = min(1+dp[i+1][j],dp[i+carpetlen][j-1]) ;\\n                 }\\n             }\\n          }\\n      }\\n     return dp[0][num] ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumWhiteTiles(string floor, int num, int carpetlen) {\\n      //knapsack type problem\\n      int n = floor.length() ;\\n      int dp[n+1][num+1] ;\\n      memset(dp,0,sizeof(dp)) ;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n          for(int j=0;j<=num;j++)\\n          {\\n             if(j==0) dp[i][j] = (floor[i]==\\'1\\')?dp[i+1][j]+1:dp[i+1][j] ;\\n             else if(i+carpetlen >= n) dp[i][j] = 0 ;\\n             else{\\n                 if(floor[i]==\\'0\\'){\\n                     dp[i][j] = dp[i+1][j] ;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1870132,
                "title": "dp-solution",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        dp=[[0 for i in range(numCarpets+1)] for j in range(len(floor)+1)]\\n\\n        for i in range(1,len(floor)+1):\\n            if floor[i-1]==\\'1\\':\\n                dp[i][0]=dp[i-1][0]+1\\n            else:\\n                dp[i][0]=dp[i-1][0]\\n\\n        for j in range(1,numCarpets+1):\\n            for i in range(1,len(floor)+1):\\n                dp[i][j]=min(dp[max(0,i-carpetLen)][j-1],dp[i-1][j]+(floor[i-1]==\\'1\\'))\\n        return dp[-1][numCarpets]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870008,
                "title": "top-down-dynamic-programming-knapsack-approach",
                "content": "Time Complexity : O(n*m) where m is num of carpets\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(string &str, int n, int pos, int carpetLen, vector<int> &cnt)\\n    {\\n        if(pos >= str.length())\\n            return 0;\\n        \\n        if(n == 0)\\n            return cnt[pos];\\n        \\n        \\n        if(dp[pos][n] != -1)\\n            return dp[pos][n];\\n        \\n        int op1 = 0, op2 = 0;\\n        \\n        while(str[pos] == \\'0\\')\\n            pos++;\\n        \\n        if(pos >= str.length())\\n        {\\n            return 0;\\n        }\\n        \\n        // if(str[pos] == \\'0\\')\\n        // {\\n        //     return dp[pos][n] = solve(str, n, pos + 1, carpetLen, cnt);\\n        // }\\n        \\n        if(str[pos] == \\'1\\')\\n        {\\n            op1 = solve(str, n - 1, pos + carpetLen, carpetLen, cnt); // place the carpet\\n            \\n            op2 = 1 + solve(str, n, pos + 1, carpetLen, cnt); // did not place the carpet, so the white tile is still visisble\\n        }\\n        \\n        //cout<<op1<<\" \"<<op2<<endl;\\n        return dp[pos][n] = min(op1, op2);\\n            \\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        \\n        \\n        int sz = floor.length();\\n        \\n        vector<int> cnt(sz + 1, 0);\\n        \\n        cnt[sz - 1] = (floor[sz - 1] == \\'1\\') ? 1 : 0;\\n        \\n        for(int i = sz - 2; i >= 0; i--)\\n        {\\n            cnt[i] =  cnt[i + 1] + (floor[i] == \\'1\\'); \\n        }\\n        \\n        \\n        // for(int x : cnt)\\n        //     cout<<x<<\" \";\\n        \\n        //cout<<endl;\\n        \\n        dp.resize(sz + 1, vector<int>(numCarpets + 1, -1));\\n        \\n        return solve(floor, numCarpets, 0, carpetLen, cnt);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869875,
                "title": "java-easy-to-understand-solution-dp-recursive-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int ded = 0;\\n        int[][] dp = new int[numCarpets+1][floor.length()];\\n        for(int i = 0; i < floor.length(); i++) {\\n            if(floor.charAt(i) == \\'1\\') ded++;\\n        }\\n        if(ded == floor.length()){\\n            return ded - numCarpets*carpetLen>=0?ded-numCarpets*carpetLen:0;\\n        }\\n        \\n        if(ded == 0){\\n            return 0;\\n        }\\n        \\n        return ded - helper(floor, numCarpets, carpetLen, 0, dp);\\n    }\\n    \\n    private int helper(String floor, int numCarpets, int carpetLen, int start, int[][] dp){\\n        if(start >= floor.length() || numCarpets==0) return 0;\\n        \\n        if(dp[numCarpets][start]!=0) return dp[numCarpets][start];\\n        \\n        int take= calc(floor, start,  start + carpetLen);\\n        if(floor.charAt(start) == \\'1\\') {\\n            return dp[numCarpets][start] = Math.max((take + helper(floor, numCarpets-1, carpetLen, start+carpetLen, dp)),\\n                           helper(floor, numCarpets, carpetLen, start+1, dp));\\n        }else if(floor.charAt(start) == \\'0\\'){\\n            return dp[numCarpets][start] = helper(floor, numCarpets, carpetLen, start+1, dp);\\n        }\\n        return dp[numCarpets][start];\\n    }\\n    \\n    private int calc(String floor, int start, int end) {\\n        int answer = 0;\\n        for(int i = start; i < end && i < floor.length() ; i++) {\\n            if(floor.charAt(i) == \\'1\\') answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869157,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        char [] arr = floor.toCharArray();\\n        int [] pre = new int[arr.length];\\n        pre[0] = (arr[0]==\\'1\\'?1:0);\\n        for(int i = 1;i<arr.length;i++){\\n            if(arr[i]==\\'1\\'){\\n                pre[i] = (pre[i-1]+1);\\n            }else{\\n                pre[i] = pre[i-1];\\n            }\\n        }\\n        int [][] dp = new int[pre.length+1][numCarpets+1];\\n        for(int [] row : dp){\\n            Arrays.fill(row,-1);\\n        }\\n        return pre[pre.length-1]-solve(pre,0,numCarpets,carpetLen,dp);\\n    }\\n    private int solve(int [] pre,int idx,int num,int carpetLen,int[][] dp){\\n        if(idx>=pre.length){\\n            return 0;\\n        }\\n        if(num<=0){\\n            return 0;\\n        }\\n        if(dp[idx][num]!=-1){\\n            return dp[idx][num];\\n        }\\n        int end = (idx+carpetLen-1>=pre.length)?pre.length-1:(idx+carpetLen-1);\\n        // place carpet at idx.\\n        int best = getSum(pre,idx,end) + solve(pre,end+1,num-1,carpetLen,dp);\\n        //dont place carpet at idx.\\n        best = Math.max(solve(pre,idx+1,num,carpetLen,dp),best);\\n        \\n        return dp[idx][num]=best;\\n    }\\n    \\n    private int getSum(int [] pre,int start,int end){\\n        if(start>0){\\n            return pre[end] - pre[start-1];\\n        }\\n        return pre[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867874,
                "title": "debug",
                "content": "I am doing anything wrong?\\n```\\nclass Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }\\n        int ind = i+cl;\\n        if (ind >= arr.size()) {\\n            ind = arr.size()-1;\\n        }\\n        \\n        int ans = hideTile(arr, rem-1, i+cl, w-(arr[ind]-arr[i]));\\n        int skipCurr = hideTile(arr, rem, i+1, w);\\n        \\n        mp[i][rem] = min(ans, skipCurr);\\n        return mp[i][rem];\\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<int> pf(floor.length()+1, 0);\\n        \\n        mp = vector<vector<int>> (1002, vector<int> (1002, 0));\\n        for (int i = 0; i < floor.length(); i++) {\\n            if (floor[i] == \\'1\\') {\\n                pf[i+1] += pf[i] + 1;\\n            } else {\\n                pf[i+1] = pf[i];\\n            }\\n        }\\n        cl = carpetLen;\\n        \\n        return hideTile(pf, numCarpets , 0, pf[floor.length()]);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int cl;\\n    vector<vector<int>> mp;\\n    int hideTile(vector<int> &arr, int rem, int i, int w) {\\n        if (rem == 0) return w;\\n        if (i >= arr.size()) return w;\\n        if (w <= 0) return 0;\\n        \\n        if (mp[i][rem]!=0) {\\n            return mp[i][rem];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1867834,
                "title": "python-dp-solution-optimized",
                "content": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\\nNote: without writing special cases it gives TLE which is:\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n\\t\\t# number of white tiles up in the first i tiles\\n        c_sums=[]\\n        cur=0\\n        for x in floor:\\n            cur+=int(x)\\n            c_sums.append(cur)\\n\\n        if carpetLen == 1:\\n            return max(0,c_sums[-1]-numCarpets)\\n\\t\\t\\n\\t\\t# the minimum number of white tiles still visible when using k tiles to cover the first i tiles \\n        @cache\\n        def dp(i,k):\\n\\t\\t\\t# no tiles left\\n            if  k <= 0:\\n                return c_sums[i-1]\\n\\t\\t\\t\\t\\n            # cover all white tiles\\n            if i <= k*carpetLen:\\n                return 0\\n\\t\\t\\t\\t\\n\\t\\t\\t# everytile is white\\n            if i == c_sums[i-1]:\\n                return i-k*carpetLen\\n\\t\\t\\t\\n\\t\\t\\t# either not cover the ith(last) tile or cover it \\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1)) \\n        \\n        return dp(len(floor),numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        @cache\\n        def dp(i,k):            \\n            if i<=k*carpetLen:\\n                return 0\\n\\n            return min(dp(i-1,k) + int(floor[i-1]), dp(i-carpetLen,k-1) if k>0 else float(\"inf\")) \\n        \\n        return dp(len(floor),numCarpets)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867643,
                "title": "java-top-down-tle-then-optimized-to-bottom-up",
                "content": "I have top-down solution with memoization but TLE\\n\\nThe requirement is find minimum number of white after covered by carpets\\nIdea: Ahh, If we able to find maximum white we could cover by carpets then the rest of white are minimum\\nImplement: top-down approach TLE but they show us that programming depending on 2 parameter: number of floor and number of carpet so far\\nBottom-up: call dp[i][k] is maximum white we could cover at first ith floor(include ith floor) with k carpet.\\ndp[floor.length()][numOfCarpet] is our solution, but final solution is maxWhite - dp[floor.length()][numOfCarpet]\\n\\n```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```\\n\\nThen I have optimized to bottom-up\\n```\\n\\tpublic int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n           int numOfWhite = 0;\\n           int[] prefix = new int[floor.length()];\\n           for(int i = 0; i < floor.length(); i++) {\\n               if (floor.charAt(i) == \\'1\\') {\\n                   numOfWhite++;\\n               }\\n               prefix[i] = numOfWhite;\\n           }\\n           \\n           int[][] dp = new int[floor.length() + 1][numCarpets + 1];\\n           for(int i = 1; i <= floor.length(); i++) { /// number of floor \\n               for(int j = 1; j <= numCarpets; j++) {\\n                   dp[i][j] = (i - carpetLen >= 0 ? dp[i - carpetLen][j - 1] : 0) + \\n                       prefix[i - 1] - (i - 1 - carpetLen >= 0 ? prefix[i - 1 - carpetLen] : 0);\\n                   dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);\\n               }\\n           }\\n           \\n           return numOfWhite - dp[floor.length()][numCarpets];\\n       }\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int countWhite = 0;\\n        char[] floorArr = floor.toCharArray();\\n        for(char c : floorArr) {\\n            if (c == \\'1\\') countWhite++;\\n        }\\n        \\n        int numOfWhiteSoFar = 0;\\n        int[] rangeWhite = new int[floorArr.length];\\n        for(int i = 0; i < floorArr.length; i++) {\\n            if (floorArr[i] == \\'1\\') numOfWhiteSoFar++;\\n            rangeWhite[i] = numOfWhiteSoFar;\\n        }\\n        \\n        Integer[][] cache = new Integer[numCarpets + 1][floorArr.length + 1];\\n        int max= maximumWhiteTiles(floorArr, numCarpets, carpetLen, 0, cache, rangeWhite);\\n        return countWhite - max;\\n    }\\n    \\n    private int maximumWhiteTiles(char[] floorArr, int numCarpets, int carpetLen, int start\\n                                 , Integer[][] cache, int[] rangeWhite) {\\n        \\n        // start from a index what is maximum white tiles you could cover;\\n        if (numCarpets == 0) return 0;\\n        if (start >= floorArr.length) return 0;\\n        \\n        if (cache[numCarpets][start] != null) return cache[numCarpets][start];\\n        int max = 0;\\n        for(int i = start; i < floorArr.length; i++) {\\n            int end = floorArr.length - 1 <= i + carpetLen - 1 ? floorArr.length - 1 : i + carpetLen - 1;\\n            int rangeWhileFromIToEnd = rangeWhite[end] - (i - 1 >= 0 ? rangeWhite[i - 1] : 0);\\n            int val = rangeWhileFromIToEnd + maximumWhiteTiles(floorArr, numCarpets - 1, carpetLen, i + carpetLen, cache, rangeWhite);\\n            max = Math.max(max, val);\\n        }\\n        \\n        cache[numCarpets][start] = max;\\n        return max;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867595,
                "title": "c-simple-easy-explanation-with-code-easy-to-understand",
                "content": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "The most basic intuition we can get after seeing the problem is that , **for every index i ( 0 <= i < n )** in the array there are **2 possibilites** - \\n\\n**1. You put a carpet** \\n\\n    So if you decide to put carpet on ith block , then you don\\'t have to worry about the indices i , i + 1 , i + 2 ... i + len - 1. (len -> is carpet length)\\n\\t\\n   This will cost you one carpet and now you have to do the same thing from index **i + len** with **numCarpet - 1** .\\n   \\n2. **You do not put a carpet**\\n      \\n\\tNow , if the ith tile is white this will increase the **white tile count by 1**.\\n\\tAnd now you have to do the same thing from index **i + 1** with **numCarpet**.\\n\\t\\n**Your answer will be the minimum of 2 cases.**\\n\\n**Code - **\\n\\n...\\nint dp[1001][1001] ; \\n\\n  int fun(string &s , int &k , int c , int i) { \\n\\n  \\t     int n = s.length() ; \\n\\n  \\t     if (c == 0) {\\n               \\n              int x = 0 ; \\n  \\t     \\t    for (int j = i ; j < n ; j ++ ) {\\n\\n  \\t     \\t    \\t     if (s[j] == \\'1\\') x ++; \\n  \\t     \\t    }\\n\\n  \\t     \\t    return x ; \\n  \\t     }\\n\\n  \\t     if ((n - i) <= k || i >= n ) return 0 ;  \\n\\n  \\t     if (dp[c][i] != -1 ) return dp[c][i] ; \\n\\n  \\t     int q1 = fun(s , k , c - 1 , i + k) ; \\n  \\t     int q2 = ((s[i] == \\'1\\') ? 1 : 0) + fun(s , k , c , i + 1) ;\\n\\n  \\t     return dp[c][i] = min(q1,q2) ; \\n  }\\n \\n  int minimumWhiteTiles(string s, int c, int k) {\\n\\n         memset(dp , -1 , sizeof(dp)) ; \\n         return fun(s , k , c , 0); \\n    }\\n\\t...",
                "codeTag": "Unknown"
            },
            {
                "id": 1867528,
                "title": "python-straight-forward-dp-solution-with-explanations",
                "content": "We can divide the problem into sub problems - where each sub problem is \\n**\"How many white tiles do you leave uncovered at most with n carpets starting from tile i\"**\\n\\nwe can use the array `dp[tile][carpets]` to store the results \\n\\nGiven the floor 10110101 with 2 carpets of length 2 we can start from the back (tile 7).\\n\\n0  1  2  3  4  5  6  7\\n[ ][#][ ][  ][#][ ][#][ ]  \\n\\nWith 0 carpets we would leave tile 7 uncovered => 1 white tile\\nWith 1 or 2 carpets we would cover tile 7 => 0 white tiles\\n\\nMoving backwards we can then find the minimum number of white tiles uncovered which is\\n\\n1. If the number of carpets * their length cover the whole rest of the floor - we leave 0 tiles uncovered\\n2. We have the choice of\\n\\ta. covering the current tile - then our answer is min tiles for the floor a carpets length away covered by carpet - 1 carpets **or**\\n\\tb. don\\'t cover the current tile - then our answer is the min tile for starting at the next tile with the same number of carpets + 1 if our tile is white (as this is now uncovered)\\n\\t\\nAt the end - the answer is dp[tile=0][carpets=numCarpets]\\n\\n```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        n = len(floor)\\n        dp= [[0 for _ in range(numCarpets + 1)] for _ in range(n)]\\n\\n        dp[n - 1][0] = int(floor[-1])\\n\\n        for tile in range(n - 2, -1, -1):\\n            for carpets in range(numCarpets, -1, -1):\\n                if carpets == 0:\\n                    dp[tile][0] = dp[tile + 1][0] + int(floor[tile])\\n                elif tile + (carpets * carpetLen) >= n:\\n                    continue   # number is 0 by default\\n                else:\\n                    dp[tile][carpets] = min(dp[tile + carpetLen][carpets - 1], int(floor[tile]) + dp[tile + 1][carpets])\\n\\n        return dp[0][numCarpets]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1867148,
                "title": "fast-dp-considering-special-test-cases-and-pruning-some-branches",
                "content": "There are shorter implementations, but in order to improve the efficiency, we\\'d better consider treatments for special test cases and pruning some branches.\\n# DP with recursion\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\\n\\n# DP with array\\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        @lru_cache(None)\\n        def dp(start, n) -> int:\\n            \"\"\" start of index, number of remaining carpets \"\"\"\\n            if n * carpetLen >= len(floor) - start:  # enough to cover all in this region\\n                return ps[start-1]\\n\\n            if n == 0:  # no tile is used\\n                return ps[-2]\\n\\n            k = min(start + carpetLen, len(floor))\\n            return min(dp(start+1, n), dp(k, n-1)-ps[k-1]+ps[start-1])\\n\\n        return dp(0, numCarpets)\\n```\n```\\nclass Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        ps = [0] * (1 + len(floor))\\n        for i, c in enumerate(floor):\\n            ps[i] = ps[i - 1] + 1 if c == \"1\" else ps[i - 1]\\n\\n        if carpetLen == 1:     # special treatments to improve the efficiency\\n            return max(ps[-2] - numCarpets, 0)\\n\\n        if ps[-2] == len(floor):\\n            return max(len(floor) - numCarpets * carpetLen, 0)\\n\\n        dp = [[ps[-2]] * (1+len(floor)) for _ in range(numCarpets+1)]  # row[len(floor)] means using no carpets\\n\\n        for n in range(1, numCarpets+1):                               # start with 1 carpet\\n            row = dp[n]\\n            for i in range(len(floor)-1, -1, -1):                      # place another carpet at \"i\"\\n                k = min(i+carpetLen, len(floor))                       # the first position that \"i\" does not cover\\n                row[i] = min(dp[n][i+1], dp[n-1][k]-ps[k-1]+ps[i-1])\\n        return dp[numCarpets][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866920,
                "title": "c-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int fun(int l,int num,string &s,int &ln){\\n        \\n        while(l<s.length() and s[l]==\\'0\\') l++;\\n        \\n        if(l>=s.length()) return 0;\\n        if(dp[l][num]!=-1) return dp[l][num];\\n        int ans=INT_MAX;\\n        if(num>0) ans=min(ans,fun(l+ln,num-1,s,ln));\\n        ans=min(ans,fun(l+1,num,s,ln)+1);\\n        \\n        return dp[l][num]=ans;\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        dp.resize(floor.length()+1,vector<int>(numCarpets+1,-1));\\n        return fun(0,numCarpets,floor,carpetLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866555,
                "title": "java-dp-memoization",
                "content": "1. Do Binary Search and store indices of whites tiles.\\n2. We can use DP here now where:\\ndp(floorLength, numCarpets) = max(dp(floorLength - carpetLen, numCarpets - 1) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength), dp(floorLength - carpetLen, numCarpets - 1)) -> number of white tiles covered from index 0 to floorLength using numCarpets number of carpets.\\n3. Base Conditions:\\nif (floorLength < 0 || numCarpets <= 0) return 0;\\n4. ans = whiteTiles.size() - dp(floorLength, numCarpets)\\n```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumWhiteTiles(String floor, int numCarpets, int carpetLen) {\\n        int floorLength = floor.length();\\n        List<Integer> whiteTiles = new ArrayList<>();\\n        for (int tile = 0; tile < floorLength; tile += 1) {\\n            if (floor.charAt(tile) == \\'1\\') {\\n                whiteTiles.add(tile);\\n            }\\n        }\\n        Integer[][] dp = new Integer[floorLength][numCarpets + 1];\\n        System.out.println(minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles) + \"-\" + whiteTiles.size());\\n        return whiteTiles.size() - minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles);\\n    }\\n    \\n    private int minimumWhiteTiles(int floorLength, int numCarpets, int carpetLen, Integer[][] dp, List<Integer> whiteTiles) {\\n        if (floorLength < 0 || numCarpets <= 0) {\\n            return 0;\\n        }\\n        if (dp[floorLength][numCarpets] != null) {\\n            return dp[floorLength][numCarpets];\\n        }\\n        return dp[floorLength][numCarpets] = Math.max(minimumWhiteTiles(floorLength - carpetLen, numCarpets - 1, carpetLen, dp, whiteTiles) + numOfWhiteTilesInRange(floorLength - carpetLen, floorLength, whiteTiles), minimumWhiteTiles(floorLength - 1, numCarpets, carpetLen, dp, whiteTiles));\\n    }\\n    \\n    private int numOfWhiteTilesInRange(int start, int end, List<Integer> whiteTiles) {\\n        int maxIndex = ceil(end, whiteTiles);\\n        int minIndex = ceil(start, whiteTiles);\\n        return maxIndex - minIndex;\\n    }\\n    \\n    int ceil(int idx, List<Integer> whiteTiles) {\\n        int ans = -1;\\n        int start = 0;\\n        int end = whiteTiles.size() - 1;\\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if(whiteTiles.get(mid) <= idx) {\\n                ans = mid;\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866430,
                "title": "c-dp-pick-nonpick-technique",
                "content": "* Solve function will return the maximum number of white tiles that can be covered with carpets \\n* Therefore , Minimum Visible white tiles = Total white tiles - Value returned by Solve function\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    //returns the max number of white tiles that can be covered\\n    int solve(string &floor , int i , int carpets ,int len,vector<int>&suff ){\\n        if(i >= floor.size() || !carpets ) return 0 ;\\n        if(dp[i][carpets] != -1) return dp[i][carpets] ;\\n        \\n\\t\\t//at every index i we have two options -> lay the carpet(if tile is white) , or dont lay and move ahead\\n        int Laid = 0 , notLaid = 0 , covered = 0 ;\\n        //if the current tile is white only then lay the carpet\\n        if(floor[i] == \\'1\\'){\\n          covered = (i+len-1 >= floor.size() ? suff[suff.size()-1] : suff[i+len-1]) - (i-1>=0 ? suff[i-1] : 0 ) ;\\n          Laid = covered + solve(floor,i+len,carpets-1,len,suff) ;  \\n        } \\n        notLaid = solve(floor,i+1,carpets,len,suff) ;\\n        return dp[i][carpets] = max(Laid,notLaid) ;\\n    }\\n    int minimumWhiteTiles(string &floor, int carpets, int len ) {\\n\\n        vector<int>suff(floor.size(),0) ;\\n        //make suffix array  for O(1) access to number of white tiles between given range \\n        for(int i = 0 ; i < floor.size() ; ++i ){\\n            if(floor[i] == \\'1\\') ++suff[i];\\n            if(i!=0) suff[i] += suff[i-1] ;\\n        }\\n        \\n        memset(dp,-1,sizeof(dp)) ;\\n        return suff[suff.size()-1] - solve(floor,0,carpets,len,suff) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866262,
                "title": "c-memoization-o-length-numberofcarpets",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &floor,int i,int n,int k,int nc,int cl,vector<vector<int>>&memo){\\n        \\n        if(i>=n)return 0;\\n        int ans1=INT_MAX;\\n        int ans2=INT_MAX;\\n        if(memo[i][k]!=-1)return memo[i][k];\\n     \\n        if(k<nc){\\n           \\n            ans1=helper(floor,i+cl,n,k+1,nc,cl,memo);\\n        }\\n       \\n        ans2=helper(floor,i+1,n,k,nc,cl,memo)+floor[i]-\\'0\\';\\n        \\n        return memo[i][k]=min(ans1,ans2);\\n        \\n    }\\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        vector<vector<int>>memo(floor.size(),vector<int>(numCarpets+1,-1));\\n        return helper(floor,0,floor.size(),0,numCarpets,carpetLen,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866143,
                "title": "simple-c-dp-memoization-top-down-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    \\n    int answer(string& nums , int black , int& len , int index){\\n        if(index >= nums.size())return 0;\\n        \\n        if(dp[index][black] != -1)return dp[index][black];\\n        \\n        int a = 3000 , b = 3000;\\n        \\n        if(black > 0){\\n            a = answer(nums , black - 1 , len , index + len);\\n        }\\n        b = answer(nums , black , len , index + 1);\\n        b += (nums[index] == \\'1\\');\\n        \\n        return dp[index][black] = min(a , b);\\n    }\\n    \\n    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        memset(dp , -1 , sizeof(dp));\\n        return answer(floor , numCarpets , carpetLen , 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576522,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1981361,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            },
            {
                "id": 1968246,
                "content": [
                    {
                        "username": "larachicharo",
                        "content": "I was trying a greedy solution where you cover the max number of whites for every new carpet. You do this iteratively one carpet at a time. I got a Wrong Anwser, not a TLE. I can\\'t find a counter example that breaks this solution. Please help me find one.\\n\\nThanks."
                    },
                    {
                        "username": "joefreedman24",
                        "content": "Counter example set up:\\nfloor = 10111101\\nlength = 4\\nrugs = 2\\n\\nGreedy round 1: Take the rug placement that covers 4 white tiles\\nresulting floor = 10000001\\nrugs left = 1\\n\\nYou can now only cover one of the two remaining white tiles with your last rug.\\nThis leaves one white tile exposed no matter what.\\n\\nAlternatively, an ideal solution would place one rug at indices 0-3 and the other on indices 4-7.\\nThese placements only cover three each but result in a full covering of all white tiles."
                    },
                    {
                        "username": "prince3244",
                        "content": "2699/2706 test cases passed. I wanna know those 7 test cases really bad. Is there any way?\\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "I tried doing it with recursion , but got MLE :((. \n\nEDIT: Solved it using recursion + memoization , initially i was taking a 3D dp array but solved it using 2D dp array only , you also try."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum Score of Array",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1998980,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1915791,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            },
            {
                "id": 1813850,
                "content": [
                    {
                        "username": "mxquint",
                        "content": "This should be classified as an Easy problem. The complexity is not enough to be considered a medium difficulty problem."
                    },
                    {
                        "username": "vishnuvt",
                        "content": "Exactly"
                    },
                    {
                        "username": "Saurav_NITH",
                        "content": "This needs to be classified as Easy problem. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if an Array Is Consecutive",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]