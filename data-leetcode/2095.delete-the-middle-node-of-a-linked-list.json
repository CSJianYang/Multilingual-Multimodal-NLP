[
    {
        "title": "Delete the Middle Node of a Linked List",
        "question_content": "You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\nThe middle node of a linked list of size n is the &lfloor;n / 2&rfloor;th node from the start using 0-based indexing, where &lfloor;x&rfloor; denotes the largest integer less than or equal to x.\n\n\tFor n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\n\n&nbsp;\nExample 1:\n\nInput: head = [1,3,4,7,1,2,6]\nOutput: [1,3,4,1,2,6]\nExplanation:\nThe above figure represents the given linked list. The indices of the nodes are written below.\nSince n = 7, node 3 with value 7 is the middle node, which is marked in red.\nWe return the new list after removing this node. \n\nExample 2:\n\nInput: head = [1,2,3,4]\nOutput: [1,2,4]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 4, node 2 with value 3 is the middle node, which is marked in red.\n\nExample 3:\n\nInput: head = [2,1]\nOutput: [2]\nExplanation:\nThe above figure represents the given linked list.\nFor n = 2, node 1 with value 1 is the middle node, which is marked in red.\nNode 0 with value 2 is the only node remaining after removing node 1.\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [1, 105].\n\t1 <= Node.val <= 105",
        "solutions": [
            {
                "id": 1612140,
                "title": "one-pass-slow-and-fast",
                "content": "...and it is true because it rhymes.\\n\\nSlow pointer goes node-by-node, and fast pointer skips a node. When the fast node reaches the end, the slow node will point to the middle. \\n\\n**C++**\\n```cpp\\nListNode* deleteMiddle(ListNode* head) {\\n    if (head->next == nullptr)\\n        return nullptr;\\n    auto slow = head, fast = head->next->next;\\n    while (fast != nullptr && fast->next != nullptr) {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    slow->next = slow->next->next;\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nListNode* deleteMiddle(ListNode* head) {\\n    if (head->next == nullptr)\\n        return nullptr;\\n    auto slow = head, fast = head->next->next;\\n    while (fast != nullptr && fast->next != nullptr) {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    slow->next = slow->next->next;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1611982,
                "title": "java-python3-slow-and-fast-pointers-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\n\\nQ1: Why do you use a `prev` and `dummy` variable for this as it\\'s taking extra space? The following code is good enough without them:\\n```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n        ListNode slow = head, fast = head.next.next;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n```\\nA1: For this specific problem we are given a constraint **The number of nodes in the list is at least 1**. Therefore the above code is perfect without using `prev` or `dummy`. \\nMy code is implemented for more general cases including empty list, in which case a dummy head is necessary.\\n\\n----\\n\\nQ2: Most of the solutions just skip the node to be deleted.\\nTo properly delete the node :\\n```java\\nListNode y = slow.next.next;  //delete_node_after_slow_node\\nslow.next.next = null;\\nslow.next = y;\\n```\\nA2: Excellent critical comment. Actually there is an ambiguous point about the `delete`: after deleting from the list, terminate the life of the object or not?\\nYou use an explicit way to terminate the object, and most others just overwrite the corresponding reference, and GC will take care of the object if there is no reference to it, otherwise the object will be still alive out of the list.\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1: Two pointers**\\n\\n1. Create a `dummy` head, and initialize `slow` and `fast` pointers as `dummy`;\\n2. Traverse the ListNodes starting from `dummy` by the afore-mentioned two pointers, `slow` forwards `1` step and `fast` forwards `2` steps per iteration;\\n3. Terminate the traversal till `fast.next` or `fast.next.next` is `null`, and now `slow` points to the previous node of the `middle` node; remove the `middle` node;\\n4. Return `dummy.next` as the result.\\n\\n```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode dummy = new ListNode(-1), slow = dummy, fast = dummy; \\n        dummy.next = head;\\n        while (fast.next != null && fast.next.next != null) {  \\n            slow = slow.next; \\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return dummy.next; \\n    }\\n```\\n\\n```python\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = slow = fast = ListNode(-math.inf)\\n        dummy.next = head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow.next = slow.next.next    \\n        return dummy.next\\n```\\n\\n----\\n\\n**Method2: Three pointers** - inspired by **@Zudas**.\\n\\nAdd a `prev` pointers following `slow` one.\\n\\n```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode dummy = new ListNode(-1), prev = dummy, slow = head, fast = head;\\n        prev.next = head;\\n        while (fast != null && fast.next != null) {  \\n            prev = slow;\\n            slow = slow.next; \\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;\\n        return dummy.next;       \\n    }\\n```\\n```python\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = ListNode(-math.inf)\\n        slow = fast = head\\n        prev.next = slow\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = slow.next\\n        return dummy.next\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = # of the nodes`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n        ListNode slow = head, fast = head.next.next;\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n```\n```java\\nListNode y = slow.next.next;  //delete_node_after_slow_node\\nslow.next.next = null;\\nslow.next = y;\\n```\n```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode dummy = new ListNode(-1), slow = dummy, fast = dummy; \\n        dummy.next = head;\\n        while (fast.next != null && fast.next.next != null) {  \\n            slow = slow.next; \\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return dummy.next; \\n    }\\n```\n```python\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = slow = fast = ListNode(-math.inf)\\n        dummy.next = head\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow.next = slow.next.next    \\n        return dummy.next\\n```\n```java\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode dummy = new ListNode(-1), prev = dummy, slow = head, fast = head;\\n        prev.next = head;\\n        while (fast != null && fast.next != null) {  \\n            prev = slow;\\n            slow = slow.next; \\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;\\n        return dummy.next;       \\n    }\\n```\n```python\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = prev = ListNode(-math.inf)\\n        slow = fast = head\\n        prev.next = slow\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        prev.next = slow.next\\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612016,
                "title": "detailed-explanation-3-pointers-rabbit-and-tortoise-story",
                "content": "I think everyone here must\\u2019ve heard about rabbit and tortoise story. To solve this problem let\\u2019s use one rabbit and two tortoises (here, the rabbit is intelligent unlike the one in story :P). In one iteration, the rabbit will move 2 steps ahead whereas tortoise moves only one step and the other tortoise will just follow the other one. After rabbit moves to the end, then we can say that tortoise will be at the middle and follow_tortoise will be just behind the middle element.\\n\\nSee the image below to understand more clearly :\\n\\n<img src = \"https://assets.leetcode.com/users/images/e4b844c8-7d0c-483e-8d20-11f822fe358b_1638676119.0080023.jpeg\" width=\"400\" height=\"400\" style=\"margin-left:auto; margin-right:auto; display:block\">\\n\\nNow simply eliminate the existing link between tortoise and follow_tortoise and point the next pointer of follow_tortoise to the next of tortoise.\\n\\n**Code :**\\n\\n```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if(head.next==None):return None \\n        tortoise=head\\n        rabbit=head\\n        follow_tortoise=None\\n        while(rabbit and rabbit.next):\\n            follow_tortoise=tortoise\\n            tortoise=tortoise.next\\n            rabbit=rabbit.next.next\\n        follow_tortoise.next=tortoise.next\\n        return head\\n```\\n\\n**Time Complexity** : O(n)\\n**Space Complexity** : O(1)\\n\\nUpvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if(head.next==None):return None \\n        tortoise=head\\n        rabbit=head\\n        follow_tortoise=None\\n        while(rabbit and rabbit.next):\\n            follow_tortoise=tortoise\\n            tortoise=tortoise.next\\n            rabbit=rabbit.next.next\\n        follow_tortoise.next=tortoise.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680543,
                "title": "python-simple-and-clean-solution",
                "content": "**Python :**\\n\\n```\\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:  \\n\\tif not head.next:\\n\\t\\treturn head.next\\n\\n\\tfast, slow = head.next.next, head\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:  \\n\\tif not head.next:\\n\\t\\treturn head.next\\n\\n\\tfast, slow = head.next.next, head\\n\\n\\twhile fast and fast.next:\\n\\t\\tslow = slow.next\\n\\t\\tfast = fast.next.next\\n\\n\\tslow.next = slow.next.next\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1612032,
                "title": "c-two-pointers-fast-pointer-slow-pointer-easy-to-understand",
                "content": "* We can solve this problem with **two pointer** approach: idea is to make two pointers - **fast pointer(jumps two node)** and **slow pointer(jumps one node)**. And **when fast pointer reaches end, slow pointer would have reached middle element.**\\n```\\nListNode* deleteMiddle(ListNode* head) {\\n\\t  // edge case conditions\\n       if (head == NULL) {\\n          return NULL;\\n       }\\n       if (head->next == NULL) {\\n          delete head;\\n          return NULL;\\n       }\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = head; // keeping this prev node to get the previous node of slow pointer when we reach middle\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            if(slow != head) prev = prev->next; // since we want prev to start one step later than slow node\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = slow->next;\\n        delete slow;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nListNode* deleteMiddle(ListNode* head) {\\n\\t  // edge case conditions\\n       if (head == NULL) {\\n          return NULL;\\n       }\\n       if (head->next == NULL) {\\n          delete head;\\n          return NULL;\\n       }\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = head; // keeping this prev node to get the previous node of slow pointer when we reach middle\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            if(slow != head) prev = prev->next; // since we want prev to start one step later than slow node\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = slow->next;\\n        delete slow;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700816,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n**TC** - O(N), **SC** - O(1)\\n\\n\\n------------------------------------------------------------------------------------\\n\\t\\n\\tListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return NULL;       //if 0 or 1 node is present, return NULL\\n        \\n        ListNode *prev=NULL, * slow=head, * fast=head;        //Maintain 3 Pointers; prev, slow, fast\\n        \\n        while(fast!=NULL and fast->next!=NULL){                  \\n            prev=slow;                                        //update prev = slow\\n            slow=slow->next;                                  //increment slow once, slow = slow->next; \\n            fast=fast->next->next;                            //increment fast twice, fast = fast->next->next;\\n        }\\n        \\n        prev->next=slow->next;                                //update connection \\n        delete slow;                                          //deleting middle node\\n        return head;                                          //return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\n**TC** - O(N), **SC** - O(1)\\n\\n\\n------------------------------------------------------------------------------------\\n\\t\\n\\tListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL) return NULL;       //if 0 or 1 node is present, return NULL\\n        \\n        ListNode *prev=NULL, * slow=head, * fast=head;        //Maintain 3 Pointers; prev, slow, fast\\n        \\n        while(fast!=NULL and fast->next!=NULL){                  \\n            prev=slow;                                        //update prev = slow\\n            slow=slow->next;                                  //increment slow once, slow = slow->next; \\n            fast=fast->next->next;                            //increment fast twice, fast = fast->next->next;\\n        }\\n        \\n        prev->next=slow->next;                                //update connection \\n        delete slow;                                          //deleting middle node\\n        return head;                                          //return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1612005,
                "title": "python-3-two-pointers-slow-and-fast-illustration-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/ab646dc3-5d64-4a6b-a4b9-3b181c2e84bf_1638678011.0424676.png)\\n\\n\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n  def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n    if not head: return head\\n    if head and not head.next: return None\\n    \\n    prev = ListNode(0, head)\\n    slow = fast = head\\n    while fast and fast.next:\\n      prev = slow\\n      slow = slow.next\\n      fast = fast.next.next\\n\\n    prev.next = slow.next\\n    return head      \\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n  def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n    if not head: return head\\n    if head and not head.next: return None\\n    \\n    prev = ListNode(0, head)\\n    slow = fast = head\\n    while fast and fast.next:\\n      prev = slow\\n      slow = slow.next\\n      fast = fast.next.next\\n\\n    prev.next = slow.next\\n    return head      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612147,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\t\\t// Base Condition\\n        if(head == null || head.next == null) return null;\\n\\t\\t// Pointers Created\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = head;\\n        \\n        while(fast != null && fast.next != null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\t\\t// Base Condition\\n        if(head == null || head.next == null) return null;\\n\\t\\t// Pointers Created\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode prev = head;\\n        \\n        while(fast != null && fast.next != null){\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701243,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        // Base cases...\\n        if (head == null) return null;\\n        if (head.next == null) return null;\\n        // Initialize slow and fast pointers to reach middle of linked list...\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        // Find the middle and previous of middle...\\n        ListNode prev = null;\\n        // To store previous of slow pointer...\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        // Delete the middle node...\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Initialize dummy, slow and fast pointers to reach middle of linked list...\\n        ListNode dummy, *fast = &dummy, *slow = &dummy;\\n        dummy.next = head;\\n        // Find the middle of the linked list...\\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        // Delete the middle node...\\n        slow->next = slow->next->next;\\n        return dummy.next;\\n    }\\n};\\n```\\n\\n# **Python / Python3 Solution:**\\n```\\n# Time complexity: O(n)\\n# Space complexity: O(1)\\nclass Solution(object):\\n    def deleteMiddle(self, head):\\n        # Initialize dummy, slow and fast pointers to reach middle of linked list...\\n        dummy = ListNode(0, head)\\n        slow = dummy\\n        fast = dummy\\n        # Find the middle of the linked list...\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        # Delete the middle node...\\n        slow.next = slow.next.next\\n        return dummy.next\\n```\\n        \\n# **JavaScript Solution:**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nvar deleteMiddle = function(head) {\\n    // Initialize slow and fast pointers to reach middle of linked list...\\n    let slow = fast = head;\\n    // Find the middle and previous of middle...\\n    let prev = null;\\n    // To store previous of slow pointer...\\n    while (fast && fast.next) {\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    // Delete the middle node...\\n    if (!prev) return null;\\n    prev.next = slow.next;\\n    return head;\\n};\\n```\\n\\n# **C Language:**\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nstruct ListNode* deleteMiddle(struct ListNode* head){\\n    // Initialize dummy, slow and fast pointers to reach middle of linked list...\\n    struct ListNode dummy, *fast = &dummy, *slow = &dummy;\\n    dummy.next = head;\\n    // Find the middle of the linked list...\\n    while (fast->next && fast->next->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    // Delete the middle node...\\n    slow->next = slow->next->next;\\n    return dummy.next;\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        // Base cases...\\n        if (head == null) return null;\\n        if (head.next == null) return null;\\n        // Initialize slow and fast pointers to reach middle of linked list...\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        // Find the middle and previous of middle...\\n        ListNode prev = null;\\n        // To store previous of slow pointer...\\n        while (fast != null && fast.next != null) {\\n            fast = fast.next.next;\\n            prev = slow;\\n            slow = slow.next;\\n        }\\n        // Delete the middle node...\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Initialize dummy, slow and fast pointers to reach middle of linked list...\\n        ListNode dummy, *fast = &dummy, *slow = &dummy;\\n        dummy.next = head;\\n        // Find the middle of the linked list...\\n        while (fast->next && fast->next->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        // Delete the middle node...\\n        slow->next = slow->next->next;\\n        return dummy.next;\\n    }\\n};\\n```\n```\\n# Time complexity: O(n)\\n# Space complexity: O(1)\\nclass Solution(object):\\n    def deleteMiddle(self, head):\\n        # Initialize dummy, slow and fast pointers to reach middle of linked list...\\n        dummy = ListNode(0, head)\\n        slow = dummy\\n        fast = dummy\\n        # Find the middle of the linked list...\\n        while fast.next and fast.next.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        # Delete the middle node...\\n        slow.next = slow.next.next\\n        return dummy.next\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nvar deleteMiddle = function(head) {\\n    // Initialize slow and fast pointers to reach middle of linked list...\\n    let slow = fast = head;\\n    // Find the middle and previous of middle...\\n    let prev = null;\\n    // To store previous of slow pointer...\\n    while (fast && fast.next) {\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    // Delete the middle node...\\n    if (!prev) return null;\\n    prev.next = slow.next;\\n    return head;\\n};\\n```\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\nstruct ListNode* deleteMiddle(struct ListNode* head){\\n    // Initialize dummy, slow and fast pointers to reach middle of linked list...\\n    struct ListNode dummy, *fast = &dummy, *slow = &dummy;\\n    dummy.next = head;\\n    // Find the middle of the linked list...\\n    while (fast->next && fast->next->next) {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n    }\\n    // Delete the middle node...\\n    slow->next = slow->next->next;\\n    return dummy.next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651995,
                "title": "c-easy-solution-100-faster-w-intuition",
                "content": "\\t**Intution**- we know that we can find middle node using two pointer fast and slow. \\n\\t After we iterate through linkedlist slow pointer is our middle node and since we need to delete it\\n\\t we only need pointer to its previous node and then just simply put next to next node in previous node.\\n\\t Woahh ! you are done with deleting middle NODE;\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteMiddle(ListNode* head) {\\n\\t\\t\\t   if(head->next==nullptr) return nullptr;\\n\\t\\t\\t   ListNode *f=head;\\n\\t\\t\\t   ListNode *s=head,*prev;\\n\\t\\t\\t  while(f!=nullptr && f->next!=nullptr){\\n\\t\\t\\t\\t  f=f->next->next;\\n\\t\\t\\t\\t  prev=s;\\n\\t\\t\\t\\t  s=s->next;\\n\\t\\t\\t  }\\n\\t\\t\\tprev->next=prev->next->next;\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* deleteMiddle(ListNode* head) {\\n\\t\\t\\t   if(head->next==nullptr) return nullptr;\\n\\t\\t\\t   ListNode *f=head;\\n\\t\\t\\t   ListNode *s=head,*prev;\\n\\t\\t\\t  while(f!=nullptr && f->next!=nullptr){\\n\\t\\t\\t\\t  f=f->next->next;\\n\\t\\t\\t\\t  prev=s;\\n\\t\\t\\t\\t  s=s->next;\\n\\t\\t\\t  }",
                "codeTag": "Java"
            },
            {
                "id": 2700726,
                "title": "java-solution-slow-and-fast-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null){\\n            return null;\\n        }\\n        ListNode fast=head,slow=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null){\\n            return null;\\n        }\\n        ListNode fast=head,slow=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700533,
                "title": "fastest-python-solution-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow,fast,prev=head,head,None\\n        while fast and fast.next:\\n            prev=slow\\n            slow=slow.next\\n            fast=fast.next.next\\n        if prev==None:\\n            return None\\n        prev.next=slow.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow,fast,prev=head,head,None\\n        while fast and fast.next:\\n            prev=slow\\n            slow=slow.next\\n            fast=fast.next.next\\n        if prev==None:\\n            return None\\n        prev.next=slow.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633096,
                "title": "python-easy-one-pass-beats-98-27-with-explanation",
                "content": "Essentialy, our first job is going to first find the middle element, before we can remove it. We can do so by utalizing a fast and slow pointer. The idea is that if I have a fast pointer going twice the speed of a slow pointer, by the time the fast pointer makes it to the end, the slow pointer will be in the middle of the linked list. The algorithm for that is shown below:\\n\\n```\\nslow, fast = head, head\\nwhile fast and fast.next:\\n\\tfast = fast.next.next\\n\\tslow = slow.next\\nreturn slow\\n```\\n\\nNow that we have found the middle element, we are tasked with removing it. One thing first though. You can end the program quickly if there is only one node, since we know that for a list containing only one node we can simply return an empty list. Another thing to consider is that if we remove the node within our while loop, we would not return an empty linked list for only one node since one of the conditions for the while loop is if head.next is not a null pointer. This takes care of that and lets our program end faster if it needs to.\\n\\nThat being said, we can modify our program to remove our middle node through a simple if statement. Since we move the fast node before the slow node, we can just check on the progress of the fast node before moving the slow node. If the fast node has run its track, and we do not move the slow node, we are effectively at the node one before the middle node. Thus, all we have to do is check if the fast pointer is at the end, and remove the next slow node if it has. \\nThe code for that is below. \\n```\\n# fast runner slow runner\\nif not head.next:\\n\\treturn head.next\\n\\nslow, fast = head, head\\nwhile fast and fast.next:\\n\\tfast = fast.next.next\\n\\tif not fast or not fast.next:\\n\\t\\tslow.next = slow.next.next\\n\\telse:\\n\\t\\tslow = slow.next\\n\\nreturn head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nslow, fast = head, head\\nwhile fast and fast.next:\\n\\tfast = fast.next.next\\n\\tslow = slow.next\\nreturn slow\\n```\n```\\n# fast runner slow runner\\nif not head.next:\\n\\treturn head.next\\n\\nslow, fast = head, head\\nwhile fast and fast.next:\\n\\tfast = fast.next.next\\n\\tif not fast or not fast.next:\\n\\t\\tslow.next = slow.next.next\\n\\telse:\\n\\t\\tslow = slow.next\\n\\nreturn head\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641343,
                "title": "easy-to-understand-c-slow-fast-pointer",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\t  // edge case \\n       if (head == NULL) {\\n          return NULL;\\n       }\\n       if (head->next == NULL) {\\n          delete head;\\n          return NULL;\\n       }\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = head;\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n            if(slow != head) prev = prev->next;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = slow->next;\\n        delete slow;\\n        return head;\\n    }\\n};\\n\\nFeel free to ask your doubts :)\\nand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700514,
                "title": "python-3-7-lines-w-explanation-t-m-92-89",
                "content": "```\\nclass Solution:\\n    def deleteMiddle(self, head: ListNode) -> ListNode:\\n\\n        if not head.next: return None                   # If only head, then it\\'s the middle node\\n\\n        ptr1, ptr2 = head.next, head                                       \\n\\n        while ptr1.next and ptr1.next.next:             # On each iteration, ptr1 jumps two nodes and ptr2\\n            ptr1 = ptr1.next.next                       # jumps one node, so when ptr1 hits the end of the\\n            ptr2 = ptr2.next                            # list, ptr1 will be at the middle node.\\n      \\n        ptr2.next = ptr2.next.next                      # middle node is removed.\\n\\n        return head\\n```\\n[https://leetcode.com/submissions/detail/822025808/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: ListNode) -> ListNode:\\n\\n        if not head.next: return None                   # If only head, then it\\'s the middle node\\n\\n        ptr1, ptr2 = head.next, head                                       \\n\\n        while ptr1.next and ptr1.next.next:             # On each iteration, ptr1 jumps two nodes and ptr2\\n            ptr1 = ptr1.next.next                       # jumps one node, so when ptr1 hits the end of the\\n            ptr2 = ptr2.next                            # list, ptr1 will be at the middle node.\\n      \\n        ptr2.next = ptr2.next.next                      # middle node is removed.\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652230,
                "title": "delete-the-middle-node-of-a-linked-list-explanation-100-o-n-java",
                "content": "The approach is based on the fast and slow pointer solution , where we search for the middle element of the linked list . We can set up a prev variable to store the previous node that was stored in the slow runner .At the last pass the slow runner will store middle node and our prev variable will store the node just before the middle node . So now we can simply use this prev variable to point to the next node of the middle node .\\n\\nclass Solution {\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n        ListNode slow = head, fast = head, prev = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head == null || head.next == null) return null;\\n        ListNode slow = head, fast = head, prev = head;\\n        while (fast != null && fast.next != null) {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1619599,
                "title": "python-js-java-cpp-go-o-n-by-two-pointers-w-visualization",
                "content": "O(n) by two-pointers\\n\\n---\\n\\n**Hint**:\\n\\nJust like the way we did in **[Leetcode #876 Middle of the Linked list](https://leetcode.com/problems/middle-of-the-linked-list/)**\\n\\nThink of **two pointers technique** with slow runner and fast runner, also known as **tortoise-and-hare algorithm**.\\n\\nBoth slow runner and fast runner are initialized to head node.\\n\\nEach iteration, **fast** runner moves **two steps forward** while the **slow** one moves **one steps** only.\\n\\nWhen fast runner meets the empty node (i.e., NULL) on the tail, the slow one will be right on the node of midpoint.\\n\\n---\\n\\n**Visualization**\\n\\n![image](https://assets.leetcode.com/users/images/d4b04db6-5aab-478e-ba27-978e619c18a3_1639044881.0230513.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n\\t\\t# dummy head make it easier for us to handle special case on linked list with one node only\\n        dummy_head = ListNode(-1, head)\\n        pre_of_middle,slow, fast = dummy_head, head, head\\n        \\n        # use tortoise-and-hare algorithm to locate the middle node\\n        while fast and fast.next:\\n            \\n            # locate the node before middle node\\n            pre_of_middle = slow\\n            \\n            # tortoise move one step on each round\\n            slow = slow.next\\n            \\n            # hare move two steps on each round\\n            fast = fast.next.next\\n            \\n        \\n        # locate the node after middle node\\n        junction = slow.next\\n        \\n        # update linkage between previous one and next one\\n        pre_of_middle.next = junction\\n        \\n        # delete and release middle node\\n        del slow\\n        \\n        \\n        return dummy_head.next\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar deleteMiddle = function(head) {\\n    \\n    let dummyHead = new ListNode(-1, head);\\n    \\n    let [prevOfMiddle, slow, fast] = [dummyHead, head, head];\\n    \\n    // Use tortoise and hare algorithm to locate the middle node\\n    while( fast != null && fast.next != null ){\\n        \\n        // locate the node before middle node\\n        prevOfMiddle = slow;\\n        \\n        // tortoise moves one step on each round\\n        slow = slow.next;\\n        \\n        // hare mvoves two steps on each round\\n        fast = fast.next.next;\\n    }\\n    \\n    \\n    // locate the node after middle node\\n    let junction = slow.next;\\n    \\n    // update linkage betwen previous one and next node\\n    prevOfMiddle.next = junction;\\n    \\n    // release middle node\\n    slow = null;\\n    \\n    return dummyHead.next;\\n};\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        ListNode dummyHead = new ListNode(-1, head);\\n        \\n        ListNode prevOfMiddle = dummyHead, slow = head, fast = head;\\n        \\n        // Use tortoise and hare algorithm to locate the middle node\\n        while( fast != null && fast.next != null ){\\n            \\n            // locate the node before middle node\\n            prevOfMiddle = slow;\\n            \\n            // tortoise moves one step on each round\\n            slow = slow.next;\\n            \\n            // hare moves two steps on each round\\n            fast = fast.next.next;\\n        }\\n        \\n        // locate the node after middle node\\n        ListNode junction = slow.next;\\n        \\n        // update linkage between previous one and next node\\n        prevOfMiddle.next = junction;\\n        \\n        // release middle node\\n        slow = null;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        ListNode *dummyHead = new ListNode(-1, head);\\n        \\n        ListNode *prevOfMiddle = dummyHead, *slow = head, *fast = head;\\n        \\n        // Use tortoise and hare algorithm to locate the middle node\\n        while( fast != nullptr && fast->next != nullptr ){\\n            \\n            // locate the node before middle node\\n            prevOfMiddle = slow;\\n            \\n            // tortoise moves one step on each round\\n            slow = slow->next;\\n            \\n            // hare moves two steps on each round\\n            fast = fast->next->next;\\n        }\\n        \\n        // locate the node after middle node\\n        ListNode *junction = slow->next;\\n        \\n        // update linkage between previous one and next node\\n        prevOfMiddle->next = junction;\\n        \\n        // release middle node\\n        delete slow;\\n        \\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    \\n    dummyHead := &ListNode{ -1, head}\\n    \\n    prevOfMiddle, slow, fast := dummyHead, head, head\\n    \\n    // Use tortoise and hare algorithm to locate the middle node\\n    for( fast != nil ) && ( fast.Next != nil ) {\\n        \\n        // locate the node before middle node\\n        prevOfMiddle = slow\\n        \\n        // tortoise moves one step on each round\\n        slow = slow.Next\\n        \\n        // hare moves two steps on each round\\n        fast = fast.Next.Next\\n        \\n    }\\n    \\n    \\n    // locate the node after middle node\\n    junction := slow.Next\\n    \\n    // update linkage between previous one and next node\\n    prevOfMiddle.Next = junction\\n    \\n    // release middle node\\n    slow = nil\\n    \\n    \\n    return dummyHead.Next\\n}\\n```\\n\\n---\\n\\n**Related leetcode challenge**:\\n\\n[Leetcode #876 Middle of the Linked list](https://leetcode.com/problems/middle-of-the-linked-list/)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n\\t\\t# dummy head make it easier for us to handle special case on linked list with one node only\\n        dummy_head = ListNode(-1, head)\\n        pre_of_middle,slow, fast = dummy_head, head, head\\n        \\n        # use tortoise-and-hare algorithm to locate the middle node\\n        while fast and fast.next:\\n            \\n            # locate the node before middle node\\n            pre_of_middle = slow\\n            \\n            # tortoise move one step on each round\\n            slow = slow.next\\n            \\n            # hare move two steps on each round\\n            fast = fast.next.next\\n            \\n        \\n        # locate the node after middle node\\n        junction = slow.next\\n        \\n        # update linkage between previous one and next one\\n        pre_of_middle.next = junction\\n        \\n        # delete and release middle node\\n        del slow\\n        \\n        \\n        return dummy_head.next\\n```\n```\\nvar deleteMiddle = function(head) {\\n    \\n    let dummyHead = new ListNode(-1, head);\\n    \\n    let [prevOfMiddle, slow, fast] = [dummyHead, head, head];\\n    \\n    // Use tortoise and hare algorithm to locate the middle node\\n    while( fast != null && fast.next != null ){\\n        \\n        // locate the node before middle node\\n        prevOfMiddle = slow;\\n        \\n        // tortoise moves one step on each round\\n        slow = slow.next;\\n        \\n        // hare mvoves two steps on each round\\n        fast = fast.next.next;\\n    }\\n    \\n    \\n    // locate the node after middle node\\n    let junction = slow.next;\\n    \\n    // update linkage betwen previous one and next node\\n    prevOfMiddle.next = junction;\\n    \\n    // release middle node\\n    slow = null;\\n    \\n    return dummyHead.next;\\n};\\n```\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        ListNode dummyHead = new ListNode(-1, head);\\n        \\n        ListNode prevOfMiddle = dummyHead, slow = head, fast = head;\\n        \\n        // Use tortoise and hare algorithm to locate the middle node\\n        while( fast != null && fast.next != null ){\\n            \\n            // locate the node before middle node\\n            prevOfMiddle = slow;\\n            \\n            // tortoise moves one step on each round\\n            slow = slow.next;\\n            \\n            // hare moves two steps on each round\\n            fast = fast.next.next;\\n        }\\n        \\n        // locate the node after middle node\\n        ListNode junction = slow.next;\\n        \\n        // update linkage between previous one and next node\\n        prevOfMiddle.next = junction;\\n        \\n        // release middle node\\n        slow = null;\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        ListNode *dummyHead = new ListNode(-1, head);\\n        \\n        ListNode *prevOfMiddle = dummyHead, *slow = head, *fast = head;\\n        \\n        // Use tortoise and hare algorithm to locate the middle node\\n        while( fast != nullptr && fast->next != nullptr ){\\n            \\n            // locate the node before middle node\\n            prevOfMiddle = slow;\\n            \\n            // tortoise moves one step on each round\\n            slow = slow->next;\\n            \\n            // hare moves two steps on each round\\n            fast = fast->next->next;\\n        }\\n        \\n        // locate the node after middle node\\n        ListNode *junction = slow->next;\\n        \\n        // update linkage between previous one and next node\\n        prevOfMiddle->next = junction;\\n        \\n        // release middle node\\n        delete slow;\\n        \\n        return dummyHead->next;\\n    }\\n};\\n```\n```\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    \\n    dummyHead := &ListNode{ -1, head}\\n    \\n    prevOfMiddle, slow, fast := dummyHead, head, head\\n    \\n    // Use tortoise and hare algorithm to locate the middle node\\n    for( fast != nil ) && ( fast.Next != nil ) {\\n        \\n        // locate the node before middle node\\n        prevOfMiddle = slow\\n        \\n        // tortoise moves one step on each round\\n        slow = slow.Next\\n        \\n        // hare moves two steps on each round\\n        fast = fast.Next.Next\\n        \\n    }\\n    \\n    \\n    // locate the node after middle node\\n    junction := slow.Next\\n    \\n    // update linkage between previous one and next node\\n    prevOfMiddle.Next = junction\\n    \\n    // release middle node\\n    slow = nil\\n    \\n    \\n    return dummyHead.Next\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739988,
                "title": "c-solution-faster-than-99-66-users-beginner-friendly",
                "content": "``` This question is a variation of finding middle of linked list.```\\n``` Extra work we have done is to keep track of previous node of the middle node.```\\n```\\n ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next==NULL)\\n            return NULL;                      // If the linked list have only one node ar empty then delete the node and return NULL.\\n        ListNode* slow = head;\\n        ListNode* prev = head;\\n        ListNode* fast = head;\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            prev=slow;         // Before moving slow to next pointer we have assigned it to previous node which keeps track of previous node.\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n          prev->next=slow->next;    // Deleting the middle node of the linked list.\\n        return head;\\n    }\\n```\\n``` If you like my approach then hit the like button.```",
                "solutionTags": [],
                "code": "``` This question is a variation of finding middle of linked list.```\n``` Extra work we have done is to keep track of previous node of the middle node.```\n```\\n ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next==NULL)\\n            return NULL;                      // If the linked list have only one node ar empty then delete the node and return NULL.\\n        ListNode* slow = head;\\n        ListNode* prev = head;\\n        ListNode* fast = head;\\n        while(fast != NULL && fast -> next != NULL)\\n        {\\n            prev=slow;         // Before moving slow to next pointer we have assigned it to previous node which keeps track of previous node.\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n          prev->next=slow->next;    // Deleting the middle node of the linked list.\\n        return head;\\n    }\\n```\n``` If you like my approach then hit the like button.```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221810,
                "title": "one-time-pass-slow-ans-fast-c-5-line-code",
                "content": "```\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next == NULL)return NULL;\\n        ListNode *p = head,*q=head,*x;\\n        while(q&&q->next){\\n            x = p;\\n            p = p->next;\\n            q = q->next->next;\\n        }\\n        x->next = x->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next == NULL)return NULL;\\n        ListNode *p = head,*q=head,*x;\\n        while(q&&q->next){\\n            x = p;\\n            p = p->next;\\n            q = q->next->next;\\n        }\\n        x->next = x->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700864,
                "title": "java-99-faster-code-easy-solution-beginner-friendly",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic ListNode deleteMiddle(ListNode head) {\\n\\n ListNode primary=head;\\n ListNode secondary=head;\\n ListNode prev=head;\\n\\n while(primary!=null && primary.next!=null){\\n     prev=secondary;\\n     primary=primary.next.next;\\n     secondary=secondary.next;\\n }\\n if(prev.next!=null){\\n prev.next=prev.next.next;\\n }\\n if(primary==secondary){\\n     head=null;\\n }\\n //System.out.println(prev.next.val);\\n return head;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic ListNode deleteMiddle(ListNode head) {\\n\\n ListNode primary=head;\\n ListNode secondary=head;\\n ListNode prev=head;\\n\\n while(primary!=null && primary.next!=null){\\n     prev=secondary;\\n     primary=primary.next.next;\\n     secondary=secondary.next;\\n }\\n if(prev.next!=null){\\n prev.next=prev.next.next;\\n }\\n if(primary==secondary){\\n     head=null;\\n }\\n //System.out.println(prev.next.val);\\n return head;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145979,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nNaive Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> Two Traversal\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head->next == NULL)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }  \\n        curr = head;\\n        for (int i = 1; i < count / 2; i++)\\n            curr = curr->next;  \\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\\n\\n# Approach 2\\nSlow and Fast Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> One Traversal\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head->next == NULL)\\n            return NULL;\\n        ListNode* slow = head, * fast = head, * prev = NULL;\\n        while (fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = slow->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head->next == NULL)\\n            return NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while (curr != NULL) {\\n            count++;\\n            curr = curr->next;\\n        }  \\n        curr = head;\\n        for (int i = 1; i < count / 2; i++)\\n            curr = curr->next;  \\n        curr->next = curr->next->next;\\n        return head;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head->next == NULL)\\n            return NULL;\\n        ListNode* slow = head, * fast = head, * prev = NULL;\\n        while (fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        prev->next = slow->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701746,
                "title": "c-don-t-be-that-person-that-leaks-memory-clean-code",
                "content": "### Approach 1: fast and slow pointer\\n\\nUsing a ```fast``` and ```slow``` pointer we find the middle node, or actually the node before the middle node and remove it from the list, and looking how [leetcode framework / runtime generated linked lists ](https://leetcode.com/playground/kXn5Ro9P) we should free the memory for the node we are removing, i.e. stop leaks! To avoid a special case if the list has only zero or one node we use a ```prehead```. Instead of ```fast``` we could have used ```head```.\\n\\n```cpp\\n    static ListNode* deleteMiddle(ListNode* head) {\\n        ListNode prehead(0, head);\\n        ListNode* fast = head;\\n        ListNode* slow = &prehead;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode* next = slow->next;\\n        if (next) {  // This is only needed for empty lists, which can\\'t happen for this problem.\\n            slow->next = next->next;\\n            // Stop leaks! Don\\'t be the person than ... :)\\n            delete next;\\n        }\\n        return prehead.next;\\n    }\\n```\\n\\nAs outline in [this post](https://leetcode.com/problems/delete-node-in-a-linked-list/discuss/2696260/c-dont-be-that-person-that-leaks-memory-clean-code) we could also use ```std::unique_ptr``` to free the node we delete, i.e. replace:\\n\\n```cpp\\n        ListNode* next = slow->next;\\n        slow->next = next->next;\\n        // Stop leaks! Don\\'t be the person than ... :)\\n        delete next;\\n```\\n\\nwith\\n\\n```cpp\\n        std::unique_ptr<ListNode> to_be_deleted(slow->next);\\n        slow->next = slow->next->next;\\n```\\n\\nNot quite sure what\\'s better here. Do you have an opinion?\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(n)$$ as we need to traverse the entire list.\\n  * Space complexity: $$O(1)$$ nothing to see here.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```fast```\n```slow```\n```prehead```\n```fast```\n```head```\n```cpp\\n    static ListNode* deleteMiddle(ListNode* head) {\\n        ListNode prehead(0, head);\\n        ListNode* fast = head;\\n        ListNode* slow = &prehead;\\n        while (fast && fast->next) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode* next = slow->next;\\n        if (next) {  // This is only needed for empty lists, which can\\'t happen for this problem.\\n            slow->next = next->next;\\n            // Stop leaks! Don\\'t be the person than ... :)\\n            delete next;\\n        }\\n        return prehead.next;\\n    }\\n```\n```std::unique_ptr```\n```cpp\\n        ListNode* next = slow->next;\\n        slow->next = next->next;\\n        // Stop leaks! Don\\'t be the person than ... :)\\n        delete next;\\n```\n```cpp\\n        std::unique_ptr<ListNode> to_be_deleted(slow->next);\\n        slow->next = slow->next->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701580,
                "title": "c-tortoise-method-delete-node-intuitive-solution",
                "content": "**It is the small modification of the following 2 problems :**\\n\\n**----------------------------------------------------------------------**\\n##### [Find the middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) : **Tortoise Method** \\n##### [Delete Node in Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/) : **2 Line Solution** \\n\\n**----------------------------------------------------------------------**\\n\\n```\\nListNode* deleteMiddle(ListNode* head) {\\n        if( !head || !head -> next ) return NULL ;\\n        \\n        // Since we do not access the members within null pointers\\n        ListNode* slow = new ListNode(0) ;\\n        ListNode* fast = slow ;\\n        \\n        slow -> next = head ;\\n        fast -> next = head ;\\n        \\n        // Find the middle of the linked list : Tortoise Method \\n        while( fast->next && fast->next->next ){\\n            slow = slow -> next ;\\n            fast = fast -> next -> next ;\\n        }\\n        \\n        // Delete a node in a Linked list \\n        slow -> next = slow -> next -> next ;\\n        \\n        // return the modified Linked list \\n        return head ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* deleteMiddle(ListNode* head) {\\n        if( !head || !head -> next ) return NULL ;\\n        \\n        // Since we do not access the members within null pointers\\n        ListNode* slow = new ListNode(0) ;\\n        ListNode* fast = slow ;\\n        \\n        slow -> next = head ;\\n        fast -> next = head ;\\n        \\n        // Find the middle of the linked list : Tortoise Method \\n        while( fast->next && fast->next->next ){\\n            slow = slow -> next ;\\n            fast = fast -> next -> next ;\\n        }\\n        \\n        // Delete a node in a Linked list \\n        slow -> next = slow -> next -> next ;\\n        \\n        // return the modified Linked list \\n        return head ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700474,
                "title": "rust-two-pass-safe-rust-w-explanation-beats-100",
                "content": "You **cannot** do a one-pass, two-pointer solution in safe Rust.\\n\\nThe non-Rust way to do this would be to have a \"slow\" pointer pointing the element *before* you want to delete, and a \"fast\" pointer ahead of it on the linked list that you step forward twice as much. The \"slow\" pointer would need to be mutable, so that you could modify the \"next\" pointer of the box when you get there.\\n\\nBut! In Rust, a mutable pointer has the fundamental right to *drop the rest of the list at any time*, by overriding the \"next\" pointer of its node and triggering a cascading Box.drop() over the rest of the list. And if that were to happen, the \"fast\" pointer would be dangling. You can do this in a garbage-collected language because the GC guarantees the fast pointer will be valid always; and you can do it in C/C++ because those languages let you do wildly unsafe things, but Rust *will not let you do this* in safe code, nor should it.\\n\\nYou can implement this in unsafe Rust, and it would be valid to do so provided that you don\\'t do anything stupid. Probably the easiest way would be to maneuver immutable fast/slow pointers along the list, drop the fast pointer, and then unsafely cast the immutable slow pointer to a mutable pointer. \\n\\nHowever, practically speaking, there is little to no benefit to doing a one-pass solution. The only time-consuming part of the process is dereferencing each successive pointer--and a slow/fast pointer solution over an n-element list requires n+n/2 dereferences. That\\'s exactly as many as it takes with a two-pass solution! n to count the length of the list with an immutable pointer, and n/2 to move a mutable pointer halfway along the list.\\n\\nSo just do two passes, keep your code 100% safe, and get better runtime anyway.\\n\\n```\\nimpl Solution {\\n    pub fn delete_middle(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if let None = head {\\n            return None;\\n        }\\n        \\n        let mut num_nodes: usize = 1;\\n        let mut ptr = head.as_ref().unwrap().as_ref();\\n        while let Some(boxed_node) = ptr.next.as_ref() {\\n            ptr = boxed_node.as_ref();\\n            num_nodes += 1;\\n        }\\n        \\n        if num_nodes == 1 {\\n            return None;\\n        }\\n        \\n        let mut base: &mut ListNode = head.as_mut().unwrap().as_mut();\\n        for _ in (0..(num_nodes>>1)-1) {\\n            base = base.next.as_mut().unwrap().as_mut();\\n        }\\n        \\n        base.next = base.next.as_mut().unwrap().as_mut().next.take();\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn delete_middle(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if let None = head {\\n            return None;\\n        }\\n        \\n        let mut num_nodes: usize = 1;\\n        let mut ptr = head.as_ref().unwrap().as_ref();\\n        while let Some(boxed_node) = ptr.next.as_ref() {\\n            ptr = boxed_node.as_ref();\\n            num_nodes += 1;\\n        }\\n        \\n        if num_nodes == 1 {\\n            return None;\\n        }\\n        \\n        let mut base: &mut ListNode = head.as_mut().unwrap().as_mut();\\n        for _ in (0..(num_nodes>>1)-1) {\\n            base = base.next.as_mut().unwrap().as_mut();\\n        }\\n        \\n        base.next = base.next.as_mut().unwrap().as_mut().next.take();\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700439,
                "title": "java-easy-solution-two-pointer-slow-fast-simple",
                "content": "IF YOU LIKE THE SOLUTION \\nMAKE SURE TO UPVOTE IT!\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        //Explictly Handle for onely 1 node\\n        if(head.next == null) return null;\\n        // For only 2 node , delete the second node and return head\\n        if(head.next.next == null) {\\n            head.next = null;\\n            return head;\\n        }\\n        // We use two pointers one is fast and other is slow\\n        //slow gonna move one step and fast gonna move two step at a time\\n        // When fast becomes null , slow is at the node which we have to delete.\\n        ListNode slow = head, fast = head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // just swap the values of slow with the slow\\'s next node and delete the next node.\\n        // slow.next.val is always != null \\n        slow.val = slow.next.val;\\n        slow.next = slow.next.next;\\n        // Finallly return original head.\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        //Explictly Handle for onely 1 node\\n        if(head.next == null) return null;\\n        // For only 2 node , delete the second node and return head\\n        if(head.next.next == null) {\\n            head.next = null;\\n            return head;\\n        }\\n        // We use two pointers one is fast and other is slow\\n        //slow gonna move one step and fast gonna move two step at a time\\n        // When fast becomes null , slow is at the node which we have to delete.\\n        ListNode slow = head, fast = head;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        // just swap the values of slow with the slow\\'s next node and delete the next node.\\n        // slow.next.val is always != null \\n        slow.val = slow.next.val;\\n        slow.next = slow.next.next;\\n        // Finallly return original head.\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125878,
                "title": "c-bestapproach-easytounderstand",
                "content": "```\\nListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL)\\n            return NULL;\\n        ListNode *fast=head,*slow=head,*prev=head;;\\n        while(fast && fast->next){\\n            prev = slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        prev->next=prev->next->next;\\n        delete slow;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL)\\n            return NULL;\\n        ListNode *fast=head,*slow=head,*prev=head;;\\n        while(fast && fast->next){\\n            prev = slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        prev->next=prev->next->next;\\n        delete slow;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1671915,
                "title": "c-slow-and-fast-pointer-solution-easy-and-short",
                "content": "Please upvote if you liked this solution or found it useful.\\nFor any clarifications, suggestions or doubts please comment down below.\\n\\n__Approach:__\\n(_Please use multiple examples and dry run this algorithm/code to fully understand_)\\n1. We will first place a pointer called __slow__ at the __head__ of the linked list and __fast__ at __head->next__ (In the special case where __fast == NULL__ simply return __NULL__ as the linked list has only 1 node if that happens)\\n2. Iterate as __slow = slow->next__ and __fast = fast->next->next__ as long as __fast->next != NULL__ && __fast->next->next!=NULL__\\n3. Finally when the loop breaks, __slow__ will be to the left of the node to be deleted. \\n4. Perform __slow->next = slow->next->next__ in order to delete the node just after __slow__\\n\\n__Code:__\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = slow->next;\\n        \\n        if(fast==nullptr)\\n            return nullptr;\\n        \\n        while(fast->next!=nullptr && fast->next->next!=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n``` \\n\\n__Complexity__\\n* Time : O(size_of_list) = O(n)\\n* Space : O(constant) = O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = slow->next;\\n        \\n        if(fast==nullptr)\\n            return nullptr;\\n        \\n        while(fast->next!=nullptr && fast->next->next!=nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        slow->next = slow->next->next;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984365,
                "title": "java-solution-super-easy-approach-video-solution",
                "content": "# Please watch this solution video for clear understanding :-\\nhttps://youtu.be/7Qe_hatrbRY?si=7upTQ94oN6E2dZ7d \\n# Approach\\nThis question is just one step ahead of leetcode question 876 [ find middle node of linkedlist ].\\nFirstly find the middle node , (by two pointer approach).\\nthen , in previous node of middle node give reference for next node of middle instead of middle node .\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) \\n    {\\n        if(head.next == null)\\n        {\\n            return null ;\\n        }\\n       []()\\n        ListNode slow = head ;\\n        ListNode fast = head ;\\n        ListNode prev = null ;\\n        while(fast!= null && fast.next != null)\\n        {\\n            prev = slow ;\\n            slow = slow.next ;\\n            fast = fast.next.next ;\\n\\n        }\\n        prev.next = slow.next ;\\n        return head ; \\n        \\n    }\\n}\\n```\\n# If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.\\n# wish you the best  !",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) \\n    {\\n        if(head.next == null)\\n        {\\n            return null ;\\n        }\\n       []()\\n        ListNode slow = head ;\\n        ListNode fast = head ;\\n        ListNode prev = null ;\\n        while(fast!= null && fast.next != null)\\n        {\\n            prev = slow ;\\n            slow = slow.next ;\\n            fast = fast.next.next ;\\n\\n        }\\n        prev.next = slow.next ;\\n        return head ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732937,
                "title": "easy-and-efficient-solution",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to delete the middle node of a linked list. To accomplish this, we need to identify the middle node by counting the number of nodes in the list and then skip over the middle node by adjusting the next pointers.\\n\\n# Approach\\n1. First, we check if the head of the linked list is null or if there is only one node in the list. In these cases, there is no middle node to delete, so we return null.\\n1. We initialize a count variable to keep track of the number of nodes and a temporary node to traverse the list.\\n1. We iterate through the linked list and increment the count for each node until we reach the end.\\n1. After counting the number of nodes, we reset the temporary node to the head and calculate the index of the middle node by dividing the count by 2.\\n1. We traverse the list again, this time stopping at the node just before the middle node by decrementing the count until it reaches 0.\\n1. Finally, we skip the middle node by adjusting the next pointers, connecting the previous node to the node after the middle node.\\n1. We return the head of the modified linked list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is $$O(n)$$, where n is the number of nodes in the linked list. This is because we need to traverse the entire list twice: once to count the nodes and once to delete the middle node.\\n\\n- Space complexity:\\nThe space complexity of the solution is $$O(1)$$ because we are not using any additional data structures that grow with the input size. We only use a constant amount of space to store variables.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if (head == null || head.next == null)\\n            return null;  // No middle node to delete if head is null or there is only one node\\n\\n        int count = 0;  // Variable to count the number of nodes\\n        ListNode temp = head;\\n\\n        // Count the number of nodes in the list\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        temp = head;\\n        count = count / 2;  // Calculate the index of the middle node\\n\\n        // Traverse to the node just before the middle node\\n        while (--count != 0) {\\n            temp = temp.next;\\n        }\\n\\n        // Skip the middle node and connect the previous node to the node after the middle node\\n        temp.next = temp.next.next;\\n\\n        return head;\\n    }\\n}\\n```\\n\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/3d6e7b11-6525-4f3a-a9ee-53fc6bcd0fbc_1688743812.1946359.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java []\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if (head == null || head.next == null)\\n            return null;  // No middle node to delete if head is null or there is only one node\\n\\n        int count = 0;  // Variable to count the number of nodes\\n        ListNode temp = head;\\n\\n        // Count the number of nodes in the list\\n        while (temp != null) {\\n            count++;\\n            temp = temp.next;\\n        }\\n\\n        temp = head;\\n        count = count / 2;  // Calculate the index of the middle node\\n\\n        // Traverse to the node just before the middle node\\n        while (--count != 0) {\\n            temp = temp.next;\\n        }\\n\\n        // Skip the middle node and connect the previous node to the node after the middle node\\n        temp.next = temp.next.next;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448855,
                "title": "python-simple-clean-code-using-slow-and-fast-pointer",
                "content": "# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        slow = head\\n        fast = head\\n        prev = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = slow.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        slow = head\\n        fast = head\\n        prev = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        prev.next = slow.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833467,
                "title": "easy-c-approach-using-fast-and-slow-pointer",
                "content": "\\n# Approach\\n**2 pointer (fast and slow) approach** \\n\\nWe are creating another node N which will keep track of the current slow pointer,there are two cases to come out of the while loop .\\n\\n**Case 1**:The first condition in while loop becomes false that is fast=NULL; in this the slow pointer is exactly at the node which we want to delete and the node n will be at a node before the node to be deleted , hence we make the connection between node n and next of slow pointer and delete slow to avoid memory leak.\\n\\n**Case 2**:The second condition ,fast->next pointer becomes NULL and hence the condition is false so we exit the loop, in this scenario the slow pointer will be exactly at the previous node which we want to delete . So we create another ListNode which will store the node to be deleted , we establish a link between our slow pointer and next of the node to be deleted and after that we delete the node to avoid memory leak (It doesnt really matters on online platforms).\\n\\n**NOTE**-If you apply the same approach and in the while condition block write \\nwhile(fast->next && fast) \\nOR change th order of checking i.e\\nif(fast->next==NULL) before if(fast==NULL) you will encounter runtime error becase at that point you are accessing NULL.\\n# Complexity\\n- Time complexity: O(n/2) ~= O(n)\\n**Runtime beats 80.21% of total submission** \\n\\n- Space complexity: O(1)\\n**Memory 294.9mb beats 44% of total submissions**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next) return NULL; // If next of head is NULL then we are deleting the first and the only node in LinkedList.\\n        ListNode* slow=head;    //slow ptr will be at head\\n        ListNode* fast=head->next;   //fast ptr will be at next of head\\n        ListNode* n=NULL;\\n        while(fast && fast->next)\\n        {\\n            n=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n        // after the loop there will be two cases as mentioned\\n        if(fast==NULL) //it means the list is of odd size and slow pointer is at the node to be deleted.\\n        {\\n            ListNode* m=slow->next;\\n            n->next=m;\\n            delete slow;\\n            return head;\\n        }\\n        if(fast->next==NULL) //this means the list is of even size and slow pointer is exactly at a node before the node to be deleted\\n        {\\n            ListNode* m=slow->next;\\n            slow->next=m->next;\\n            delete m;\\n            return head;\\n        }\\n        return head;   \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next) return NULL; // If next of head is NULL then we are deleting the first and the only node in LinkedList.\\n        ListNode* slow=head;    //slow ptr will be at head\\n        ListNode* fast=head->next;   //fast ptr will be at next of head\\n        ListNode* n=NULL;\\n        while(fast && fast->next)\\n        {\\n            n=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n        // after the loop there will be two cases as mentioned\\n        if(fast==NULL) //it means the list is of odd size and slow pointer is at the node to be deleted.\\n        {\\n            ListNode* m=slow->next;\\n            n->next=m;\\n            delete slow;\\n            return head;\\n        }\\n        if(fast->next==NULL) //this means the list is of even size and slow pointer is exactly at a node before the node to be deleted\\n        {\\n            ListNode* m=slow->next;\\n            slow->next=m->next;\\n            delete m;\\n            return head;\\n        }\\n        return head;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703133,
                "title": "easy-solution-with-explaination-c-100-beatsl",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1)Initialize two-pointers (slow and fast) with linked list head pointer.\\n2)Iterate over the linked list until the fast pointer reaches the end.\\n3)Move the slow pointer to one next node.\\n4)Move the fast pointer to the next node of the next node.\\n5)Return the head pointer\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n         if (head->next == NULL) {\\n      delete head;\\n      return NULL;\\n   }\\n   ListNode* slow_ptr = head;\\n   ListNode* fast_ptr = head;\\n   ListNode* prev;\\n   while (fast_ptr != NULL && fast_ptr->next != NULL) {\\n      fast_ptr = fast_ptr->next->next;\\n      prev = slow_ptr;\\n      slow_ptr = slow_ptr->next;\\n   }\\n   prev->next = slow_ptr->next;\\n   delete slow_ptr;\\n   return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL){\\n            return NULL;\\n        }\\n         if (head->next == NULL) {\\n      delete head;\\n      return NULL;\\n   }\\n   ListNode* slow_ptr = head;\\n   ListNode* fast_ptr = head;\\n   ListNode* prev;\\n   while (fast_ptr != NULL && fast_ptr->next != NULL) {\\n      fast_ptr = fast_ptr->next->next;\\n      prev = slow_ptr;\\n      slow_ptr = slow_ptr->next;\\n   }\\n   prev->next = slow_ptr->next;\\n   delete slow_ptr;\\n   return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701487,
                "title": "python-c-java-beast-98-simple-short-solution-easy-one-pass",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2095. Delete the Middle Node of a Linked List***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next: return None\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow.next = slow.next.next\\n        return head \\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n       if(head.next==null)\\n            return null;\\n        ListNode fast=head,slow=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n     ListNode* deleteMiddle(ListNode* head) {\\n\\t\\t   if(head->next==nullptr) return nullptr;\\n\\t\\t   ListNode *fast=head;\\n\\t\\t   ListNode *slow=head,*prev;\\n\\t\\t  while(fast!=nullptr && fast->next!=nullptr){\\n\\t\\t\\t  fast=fast->next->next;\\n\\t\\t\\t  prev=slow;\\n\\t\\t\\t  slow=slow->next;\\n\\t\\t  }\\n\\t\\tprev->next=prev->next->next;\\n\\t\\treturn head;\\n\\t}\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next: return None\\n        slow, fast = head, head.next.next\\n        while fast and fast.next:\\n            slow = slow.next\\n            fast = fast.next.next\\n        slow.next = slow.next.next\\n        return head \\n```\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n       if(head.next==null)\\n            return null;\\n        ListNode fast=head,slow=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n     ListNode* deleteMiddle(ListNode* head) {\\n\\t\\t   if(head->next==nullptr) return nullptr;\\n\\t\\t   ListNode *fast=head;\\n\\t\\t   ListNode *slow=head,*prev;\\n\\t\\t  while(fast!=nullptr && fast->next!=nullptr){\\n\\t\\t\\t  fast=fast->next->next;\\n\\t\\t\\t  prev=slow;\\n\\t\\t\\t  slow=slow->next;\\n\\t\\t  }\\n\\t\\tprev->next=prev->next->next;\\n\\t\\treturn head;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700907,
                "title": "two-pointer-using-two-method-slow-and-fast-pointer-size-of-linked-list",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n // first calculate the size the linked list. then delete the size/2 th index of linked list \\n    //     ListNode * temp=head;\\n    //     int size=0;\\n    //     while(temp){\\n    //         temp=temp->next;\\n    //         size++;\\n    //     }\\n    //      int i=0;\\n    //      temp=head;\\n    //      while(i<size/2-1){\\n    //          temp=temp->next;\\n    //          i++;\\n    //      }\\n    //      if(size==1){\\n    //          return NULL;\\n    //      }\\n    //      if(temp->next and temp->next->next){\\n    //          temp->next=temp->next->next;\\n    //      }\\n    //      else\\n    //      temp->next=NULL;\\n        \\n    //      return head;\\n    // }\\n // by using slow and fast pointer. when fast reaches end of the linked list . slow pointer is on the half of the linked list.\\n           ListNode *slow =head;\\n           ListNode * fast=head;\\n           ListNode * prev=head;\\n           if(head==NULL){\\n               return NULL;\\n           }\\n           if(head->next==NULL){\\n               return NULL;\\n           }\\n           while(fast!=NULL and fast->next!=NULL){\\n               if(slow!=head){\\n                   prev=prev->next;\\n               }\\n                   fast=fast->next->next;\\n                   slow=slow->next;\\n           }\\n\\n             prev->next=slow->next;\\n             return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n // first calculate the size the linked list. then delete the size/2 th index of linked list \\n    //     ListNode * temp=head;\\n    //     int size=0;\\n    //     while(temp){\\n    //         temp=temp->next;\\n    //         size++;\\n    //     }\\n    //      int i=0;\\n    //      temp=head;\\n    //      while(i<size/2-1){\\n    //          temp=temp->next;\\n    //          i++;\\n    //      }\\n    //      if(size==1){\\n    //          return NULL;\\n    //      }\\n    //      if(temp->next and temp->next->next){\\n    //          temp->next=temp->next->next;\\n    //      }\\n    //      else\\n    //      temp->next=NULL;\\n        \\n    //      return head;\\n    // }\\n // by using slow and fast pointer. when fast reaches end of the linked list . slow pointer is on the half of the linked list.\\n           ListNode *slow =head;\\n           ListNode * fast=head;\\n           ListNode * prev=head;\\n           if(head==NULL){\\n               return NULL;\\n           }\\n           if(head->next==NULL){\\n               return NULL;\\n           }\\n           while(fast!=NULL and fast->next!=NULL){\\n               if(slow!=head){\\n                   prev=prev->next;\\n               }\\n                   fast=fast->next->next;\\n                   slow=slow->next;\\n           }\\n\\n             prev->next=slow->next;\\n             return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402560,
                "title": "fast-and-slow-pointer-technique-java-solution",
                "content": "***Do UPVOTE GUYS!! IT MOTIVATES ME A LOT!!***\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slowPrev = null;\\n        while(fast != null && fast.next != null){\\n            slowPrev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }  \\n        \\n        slowPrev.next = slow.next;\\n        return head;\\n    }\\n\\t// DON\\'T FORGET TO UPVOTE SOLUTION\\n}\\n```\\n# UPVOTE\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null) return null;\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slowPrev = null;\\n        while(fast != null && fast.next != null){\\n            slowPrev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }  \\n        \\n        slowPrev.next = slow.next;\\n        return head;\\n    }\\n\\t// DON\\'T FORGET TO UPVOTE SOLUTION\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351752,
                "title": "c-two-pointers",
                "content": "```\\nListNode* deleteMiddle(ListNode* head) {\\n\\n        ListNode*newnode=new ListNode(0);\\n        newnode->next=head;\\n        head=newnode;\\n        ListNode*slow=head,*fast=head->next;\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        slow->next=slow->next->next;\\n        return head->next;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nListNode* deleteMiddle(ListNode* head) {\\n\\n        ListNode*newnode=new ListNode(0);\\n        newnode->next=head;\\n        head=newnode;\\n        ListNode*slow=head,*fast=head->next;\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        slow->next=slow->next->next;\\n        return head->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2223907,
                "title": "c-faster-than-87-clean-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return NULL;\\n        \\n        ListNode *slow=head, *fast=head, *prev=NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        prev->next=slow->next;\\n        delete slow;\\n        return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!***\\n\\t\\n\\tListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return NULL;\\n        \\n        ListNode *slow=head, *fast=head, *prev=NULL;\\n        while(fast!=NULL && fast->next!=NULL){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        prev->next=slow->next;\\n        delete slow;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1946682,
                "title": "c-two-pointer-with-explanation",
                "content": "**Approch** : Instead of going to calculate the length of LL and divide it by 2, we can take two Pointers and Iterate over the LL.\\n\\n**Step 1** **:** Take 2 Pointers namely **Slow** and **Fast** and fixed **Slow at Head** and **Fast at Head->next.**\\n\\n**Step 2 :** Now Iterate Pointers Untill **Fast -> next != NULL** and **Slow** will be Move **1 step ahead** where **Fast** will Move **2 step ahead.**\\n\\n**->** At the end **Slow will be reached at Previous Position of Which Node to be Removed.**\\n\\n**Complexity Analysis -:**\\n**T.C** = O(n) (where n is Length of LL)\\n**S.C** = O(1)\\n\\n**Solution:**\\n```\\nListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        \\n        while(fast -> next != NULL && fast -> next -> next != NULL)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        \\n        ListNode* curr = slow;\\n        curr -> next = curr -> next -> next; // connect Node\\n        \\n        return head;\\n    }\\n```\\n*********************** *********Guys If You Like it Then Plzz Plzz Upvote it\\uD83D\\uDE0A*********************************",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        \\n        while(fast -> next != NULL && fast -> next -> next != NULL)\\n        {\\n            slow = slow -> next;\\n            fast = fast -> next -> next;\\n        }\\n        \\n        ListNode* curr = slow;\\n        curr -> next = curr -> next -> next; // connect Node\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832605,
                "title": "javascript-solution-two-pointer-fast-slow",
                "content": "Edge Case: Single node list\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n// Two Pointer: Fast & Slow | O(N) | O(1)\\nvar deleteMiddle = function(head) {\\n  if (!head.next) return null;\\n  \\n  let prev = head;\\n  let slow = head;  \\n  let fast = head.next;\\n  let size = 2;\\n  \\n  while (fast && fast.next) {\\n    prev = slow;\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    size += fast ? 2 : 1;\\n  }\\n  \\n  if (size % 2 === 0) slow.next = slow.next.next;\\n  else prev.next = slow.next;\\n  \\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\n// Two Pointer: Fast & Slow | O(N) | O(1)\\nvar deleteMiddle = function(head) {\\n  if (!head.next) return null;\\n  \\n  let prev = head;\\n  let slow = head;  \\n  let fast = head.next;\\n  let size = 2;\\n  \\n  while (fast && fast.next) {\\n    prev = slow;\\n    slow = slow.next;\\n    fast = fast.next.next;\\n    size += fast ? 2 : 1;\\n  }\\n  \\n  if (size % 2 === 0) slow.next = slow.next.next;\\n  else prev.next = slow.next;\\n  \\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700913,
                "title": "javascript-3-pointer-o-n-time-complexity-o-1-space-complexity",
                "content": "```\\nvar deleteMiddle = function(head) {\\n    if (head.next === null) return null;\\n    \\n    let prev = null;\\n    let slow = head;\\n    let fast = head;\\n    \\n    while(fast && fast.next) {\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    prev.next = slow?.next;\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteMiddle = function(head) {\\n    if (head.next === null) return null;\\n    \\n    let prev = null;\\n    let slow = head;\\n    let fast = head;\\n    \\n    while(fast && fast.next) {\\n        prev = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n    \\n    prev.next = slow?.next;\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1633655,
                "title": "java-easiest-understandable-and-fast-solution-code",
                "content": "Easy, fast and understandable Java code\\nfor deleting the middle node of the linked list\\n\\n\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) \\n    {   \\n\\t\\n        if(head==null || head.next==null)           // if list contains 0 or 1 node\\n            return null;\\n        \\n        ListNode fast=head.next.next;\\n        ListNode slow=head;\\n        \\n        while(fast!=null && fast.next!=null)  // to get the node before the middle node\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        \\n        slow.next=slow.next.next;       //now connect the node before the middle node and after the middle node\\n        \\n        return head;\\n    }\\n}\\n\\n******\\nPLEASE UPVOTE THIS SOLUTION IF YOU FIND IT EASY**",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) \\n    {   \\n\\t\\n        if(head==null || head.next==null)           // if list contains 0 or 1 node\\n            return null;\\n        \\n        ListNode fast=head.next.next;\\n        ListNode slow=head;\\n        \\n        while(fast!=null && fast.next!=null)  // to get the node before the middle node\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4049056,
                "title": "easy-solution-beginner-friendly-solution-beats-99-89-c",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp)\\n        {\\n            c++;\\n            temp=temp->next;\\n        }\\n        temp=head;\\n        int k=0;\\n        int l=0;\\n        if(c%2!=0)\\n        {\\n            l=c/2-1;\\n        }\\n        else\\n        {\\n            l=c/2;\\n            l=l-1;\\n        }\\n        if(c==2)\\n        {\\n            head->next=NULL;\\n            return head;\\n        }\\n        if(c==1)\\n        {\\n            return NULL;\\n        }\\n        while(temp->next)\\n        {\\n            if(k==l)\\n            {\\n                temp->next=temp->next->next;\\n                return head;\\n            }\\n            temp=temp->next;\\n            k++;\\n        }\\n        return head;\\n\\n    }\\n};\\n```\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/808f484f-efe0-4f85-b0b4-9dc0b610c91f_1694804849.9722733.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* temp=head;\\n        int c=0;\\n        while(temp)\\n        {\\n            c++;\\n            temp=temp->next;\\n        }\\n        temp=head;\\n        int k=0;\\n        int l=0;\\n        if(c%2!=0)\\n        {\\n            l=c/2-1;\\n        }\\n        else\\n        {\\n            l=c/2;\\n            l=l-1;\\n        }\\n        if(c==2)\\n        {\\n            head->next=NULL;\\n            return head;\\n        }\\n        if(c==1)\\n        {\\n            return NULL;\\n        }\\n        while(temp->next)\\n        {\\n            if(k==l)\\n            {\\n                temp->next=temp->next->next;\\n                return head;\\n            }\\n            temp=temp->next;\\n            k++;\\n        }\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840762,
                "title": "two-pointers-approach-explained-easy-to-understand-clean-codes-java-c",
                "content": "\\n# Approach\\nTo delete the middle node of a linked list, you can use the two-pointer technique. One pointer will traverse the linked list one node at a time, and the other pointer will advance two nodes at a time. This way, when the faster pointer reaches the end of the list, the slower pointer will be at the middle node.\\nThe given Java function deleteMiddle takes the head of a linked list as input and aims to delete the middle node of the linked list. It uses the two-pointer technique to find the middle node and then proceeds to delete it.\\n\\nLet\\'s break down the code step by step:\\n\\n1. The function starts by creating three ListNode pointers: slow, fast, and prev, all initially pointing to the head of the linked list.\\n\\n2. Two base cases are checked to handle edge scenarios:\\n\\n- If the input head is null, indicating an empty linked list, the function returns null since there is nothing to delete.\\n- If the linked list contains only one node (head.next is null), the function also returns null since a single node doesn\\'t have a middle node to delete.\\n3. The function proceeds to use the two-pointer technique within a while loop to find the middle node:\\n\\n- slow moves one step at a time, while fast moves two steps at a time through the linked list. This causes fast to reach the end (or the last node) of the list when slow reaches the middle node.\\n4. Inside the loop, an additional check if (slow != head) is used to ensure that prev stays one node behind slow, except when slow is at the head. This is to handle the case where the linked list has an odd number of nodes. If it\\'s even, prev will lag one node behind the middle node, and it will be the node right before the middle node.\\n\\n5. Once the loop completes, slow points to the middle node, and prev points to the node before it.\\n\\n6. Now, the function performs the deletion by setting prev.next to slow.next. This effectively bypasses the middle node, removing it from the linked list.\\n\\n7. Finally, the function returns the modified head of the linked list.\\n\\n**This function handles both odd and even-length linked lists correctly. If the linked list has an even number of nodes, it deletes the second node from the middle. If the linked list has an odd number of nodes, it deletes the middle node directly.**\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(N), where N is the number of nodes in the linked list. The two-pointer technique, with one pointer moving one step at a time and the other pointer moving two steps at a time, takes approximately N/2 iterations to find the middle node. Since the constant factor is dropped in big O notation, the time complexity is O(N).\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1) because it uses a constant amount of additional space regardless of the size of the input linked list. It only uses three ListNode pointers (slow, fast, and prev), which do not depend on the size of the linked list. Therefore, the space complexity is constant, or O(1).\\n\\n---\\n\\n\\n# Code\\n```Java []\\n\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head)\\n     {\\n        ListNode slow=head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n\\n        if(head==null){\\n               return null;\\n           }\\n           if(head.next==null){\\n               return null;\\n           }\\n    \\n        while(fast!=null && fast.next!=null)\\n        {\\n            if(slow!=head)\\n            {\\n                prev=prev.next;\\n            }\\n            slow=slow.next;\\n            fast=fast.next.next;\\n\\n        }\\n        prev.next=slow.next;\\n        return head;\\n    }\\n}\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) \\n    {\\n            ListNode *slow=head;\\n            ListNode *fast=head;\\n            ListNode *prev = head;\\n\\n         if(head==NULL){\\n               return NULL;\\n           }\\n           if(head->next==NULL){\\n               return NULL;\\n           }\\n    \\n            \\n            while(fast!=NULL && fast->next!=NULL)\\n            {\\n                if(slow!=head)\\n                {\\n                    prev = prev->next;\\n                }\\n                slow=slow->next;\\n                fast=fast->next->next;\\n            }\\n            prev->next=slow->next;\\n            return head;   \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```Java []\\n\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head)\\n     {\\n        ListNode slow=head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n\\n        if(head==null){\\n               return null;\\n           }\\n           if(head.next==null){\\n               return null;\\n           }\\n    \\n        while(fast!=null && fast.next!=null)\\n        {\\n            if(slow!=head)\\n            {\\n                prev=prev.next;\\n            }\\n            slow=slow.next;\\n            fast=fast.next.next;\\n\\n        }\\n        prev.next=slow.next;\\n        return head;\\n    }\\n}\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) \\n    {\\n            ListNode *slow=head;\\n            ListNode *fast=head;\\n            ListNode *prev = head;\\n\\n         if(head==NULL){\\n               return NULL;\\n           }\\n           if(head->next==NULL){\\n               return NULL;\\n           }\\n    \\n            \\n            while(fast!=NULL && fast->next!=NULL)\\n            {\\n                if(slow!=head)\\n                {\\n                    prev = prev->next;\\n                }\\n                slow=slow->next;\\n                fast=fast->next->next;\\n            }\\n            prev->next=slow->next;\\n            return head;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495905,
                "title": "java-beats-100-slow-and-fast-pointers",
                "content": "# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the linked list. We traverse the linked list once to find the middle node.\\n- Space complexity: O(1), as we are using a constant amount of extra space.\\n\\n# Code\\n```java\\npublic ListNode deleteMiddle(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return null;\\n    }\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    ListNode prev = head;\\n\\n    // Find the middle node using the slow and fast pointers\\n    while (fast != null && fast.next != null) {\\n        fast = fast.next.next;\\n        prev = slow;\\n        slow = slow.next;\\n    }\\n\\n    // Delete the middle node by updating the next pointer of the previous node\\n    prev.next = slow.next;\\n\\n    return head;\\n}\\n```\\n\\n# Intuition and Explanation\\nTo delete the middle node of a singly linked list, we need to find the middle node first. We can use the slow and fast pointers approach, where the slow pointer moves one step at a time and the fast pointer moves two steps at a time. When the fast pointer reaches the end of the linked list, the slow pointer will be pointing to the middle node.\\n\\nOnce we have identified the middle node, we can delete it by updating the next pointer of the previous node to skip the middle node. To keep track of the previous node, we initialize a `prev` variable that initially points to the head of the linked list.\\n\\nThe code handles special cases where the linked list is empty or has only one node. If the head is null or the head\\'s next is null, it means there are no middle nodes, so we return null.\\n\\nOverall, the code efficiently deletes the middle node of a linked list in-place by adjusting the next pointers, without requiring any extra space.",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java\\npublic ListNode deleteMiddle(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return null;\\n    }\\n    ListNode slow = head;\\n    ListNode fast = head;\\n    ListNode prev = head;\\n\\n    // Find the middle node using the slow and fast pointers\\n    while (fast != null && fast.next != null) {\\n        fast = fast.next.next;\\n        prev = slow;\\n        slow = slow.next;\\n    }\\n\\n    // Delete the middle node by updating the next pointer of the previous node\\n    prev.next = slow.next;\\n\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324088,
                "title": "easy-to-understand-c-2-pointer-aproch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL) return NULL;\\n        ListNode*f=head;\\n        ListNode*s=head;\\n        ListNode*p=NULL;\\n        while(f!=NULL&&f->next!=NULL){\\n            f=f->next->next;\\n            p=s;\\n            s=s->next;\\n            \\n        }\\n        p->next=p->next->next;\\n\\n        return head;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL) return NULL;\\n        ListNode*f=head;\\n        ListNode*s=head;\\n        ListNode*p=NULL;\\n        while(f!=NULL&&f->next!=NULL){\\n            f=f->next->next;\\n            p=s;\\n            s=s->next;\\n            \\n        }\\n        p->next=p->next->next;\\n\\n        return head;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272027,
                "title": "python3-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**find middle and replace previous next to middle\\'s next.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- make list of every node of list, while doing so **calculate** **number of nodes**.\\n- now if nodes are even then **k = ceil(n/2)** else **n // 2**, because we want second middle.\\n- now if **n is 1** then **return None**, because after deletion list will be empty.\\n- **if not** then make **middle\\'s previous\\' next to middle\\'s next**.\\n- **return mapped[0]**, head of updated list.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import ceil\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        mapped = []\\n        n = 0\\n        while head:\\n            mapped.append(head)\\n            n += 1\\n            head = head.next\\n        middle = n // 2 if n % 2 else ceil(n/2)\\n        if n - 1:\\n            mapped[middle-1].next = mapped[middle].next\\n            return mapped[0]\\n        else :return None\\n```\\n# Please like and comment below (\\u0336\\u25C9\\u035B\\u203F\\u25C9\\u0336)",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nfrom math import ceil\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        mapped = []\\n        n = 0\\n        while head:\\n            mapped.append(head)\\n            n += 1\\n            head = head.next\\n        middle = n // 2 if n % 2 else ceil(n/2)\\n        if n - 1:\\n            mapped[middle-1].next = mapped[middle].next\\n            return mapped[0]\\n        else :return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208181,
                "title": "best-and-very-simple-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode temp = head;\\n        ListNode empty = new ListNode();\\n        if(temp == null||temp.next ==null){\\n            temp = null;\\n            return temp;\\n        }\\n        int sz = 0;\\n        while(temp!=null){\\n            temp = temp.next;\\n            sz++;\\n        }\\n        int mid = sz/2;\\n        int i = 0;\\n        ListNode prev = head;\\n        while(i<mid-1){\\n            prev = prev.next;\\n            i++;\\n        }\\n        prev.next = prev.next.next;\\n        return head;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode temp = head;\\n        ListNode empty = new ListNode();\\n        if(temp == null||temp.next ==null){\\n            temp = null;\\n            return temp;\\n        }\\n        int sz = 0;\\n        while(temp!=null){\\n            temp = temp.next;\\n            sz++;\\n        }\\n        int mid = sz/2;\\n        int i = 0;\\n        ListNode prev = head;\\n        while(i<mid-1){\\n            prev = prev.next;\\n            i++;\\n        }\\n        prev.next = prev.next.next;\\n        return head;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106010,
                "title": "c-easiest-solution-beats-98",
                "content": "# Intuition\\nCount and Delete !!\\n\\n# Approach\\n1. First we will count the number of nodes in list.\\n2. then we will traverse again to the mid and perform deletion\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head == NULL) \\n            return NULL;\\n        \\n        int len = 0;\\n\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            len++;\\n            curr = curr->next;\\n        }\\n\\n        if(len == 1)\\n            return NULL;\\n\\n        curr = head;\\n        ListNode* prev = NULL;\\n\\n        for(int i = 0; i < len/2; ++i){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        prev->next = curr->next;\\n        //curr->next = NULL;\\n        delete curr;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head == NULL) \\n            return NULL;\\n        \\n        int len = 0;\\n\\n        ListNode* curr = head;\\n\\n        while(curr != NULL){\\n            len++;\\n            curr = curr->next;\\n        }\\n\\n        if(len == 1)\\n            return NULL;\\n\\n        curr = head;\\n        ListNode* prev = NULL;\\n\\n        for(int i = 0; i < len/2; ++i){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        prev->next = curr->next;\\n        //curr->next = NULL;\\n        delete curr;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796957,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode abc = new ListNode(0, head);\\n        ListNode x = abc, y = head;\\n        while (y != null && y.next != null) {\\n            x = x.next;\\n            y = y.next.next;\\n        }\\n        x.next = x.next.next;\\n        return abc.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode abc = new ListNode(0, head);\\n        ListNode x = abc, y = head;\\n        while (y != null && y.next != null) {\\n            x = x.next;\\n            y = y.next.next;\\n        }\\n        x.next = x.next.next;\\n        return abc.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703659,
                "title": "c-hare-tortoise-algorithm-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // prev to store the previous value of slow pointer \\n        // slow moves one at a time && fast moves two at a time so distance cover by a slow at any time is half of distance covered by fast\\n        // thats why when fast cover the distance of linked list length, slow points to the middle of linked list\\n        // as we want to delete the middle element we have to set middle previous to point to next of middle thats why we maintain slow pointer\\n        \\n        ListNode* prev=NULL,*slow=head,*fast=head;\\n        while(fast and fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        // case when linked list is made up of only single node \"ek lauti node:)\"\\n        if(!prev)return NULL;\\n        prev->next=slow->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // prev to store the previous value of slow pointer \\n        // slow moves one at a time && fast moves two at a time so distance cover by a slow at any time is half of distance covered by fast\\n        // thats why when fast cover the distance of linked list length, slow points to the middle of linked list\\n        // as we want to delete the middle element we have to set middle previous to point to next of middle thats why we maintain slow pointer\\n        \\n        ListNode* prev=NULL,*slow=head,*fast=head;\\n        while(fast and fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        \\n        // case when linked list is made up of only single node \"ek lauti node:)\"\\n        if(!prev)return NULL;\\n        prev->next=slow->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703549,
                "title": "100-faster-submission-0-ms-runtime-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)\\n        {\\n        return null;\\n        }\\n        ListNode slow=head,fast=head.next.next;\\n        while(fast!=null && fast.next !=null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)\\n        {\\n        return null;\\n        }\\n        ListNode slow=head,fast=head.next.next;\\n        while(fast!=null && fast.next !=null)\\n        {\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703480,
                "title": "two-pointers-slow-fast-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return NULL;\\n        ListNode *slow, *fast;\\n        slow = new ListNode(0, head);\\n        fast = head;\\n        \\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        ListNode *store = slow->next->next;\\n        slow->next = store;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return NULL;\\n        ListNode *slow, *fast;\\n        slow = new ListNode(0, head);\\n        fast = head;\\n        \\n        while (fast && fast->next) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        ListNode *store = slow->next->next;\\n        slow->next = store;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701952,
                "title": "easy-in-o-n-complexity",
                "content": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i=head\\n        n=0\\n        while(i):\\n            n+=1\\n            i=i.next\\n        n=n//2-1\\n        if(n<0):\\n            return None\\n        i=head\\n        while(i and 0<n):\\n            i=i.next\\n            n-=1\\n        i.next=i.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        i=head\\n        n=0\\n        while(i):\\n            n+=1\\n            i=i.next\\n        n=n//2-1\\n        if(n<0):\\n            return None\\n        i=head\\n        while(i and 0<n):\\n            i=i.next\\n            n-=1\\n        i.next=i.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701755,
                "title": "python-single-pointer-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/822204774/) employs a single pointer approach together with calculation of list\\'s size. It demonstrated **1762 ms runtime (98.07%)** and used **60.6 MB memory (40.40%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Rust**](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/2701933/Rust-fastest-(100)-safe-one-pointer-solution-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        sz: int = 0\\n        \\n        # [1] find the size of the list\\n        node = head\\n        while node: node = node.next; sz += 1\\n        \\n        # [2] trivial case\\n        if sz <= 1: return None\\n        \\n        # [3] typical case\\n        sz //= 2\\n        node = head\\n        while sz > 1: node = node.next; sz -= 1\\n        node.next = node.next.next\\n        \\n        return head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        sz: int = 0\\n        \\n        # [1] find the size of the list\\n        node = head\\n        while node: node = node.next; sz += 1\\n        \\n        # [2] trivial case\\n        if sz <= 1: return None\\n        \\n        # [3] typical case\\n        sz //= 2\\n        node = head\\n        while sz > 1: node = node.next; sz -= 1\\n        node.next = node.next.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701548,
                "title": "simple-java-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)\\n            return null;\\n        ListNode slow=head,fast=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=slow.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)\\n            return null;\\n        ListNode slow=head,fast=head,prev=null;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=slow.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701461,
                "title": "js-solution-with-two-pointer-explained",
                "content": "## Getting the middle of the linked list\\nIf the list is traversed with one slow pointer and one fast pointer, the slow pointer will be in the middle when the fast pointer arrives at the end.\\nThe fast pointer moves two nodes will the slow pointer moves one node.\\n*For a odd list:*\\n![image](https://assets.leetcode.com/users/images/071f975c-6698-4c34-b11a-463ad58b5851_1665729906.8682323.png) ![image](https://assets.leetcode.com/users/images/65175a04-f1b6-43f3-bfca-03cad18a7faf_1665729944.2993717.png) ![image](https://assets.leetcode.com/users/images/95d7c5af-e7f0-4bb6-87cb-71fdca77d4d3_1665729970.9001544.png)\\n*For a even list:*\\n![image](https://assets.leetcode.com/users/images/79f9d06d-d727-452b-8093-58cfc16f36e7_1665730142.8312619.png) ![image](https://assets.leetcode.com/users/images/c003413a-6c60-4ffc-9b4b-c1601c56b85f_1665730171.6315277.png) ![image](https://assets.leetcode.com/users/images/b864b1c9-1c4a-4911-bfc4-08650c494caf_1665730196.7058487.png)\\n\\n## Deletind a node from a linked list\\nUsually, for deleting a node from a singly-linked list, only is needed to connect the previous node to the next node. Resulting in the given node detached.\\n![image](https://assets.leetcode.com/users/images/5de93ff7-cb9b-4658-8faf-046acf5fd566_1665730529.368555.png) ![image](https://assets.leetcode.com/users/images/0b61f52b-8691-4dac-805f-7b9394e90f30_1665730491.8561914.png)\\n\\nSo it needed to keep the reference to the previous node of the middle node.\\n\\n## 1 Node list\\nIf the list has only one node, deleting the middle node is deleting the list, so the return will be `null`.\\n\\n## Code\\n```javascript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction deleteMiddle(head) {\\n  if (head.next == null) return null;\\n\\n  let slow = head;\\n  let fast = head;\\n  let prevSlow = null;\\n\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    prevSlow = slow;\\n    slow = slow.next;\\n  }\\n\\n  prevSlow.next = slow.next;\\n  return head;\\n}\\n```\\n\\n## Refine\\nThe two significan pointers are the one who detected the end of the lest and the one who keep the reference from the previous node of the middle node. So if slow pointer starts one node before the fast pointer, the problem is solved with only two pointers.\\n\\n![image](https://assets.leetcode.com/users/images/49b6479d-ad4e-4bfd-a669-4d8893ad05ae_1665746899.3146877.png) ![image](https://assets.leetcode.com/users/images/c8a5f98e-4dfb-46ca-a0be-4ad0f6ec2452_1665746928.2799037.png) ![image](https://assets.leetcode.com/users/images/4cbee6e7-5d4d-448a-987f-f6cd5e73ec31_1665746956.4900575.png)\\n\\n```javascript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction deleteMiddle(head) {\\n  // One node list\\n  if (head.next == null) return null;\\n\\n  let slow = new ListNode(null, head),\\n      fast = head;\\n\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n\\n  slow.next = slow.next.next;\\n  return head;\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction deleteMiddle(head) {\\n  if (head.next == null) return null;\\n\\n  let slow = head;\\n  let fast = head;\\n  let prevSlow = null;\\n\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    prevSlow = slow;\\n    slow = slow.next;\\n  }\\n\\n  prevSlow.next = slow.next;\\n  return head;\\n}\\n```\n```javascript\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nfunction deleteMiddle(head) {\\n  // One node list\\n  if (head.next == null) return null;\\n\\n  let slow = new ListNode(null, head),\\n      fast = head;\\n\\n  while (fast && fast.next) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n\\n  slow.next = slow.next.next;\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701435,
                "title": "java-two-pointers-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        //Code here....\\n        if(head == null || head.next == null)\\n            return null;    //Checking corner case\\n        \\n        ListNode curr = head;\\n        curr = middle(curr);    //Finding the element previous to the middle node\\n        curr.next = curr.next.next; //Removing the middle node\\n        \\n        return head;\\n        \\n    }\\n    \\n    public ListNode middle(ListNode head)\\n    {\\n        ListNode slow = head, fast = head,prev = null;\\n        while(fast != null && fast.next != null)\\n        {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        //Code here....\\n        if(head == null || head.next == null)\\n            return null;    //Checking corner case\\n        \\n        ListNode curr = head;\\n        curr = middle(curr);    //Finding the element previous to the middle node\\n        curr.next = curr.next.next; //Removing the middle node\\n        \\n        return head;\\n        \\n    }\\n    \\n    public ListNode middle(ListNode head)\\n    {\\n        ListNode slow = head, fast = head,prev = null;\\n        while(fast != null && fast.next != null)\\n        {\\n            prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701101,
                "title": "c-use-two-pointers-approach-easy-and-efficient",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) \\n    {\\n        if(!head->next) return NULL;\\n        \\n        ListNode *slow = new ListNode(0);\\n        ListNode *fast = slow;\\n        \\n        slow->next = head;\\n        fast->next = head;\\n        \\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) \\n    {\\n        if(!head->next) return NULL;\\n        \\n        ListNode *slow = new ListNode(0);\\n        ListNode *fast = slow;\\n        \\n        slow->next = head;\\n        fast->next = head;\\n        \\n        while(fast->next && fast->next->next)\\n        {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        slow->next = slow->next->next;\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700849,
                "title": "java-solution-two-pointer-approach-97-faster-with-explanation",
                "content": "-> I am considering two pointer i.e fast and slow pointer \\n-> The fast pointer moves two steps whereas the slow pointer moves one step\\n-> So when the fast pointer will reach the end , the slow pointer will naturally reach the middle node\\n\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if(head == null ||  head.next == null)  return null;\\n        \\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null && fast.next.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\n        slow.next = slow.next.next;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if(head == null ||  head.next == null)  return null;\\n        \\n        ListNode fast = head.next;\\n        ListNode slow = head;\\n\\n        while(fast != null && fast.next != null && fast.next.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n\\n        slow.next = slow.next.next;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700763,
                "title": "easy-c-linked-list",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast->next->next!=NULL && fast->next->next->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n};\\n```\\nSingle Pass Approach.....>>",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast->next->next!=NULL && fast->next->next->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        slow->next=slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700742,
                "title": "two-pointer-no-memory-leaks-c-explanation-space-1",
                "content": "\\n\\n        ListNode* deleteMiddle(ListNode* head) {\\n        //BASE CONDITION\\n        if(head==NULL || head->next==NULL){\\n            return NULL;\\n        }\\n        //SLow move one step\\n        ListNode* slow=head;\\n        ListNode* fast=head->next->next; //First Move two step...Fast=head->next->next..because we want the noe exactly one step before middle node\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next; //move one step\\n            fast=fast->next->next; //move two step\\n        }\\n        ListNode* temp=slow->next;//store delete node or middle node\\n        \\n        slow->next=slow->next->next;//break and making link\\n        \\n        delete temp;//delete the node ..we don\\'t want memory leaks\\n        \\n        return head; //return head\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n\\n        ListNode* deleteMiddle(ListNode* head) {\\n        //BASE CONDITION\\n        if(head==NULL || head->next==NULL){\\n            return NULL;\\n        }\\n        //SLow move one step\\n        ListNode* slow=head;\\n        ListNode* fast=head->next->next; //First Move two step...Fast=head->next->next..because we want the noe exactly one step before middle node\\n        \\n        while(fast!=NULL && fast->next!=NULL){\\n            slow=slow->next; //move one step\\n            fast=fast->next->next; //move two step\\n        }\\n        ListNode* temp=slow->next;//store delete node or middle node\\n        \\n        slow->next=slow->next->next;//break and making link\\n        \\n        delete temp;//delete the node ..we don\\'t want memory leaks\\n        \\n        return head; //return head\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2700695,
                "title": "easy-c-100-faster-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next == nullptr) return head->next;\\n        ListNode *slow=head, *fast=head, *prev=head;\\n        while(fast->next){\\n            prev = slow;\\n            slow = slow->next;\\n            if(fast->next->next) fast = fast->next->next;\\n            else break;\\n        }\\n        prev->next = prev->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next == nullptr) return head->next;\\n        ListNode *slow=head, *fast=head, *prev=head;\\n        while(fast->next){\\n            prev = slow;\\n            slow = slow->next;\\n            if(fast->next->next) fast = fast->next->next;\\n            else break;\\n        }\\n        prev->next = prev->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700560,
                "title": "c-easy-solution-using-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode*n=head,*p=head,*b=head;\\n        while(p&&p->next){\\n            if(n!=head)b=b->next;\\n            n=n->next;\\n            p=p->next->next;\\n        }\\n        if(n==head)return n->next;\\n        b->next=n->next;\\n        return head;\\n        \\n    }\\n};\\n```\\n# **Please share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode*n=head,*p=head,*b=head;\\n        while(p&&p->next){\\n            if(n!=head)b=b->next;\\n            n=n->next;\\n            p=p->next->next;\\n        }\\n        if(n==head)return n->next;\\n        b->next=n->next;\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700445,
                "title": "daily-leetcode-solution-easy-to-undertsand-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getLength(ListNode* head)\\n    {\\n        int cnt=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL) return NULL;\\n        int len=getLength(head);\\n        ListNode* curr=head;\\n        for(int i=0;i<len/2-1;i++)\\n        {\\n            curr=curr->next;\\n        }\\n        ListNode* next=curr->next;\\n        ListNode* next_next=next->next;\\n        curr->next=next_next;\\n        next->next=NULL;\\n        delete next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getLength(ListNode* head)\\n    {\\n        int cnt=0;\\n        while(head!=NULL)\\n        {\\n            head=head->next;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL) return NULL;\\n        int len=getLength(head);\\n        ListNode* curr=head;\\n        for(int i=0;i<len/2-1;i++)\\n        {\\n            curr=curr->next;\\n        }\\n        ListNode* next=curr->next;\\n        ListNode* next_next=next->next;\\n        curr->next=next_next;\\n        next->next=NULL;\\n        delete next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700271,
                "title": "daily-leetcoding-challenge-october-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2498870,
                "title": "very-easy-implementation-beats-85-runtime",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fast=slow=head\\n        prev=None\\n        if not head.next:\\n            return None\\n        while fast and fast.next:\\n            prev=slow\\n            slow=slow.next\\n            fast=fast.next.next\\n        prev.next=slow.next \\n        return head\\n          \\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fast=slow=head\\n        prev=None\\n        if not head.next:\\n            return None\\n        while fast and fast.next:\\n            prev=slow\\n            slow=slow.next\\n            fast=fast.next.next\\n        prev.next=slow.next \\n        return head\\n          \\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377140,
                "title": "swift-solution-fast-and-slow",
                "content": "```\\nclass Solution {\\n    func deleteMiddle(_ head: ListNode?) -> ListNode? {\\n        if head?.next == nil{\\n            return nil\\n        }\\n        var slow=head\\n        var fast=head\\n        var prev:ListNode?\\n        while fast?.next != nil{\\n            fast=fast?.next?.next\\n            prev=slow\\n            slow=slow?.next\\n        }\\n        prev?.next=slow?.next\\n        return head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteMiddle(_ head: ListNode?) -> ListNode? {\\n        if head?.next == nil{\\n            return nil\\n        }\\n        var slow=head\\n        var fast=head\\n        var prev:ListNode?\\n        while fast?.next != nil{\\n            fast=fast?.next?.next\\n            prev=slow\\n            slow=slow?.next\\n        }\\n        prev?.next=slow?.next\\n        return head\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187828,
                "title": "go-o-n-that-beats-90",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {return nil}\\n    \\n    pre, slow, fast := head, head, head\\n    \\n    for slow.Next != nil && fast.Next != nil {\\n        pre = slow\\n        slow = slow.Next\\n        fast = fast.Next\\n        \\n        if fast.Next != nil {\\n            fast = fast.Next\\n        }\\n    }\\n    \\n    pre.Next = slow.Next\\n    \\n    return head\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {return nil}\\n    \\n    pre, slow, fast := head, head, head\\n    \\n    for slow.Next != nil && fast.Next != nil {\\n        pre = slow\\n        slow = slow.Next\\n        fast = fast.Next\\n        \\n        if fast.Next != nil {\\n            fast = fast.Next\\n        }\\n    }\\n    \\n    pre.Next = slow.Next\\n    \\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2153481,
                "title": "c-solution-delete-the-middle-node-of-a-linked-list",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode *temp = head; int count = 0 , mid = 0;\\n        while(temp->next != NULL){\\n            count++;\\n            temp = temp->next;\\n        }\\n        \\n        if(count % 2 == 0)\\n            mid = count / 2;\\n        else\\n            mid = count / 2 + 1;\\n        \\n        temp = head; count = 1;\\n        while(count < mid){\\n            temp = temp->next;\\n            count++;\\n        }\\n        \\n        ListNode *temp1 = temp->next->next;\\n        ListNode *temp2 = temp->next;\\n        delete temp2;\\n        temp->next = temp1;\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode *temp = head; int count = 0 , mid = 0;\\n        while(temp->next != NULL){\\n            count++;\\n            temp = temp->next;\\n        }\\n        \\n        if(count % 2 == 0)\\n            mid = count / 2;\\n        else\\n            mid = count / 2 + 1;\\n        \\n        temp = head; count = 1;\\n        while(count < mid){\\n            temp = temp->next;\\n            count++;\\n        }\\n        \\n        ListNode *temp1 = temp->next->next;\\n        ListNode *temp2 = temp->next;\\n        delete temp2;\\n        temp->next = temp1;\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102017,
                "title": "2095-delete-the-mid-node-beginner-friendly-java",
                "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n \\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\t\\n        ListNode s = head;\\n        ListNode f = head;\\n        ListNode temp = head;\\n        ListNode counter = head;\\n\\t\\t\\n        \\n       // size of linkedlist\\n        int countnodes = 0;\\n\\t\\twhile(counter != null){\\n            counter = counter.next;\\n            countnodes++;\\n        }\\n\\t\\t// if there is only one node\\n        if(countnodes == 1){\\n            return null;\\n        }\\n        // if linklist is odd\\n        if(countnodes %2 == 1){\\n             int c = 0;\\n        while (f.next != null && f !=null){\\n             f= f.next.next;\\n             s = s.next;\\n             c++;\\n        }\\n        \\n        for(int i =1; i<c; i++){\\n            temp = temp.next;\\n        }\\n        temp.next = temp.next.next;\\n        \\n        \\n        }else{ //if linkedlist is even\\n            int c = 0;\\n            while(f !=null){\\n                 f= f.next.next;\\n                s = s.next;\\n                c++;\\n            }\\n            for(int i =1; i<c; i++){\\n            temp = temp.next;\\n            }\\n                temp.next = temp.next.next;\\n        }\\n        \\n         return head;  \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\t\\n        ListNode s = head;\\n        ListNode f = head;\\n        ListNode temp = head;\\n        ListNode counter = head;\\n\\t\\t\\n        \\n       // size of linkedlist\\n        int countnodes = 0;\\n\\t\\twhile(counter != null){\\n            counter = counter.next;\\n            countnodes++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2002892,
                "title": "go-two-pointers-clear-solution",
                "content": "```\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    dummy := &ListNode{0, head}\\n    slow, fast := dummy, head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    slow.Next = slow.Next.Next\\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    dummy := &ListNode{0, head}\\n    slow, fast := dummy, head\\n    for fast != nil && fast.Next != nil {\\n        slow = slow.Next\\n        fast = fast.Next.Next\\n    }\\n    slow.Next = slow.Next.Next\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845679,
                "title": "easy-solution-in-cpp-with-explanation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode *l1=head,*start,*tmp=head;\\n        start=tmp;\\n        int n=0;\\n\\t\\t// if list is empty we simply return null\\n        if(head==NULL)\\n            return NULL;\\n\\t\\t\\t//if it has one element we simply delete it will return NULL\\n        if(head->next==NULL)\\n            return NULL;\\n        while(l1!=NULL)\\n        {\\n            n++;\\n            l1=l1->next;\\n        }\\n\\t\\t//counted n value\\n        n=n/2;\\n      //for deleteing particular we should reach it previous so here consition is n!=1\\n        while(n!=1)\\n        {   \\n            tmp=tmp->next;\\n            n--;\\n        }\\n\\t\\t//here in persent tmp->next we assign temp->next->next it mans we skipped one node\\n        tmp->next=tmp->next->next;\\n        return start;           \\n\\t\\t//and here we returned start which is head pointer\\n    }\\n};\\n\\n```\\n\\n***If you find helpful, then please Upvote it.***",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode *l1=head,*start,*tmp=head;\\n        start=tmp;\\n        int n=0;\\n\\t\\t// if list is empty we simply return null\\n        if(head==NULL)\\n            return NULL;\\n\\t\\t\\t//if it has one element we simply delete it will return NULL\\n        if(head->next==NULL)\\n            return NULL;\\n        while(l1!=NULL)\\n        {\\n            n++;\\n            l1=l1->next;\\n        }\\n\\t\\t//counted n value\\n        n=n/2;\\n      //for deleteing particular we should reach it previous so here consition is n!=1\\n        while(n!=1)\\n        {   \\n            tmp=tmp->next;\\n            n--;\\n        }\\n\\t\\t//here in persent tmp->next we assign temp->next->next it mans we skipped one node\\n        tmp->next=tmp->next->next;\\n        return start;           \\n\\t\\t//and here we returned start which is head pointer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617620,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tif head.next == None:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\tprev = None\\n\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tprev = slow\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\n\\t\\t\\tprev.next = slow.next\\n\\n\\t\\t\\treturn head\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tif head.next == None:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tslow, fast = head, head\\n\\t\\t\\tprev = None\\n\\n\\t\\t\\twhile fast and fast.next:\\n\\t\\t\\t\\tprev = slow\\n\\t\\t\\t\\tslow = slow.next\\n\\t\\t\\t\\tfast = fast.next.next\\n\\n\\t\\t\\tprev.next = slow.next\\n\\n\\t\\t\\treturn head\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1612389,
                "title": "simple-deletion-approach",
                "content": "Steps\\n1. Reach the Previous Node for that we need to know the length \\n2. Delete the next Node and Maintain the links by using another pointer\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getCount(ListNode* head) { \\n    int count = 0; // Initialize count \\n    ListNode* current = head; // Initialize current \\n    while (current != NULL) \\n    { \\n        count++; \\n        current = current->next; \\n    } \\n    return count; \\n} \\n    ListNode* deleteMiddle(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return NULL;\\n    }\\n    int n = getCount(head);\\n    ListNode* temp = head;\\n    int position = (n/2); \\n    for(int i = 0; temp != NULL && i < position-1; i++)\\n        temp = temp->next;\\n     ListNode *next = temp->next->next;\\n    delete temp->next;\\n    // Unlink the deleted node from list\\n    temp->next = next; \\n    return head;\\n    }\\n};\\n```\\nT.C. = O(N) S.C. = O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getCount(ListNode* head) { \\n    int count = 0; // Initialize count \\n    ListNode* current = head; // Initialize current \\n    while (current != NULL) \\n    { \\n        count++; \\n        current = current->next; \\n    } \\n    return count; \\n} \\n    ListNode* deleteMiddle(ListNode* head) {\\n    if(head==NULL||head->next==NULL){\\n        return NULL;\\n    }\\n    int n = getCount(head);\\n    ListNode* temp = head;\\n    int position = (n/2); \\n    for(int i = 0; temp != NULL && i < position-1; i++)\\n        temp = temp->next;\\n     ListNode *next = temp->next->next;\\n    delete temp->next;\\n    // Unlink the deleted node from list\\n    temp->next = next; \\n    return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612082,
                "title": "python-rabbit-and-tortoise",
                "content": "Slow pointer stores the node to be deleted. \\nLast pointer stores the node before slow.\\n```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = fast = head\\n        last = None\\n        while fast and fast.next:\\n            last = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        if last:\\n            last.next = last.next.next\\n        else:\\n            return None\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        slow = fast = head\\n        last = None\\n        while fast and fast.next:\\n            last = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        if last:\\n            last.next = last.next.next\\n        else:\\n            return None\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611985,
                "title": "java-runner-walker-simple",
                "content": "\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head==null || head.next==null)\\n        return null;\\n        \\n        ListNode prev=null;\\n        ListNode runner=head;\\n        ListNode walker=head;\\n         \\n        while(runner!=null && runner.next!=null){\\n           prev=walker;\\n           walker=walker.next;\\n           runner=runner.next.next;   \\n        }\\n\\n        prev.next=walker.next;\\n\\n        return head;      \\n    }   \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head==null || head.next==null)\\n        return null;\\n        \\n        ListNode prev=null;\\n        ListNode runner=head;\\n        ListNode walker=head;\\n         \\n        while(runner!=null && runner.next!=null){\\n           prev=walker;\\n           walker=walker.next;\\n           runner=runner.next.next;   \\n        }\\n\\n        prev.next=walker.next;\\n\\n        return head;      \\n    }   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042925,
                "title": "delete-the-middle-node-of-a-linked-list-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL) return NULL;\\n        int n = length(head);\\n        int t = n/2;\\n        ListNode* temp = head;\\n        for(int i=0;i<t;i++){\\n            if(i==t-1){\\n                ListNode* todelete = temp->next;\\n                temp->next=temp->next->next;\\n                delete todelete;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int length(ListNode* head){\\n        ListNode* temp = head;\\n        int count = 0;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL) return NULL;\\n        int n = length(head);\\n        int t = n/2;\\n        ListNode* temp = head;\\n        for(int i=0;i<t;i++){\\n            if(i==t-1){\\n                ListNode* todelete = temp->next;\\n                temp->next=temp->next->next;\\n                delete todelete;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031357,
                "title": "java-slow-and-fast-pointer-97-faster",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n**Slow and Fast Pointer**\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null){\\n            return null;\\n        }\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n```\\n**Using Length of LinkedList**\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode temp=head;\\n        int n=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++;\\n        }\\n        if(n<2){\\n            return null;\\n        }\\n        temp=head;\\n        n/=2;\\n        while(n-1>0){\\n            n--;\\n            temp=temp.next;\\n        }\\n        temp.next=temp.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null){\\n            return null;\\n        }\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode temp=head;\\n        int n=0;\\n        while(temp!=null){\\n            temp=temp.next;\\n            n++;\\n        }\\n        if(n<2){\\n            return null;\\n        }\\n        temp=head;\\n        n/=2;\\n        while(n-1>0){\\n            n--;\\n            temp=temp.next;\\n        }\\n        temp.next=temp.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934820,
                "title": "easy-java-solution-with-all-test-case-beats-99-3ms-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Calculate the Size of LL\\n2.getmid by doing sz/2;\\n3.while loop to get the previous Node and then make the prev node next to next.next;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n          int sz = 0;\\n        ListNode temp = head;\\n        while ( temp != null){\\n            temp = temp.next;\\n            sz++;\\n        }\\n        if (sz == 2){\\n            head.next = null;\\n            return head;\\n        }\\n         if (sz == 1){\\n            head = null;\\n            return head;\\n        }\\n        int middle = sz/2;\\n        int i = 1;\\n        ListNode prev = head;\\n        while ( i < middle){\\n            prev = prev.next;\\n            i++;\\n        }\\n        prev.next = prev.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n          int sz = 0;\\n        ListNode temp = head;\\n        while ( temp != null){\\n            temp = temp.next;\\n            sz++;\\n        }\\n        if (sz == 2){\\n            head.next = null;\\n            return head;\\n        }\\n         if (sz == 1){\\n            head = null;\\n            return head;\\n        }\\n        int middle = sz/2;\\n        int i = 1;\\n        ListNode prev = head;\\n        while ( i < middle){\\n            prev = prev.next;\\n            i++;\\n        }\\n        prev.next = prev.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775291,
                "title": "easy-java-solution-clean-code-easy-to-understand-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n\\n        while(fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head == null || head.next == null) {\\n            return null;\\n        }\\n\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n\\n        while(fast.next != null && fast.next.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768022,
                "title": "easy-and-simple-solution",
                "content": "\\n\\n\\n    class Solution {\\n    public:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=NULL and fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        if(slow->next==NULL){\\n            head->next=NULL;\\n            return head;\\n        }\\n        slow->val=slow->next->val;\\n        slow->next=slow->next->next;\\n        return head;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL or head->next==NULL)return NULL;\\n        ListNode* slow=head;\\n        ListNode* fast=head;\\n        while(fast!=NULL and fast->next!=NULL){\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3751322,
                "title": "optimized-brute-force-approach-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe `getMiddle` function is used to find the middle node of the linked list. It uses two pointers, `slow` and `fast`, initialized to the head of the list. The `fast` pointer moves two nodes at a time, while the `slow` pointer moves one node at a time. By the time the `fast` pointer reaches the end of the list, the `slow` pointer will be pointing to the middle node. The function then returns the `slow` pointer.\\n\\nThe `deleteMiddle` function deletes the middle node from the linked list. It first checks if the list is empty or contains only one node. If so, it returns `NULL`, indicating an empty list or a list with no middle node to delete. Otherwise, it calls the `getMiddle` function to find the middle node. It then traverses the list using a temporary pointer `temp` until it reaches the node just before the middle node. It updates the next pointer of `temp` to skip the middle node and point to the node after it. Finally, it returns the head of the modified list.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* getMiddle(ListNode* head){\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        while(fast != NULL){\\n            fast = fast -> next;\\n            if(fast != NULL){\\n                fast = fast -> next;\\n            }\\n            slow = slow -> next;\\n        }\\n        return slow;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)\\n            return NULL;\\n        ListNode* curr = getMiddle(head);        \\n        ListNode* temp = head;\\n        while(temp -> next != curr){\\n            temp = temp -> next;\\n        }\\n        temp -> next = curr -> next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* getMiddle(ListNode* head){\\n        ListNode* slow = head;\\n        ListNode* fast = head -> next;\\n        while(fast != NULL){\\n            fast = fast -> next;\\n            if(fast != NULL){\\n                fast = fast -> next;\\n            }\\n            slow = slow -> next;\\n        }\\n        return slow;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head -> next == NULL)\\n            return NULL;\\n        ListNode* curr = getMiddle(head);        \\n        ListNode* temp = head;\\n        while(temp -> next != curr){\\n            temp = temp -> next;\\n        }\\n        temp -> next = curr -> next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742347,
                "title": "easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next == null) return null;\\n        ListNode slow = head;\\n        ListNode fast = head.next.next;\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next == null) return null;\\n        ListNode slow = head;\\n        ListNode fast = head.next.next;\\n        while(fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710337,
                "title": "easy-solution-two-pointer-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to find the middle node of the linked list efficiently using the two-pointer technique. By moving one pointer at a slower pace than the other, we can identify the middle node when the faster pointer reaches the end of the list. Once the middle node is found, we modify the previous node\\'s next pointer to skip the middle node, effectively removing it from the list.\\n\\nThe code handles edge cases such as lists with only one node (in which case the middle node does not exist) and properly deletes the middle node from memory to avoid memory leaks.\\n\\nOverall, the code efficiently deletes the middle node from a singly-linked list while maintaining the relative order of the other nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a two-pointer technique to find the middle node of the linked list. It initializes two pointers, slow and fast, both starting from the head of the list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. By the time the fast pointer reaches the end of the list, the slow pointer would have reached the middle node.\\n\\nTo delete the middle node, the code maintains a prev pointer to keep track of the node before the middle node. Once the middle node is found, the prev pointer\\'s next pointer is updated to skip the middle node. Finally, the middle node is deleted from memory using the delete keyword.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the provided code is O(n), where n is the number of nodes in the linked list. This is because the code traverses the list once to find the middle node. The traversal is done using the two-pointer technique, where one pointer moves at a slower pace than the other. As a result, it takes approximately n/2 iterations to reach the middle node, which simplifies to O(n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it uses a constant amount of extra space to store the pointers (slow, fast, prev) and perform the deletion of the middle node. Regardless of the size of the linked list, the amount of additional memory used remains constant. Hence, the space complexity is constant or O(1).\\n\\n# Code\\n\\n/**\\n /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Check if the list contains only one node\\n        if (head->next == NULL) {\\n            return NULL;\\n        }\\n\\n        // Initialize slow and fast pointers\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n\\n        // Move slow pointer one step and fast pointer two steps at a time\\n        while (fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Delete the middle node by updating the previous node\\'s next pointer\\n        prev->next = slow->next;\\n\\n        // Delete the middle node from memory\\n        delete slow;\\n\\n        // Return the head of the modified list\\n        return head;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Check if the list contains only one node\\n        if (head->next == NULL) {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3710327,
                "title": "fully-explained-solution-two-pointer-explained-easy-solution-for-everyone",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to find the middle node of the linked list efficiently using the two-pointer technique. By moving one pointer at a slower pace than the other, we can identify the middle node when the faster pointer reaches the end of the list. Once the middle node is found, we modify the previous node\\'s next pointer to skip the middle node, effectively removing it from the list.\\n\\nThe code handles edge cases such as lists with only one node (in which case the middle node does not exist) and properly deletes the middle node from memory to avoid memory leaks.\\n\\nOverall, the code efficiently deletes the middle node from a singly-linked list while maintaining the relative order of the other nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a two-pointer technique to find the middle node of the linked list. It initializes two pointers, slow and fast, both starting from the head of the list. The slow pointer moves one step at a time, while the fast pointer moves two steps at a time. By the time the fast pointer reaches the end of the list, the slow pointer would have reached the middle node.\\n\\nTo delete the middle node, the code maintains a prev pointer to keep track of the node before the middle node. Once the middle node is found, the prev pointer\\'s next pointer is updated to skip the middle node. Finally, the middle node is deleted from memory using the delete keyword.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the provided code is O(n), where n is the number of nodes in the linked list. This is because the code traverses the list once to find the middle node. The traversal is done using the two-pointer technique, where one pointer moves at a slower pace than the other. As a result, it takes approximately n/2 iterations to reach the middle node, which simplifies to O(n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) because it uses a constant amount of extra space to store the pointers (slow, fast, prev) and perform the deletion of the middle node. Regardless of the size of the linked list, the amount of additional memory used remains constant. Hence, the space complexity is constant or O(1).\\n\\n# Code\\n```\\n/**\\n /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Check if the list contains only one node\\n        if (head->next == NULL) {\\n            return NULL;\\n        }\\n\\n        // Initialize slow and fast pointers\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n\\n        // Move slow pointer one step and fast pointer two steps at a time\\n        while (fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Delete the middle node by updating the previous node\\'s next pointer\\n        prev->next = slow->next;\\n\\n        // Delete the middle node from memory\\n        delete slow;\\n\\n        // Return the head of the modified list\\n        return head;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n /**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        // Check if the list contains only one node\\n        if (head->next == NULL) {\\n            return NULL;\\n        }\\n\\n        // Initialize slow and fast pointers\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n\\n        // Move slow pointer one step and fast pointer two steps at a time\\n        while (fast != NULL && fast->next != NULL) {\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        // Delete the middle node by updating the previous node\\'s next pointer\\n        prev->next = slow->next;\\n\\n        // Delete the middle node from memory\\n        delete slow;\\n\\n        // Return the head of the modified list\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658302,
                "title": "python-solution-t-o-n-s-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the problem statement involves finding the middle element of the linked list, we use the Fast and Slow pointer strategy to solve this problem. This is because, ```fast``` pointer\\'s value changes as ```fast = fast.next.next #2 steps ahead``` and the ```slow``` pointer\\'s value changes as ```slow = slow.next #1 step ahead```. By the time the fast pointer reaches to the end of the linked list, slow pointer reaches to the middle node of the linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the head has a next or is it None. If the next is None, it means it has only 1 element and that can be deleted.\\n2. If there are more than 1 elements in the list, then we use the ```slow```, ```fast``` pointer strategy here to find the middle element in the linked list. \\nBy the time fast pointer reaches the end of the list, slow pointer reaches the middle of the list.\\n3. During the traversal, we also keep a track of the previous pointer. Hence the ```prev``` pointer.\\n4. Once the while loop exits, the ```slow``` pointer points to the middle node and the ```prev``` pointer points to the node previous to the middle element.\\n5. As the final step we update the ```prev.next``` to  ```slow.next``` and return the head of the linked list.\\n\\n# Complexity\\n- Time complexity: O(N), since we are visiting all the nodes in the lsit\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n\\n        slow, fast, prev = head, head, head\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        prev.next = slow.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```fast```\n```fast = fast.next.next #2 steps ahead```\n```slow```\n```slow = slow.next #1 step ahead```\n```slow```\n```fast```\n```prev```\n```slow```\n```prev```\n```prev.next```\n```slow.next```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n\\n        slow, fast, prev = head, head, head\\n\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        prev.next = slow.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593227,
                "title": "beats-java-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if (head == null || head.next == null) return null;\\n\\n        ListNode prev=head;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n\\n        while(fast!=null && fast.next!=null){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n\\n        if (head == null || head.next == null) return null;\\n\\n        ListNode prev=head;\\n        ListNode slow=head;\\n        ListNode fast=head;\\n\\n        while(fast!=null && fast.next!=null){\\n            prev=slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n        }\\n        prev.next=prev.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592129,
                "title": "java-program-to-remove-middle-node-of-a-linked-list-beats-100-tc-o-n-2-sc-o-1",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. First, it checks if the linked list is empty or contains only one node. If this is the case, it returns null because there is no middle node to remove.\\n\\n2. If the linked list has at least two nodes, it initializes three pointers: fastPtr, slowPtr, and prev. These pointers are used to traverse the linked list.\\n\\n3. The while loop condition checks if both fastPtr and fastPtr.next are not null. This ensures that the fastPtr can move two nodes ahead at each iteration.\\n\\n4. Inside the loop, the prev pointer is updated to the current position of the slowPtr. Then, the fastPtr moves two nodes ahead, and the slowPtr moves one node ahead.\\n\\n5. Once the loop ends, the slowPtr is pointing to the middle node of the linked list.\\n\\n6. The code checks if prev is still null. If it is, it means the slowPtr is pointing to the first node. In this case, the head of the linked list is updated to the second node, effectively removing the first node.\\n\\n7. If prev is not null, it means the slowPtr is pointing to a middle node. The prev.next pointer is updated to skip the slowPtr, effectively removing the middle node.\\n\\n8. Finally, the modified linked list (with the middle node removed) is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n/2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null){\\n            return null;\\n        }\\n        ListNode fastPtr = head;\\n        ListNode slowPtr = head;\\n        ListNode prev = null;\\n\\n        while(fastPtr != null && fastPtr.next != null){\\n            prev = slowPtr;\\n            fastPtr = fastPtr.next.next;\\n            slowPtr = slowPtr.next;\\n        }\\n        if(prev == null){\\n            head = head.next;\\n        }else{\\n            prev.next = slowPtr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null){\\n            return null;\\n        }\\n        ListNode fastPtr = head;\\n        ListNode slowPtr = head;\\n        ListNode prev = null;\\n\\n        while(fastPtr != null && fastPtr.next != null){\\n            prev = slowPtr;\\n            fastPtr = fastPtr.next.next;\\n            slowPtr = slowPtr.next;\\n        }\\n        if(prev == null){\\n            head = head.next;\\n        }else{\\n            prev.next = slowPtr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575856,
                "title": "beats-100-proper-easy-explanation-java-solution",
                "content": "# Approach\\n- We have two pointers, p and q, initially pointing to the head of a linked list.\\n\\n- We want to move p one step forward and q two steps forward in each iteration so that q ends up being twice as far as p.\\n\\n- At each step, we keep track of the previous node of p using another pointer, let\\'s call it k.\\n\\n- After traversing the linked list, when q reaches the last element (i.e., q.next is null), p will be at the middle element.\\n\\n- By having the previous node of p stored in k, we can skip that node and reconnect the linked list, effectively removing the middle element.\\n\\nFinally, we return the head of the modified linked list.\\n\\nIn summary, this code solution involves traversing the linked list with two pointers (p and q), ensuring that q moves twice as fast as p. By keeping track of the previous node of p using k, we can skip the middle node when q reaches the end. The code ultimately returns the modified linked list without the middle node.\\n\\n- Don\\'t forgot to UpVote \\u2764\\uFE0F\\n\\n# Complexity\\n- Time complexity:O(n/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode p=head;  // slow \\n        ListNode k=new ListNode();\\n        k.next=head;\\n        ListNode q=head; //fast \\n        \\n        if(q.next==null)\\n        return null;\\n\\n        while( q!=null && q.next!=null)\\n        {\\n            k=k.next;\\n            p=p.next;\\n            q=q.next.next;\\n        }\\n        // p is pointing middle and k pointing previous node of p\\n        k.next=p.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode p=head;  // slow \\n        ListNode k=new ListNode();\\n        k.next=head;\\n        ListNode q=head; //fast \\n        \\n        if(q.next==null)\\n        return null;\\n\\n        while( q!=null && q.next!=null)\\n        {\\n            k=k.next;\\n            p=p.next;\\n            q=q.next.next;\\n        }\\n        // p is pointing middle and k pointing previous node of p\\n        k.next=p.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531142,
                "title": "c-solution-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteMiddle(struct ListNode* head){\\n  if(head->next==NULL){\\n    head=NULL;\\n    return head;\\n  }\\n  struct ListNode *fast=head,*slow=head,*prev;\\n  while(fast!=NULL&&fast->next!=NULL){\\n      prev=slow;\\n      slow=slow->next;\\n      fast=fast->next->next;\\n  }\\n  prev->next=slow->next;\\n  return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* deleteMiddle(struct ListNode* head){\\n  if(head->next==NULL){\\n    head=NULL;\\n    return head;\\n  }\\n  struct ListNode *fast=head,*slow=head,*prev;\\n  while(fast!=NULL&&fast->next!=NULL){\\n      prev=slow;\\n      slow=slow->next;\\n      fast=fast->next->next;\\n  }\\n  prev->next=slow->next;\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492380,
                "title": "easiest-c-solution-using-vector-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        vector<ListNode*> vec;\\n        ListNode* temp = head;\\n        while(temp){\\n            vec.emplace_back(temp);\\n            temp=temp->next;}\\n            \\n        int n=vec.size();\\n        if(n==1) return NULL;\\n\\n        else if(n==2){\\n            vec[n-2]->next=NULL;\\n            return head;}\\n\\n        else \\n            vec[n/2-1]->next=vec[(n/2)+1];\\n            return head;\\n        \\n    }\\n};\\nDO UPVOTE if it helped\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        vector<ListNode*> vec;\\n        ListNode* temp = head;\\n        while(temp){\\n            vec.emplace_back(temp);\\n            temp=temp->next;}\\n            \\n        int n=vec.size();\\n        if(n==1) return NULL;\\n\\n        else if(n==2){\\n            vec[n-2]->next=NULL;\\n            return head;}\\n\\n        else \\n            vec[n/2-1]->next=vec[(n/2)+1];\\n            return head;\\n        \\n    }\\n};\\nDO UPVOTE if it helped\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463124,
                "title": "concise-and-beginner-friend-code",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n         if (head == null || head.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        ListNode previous = null;\\n        while (fastPointer != null && fastPointer.next != null) {\\n            previous = slowPointer;\\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        }\\n        previous.next = slowPointer.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n         if (head == null || head.next == null) {\\n            return null;\\n        }\\n        ListNode slowPointer = head;\\n        ListNode fastPointer = head;\\n        ListNode previous = null;\\n        while (fastPointer != null && fastPointer.next != null) {\\n            previous = slowPointer;\\n            slowPointer = slowPointer.next;\\n            fastPointer = fastPointer.next.next;\\n        }\\n        previous.next = slowPointer.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350861,
                "title": "python-o-n-and-beats-98-55-trick-with-fast-and-slow-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is solved easily with a ```fast``` and ```slow``` pointers \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor reference sake, Fast pointer goes two steps and Slow pointer goes one step. When Fast pointer reaches NULL(nullptr), then Slow pointer will be in middle of Linked List. We just return our Slow pointer!. But since you can\\'t delete a node when you don\\'t have a pointer to its previous node, we keep track of another pointer, which I call ```mid```. Mid will always be one node behind slow, this means by the time ```slow``` is at the middle, ```mid``` is also the ```prev``` of ```slow```. The rest becomes easy, you just set the next of ```mid``` to ```mid.next.next```\\n\\n\\n\\n\\n**If this helped, then please give me an upvote**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        slow, fast = head, head\\n        mid = None\\n\\n        while fast and fast.next:\\n            mid = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        mid.next = mid.next.next\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```fast```\n```slow```\n```mid```\n```slow```\n```mid```\n```prev```\n```slow```\n```mid```\n```mid.next.next```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        slow, fast = head, head\\n        mid = None\\n\\n        while fast and fast.next:\\n            mid = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n\\n        mid.next = mid.next.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301479,
                "title": "easy-slow-fast-pointer-approach-99-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode curr = head;\\n        ListNode next;\\n        if(head.next == null)\\n            head = head.next;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        while(curr != null){\\n            if(curr.next == slow){\\n                curr.next = curr.next.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode curr = head;\\n        ListNode next;\\n        if(head.next == null)\\n            head = head.next;\\n        while(fast != null && fast.next != null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        while(curr != null){\\n            if(curr.next == slow){\\n                curr.next = curr.next.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288668,
                "title": "java-easy-solution-iterative-approach",
                "content": "\\n\\n# Approach\\nIterative Approach\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        int size=0;\\n        ListNode temp= head;\\n        while(temp != null){    // Calculating size\\n            temp= temp.next;\\n            size++;\\n        }\\n\\n        if (size==1){          //if the linkedlist contains only one node \\n            head=head.next;\\n            return head;\\n        }\\n        \\n        int i=0;\\n        ListNode prev= head;      //defining prev node to find the node which is just before the middle node (or which is pointing to the middle node)\\n\\n        while(i < (size/2)-1 ){   //loop runs from head node(i=0) to (middle-2)th node and prev becomes equal to the (middle-1)th node\\n            prev=prev.next;\\n            i++;\\n        }\\n\\n        prev.next = prev.next.next;   //now our prev (i.e. middle-1) points to the middle element\\'s next (i.e. middle+1) and the middle element has been deleted  \\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        int size=0;\\n        ListNode temp= head;\\n        while(temp != null){    // Calculating size\\n            temp= temp.next;\\n            size++;\\n        }\\n\\n        if (size==1){          //if the linkedlist contains only one node \\n            head=head.next;\\n            return head;\\n        }\\n        \\n        int i=0;\\n        ListNode prev= head;      //defining prev node to find the node which is just before the middle node (or which is pointing to the middle node)\\n\\n        while(i < (size/2)-1 ){   //loop runs from head node(i=0) to (middle-2)th node and prev becomes equal to the (middle-1)th node\\n            prev=prev.next;\\n            i++;\\n        }\\n\\n        prev.next = prev.next.next;   //now our prev (i.e. middle-1) points to the middle element\\'s next (i.e. middle+1) and the middle element has been deleted  \\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241625,
                "title": "my-c-solution-beats-98-95-0ms-run-time",
                "content": "//-------------> Pls Upvote if it is helpful for You <------------------//\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - Slow and Fast pointer Approach\\n\\n# Complexity\\n - Time Complexity: -----> RunTime Beats 98.95%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n // when list is empty Or only one Node head \\n\\n        if(head==nullptr || head->next==nullptr){\\n            return nullptr;\\n        }\\n\\n// use slow and fast pointer to find middle of linked list \\n//and retain its previous node in temp variable to remove the middle\\n// Node of linked list \\n\\n        ListNode * slow=head;\\n        ListNode* fast=head;\\n        ListNode* temp;\\n        while(fast!=nullptr && fast->next!=nullptr){\\n// store previous node each time  in temp before reaching the middle node\\n            temp=slow;  \\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n// after End of the while loop slow is the Middle Node Of the list \\n// store the middle node of linked list in mid variable \\n\\n        ListNode* mid=slow; \\n        temp->next=slow->next;\\n        delete mid; // then remove the mid form the memory \\n        return head;\\n    }\\n};\\n```                \\n---\\n\\n* //          **   Pls Upvote if it is helpful for you Thanks . **  ```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n // when list is empty Or only one Node head \\n\\n        if(head==nullptr || head->next==nullptr){\\n            return nullptr;\\n        }\\n\\n// use slow and fast pointer to find middle of linked list \\n//and retain its previous node in temp variable to remove the middle\\n// Node of linked list \\n\\n        ListNode * slow=head;\\n        ListNode* fast=head;\\n        ListNode* temp;\\n        while(fast!=nullptr && fast->next!=nullptr){\\n// store previous node each time  in temp before reaching the middle node\\n            temp=slow;  \\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n\\n// after End of the while loop slow is the Middle Node Of the list \\n// store the middle node of linked list in mid variable \\n\\n        ListNode* mid=slow; \\n        temp->next=slow->next;\\n        delete mid; // then remove the mid form the memory \\n        return head;\\n    }\\n};\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171575,
                "title": "simple-python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to remove the middle element, so one of the approach which I used is slow-fast pointer where fast pointer moves 2 steps while slow pointer moves 1 step.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initilize the slow as head and fast as head.next.\\n2. Now, traverse as per the fast and slow pointer rule.\\n3. When fast pointer reaches the end, slow will be at the middle of linked list.\\n4. Based on the observation, we need to remove the next node to the slow.\\n5. We get the required answer.\\nODD CASE:\\n![image.png](https://assets.leetcode.com/users/images/774f9997-b3d3-47c4-9dd0-fb518cf4abd3_1676113265.8737018.png)\\n\\nEVEN CASE:\\n![image.png](https://assets.leetcode.com/users/images/1ed211ee-4ac0-4546-a6ed-e641a913cce9_1676113387.2875319.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n//2) - O(n) - traversing half of the list\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - no extra space used\\n# Code\\n```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if(head.next==None):\\n            return None\\n        slow=head\\n        fast=head.next\\n        while(fast.next!=None and fast.next.next!=None):\\n            slow=slow.next\\n            fast=fast.next.next\\n        slow.next=slow.next.next\\n        return head\\n```\\nPlease upvote if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if(head.next==None):\\n            return None\\n        slow=head\\n        fast=head.next\\n        while(fast.next!=None and fast.next.next!=None):\\n            slow=slow.next\\n            fast=fast.next.next\\n        slow.next=slow.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152704,
                "title": "java-easy-sol-beats-100-two-pointers",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head.next == null) return null;\\n        if (head.next.next == null) {\\n            head.next = null;\\n            return head;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next.next;\\n        while (fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if (head.next == null) return null;\\n        if (head.next.next == null) {\\n            head.next = null;\\n            return head;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next.next;\\n        while (fast!=null && fast.next!=null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072338,
                "title": "fast-slow-pointer-approach",
                "content": "# Intuition & Approach\\nLike we find the middle of linked list using fast and slow pointers , we can use same concept here as well, with an addition to that, we will keep one more slow pointer, just behind the exisisting slow pointer.\\n\\n- f-> fast pointer ( will jump 2 nodes)\\n- s-> slow pointer ( will jump 1 node only [Goes to immediate next])\\n- p-> stores the last value of slow pointer ( acts as if it\\'s a tail of slow pointer ).\\n\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nMax number of iterations will be N/2 where N is length of linked list.\\nso Time Complexity is O(n).\\n\\n- Space complexity:\\nSince, only 3 extra nodes are used irrespective of number of nodes in a list, Space Complexity is O(1).\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode f=head,s=head,p=null;\\n        while(f!=null && f.next!=null){\\n            p=s;\\n            s=s.next;\\n            f=f.next.next;\\n        }\\n\\n        if(p==null){\\n            head=null;\\n        }else{\\n            p.next=s.next;\\n            s.next=null;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode f=head,s=head,p=null;\\n        while(f!=null && f.next!=null){\\n            p=s;\\n            s=s.next;\\n            f=f.next.next;\\n        }\\n\\n        if(p==null){\\n            head=null;\\n        }else{\\n            p.next=s.next;\\n            s.next=null;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071017,
                "title": "self-explanatory-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count(ListNode* head)\\n{\\n    int c=0;\\n    while(head!=NULL)\\n    {\\n        c++;\\n        head=head->next;\\n    }\\n    return c;\\n}\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode*temp=head;\\n        int c=count(head);\\n        int mid=c/2;\\n        if(c==1)\\n        {\\n            head=head->next;\\n            return head;\\n        }\\n        else\\n        {\\n            for(int i=1;i<mid;i++)\\n            {\\n                head=head->next;\\n            }\\n            if(head->next!=NULL)\\n            head->next=head->next->next;\\n            return temp;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint count(ListNode* head)\\n{\\n    int c=0;\\n    while(head!=NULL)\\n    {\\n        c++;\\n        head=head->next;\\n    }\\n    return c;\\n}\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode*temp=head;\\n        int c=count(head);\\n        int mid=c/2;\\n        if(c==1)\\n        {\\n            head=head->next;\\n            return head;\\n        }\\n        else\\n        {\\n            for(int i=1;i<mid;i++)\\n            {\\n                head=head->next;\\n            }\\n            if(head->next!=NULL)\\n            head->next=head->next->next;\\n            return temp;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030608,
                "title": "c-slow-fast-pointer-very-easy",
                "content": "* Time Complexity = `O(N)`\\n* Space Complexity = `O(1)`\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head || !head->next) return nullptr;\\n        ListNode* slow = head, *fast = head;\\n        ListNode* prev = nullptr;\\n\\n        while(fast && fast -> next) {\\n            prev = slow;\\n            slow = slow -> next;\\n            fast = fast -> next -> next; \\n        }\\n\\n        prev -> next = slow -> next;\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head || !head->next) return nullptr;\\n        ListNode* slow = head, *fast = head;\\n        ListNode* prev = nullptr;\\n\\n        while(fast && fast -> next) {\\n            prev = slow;\\n            slow = slow -> next;\\n            fast = fast -> next -> next; \\n        }\\n\\n        prev -> next = slow -> next;\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994098,
                "title": "easy-c-solution-by-2-approaches-beginner",
                "content": "# Find the middle node by counting the nodes \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\n\\nprivate:\\nint count(ListNode* head)\\n{\\n  ListNode* p = head;\\n  int cnt = 0;\\n\\n  while(p != NULL)\\n  {\\n      cnt++;\\n      p = p->next;\\n  }\\n\\n  return cnt;\\n}\\n\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n      if(head == NULL){\\n        return NULL;\\n      }\\n      \\n      if(count(head) == 1)\\n      {\\n        return NULL;\\n      }\\n      if(count(head) == 2)\\n      {\\n        head->next = NULL;\\n        return head;\\n      }\\n\\n      int n = count(head);\\n\\n      ListNode *p = head;\\n      ListNode *q = head;\\n\\n      for(int i = 0; i<n/2; i++)\\n      {\\n        q = p;\\n        p = p->next;\\n      }\\n\\n      q->next = p->next;\\n      \\n      delete (p);\\n\\n      return head;\\n\\n      \\n\\n        \\n    }\\n\\n};\\n```\\n\\n\\n\\n# Two pointers approach(tortoise and hare)\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n      if(head == NULL || head->next == NULL)\\n      {\\n        return NULL;\\n      }\\n\\n      ListNode* fast = head;\\n      ListNode* slow = head;\\n      ListNode* prev = NULL;\\n\\n      while(fast != NULL && fast->next != NULL)\\n      {\\n        prev = slow;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        \\n      }\\n\\n      prev->next = slow->next;\\n\\n      return head;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\n\\nprivate:\\nint count(ListNode* head)\\n{\\n  ListNode* p = head;\\n  int cnt = 0;\\n\\n  while(p != NULL)\\n  {\\n      cnt++;\\n      p = p->next;\\n  }\\n\\n  return cnt;\\n}\\n\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n      if(head == NULL){\\n        return NULL;\\n      }\\n      \\n      if(count(head) == 1)\\n      {\\n        return NULL;\\n      }\\n      if(count(head) == 2)\\n      {\\n        head->next = NULL;\\n        return head;\\n      }\\n\\n      int n = count(head);\\n\\n      ListNode *p = head;\\n      ListNode *q = head;\\n\\n      for(int i = 0; i<n/2; i++)\\n      {\\n        q = p;\\n        p = p->next;\\n      }\\n\\n      q->next = p->next;\\n      \\n      delete (p);\\n\\n      return head;\\n\\n      \\n\\n        \\n    }\\n\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n\\n      if(head == NULL || head->next == NULL)\\n      {\\n        return NULL;\\n      }\\n\\n      ListNode* fast = head;\\n      ListNode* slow = head;\\n      ListNode* prev = NULL;\\n\\n      while(fast != NULL && fast->next != NULL)\\n      {\\n        prev = slow;\\n        fast = fast->next->next;\\n        slow = slow->next;\\n        \\n      }\\n\\n      prev->next = slow->next;\\n\\n      return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962148,
                "title": "easy-to-understand-simple-c-solution-slow-fast-pointers",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head==NULL || head->next==NULL)return NULL;\\n        // 2 or more nodes\\n        ListNode* fast= head;\\n        ListNode* slow= head;\\n        ListNode* prev= head;    \\n        while (fast && fast->next){\\n            fast= fast->next->next;\\n            prev= slow;\\n            slow= slow->next;\\n        }\\n        prev->next = prev->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (head==NULL || head->next==NULL)return NULL;\\n        // 2 or more nodes\\n        ListNode* fast= head;\\n        ListNode* slow= head;\\n        ListNode* prev= head;    \\n        while (fast && fast->next){\\n            fast= fast->next->next;\\n            prev= slow;\\n            slow= slow->next;\\n        }\\n        prev->next = prev->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880295,
                "title": "java",
                "content": "If you like it pls upvote.\\n\\n```\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode first = head;\\n        int size = 0;\\n\\n        while (first != null) {\\n            size++;\\n            first = first.next;\\n        }\\n\\n        int mid = size / 2;\\n\\n        ListNode second = head;\\n\\n        ListNode res = new ListNode(-1);\\n        ListNode prev;\\n        prev = res;\\n\\n        for (int i = 0; i < mid; i++) {\\n            prev.next = new ListNode(second.val);\\n            prev = prev.next;\\n            second = second.next;\\n        }\\n\\n        prev.next = second.next;\\n        return res.next;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode first = head;\\n        int size = 0;\\n\\n        while (first != null) {\\n            size++;\\n            first = first.next;\\n        }\\n\\n        int mid = size / 2;\\n\\n        ListNode second = head;\\n\\n        ListNode res = new ListNode(-1);\\n        ListNode prev;\\n        prev = res;\\n\\n        for (int i = 0; i < mid; i++) {\\n            prev.next = new ListNode(second.val);\\n            prev = prev.next;\\n            second = second.next;\\n        }\\n\\n        prev.next = second.next;\\n        return res.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2879567,
                "title": "c-optimized-easy-code-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWE NEED TO CALCULATE THE COUNT OF ELEMENTS TO CALCULATE THE MIDDLE ELEMENT.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHERE TEMP IS TEMPORARY VARIABLE.WE HAVE ASSIGNED TEMP =HEAD\\nAND ITERATED THE WHOLE LINK LIST TO CALCULATE COUNT.\\n```\\n while(temp->next!=NULL){\\n        temp=temp->next;\\n        count++;}\\n```\\nIF OUR LINKLIST HAS ONLY ONE VALUE WE WILL RETURN NULL\\n```\\n if(count==1){return NULL;}\\n```\\nSINCE OUR TEMP IS AT THE LAST NODE WE WILL REASSIGN TEMP =HEAD SO THAT WE CAN TRAVERSE THE LINKLIST  FROM BEGINING ONCE AGAIN   **temp=head;**\\n\\nONCE WE GET THE COUNT WE WILL CALCULATE MID=COUNT/2; THIS WILL GIVE FLOOR VALUE INCASE OF 7 IT WILL RETURN 3 SO WE NEED TO REMOVE NODE NO 3\\nSO WE WILL ITERATE TO NODE THAT IS JUST BEFORE OUR TARGET NODE TO BE DELETED SO I HAVE STORED MID=COUNT/2-1;\\n\\nONCE WE WILL GET TO NODE BEFORE THE NODE TO BE DELETED WE COME OUT OF WHILE LOOP\\n```\\n while(mid--){\\n         temp=temp->next;\\n       }\\n```\\nAFTER WHILE LOOP WE WILL POINT OUR TEMP\\'S NEXT TO NEXT OF (TEMP\\'S NEXT)\\n```\\n temp->next=(temp->next)->next;\\n```\\nSO IT WILL SKIP THE NODE TO BE DELETED \\n```\\nreturn head;\\n```\\n**AND FINALLY WE WILL RETUTRN HEAD WHICH IS OUR RESULT.**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N)$ **WE HAVE TRAVERSED THE WHOLE LINKLIST**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$ **ONLY TEMP EXTRA VARIABLE (MEMORY ) IS USED**\\n\\n\\n###### **IF MY EXPLANATION AND CODE IS EASY AND UNDERSTANDABLE  UPVOTE MY SOLUTION SO THAT OTHER BEGINNERS CAN SEE IT**\\n\\n##### IF HAVE ANY DOUBT ASK IN COMMENT SECTION\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n      ListNode *temp=new ListNode();\\n      \\n      int count=1,mid=0;\\n      temp=head;\\n      while(temp->next!=NULL){\\n        temp=temp->next;\\n        count++;}\\n        \\n      if(count==1){return NULL;}\\n        \\n       mid=count/2-1;\\n       temp=head;\\n       while(mid--){\\n         temp=temp->next;\\n       }\\n        temp->next=(temp->next)->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Doubly-Linked List"
                ],
                "code": "```\\n while(temp->next!=NULL){\\n        temp=temp->next;\\n        count++;}\\n```\n```\\n if(count==1){return NULL;}\\n```\n```\\n while(mid--){\\n         temp=temp->next;\\n       }\\n```\n```\\n temp->next=(temp->next)->next;\\n```\n```\\nreturn head;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n      ListNode *temp=new ListNode();\\n      \\n      int count=1,mid=0;\\n      temp=head;\\n      while(temp->next!=NULL){\\n        temp=temp->next;\\n        count++;}\\n        \\n      if(count==1){return NULL;}\\n        \\n       mid=count/2-1;\\n       temp=head;\\n       while(mid--){\\n         temp=temp->next;\\n       }\\n        temp->next=(temp->next)->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825714,
                "title": "c-o-n-easy-explanation-two-pointers-memory-leak-handling",
                "content": "To begin, try the **[Middle of the Linked List issue](https://leetcode.com/problems/middle-of-the-linked-list/)**. Then you\\'d have a good idea of what\\'s going on and its **[DISCUSSION](https://leetcode.com/problems/middle-of-the-linked-list/discuss/2824243/c-on-easy-explanation-two-pointers)** here.\\n\\n**Time Complexity:** O(N/2)=O(N)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL)   //edge case\\n            return NULL;\\n        \\n        ListNode* fast=head;                //fast pointer moves 2 steps\\n        ListNode* slow=head;                //slow pointer moves 1 step\\n        ListNode* temp=new ListNode();      // temp to have access to slow node\\'s previous\\n        \\n        temp->next=head;                    //slow starts from head, i.e. why making temp before head\\n        \\n        while(fast && fast->next){          //to find the middle\\n            temp=temp->next;\\n            slow=slow->next;\\n            fast=fast->next->next;     \\n            \\n        }\\n        \\n        temp->next=slow->next;              //deleting the slow pointer \\n\\t\\t\\tdelete slow;                    //memory leak handling\\n        return head;                        //returning the head\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head==NULL || head->next==NULL)   //edge case\\n            return NULL;\\n        \\n        ListNode* fast=head;                //fast pointer moves 2 steps\\n        ListNode* slow=head;                //slow pointer moves 1 step\\n        ListNode* temp=new ListNode();      // temp to have access to slow node\\'s previous\\n        \\n        temp->next=head;                    //slow starts from head, i.e. why making temp before head\\n        \\n        while(fast && fast->next){          //to find the middle\\n            temp=temp->next;\\n            slow=slow->next;\\n            fast=fast->next->next;     \\n            \\n        }\\n        \\n        temp->next=slow->next;              //deleting the slow pointer \\n\\t\\t\\tdelete slow;                    //memory leak handling\\n        return head;                        //returning the head\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703825,
                "title": "easiest-approach-5-lines-only",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n      if(!head->next) return NULL;\\n      ListNode* slow = head, *fast = head->next->next;\\n      while(fast && fast->next)\\n      {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n      }\\n      slow->next = slow->next->next;\\n      return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n      if(!head->next) return NULL;\\n      ListNode* slow = head, *fast = head->next->next;\\n      while(fast && fast->next)\\n      {\\n        slow = slow->next;\\n        fast = fast->next->next;\\n      }\\n      slow->next = slow->next->next;\\n      return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703397,
                "title": "simple-c-basic-pointer-solution",
                "content": "plz upvote if it helps\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n     if(head==NULL || head->next==NULL)   \\n         return NULL;\\n        \\n        ListNode *prev=NULL,*slow=head,*fast=head;\\n        \\n        while(fast!=NULL and fast->next!=NULL ){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        prev->next=slow->next;\\n        delete slow;\\n        return head;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n     if(head==NULL || head->next==NULL)   \\n         return NULL;\\n        \\n        ListNode *prev=NULL,*slow=head,*fast=head;\\n        \\n        while(fast!=NULL and fast->next!=NULL ){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        prev->next=slow->next;\\n        delete slow;\\n        return head;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703395,
                "title": "easy-java-code",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null)return null;\\n        ListNode slow=head,fast=head;\\n        ListNode prev=new ListNode(0);\\n        prev.next=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            prev=prev.next;\\n            fast=fast.next.next;\\n        }\\n        if(slow.next==null){\\n            prev.next=null;\\n        }\\n        else {\\n            delete(slow);\\n            \\n        }\\n        return head;\\n    }\\n    public void delete(ListNode node){\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null)return null;\\n        ListNode slow=head,fast=head;\\n        ListNode prev=new ListNode(0);\\n        prev.next=head;\\n        while(fast!=null && fast.next!=null){\\n            slow=slow.next;\\n            prev=prev.next;\\n            fast=fast.next.next;\\n        }\\n        if(slow.next==null){\\n            prev.next=null;\\n        }\\n        else {\\n            delete(slow);\\n            \\n        }\\n        return head;\\n    }\\n    public void delete(ListNode node){\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703089,
                "title": "c-short-and-clean-code-two-pointer-slow-fast-pointer",
                "content": "**Make Sure To Dry Run This Code**\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* nodeBeforeMid;\\n        \\n        while(fast && fast->next){\\n            nodeBeforeMid = slow;\\n            fast = fast->next->next;\\n            slow = slow->next; \\n        }\\n        nodeBeforeMid->next = nodeBeforeMid->next->next;\\n        return head;\\n    }\\n};\\n\\n**Time Complexity :- O(N)**\\n**Space Complexity :- O(1)**\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head == NULL || head->next == NULL)\\n            return NULL;\\n        \\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n        ListNode* nodeBeforeMid;\\n        \\n        while(fast && fast->next){\\n            nodeBeforeMid = slow;\\n            fast = fast->next->next;\\n            slow = slow->next; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2702878,
                "title": "java-easy-96-faster-fast-slow-pointer",
                "content": "# Please Upvote \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\n\\t\\tif (head.next == null)\\n            return null;\\n        ListNode slow = head, fast = head.next.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n\\t\\tif (head.next == null)\\n            return null;\\n        ListNode slow = head, fast = head.next.next;\\n        while (fast != null && fast.next != null) {\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.next = slow.next.next;\\n        return head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702147,
                "title": "c-mid-2-1-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head -> next == NULL){\\n            return NULL;\\n        }\\n        int cntNodes = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            temp = temp->next;\\n            cntNodes++;\\n        }\\n        \\n        int n = (cntNodes/2)-1;\\n        temp = head;\\n        while(n--){\\n            temp = temp->next;\\n        }\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head -> next == NULL){\\n            return NULL;\\n        }\\n        int cntNodes = 0;\\n        ListNode* temp = head;\\n        while(temp != NULL){\\n            temp = temp->next;\\n            cntNodes++;\\n        }\\n        \\n        int n = (cntNodes/2)-1;\\n        temp = head;\\n        while(n--){\\n            temp = temp->next;\\n        }\\n        temp->next = temp->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701933,
                "title": "rust-fastest-100-safe-one-pointer-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/822229458/) employs a single pointer approach together with calculation of list\\'s size. It demonstrated **140 ms runtime (100.00%)** and used **9.9 MB memory (70.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\nPlease check the analogous solution in [**Python**](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/2701755/Python-single-pointer-solution-(with-detailed-comments)).\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn delete_middle(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut sz = 0;\\n        \\n        // [1] find the size of the list\\n        let mut node = head.as_ref();\\n        while node.is_some() { node = node.unwrap().next.as_ref(); sz += 1; }\\n\\n        // [2] trivial case\\n        if sz <= 1 { return Option::None; }\\n\\n        // [3] typical case\\n        sz /= 2;\\n        let mut node = head.as_mut();\\n        while sz > 1 { node = node.unwrap().next.as_mut(); sz -= 1; }\\n        node.unwrap().next = node.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n\\n        return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Linked List"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn delete_middle(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> \\n    {\\n        let mut sz = 0;\\n        \\n        // [1] find the size of the list\\n        let mut node = head.as_ref();\\n        while node.is_some() { node = node.unwrap().next.as_ref(); sz += 1; }\\n\\n        // [2] trivial case\\n        if sz <= 1 { return Option::None; }\\n\\n        // [3] typical case\\n        sz /= 2;\\n        let mut node = head.as_mut();\\n        while sz > 1 { node = node.unwrap().next.as_mut(); sz -= 1; }\\n        node.unwrap().next = node.as_mut().unwrap().next.as_mut().unwrap().next.take();\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701763,
                "title": "easy-to-understand-java-solution",
                "content": "```\\n/** 2095. Delete the Middle Node of a Linked List **/\\n\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        //when only 1 node are there\\n        if(head.next==null){\\n            return null;\\n        }\\n        \\n        //when only 2 node are there\\n        if(head.next.next==null){\\n            head.next = null;\\n            return head;\\n        }\\n        \\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        slow.val = slow.next.val;  \\n        slow.next = slow.next.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        //when only 1 node are there\\n        if(head.next==null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2701682,
                "title": "c-easy-and-simple-solution-with-explanation",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        //if there is 0 or 1 node we simply return NULL\\n        if(head == NULL || head->next == NULL) return NULL;\\n        \\n        //to solve this problem we can use the two pointer approach\\n        //to find the middle of linked list we make a third pointer prev which keeps account of a node previous to the middle node so that at the end we can remove the middle node\\n        ListNode* prev = NULL; //to find the middle of linked list we make a third pointer prev which keeps account of a node previous to the middle node so that at the end we can remove the middle node\\n        //slow moves only one step\\n        //fast moves two step at a time so that when it reaches the end the slow pointer ends with the middle node\\n        ListNode* slow = head; \\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        \\n        //attach one previous node of middle to the next of middle\\n        prev->next = slow->next;\\n        return head;\\n    }\\n};\\n\\n**Upvote if you found this solution helpful** \\u2B50",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        //if there is 0 or 1 node we simply return NULL\\n        if(head == NULL || head->next == NULL) return NULL;\\n        \\n        //to solve this problem we can use the two pointer approach\\n        //to find the middle of linked list we make a third pointer prev which keeps account of a node previous to the middle node so that at the end we can remove the middle node\\n        ListNode* prev = NULL; //to find the middle of linked list we make a third pointer prev which keeps account of a node previous to the middle node so that at the end we can remove the middle node\\n        //slow moves only one step\\n        //fast moves two step at a time so that when it reaches the end the slow pointer ends with the middle node\\n        ListNode* slow = head; \\n        ListNode* fast = head;\\n        \\n        while(fast != NULL && fast->next != NULL){\\n            prev = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2701621,
                "title": "best-solution-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return NULL;\\n        ListNode *ptr=head,*tmp=head;\\n        int n=0,final=0;\\n        while(ptr!=NULL){\\n            n++;\\n            ptr=ptr->next;\\n        }\\n        final=n/2;\\n        for(int i=0;i<final-1;i++)\\n            tmp=tmp->next;\\n        ptr=tmp->next->next;\\n        tmp->next=ptr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return NULL;\\n        ListNode *ptr=head,*tmp=head;\\n        int n=0,final=0;\\n        while(ptr!=NULL){\\n            n++;\\n            ptr=ptr->next;\\n        }\\n        final=n/2;\\n        for(int i=0;i<final-1;i++)\\n            tmp=tmp->next;\\n        ptr=tmp->next->next;\\n        tmp->next=ptr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701585,
                "title": "java-solution-fast-and-slow-pointer",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)return null;\\n        if(head.next.next==null){\\n            head.next = null;\\n            return head;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.val = slow.next.val;\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head.next==null)return null;\\n        if(head.next.next==null){\\n            head.next = null;\\n            return head;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        while(fast!=null && fast.next!=null){\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        slow.val = slow.next.val;\\n        slow.next = slow.next.next;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701473,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode prev = null;\\n        while(current!=null){\\n            count++;\\n            current = current.next;\\n        }\\n        current = head;\\n        if(count==1){\\n            return null;\\n        }\\n        if(count%2==1){\\n            for(int i = 0;i<Math.floor(count/2);i++){\\n                prev = current;\\n                current = current.next;\\n            }\\n            prev.next = current.next;\\n            //current = prev.next;\\n        }\\n        else{\\n            for(int i = 0;i<count/2;i++){\\n                prev = current;\\n                current = current.next;\\n            }\\n            prev.next = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        int count = 0;\\n        ListNode current = head;\\n        ListNode prev = null;\\n        while(current!=null){\\n            count++;\\n            current = current.next;\\n        }\\n        current = head;\\n        if(count==1){\\n            return null;\\n        }\\n        if(count%2==1){\\n            for(int i = 0;i<Math.floor(count/2);i++){\\n                prev = current;\\n                current = current.next;\\n            }\\n            prev.next = current.next;\\n            //current = prev.next;\\n        }\\n        else{\\n            for(int i = 0;i<count/2;i++){\\n                prev = current;\\n                current = current.next;\\n            }\\n            prev.next = current.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701368,
                "title": "easy-java-solution-100-faster-98-memory-efficient",
                "content": "class Solution {\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode ptr=head;\\n        ListNode ptr2=head.next;\\n        if(ptr==null)return null;\\n        if(ptr.next==null){head=null;return head;}\\n\\t\\t\\n\\t\\t//when ptr2 reach end ptr reaches mid;\\n\\t\\t\\n        while(ptr2.next!=null&&ptr2.next.next!=null){\\n            ptr=ptr.next;\\n            ptr2=ptr2.next.next;\\n        }\\n       ptr.next=ptr.next.next;\\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode deleteMiddle(ListNode head) {\\n        ListNode ptr=head;\\n        ListNode ptr2=head.next;\\n        if(ptr==null)return null;\\n        if(ptr.next==null){head=null;return head;}",
                "codeTag": "Java"
            },
            {
                "id": 2701277,
                "title": "delete-the-middle-node-of-a-linked-list-c",
                "content": "# Intuition\\nIterate till the previous node of the middle node and set that node\\'s next as node\\'s next next.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\nClose to $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int size_of_ll(ListNode* head){\\n        int cnt = 0;\\n        while(head){\\n            cnt++;\\n            head = head -> next;\\n        }\\n        return cnt;\\n    }\\n\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head -> next) return NULL;\\n        int tar = size_of_ll(head) / 2 - 1;\\n        ListNode* temp = head;\\n\\n        while(tar--){\\n            temp = temp -> next;\\n        }\\n\\n        temp -> next = temp -> next -> next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int size_of_ll(ListNode* head){\\n        int cnt = 0;\\n        while(head){\\n            cnt++;\\n            head = head -> next;\\n        }\\n        return cnt;\\n    }\\n\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head -> next) return NULL;\\n        int tar = size_of_ll(head) / 2 - 1;\\n        ListNode* temp = head;\\n\\n        while(tar--){\\n            temp = temp -> next;\\n        }\\n\\n        temp -> next = temp -> next -> next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701067,
                "title": "floyd-s-slow-and-fast-pointer-c-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* slow=head,*fast=head->next, *prev;\\n        if(!head->next)\\n        {\\n            return NULL;\\n        }\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            prev=slow;\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        // in case of odd length linkedlist slow pointer will point at middle of the linked list and in case of even length linked list slow pointer will point at previous node of middle node.\\n        if(fast==NULL)// checking if linkedlist is of odd lenth or even length \\n        {\\n        prev->next=prev->next->next;\\n        }\\n        else\\n        {\\n        slow->next=slow->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        ListNode* slow=head,*fast=head->next, *prev;\\n        if(!head->next)\\n        {\\n            return NULL;\\n        }\\n        while(fast!=NULL && fast->next!=NULL)\\n        {\\n            prev=slow;\\n            fast=fast->next->next;\\n            slow=slow->next;\\n        }\\n        // in case of odd length linkedlist slow pointer will point at middle of the linked list and in case of even length linked list slow pointer will point at previous node of middle node.\\n        if(fast==NULL)// checking if linkedlist is of odd lenth or even length \\n        {\\n        prev->next=prev->next->next;\\n        }\\n        else\\n        {\\n        slow->next=slow->next->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701063,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteMiddle = function(head) {\\n    if(head.next==null){return null;}\\n    let first = head; \\n    let last = head; \\n    let previous;\\n    while(last && last.next){\\n        last = last.next.next;\\n        previous = first;\\n        first = first.next;\\n    }\\n    previous.next = previous.next.next;\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar deleteMiddle = function(head) {\\n    if(head.next==null){return null;}\\n    let first = head; \\n    let last = head; \\n    let previous;\\n    while(last && last.next){\\n        last = last.next.next;\\n        previous = first;\\n        first = first.next;\\n    }\\n    previous.next = previous.next.next;\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701018,
                "title": "simple-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n         if( head == null || head.next == null){           \\n            return null; \\n         }\\n          ListNode slow = head;\\n          ListNode fast = head;\\n          ListNode prev = null;\\n          while(fast!=null && fast.next!=null){\\n            prev = slow;                                         \\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;                             \\n        return head;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n         if( head == null || head.next == null){           \\n            return null; \\n         }\\n          ListNode slow = head;\\n          ListNode fast = head;\\n          ListNode prev = null;\\n          while(fast!=null && fast.next!=null){\\n            prev = slow;                                         \\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        prev.next = slow.next;                             \\n        return head;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700985,
                "title": "c-fast-and-slow-pointer-time-complexity-o-n-efficient-approach",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next)\\n            return NULL;\\n        ListNode *fast=head->next->next ,*slow = head; //initializing fast to head->next->next so only we will get slow before the middle\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next)\\n            return NULL;\\n        ListNode *fast=head->next->next ,*slow = head; //initializing fast to head->next->next so only we will get slow before the middle\\n        while(fast && fast->next){\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700570,
                "title": "js-faster-than-97-92-in-first-run",
                "content": "![image](https://assets.leetcode.com/users/images/04d3b722-11c1-4186-a1dc-af17d29273d7_1665716234.9231985.png)\\n\\n```\\nvar deleteMiddle = function(head) {\\n    \\n    const getLength = (list, count) => {\\n        if (list.next) {\\n            return getLength(list.next, count + 1);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    const mid = Math.floor(getLength(head, 1) / 2);\\n    \\n    if (!mid) {\\n        return null;\\n    }\\n    \\n    const loop = (list, count) => {\\n        if (list?.next) {\\n            \\n            if (count + 1 === mid) {\\n                if (list.next?.next) {\\n                    list.next.val = list.next.next.val;\\n                    list.next.next = list.next.next.next;\\n                    return head;\\n                } else {\\n                    list.next = null;\\n                }\\n            } else {\\n                loop(list.next, count + 1);\\n            }\\n        }\\n    }\\n    \\n    loop(head, 0);\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteMiddle = function(head) {\\n    \\n    const getLength = (list, count) => {\\n        if (list.next) {\\n            return getLength(list.next, count + 1);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    const mid = Math.floor(getLength(head, 1) / 2);\\n    \\n    if (!mid) {\\n        return null;\\n    }\\n    \\n    const loop = (list, count) => {\\n        if (list?.next) {\\n            \\n            if (count + 1 === mid) {\\n                if (list.next?.next) {\\n                    list.next.val = list.next.next.val;\\n                    list.next.next = list.next.next.next;\\n                    return head;\\n                } else {\\n                    list.next = null;\\n                }\\n            } else {\\n                loop(list.next, count + 1);\\n            }\\n        }\\n    }\\n    \\n    loop(head, 0);\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700451,
                "title": "c-easy-to-understand-o-n-using-while-loop",
                "content": "# Please upvote\\uD83D\\uDC4D if it is helpful\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL )\\n            return head;\\n        if(head->next==NULL)\\n            return nullptr;\\n        int s=0;\\n        ListNode* temp =head;\\n        while(temp!=NULL){\\n            s++;\\n            temp=temp->next;\\n        }\\n        int n=s/2;\\n        int i=1;\\n        \\n        temp=head;\\n        while(temp!=NULL){\\n            if(i==n){\\n                temp->next=temp->next->next;\\n                break;\\n            }\\n            temp=temp->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Greedy",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL )\\n            return head;\\n        if(head->next==NULL)\\n            return nullptr;\\n        int s=0;\\n        ListNode* temp =head;\\n        while(temp!=NULL){\\n            s++;\\n            temp=temp->next;\\n        }\\n        int n=s/2;\\n        int i=1;\\n        \\n        temp=head;\\n        while(temp!=NULL){\\n            if(i==n){\\n                temp->next=temp->next->next;\\n                break;\\n            }\\n            temp=temp->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698280,
                "title": "slow-pointer-fast-pointer-beats-100",
                "content": "# Intuition\\nSlow pointer Fast pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSlow pointer Fast pointer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null)\\n            return null;\\n        if(head.next == null)\\n            return null;\\n        ListNode slow= head;\\n        ListNode fast= head.next.next;\\n\\n        while(fast != null && fast.next != null){\\n            slow= slow.next;\\n            fast= fast.next.next;\\n        }\\n        slow.next= slow.next.next;\\n        return head;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null)\\n            return null;\\n        if(head.next == null)\\n            return null;\\n        ListNode slow= head;\\n        ListNode fast= head.next.next;\\n\\n        while(fast != null && fast.next != null){\\n            slow= slow.next;\\n            fast= fast.next.next;\\n        }\\n        slow.next= slow.next.next;\\n        return head;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683025,
                "title": "easy-and-beginner-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have to remove middle of LL so i need prev of middle node\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate Length of LL\\n2. Traverse LL to one before of middle node\\n3. Change the pointer reference of \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int CountLL(ListNode* head){\\n      ListNode* curr=head;\\n      int count=0;\\n      while(curr!=NULL){\\n        count++;\\n        curr=curr->next;\\n      }\\n      return count;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n          return NULL;\\n        }\\n        int middle=CountLL(head)/2;\\n        ListNode* curr=head;\\n        while(middle!=1){\\n            middle--;\\n            curr=curr->next;\\n        }\\n        curr->next=curr->next->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int CountLL(ListNode* head){\\n      ListNode* curr=head;\\n      int count=0;\\n      while(curr!=NULL){\\n        count++;\\n        curr=curr->next;\\n      }\\n      return count;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head==NULL || head->next==NULL){\\n          return NULL;\\n        }\\n        int middle=CountLL(head)/2;\\n        ListNode* curr=head;\\n        while(middle!=1){\\n            middle--;\\n            curr=curr->next;\\n        }\\n        curr->next=curr->next->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656166,
                "title": "java-solution",
                "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null)\\n            return null;\\n        ListNode fast,slow,prev;\\n        fast=slow=prev=head;\\n        \\n            while(fast!=null && fast.next!=null){\\n                prev=slow;\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                \\n            }\\n        prev.next=slow.next;\\n        return head;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null)\\n            return null;\\n        ListNode fast,slow,prev;\\n        fast=slow=prev=head;\\n        \\n            while(fast!=null && fast.next!=null){\\n                prev=slow;\\n                fast=fast.next.next;\\n                slow=slow.next;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2651021,
                "title": "2095-delete-the-middle-node-of-a-linked-list",
                "content": "[](http://)class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head->next == NULL)\\n        {\\n            head = NULL;\\n            return head;\\n        }\\n      \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast != NULL && fast->next != NULL)\\n        {\\n         \\n            fast = fast->next->next;\\n            if(fast == NULL || fast->next == NULL)\\n            {\\n                break;\\n            }\\n            slow = slow->next;\\n        }\\n        slow->next = slow->next->next;\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        \\n        if(head->next == NULL)\\n        {\\n            head = NULL;\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2649794,
                "title": "2-approch-1-count-length-2-using-slow-and-fast-pointer-java",
                "content": "// Runtime: 9 ms  Memory Usage :205.6 MB\\n\\npublic ListNode deleteMiddle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        int n = 0;\\n        while(curr!=null){\\n            n++;\\n            curr = curr.next;\\n        }\\n        if(n==1)return null;\\n        curr = head;\\n        int mid = n/2 -1;\\n        int i=0;\\n        while(i<mid){\\n            curr = curr.next;\\n            i++;\\n        }\\n        curr.next = curr.next.next;\\n        return head;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t//Runtime: 6 ms Memory Usage: 227.8 MB\\n\\t\\n\\tif(head.next==null){\\n            return null;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast!=null && fast.next!=null){\\n            \\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next!=slow){\\n            curr = curr.next;\\n        }\\n        curr.next = slow.next;\\n        return head;",
                "solutionTags": [
                    "Java"
                ],
                "code": "// Runtime: 9 ms  Memory Usage :205.6 MB\\n\\npublic ListNode deleteMiddle(ListNode head) {\\n        \\n        ListNode curr = head;\\n        int n = 0;\\n        while(curr!=null){\\n            n++;\\n            curr = curr.next;\\n        }\\n        if(n==1)return null;\\n        curr = head;\\n        int mid = n/2 -1;\\n        int i=0;\\n        while(i<mid){\\n            curr = curr.next;\\n            i++;\\n        }\\n        curr.next = curr.next.next;\\n        return head;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t//Runtime: 6 ms Memory Usage: 227.8 MB\\n\\t\\n\\tif(head.next==null){\\n            return null;\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        \\n        while(fast!=null && fast.next!=null){\\n            \\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n        \\n        ListNode curr = head;\\n        \\n        while(curr.next!=slow){\\n            curr = curr.next;\\n        }\\n        curr.next = slow.next;\\n        return head;",
                "codeTag": "Unknown"
            },
            {
                "id": 2646693,
                "title": "simple-java-solution-faster-than-96",
                "content": "\\nuse two pointer one move to the next node and the other move with twice speed \\nonce the second reach the end of linked list the first pointer will be in the middle\\n\\n\\n```\\nclass Solution {\\n      public ListNode deleteMiddle(ListNode head) {\\n      if (head == null) return null;\\n      if (head.next == null) return null;\\n      var current = head;\\n      var fast=current.next.next;\\n      while (fast!=null && fast.next != null){\\n          current = current.next;\\n          fast = fast.next.next;\\n      }\\n       current.next = current.next.next;\\n       return head;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n      public ListNode deleteMiddle(ListNode head) {\\n      if (head == null) return null;\\n      if (head.next == null) return null;\\n      var current = head;\\n      var fast=current.next.next;\\n      while (fast!=null && fast.next != null){\\n          current = current.next;\\n          fast = fast.next.next;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2611993,
                "title": "easy-c-2-pointer-approach-o-n-2-time-o-1-space-deleting-node",
                "content": "***A NOTE FOR FELLOW PROGRAMMERS*** : You might solve the solution without using the ```delete``` function and leaving the existing node as it is but this is a bad practice in the industry. Whenever you leave a node and just unlink it from the linked list without deleting it, this might ause data leak. Over here in this question the data contained in the nodes are numbers but when you will be working for a firm, then you must keep in mind that these lists might contain sensitive data, this is why deleting a node after freeing it is important.\\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next){\\n            delete head;  /*this is important to do*/\\n            return NULL;\\n        }\\n        ListNode *slow=head,*fast=head,*prev;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        prev->next=slow->next;\\n        delete slow;         /*this is important to do*/\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```delete```\n```\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(!head->next){\\n            delete head;  /*this is important to do*/\\n            return NULL;\\n        }\\n        ListNode *slow=head,*fast=head,*prev;\\n        while(fast && fast->next){\\n            prev=slow;\\n            slow=slow->next;\\n            fast=fast->next->next;\\n        }\\n        prev->next=slow->next;\\n        delete slow;         /*this is important to do*/\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533096,
                "title": "c-100-faster-solution-0ms-solution-easy-to-understand",
                "content": "**Please Upvote If helpful\\nComment down your doubts**\\n```cpp\\nclass Solution {\\npublic:\\n    int getcount(ListNode* head){\\n        ListNode* temp=head;\\n        int count=0;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n        }\\n        return count/2;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        int mid=getcount(head);\\n        ListNode* temp=head;\\n        for(int i=0;i<mid-1;i++){\\n            temp=temp->next;\\n        }\\n        temp->next=temp->next->next;\\n        return head;\\n    }\\n};\\n```\\n**Second solution**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* getmiddle(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast!=NULL){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        ListNode* mid=getmiddle(head);\\n        if(mid->next==NULL){\\n            head->next=NULL;\\n        }else{\\n            mid->val=mid->next->val;\\n            mid->next=mid->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getcount(ListNode* head){\\n        ListNode* temp=head;\\n        int count=0;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n        }\\n        return count/2;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        int mid=getcount(head);\\n        ListNode* temp=head;\\n        for(int i=0;i<mid-1;i++){\\n            temp=temp->next;\\n        }\\n        temp->next=temp->next->next;\\n        return head;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* getmiddle(ListNode* head){\\n        ListNode* slow=head;\\n        ListNode* fast=head->next;\\n        while(fast!=NULL){\\n            fast=fast->next;\\n            if(fast!=NULL){\\n                fast=fast->next;\\n            }\\n            slow=slow->next;\\n        }\\n        return slow;\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if(head->next==NULL){\\n            return NULL;\\n        }\\n        ListNode* mid=getmiddle(head);\\n        if(mid->next==NULL){\\n            head->next=NULL;\\n        }else{\\n            mid->val=mid->next->val;\\n            mid->next=mid->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510026,
                "title": "typescript-javascript-with-comments-fast-slow-pointers",
                "content": "```\\nfunction deleteMiddle(head: ListNode | null): ListNode | null {\\n  if(!head.next) return null;\\n  let slow = head;\\n  \\n  // make fast start from 3rd node\\n  let fast = head.next.next;\\n  \\n  // now we loop until fast reaches end of list\\n  while(fast && fast.next){\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  \\n  // since we made fast start from 3rd node\\n  // when we exit the loop, the slow pointer\\n  // will be at node middle - 1 (not middle)\\n  // so we can easily delete middle node now\\n  slow.next = slow.next.next;\\n  return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction deleteMiddle(head: ListNode | null): ListNode | null {\\n  if(!head.next) return null;\\n  let slow = head;\\n  \\n  // make fast start from 3rd node\\n  let fast = head.next.next;\\n  \\n  // now we loop until fast reaches end of list\\n  while(fast && fast.next){\\n    slow = slow.next;\\n    fast = fast.next.next;\\n  }\\n  \\n  // since we made fast start from 3rd node\\n  // when we exit the loop, the slow pointer\\n  // will be at node middle - 1 (not middle)\\n  // so we can easily delete middle node now\\n  slow.next = slow.next.next;\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458594,
                "title": "python-easy-faster-than-90",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        slow = fast = head\\n        \\n        if not head or not head.next:\\n            return None\\n        \\n        if not head.next.next:\\n            head.next = None\\n            return head\\n        \\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        slow.val = slow.next.val\\n        slow.next = slow.next.next\\n        \\n        \\n        return head\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        slow = fast = head\\n        \\n        if not head or not head.next:\\n            return None\\n        \\n        if not head.next.next:\\n            head.next = None\\n            return head\\n        \\n        while(fast and fast.next):\\n            slow = slow.next\\n            fast = fast.next.next\\n            \\n        slow.val = slow.next.val\\n        slow.next = slow.next.next\\n        \\n        \\n        return head\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2338045,
                "title": "slow-fast-pointer-solution-in-javascript",
                "content": "```\\nconst deleteMiddle = (head) => {\\n    let slow = fast = head;\\n    let prevNode = null;\\n    while (fast && fast.next) {\\n        prevNode = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n\\n    if (!prevNode) return null;\\n    prevNode.next = slow.next;\\n    \\n    return head;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst deleteMiddle = (head) => {\\n    let slow = fast = head;\\n    let prevNode = null;\\n    while (fast && fast.next) {\\n        prevNode = slow;\\n        slow = slow.next;\\n        fast = fast.next.next;\\n    }\\n\\n    if (!prevNode) return null;\\n    prevNode.next = slow.next;\\n    \\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2299127,
                "title": "simple-easy-to-understand-solution",
                "content": "```python\\nclass Solution(object):\\n    def deleteMiddle(self, head):\\n        # Edge Case: the list contains only one node, then delete it\\n        if not head.next:\\n            return None\\n        \\n        slow = fast = head\\n        temp = None\\n        \\n        while fast and fast.next:\\n            temp = slow\\n            fast = fast.next.next\\n            slow = slow.next\\n        \\n        temp.next = slow.next\\n        slow.next = None\\n    \\n        return head\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```python\\nclass Solution(object):\\n    def deleteMiddle(self, head):\\n        # Edge Case: the list contains only one node, then delete it\\n        if not head.next:\\n            return None\\n        \\n        slow = fast = head\\n        temp = None\\n        \\n        while fast and fast.next:\\n            temp = slow\\n            fast = fast.next.next\\n            slow = slow.next\\n        \\n        temp.next = slow.next\\n        slow.next = None\\n    \\n        return head\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261585,
                "title": "remove-middle-of-linkedlist-solution-is-faster-than-99-97-solution-java",
                "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head.next == null){\\n            return head.next;\\n        }\\n        \\n        ListNode fast = head.next.next, slow = head;\\n        \\n        while(fast != null && fast.next != null){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        slow.next = slow.next.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        \\n        if(head.next == null){\\n            return head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2073229,
                "title": "java-solution",
                "content": "I have tried to apply **two pointers** approach and explained in comments about *my understanding*.\\n\\n\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 6 ms, faster than 32.38% of Java online submissions for Delete the Middle Node of a Linked List.\\n// Memory Usage: 231.8 MB, less than 18.63% of Java online submissions for Delete the Middle Node of a Linked List.\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        // if head is null or contains only one node...\\n        if(head==null || head.next==null) { // return null...\\n            return null;\\n        } else { // otherwise use algorithm...\\n            // made three pointers...\\n            // turtlePrev = turtle\\'s prevois pointer = (reffered as slow pointer\\'s previous)\\n            // turtle = refferred as slow pointer \\n            // rabbit = reffered as fast pointer\\n            ListNode turtlePrev=null,turtle=head,rabbit=head;\\n            \\n            // while rabbit is not reached to end (rabbit!=null)\\n            // neither close to the end (rabbit.next != null)\\n            while(rabbit!=null && rabbit.next!=null) {\\n                turtlePrev=turtle;\\n                turtle=turtle.next;\\n                rabbit=rabbit.next.next;\\n            }\\n            \\n            //make turtle loose\\n            turtlePrev.next=turtle.next;\\n            // return head...\\n            return head;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n// 6 ms, faster than 32.38% of Java online submissions for Delete the Middle Node of a Linked List.\\n// Memory Usage: 231.8 MB, less than 18.63% of Java online submissions for Delete the Middle Node of a Linked List.\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        // if head is null or contains only one node...\\n        if(head==null || head.next==null) { // return null...\\n            return null;\\n        } else { // otherwise use algorithm...\\n            // made three pointers...\\n            // turtlePrev = turtle\\'s prevois pointer = (reffered as slow pointer\\'s previous)\\n            // turtle = refferred as slow pointer \\n            // rabbit = reffered as fast pointer\\n            ListNode turtlePrev=null,turtle=head,rabbit=head;\\n            \\n            // while rabbit is not reached to end (rabbit!=null)\\n            // neither close to the end (rabbit.next != null)\\n            while(rabbit!=null && rabbit.next!=null) {\\n                turtlePrev=turtle;\\n                turtle=turtle.next;\\n                rabbit=rabbit.next.next;\\n            }\\n            \\n            //make turtle loose\\n            turtlePrev.next=turtle.next;\\n            // return head...\\n            return head;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056407,
                "title": "in-one-pass-solution-python",
                "content": "**Quick Explanation:**\\nHere, we use the two pointer approach to find the mid. As we know if second pointer moves twice faster then the first pointer then when second pointer reach the last then first pointer will point to the mid which is required then we can simply delete it. So, this is the approach.\\n\\n**Let\\'s do the coding.....**\\n\\n```\\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next==None:\\n            return None\\n        first=head\\n        sec=head.next\\n        while sec.next!=None and sec.next.next!=None:\\n            first=first.next\\n            sec=sec.next.next\\n        first.next=first.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head.next==None:\\n            return None\\n        first=head\\n        sec=head.next\\n        while sec.next!=None and sec.next.next!=None:\\n            first=first.next\\n            sec=sec.next.next\\n        first.next=first.next.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1905307,
                "title": "c-100-faster-with-logic-2-pointers-easy",
                "content": "**Idea =>\\nWe will find the middle element using 2 ptr method (Fast & slow Techq)\\nWe maintain a prev ptr to points on prev node of middle, so we can delete mid easily.\\n\\nListNode* deleteMiddle(ListNode* head) \\n    {\\n        if(!head || !head->next)   //base case\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        //2 Ptr Techq\\n        while(fast && fast->next)  //find mid point of LL\\n        {\\n            prev = slow;\\n            slow = slow->next;      //slow ptr points to mid\\n            fast = fast->next->next; \\n        }\\n        \\n        prev->next = slow->next;  //remove middle \\n        delete slow;\\n        \\n      return head;\\n    }\\n\\t\\n****\\tPlease upvote if you liked this solution or found it useful.****",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**Idea =>\\nWe will find the middle element using 2 ptr method (Fast & slow Techq)\\nWe maintain a prev ptr to points on prev node of middle, so we can delete mid easily.\\n\\nListNode* deleteMiddle(ListNode* head) \\n    {\\n        if(!head || !head->next)   //base case\\n            return NULL;\\n        \\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* prev = NULL;\\n        \\n        //2 Ptr Techq\\n        while(fast && fast->next)  //find mid point of LL\\n        {\\n            prev = slow;\\n            slow = slow->next;      //slow ptr points to mid\\n            fast = fast->next->next; \\n        }\\n        \\n        prev->next = slow->next;  //remove middle \\n        delete slow;\\n        \\n      return head;\\n    }\\n\\t\\n****\\tPlease upvote if you liked this solution or found it useful.****",
                "codeTag": "Unknown"
            },
            {
                "id": 1869495,
                "title": "python-one-pass-without-counting-length",
                "content": "Similar to [876. Middle of Linkedlist](https://leetcode.com/problems/middle-of-the-linked-list/) , use the turtoise and hare method to find the middle element to be removed. \\nHowever, since this is not a double-linkedlist, we need to keep track of the previous node `prev` before the middle node in order to remove it.\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        sentinel = ListNode(0, head)\\n        \\n        prev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # slow is the node to be deleted\\n        prev.next = prev.next.next\\n        return sentinel.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head.next:\\n            return None\\n        sentinel = ListNode(0, head)\\n        \\n        prev = None\\n        slow = fast = head\\n        while fast and fast.next:\\n            prev = slow\\n            slow = slow.next\\n            fast = fast.next.next\\n        \\n        # slow is the node to be deleted\\n        prev.next = prev.next.next\\n        return sentinel.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844965,
                "title": "recursive-approach-c",
                "content": "```\\n/*\\nI am practicing my recursive thinking \\nNot posting the best solution coz those posts are in abundance\\nhit a like if you think this is different\\n*/\\nclass Solution {\\npublic:\\n    int len;\\n    ListNode* deleteMiddle(ListNode* head,int count=0) {\\n        if(!head)\\n        {\\n            len=count-1;\\n            len = len/2+len%2;\\n            return NULL;\\n        }\\n        head->next = deleteMiddle(head->next,count+1);\\n        if(count==len)\\n            return head->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n/*\\nI am practicing my recursive thinking \\nNot posting the best solution coz those posts are in abundance\\nhit a like if you think this is different\\n*/\\nclass Solution {\\npublic:\\n    int len;\\n    ListNode* deleteMiddle(ListNode* head,int count=0) {\\n        if(!head)\\n        {\\n            len=count-1;\\n            len = len/2+len%2;\\n            return NULL;\\n        }\\n        head->next = deleteMiddle(head->next,count+1);\\n        if(count==len)\\n            return head->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804509,
                "title": "go-fast-and-slow-pointer-clean-code-220ms-100",
                "content": "Hello Gophers!\\n\\nPrevious question: [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/).  \\n[HERE](https://leetcode.com/problems/middle-of-the-linked-list/discuss/2480851/Go-Multiple-solutions-Clean-code-and-fast-(0ms-100)) is my solution!\\n\\nWe will use algorithm that is called the `Fast & Slow Pointers Algorithm`, the `Hair & Tortoise Algorithm` and the `Floyd\\'s Cycle Finding Algorithm`.\\nIt\\'s like the `Two Pointers Algorithm`, **but one of the pointers is going two times faster than the other one, so the \"slow pointer\" will be in the middle when the \"fast pointer\" is at the end**.\\nWe also need to keep in memory the \"previous slow\" pointer to change its next (the \"slow pointer\").\\n\\nLet\\'s say we have this linekd list:  \\n`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> nil`\\n\\nThe middle is `4` so we want `3 -> 4 -> 5` to become `3 -> 5`, hence the reason to save the \"previous pointer\" which is `3`.\\n\\nStart: `previou = nil`, `slow = 1`, `fast = 1`\\n1. `previou = 1`, `slow = 2`, `fast = 3`\\n2. `previou = 2`, `slow = 3`, `fast = 5`\\n2. `previou = 3`, `slow = 4`, `fast =7`\\n\\n`fast.Next == nil` -> `return slow //3`\\n\\n```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return nil\\n    }\\n\\n    var previous, slow, fast *ListNode = nil, head, head\\n\\t\\n\\t// Time: O(n/2) = O(n)\\n    for slow != nil && fast != nil && fast.Next != nil {\\n        previous, slow, fast = slow, slow.Next, fast.Next.Next\\n    }\\n    \\n    previous.Next = slow.Next\\n    \\n    return head\\n}\\n```\\n\\nHere are my solutions to other problems with this same algorithm pattern (Fast and Slow pointer):\\n\\n- [Happy Number](https://leetcode.com/problems/happy-number/discuss/1790169/go-multiple-solutions-clean-code-0ms-100)\\n- [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/discuss/1787725/go-multiple-solutions-clean-code-0ms-100)\\n- [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/discuss/1790316/go-multiple-solutions-clean-and-commented-code-0ms-100)\\n- [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/discuss/1801437/go-multiple-solutions-clean-code-with-comments)\\n- [Delete the Middle Node of a Linked List](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/1804509/Go-Fast-and-Slow-pointer-Clean-code-(220ms-100)) (this problem)\\n- [Reorder List](https://leetcode.com/problems/reorder-list/discuss/1804821/Go-Clean-and-commented-code-(4ms-100)) \\n\\nI hope it helped!\\n\\nEdit: shout out to [this great solution in Go with images](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/discuss/1654970/Golang-Solution-with-Explanation-and-Images).",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// Time: O(n)\\n// Space: O(1)\\nfunc deleteMiddle(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return nil\\n    }\\n\\n    var previous, slow, fast *ListNode = nil, head, head\\n\\t\\n\\t// Time: O(n/2) = O(n)\\n    for slow != nil && fast != nil && fast.Next != nil {\\n        previous, slow, fast = slow, slow.Next, fast.Next.Next\\n    }\\n    \\n    previous.Next = slow.Next\\n    \\n    return head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782134,
                "title": "delete-middle-node-of-linked-list",
                "content": "ListNode* deleteMiddle(ListNode* head) {\\n        ListNode *temp=head,*abc=head;\\n        if(head==NULL || head->next==NULL)\\n            return NULL;\\n        int count=0;\\n        while(temp->next!=NULL)\\n        {\\n            count++;\\n            temp=temp->next;\\n        }\\n        count=(count%2==0)?(count/2)-1:(count/2);\\n        while(count-- and abc->next)\\n        {\\n            abc=abc->next;\\n        }\\n        abc->next=abc->next->next;\\n        return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "ListNode* deleteMiddle(ListNode* head) {\\n        ListNode *temp=head,*abc=head;\\n        if(head==NULL || head->next==NULL)\\n            return NULL;\\n        int count=0;\\n        while(temp->next!=NULL)\\n        {\\n            count++;\\n            temp=temp->next;\\n        }\\n        count=(count%2==0)?(count/2)-1:(count/2);\\n        while(count-- and abc->next)\\n        {\\n            abc=abc->next;\\n        }\\n        abc->next=abc->next->next;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1764823,
                "title": "two-pointers-java-with-dummy-node",
                "content": "This question can be solved similar to middle of the linked list by using two pointers.\\nTo find the middle, we use two pointers slow and fast. By the time fast reaches null \\nslow will be at middle of linked list.\\nSo when we need to delete the middle element, it will be useful if we have the previous element of middle.\\nHere instead of tracking previous node,I had created slow node which will be be one node before the head.\\nSo by the time fast reaches null,slow pointer will be at one node before the middle element.Then we can delete middle\\nnode. It will be more easy to understand by seeing the code.\\n\\n```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {  \\n        if(head==null || head.next==null){\\n            return null;\\n        }\\n        ListNode slow=new ListNode(0);\\n        ListNode fast=head;\\n        slow.next=head;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next;\\n            if(fast.next!=null){\\n                fast=fast.next;\\n            }\\n            slow=slow.next;\\n        }\\n        if(slow.next!=null)\\n        {\\n            slow.next=slow.next.next;\\n        }\\n        return head;\\n        \\n        \\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {  \\n        if(head==null || head.next==null){\\n            return null;\\n        }\\n        ListNode slow=new ListNode(0);\\n        ListNode fast=head;\\n        slow.next=head;\\n        while(fast!=null && fast.next!=null){\\n            fast=fast.next;\\n            if(fast.next!=null){\\n                fast=fast.next;\\n            }\\n            slow=slow.next;\\n        }\\n        if(slow.next!=null)\\n        {\\n            slow.next=slow.next.next;\\n        }\\n        return head;\\n        \\n        \\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761774,
                "title": "delete-the-middle-node-of-a-linked-list",
                "content": "```class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            \\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null) return null;\\n        ListNode slow = head;\\n        ListNode fast = head;\\n        ListNode prev = head;\\n        while(fast!=null && fast.next!=null){\\n            prev = slow;\\n            slow=slow.next;\\n            fast=fast.next.next;\\n            \\n        }\\n        prev.next = slow.next;\\n        return head;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1752442,
                "title": "java-here-and-tortoise-algorithm",
                "content": "```\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null)return head;\\n        if(head.next==null)\\n        {\\n            return head.next;\\n        }\\n        ListNode fast=head;\\n        ListNode slow=head;\\n        ListNode prev=null;\\n        while(fast!=null && fast.next!=null)\\n        {\\n            fast=fast.next.next;\\n            prev=slow;\\n            slow=slow.next;\\n        }\\n        prev.next=slow.next;\\n        \\n        return head;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null)return head;\\n        if(head.next==null)\\n        {\\n            return head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1734905,
                "title": "java-easy-99-94-faster",
                "content": "`![image](https://assets.leetcode.com/users/images/426c951b-6cfe-4aa2-a568-7ad1f037fd5a_1643653769.8299742.png)\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null) return null;\\n        ListNode fast=head,slow=head,ans=head;\\n        while(fast.next.next!=null && fast.next.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head==null || head.next==null) return null;\\n        ListNode fast=head,slow=head,ans=head;\\n        while(fast.next.next!=null && fast.next.next.next!=null){\\n            fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1644323,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644977,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644222,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1708781,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644153,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 2070585,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1922236,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1902945,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1796714,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1787294,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644323,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644977,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644222,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1708781,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1644153,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 2070585,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1922236,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1902945,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1796714,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1787294,
                "content": [
                    {
                        "username": "Shivgup_2000",
                        "content": "The best and easiest solution to this problem is to use fast and slow pointer."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "johnofagbe",
                        "content": "Approach: \n1. Find the middle `slow`, and node before slow, `preSlow` by using `slow` and `fast` pointers. O(n) time .\n2. Reassign `preSlow.next` to `slow.next`\n\nTake note of the edge case of when there's only one node in the singly-linked list. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "akriart",
                        "content": "Using slow and fast pointers to reach the middle using the slow one maybe another prev pointer to keep track of the pointer before slow to enable easy deletion and its done!!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/solutions/2887856/easiest-faang-method-ever/"
                    },
                    {
                        "username": "shreyans",
                        "content": "Slow and fast pointers for the win!"
                    },
                    {
                        "username": "ajais_2518",
                        "content": "The easy solution to this is using fast and slow pointers."
                    },
                    {
                        "username": "yin78105",
                        "content": "why everyone knows slow/fast pointer? I could think of an array of int and iterate it. When I saw the problem requires struct based data type, I am like gotta search for more resources...\nBTW I am using go lang and a newbie"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "It is because they have solved the following question and in their editorial slow and fast approach is explained \\nhttps://leetcode.com/problems/middle-of-the-linked-list/editorial/ "
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "easy to understand\\n\\nclass Solution {\\npublic:\\n    ListNode* deleteMiddle(ListNode* head) {\\n        if (!head->next) return nullptr;\\n        int n=1;\\n        ListNode* copy=head;\\n        while(copy!=NULL){\\n            n++;\\n            copy=copy->next;\\n        }\\n\\n        int mid;\\n        if(n%2==0) mid=n/2-1; //if n is even\\n        else mid=n/2;  //n is odd\\n      \\n        ListNode* p=head;\\n        \\n        for(int i=0;i<mid-1;i++){\\n            p=p->next;\\n        }\\n\\n        p->next=p->next->next;  //p needs to point element after element (we need to skip/delete the element)\\n\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "mohit__agarwal",
                        "content": "# Intuition\\nWe can easily solve this problem by counting the total length of the linked list and then iterating it again upto half the length and deleting the node.\\nBut it takes O(n+n/2) time complexity. Can we improve it to O(n)?\\nWe can do that by the help of slow and fast pointers.\\n\\n# Approach\\nInitialise a fast and slow pointer and move the fast in twice the speed slow moves. Then delete the node next to the slow pointer.\\nSince we need to delete the node next to the slow pointer, initialise the slow pointer to 0 so that it reaches to the node just before the middle node of the linked list. "
                    },
                    {
                        "username": "goyalishika132",
                        "content": "=34==ERROR: AddressSanitizer: alloc-dealloc-mismatch (operator new vs free) on 0x6020000000b0\\n    #3 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x6020000000b0 is located 0 bytes inside of 16-byte region [0x6020000000b0,0x6020000000c0)\\nallocated by thread T0 here:\\n    #4 0x7f82cb4180b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n==34==HINT: if you don\\'t care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n==34==ABORTING\\n\\n\\n\\nye kya error h bhyy???"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Paste your code here"
                    }
                ]
            },
            {
                "id": 1763833,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1755516,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1710884,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1706508,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1706305,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1659984,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1648537,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1645005,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1644645,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            },
            {
                "id": 1644387,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "hitler_fitler",
                        "content": "Approach:\\n1. Check the head and head.next  is None. If it, return None\\n2. Find the middle node using Fast Slow pointers(middle node is Slow point)\\n3. outside the while reassign slow.next to slow.next.next(it deletes the middle node)\\n4. finally return the head\\n\\n  `if head == None or head.next == None:\\n            return None\\nslow = head\\nfast = head.next.next\\nwhile fast != None and fast.next != None:\\n            fast = fast.next.next\\n            slow = slow.next\\nslow.next = slow.next.next\\nreturn head`"
                    },
                    {
                        "username": "Amit_kumar_07",
                        "content": "\n    public ListNode findMid(ListNode fastNode, ListNode slowNode){\n        while(fastNode!=null && fastNode.next!=null){\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n\n        return slowNode;\n    }\n\n    public ListNode deleteMiddle(ListNode head) {\n\n        if(head==null || head.next == null) return null;\n\n        ListNode slowNode = findMid(head,head);\n        if(slowNode.next==null){ \n            slowNode = null; // -> why this line isn't working ( case = [2,1] if slowNode is pointing to 1 it should be written null but it's not happening )\n        }\n        else{\n            slowNode.val = slowNode.next.val;\n            slowNode.next = slowNode.next.next;\n        }\n        return head;\n    }\n\n\nIf someone know the answer plz let me know...  I've commented my question"
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": "for case [2,1]\\n\\nto delete node 1 we need to assign  node[2].next=null;\\nby making  node[1]=null    will not change  node 2\\'s.next\\n\\nthis will happen only if list contain 2 nodes\\nso in if case just try\\n    head.next=null           //  2\\'s.next=null\\n\\n//***********************************************************************************************\\n\\nfor more understanding just print this in if case :\\n\\nSystem.out.println(\"slownode before : \"+slowNode);\\nslowNode = null; \\nSystem.out.println(\"slownode after : \"+slowNode);\\nSystem.out.println(\"2\\'s next : \"+head.next);\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "[leetcode](https://leetcode.com)https://github.com/lets-do-code/Delete-the-Middle-Node-of-a-Linked-List-leetcode"
                    },
                    {
                        "username": "manoharmj2338",
                        "content": "This is simple java solution \\n\\n `your inline code...your inline code...`\\n        \\n        if(head==null || head.next==null) return null;\\n        ListNode slow=head;\\n        ListNode fast=head.next.next;\\n        while(fast!=null && fast.next!=null){\\n        fast=fast.next.next;\\n            slow=slow.next;\\n        }\\n        slow.next=slow.next.next;\\n        return head;"
                    },
                    {
                        "username": "ashishbaranwal",
                        "content": "class Solution {\\n    public ListNode deleteMiddle(ListNode head) {\\n        if(head == null || head.next == null)\\n            return null;\\n\\n        ListNode fast = head;\\n        ListNode slow = head;\\n        ListNode slow_prev = head;\\n\\n        while(fast != null && fast.next != null)\\n        {\\n            slow_prev = slow;\\n            slow = slow.next;\\n            fast = fast.next.next;\\n        }\\n \\n        slow_prev = slow.next;\\n              \\n        return head;\\n    }\\n}\\n\\n\\nI am assigning slow_prev = slow.next, but it\\'s not working.\\nIt\\'s not deleting the middle node.\\n\\nCan anyone please help me regarding this one."
                    },
                    {
                        "username": "Sumit_Tupe",
                        "content": " slow_prev.next = slow.next;"
                    },
                    {
                        "username": "chfusd111",
                        "content": "The constraint forgot to clarify that we cannot get or change val of ListNode."
                    },
                    {
                        "username": "AMAN_SAINI_",
                        "content": "class Solution {\\npublic:\\n    int count(ListNode* head){\\n        int ans = 0;\\n        while(head){\\n            head = head->next;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    void moveHead(ListNode *head, int move){\\n        for(int i=0; i<move; i++){\\n            head = head->next;\\n        }\\n        head->next = head->next->next; // error line.\\n    }\\n    ListNode* deleteMiddle(ListNode* head) {\\n        int n = count(head);\\n        int move = n/2;\\n        moveHead(head, move);\\n        return head;\\n    }\\n};\\n\\nwhy am i getting the error in this code can someone tell me ??\\n"
                    },
                    {
                        "username": "ijxx",
                        "content": "Before starting slow and fast pointer traversal, if we add one node at the head of slow pointer, then no need to maintain previous node. Some solutions are using the strategy of \"delete a node with a pointer given to that node\" problem. This will not  work in case of exact middle node  to be removed not just its value. "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "I have seen many solution that maintain a previousNode variable so that they can later point it to its next to next element, thus deleting the next element. But you don't need to have access to the previous location if you want to delete the current node. Say your current node is named node, and you want to delete it, you can change what is stored at that address and it will work fine.\n```cpp\n     *node = *node->next; //replacing the node present at address of node with node->next 's address\n```\nDo let me know if I am wrong somewhere or if there are some downside of this method of deletion, hope it helps "
                    }
                ]
            }
        ]
    }
]