[
    {
        "title": "Score of Parentheses",
        "question_content": "Given a balanced parentheses string s, return the score of the string.\nThe score of a balanced parentheses string is based on the following rule:\n\n\t\"()\" has score 1.\n\tAB has score A + B, where A and B are balanced parentheses strings.\n\t(A) has score 2 * A, where A is a balanced parentheses string.\n\n&nbsp;\nExample 1:\n\nInput: s = \"()\"\nOutput: 1\n\nExample 2:\n\nInput: s = \"(())\"\nOutput: 2\n\nExample 3:\n\nInput: s = \"()()\"\nOutput: 2\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 50\n\ts consists of only '(' and ')'.\n\ts is a balanced parentheses string.",
        "solutions": [
            {
                "id": 1856519,
                "title": "java-c-visually-explained",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Score of Parentheses**\\n\\nIn order to solve this problem we are assigned with few rules :-\\n```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\\n\\nLet\\'s understand our rule\\'s first of all :-\\n* If our input string is **\"()\"** then our score will be **`1`**, so this is our first rule\\n\\n\\n* If we have input string **\"()()\"** then our score will be **1 + 1** i.e. **`2`**, where `1` is a score of a balanced parentheses. So, this is our second rule\\n* Now last rule say\\'s, if we have given something like **\"(())\"** in our input string, our score will be **2 X 1** i.e. **`2`**, it means that we have something like `nested parenthesis`. Then multiply it by 2.\\n\\nLet\\'s take one example, inorder to solve this problem :-\\n\\n**Input :** \"( ( ) ( ( ) ) )\"\\n**Output :** 6\\n\\n![image](https://assets.leetcode.com/users/images/d4cd1104-d9d1-48b7-ada3-f3f4b98568da_1647481533.8082087.png)\\n\\nOkay, so first thing came in our mind is can we solve this problem using stack, and I say yes we\\'ll solve this problem using stack.\\n\\n* First create one stack of **Integer** not ~~**Character**~~\\n* So, as we are using Integer, what we gonna put in stack is intially **0** when we encounter `(`\\n* And we\\'ll calculate the score when we encounter `)`\\n\\n```\\nLet\\'s Understand it visually :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b80fe1d1-6ffc-4d49-b52e-a9749b50bdaf_1647483490.0576897.gif)\\n\\n*I hope you got the idea* **Let\\'s Code it up :-**\\n\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\"()\" has score 1.\\nAB has score A + B, where A and B are balanced parentheses strings.\\n(A) has score 2 * A, where A is a balanced parentheses string.\\n```\n```\\nLet\\'s Understand it visually :-\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int score = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.pop() + Math.max(2 * score, 1);\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int score = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(score);\\n                score = 0;\\n            }\\n            else {\\n                score = st.top() + max(2 * score, 1);\\n                st.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856699,
                "title": "c-beats-100-omg-o-1-space-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nLet\\'s take a look how do we calculate the score on following examples: \\n\\n`()()` => `1+1`\\n`(()())` => `2*(1+1)`\\n`((()()))` => `2*2*(1+1)`\\n`((()(())))` => `2*2*(1+2*1)`\\n\\nWe can see that any `()` in the string gives a score depending on its depth. If `()` is located on the higher possible level (depth=0), the score is simply a 1. If it\\'s located deeper, we just multiply it by 2 as many times as its depth. The found score we can just add to the final result. Why can we do that? Remember that, for example, this expression `2*2*(1+1)` can be expressed as `2*2+2*2`. No matter how deep parenthesis, the final expression of score can be represented as a sum of `()` scores.\\n\\nTime: **O(N)** - traversing\\nSpace: **O(1)** - OMAGAD!!! (\\xB4\\u25BD`\\u0283\\u01AA)\\n\\nRuntime: 0 ms, faster than **100.00%** of C++ online submissions for Score of Parentheses.\\nMemory Usage: 6.1 MB, less than **83.25%** of C++ online submissions for Score of Parentheses.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856520,
                "title": "java-easy-to-understand-intuition-and-solution-o-n-o-1",
                "content": "****\\nPlease upvote if the solution helps, as it keeps up the motivation to provide such posts.\\n\\n****\\n\\u2318 **Explanation Flow :**\\n* Observations.\\n* Code Flow : Rules and Dry Run\\n* Implementations\\n\\t* Using Stack of Character\\n\\t* Using Stack of Integer\\n\\t* Constant Space Solution\\n\\t* Complexity Analysis\\n\\n\\u2318 **Observations :**\\n\\nAs the given string is balanced, thus it makes our task easy. \\nWe solve the self-dependant `()` and store the result in stack and follow the simulation acc. to the given rules.\\n\\nRight off the bat, first intuition is always using a `stack` here, but we can definately reduce the `SC` to `O(1)` as input constraints to use just two chars `( and )`.\\n\\n# Code Flow : \\n**Rules**:\\n1. \"()\" has score 1.\\n2. AB has score A + B, where A and B are balanced parentheses strings.\\n3. (A) has score 2 * A, where A is a balanced parentheses string.\\n\\n\\n`str =  ( () ( () ) )`\\n\\n* if `ch == (`:\\n\\t* push `ch` in stack\\n* if `ch == )`:\\n\\t* Check the top of stack. It can either of two :\\n\\t\\t* `stack.top() == (` : \\n\\t\\t\\t* i.e. we got a pair `()`. Thus, we push `1`  as per the `1st rule`\\n\\t\\t* `stack.top() == \\'NUMBER\\'`\\n\\t\\t\\t* `Using rule 2 & rule 3` : We add all the numbers till we find the starting `(` of this. ( let `A`)\\n\\t\\t\\t* `Push 2*A back in the stack`\\n* Check if stack is empty. If not, use `rule #2` \\n\\n\\n# \\u2318Code Dry Run States :\\n\\n* `( () ( () ) )`\\n* `( 1 ( () ) )`\\n* `( 1 ( 1 ) )`\\n* `( 1 2 )`\\n* `( 3 )`\\n* `6`\\n\\n****\\n\\n\\uD83D\\uDCCE **First Implementation :** \\n\\nUsing stack of `Character`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n****\\n\\n\\uD83D\\uDCCE **Second Implementation :** \\n\\nUsing `stack of int`\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(n)\\n`\\n****\\n\\n\\uD83D\\uDCCE **Constant Space :** \\n\\nAs the string is balanced, a `(` bracket could be used to mark the start of a new depth (`i.e. 2 times the depth`) & a `)` bracket would indicate us the end of a valid sub-portion of paranthesis. Hence, \\n\\n* We need to update the depth of a paranthesis.\\n\\t* If `(` - our depth increases\\n\\t* If `)` - our depth decreases \\n\\t\\t* If at any point, we see a valid balanced pair `()`, then we need to update the output acc to `Rule #3`\\n\\nFor eg: \\n\\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\\n\\n# Code Implementation : \\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```\\n\\n\\u2318 **Complexity Analysis** : \\n\\n`TC : O(n)\\nSC: O(1)\\n`",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\') {\\n                stack.push(ch);\\n            } else {\\n                // if top of stack is \\'(\\'\\n                if(!stack.isEmpty() && stack.peek() == \\'(\\') {\\n                    stack.pop();\\n                    stack.push(\\'1\\');\\n                } else {\\n                    // if top of stack is a \\'(char) number\\'\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=\\'(\\') {\\n                        sum += stack.pop()-\\'0\\';\\n                    }\\n                    // pop \\'(\\'\\n                    stack.pop();\\n                    stack.push((char)(2*sum+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += (stack.pop()-\\'0\\');\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Deque<Integer> stack = new ArrayDeque<>();\\n        for(char ch : s.toCharArray()) {\\n            if(ch == \\'(\\')\\n                stack.push(-1);\\n            else {\\n                if(!stack.isEmpty() && stack.peek() == -1)\\n                {\\n                    stack.pop(); // remove \\'(\\'\\n                    stack.push(1);\\n                }\\n                else {\\n                    // top of the stack is number\\n                    int sum = 0;\\n                    while(!stack.isEmpty() && stack.peek()!=-1) {\\n                        sum += stack.pop();\\n                    }\\n                    \\n                    stack.pop();\\n                    stack.push(2*sum);\\n                }\\n            }\\n        }\\n        \\n        int sum = 0;\\n        while(!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nstr =    (   (   (   (   )  (   )  (   )   )  )  )\\ndepth =  1   2   3   4   3  4   3  4   3   2  1  0\\nR =                      8      8      8\\n\\nFinal result = 8 + 8 + 8 = 24\\n\\nWhy are we decrementing when we find a `)` ? It is because the intermediate `()` lies at d-1 depth. \\neg: (   (   (  **(   )** - this valid pair lies at depth 3.\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int n = s.length(), d = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++) {\\n            char ch = s.charAt(i);\\n            // if `(` increase the depth\\n            if(ch == \\'(\\')\\n                d++;\\n            else {\\n            // if `)` decrease the depth\\n                --d;\\n                // check if a balanced pair is getting formed, if yes update the result\\n                if(s.charAt(i-1) == \\'(\\')\\n                    R += Math.pow(2, d);\\n            }\\n        }\\n        return R;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141777,
                "title": "c-java-python-o-1-space",
                "content": "# **Approach 0: Stack**\\n\\n`cur` record the score at the current layer level.\\n\\nIf we meet `\\'(\\'`,\\nwe push the current score to `stack`,\\nenter the next inner layer level,\\nand reset `cur = 0`.\\n\\nIf we meet `\\')\\'`,\\nthe `cur` score will be doubled and will be at least 1.\\nWe exit the current layer level,\\nand set `cur += stack.pop() + cur`\\n\\n**Complexity:** `O(N)` time and `O(N)` space\\n\\n**Java**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\\n<br>\\n\\n# **Approach 1: Array**\\n\\nSame as stack, I do it with an array.\\nWe change a pointer instead of pushing/popping repeatedly.\\n\\nComplexity: `O(N)` time and `O(N)` space\\n\\n\\n**Java:**\\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\\n<br>\\n\\n# **Follow-Up**\\nCan you solve it in `O(1)` space?\\n<br>\\n\\n# **Approach 2: O(1) Space**\\n\\nWe count the number of layers.\\nIf we meet `\\'(\\'` layers number `l++`\\nelse we meet `\\')\\'` layers number `l--`\\n\\nIf we meet `\"()\"`, we know the number of layer outside,\\nso we can calculate the score `res += 1 << l`.\\n\\n**C++:**\\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n[1130. Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n[901. Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n[856. Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n[503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n496. Next Greater Element I\\n84. Largest Rectangle in Histogram\\n42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```java\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int cur = 0;\\n        for (char i : S)\\n            if (i == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            }\\n            else {\\n                cur += stack.top() + max(cur, 1);\\n                stack.pop();\\n            }\\n        return cur;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        stack, cur = [], 0\\n        for i in S:\\n            if i == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur += stack.pop() + max(cur, 1)\\n        return cur\\n```\n```java\\n    public int scoreOfParentheses(String S) {\\n        int res[] = new int[30], i = 0;\\n        for (char c : S.toCharArray())\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += Math.max(res[i--] * 2, 1);\\n        return res[0];\\n    }\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res[30] = {0}, i = 0;\\n        for (char c : S)\\n            if (c == \\'(\\') res[++i] = 0;\\n            else res[i - 1] += max(res[i] * 2, 1), i--;\\n        return res[0];\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res, i = [0] * 30, 0\\n        for c in S:\\n            i += 1 if c == \\'(\\' else -1\\n            res[i] = res[i] + max(res[i + 1] * 2, 1) if c == \\')\\' else 0\\n        return res[0]\\n```\n```cpp\\n    int scoreOfParentheses(string S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S[i] == \\'(\\') l++; else l--;\\n            if (S[i] == \\')\\' && S[i - 1] == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```jave\\n    public int scoreOfParentheses(String S) {\\n        int res = 0, l = 0;\\n        for (int i = 0; i < S.length(); ++i) {\\n            if (S.charAt(i) == \\'(\\') l++; else l--;\\n            if (S.charAt(i) == \\')\\' && S.charAt(i - 1) == \\'(\\') res += 1 << l;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def scoreOfParentheses(self, S):\\n        res = l = 0\\n        for a, b in itertools.izip(S, S[1:]):\\n            if a + b == \\'()\\': res += 2 ** l\\n            l += 1 if a == \\'(\\' else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141975,
                "title": "c-solution-using-stack-5ms-detail-explained",
                "content": "When travel through S, only meets \\')\\', we need to calculate the score of this pair of parenthese. If we know the score of inner parentheses, such as 3, we can double it and pass to the outer parenthese.  But the question is how do we know the score of inner parentheses? Using stack.\\n\\nexplain with \"( ( ) ( ( ) ) )\"\\n\\nstack: 0-> \\nstring_traveled :\"\"\\nWhen start only 0 in stack, this int will store the total score\\n\\nstack: 0->0->0->\\nstring_traveled:\"( (\"\\nMeet two \\'(\\', push two zeros to the stack\\n\\nstack: 0->1->\\nstring_traveled: \"( ( )\"\\nFirst time meets \\')\\', it balance the last \\'(\\', so pop the stack. But 0 indicates no inner parentheses exists, so just pass 1 to parent parenthese.\\n\\nstack: 0->1->0->0->\\nstring_traveled: \"( ( ) ( (\"\\nKeep pushing zeros\\n\\nstack 0->1->1->\\nstring_traveled: \"( ( ) ( ( )\"\\nBalance one \\'(\\', and still no inner parenthese, so pass 1 to parent\\n\\nstack 0->3->\\nstring_traveled: \"( ( ) ( ( ) )\"\\nBalance another \\'(\\', but the inner is not zero, so double it and add to parent\\'s score\\n\\nstack 6->\\nstring_traveled: \"( ( ) ( ( ) ) )\"\\nSame as last step, double the inner score and add to parent\\'s\\n\\n```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S)\\n{\\n    stack<int> m_stack;\\n    m_stack.push(0); // to keep the total score\\n    for(char c:S){\\n        if(c==\\'(\\')\\n            m_stack.push(0); //When meets \\'(\\', just push a zero to stack\\n        else{\\n            int tmp=m_stack.top(); //  balance the last \\'(\\', it stored the score of inner parentheses\\n            m_stack.pop();\\n            int val=0;\\n            if(tmp>0) // not zero means inner parentheses exists and double it\\n                val=tmp*2;\\n            else // zero means no inner parentheses, just using 1\\n                val=1;\\n            m_stack.top()+=val; // pass the score of this level to parent parenthese\\n        }   \\n    }\\n    return m_stack.top();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141778,
                "title": "1-line-python",
                "content": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S):\\n        return eval(S.replace(\\')(\\', \\')+(\\').replace(\\'()\\', \\'1\\').replace(\\')\\', \\')*2\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 141763,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(-1);\\n            } else {\\n                int cur = 0;\\n                while (stack.peek() != -1) {\\n                    cur += stack.pop();\\n                }\\n                stack.pop();\\n                stack.push(cur == 0 ? 1 : cur * 2);\\n            }\\n        }\\n        int sum = 0;\\n        while (!stack.isEmpty()) {\\n            sum += stack.pop();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856417,
                "title": "c-explained-with-algorithm-0ms-100-easy-simple",
                "content": "# 856. Score of Parentheses\\n**KNOCKCAT**\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n``` ```\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**ALGORITHM**\\n1. **\"()\"** has a **score of 1.**\\n2. **\"xy**\" has a **score of x + y** ,  here x & y are balanced pairs of balanced parenthese.\\n3. **\"(x) \"** has a **score of x , (i.e) 2 * score of x.**\\n\\tExample.\\n\\t**Input: str = \\u201C()()\\u201D\\n\\tOutput: 2**\\n\\t\\tExplanation: There are are two individual pairs of balanced parenthesis \\u201C() ()\\u201D. Therefore, **score = score of \\u201C()\\u201D + score of \\u201C()\\u201D = 1 + 1 = 2**\\n\\n\\tInput: str = \\u201C(())\\u201D\\n\\tOutput: 2\\n\\t\\tExplanation: Since the input is of the form \\u201C(x)\\u201D, **the total score = 2 * score of \\u201C()\\u201D = 2 * 1 = 2**\\n\\t\\t\\n* **Take a Stack**, **Iterate  over the characters of string.**\\n* For every i**th character check if the character is \\u2018(\\u2018 or not.** If found to be true, then **insert the character score into the stack.**\\n* Initialize a **stack to store the current traversed character score** of inner balanced parenthesis.\\n* For every i check for the conditions.\\n\\t* **if the current character is \\'(\\' push the current score into stack** , enter the next inner layer and **reset score to 0.**\\n\\t* if the **current character is \\')\\'** then **ind score will be doubled and will be at  least one .**\\n\\t* we **exit the current level**  and **set ind = stack.top() + max(ind * 2, 1).**\\n\\t* and pop the  score from the stack.\\n\\t\\nANALYSIS :-\\n* \\t**Time Complexity : O(N)**\\n\\n* \\t**Space Complexity : O(N)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/096896ec-5acf-4e04-b049-6f70de10349d_1647479213.4339418.png)\\n\\n**CODE WITH EXPLANATION**\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Stack Approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        int ind = 0;\\n        \\n        for(auto i : s)\\n        {\\n\\t\\t\\t// if we find open parenthesis\\n\\t\\t\\t// push the current score into the stack\\n            if(i == \\'(\\')\\n            {\\n                st.push(ind);\\n\\t\\t\\t\\t// reset the score to 0\\n                ind = 0;\\n            }\\n            else // if we find close parenthesis\\n            {\\n                ind = st.top() + max(ind*2 ,1);\\n                st.pop();\\n            }\\n                \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080518,
                "title": "python-o-1-space-solution-explained",
                "content": "When you see parentheses in problem forlumation you should think about stack and indeed, there is stack solution for this problem. This solution will be optimal in time, but in place we can do better! Let us look at the following string:\\n`(((()))(()(())))` and try tu understand what will be the score of such string.\\nFirst of all it can be written as 2 * `((()))(()(()))`, which can be written as `2*((())) + 2*(()(())) = 2*2*(()) + 2*2*() + 2*2*(()) = 2*2*2 + 2*2 + 2*2*2 = 20` and it helps us to notice that what acutally matters is how many `()` we meet in our string, and how deep they are located. So, let us traverse through our string, keep `bal`: balance, or depth of current place, that is how many brackets we need to close to get correct expression, and also if we see `()`, we update `ans += 1<< bal`.\\n\\n**Complexity**: time complexity is `O(n)`: we need to traverse our string once, space complexity is just `O(1)`.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        ans, bal = 0, 0\\n        for i, s in enumerate(S):\\n            bal = bal + 1 if s == \"(\" else bal - 1\\n            if i > 0 and S[i-1:i+1] == \"()\":\\n                ans += 1 << bal\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141779,
                "title": "java-8ms-11-lines-recursion-with-explanation",
                "content": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1529810228.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i=0;\\n    public int scoreOfParentheses(String S) {\\n        int res=0;\\n        while(i<S.length()){\\n            char c=S.charAt(i++);\\n            if (c==\\'(\\'){\\n                if (S.charAt(i)==\\')\\'){\\n                    res+=1;\\n                    i++;\\n                } else res+=2*scoreOfParentheses(S);\\n            }else return res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141828,
                "title": "python-javascript-simple-and-readable-stack-solution",
                "content": "When we see \"(\" character, we are entering new valid paranthesis cluster, so we append initalized value 0 to stack.\\nWhen we see \")\" character, we should process currently open valid paranthesis cluster(Stack.pop()). If valid paranthesis cluster is still valued 0, it is a valid empty paranthesis cluster, so value is 1. Otherwise multiply inside value by 2. Add processed value to outer valid paranthesis cluster(Stack[-1]) \\n* Python\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\\n* Javascript\\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for c in S:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                last = stack.pop()\\n                stack[-1] += 2 * last or 1\\n        return stack.pop()\\n```\n```\\nvar scoreOfParentheses = function(S) {\\n    let stack = [0];\\n    for (i in S) {\\n        if (S[i] == \"(\") {\\n            stack.push(0);\\n        }\\n        else {\\n            last = stack.pop();\\n            stack[stack.length - 1] += 2 * last || 1\\n        }\\n    }\\n    return stack.pop();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204576,
                "title": "simple-python-stack-solution-o-n-time-beats-100-easy-to-understand",
                "content": "Please give me some upvotes if you like it.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        stack = [0]\\n        for par in S:\\n            if par == \"(\": stack.append(0)\\n            else:\\n                last = stack.pop()\\n                if last == 0: score = 1\\n                else: score = last * 2\\n                stack[-1] += score\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080625,
                "title": "js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568087,
                "title": "c-easy-to-understand-well-commented-solution-stack-solution-100-time-100-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int n=S.size();\\n        stack<int> s;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'(\\'){ //Whenever we get opening brackets, we will push it in the stack, it tells we have to do some calculation\\n                // \\'(\\' will be represented by -1, as any computaitional value can become ascii value of \\'(\\' i.e. 40\\n                s.push(-1);\\n            }\\n            else{   //S[i]==\\')\\'  ,now we have to do calculation\\n                //We have to see top of the stack\\n                if(s.top()==-1){ //Case 1- ()=1\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else{ //We have some number \\n                    int res=s.top();\\n                    s.pop();\\n                    if(s.top()==-1){ //Case 2- (A)=2*A\\n                        s.pop();\\n                        s.push(2*res);\\n                    }\\n                    else{  //Case 3- ABC..=A+B+C+..\\n                        //I will keep adding elements until I get to opening loop\\n                        while(!s.empty()&&s.top()!=-1){\\n                            res+=s.top();\\n                            s.pop();\\n                        }\\n                        if(!s.empty()&&s.top()==-1){\\n                            s.pop();\\n                            res=res*2;\\n                        }\\n                        s.push(res);//I will add calculated value in stack after popping out all brackets within which value is calculated\\n                    }\\n                }\\n            }\\n        }\\n        //I have eliminated all brackets \\n        //I only have numbers remaining in my stack like 1,2,3...\\n        //So I have to do AB= A+B\\n        int ans=0;\\n        while(!s.empty()){\\n            ans+=s.top();\\n            s.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856451,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time complexity : O(n)**\\n\\n```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        int cur = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'(\\'){\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(1, cur*2);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\n```javascript []\\nvar scoreOfParentheses = function(s) {\\n    let stack = []\\n    let cur = 0;\\n    for(let c of s) {\\n        if(c == \\'(\\') {\\n            stack.push(cur);\\n            cur = 0;\\n        } else {\\n            cur = stack.pop() + Math.max(1, cur*2);\\n        }\\n    }\\n    return cur;\\n};\\n```\n```python []\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        cur = 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(cur)\\n                cur = 0\\n            else:\\n                cur = stack.pop() + max(1, cur*2)\\n        return cur \\n```",
                "codeTag": "Java"
            },
            {
                "id": 332150,
                "title": "python3-recursion-solution-beats-100",
                "content": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef scoreOfParentheses(self, S: str) -> int:\\n\\t\\t\\treturn self.helper(S,0,len(S)-1)        \\n\\t\\tdef helper(self,S,l,r):\\n\\t\\t\\tif r-l==1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(l,r):\\n\\t\\t\\t\\tif S[i]==\\'(\\':\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\tif S[i]==\\')\\':\\n\\t\\t\\t\\t\\tcount-=1\\n\\t\\t\\t\\tif count==0:\\n\\t\\t\\t\\t\\treturn self.helper(S,l,i)+self.helper(S,i+1,r)\\n\\t\\t\\treturn 2*self.helper(S,l+1,r-1)",
                "codeTag": "Java"
            },
            {
                "id": 1857157,
                "title": "detail-explanation-using-stack",
                "content": "\\n\\n```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## If(solution == helpfull ) upvote \\uD83E\\uDD17 . . .",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\nfirst ->we are gonna create a stack of int . . .\\nmain motive is whenever we find \\'(\\' just push -1  into the stack  . . .\\n\\nafter that we have to do this operations --->\\n\\t\\t1) when stack\\'s top == -1 and we find a \\')\\' then it\\'s mean we found () and its value is 1 . so pop the\\n\\t\\t    front element and push 1 . . .\\n\\t\\t2) in 2nd scenario we find a \\')\\' but the stack\\'s top == 1 it\\'s mean the 3rd rule applied here and we have to\\n\\t\\t    calculate all the () parentheses value and after that push the calculated value in the stack . . .\\n\\t\\t3) now if the provided string is \\'()()()\\' then you have to calculate all the value present in the stack . . .\\n\\t\\t4) calculate the stack and return the ans . . .\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int i = 0 ;\\n        while(s[i] != \\'\\\\0\\'){\\n\\t\\t\\n\\t\\t\\t// when we find a open parentheses . . .\\n            if(s[i] == \\'(\\') st.push(-1);\\n\\t\\t\\t\\n\\t\\t\\t// when we find a close parentheses . . .\\n            else{\\n\\t\\t\\t\\t// when we find a () . . .\\n                if(st.top() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n\\t\\t\\t\\t//apply the 3rd rule\\n                else{\\n                    int ans = 0;\\n                    while(st.top() != -1){\\n                        ans += st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*ans);\\n                }\\n            }\\n            i++;\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288667,
                "title": "easy-c-solution-using-stack-passess-100-submission",
                "content": "Time Complexity: O(n)\\nSpace Complexiy: O(n)  // using stack\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> a;  // lets assume 0 as (\\n        for(char c : s){\\n            if(c==\\'(\\'){\\n                a.push(0);\\n            } else if(c==\\')\\'){\\n                if(a.top() ==0){   // detect () and replace that with 1\\n                    a.pop();\\n                    a.push(1);\\n                }else {\\n                    int x=0;\\n                    while(a.top() != 0){   // detects complex nested (()) types cases and replaces the block with sum *2 \\n                        x+=a.top();\\n                        a.pop();\\n                    }\\n                    a.pop();\\n                    a.push(2*x);\\n                }\\n            }\\n        }\\n        int x=0;\\n        while(a.size()>0){   // sum the stack value and store in x\\n            x+=a.top();\\n            a.pop();\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856782,
                "title": "c-efficient-stack-tc-o-n-sc-o-n-with-explanation-clean-solution",
                "content": "##### *Please, Upvote , if you find its helpful :)*\\n##### Let\\'s understand our rule\\'s first of all :-\\n```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\\n#### Code:-\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```\\n*Time Complexity :- O(N)\\nSpace Complexity :- O(N)*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nIf our input string is \"()\" then our score will be 1, so this is our first rule\\nIf we have input string \"()()\" then our score will be 1 + 1 i.e. 2, where 1 is a score of a balanced parentheses. So, this is our second rule\\nNow last rule say\\'s, if we have given something like \"(())\" in our input string, our score will be 2 X 1 i.e. 2, it means that we have something like nested parenthesis. \\nThen multiply it by 2.\\n\\nLet\\'s take a look how do we calculate the score on following examples:\\n()() => 1+1\\n(()()) => 2*(1+1)\\n((()())) => 2*2*(1+1)\\n((()(()))) => 2*2*(1+2*1)\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        int score=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){//if we find open parenthesis, push the current score into the stack\\n                st.push(score);\\n                score=0;//reset the score to 0\\n            }\\n            else if(s[i]==\\')\\'){//if we find close parenthesis\\n                score=st.top()+ max(2* score , 1);\\n                st.pop();\\n            }\\n        }\\n        return score;//return score\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281710,
                "title": "c-code-easy-to-understand-stack-use",
                "content": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "solutionTags": [],
                "code": "int scoreOfParentheses(string s) {\\n        stack<int>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else {\\n                    int val=0;\\n                    while(st.top()!=-1){\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(st.size()>0){\\n            val+=st.top();\\n            st.pop();\\n        }\\n        return val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1858780,
                "title": "multiple-c-solutions-with-explanations-using-stack",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using a stack to store the values, to store parentheses we\\u2019re using -1, else the value for the parentheses.\\n- There can be 3 cases:\\n    - `if(x == \\'(\\')` we\\u2019ll **push *-1*** in this case to our stack, as it\\u2019s a open parentheses.\\n    - `else if(x == \\')\\' && st.top() == -1)` in this case we are getting open and close parentheses side by side, which derives the value 1, so we pop the top element and **push *1*** to the stack.\\n    - `else if(x == \\')\\' && st.top() != -1)` in this case we\\u2019ve some value in the stack, before a open parentheses. Here we\\u2019ll use a while loop to pop the elements till we found a open parentheses(-1) & add the values to count. After breaking this loop we have a open parentheses at top, we pop that & **push *count*2***\\n- Now add the stack integers to ans and return it.\\n- **Time complexity:** O(n^2).\\n\\n### Solution 02\\n\\n- This is the optimal solution of the previous one.\\n- Here we\\u2019re pushing the count only if it is an open parentheses.\\n- If it\\u2019s a closing parentheses then we\\u2019ll update the count with `max(1, 2*count)` & add the top element from stack, then pop it. Next time when there is a open parentheses then it\\u2019ll push it to stack and update count to 0.\\n- return count.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size();\\n        int count = 0, ans = 0;\\n        stack<int> st;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(x == \\')\\' && st.top() == -1){\\n                st.pop();\\n                st.push(1);\\n            }\\n            else if(x == \\')\\' && st.top() != -1){\\n                while(st.top() != -1){\\n                    count += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*count);\\n                count = 0;\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int count = 0;\\n        \\n        for(auto x:s){\\n            if(x == \\'(\\'){\\n                st.push(count);\\n                count = 0;\\n            }\\n            else{\\n                count = st.top() + max(1, 2*count);\\n                st.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655150,
                "title": "2-approaches-o-1-space-c",
                "content": "Implementation\\n\\n**1st Approach\\nUsing stack\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nMost Efficient Approach\\nTime Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0);\\n        \\n        for(auto itr : s){\\n            // if meets this \\'(\\' then just add 0 to stack\\n            if(itr == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                // if we meets \\')\\' then take out the top value, and\\n                // check if its 0 then simply add 1 to the next top of the stack, or\\n                // if its more than 0 it means we are already in one inside the level, then\\n                // simply multiply that value by 2, and add it into the next top of the stack\\n                int val = st.top();\\n                st.pop();\\n                int newValue = 0;\\n                if(val){\\n                    newValue = val * 2;\\n                }\\n                else{                    \\n                    newValue = 1;\\n                }\\n                st.top() += newValue;                \\n            }\\n        }\\n        return st.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        \\n        for(int itr = 0; itr < s.size(); itr++){\\n            if(s[itr] == \\'(\\') depth++;\\n            else depth--;\\n            \\n\\t\\t\\t// we need to add the 2^depth, when we are getting any pair like ()\\n            if(s[itr] == \\')\\' && s[itr-1] == \\'(\\'){\\n                res += pow(2, depth);\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141848,
                "title": "c-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int a=0;\\n        int result=0;\\n        for(int i=0;i<S.length()-1;++i)\\n        {\\n            if(S[i]==\\'(\\')\\n            {\\n                if(S[i+1]==\\')\\')\\n                    result+=1<<a;\\n                a++;\\n            }\\n            else\\n                a--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299821,
                "title": "python-faster-than-83-easy-understanding-explaining-with-comments",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stk = [0]   # temp value to help us\\n\\n        for char in s:\\n            if char == \\'(\\':\\n                stk.append(0)   # new parent: current sum = 0\\n            else:\\n                # An expression will be closed\\n                # Find its value: either 1 for empty () or 2 * its sub-expressions\\n                # we can calc both with a simple max()\\n                value = max(2 * stk.pop(), 1)\\n\\n                # Add the expression sum to its parent current sum\\n                #  Assume we have expression E that is (CHD)\\n                # where C, H, D are valid-subexpressions with values 5, 10, 4\\n                # then E is (5+10+4) = (19) = 38\\n                # Every time we finish an expression, we add its value to its parent\\n                # get the parent and update its sum with a finished sub-expression\\n                stk[-1] += value\\n\\n        return stk.pop()\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1149968,
                "title": "c-o-n-time-o-1-space-have-illustration-very-straightforward-and-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/1097015d-9a3d-4aa5-ab1c-f541f4fdb844_1617961993.5570076.png)\\n\\nBy apply rules in the question, we get:\\n**Score**= 2 x (  2x(1+(2x1)+1) + 1 + 2x1 )\\n### = (2x2x1)+ (2x2x2x1) + (2x2x1) + (2x1) + (2x2x1) (**\\\\***)\\n= 22\\n\\nLook at above (\\\\*) expression and line-chart, I see some logical: \\n1. **number of 1s is equal to number of top** in line-chart\\n2. **number of 2s of each sub-expression == (height_of_top  - 1)**\\n\\nExample: Assume height of top is 4 (the second top of above chart), so we have to **multiply 1 by 2^3** \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int top=0, ans=0;\\n        for(int i=0; i<S.size(); i++)\\n        {\\n          if(S[i]==\\'(\\') {\\n            top++;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(S[i+1]==\\')\\') ans+=pow(2,top-1);  // on top\\n\\t\\t  } else top--;\\n        }\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080600,
                "title": "score-of-parentheses-stack-python-3-o-n",
                "content": "crr record the score at the current layer level.\\n\\n**If we meet \\'(\\':**\\n1. we push the current score to stack,\\n1. enter the next inner layer level,\\n1. and reset crr = 0.\\n\\n**If we meet \\')\\':**\\n1. we cumulative points of crr while not meet \\'(\\' yet.\\n1. We exit the current layer level,\\n1. and set crr = stack.pop() + crr\\n\\nComplexity: O(N) time and O(N) space\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        crr, stack = 0, []\\n        for pos in range(len(S)):\\n            if S[pos] == \\'(\\':\\n                stack.append(\\'(\\')\\n            else:\\n                while stack[-1] != \\'(\\':\\n                    crr += stack[-1]\\n                    stack.pop()\\n                stack[-1] = crr * 2 if crr else 1\\n                crr = 0\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080516,
                "title": "c-easy-stack-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> stack;\\n        int res = 0;\\n        for (auto c : S) {\\n            if (c == \\'(\\') {\\n                stack.push(res);\\n                res = 0;\\n            }\\n            else {\\n                int prev = stack.top();\\n                stack.pop();\\n                res += prev + max(res, 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718346,
                "title": "java-use-stack",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> st = new Stack<>();\\n        int res = 0;\\n        for (char c : S.toCharArray()) {\\n            if (c == \\'(\\') {\\n                st.push(res);\\n                res = 0;\\n            } else {\\n                res = Math.max(1, res * 2);\\n                res += st.pop();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189588,
                "title": "python-concise-100-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                num = stack.pop()\\n                stack[-1] += (1 if num==0 else 2*num)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856351,
                "title": "single-pass-o-n-no-stack-no-recursion",
                "content": "\\n\\n```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int ScoreOfParentheses(string s)\\n    {\\n        int res = 0;\\n        int n = 1;\\n        \\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                n *= 2;\\n            }\\n            else\\n            {\\n                n /= 2;\\n                if (s[i - 1] == \\'(\\') res += n;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248095,
                "title": "solution-swift-score-of-parentheses",
                "content": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.008 (0.009) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func scoreOfParentheses(_ s: String) -> Int {\\n        \\n        var arr = Array(s), val = 0, res = 0\\n        \\n        for i in 0 ..< arr.count {\\n            if arr[i] == \"(\" {\\n                val += 1\\n            } else {\\n                val -= 1\\n                if arr[i-1] == \"(\" { res += 1 << val }\\n            }\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.scoreOfParentheses(\"()\")\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.scoreOfParentheses(\"(())\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test2() {\\n        let value = solution.scoreOfParentheses(\"()()\")\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354283,
                "title": "python-using-stack",
                "content": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        if not S:\\n            return 0\\n\\n        count = 0\\n        stack = []\\n        flag = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                flag = 1\\n                stack.append(\"(\")\\n            if S[i] == \")\":\\n                if flag == 1:\\n                    count += 2**(len(stack)-1)\\n                    flag = 0                \\n                stack.pop()\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 3100132,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int x=0;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                st.push(x);\\n                x=0;\\n            }\\n            else\\n            {\\n                if(x==0)\\n                x=1;\\n                else\\n                x*=2;\\n                x+=st.top();\\n                st.pop();\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197544,
                "title": "java-basic-stack-based-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nOur line of thinking is like this: when you see a new opening bracket, you\\'ll later need to double the \"score\" of everything inside of it. When you see a closing bracket, pop the stack to retrieve the \"score\" of what\\'s inside the pair, double the score (because of (A) = 2 * A, given in problem), then use it as a sum term; if it\\'s inside another bracket, then add that to what\\'s now at the top of the stack, because it needs to be part of that \"doubling\" operation. If the stack is empty, then just add it straight to your final answer.\\n\\nThe ternary operator in the popping operation area is because if you end up with \\'()\\', there is nothing inside of it, but the score should be 1, not 0. So, we treat that as a special case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        int res = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            char c = S.charAt(i);\\n            if (c == \\'(\\') {\\n                stack.push(0);\\n            } else if (c == \\')\\') {\\n                int pop = stack.pop() * 2;\\n                pop = (pop == 0) ? 1 : pop;\\n                if (! stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    stack.push(top + pop);\\n                } else {\\n                    res += pop;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142807,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of the input string `s` keeping track of the parenthesis `depth` to accumulate the answer `ans` by performing reductions when the previous `pre` and current `cur` characters are `\\'(\\'` and `\\')\\'` correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun scoreOfParentheses(s: String): Int {\\n        var ans = 0\\n        var pre = \\'0\\'\\n        var depth = 0\\n        for (cur in s) {\\n            depth += if (cur == \\'(\\') 1 else -1\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 shl depth\\n            pre = cur\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet scoreOfParentheses = (s, depth = 0, pre = \\'0\\', ans = 0) => {\\n    for (cur of s) {\\n        depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n        if (pre == \\'(\\' && cur == \\')\\')\\n            ans += 1 << depth;\\n        pre = cur;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str, depth = 0, pre = \\'0\\', ans = 0) -> int:\\n        for cur in s:\\n            depth += 1 if cur == \\'(\\' else -1\\n            if pre == \\'(\\' and cur == \\')\\':\\n                ans += 1 << depth\\n            pre = cur\\n        return ans\\n```\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut ans = 0;\\n        let mut pre = \\'0\\';\\n        let mut depth = 0;\\n        for cur in s.chars() {\\n            depth += if cur == \\'(\\' { 1 } else { -1 };\\n            if pre == \\'(\\' && cur == \\')\\' {\\n                ans += 1 << depth;\\n            }\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int depth = 0, char pre = \\'0\\', int ans = 0) {\\n        for (auto cur: s) {\\n            depth = cur == \\'(\\' ? depth + 1 : depth - 1;\\n            if (pre == \\'(\\' && cur == \\')\\')\\n                ans += 1 << depth;\\n            pre = cur;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141786,
                "title": "c-java-3-lines-recursion",
                "content": "Search for the first balanced group, multiply by 2 the value of the inner string, and add the value of the remaning string.\\n```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\\nJava version:\\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string S, int i = 1) {\\n  if (S.size() == 0) return 0;\\n  for (auto ch = 1; ch != 0; ++i) ch += S[i] == \\'(\\' ? 1 : -1;\\n  return (i == 2 ? 1 : 2 * scoreOfParentheses(S.substr(1, i - 2))) + scoreOfParentheses(S.substr(i));\\n}\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int ch = S.length() == 0 ? 0 : 1, i = 1;\\n    for (; ch != 0; ++i) ch += S.charAt(i) == \\'(\\' ? 1 : -1;\\n    return i == 1 ? 0 : (i == 2 ? 1 : 2 * scoreOfParentheses(S.substring(1, i - 1))) + scoreOfParentheses(S.substring(i));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858290,
                "title": "score-of-parentheses-o-n-simple-java-for-loop",
                "content": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hello everyone,\\n\\nThe description looks like an easy one, but little tricks are there.\\n\\nI did not use data structures as the restrictions are straightforward.\\nThe idea and thought process behind this is as follows:\\n\\t1. Based on the conditions, we could see the first character will be an open bracket\\n\\t2. Whenever open bracket and close bracket comes together -> () we will sum the result\\n\\t3. Another thing is we have to double the bracket whenever we see an open bracket -> \\'(\\'  and divide the bracket whenever we see close bracket -> \\')\\'\\n\\nThese 3 points will work even with any loops. Please upvote if its helpful.. Happy learning :)\\n\\n```\\n    public int scoreOfParentheses(String s) {\\n        int res = 0;\\n        int bracket = 0;\\n        for(int i=0; i<s.length(); i++){\\n        \\tif(s.charAt(i)==\\'(\\')\\n            \\tbracket*=2;\\n        \\tif(bracket==0)\\n        \\t\\tbracket=1;\\n        \\tif(s.charAt(i)==\\')\\' && s.charAt(i-1)==\\'(\\')\\n        \\t\\tres = res + bracket;\\n        \\tif(s.charAt(i)==\\')\\')\\n        \\t\\tbracket/=2;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1857804,
                "title": "c-3-approach-stack-in-place-stack-counter",
                "content": "# 1. stack approach\\nBy intuitation of this problem, many people can use stack to solve it.\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\\nTime complexity = O(n), Space complexity = O(n)\\nNow, we want to improve space complexity from O(n) to O(1)\\n\\n\\n# in-place stack approach but out of value\\n\\nWe use the space in left part of string s as the in-place stack. \\nWe can have the following solution but character only can show 0~255. \\nbut 2^50 is larget than 255. \\nSo, the in-place stack approach is out of char value for this algorithm.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\\n# 2. in-place stack approach \\nBecause the sum always add value of power(2, x). \\nwe can save x in the in-place stack. so the in-place stack \\nwill not out of value. \\n\\nTime complexity O(n)\\nSpace complexity O(1)\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\n\\n# in-place stack approach that simplify into one variable\\nIn the previous method, you can observe the values store in your stack \\nis somethign like [1,2,3,4,5,...,t]. Thus one variable can represent this stack. \\nWe have the following code to use one variable to represent this stack.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\\n\\nThat\\'s so interesting, the stack is become a counter.\\nAnd we need to observe more and find out new approach. \\n`()` = 1 = 2^`0` .The substring lead by `()` is `()`.\\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 0\\n\\n((((`()`)))) = 2^`4`  The substring lead by `()` is (((((), \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\n\\nObserve this string\\n((((`()`)(`()`))))\\n\\nthere are two `()` in this string, and each `()` mean one value.\\nso we need to sum of this two values. \\nThe substring lead by left `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nThe substring lead by right `()` is (((((), so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nSo, the value for left  `()` is 2^4. \\n\\nFor the right `()`, the substring it lead is ((((())(() , so \\nthe total number of \\'(\\' minus total number of \\')\\' is equal to 4\\nThe value of right `()` is 2^4. \\n\\nSo the value of \"((((())(()))))\" is 2^4 + 2^4 = 32 \\n\\nFor this observation , we can write the following counter approach.\\n# 3. counter approach\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\\nTime complexity : O(n)\\nSpace complexity: O(1)\\n\\nThere is something intresting here. \\nIf you compare the two source code from \\n**in-place stack approach that simplify into one variable**  \\nand **counter approach**. these two source code  are almost the same. \\n\\nBy the way, if you want to optimize the code of counter approach, we can do this\\n\\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                stk.push( stk.empty()?1:stk.top()*2);\\n            } else {//s[i]==\\')\\'\\n                sum +=stk.top();\\n                stk.pop();\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    stk.pop();\\n                }\\n            }\\n        }\\n        return sum;        \\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?1:s[stk_idx]*2;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                sum +=s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        //stack<int> stk;\\n        int stk_idx=-1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                //stk.push( stk.empty()?1:stk.top()*2);\\n                s[++stk_idx] = stk_idx==-1?0:s[stk_idx]+1;\\n            } else {//s[i]==\\')\\'\\n                //sum +=stk.top();\\n                //sum +=s[stk_idx];\\n                sum += 1<<s[stk_idx];\\n                //stk.pop();\\n                --stk_idx;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    i++;\\n                    //stk.pop();\\n                    --stk_idx;\\n                }\\n            }\\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int stk= -1;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++stk;\\n            } else {\\n                sum += 1<<(stk);\\n                --stk;\\n                while(i+1<n && s[i+1]==\\')\\') {\\n                    ++i;\\n                    --stk;\\n                }\\n            }\\n        }\\n        return sum;        \\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0;\\n        int sum = 0;\\n        int n = s.length();\\n        for(int i = 0;i<n;i++) {\\n            if(s[i] == \\'(\\') {\\n                ++cnt;\\n            } else if(s[i]==\\')\\') {\\n                --cnt;\\n            }\\n            if(i-1>=0 && s[i-1]==\\'(\\' && s[i]==\\')\\') {\\n                sum += 1<<cnt;\\n            }\\n            \\n        }\\n        return sum;\\t\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int cnt= 0, ans =0, n = s.length();\\n        for(int i = 0;i<n;i++) \\n            if(s[i] == \\'(\\')\\n                ++cnt;\\n            else\\n                ans += (s[i-1]==\\'(\\')<<--cnt;\\n        return ans;\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856605,
                "title": "c-simplest-solution-0ms-w-explanation",
                "content": "The approach is to use stack but it\\'s a little different from our intuition. We do not push the characters in the given string. \\nInstead, we push the score onto stack.\\n\\n**APPROACH :**\\n\\n* We start with ```score = 0```.\\n\\n* If the current char is ```(```, we push the curr score on to the stack & reset the score to ```0```.\\n\\n*  Else if the current character is ```)```, we calculate the score & pop the top of the stack :\\n\\n         1. ```score = st.top() + max(score*2 + 1)``` .\\n         \\n         2. This is because, we need to add the previous score as we traverse the string & compute the current score (```st.top()```)\\n         \\n         3. If the score is set back to ```0```, after a ```(``` is pushed, then the score has to be ```1``` when ```)``` is encountered.\\n         \\n         4. If the parantheses are this way -- ```( ( ) )```, then the inner parantheses score is computed as ```1``` & then we encounter the outer ```)```.\\n         \\n         5. Now, the score is ```1```, so we need to do ```2*score```.\\n         \\n         6. Add the current score to the previous : ```curr score+ st.top()```\\n\\n\\n**Time Complexity :** O(n) - We are visiting each character only once.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```score = 0```\n```(```\n```0```\n```)```\n```score = st.top() + max(score*2 + 1)```\n```st.top()```\n```0```\n```(```\n```1```\n```)```\n```( ( ) )```\n```1```\n```)```\n```1```\n```2*score```\n```curr score+ st.top()```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.size(), score = 0;\\n        stack<int> st;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'(\\') {\\n                st.push(score);\\n                score = 0;\\n            } else {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231515,
                "title": "c-0ms-sol-beats-100-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> stk;\\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            {\\n                //we store the \\'(\\' as -1 in stack\\n                stk.push(-1);\\n            }\\n            else{\\n                int res=0;\\n                    while(stk.top()!=-1)\\n                    {\\n                        //until a opening bracket\\n                        //we sum up all the numbers \\n                        //multiply by 2 and we push it\\n                        res+=stk.top();\\n                        stk.pop();\\n                    }\\n                //remove the opening bracket\\n                stk.pop();\\n                (res==0) ? stk.push(1) : stk.push(2*res);\\n            }\\n        }\\n        int ans=0;\\n        while (!stk.empty()){\\n            ans+=stk.top();\\n            stk.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098596,
                "title": "2-solutions-with-pictures",
                "content": "The first idea is straightforward:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/b908f74e-09de-4e16-b417-a529bc2bdecd_1615384272.95443.png)\\n\\n<br>\\n\\nIn order to store the results of `B` calculation we need a separate variable from the one we used for `A`. After we are done with `B` we no longer need it as we add it to \\'A\\'. But in the process of calculating `B` we may need new variable to calculate say `C`. It seems like we have recursion and we need a stack to store the calculations on the current recursive call. Also there are two alternatives:\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/428b95c1-25b5-47fd-a4dc-68fd0c01920a_1615386243.2236943.png)\\n\\n\\n<br>\\n\\nThat\\'s not that important, you can do it either way.\\n\\n**`Stack` based \"delayed\" calculations**: time `O(N)`, space `O(N)`\\nAs we have seen the basic idea is the following:\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/617dfffb-40f5-448a-96af-3ed18cbb45fa_1615301025.9395669.png)\\n\\n<br>\\n\\nHere the caller does the doubling and adding.\\nYou can think about it like a company that has bank account(stack frame). Inside a mother company there are multiple projects(labs). Every time a new project is created it\\'s given it\\'s own bank account with `0` money on it. At the end of the project it\\'s earned money is funnelled back into the mother organization. Projects are allowed to open it\\'s own subprojects. That\\'s recursion, hence the use of stack.\\n\\nHere\\'s implementation and a more accurate picture. The calee does the doubling and the caller does the adding. New stack is created every time `\\'(\\'` is encountered and is closed in case of `\\')\\'`.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/86ed0703-b119-489d-bd03-4acc2c0aef20_1615397817.871677.png)\\n\\n<br>\\n\\nAll in all the above algo is **DFS** in the following tree.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/fdcd1f99-6a9a-4725-9eee-ea7bab0084e8_1615402799.2036629.png)\\n\\n<br>\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\\n*Recursive*\\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\\n**Global_state_variable based \"global\" calculations**:  time `O(N)`, space `O(1)`\\nAs we can see all we do is the doubling and adding (in other words we are adding the powers of two). Instead of adding `b` and `c` and then adding the `out` variable, we can add `b` to result and  `c` to `out` **directly**.\\nThus the adding is done only at the **leaf-nodes** of the tree, but to do that they need to know their height.\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/e339f56e-5836-4b07-9146-e0dbd3c145fb_1615402274.453685.png)\\n\\n\\n<br>\\n\\nIn fact you don\\'t need stacks and trees, you can use one variable to track height (or power of two) and modify `out` when you encounter `()`(leaf).\\n\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/06b5736c-5fab-4a1b-91ee-1de12514b9d1_1615298484.7858808.png)\\n\\n*Iterative*\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(string s) \\n{\\n\\tstack<int> st({0});\\n\\tfor(const auto & c : s)\\n\\t\\tif(c==\\')\\')\\n\\t\\t{\\n\\t\\t\\tauto t{max(1, 2*st.top())};\\n\\t\\t\\tst.pop();\\n\\t\\t\\tst.top() += t;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tst.push(0);\\n\\n\\treturn st.top();\\n}\\n```\n```\\nint scoreOfParentheses(string & s, int && i = -1) \\n{\\n\\tint out{0};\\n\\tfor( ; ++i<size(s); )\\n\\t\\tif(s[i]==\\'(\\')\\n\\t\\t\\tout+=scoreOfParentheses(s, move(i)); \\n\\t\\telse\\n\\t\\t\\treturn max(1, 2*out);\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t{\\n\\t\\tp = s[i]==\\')\\' ? p/2 : p*2;\\n\\t\\tif(s[i]==\\')\\' and s[i-1]==\\'(\\') out+=p;            \\n\\t}\\n\\n\\treturn out;\\n}\\n```\n```\\nint scoreOfParentheses(string s) \\n{\\n\\tauto out{0};\\n\\tfor(auto i{0}, p{1}; i<size(s); ++i)\\n\\t\\tif(s[i]==\\')\\')\\n\\t\\t{\\n\\t\\t\\tp>>=1;\\n\\t\\t\\tif(s[i-1]==\\'(\\') out+=p;   \\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\tp<<=1;\\n\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081394,
                "title": "c-single-pass-constant-space-solutions-explained-100-time-80-space",
                "content": "Read this problem this morning, had an intuition (well, a partial one) and my mind kept working on it in any break I took.\\n\\nAnd this is the final version.\\n\\nThe key intuition was to navigate it like a tree, but possibly in constant time; and then I realised that the trick is to keep track of how deep we go and add something to an accumulator variable only when we find `\\'(\\'` immediately followed by `\\')\\'` - which means we found a base expression `\"()\"` whose score is going to be equal to `pow(2, depthOfTheExpression)`.\\n\\nAny other instance of `\\'(\\'` or `\\')\\'` will just mean to go either deeper or up in an ideally nested tree.\\n\\nTo do so, we declared a few support variables:\\n* `res` is going to be our accumulator, initially set to `0`;\\n* `isOpen` is a boolean to keep track of the logic above and we will set it to `true` after each `\\'(\\'` and to `false` after each `\\')\\'`.\\n\\nTime then for the main loop, going with `i` up to `lmt` (the length of the string), setting also a counting variable `c = 0` and:\\n* when `s[i] == \\'(\\'` we will:\\n\\t* set `isOpen` to `true`;\\n\\t* increase `c`;\\n* otherwise:\\n\\t* decrease `c`;\\n\\t* if `isOpen` we will additionally:\\n\\t\\t* increase `res` by `pow(2, c)` (note that we decrease `c` in advance, not to count the current level);\\n\\t\\t* reset `isOpen` to `false`.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\nAnd then it occurred to me that we do not really need even the boolean flag, since just looking at the previous character (and we know that since the string is balance we will never encounter a `\\')\\'` at the beginning of the string) tells us just the same; surprisingly, we save a good chunk of memory this way - I guess mostly for not having to do needless operations:\\n\\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFinally, same logic in recursive format, just for the lolZ - going as fast, just burning a bit more memory:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        bool isOpen;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') {\\n                c++;\\n                isOpen = true;\\n            }\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (isOpen) {\\n                    isOpen = false;\\n                    res += pow(2, c);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\npublic:\\n    int scoreOfParentheses(string s) {\\n        // support variables\\n        int res = 0;\\n        // looping through all the characters\\n        for (int i = 0, c = 0, lmt = s.size(); i < lmt; i++) {\\n            // opening parentheses\\n            if (s[i] == \\'(\\') c++;\\n            // closing parentheses\\n            else {\\n                c--;\\n                if (s[i - 1] == \\'(\\') res += pow(2, c);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s, int pos = 0, int c = 0, int res = 0) {\\n        return pos == s.size() ? res : scoreOfParentheses(s, pos + 1, c + (s[pos] == \\'(\\' ? 1 : -1), res + ((c && s[pos - 1] == \\'(\\' && s[pos] == \\')\\') ? pow(2, c - 1) : 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081329,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth;  //binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080564,
                "title": "python-o-n-by-stack-w-comment",
                "content": "Python O(n) by stack\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        \\n        \\n        stack = []\\n\\t\\t\\n\\t\\t# cur: total score so far\\n\\t\\t# prev: previous score\\n        cur, prev = 0, 0\\n        \\n        \\n        # scan each symbol in input S\\n        for char in S:\\n            \\n            if char == \\'(\\':\\n                \\n                # \\'(\\', push in with current socre\\n                stack.append( cur )\\n                \\n                # reset previous and current to zero\\n                prev, cur = 0, 0\\n            \\n            else:\\n                \\n                # \\')\\' match with latest \\'(\\', get top score\\n                top = stack.pop()\\n                \\n                if prev:\\n                    # we have valid parenthesis pair inside, add prev\\n                    cur += top + prev\\n                else:\\n                    # no parenthesis pair inside, directly add 1\\n                    cur += top + 1\\n            \\n            # update previous as current\\n            prev = cur\\n        \\n        \\n        # total score so far\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939553,
                "title": "python3-stack-o-n",
                "content": "Approach 1 - stack `O(N)` space \\nDefine `stack` to store values when entering into a pair parenthesis. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\\n\\nApproach 2 - `O(1)` space \\nThe required value is related to the depth of parenthesis via `2**k`. \\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, stack = 0, []\\n        for c in S: \\n            if c == \"(\": \\n                stack.append(ans)\\n                ans = 0\\n            else: ans = max(1, 2*ans) + stack.pop()\\n        return ans\\n```\n```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans = k = 0\\n        for i in range(len(S)): \\n            k += 1 if S[i] == \"(\" else -1\\n            if S[i-1:i+1] == \"()\": ans += 2**k\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 512631,
                "title": "python-simple-readable-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == \\'((\\': val *= 2\\n            if S[i: i+2] == \\'()\\': ans += val\\n            if S[i: i+2] == \\'))\\': val //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141823,
                "title": "c-recursive",
                "content": "This is how many of the top scorers solved the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(string s, int a, int b) {\\n        \\n        int v = 0;\\n        \\n        if (b - a == 1)  return 1; // \"()\"\\n                \\n        for (int i=a; i<=b; i++) {\\n            \\n            if (s[i] == \\'(\\') v++;\\n            else if (s[i] == \\')\\') v--;\\n            \\n            if (v==0 && i!=b)\\n                return helper(s, a, i) + helper(s, i+1, b); // (...) + (...)\\n        }\\n        \\n        return 2*helper(s, a+1, b-1); // (...)\\n\\n    }\\n\\n    \\n    int scoreOfParentheses(string S) {\\n        return helper(S, 0, S.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405044,
                "title": "c-100-beats-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n\\n        for(auto it : s)    {\\n            if(it == \\'(\\')   st.push(-1);\\n            else if(st.top()==-1)    {\\n                st.pop();\\n                st.push(1);\\n            }\\n            else    {\\n                int x = 0;\\n                while(st.top() != -1)   {\\n                    x += st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*x);\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty())  {\\n            ans += st.top();\\n            st.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860335,
                "title": "explained-go-clean-solution-using-stack-beats-100-on-runtime-92-on-memory",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe Stack is a common data structure we use when dealing with parentheses problems.\\n\\nSo let\\'s implement a simple slice-based Stack:\\n    1. Create a Stack structure that holds the data field of type []rune.\\n    2. Define the Push method to add a new value to the Stack using simple append().\\n    3. Define the Pop method to remove the top element from the Stack returning this very element. We can remove the last element of the array using slicing: slice = slice[:len(slice)-1].\\n\\nThen we implement our business logic:\\n1. Initialize an empty stack and a multiplier equal to 1. The multiplier variable will be added to the answer every time we see the \"()\" in our input string.\\n2. Let\\'s loop through the input string: \\n    a. Pop the element from the top of the stack.\\n    b. If the top element is \\'(\\' and we got \\')\\' as the current character, add the multiplier to the answer.\\n    c. If we get two consecutive \"((\", then, as stated in the problem description, multiply the multiplier by 2.\\n    d. If we get two consecutive \"))\", then we divide the multiplier by 2.\\n    e. Push the current character to the stack.\\n\\n# Complexity\\n- Time complexity: $O(n)$ - one pass through the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ - we need to store **at most** half of the input string in our stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```\\ntype Stack struct {\\n    data []rune\\n}\\n\\nfunc (s *Stack) Push(val rune) {\\n    s.data = append(s.data, val)\\n}\\n\\nfunc (s *Stack) Pop() rune {\\n    if len(s.data) == 0 {\\n        var r rune\\n        return r\\n    }\\n\\n    top := s.data[len(s.data) - 1]\\n    (*s).data = s.data[:len(s.data) - 1]\\n    return top\\n}\\n\\nfunc scoreOfParentheses(s string) int {\\n    var stack Stack\\n\\n    ans := 0\\n    multiplier := 1\\n    for _, c := range s {\\n        top := stack.Pop()\\n\\n        switch {\\n        case top == \\'(\\' && c == \\')\\':\\n            ans += multiplier\\n        case top == \\'(\\' && c == \\'(\\':\\n            multiplier *= 2\\n        case top == \\')\\' && c == \\')\\':\\n            multiplier /= 2\\n        }\\n\\n        stack.Push(c)\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1857575,
                "title": "python-solution-using-stack-with-explanation",
                "content": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n######################################################\\n\\n#   Runtime: 28ms   -   94.45%\\n#   Memory: 13.8MB  -   70.86%\\n\\n######################################################\\n\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n\\n        stack = []\\n        # Looping through string\\n        for char in s:\\n            # If char is \"(\" we add it to stack\\n            if char == \"(\":\\n                stack.append(\"(\")\\n            else:\\n                # If char is \")\", we pop out the top element from stack till\\n                # we find \"(\". The popped elements will be 2 * score of child\\n                # balanced parentheses of current closed parentheses we have found\\n                # So we will add them to score var\\n                score = 0\\n                while stack[-1] != \"(\":\\n                    score += stack.pop()\\n                # If score is 0, that means the top of stack is \"(\" and we have\\n                # () in the string. So we make score 1\\n                if score == 0: score = 1\\n                # We remove \"(\" from stack\\n                stack.pop()\\n                # We append twice the actual score that a balanced parentheses should\\n                # have into the stack\\n                stack.append( 2 * score)\\n        # stack will have only 1 element if s is of format \"(A)\"\\n        # Else it will have > 1 element.\\n        # Each element will be int of scores multiplied by 2.\\n        # We add them and divide by 2 to remove that extra multiple 2 which we have done\\n        # in our logic\\n        return sum(stack) // 2\\n\\n        \"\"\"\\n            Example: \"(()())()\"\\n            char        stack\\n             (            [\"(\"]\\n             (            [\"(\", \"(\"]\\n             )            [\"(\", 2]\\n             (            [\"(\", 2, \"(\"]\\n             )            [\"(\", 2, 2]\\n             )            [8]\\n             (            [8, \"(\"]\\n             )            [8, 2]\\n\\n            Finally sum(stack) // 2\\n                    = (8 + 2) // 2\\n                    = 5\\n            which is the score of that string\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857281,
                "title": "java-0ms-no-stack-use-with-simple-math-based-on-depth-intuitive-with-explanation-o-1-space",
                "content": "## Score of Parentheses\\n[Based on the Amazing c++ solution given by @artod](https://leetcode.com/problems/score-of-parentheses/discuss/1856699/C%2B%2B-BEATS-100-OMG!!!)\\n\\nCredit to [Soba_1](https://leetcode.com/Soba_1/) for recommending the use of left shift operator on the original post to calculate the power of 2 which can increase the effeciency even more.\\n\\nFirst of all, wow, what an amazing solution by Artod for c++, it\\'s so simple and at the same time genius.\\nI am just adding on a bit more thought into it and trying to explain a bit more in depth about why it works with a solution in Java.\\n**Time: O(N) \\n Space: O(1)**\\n\\n**Explanation**\\n\\n**Problem with the simple detect nesting and add/multiply approach/ What didn\\'t work so smoothly:**\\n\\nWhile we can get caught up on the fact that how we can add the score when there is no nestin and how we can multiply it by 2 when there is nesting, when you start to code it, you realize that it becomes very complicated when you have to detect deep nesting, let\\'s say something like (()(((((()))))))). Trying to use a stack and a loop to track where the nesting starts and stops is possible but kind of complicated and can lead to a lot of issues which I faced as well when I was trying to brute force my way through it, I tried assigning a 1 every time opening and closing brackets were next to one another then I quickly realised there could be something like this (((()()())))()() and now I\\'ll need too many functions and loops with potential infinity loop problems if I tried to brute force my way through this.\\n\\n**How it was avoided with Math**\\n**Approach:** Score for each pair is actually dependent on how deep the pair is inside.\\n1. This Appraoch in comparison to brute forcing to detect nesting notices a very simple thing, instead of looking at a string (()()) as 2(1+1) we can also look at it like `2*1 +2*1` or `2^1 + 2^1`.\\n2. You can also look at something like ((( () () ) () ) as `2^3 + 2^3 + 2^2` instead of `((1+1)*2+1)*2`\\n3. What does this signify? For a deep bracket ((())) it\\'s going to be `2*2*1` which is actually just 2^how deep the pair without nesting was, hence if we calculate the individual score based upon the depth of non nested parentheses and add those, we\\'ll get the correct score.\\n4. If we look at it for a while, we\\'ll realise that we\\'re first following the distributive property of multiplication over addition and after that instead of multiplying by 2 for every level of nesting, we\\'re just using the power of 2.\\n\\nHence for example ((( () () ) () ) answer is more like\\n> score of how deep first () was + score of how deep second () was +score of how deep third () was.\\n which is in other words, 2^how deep the first () was+2^how deep the second () was + 2^ how deep the third () was.\\n \\n \\n **Code:**\\n```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Math",
                    "Stack"
                ],
                "code": "```\\n class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score =0;\\n        int depth=0;\\n        int s_length=s.length();\\n        char prev=\\' \\';\\n        for(int i=0;i<s_length;i++){\\n            if(s.charAt(i)==\\'(\\')\\n                depth++;\\n            else{\\n                depth--;// ignore the parentheses we found just before ) as it\\'s not contributing to the depth\\n                if(prev==\\'(\\'){\\n                    score+=Math.pow(2,depth); //Calculate score for the () we just found and add it\\n\\t\\t\\t\\t\\t//score+=1<<depth; this can calculate the power even more effeciently. Thanks soba_1 <3\\n                }\\n            }\\n            prev=s.charAt(i);//Keep track of the last character we found for deciding if we\\'re just decreasing the depth or we\\'ve also got a new ()? Why this?\\n\\t\\t\\t\\t\\t\\t//Two reasons, one to detect the () non nested bracket\\n\\t\\t\\t\\t\\t\\t//other one:\\n\\t\\t\\t\\t\\t\\t//For example; (()) ()  -> (()) | after this point previous depth doesn\\'t matter to us, so in this case we\\'re just decreasing the depth and moving forward. the () in the end has a depth of 1\\n        }\\n        return score;\\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857252,
                "title": "python-solution",
                "content": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    class Solution:\\n\\t\\tdef scoreOfParentheses(self, s: str) -> int:\\n\\t\\t\\tif s == \"()\":           # Base condition for recursion\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tstack = []\\n\\t\\t\\ti = j = 0\\n\\t\\t\\tans = 0\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\twhile i < length:\\n\\t\\t\\t\\tstack.append(i)   \\'\\'\\'It will be surely opening parentheses\\'\\'\\'\\n\\t\\t\\t\\tj = i              \\'\\'\\'Now we will look for it\\'s closing parentheses \\'\\'\\'\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tif s[j] == \\'(\\':\\n\\t\\t\\t\\t\\t\\tstack.append(j)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\tif (i+1) != j:      \\'\\'\\'If string b/w parentheses (found above) is not empty \\'\\'\\'\\n\\t\\t\\t\\t\\tans += 2 * self.scoreOfParentheses(s[i+1:j])    #recursion\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\ti = j+1     \\'\\'\\'Continuing ahead closing parentheses \\'\\'\\'\\n\\t\\t\\treturn ans\\n\\n                    \\n        \\n                \\n                    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1857214,
                "title": "c-easy-to-understand-algorithm-daily-leetcoding-challenge-march-day-17",
                "content": "Please Upvote if it helps\\u2B06\\uFE0F\\n\\n**Algorithm**\\n\\n* Just create an **empty stack** to store the **pair of parenthesis**\\n\\n* Iterate over the given string then checked **2 cases**:\\n     1.      if we found \\'(\\' parenthesis **store it into stack** and set score of pair 0 again \\n     2.      if we found \\')\\' parenthesis calculate the score for that parensthis by using formula **score = stack.top() + max(2*score, 1)** **and pop**\\n* After whole iteration **return the score**\\n\\n**Time Complexity: O(N)** \\n**Space Complexity: O(N)**\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int score = 0;\\n        stack<int> st;\\n        \\n        for(auto it : s)\\n        {\\n            // when we found ( just push it to the stack\\n            if(it==\\'(\\')\\n            {\\n                // pushing a pair\\n                st.push(score);\\n                \\n                // set score to 0 again for new pair\\n                score = 0;\\n            }\\n            \\n            // if we found ) parenthesis for a pair then change the score\\n            else\\n            {\\n                score = st.top() + max(2*score, 1);\\n                st.pop();\\n            }\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857005,
                "title": "python3-runtime-24-ms-faster-than-98-71-memory-13-8-mb-less-than-97-15",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        stack = []\\n        ans = 0\\n        for i in s:\\n            if i == \")\":\\n                ans += stack.pop()+ max(ans,1)   \\n            else:\\n                stack.append(ans)\\n                ans = 0   \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856804,
                "title": "c-java-easy-to-understand-o-1-without-stack-simple-efficient",
                "content": "**856. Score of Parentheses**\\n\\n##### **APPROACH -**\\n* **`() = 1, (()) = 2, ((())) = 4, (((()))) = 8; ==> score = 2^(level - 1)`**\\n\\n*Create `level` to store current level, i.e. number of continuously nested pair of parentheses\\n**Level increases at every open parenthesis and decreases at every close parenthesis**\\nWhenever a set of continously nested pair of parenthesis ends, add the score for this set*\\n\\n<br/>\\n\\n##### **ANALYSIS -**\\n* **Time Complexity : O(N)**, where N = length of string\\n* **Space Complexity : O(1)**\\n\\n<br/>\\n\\n##### **IMPLEMENTATION -**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```\\n**If you found this helpful, please Upvote \\u2B06\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s[i] == \\'(\\')    \\n\\t\\t\\t\\tlevel++;\\n            else    \\n\\t\\t\\t\\tlevel--;\\n            if(s[i] == \\')\\' && s[i-1] == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int score = 0, level = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'(\\')    \\n                level++;\\n            else    \\n                level--;\\n            if(s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\')\\n                score += 1 << level;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856797,
                "title": "856-c-o-n-solution-with-explanation",
                "content": "**Please upvote if you find this solution helpful :)**\\n\\n**Approach:**\\n* Use stack to store the score of the parenthesis pair.\\n* Iterate over the string if we find open parenthesis put current_score into the stack and initialize current_score to 0 (for the new parenthesis pair).\\n* If we find close parenthesis we calculate the current score by using the formula **current_score = stack.top() + max(2*current_score, 1)** and pop out the top most element.\\n* At the end return the current_score.\\n**Time Complexity: O(N), Space Complexity: O(N)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if you find this solution helpful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        stack<int> st;\\n        int ind=0;\\n        \\n        for(auto i : s)\\n        {\\n            //if we found open parenthesis\\n            if(i==\\'(\\')\\n            {\\n                st.push(ind);\\n                \\n                //set ind to 0\\n                ind = 0;    \\n            }\\n            //if we found close parenthesis\\n            else\\n            {\\n                ind = st.top() + max(2*ind, 1);\\n                st.pop();\\n            }\\n            \\n        }\\n        return ind;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856359,
                "title": "time-o-n-space-o-n-recursion-solution-in-python",
                "content": "Move the index from left to right.\\nWhen we find open parenthesis `(`, we call recursion from the next character.\\nWhen we find close parenthesis `)`, we return the values inside the recursion, and also return the length of the expression inside parenthesis.\\n\\nAll numbers are stored in the `stack`, and we return the sum of the value in `stack` and the end. When `stack` is empty, that means there was a `()` pair with nothing inside, so return 1 as value.\\n\\n```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        def rec(s):\\n            stack = []\\n            idx = 0\\n            L = len(s)\\n            while idx < L:\\n                if s[idx] == \\'(\\':\\n                    val, length = rec(s[idx + 1:])\\n                    idx += length + 1\\n                    stack.append(val)\\n                elif s[idx] == \\')\\':\\n                    val = 2 * sum(stack) if stack else 1\\n                    return val, idx\\n                idx += 1\\n            \\n            val = sum(stack) if stack else 1\\n            return val, idx\\n            \\n        return rec(s)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374384,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int sum=0;\\n        int level=1;\\n        Deque<Character> stack =new ArrayDeque<>();\\n        \\n        s = s.replace(\"()\", \"1\");\\n        for(char c: s.toCharArray()){\\n            if(c==\\'(\\'){\\n                level*=2;\\n            }else if(c==\\')\\'){\\n                level/=2;\\n            }else if(c==\\'1\\'){\\n                sum += level*1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195998,
                "title": "java-stack-easy-solution",
                "content": "\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n          if(s.charAt(i)==\\'(\\'){\\n            stack.push(-1);\\n          }\\n          else if(stack.peek()==-1){\\n            stack.pop();\\n            stack.push(1);\\n          }\\n          else{\\n            int score=0;\\n            while(stack.peek()!=-1){\\n              score+=stack.pop();\\n            }\\n            stack.pop();\\n            stack.push(2*score);\\n          }\\n        }\\n      int score=0;\\n      while(stack.size()>0){\\n        score+=stack.pop();\\n      }\\n      return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187189,
                "title": "o-1-space-o-n-time-intuitive-concise-and-efficient",
                "content": "Approach:\\n(()(())) = (()) + ((())) = 2 + 4\\n(1+2)  \\n6\\n\\nAt every \\'(\\' we are moving deeper, so we multiply the current depth with 2\\nAt the first \\')\\', add the current depth to final score; \\nAt every \\')\\' (including first) reduce the depth by dividing by 2\\n\\n```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Time O(n), Space O(1)\\n// No stack\\n\\nfunc scoreOfParentheses(S string) int {\\n    \\n    var score int\\n    depth := 1  \\n    flag := false\\n    \\n    for _, ch := range S {\\n        if ch == \\'(\\' {\\n            depth *= 2\\n            flag = true\\n        } else {\\n            depth /= 2\\n            if flag {\\n                score += depth\\n                flag = false\\n            }\\n        }    \\n    }\\n    \\n    return score\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085077,
                "title": "java-recursion-beats-100-14-line-code",
                "content": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int index = 0;\\n    public int scoreOfParentheses(String S) {\\n        int score = 0;\\n        while(index<S.length()){\\n            if(S.charAt(index)==\\'(\\'){\\n                index++;\\n                score+=scoreOfParentheses(S);\\n            }\\n            else if(S.charAt(index)==\\')\\'){\\n                index++;\\n                score= score==0 ? 1 : 2*score;\\n                return score;\\n            }   \\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082430,
                "title": "c-2-approaches-o-n-0ms-beats-100-no-extra-space-best-easy-to-understand",
                "content": "**APPROACH 1 ( Using Stack ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(n)**\\n\\n---\\n\\n**APPROACH 2 ( No Extra Space ) CODE IMPLEMENTATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)**\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>st;\\n        int ans=0;\\n        st.push(0);\\n        int i=1;\\n        while(i<S.length()){\\n            if(S[i]==\\'(\\'){\\n                st.push(0);\\n            }            \\n            else{\\n                int top=st.top();                                           \\n                st.pop();\\n                int curr = top ? top : 1;\\n                if(st.empty()){\\n                    ans+=curr;  \\n                }\\n                else{\\n                    int new_top=st.top();\\n                    st.pop();\\n                    curr=curr<<1; // curr*2 = curr<<1\\n                    st.push(new_top+curr); \\n                }\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int ans=0;\\n        int dm=2; // depth-multiplier\\n        for(int i=1;i<S.length();++i){\\n            if(S[i]==\\'(\\'){\\n                dm=dm<<1; // dm=dm*2\\n            } \\n            else{\\n                dm=dm>>1; // dm=dm/2\\n                if(S[i-1]==\\'(\\') ans += dm; // \"()\" is encountered        \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081068,
                "title": "score-of-parentheses-c-easy-using-stack",
                "content": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\tint n=s.size();\\n        int count=0;\\n        stack<int> st;\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                sum=0;\\n                st.push(0);\\n            }\\n            else\\n            {\\n                if(st.top()==0)\\n                {\\n                    sum+=1;\\n                    st.pop();\\n                    st.push(sum);\\n                    \\n                }\\n                else if(st.top()>0)\\n                {\\n                    int val=0;\\n                    while(st.top()!=0)\\n                    {\\n                        val+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*val);\\n                }\\n            }\\n        }\\n        sum=0;\\n        while(!st.empty())\\n        {\\n            sum+=st.top();\\n            st.pop();\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1080638,
                "title": "c-0-ms-faster-than-100-00-o-1-space-super-simple-solution",
                "content": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint scoreOfParentheses(char * S){\\n    int res = 0, balance = 0;\\n    for ( int index = 0; S[index]; ++index )\\n    {\\n        balance += S[index] == \\'(\\' ? 1 : -1;\\n        if ( index && S[index - 1] == \\'(\\' && S[index] == \\')\\' )\\n            res += pow( 2, balance );\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1080614,
                "title": "python-super-simple-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, balance = 0, 0\\n        for index, par in enumerate(S):\\n            balance += 1 if par == \"(\" else -1\\n            if index and S[index - 1] + par == \"()\":\\n                res += 2 ** balance\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1080527,
                "title": "python-o-n-time-o-1-or-o-n-space-with-stack-and-without-stack-1-pass",
                "content": "#### Solution I\\nscan the string, \\n1. char is `(`,  push it into the stack and record it\\'s inner `val` to `0`.  `val` is used to record all its inner value;\\n2. char is `)`,  then last elem in the stack is the match one. \\n\\t* \\tif its inner value is 0, which means there is no inner parentheses in it, set `val=1`\\n\\t* \\telse, there are some parentheses in it, we need to double it;\\n\\t* \\tthen we need to check whether is has outer parentheses\\n\\t\\t* \\tif not, just add it to the result;\\n\\t\\t* \\telse, record to its outer parentheses\\' val, which is the last element in the stack;\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\\n\\n\\n#### Solution II\\n1. using `depth` to record depth of `(` in current group;\\n2. If we come across a leaf node `()`,  we know the `result` of current group; \\n\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\\n\\n\\nIf there are same useless chars in the string, we\\'ll have to identify the leaf node by some trick.\\n\\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res = 0\\n        st = []\\n        for c in S:\\n            if c == \\'(\\': st.append(0)\\n            elif c == \\')\\':\\n                inner_val = st.pop()\\n                val = 2 * inner_val if inner_val > 0 else 1\\n                if not st: res += val\\n                else: st[-1] += val\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth = 0, 0\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                if S[idx + 1] == \\')\\': res += 1 << (depth-1)\\n            else:\\n                depth -= 1\\n        return res\\n```\n```\\n    def scoreOfParentheses(self, S: str) -> int:\\n        res, depth, isleaf = 0, 0, False\\n        for idx, c in enumerate(S):\\n            if c == \\'(\\':\\n                depth += 1\\n                isleaf = True\\n            else:\\n                depth -= 1\\n                if isleaf: res += 1 << depth\\n                isleaf = False\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 907389,
                "title": "very-simple-o-1-space-linear-solution-without-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int depth = 0;\\n        int ans = 0;\\n        \\n        for( int i=0; i<S.length(); i++){\\n            \\n            if( S.charAt(i) == \\'(\\' && S.charAt(i+1) == \\')\\' ) {\\n                ans += Math.pow(2, depth);\\n\\t\\t\\t\\t//skipping the next closing paranthesis\\n                i++; \\n            }\\n            \\n            else if( S.charAt(i) == \\'(\\')\\n                depth++;\\n            \\n            else if( S.charAt(i) == \\')\\')\\n                depth--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746700,
                "title": "java-0ms-100-solution",
                "content": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n   public int scoreOfParentheses(String S) {\\n        \\n        int i = 0, n = S.length(), open = -1, ans = 0;\\n        while (i < n) {\\n            while (i < n && S.charAt(i++) == \\'(\\') open++;\\n            \\n            ans += Math.pow(2, open);\\n            \\n            while(i < n && S.charAt(i++) == \\')\\') open--;\\n        }\\n            \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 545261,
                "title": "beats-100-c-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C online submissions for Score of Parentheses.\\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions for Score of Parentheses.\\n```\\n\\nint scoreOfParentheses(char * s){\\n    int score=0,flag=0;\\n    for(int i=0;i<strlen(s);i++){\\n        if(s[i]==\\'(\\'){\\n            flag++;\\n        }\\n        else{\\n            flag--;\\n            if(s[i-1]==\\'(\\')\\n                score += 1 << flag;\\n        }\\n    }\\n    return score;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 497396,
                "title": "java-solution-with-code-templates-for-similar-problems",
                "content": "The solution might not as concise as others, but can be used as the template to solve most similar string interpretor problem like 729 Number of Atoms, 394 Decode string...etc\\nPlease check the comments in the code\\n\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        if(S == null || S.length() == 0) return 0;\\n\\t\\t\\n\\t//Need initialize the Stack with String for all Number/Symbol/Letter\\n        Stack<String> stack = new Stack<>();\\n        \\n\\t/**Loop through the entire string and each character\\n\\tUsing if/else statement to think about all the cases for each character:\\n\\t\\'(\\' , \\')\\', \\'[\\', \\']\\', \\'number\\', \\'letter\\', \\'upperCase\\', \\'lowerCase\\' depends on the input of the problem**/\\n        for(int i = 0; i<S.length(); i++) {\\n            char c = S.charAt(i);\\n            \\n            if(c == \\'(\\') {\\n\\t\\t\\t\\n\\t\\t/**Usually need push the symbol like \\'(\\' to be the stop sign when you loop back**/\\n                stack.push(\"(\");\\n            }\\n\\t\\t\\t\\n\\t\\t/**And \\')\\' would be the symbol to start looking back, \\n\\t\\twhich needs to popup previous element until the stop sign, \\n\\t\\tand calculate the values according to the problem, \\n\\t\\tthen push back the new value to the stack**/\\n            else if(c == \\')\\'){\\n                //()\\n                if(stack.peek() == \"(\") {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                //(1234...)\\n                else{\\n                    int num = 0;\\n                    while(!stack.isEmpty() && stack.peek() != \"(\") {\\n                        num += Integer.parseInt(stack.pop());\\n                    }\\n                    stack.pop();\\n                    stack.push(String.valueOf(num * 2));\\n                }\\n            }\\n        }\\n        \\n\\t//finally popup all the elements from the stack \\n        int res = 0;\\n        while(!stack.isEmpty()) {\\n            res += Integer.parseInt(stack.pop());\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188525,
                "title": "c-solution-0ms-no-stack-no-recursion-with-explanation-o-n-runtime",
                "content": "Move forward through the string and meanwhile keep track of the number visited open and close parenthesis. \\nOnce we reach each close parenthesis followed by an open parenthesis, do calculation. The calculation is as simple as subtracting the visited closed parenthesis from visited open parenthesis used till now. \\nLet\\u2019s call it diff (cnt = open - close).\\nThen add the pow(2,cnt) and add it to result.\\nRunning Complexity O(n)\\nSpace Complexity O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {      \\n      int res=0;  int cnt=1;        \\n      if (S.size()==0)\\n           return res;\\n      for (int i=1; i<S.size();++i) {\\n          if (S[i]==\\'(\\')\\n             cnt++;\\n          else {\\n              cnt--;\\n              if (S[i-1]==\\'(\\') {\\n                  res+= pow(2,(cnt));  // or  1<<cnt;           \\n              }              \\n          }              \\n      }\\n      return res;\\n    }           \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624991,
                "title": "easy-to-understand-c-solution-stack-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<string>st;\\n        for(auto ch: s){\\n            if(ch == \\'(\\') st.push(\"(\");\\n            else{\\n                int temp = 0;\\n                while(st.top() != \"(\"){\\n                    temp += (stoi(st.top()));\\n                    st.pop();\\n                }\\n                st.pop();\\n                if(temp == 0) st.push(\"1\");\\n                else st.push(to_string(2 * temp));\\n            }\\n        }\\n        int ans = 0;\\n        while(!st.empty()){\\n            ans += stoi(st.top());\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495372,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\\n\\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans=0;\\n        stack<int> st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(-1);\\n            }\\n            else if(st.top()==-1){\\n               st.pop();\\n               st.push(1);\\n            }\\n            else{\\n                int temp=0;\\n                while(st.top()!=-1){\\n                    temp+=st.top();\\n                    st.pop();\\n                }\\n                st.pop();\\n                st.push(2*temp);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans=ans+st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = [0]\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(0)\\n            else:\\n                v = stack.pop()\\n                stack[-1] += max(2 * v, 1)\\n        return stack.pop()        \\n```\n```Java []\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        int cur = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'(\\') {\\n                stack.push(cur);\\n                cur = 0;\\n            } else {\\n                cur = stack.pop() + Math.max(cur * 2, 1);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758390,
                "title": "c-easy-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int scoreOfParentheses(string s) {\\n        int depth = 0, res = 0;\\n        char prev = \\'(\\';\\n        \\n        for (const char &ch: s) {\\n            if (ch == \\'(\\')\\n                depth++;\\n            else {\\n                depth--;\\n                if (prev == \\'(\\')\\n                    res += pow(2, depth);\\n            }\\n            \\n            prev = ch;\\n        }\\n        \\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637318,
                "title": "100-fastest-solution-simple-stack-implementation",
                "content": "The idea is that whenever we encouter any opening \\')\\' we put in stack and when we get a closing \\'(\\' and if it is \\'( )\\' then we add 1 in stack so that we can keep track of no of balanced bracket for outer one.\\nAs the brackets are balanced so there exist a \\'(\\' for every \\')\\' .\\nwe move in stack till we dont get a \\')\\' for any oter bracket and add all the previous inside parenthesis value and multiply it by 2 and push int stack.\\n\\n\\n\\n\\n```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int scoreOfParentheses(string s)\\n        {\\n            stack<int> st;\\n            int ans = 0;\\n            for (int i = s.size() - 1; i >= 0; i--)\\n            {\\n                if (s[i] == \\')\\')\\n                    st.push(s[i]);\\n\\n                else\\n                {\\n                    if (s[i + 1] == \\')\\')\\n                    {\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        int cnt = 0;\\n                        while (st.top() != \\')\\')\\n                        {\\n                            cnt += st.top();\\n                            st.pop();\\n                        }\\n                        st.pop();\\n                        st.push(cnt *2);\\n                    }\\n                }\\n            }\\n            while (st.size() != 0)\\n            {\\n                ans += st.top();\\n                st.pop();\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589641,
                "title": "c-solution-score-of-parentheses",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        char lastChar = \\'(\\';\\n        int n = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\')\\n                n++;\\n            else{\\n                n--;\\n                if(lastChar == \\'(\\')\\n                    ans = ans + pow(2 , n);\\n            }\\n            lastChar = s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323927,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-for-score-of-parentheses",
                "content": "# **[@iprincekumark](https://leetcode.com/iprincekumark/)**\\nVISIT MY PROFILE\\n**CODE :**\\n```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int> st;\\n        st.push(0); // to keep the total score\\n        for(char i:s) {\\n            if(i==\\'(\\') {\\n                st.push(0);\\n            }\\n            else {\\n                int A = st.top(), val=0;\\n                st.pop();\\n                if(A>0) \\n                    val = 2*A;\\n                else\\n                    val = 1;\\n                st.top() += val;\\n            }\\n        }\\n        return st.top();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152478,
                "title": "recursive-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(string &s,int i,int j){\\n        if(j == i+1)\\n            return 1;\\n        int ans = 0;\\n        int x = 0;\\n        int st = i;\\n        int n = s.length();\\n        while(i < j){\\n            if(s[i] == \\'(\\')\\n                x++;\\n            if(s[i] == \\')\\')\\n                x--;\\n            if(x == 0){\\n                return helper(s,st,i)+helper(s,i+1,j);\\n            }\\n            i++;\\n        }\\n        return 2*helper(s,st+1,j-1);\\n    }\\n    int scoreOfParentheses(string s) {\\n        return helper(s,0,s.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019616,
                "title": "100-fastest-solution-constant-space-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n=s.size(),ans=0;\\n        int d=0,i=0;\\n        while(i<n) {\\n            if(s[i]==\\'(\\') d++;\\n            else {\\n                d--;\\n                if(i>0 && s[i-1]==\\'(\\') ans+=1<<d;\\n                }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858474,
                "title": "cpp-solution-runtime-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n     stack<pair<int,char>>st1; //this stack is used for the follow the \\'(\\'\\n       stack<pair<int,int>>st2;// this stack is used for the  count the score of a where  the string is \"(a)\".\\n        for(int i=0; i<s.length(); ){\\n            if(st1.empty()){\\n                st1.push({i,\\'(\\'});\\n                i++;\\n            }else{\\n                if(s[i] == \\')\\'){\\n                    \\n                    while(!st1.empty() && i < s.length() && s[i] == \\')\\'){\\n                       if(st2.empty()){\\n                           st2.push({1,st1.top().first});\\n                           st1.pop(); \\n                           i++;\\n                       }else{\\n                           int res = 0;\\n                           \\n                           while(!st2.empty() && st2.top().second > st1.top().first){ \\n\\t\\t\\t\\t\\t\\t   // here is the main idea if you understand above condition \\n\\t\\t\\t\\t\\t\\t   // then you will be able  to understand whole code.\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t   // here i basically do the thing that while(curr = st1.top().first) \\n\\t\\t\\t\\t\\t\\t   //means current index of \\'(\\'   is smaller than the st2.top().first\\n\\t\\t\\t\\t\\t\\t   //we remove the element from the st2 and take the total sum\\n\\t\\t\\t\\t\\t\\t   //of all popped elements  \\n\\t\\t\\n\\t\\t\\n\\t\\t\\t\\t\\t\\n                               res += st2.top().first;\\n                               st2.pop();\\n                               \\n                           }\\n                           if(res != 0)\\n                           st2.push({2*res,st1.top().first});\\n                           else\\n                               st2.push({1,st1.top().first});\\n                           st1.pop();\\n                           i++;\\n                       }\\n                    }\\n                }else{\\n                    st1.push({i,\\'(\\'});\\n                    i++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        while(!st2.empty()){\\n            res += st2.top().first;\\n            st2.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858163,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }\\n            else{\\n                d--;\\n                if(s[i-1]==\\'(\\')\\n                    result+=pow(2,d);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int result=0,d=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                d++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857834,
                "title": "easy-c-100-faster-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n       \\n        int count=0;//for opening parentheses count\\n        int rcount=0;//for closing parentheses count\\n        int ans=0;\\n        int i=0;//for iterating over string s\\n        while(i<s.size()){\\n            if(s[i]==\\'(\\'){ //counting opening bracket\\n                count++;\\n                i++;\\n            }\\n            else { // if closing bracket then count it in rcount, think of case. (()((())))\\n                while(s[i]==\\')\\'){\\n                    rcount++;\\n                    i++;\\n                }\\n                ans+=pow(2,count-1); //(A)--> 2*A  , see in question explanation\\n                count-=rcount; //if count==rcount, both equal and counted in answer and if count!=rcount,we will do the operations for rcount only\\n                rcount=0;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857674,
                "title": "python-stack-simplest-solution",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for ch in s:\\n            if ch == \\')\\':\\n\\t\\t\\t\\t# If ch is \\')\\' then calculate the score till previous \\'(\\' as per the formula and append the score into stack.\\n                score = 0\\n                while stack and stack[-1] != \\'(\\':\\n                    score += stack.pop()\\n                if stack and stack[-1] == \\'(\\':\\n                    stack.pop()\\n                stack.append(2*score if score > 0 else 1)\\n            else:\\n\\t\\t\\t\\t# If ch is \\'(\\' then simple put it into stack\\n                stack.append(ch)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857442,
                "title": "score-of-parentheses-t-c-o-n-s-c-o-1",
                "content": "() maximum depth is 0. hence 2^0 will result as 1.\\n()() maximum depth is 0, and is occuring twice, hence (2^0) + (2^0) = 2;\\n(()()) maximum depth is 1, and is occuring twice, hence (2^1) + (2^1) = 4;\\n(()) maximum depth is 1, and is occuring once, hence (2^1) = 2;\\nin same manner the below code is implemented.\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote the solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int d = 1; // Varibale d measures the depth of the current parenteses.\\n        int ans = 0; // ans stores the total score of the parentheses, till the current parentheses.\\n        int n = s.size();\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (s[i] == \\'(\\')  // Increment the depth whenever you encounter a opening bracket.\\n                d++;\\n            else  // Decrement the depth whenever you encounter a closing bracket.\\n                d--;\\n            if (s[i] == \\')\\' && s[i - 1] == \\'(\\') whenever this condition satisfy. get the score by 2 power the depth.\\n                ans += pow(2, d);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856716,
                "title": "c-0ms-better-then-100-cpp-solution",
                "content": "# Please Upvote if tou find this helpfull\\n![image](https://assets.leetcode.com/users/images/a73b9a52-854b-4c00-832e-d05db3e803c6_1647489700.5493279.png)\\n```\\nclass Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint temp=0;\\n\\t\\t\\t\\t\\twhile(!st.empty() && st.top()!=0){\\n\\t\\t\\t\\t\\t\\ttemp+=st.top();\\n\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(2*temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile(!st.empty())\\n\\t\\t{\\n\\t\\t\\tans+=st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\tint scoreOfParentheses(string s) {\\n\\t\\t  stack<int> st;\\n\\t\\tint ans=0;\\n\\t\\tfor(int i=0;i<s.length();i++){\\n\\t\\t\\tif(s[i]==\\'(\\') st.push(0);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif(st.top()==0){\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tst.push(1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1856432,
                "title": "java-using-stack",
                "content": "Approach 1: Using Stack\\n```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\\n\\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\\n\\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\\n\\nApproach 2: Without additional data structure O(1) memory\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n       Stack<Integer> stack = new Stack<>();\\n        int score = 0;\\n        for(char c: s.toCharArray()){\\n            if(c == \\'(\\'){\\n                // when you encounter a opening paranthesis you add current score to stack to be popped in future to calculate score with its pair closing paranthesis\\n\\t\\t\\t\\tstack.push(score);\\n\\t\\t\\t\\t// reset score here for next open paranthesis\\n                score = 0;\\n            }else{\\n\\t\\t\\t// when ever you meet a closing parantheses score will be updated\\n                score = stack.pop() + Math.max(2*score,1);\\n            }\\n        }\\n    return score;\\n    }\\n}\\n```\n```\\nExample 1 : ()\\n\\nstep 1 : 0 // current score will be pushed to stack at initial if\\nstep 2: In else block score will be updated as score = 0 + max(2*0 + 1) = 1\\nnote : in else block you need to get max of 2*(count of open parantheses encounter sofar until you find a closing)  + 1(minimum score for a pair of () )\\n```\n```\\nExample 2 : ()()\\nstep 1: 0 // for initial opening stack will be pushed with current score\\nstep 2: score will be updated as score = 0 + max(2*0,1) = 1 // for the first pair encountered sofar ()\\nstep 3: 1 // current score will be pushed to stack for second opening and score will be reset to 0\\nstep 4: score will be updated as score  = 1 + max(2*0,1) = 1 + 1 = 2\\n\\nNote : In case of adjacent valid pairs AB = A + B stack.pop() will always give calculated score sofar  and max(2*score,1) will give score for current closing paranthesis. It is important to reset score after pushing to stack because for every new opening score should start with 0\\n\\n```\n```\\nExample 3 : (())\\nstep 1: 0 // current stack\\nstep 2: 0 0 // updated stack for second opening paranthesis\\nstep 3: calculate score = 0 + max(2*0,1) = 0 + 1 = 1 (which is for inside nested pair ())\\nstep 4 : calculate score = 0 + max(2*1,1) = 0 + 2 = 2 (which is for outer pair 2*(score of innner pair 1))\\n\\nNote : In case of nested pairs max(2*current_score,1) will provide multiplication factor for nested pairs\\n\\nsimilary \\nif you have nested at 3 (2*(2*(1))) levels score = 2*(2*(1))  = 4\\nif you have nested at 4 (2*(2*(2*(1)))) levels score = 2*(2*(2*(1)))  = 8\\n\\n```\n```\\npublic int scoreOfParentheses(String S) {\\n    int score = 0;\\n    int depth = 0;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            depth++;\\n        } else {\\n            depth--;\\n        }\\n\\n        if (s.charAt(i) == \\')\\' && s.charAt(i - 1) == \\'(\\') {\\n            // Whenever you meet a () pair, you multiply 1 by all the 2 outside of it, and accumulate the result\\n            score += Math.pow(2, depth);\\n        }\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818803,
                "title": "easy-based-solution-c-fcuk-u",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }\\n            else if(x[i]==\\')\\')\\n            {\\n                //here we make two cases of simple and complex \\n                if(s.top()==0)\\n                {\\n                    //simple ()\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    //for complex case\\n                    int ans=0;\\n                    while(s.top()!=0)\\n                    {\\n                        ans=ans+s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*ans);\\n                }\\n            }\\n                \\n        }\\n        int count=0;\\n        while(!s.empty())\\n        {\\n            count=count+s.top();\\n            s.pop();\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string x) {\\n        stack<int>s;\\n        //here we are putting these scores in here eyou can see\\n        for(int i=0;i<x.length();i++)\\n        {\\n            if(x[i]==\\'(\\')\\n            {\\n                s.push(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1496748,
                "title": "o-n-solution",
                "content": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }\\n            else{\\n                cur=st.pop()+Math.max(2*cur,1);\\n            }\\n        }\\n        return cur;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n    int cur=0;\\n        Stack<Integer> st=new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'(\\'){\\n                st.push(cur);\\n                cur=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487703,
                "title": "cpp-using-stack-o-n",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                     val=0;\\n                    while(!s.empty()&&s.top()!=-1)\\n                    {\\n                        val+=s.top();\\n                        s.pop();\\n                    }\\n                    s.pop();\\n                    s.push(2*val);\\n                }\\n            }\\n        }\\n        val=0;\\n        while(!s.empty())\\n        {\\n            val+=s.top();\\n            s.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string st) {\\n        stack<int> s;\\n        int val=0;\\n        for(int i=0;i<st.length();i++)\\n        {\\n            if(st[i]==\\'(\\')\\n                s.push(-1);\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1219205,
                "title": "100-faster-intuitive-recursive-solution-with-proper-comments",
                "content": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    int scoreOfParentheses(string s) \\n    {\\n        unordered_map<int,int> map;  //key will be index of \\'(\\' and value will be index of corresponding closing bracket\\n        stack<int> stack; //stack will be used to find index of \\')\\' corresponding to each \\'(\\'\\n        int n=s.length();\\n        \\n        for(int i=0;i<n;i++)  // fill entries in map(preprocessing)\\n        {\\n            if(s[i]==\\'(\\')\\n                stack.push(i);\\n            else\\n            {\\n                int ind=stack.top();\\n                stack.pop();\\n                map[ind]=i;\\n            }\\n                \\n        }\\n        \\n        return score(0,n-1,map); //calling recursive function to calculate score for whole expression\\n    }\\n\\t\\n\\tint score(int start,int end,unordered_map<int,int> map)\\n    {\\n        \\n        if(start+1==end and map[start]==end) // if \\'(\\' and \\')\\' are adjacent like \"()\"\\n        {\\n            return 1;\\n        }\\n        else if(map[start]==end) // if \\')\\' corresponding to first \\'(\\' is at last index like \"(..........)\"\\n            return 2*score(start+1,end-1,map);\\n        else\\n            return score(start,map[start],map)+score(map[start]+1,end,map); //case where \"()()\" \\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081334,
                "title": "score-of-parentheses-easy-to-understand-explanation-javascript-code",
                "content": "Initially I read this and it seemed quite easy.  However once I tried to implement it, I was caught up in odd recursive calls which sometimes worked, and others didn\\'t.  After passing my 30minute self timer I gave up and went to the solution.  Even understanding that was a challenge so I will attempt to improve on the solution explanation.\\n\\nOk, one way to think of this problem is in the number of \\'()\\' or cores.  I dont mean nesting, I mean the literal \\'()\\'.  The answer is the sum of those values.  The nesting only serves to double their value.  So, no need to do a recursive call, or even use a stack.  \\n\\nHow can we do this in a linear fashion?  Ok, loop though your string.  Every time u notice a (, you increment your depth counter.  If the current char is not a (, it must be a ).  Now you have two possibilities, the previous char could have been a (, in which case, u\\'ve got a core (), so add its value to the score (more on the calc later, see next paragraph).  Or the previous character could have been another ), ie )).  In that case u don\\'t have a core, but you still need to decrement the nesting level, which previously you had incremented on a prior iteration of seeing (.  \\n\\nRegarding that core value.  What is it?  Well check how many levels it is nested and double its value that many times.  So (()) would be 1*2^depth or using a bitwise operator, 1 shifted 1 place, so 1 << 1 = 2  \\n\\nIn summary: The trick is to evaluate each \\'core\\' as you encounter it, adding its value to the score. For it\\'s score, you\\'ll keep track of how deep the nesting is, sometimes decrementing the nesting as necessary when you find closing parens.\\n\\n```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(S) {\\n  let score = 0, depth = 0;\\n  for (let i=0, j=S.length; i<j; i++) { // linear left to right iteration\\n    if (S.charAt(i) == \\'(\\')  // found ( so increment depth\\n\\t\\tdepth++;\\n    else if (S.charAt(i-1) == \\'(\\')  // found () a core, so time to add its calculated value to score\\n       score += 1 << --depth; // binary bit shift operator, doubling value by depth\\n    else \\n\\t\\t--depth; // not a core, but need to unwrap a layer of nesting\\n  }\\n  return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081212,
                "title": "score-of-parentheses-python-recursive-solution",
                "content": "The variable \"layer\" is equal to 0 when the iterator is between two balanced parentheses while not inside any parentheses.\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, S):\\n        if S == \"()\":\\n            return 1\\n        layer = 0\\n        for i in range(len(S)):\\n            if S[i] == \"(\":\\n                layer += 1\\n            elif S[i] == \")\":\\n                layer -= 1\\n                if layer == 0 and i < len(S)-1:\\n                    return self.scoreOfParentheses(S[:i+1]) + self.scoreOfParentheses(S[i+1:])\\n        return 2 * self.scoreOfParentheses(S[1:len(S)-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080627,
                "title": "score-of-parentheses-js-python-java-c-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nAny time we see a problem that describes a doubling operation and an incrementing operation, we should at least think about a potential binary solution. In this case, those are really the only two operations. Nested doubling operations means powers of **2** depending on the nesting depth, and a simple closed pair of parentheses is a **+1**.\\n\\nAt first glance, the addition operation would seem to cause a problem, but math once again comes to our aid.\\n\\nConsider the following:\\n```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\\nAs we can see, we don\\'t *really* have to wait for the summation before applying the power operation, because it will get distributed across the summation anyway. And since we know how many nested parentheses there are (**pwr**) when we finish a simple parentheses pair, we can immediately add the appropriate value to our answer (**ans**).\\n\\nThis means that we can solve this problem in **O(n) time** and **O(1) space**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor JavaScript **S.charAt(i)** is faster at processing string iteration than **S[i]**.\\n\\nWe can start our iteration at **i = 1** because we know the first character is going to be **\"(\"**. We *could* start at **i = 0**, but then we\\'d have to either start with **pwr = 1** or make sure to decrement **pwr** before the power operation instead of after.\\n\\nWe can use a **bitwise shift** for the power operation to more accurately reflect the solution\\'s binary nature.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **64ms / 38.4MB** (beats 99% / 77%).\\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **24ms / 14.0MB** (beats 96% / 90%).\\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 37.0MB** (beats 100% / 60%).\\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 5.9MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nS = \"(((()()())))\"\\n  = \"(((\" 1 + 1 + 1 \")))\"    // After replacing completed \"()\"s with 1s\\n  = (1 + 1 + 1) * 2^3        // Applying the power operations\\n  = 2^3 + 2^3 + 2^3          // Through the distributive property of multiplication\\n```\n```javascript\\nvar scoreOfParentheses = function(S) {\\n    let len = S.length, pwr = 0, ans = 0\\n    for (let i = 1; i < len; i++)\\n        if (S.charAt(i) === \"(\") pwr++\\n        else if (S.charAt(i-1) === \"(\") ans += 1 << pwr--\\n        else pwr--  \\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        pwr, ans = 0, 0\\n        for i in range(1, len(S)):\\n            if S[i] == \"(\": pwr += 1\\n            elif S[i-1] == \"(\":\\n                ans += 1 << pwr\\n                pwr -= 1\\n            else: pwr -= 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S.charAt(i) == \\'(\\') pwr++;\\n            else if (S.charAt(i-1) == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int len = S.length(), pwr = 0, ans = 0;\\n        for (int i = 1; i < len; i++)\\n            if (S[i] == \\'(\\') pwr++;\\n            else if (S[i-1] == \\'(\\') ans += 1 << pwr--;\\n            else pwr--;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070470,
                "title": "java-easy-to-understand-stack-solution",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        \\n        Stack<String> stack = new Stack<String>();\\n        for(char ch: S.toCharArray())\\n        {\\n            if(ch == \\'(\\')\\n            {\\n                stack.push(\"(\");\\n            }\\n            else\\n            {\\n                if(stack.peek().equals(\"(\"))\\n                {\\n                    stack.pop();\\n                    stack.push(\"1\");\\n                }\\n                else\\n                {\\n                    int val = 0;\\n                    while(!stack.isEmpty() && !stack.peek().equals(\"(\"))\\n                        val += Integer.parseInt(stack.pop());\\n                    val *= 2;\\n                    stack.pop();\\n                    stack.push(String.valueOf(val));\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans = 0;\\n        while(!stack.isEmpty())\\n        {\\n            \\n            ans += Integer.parseInt(stack.pop());\\n            \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906001,
                "title": "c-o-n-solution-beats-100-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/score-of-parentheses/submissions/\\n    \\n    Since the scoring happens based on the nested braces, we need a way\\n    to know the level of nested braces. To indicate each nested level we\\n    use 0 when a \\'(\\' is encountered. Then everytime we get a \\')\\', we find \\n    the total score between the start of the \\'(\\' and current \\')\\', \\n    use the rule 2 * A and push the result back.\\n    \\n    Eg: ()()\\n    ( Stack: 0,\\n    ) Stack: 1,\\n    ( Stack: 1, 0\\n    ) Stack: 1, 1\\n    \\n    Final: 1 + 1 = 2\\n    \\n    TC: O(N)\\n    SC: O(N)\\n*/\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int total = 0;\\n        int curr_score = 0;\\n        \\n        stack<int> vals;\\n        \\n        for(char &c: s) {\\n            // opening bracket\\n            if(c == \\'(\\') { \\n                vals.emplace(0);\\n            }\\n            else {\\n                int curr_val = 0;\\n                // find the total sum\\n                while(vals.top() != 0) {\\n                    curr_val += vals.top();\\n                    vals.pop(); \\n                }\\n                // remove score for the opening brace of current )\\n                vals.pop();\\n                // assign score based on whether the current \\n                // closing brace has enclosed brace \\n                curr_val = curr_val == 0 ? 1 : 2 * curr_val;\\n                vals.emplace(curr_val);\\n            }\\n        }\\n        // final score is sum of all remaining brace scores\\n        while(!vals.empty()) {\\n            total += vals.top();\\n            vals.pop();\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877174,
                "title": "python-stack-o-n-explanations",
                "content": "The solution is below. The intuition follows.\\n\\n```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```\\n\\nIntuition: \\nFor every character in S:\\n- if it\\'s an `(` push 0 to the stack\\n- If it\\'s an `)`:\\n\\t- `pop` and `sum` all values of the stack unitl reaching `0` which corresponds to the open `(`\\n\\t- if the `sum = 0`, this means we\\'re in the case `()`, then push `1` to the stack\\n\\t- if the `sum > 0`, this means we\\'re in the case `(A)`, then push `2 * sum` to the stack\\n- Finally, return the `sum` of all remaining values of the stack\\n\\nComplexity Analysis:\\n\\t- Time Complexity: `O(n)`\\n\\t- Space Complexity: `O(n/2) = O(n)`\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef scoreOfParentheses(self, S: str) -> int:\\n                \\n        stack = []\\n        for p in S:\\n            if p == \\'(\\':\\n                stack.append(0)\\n            \\n            else:\\n                score = 0\\n                while stack[-1]:       # case AB: score(A) + score(B)\\n                    score += stack[-1]\\n                    stack.pop()\\n                stack.pop() # pop 0 that corresponds to \\'(\\'\\n                stack.append(2 * score if score else 1) # if score = 0 => case: \"()\" if score>0 => case \"(A)\"\\n              \\n        return sum(stack)\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 750647,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        int t = 0;\\n        int res = 0;\\n        for (int i = 0; i < S.length() - 1; i++) {\\n            if (S[i] == \\'(\\') {\\n                t++;\\n                if (S[i + 1] == \\')\\') {\\n                    res += pow(2, t - 1);\\n                }\\n            } else {\\n                t--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740991,
                "title": "c-0ms-runtime-100-using-stack-14-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int>stackk;\\n        int result=0;\\n        for(int i=0;i<S.size();i++){\\n            if(S[i]==\\'(\\'){stackk.push(0);}\\n            else{\\n                int score = (stackk.top()==0)? 1 : stackk.top();\\n                stackk.pop();\\n                if(stackk.empty()){result+=score;}\\n                else{stackk.top() += 2*score;}\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630695,
                "title": "java-4-lines-recursive",
                "content": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int i = 0;\\n    public int scoreOfParentheses(String S) {\\n\\n        int k = 0;\\n        while ( i < S.length()) {\\n            if (S.charAt(i++) == \\')\\')\\n                return k == 0 ? 1 : k;\\n            k += 2 * scoreOfParentheses(S);\\n        }\\n        return k/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581799,
                "title": "java-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        return helper(S, 0, S.length()-1);\\n        \\n    }\\n    \\n    public int helper(String S, int l, int r){\\n        if(r-l == 1) return 1;\\n        \\n        int count = 0;\\n        for(int i = l; i < r; i++){\\n            \\n            if (S.charAt(i) == \\'(\\') count++;\\n            if (S.charAt(i) == \\')\\') count--;\\n            \\n            if (count == 0){\\n                return helper(S, l, i) + helper(S, i+1, r);\\n            }\\n        }\\n        \\n        return 2 * helper(S, l+1, r-1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522559,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        vector<pair<char, int>> stack;\\n        int sum = 0, score;\\n        for(int i = 0; i < S.size(); i++){\\n            if(stack.empty() || S[i] == \\'(\\'){\\n                stack.push_back(make_pair(S[i], 0));\\n            }\\n            else{ //S is valid so S[i] == \\')\\' and stack.back().first == \\'(\\'\\n                score = stack.back().second * 2;\\n                score = score == 0? 1 : score;\\n                stack.pop_back();\\n                if(stack.empty()){\\n                    sum += score;\\n                }\\n                else{ //S is valid so stack.back().fist ==\\'(\\'\\n                    stack.back().second += score;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442398,
                "title": "c-0ms-solution",
                "content": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\nimplemented using stack . \\nPlease tell if you find any error in this approach",
                "solutionTags": [],
                "code": "````\\n#include<bits/stdc++.h>\\n#define FOR(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\\n#define RFOR(i,a,b) for(long long i = (long long)(a); i >= (long long)(b); i--)\\n#define MIN3(a,b,c) (a)<(b)?((a)<(c)?(a):(c)):((b)<(c)?(b):(c))\\n#define MAX(a,b) (a)>(b)?(a):(b)\\n#define MIN2(a,b) (a)<(b)?(a):(b)\\nusing namespace std;\\ntypedef pair<int, int> ii;\\ntypedef pair<int, ii> iii;\\ntypedef vector<ii> vii;\\ntypedef vector<int> vi;\\ntypedef long long ll;\\n#define ull unsigned long long\\ntypedef long double ld;\\ntypedef vector<ll> vll;\\ntypedef pair<ll,ll> lll;\\n#define deb(x )     cerr << #x << \" here \"<< x << endl;\\n#define endl    \"\\\\n\"\\n#define printCase() \"Case #\" << caseNum << \": \"\\ninline bool is_palindrome(const string& s){ return std::equal(s.begin(), s.end(), s.rbegin()); }\\nconst ll MOD = 1000000007;\\nconst ll INF = 1e9+5;\\nconst double eps = 1e-7;\\nconst double PI = acos(-1.0);\\n#define coud(a,d) cout << fixed << showpoint << setprecision(d) << a;\\ninline void debug_vi(vi a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\ninline void debug_vll(vll a) {FOR(i, 0, a.size()) cout<<a[i]<<\" \";}\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string S) {\\n        stack<int> st;\\n        int cnt = 0;\\n        // ) = 0  ( = -1\\n        FOR(i,0,S.length()) {\\n            if(S[i] == \\')\\') {\\n                int a = st.top();\\n                st.pop();\\n                int n = 0;\\n                while(a != 0) {\\n                    n+=a;\\n                    a = st.top();\\n                    st.pop();\\n                }\\n                st.push(n== 0?1:2*n);\\n            } else {\\n                st.push(0);\\n            }\\n        }\\n        int n = 0;\\n        while(!st.empty()) {\\n            n+=st.top();\\n            st.pop();\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 263080,
                "title": "javascript-recursive-solution",
                "content": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nconst scoreOfParentheses = (S) => {\\n    if (S === \\'()\\') return 1;\\n    \\n    const stack = [], parts = [];\\n    let part = \\'\\';\\n    for (const char of S) {\\n        part += char;\\n        if (char === \\'(\\') {\\n            stack.push(0);\\n        } else {\\n            stack.pop();\\n            if (stack.length === 0) {\\n                parts.push(part);\\n                part = \\'\\';\\n            }\\n        }\\n    }\\n    if (parts.length === 1) {\\n        return scoreOfParentheses(S.slice(1, S.length - 1)) * 2;\\n    }\\n    return parts.reduce((prev, item) => prev + scoreOfParentheses(item), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 150131,
                "title": "java-solution-o-1-space-o-n-time",
                "content": "The key is to recognize that we only add to result when a \\')\\' is found right after a \\'(\\'. Use an interger to keep track of how much we should add to result when a \"()\" pattern is found.\\n\\n```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int scoreOfParentheses(String S) {\\n    int mult = 0, res = 0;  //Multiplier determines how much should be added to result when a \"()\" is found\\n    for (int i = 0; i < S.length(); i++){\\n        if (S.charAt(i)==\\'(\\'){\\n            mult+=mult==0?1:mult;\\n        }else{\\n            if (S.charAt(i-1)==\\'(\\'){\\n                res+=mult;\\n            }\\n            mult/=2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142048,
                "title": "python-o-n-solution-with-explanation",
                "content": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "solutionTags": [],
                "code": "Each element or collection of elements in the string can be considered a primitive or an object. Primitives are single elements `(` or `)` while objects are constructs that can be created out of primitives, such as `(())` or `()()`. By keeping track of the score of objects as we traverse the string, the total score can be computed easily.\\n\\nThe stack contains tuples of the form `(x, y)` where `x` is a boolean indicating whether the item is a primitive or object and `y` is an integer describing the primitive/object\\'s score.\\n* When encountering `(`, we push `(` onto the stack as a primitive with score 0\\n* When encountering `)`, there are two cases: the `)` either (1) the closes a `(` primitive or (2) encompasses an object or series of objects that contains a `(` in the beginning. For (1), we can construct an object `()` with score `1` and push it onto the stack. For (2), we can compute the score of the series of objects, multiply it by two when we discover a `(`, then push the newly formed object onto the stack.\\n\\nIn the end, the stack will contain a series of objects since all primitives will have turned into objects. Therefore, we can simply compute the score of all objects, which is the result.\\n\\n    def scoreOfParentheses(self, S):\\n        stack = []\\n        res = 0\\n        \\n        for c in S:\\n            if c == \\'(\\':\\n                stack.append((False, 0))\\n            if c == \\')\\':\\n                obj, new_score = stack.pop()\\n                if obj:\\n                    while obj:\\n                        obj, score = stack.pop()\\n                        new_score += score\\n                    stack.append((True, new_score * 2))\\n                else:\\n                    stack.append((True, 1))\\n\\n        while stack:\\n            obj, score = stack.pop()\\n            res += score\\n        \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 141865,
                "title": "short-java-solution",
                "content": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int scoreOfParentheses(String S) {\\n        int ans = 0, depth = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            depth += S.charAt(i) == \\'(\\' ? 1 : -1;\\n            if (S.charAt(i) == \\'(\\' && S.charAt(i + 1) == \\')\\') ans += 1 << (depth - 1); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141804,
                "title": "java-o-n-one-pass-non-recursive-using-stack",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String S) {\\n        int[] sum = new int[S.length() * 2];\\n        int top = 0;\\n        for (int i = 0; i < S.length(); i++) {\\n            if (S.charAt(i) == \\'(\\') {\\n                sum[++top] = 0;\\n            } else {\\n                sum[top - 1] += (S.charAt(i - 1) == \\'(\\' ? 1 : 2 * sum[top]);\\n                top--;\\n            }\\n        }\\n        return sum[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141803,
                "title": "no-3-4-liners-easily-understood-c-recursive-solution-with-explanation",
                "content": "No Hard feelings against 3-4 liners. But I just feel that its sometimes too difficult to come up with 3-4 lines of optimal solution during an actual interview :)\\n\\nThe idea is simple. Once you encounter a \\'(\\', you check whether the next element is \\')\\'. If it is, then you add 1 to the current result, else you recursively calculate the inner parentheses pattern value and multiply it by 2 and add to the current result.\\nSince we are using C++, so we can use pass by reference for index. \\nPlease do let me know if solution can be optimized further.\\n\\n```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int util(string& S,int& index){\\n        int result = 0;\\n        while(index < S.length()){\\n            if(S[index] == \\')\\') return result;\\n            else{\\n                if(S[index + 1] == \\')\\'){\\n                    result += 1;\\n                    index++;\\n                }\\n                else result += 2*util(S,++index);\\n            }\\n            index++;\\n        }\\n        return result;\\n    }\\n    \\n    int scoreOfParentheses(string S) {\\n        int n = S.length();\\n        if(n == 2) return 1;\\n        int index = 0;\\n        return util(S,index);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011105,
                "title": "very-easy-soln-stack-greedy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        # Initialize an empty stack to keep track of scores\\n        st = []\\n        # Initialize a variable to store the final result\\n        res = 0\\n        \\n        # Iterate through each character in the input string \\'s\\'\\n        for i in s:\\n            if i == \"(\":\\n                # When an opening parenthesis is encountered, push the current result onto the stack\\n                st.append(res)\\n                # Reset the current result to 0\\n                res = 0\\n            else:\\n                # When a closing parenthesis is encountered, pop the last result from the stack\\n                popd = st.pop()\\n                # Calculate the new result for the current parenthesis pair and update \\'res\\'\\n                res = popd + max(2 * res, 1)\\n        \\n        # The final \\'res\\' will contain the score of the entire expression\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005820,
                "title": "simple-cpp-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans = 0;\\n\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'(\\')st.push(-1);\\n            if(s[i]==\\')\\'){\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    int temp = 0;\\n                    while(st.top()!=-1){\\n                        temp+=st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*temp);\\n                }\\n            }\\n        }\\n\\n        while(st.size()){ans+=st.top(); st.pop();}\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756768,
                "title": "c-beats-100-recursive-simple-beginner-solution-commented",
                "content": "\\n# Approach\\nThink it as :- If we encounter a \\'(\\', then we see next char to it , if the next char is \\')\\' ,then we simply add 1 to ans ,else we call recursively to the next index and multiply the recursive sub-solution with 2.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(string &s,int &i)\\n    {\\n        int ans=0;\\n        while(i<s.size() && s[i]!=\\')\\')\\n        {\\n            // if we have entered the loop => s[i]==\\'(\\' , now look for next char, so i++;\\n            i++;\\n            if(s[i]==\\')\\')  // now if next char is \\')\\' , => we got one pair so ans++;  \\n            ans++;\\n            else // if next char is \\'(\\' then we call recursion to i and multiply the recursive  \\n            ans += 2*solve(s,i);    //sub-solution with 2 , as per the rule of problem\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n    int scoreOfParentheses(string s) {\\n        int i=0;\\n        return solve(s,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643447,
                "title": "easy-to-understand-stack-c-solution",
                "content": "# Intuition\\nWhenever we see a parenthesis problem first intuition is using stacks.\\nThis is a special problem as here we have to carry the previous scores of the closed parenthesis.\\nThe code written below is a true beauty.\\nU will easily understand the logic behind it however it took time to come this solution on paper using many Testcases.\\n Below is the most beautiful line which reinitialise score as 0 .\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nUsing s.top() is understood but max function is used because score is being calculated inside which can be at times 0 so in that case we add to s.top(). rest applies to the condition\\n (()()\\')\\'\\nthis bracket is used for multiplication only.\\n\\nBasically every ( is carying the past scores in the stack and reinstatting its own score =0;\\n\\nupvote if you find it helpful !\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n\\n        stack<char> s;\\n        int n=str.size();\\n        int score=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            if(str[i]==\\'(\\'){\\n\\n                s.push(score);\\n                score=0;\\n\\n            }\\n\\n            else{\\n\\n                score=s.top()+max(2*score,1);\\n                s.pop();\\n            }\\n\\n        }\\n\\n\\n        return score;\\n\\n       \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338104,
                "title": "very-simple-java-solution-beats-100-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        \\n        // instead of calculating like 2*(2*(1+1)+1). calculating like : 4*1 + 4*1 + 2*1\\n        int mul = 1;\\n        int add = 0;\\n        int ans = 0;\\n\\n        for(int i=0;i<s.length();i++){\\n\\n            char ch = s.charAt(i);\\n\\n            // keeping track of depth\\n            if(ch==\\'(\\' && s.charAt(i+1)==\\'(\\') mul *=2;  // for each nesting having a multiplier 2\\n\\n            else if(ch==\\'(\\' && s.charAt(i+1)==\\')\\'){\\n                add++;\\n                ans += add*mul;         // seperatly calculating the score\\n                add = 0;\\n                i++;\\n            }else if(ch==\\')\\'){\\n                mul /= 2;           // moving out of a nesting\\n            }\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217612,
                "title": "python-96-faster-easy-sliding-window",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        a,n=[],len(s)\\n        c=t=0\\n        for i in range(1,n):\\n            if s[i]==\\'(\\':\\n                t+=1\\n            elif s[i-1]==\\'(\\':\\n                c+=1<<t\\n                t-=1\\n            else:\\n                t-=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019659,
                "title": "use-stack-to-store-intermediate-values-as-well-push-1-when-you-see",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int n = s.length();\\n        stack<int> st;\\n        int res = 0;\\n        bool f = false;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(-1);\\n            }\\n            else\\n            {\\n                int temp=0;\\n                while(!st.empty() && st.top()>-1)\\n                {\\n                    temp+=st.top();\\n                    st.pop();\\n                    f=1;\\n                }\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    if(!f){\\n                        st.pop();\\n                        st.push(1);\\n                    }\\n                    else\\n                    {\\n                        f=0;\\n                        st.pop();\\n                        st.push(temp*2);\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            if(st.top()!=-1)\\n                res+=st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959716,
                "title": "c-runtime-beats-100-using-stack-basics",
                "content": "**856. Score of Parentheses \\u23E9 An implementation problem**\\n\\nIf `s[i]==\\'(\\'` we will push it in stack as something to add to score has come.\\nif `s[i]==\\')\\'` now is the time to increment our score by factor ***k*** because it is time for this balanced bracket to leave. \\n\\n**Q.** How much should ***k*** be?\\n**Ans:** If `(((` is a sequence and a `)` comes, we can see that ( ( **( )** the bold balanced-bracket comes after 2 continuous brackets and it is given that `(A) = 2*A`. \\nTherefore, here `((()` will be `2*2*1` as `()` = 1 Or we can see this as `2^(size_of_stack-1)`, hence ***k*** = `pow(2,size_of_stack-1)`.\\n**Then we stop adding scores for upcoming continuous `)` brackets as obviously they are already included in `2^x`**.\\n\\nNote: Approach is very simple, but if you find the explanation unclear, kindly go through the code and dry-run for `s = \"(())((())())\"` and you\\'ll understand it. \\n\\nSome examples:\\n```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\\n\\n\\nTime: **O(N)** \\nSpace: **O(N)** \\n\\n**`C++ CODE` \\u2B07**\\n\\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```\\n\\n**UPVOTE if you like \\uD83D\\uDE07, feel free to ask doubts, I\\'ll try to reply asap.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n* ()() => 1+1\\n* (()()) => 2*(1+1)\\n* ((()())) => 2*2*(1+1)\\n* ((()(()))) => 2*2*(1+2*1)\\n```\n```\\nint scoreOfParentheses(string s) {\\n        stack<char>st;\\n        int score=0;\\n        bool addScore=false;\\n        for(int i=0;i<s.size();i++){\\n            int sz = st.size()-1;\\n            if(s[i]==\\')\\'){\\n                if(addScore) \\n                    score+=pow(2,sz), addScore=false;\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n                addScore=true;\\n            }\\n        }\\n        return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704363,
                "title": "javascript-most-intuitive-solution",
                "content": "I think it\\'s much more intuitive solution than others, also Larry from video below\\nwas able to come up with it on spot which partly proves that it\\'s more intuitive, \\nthe easiest way to understand it is to dry run this test case:\\n\\'(()()())\\'\\nEsentially we push \\'(\\' if there is opening brackets and we calculate current sum if there is closing bracket, \\ncurrent sum might be spread across many groups, so we need to loop till we find previous opening bracket which we also going to \\npop as we found closing bracket to that particular opening bracket.\\n\\nFull explaination:\\nhttps://www.youtube.com/watch?v=QM7YYNFcgAU\\n\\n```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n  const stack = []  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      const curr = s[i]\\n      \\n      if(curr===\\'(\\') {\\n          stack.push(\\'(\\')\\n          continue\\n      }\\n      \\n      let currSum = 0\\n      while(stack.length && stack[stack.length-1] !== \\'(\\') {\\n         currSum += stack.pop()\\n      }\\n      \\n      stack.pop()\\n      \\n      if(currSum===0) {\\n          stack.push(1)\\n      } else {\\n          stack.push(2*currSum)\\n      }\\n  }\\n    \\n    return stack.reduce((a,b) => a+b,0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682015,
                "title": "c-solution",
                "content": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```\\npublic int ScoreOfParentheses(string s) {\\n\\tStack<int> stack = new Stack<int>();\\n\\tint score = 0;\\n\\tchar[] chars = s.ToCharArray();\\n\\tforeach(char c in chars)\\n\\t{\\n\\t\\tint val = 0;\\n\\t\\tif (c == \\'(\\') stack.Push(0);\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\t// calculate\\n\\t\\t\\twhile (stack.Peek() != 0) val = val + stack.Pop();\\n\\t\\t\\tval = Math.Max(2 * val, 1);\\n\\t\\t\\tstack.Pop();\\n\\t\\t\\tstack.Push(val);\\n\\t\\t}\\n\\t}\\n\\twhile(stack.Count > 0)\\n\\t\\tscore = score + stack.Pop();\\n\\treturn score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664560,
                "title": "python-solution-explained-line-by-line",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL, THANKS !!**\\n**AND FREELY ASK YOUR DOUBTS** \\uD83C\\uDF3A",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int: \\n        st=[] #stack declared\\n        \\n        for i in s:\\n            #if ( is found put in stack\\n            if i==\\'(\\': \\n                st.append(i)\\n                \\n            #if ) is found \\n            elif i==\\')\\': \\n                \\n                #and stack top is opening bracket then need to enter the score 1\\n                #as said in question => \"()\" has score 1\\n                if st[-1]==\\'(\\': \\n                    st.pop()\\n                    st.append(1)\\n                \\n                #but if opening bracket is not found in st then there must me score numbers\\n                #are present in above opening bracket => 2nd rule (check in ques)\\n                #eg: st=[(,(,1,1,1,)] , closing bracket in st only for understanding, we are not really append it\\n                else:\\n                    #calculate the score till the opening bracket found\\n                    score=0\\n                    while st[-1]!=\\'(\\':\\n                        score+=st.pop()\\n                        \\n                    #so pop the opening bracket as we have calculated the score above it and \\n                    #now we have reached the 3rd rule => (A) has score 2 * A\\n                    #eg: st=[(,(,3,)] , closing bracket in st only for understanding, we are not really append it\\n                    st.pop()\\n                    st.append(2*score)\\n                    \\n        #return total sum of numbers present in st\\n        return sum(st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639620,
                "title": "c-o-n-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.push(count);\\n                }\\n                else \\n                {\\n                    int count=0;\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(count*2);\\n                }\\n            }\\n            \\n        }\\n        int res=0;\\n        while(!st.empty()){\\n            res+=(int)st.top();st.pop();}\\n        return(res);\\n    }\\n};\\nWe simply assume \\'(\\' to be -1 and make a stack of integers and simply follow the instructions given in the question.",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;int c=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(-1);\\n            else\\n            {\\n                if(!st.empty() && st.top()==-1)\\n                {\\n                    int count=1;\\n                    st.pop();\\n                    while(!st.empty() && st.top()!=-1)\\n                    {\\n                        count=count+st.top();\\n                        st.pop();\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2603270,
                "title": "easy-javascript-solution",
                "content": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar scoreOfParentheses = function(s) {\\n    let stack = [0];\\n    \\n    for (let el of s) {\\n        if (el === \\'(\\') stack.push(0);\\n        \\n        else {\\n            let popped = stack.pop();\\n            \\n            if (popped === 0) stack[stack.length - 1] += 1;\\n            else {\\n                popped *= 2;\\n                stack[stack.length - 1] += popped;\\n            }\\n        }\\n    }\\n    \\n    return stack[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522600,
                "title": "c-100-fastest-easy-solution",
                "content": "Push -1 for \\'(\\' and push the value of corresponding balanced paranthesis string when you encounter \\')\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        \\n        for(char c:s)\\n        {\\n            if(c==\\'(\\')\\n            st.push(-1);\\n            else\\n            {\\n                int x=0;\\n                while(st.size() and st.top()>0) // pop all numbers stored and store sum in x\\n                {\\n                    x+=st.top();\\n                    st.pop();\\n                }\\n                st.pop(); // pop the \\'(\\' char\\n                if(x==0) // if there was no number push 1 [for simple () ]\\n                st.push(1);\\n                else\\n                st.push(x*2); // else push total value * 2\\n            }\\n        }\\n        int ans=0;\\n        while(st.size()) //  sum all the remaining numbers and return sum\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457022,
                "title": "java-solution-stack",
                "content": "```java \\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }\\n        }\\n        int score=0;\\n        while(!st.isEmpty()){\\n            score+=st.pop();\\n        }\\n        return score;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int a = 0;\\n                while(st.peek()!=0)\\n                    a+=st.pop();\\n                st.pop();\\n                st.push(Math.max(1,2*a));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2366247,
                "title": "easy-gredy-without-stack-o-n",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        \\n        level = 0\\n        result = 0\\n        prev = \"\"\\n        \\n        for c in s:           \\n            if c == \"(\":\\n                level += 1\\n            if c == \")\":\\n                if prev == \"(\":\\n                    result += 2 ** (level - 1)\\n                level -= 1                \\n            prev = c\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347385,
                "title": "c-iterative-stack-solution",
                "content": "(i) for a single opening brace, push score 0\\n(ii) if we found a closing brace then caluculate the score and push the curr score into the stack\\n(iii) at the end sum up all the scores and return \\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans =0;\\n        for(char c : s){\\n            int curr = 0;\\n            if(c == \\'(\\') st.push(0);\\n            else{\\n                while(st.top() != 0){\\n                    curr += st.top();\\n                    st.pop();\\n                }\\n                curr = max(curr*2,1);\\n                st.pop();\\n                st.push(curr);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322146,
                "title": "c-stack-o-n-time-complexity",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        \\n        stack<int> st;\\n        for(int i=0;i<s.length();i++)\\n            if(s[i]==\\'(\\')\\n                st.push(0);\\n            else\\n            {\\n                int flag=0;\\n                if(!st.top())\\n                {\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else\\n                {\\n                    while(st.top())\\n                    {\\n                        flag+=st.top();\\n                        st.pop();\\n                    }\\n                st.pop();\\n                st.push(2*flag);\\n                }\\n            }\\n        int result=0;\\n        while(!st.empty())\\n        {\\n            result+=st.top();\\n            st.pop();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219644,
                "title": "c-easy-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        int ans =0;\\n        char prev;\\n        for(auto &e : s){\\n            if(e == \\'(\\') st.push(e);\\n            else{\\n              st.pop();\\n              if(prev == \\'(\\') ans+= pow(2, st.size());               \\n            }\\n            prev = e;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166066,
                "title": "c-simple-implementation-0ms-without-stack",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) \\n    {\\n        int ans = 0, open = 0, idx = 0;\\n                \\n        while(idx < s.length())\\n        {\\n            if(s[idx] == \\'(\\') ++open;\\n            else\\n            {\\n                --open;\\n                if(s[idx-1] == \\'(\\') ans += (1 << open);\\n            }\\n            ++idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134388,
                "title": "python-856-solution",
                "content": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def scoreOfParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if 2 == len(s):\\n            return 1\\n        if 0 == len(s):\\n\\t        return 0\\n        left_count = 0\\n        right_count = 0\\n        for i in range(len(s)): \\n            if s[i] == \\'(\\':\\n\\t\\t        left_count += 1\\n            if s[i] == \\')\\':\\n\\t\\t        right_count += 1\\n\\n            if left_count == right_count:\\n                if left_count > 1:\\n                    return 2*self.scoreOfParentheses(s[1:i]) + self.scoreOfParentheses(s[i+1:])\\n                else:\\n                    return self.scoreOfParentheses(s[:i+1]) + self.scoreOfParentheses(s[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117775,
                "title": "java-2ms-easy-code",
                "content": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }\\n            else{\\n                if(st.peek() == -1){\\n                    st.pop();\\n                    st.push(1);\\n                }\\n                else{\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum += st.pop();\\n                    }\\n                    st.pop();\\n                    st.push(2*sum);\\n                }\\n            }\\n        }\\n        while(st.size()>0){\\n            ans +=st.pop();\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public int scoreOfParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        int ans  = 0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            \\n            if(ch == \\'(\\'){\\n                st.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2092537,
                "title": "intuitive-solution-with-commentary-hope-this-is-helpful",
                "content": "\\n```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\\n\\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```\\n\\nPlease upvote if this was helpful. I\\'d use that as an indicator that it\\'s helping folks and I\\'d try to post more.",
                "solutionTags": [],
                "code": "```\\nExample: ()(()())\\n\\nVisualization :\\n\\tStep 1: [1 ,(1,1)]\\n\\tStep 2: [1, (2)]\\n\\tStep 3: [1, 4]\\n\\tStep 4: [5]\\n\\n```\n```\\nclass Solution {\\n    \\n    public int scoreOfParentheses(String s) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        int ans = 0;\\n        \\n        int i=0;\\n        while(i< s.length()){\\n            char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n                // I\\'m using -1 to represent \\'(\\' in the stack\\n                st.push(-1);\\n            }\\n            else {\\n                if(st.peek() == -1){\\n                    // Solve case:() and push the answer into the stack\\n                    st.pop(); // pop -1 i.e \\'(\\'\\n                    st.push(1);// push the answer\\n                }else{\\n                    // Sum while we do not encounter \\'(\\' \\n                    // End of while loop represents case: ( A+B+C... )\\n                    int sum = 0;\\n                    while(st.peek()!=-1){\\n                        sum+=st.pop();\\n                    }\\n                    \\n                    // Remove the \\'(\\' and multiple by 2 \\n                    // same as 2 * [A+B+C]\\n                    // Push the result into the stack\\n                    st.pop(); // Pop the \\'(\\' in the beginning of case: ( A+B+C... )\\n                    st.push(2*sum); // sum = A+B+C+..\\n                }\\n            }\\n            \\n            i++;\\n        }\\n        \\n        // At the end, stack will have \\n        // a) one element : Case : (()()) : everything is enclosed inside one ()\\n        // b) multiple elements: Case: ()(()())\\n        while(!st.isEmpty()){\\n            ans+=st.pop();\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085095,
                "title": "go-faster-than-100-without-stack",
                "content": "Counting the power of 2 by using bit shift:\\n\\n```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc scoreOfParentheses(s string) int {\\n    var open, result int\\n    var closeLast bool\\n    for _, letter := range s {\\n        if letter == \\'(\\' {\\n            closeLast = false\\n            open++\\n            continue\\n        }\\n        open--\\n        if closeLast {\\n            continue\\n        }\\n        result+= 1 << open\\n        closeLast = true \\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2074800,
                "title": "100-faster-simply-explained",
                "content": "Whenever the incoming character is opening parathesis,-1 will be pushed into stack. if closing is occuring, top element of stack will be checked whether it is -1 ( indicating that the last character was opening paranthesis) or other positive number ( indicating that last character was a closing paranthesis).\\n\\n-1 -> (last char was opening paranthesis) 1 will be pushed in in place of -1 ( indication tha one valid paranthesis) \\npoitiive number other than -1 ->(last char was closing paranthesis) all positive numbers will be added and popped out untill we reach -1 again ( in order to put valid paranthesis value in stack)\\n![image](https://assets.leetcode.com/users/images/d882a64b-d40c-4371-be17-7bb5bf13aabd_1653543491.691877.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int ans=0;\\n        \\n        for(char c: s){\\n            if(c==\\'(\\'){\\n                st.push(-1);        \\n            }else{\\n                if(st.top()==-1){\\n                    st.pop();\\n                    st.push(1);\\n                }else{\\n                    ans=0;\\n                    while(st.top()!=-1){\\n                        ans+=st.top();\\n                        st.pop();\\n                    }\\n                    \\n                    st.pop();\\n                    \\n                    ans*=2;\\n                    st.push(ans);\\n                }\\n            }\\n            \\n        }\\n        \\n        ans=0;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071648,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if i == \"(\":\\n                stack.append(i)\\n                \\n            #checking for this ()\\n            elif stack[-1] == \"(\" and i == \")\":\\n                stack.pop()\\n                stack.append(1)\\n                \\n            else:\\n                \\n                #until did not found open parentheses adding the numbers\\n                count = 0\\n                while stack[-1] != \"(\":\\n                    count += stack.pop()\\n                if(stack[-1] == \"(\"):\\n                    stack.pop()\\n                    stack.append(count*2)\\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870460,
                "title": "java-0ms-submission-with-o-1-space",
                "content": "Basically when you open a bracket, you times the base with 2, when you close the bracket, you devided by 2. You only settle up the score when you meet a `()` i.e. (when `s.charAt(i) == \\')\\' && s.charAt(i-1) == \\'(\\'`.\\n```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int res = 0, base = 1;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                base *= 2;\\n            }\\n            else {\\n                base /= 2;\\n                if (s.charAt(i-1) == \\'(\\') {\\n                    res += base;\\n                }   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861572,
                "title": "c-clear-solution-o-n-time-o-1-space",
                "content": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int ScoreOfParentheses(string s) {\\n\\t\\tvar result = 0;\\n        var level = 0;\\n        for (int i=0; i<s.Length; i++) {\\n            if (s[i] == \\'(\\')\\n                level++;\\n            if (s[i] == \\')\\') {\\n                level--;\\n                result += s[i-1] == \\'(\\' ? 1 << level : 0;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859699,
                "title": "easy-cpp-based-solution-0ms",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        stack<int>s1;\\n        int n=0;\\n        int sum=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                s1.push(sum);\\n                sum=0;\\n            }\\n            else if(s[i]==\\')\\')\\n            {\\n                sum=s1.top() + max(2*sum,1);\\n                s1.pop();\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1859042,
                "title": "rust-0ms-2mb",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Score of Parentheses.\\nMemory Usage: 2 MB, less than 100.00% of Rust online submissions for Score of Parentheses.\\n\\n```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn score_of_parentheses(s: String) -> i32 {\\n        let mut stack = vec![0];\\n        for ch in s.chars() { \\n            match ch  { \\n                \\'(\\' => stack.push(0),\\n                _ => { \\n                    let v = stack.pop().unwrap();\\n                    *stack.last_mut().unwrap() += i32::max(2 * v, 1)\\n                }\\n            }\\n        }\\n        stack.pop().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1858745,
                "title": "python-o-n-approach-stack-simple-and-easy",
                "content": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def scoreOfParentheses(self, s: str) -> int:\\n        stack, ans = [0], 0\\n        for i in range(len(s)):\\n            if s[i] == \\')\\':\\n                curr = stack.pop()\\n                if curr == 0: ans = 1\\n                else: ans = 2*curr\\n                stack[-1] += ans\\n            else:\\n                stack.append(0)\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858447,
                "title": "this-easy-code-is-not-mentioned-anywhere",
                "content": "Just push the character until you are getting \\'(\\' and when you iterator pointing to the closing braces \\')\\', then you have to check the stack size, if the stack size is 1, then ans++. Why.? For this type of cases \\'()\\', If stack size is greater than 1, than you just need to add the power of 2 raise to the stack.size()-1. \\nYou get the answer....!!!\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        stack<char> st;\\n        int i = 0;\\n        int n = s.length();\\n        \\n        while(i<n){\\n            while(i <n && s[i] == \\'(\\'){\\n                st.push(s[i]);\\n                i++;\\n            }\\n            if(st.size() > 1){\\n                int sz = st.size();\\n                sz--;\\n                ans += (int)(pow(2, sz) + 1e-9);\\n            }\\n            else if(st.size() == 1){\\n                ans++;\\n            }\\n            while(i<n && s[i] == \\')\\'){\\n                st.pop();\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858440,
                "title": "both-s-n-s-1-easiest-way-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(N) && S(N)  \\n//     int scoreOfParentheses(string str) {\\n//         int ans=0;\\n//         stack<int> s;\\n//         for(auto it:str)\\n//             if(it==\\'(\\')\\n//                 s.push(ans),ans=0;\\n//             else\\n//                 ans=s.top()+max(2*ans,1),s.pop();\\n            \\n\\n//         return ans;\\n//     }\\n    \\n    //O(N) && S(1)\\n    int scoreOfParentheses(string str) {\\n        int ans=0;\\n        int score=1;\\n        int f=1;\\n        for(auto it:str)\\n            if(it==\\'(\\')\\n                score*=2,f=1;\\n            else{\\n                score/=2;\\n                if(f){\\n                    f=0;\\n                    ans+=score;\\n                }\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858355,
                "title": "c-solution-0ms-time-using-stack-brief-explanation",
                "content": "Here\\'s my C++ Solution using Stack ( 0ms time taken, 100% faster )-\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int ans = 0;\\n        int n = s.size();\\n        stack<int> st;\\n        \\n        /* An Extra value to get final answer starting as 0 */\\n        st.push(0);\\n\\n        for(auto it:s){\\n            /* Simply add 0 in cases of opening braces */\\n            if(it==\\'(\\'){\\n                st.push(0);\\n            }\\n            \\n            /* start manipulating values when getting closing braces */\\n            else{\\n                /* Got the top of the Stack and removed it*/\\n                int k = st.top();\\n                st.pop();\\n                \\n                /* If the top was storing 0 that indicates this was first pair of opening and closing   braces, In this case just increase value by 1 */\\n                if(k== 0) k = k=1;\\n                \\n                /* If the value of top was greater than 0 that indicates inner pairs of so we\\'ll increase value by 2 */\\n                else k *= 2;\\n                \\n                /* This value will be added to the next top element to contribute in final answer */\\n                st.top()+=k;\\n            }\\n            \\n        }\\n       \\n        // Our extra 0 stored in the starting now actually contains the final answer\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858298,
                "title": "c-faster-than-100-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<char> st;\\n        vector<int> dp(26,0);\\n        for(int i=0;i<s.length();i++) {\\n            if(s[i] == \\'(\\') {\\n                st.push(\\'(\\');\\n            } else {\\n                int idx = st.size();\\n                if(dp[idx] == 0)\\n                    dp[idx-1] += 1;\\n                else {\\n                    dp[idx-1] += 2*dp[idx];\\n                    dp[idx] = 0;\\n                }\\n                st.pop();\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858222,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }\\n            else\\n            {\\n                if(s.top()==-1)\\n                {\\n                    s.pop();\\n                    s.push(1);\\n                }\\n                else\\n                {\\n                    int x = s.top();\\n                    s.pop();\\n                    if(!s.empty() and s.top()<0)\\n                    {\\n                        s.pop();\\n                    }\\n                    s.push(x*2);\\n                }\\n            }\\n            int y=0;\\n            while(!s.empty() and s.top()>0)\\n            {\\n               y += s.top();\\n                s.pop();\\n            }\\n            if(y)\\n                s.push(y);\\n        }\\n        return s.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string str) {\\n        \\n        int n = str.length();\\n        \\n        stack<int>s;\\n         \\n        for(int i=0;i<n;i++)\\n        {\\n            if(str[i]==\\'(\\')\\n            {\\n                s.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858111,
                "title": "simple-c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }else{\\n                if(stk.top()==-1){\\n                    stk.pop();\\n                    stk.push(1);\\n                }else{\\n                    int val=0;\\n                    while(stk.top()!=-1){\\n                        val+=stk.top();stk.pop();\\n                    }\\n                    stk.pop();\\n                    stk.push(2*val);\\n                }\\n            }\\n        }\\n        int val=0;\\n        while(stk.size()>0){\\n            val+=stk.top();stk.pop();\\n        }\\n        return val;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int>stk;\\n        for(auto x:s){\\n            if(x==\\'(\\'){\\n                stk.push(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1858043,
                "title": "100-faster-time-o-n-space-o-n",
                "content": "***Upvote if you like it*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        stack<int> st;\\n        int res = 0;\\n        int count = 0;\\n        \\n        for(int i = 0 ; i < s.length() ; i++){\\n            if(s[i] == \\'(\\'){\\n                st.push(0);\\n            }\\n            else{\\n                while(!st.empty() && st.top() != 0){\\n                    count += st.top(); // To calculate the inner brackets\\n                    st.pop();\\n                }\\n                count = max(2 * count , 1); // If () is the case\\n                st.pop();\\n                st.push(count);\\n                count = 0;\\n            }\\n        }\\n        \\n        while(!st.empty()){\\n            res += st.top();\\n            st.pop();\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858004,
                "title": "runtime-0ms-o-1-space-no-stack-used-java-100-faster-self-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }\\n            else{\\n                if(wasOpen) sum += two;\\n                wasOpen = false;\\n                two = two/2;\\n            }\\n        }\\n    return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int scoreOfParentheses(String s) {\\n        int two = 0;\\n        int sum = 0;\\n        boolean wasOpen = true;\\n        for(int i = 0; i< s.length(); i++){\\n           char ch = s.charAt(i);\\n            if(ch == \\'(\\'){\\n              if(two == 0) two = 1;\\n                else two *= 2;\\n                wasOpen = true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1857975,
                "title": "o-1-counting-open-paranthesis",
                "content": "We just find out the number of open paranthesis. There are only two cases:\\n1. `()` (paranthesis with no content inside) will contribute to answer by +1. for eg. ()()() = 3;\\n2.  `(()....())` (paranthesis with content inside) will contribute to answer by multiplying by 2;\\nThe depth of paranthesis will decide the power of 2 and the (inner) paranthesis with no content i.e. `s[i-1] == \\'(\\'` will contribute only and the outers will decide the power of 2.\\n\\ncode:\\n\\n```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n        int opens = 0;\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); ++i)\\n        {\\n            char c = s[i];\\n            if (c == \\'(\\') \\n            {\\n                opens++;\\n            } else {\\n                if (s[i-1] == \\'(\\') ans += pow(2, opens-1);  // only applied for solo and the inner ones;\\n                opens--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857925,
                "title": "easy-c-solution-o-1-space-complexity-o-n-time-complexity-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int scoreOfParentheses(string s) {\\n     int st = 0, score = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st++;\\n            }\\n            else if(s[i]==\\')\\' && s[i-1]==\\'(\\'){\\n               st--;\\n                score+=1<<st;\\n            }\\n            else st--;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857884,
                "title": "c-no-stack-100-99-9",
                "content": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nWe keep track of the current depth with the \"two\" variable which we can calculate each time by doubling or halving the value.",
                "solutionTags": [],
                "code": "```\\nint scoreOfParentheses(string s) {\\n        int ans = 0,two=1;\\n        for(int ind = 0;ind<s.size();ind++){\\n            if(s[ind]==\\'(\\'){\\n                two+=two;\\n            }\\n            else{\\n                two/=2;\\n                if(s[ind-1]==\\'(\\'){\\n                    ans+=two;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1797276,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1567739,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1953309,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 1978296,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            },
            {
                "id": 2000809,
                "content": [
                    {
                        "username": "djslim",
                        "content": "It\\'s marked as stack but dfs approach is way easier"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/score-of-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Divide and Conquer\n\n  \n**Approach 2:** Stack\n\n  \n**Approach 3:** Count Cores\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "user6982nz",
                        "content": "What does \"AB\" has score of A + B mean?"
                    },
                    {
                        "username": "umangkumarchaudhary",
                        "content": "Rule is saying that \\nAB has score A + B, where A and B are balanced parentheses strings.\\nit means A = ( ) and B = ( )\\nif any string contains parenthesis like this ( )( ) then it will score will A + B which is eqaul to 2.\\ni hope it would be helpful for you."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I don\\'t think the description is explained well... why is the output expected to be 6 instead of 8 when s = \"(()(()))\"?"
                    },
                    {
                        "username": "manavsarkar07",
                        "content": "bcz () = 1, so (()) = 2 and AB = A+B\\nHere ()(()) = 1 + 2 = 3\\nFinally (()(())) = 3*2 = 6"
                    },
                    {
                        "username": "M1nex",
                        "content": "s =\"(()(()))\"\\nOutput\\n4\\nExpected\\n6\\n-_-"
                    },
                    {
                        "username": "maximepierre",
                        "content": "2*(1+2) = 6"
                    }
                ]
            }
        ]
    }
]